{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMzOTc5MDY2", "number": 24057, "reviewThreads": {"totalCount": 45, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QxMTozMjoyMFrOEFP62w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNToxMDoxMlrOEPLO9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTM5MTYzOnYy", "diffSide": "RIGHT", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/JSONParser.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QxMTozMjoyMFrOGjXHjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxODozNjoxMlrOGj-DnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTczMjEwOA==", "bodyText": "I don't think this is where we should change. IMO we should do something like https://github.com/ballerina-platform/ballerina-lang/blob/master/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/JSONParser.java#L64 because\n\nthere may be other non-array member string values that will not get changed to BString if we change only here.\n\nFor example, the following might fail\npublic function main() {\n    string st = \"\\\"hello\\\"\";\n    string j = <string> st.fromJsonString();\n}\n\nOn paths where changeForBString is already called and there are arrays present we'll be calling this method twice unnecessarily.\n\ne.g., \n  \n    \n      ballerina-lang/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/JSONParser.java\n    \n    \n         Line 95\n      in\n      8077e15\n    \n    \n    \n    \n\n        \n          \n           return changeForBString(jsonObj);", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r439732108", "createdAt": "2020-06-13T11:32:20Z", "author": {"login": "MaryamZi"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/JSONParser.java", "diffHunk": "@@ -687,7 +687,7 @@ public State transition(StateMachine sm, char[] buff, int i, int count) throws J\n                     ch = buff[i];\n                     sm.processLocation(ch);\n                     if (ch == sm.currentQuoteChar) {\n-                        ((ArrayValue) sm.currentJsonNode).append(sm.value());\n+                        ((ArrayValue) sm.currentJsonNode).append(changeForBString(sm.value()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8077e15459944ea37f0c4a73d99bad2da6fe288f"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3MDA3Ng==", "bodyText": "Got it. Solved", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440370076", "createdAt": "2020-06-15T18:36:12Z", "author": {"login": "dulajdilshan"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/JSONParser.java", "diffHunk": "@@ -687,7 +687,7 @@ public State transition(StateMachine sm, char[] buff, int i, int count) throws J\n                     ch = buff[i];\n                     sm.processLocation(ch);\n                     if (ch == sm.currentQuoteChar) {\n-                        ((ArrayValue) sm.currentJsonNode).append(sm.value());\n+                        ((ArrayValue) sm.currentJsonNode).append(changeForBString(sm.value()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTczMjEwOA=="}, "originalCommit": {"oid": "8077e15459944ea37f0c4a73d99bad2da6fe288f"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTM5NjI5OnYy", "diffSide": "LEFT", "path": "langlib/lang.value/src/main/ballerina/src/lang.value/value.bal", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QxMTo0Mjo1NFrOGjXJ-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNFQxNjowOTo0MVrOGjd-5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTczMjcyOQ==", "bodyText": "Noticed some minor punctuation differences in the descriptions here and in the spec, shall we recheck and have the same as the ones in the spec for these functions?\nLet's also maintain the same order.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r439732729", "createdAt": "2020-06-13T11:42:54Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/ballerina/src/lang.value/value.bal", "diffHunk": "@@ -117,9 +117,26 @@ public function toString((any|error) v) returns string = external;\n \n # Returns the string that represents `v` in JSON format.\n #\n-# + v - json value", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8077e15459944ea37f0c4a73d99bad2da6fe288f"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0MzQzMA==", "bodyText": "In here the spec is wrong right ? toJsonString() should allow for anydata. Shouldn't we correct them here?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r439843430", "createdAt": "2020-06-14T15:55:55Z", "author": {"login": "dulajdilshan"}, "path": "langlib/lang.value/src/main/ballerina/src/lang.value/value.bal", "diffHunk": "@@ -117,9 +117,26 @@ public function toString((any|error) v) returns string = external;\n \n # Returns the string that represents `v` in JSON format.\n #\n-# + v - json value", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTczMjcyOQ=="}, "originalCommit": {"oid": "8077e15459944ea37f0c4a73d99bad2da6fe288f"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0NDU0Mw==", "bodyText": "Shall we create an issue in the spec repo for this?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r439844543", "createdAt": "2020-06-14T16:08:54Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/ballerina/src/lang.value/value.bal", "diffHunk": "@@ -117,9 +117,26 @@ public function toString((any|error) v) returns string = external;\n \n # Returns the string that represents `v` in JSON format.\n #\n-# + v - json value", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTczMjcyOQ=="}, "originalCommit": {"oid": "8077e15459944ea37f0c4a73d99bad2da6fe288f"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0NDU4MQ==", "bodyText": "Sure I'll create", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r439844581", "createdAt": "2020-06-14T16:09:41Z", "author": {"login": "dulajdilshan"}, "path": "langlib/lang.value/src/main/ballerina/src/lang.value/value.bal", "diffHunk": "@@ -117,9 +117,26 @@ public function toString((any|error) v) returns string = external;\n \n # Returns the string that represents `v` in JSON format.\n #\n-# + v - json value", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTczMjcyOQ=="}, "originalCommit": {"oid": "8077e15459944ea37f0c4a73d99bad2da6fe288f"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTQ0ODY4OnYy", "diffSide": "RIGHT", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QxMzozMDowOFrOGjXkhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNToxNDo1M1rOGkLhSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTczOTUyNA==", "bodyText": "Please check the following example.\npublic function main() {\n    map<int> m = {a: 1, b: 2};\n    map<json> mj = <map<json>> m.toJson();\n\n    mj[\"c\"] = \"non-int json\";\n}\nThis currently fails with\n$ ballerina run xyz.bal\nCompiling source\n        xyz.bal\nRunning executables\n\nerror: {ballerina/lang.map}InherentTypeViolation message=invalid map insertion: expected value of type 'int', found 'string'\n        at xyz:main(xyz.bal:5)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r439739524", "createdAt": "2020-06-13T13:30:08Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.JSON),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        BType sourceType = TypeChecker.getType(value);\n+        BType targetJsonType = BTypes.typeJSON;\n+        if (!TypeChecker.checkIsLikeType(value, targetJsonType, true)) {\n+            if (sourceType.getTag() >= TypeTags.XML_ELEMENT_TAG || sourceType.getTag() == TypeTags.XML_TAG) {\n+                return ToString.toString(strand, value);\n+            } else {\n+                throw createConversionError(value, targetJsonType);\n+            }\n+        }\n+\n+        // handle primitive values\n+        if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+            if (TypeChecker.checkIsType(value, targetJsonType)) {\n+                return value;\n+            } else {\n+                // Has to be a numeric conversion.\n+                return TypeConverter.convertValues(targetJsonType, value);\n+            }\n+        }\n+\n+        return convert((RefValue) value, targetJsonType, new ArrayList<>(), strand);\n+    }\n+\n+    private static Object convert(RefValue value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  Strand strand) {\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, value.getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        Object newValue;\n+        switch (value.getType().getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, targetType, unresolvedValues, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, targetType, unresolvedValues, strand);\n+                break;\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+            case TypeTags.ERROR_TAG:\n+                newValue = value.copy(new HashMap<>());\n+                break;\n+            default:\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  boolean allowAmbiguity, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+        List<BType> convertibleTypes;\n+        convertibleTypes = TypeConverter.getConvertibleTypes(value, targetType);\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (!allowAmbiguity && convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType sourceType = TypeChecker.getType(value);\n+        BType matchingType = convertibleTypes.get(0);\n+        // handle primitive values\n+        if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+            if (TypeChecker.checkIsType(value, matchingType)) {\n+                return value;\n+            } else {\n+                // Has to be a numeric conversion.\n+                return TypeConverter.convertValues(matchingType, value);\n+            }\n+        }\n+\n+        return convert((RefValue) value, matchingType, unresolvedValues, strand);\n+    }\n+\n+    private static Object convertMapToJson(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                           Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();\n+                    putToMap(newMap, entry, constraintType, unresolvedValues, strand);\n+                }\n+                return newMap;\n+            case TypeTags.JSON_TAG:\n+                BType matchingType = TypeConverter.resolveMatchingTypeForUnion(map, targetType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8077e15459944ea37f0c4a73d99bad2da6fe288f"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU5MDY2NQ==", "bodyText": "Solved", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440590665", "createdAt": "2020-06-16T05:14:53Z", "author": {"login": "dulajdilshan"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.JSON),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        BType sourceType = TypeChecker.getType(value);\n+        BType targetJsonType = BTypes.typeJSON;\n+        if (!TypeChecker.checkIsLikeType(value, targetJsonType, true)) {\n+            if (sourceType.getTag() >= TypeTags.XML_ELEMENT_TAG || sourceType.getTag() == TypeTags.XML_TAG) {\n+                return ToString.toString(strand, value);\n+            } else {\n+                throw createConversionError(value, targetJsonType);\n+            }\n+        }\n+\n+        // handle primitive values\n+        if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+            if (TypeChecker.checkIsType(value, targetJsonType)) {\n+                return value;\n+            } else {\n+                // Has to be a numeric conversion.\n+                return TypeConverter.convertValues(targetJsonType, value);\n+            }\n+        }\n+\n+        return convert((RefValue) value, targetJsonType, new ArrayList<>(), strand);\n+    }\n+\n+    private static Object convert(RefValue value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  Strand strand) {\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, value.getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        Object newValue;\n+        switch (value.getType().getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, targetType, unresolvedValues, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, targetType, unresolvedValues, strand);\n+                break;\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+            case TypeTags.ERROR_TAG:\n+                newValue = value.copy(new HashMap<>());\n+                break;\n+            default:\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  boolean allowAmbiguity, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+        List<BType> convertibleTypes;\n+        convertibleTypes = TypeConverter.getConvertibleTypes(value, targetType);\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (!allowAmbiguity && convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType sourceType = TypeChecker.getType(value);\n+        BType matchingType = convertibleTypes.get(0);\n+        // handle primitive values\n+        if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+            if (TypeChecker.checkIsType(value, matchingType)) {\n+                return value;\n+            } else {\n+                // Has to be a numeric conversion.\n+                return TypeConverter.convertValues(matchingType, value);\n+            }\n+        }\n+\n+        return convert((RefValue) value, matchingType, unresolvedValues, strand);\n+    }\n+\n+    private static Object convertMapToJson(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                           Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();\n+                    putToMap(newMap, entry, constraintType, unresolvedValues, strand);\n+                }\n+                return newMap;\n+            case TypeTags.JSON_TAG:\n+                BType matchingType = TypeConverter.resolveMatchingTypeForUnion(map, targetType);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTczOTUyNA=="}, "originalCommit": {"oid": "8077e15459944ea37f0c4a73d99bad2da6fe288f"}, "originalPosition": 189}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTQ4ODc3OnYy", "diffSide": "RIGHT", "path": "langlib/lang.value/src/main/ballerina/src/lang.value/value.bal", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QxNDo0OTo0MFrOGjX4rQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNzoyODoyNlrOGj703g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc0NDY4NQ==", "bodyText": "This PR doesn't add .toJson() support for tables right?\nThe following fails at runtime\ntype Foo record {|\n    int id;\n    string str;\n|};\n\npublic function main() {\n    table<Foo> tb = table [\n        {id: 12, str: \"abc\"},\n        {id: 34, str: \"def\"}\n    ];\n\n    json j = tb.toJson();\n}\nballerina run xyz.bal\nCompiling source\n        xyz.bal\nRunning executables\n\nerror: {ballerina/lang.typedesc}ConversionError message='table<Foo>' value cannot be converted to 'json'\n        at ballerina.lang_value.1_0_0:toJson(value.bal:139)\n           xyz:main(xyz.bal:12)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r439744685", "createdAt": "2020-06-13T14:49:40Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/ballerina/src/lang.value/value.bal", "diffHunk": "@@ -117,9 +117,26 @@ public function toString((any|error) v) returns string = external;\n \n # Returns the string that represents `v` in JSON format.\n #\n-# + v - json value\n+# + v - anydata value\n # + return - string representation of json\n-public function toJsonString(json v) returns string = external;\n+public function toJsonString(anydata v) returns string = external;\n+\n+# Converts a value of type `anydata` to `json`.\n+# This does a deep copy of `v` converting values that do\n+# not belong to json into values that do.\n+# A value of type `xml` is converted into a string as if\n+# by the `toString` function.\n+# A value of type `table` is converted into a list of\n+# mappings one for each row.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8077e15459944ea37f0c4a73d99bad2da6fe288f"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMzMzUzNA==", "bodyText": "Solved", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440333534", "createdAt": "2020-06-15T17:28:26Z", "author": {"login": "dulajdilshan"}, "path": "langlib/lang.value/src/main/ballerina/src/lang.value/value.bal", "diffHunk": "@@ -117,9 +117,26 @@ public function toString((any|error) v) returns string = external;\n \n # Returns the string that represents `v` in JSON format.\n #\n-# + v - json value\n+# + v - anydata value\n # + return - string representation of json\n-public function toJsonString(json v) returns string = external;\n+public function toJsonString(anydata v) returns string = external;\n+\n+# Converts a value of type `anydata` to `json`.\n+# This does a deep copy of `v` converting values that do\n+# not belong to json into values that do.\n+# A value of type `xml` is converted into a string as if\n+# by the `toString` function.\n+# A value of type `table` is converted into a list of\n+# mappings one for each row.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc0NDY4NQ=="}, "originalCommit": {"oid": "8077e15459944ea37f0c4a73d99bad2da6fe288f"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTUwNDMyOnYy", "diffSide": "RIGHT", "path": "langlib/lang.value/src/main/ballerina/src/lang.value/value.bal", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QxNToyMDo0MFrOGjYAkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxMzoyMTozNlrOGjx4Xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc0NjcwNQ==", "bodyText": "XML conversion doesn't seem to work when its in a map?\npublic function main() {\n    xml x = xml `<foo><bar/>Hello World</foo>`;\n    json j1 = x.toJson(); // WORKS\n\n    map<anydata> m1 = {a: 1, b: \"str\"};\n    json j2 = m1.toJson(); // WORKS\n\n    map<anydata> m2 = {a: 1, b: x};\n    json j3 = m2.toJson(); // ERROR - error: {ballerina/lang.typedesc}ConversionError \n                        // message='map<anydata>' value cannot be converted to 'json'\n}", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r439746705", "createdAt": "2020-06-13T15:20:40Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/ballerina/src/lang.value/value.bal", "diffHunk": "@@ -117,9 +117,26 @@ public function toString((any|error) v) returns string = external;\n \n # Returns the string that represents `v` in JSON format.\n #\n-# + v - json value\n+# + v - anydata value\n # + return - string representation of json\n-public function toJsonString(json v) returns string = external;\n+public function toJsonString(anydata v) returns string = external;\n+\n+# Converts a value of type `anydata` to `json`.\n+# This does a deep copy of `v` converting values that do\n+# not belong to json into values that do.\n+# A value of type `xml` is converted into a string as if", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8077e15459944ea37f0c4a73d99bad2da6fe288f"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE3MDU5MA==", "bodyText": "Solved", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440170590", "createdAt": "2020-06-15T13:21:36Z", "author": {"login": "dulajdilshan"}, "path": "langlib/lang.value/src/main/ballerina/src/lang.value/value.bal", "diffHunk": "@@ -117,9 +117,26 @@ public function toString((any|error) v) returns string = external;\n \n # Returns the string that represents `v` in JSON format.\n #\n-# + v - json value\n+# + v - anydata value\n # + return - string representation of json\n-public function toJsonString(json v) returns string = external;\n+public function toJsonString(anydata v) returns string = external;\n+\n+# Converts a value of type `anydata` to `json`.\n+# This does a deep copy of `v` converting values that do\n+# not belong to json into values that do.\n+# A value of type `xml` is converted into a string as if", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc0NjcwNQ=="}, "originalCommit": {"oid": "8077e15459944ea37f0c4a73d99bad2da6fe288f"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTYwODY0OnYy", "diffSide": "RIGHT", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonStringWithType.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QxODo0ODowNFrOGjY14Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNToxNDozOFrOGkLhAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2MDM1Mw==", "bodyText": "Double check this error message format. AFAIK, the convention is to prefix the reason with the module. But I can see that some of the lang.value functions have used this format. Let's check with the others and verify.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r439760353", "createdAt": "2020-06-13T18:48:04Z", "author": {"login": "pubudu91"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonStringWithType.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.JSONParser;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.io.Reader;\n+import java.io.StringReader;\n+\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ * Converts a string in JSON format to a user-specified type.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonStringWithType\",\n+        args = {\n+                @Argument(name = \"str\", type = TypeKind.STRING),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonStringWithType {\n+\n+    public static Object fromJsonStringWithType(Strand strand, BString value, TypedescValue t) {\n+\n+        String str = value.getValue();\n+        if (str.equals(\"null\")) {\n+            return null;\n+        }\n+        Reader reader = new StringReader(str);\n+        try {\n+            Object jsonFromString = JSONParser.parse(reader);\n+            return FromJsonWithType.fromJsonWithType(strand, jsonFromString, t);\n+        } catch (BallerinaException e) {\n+            return BallerinaErrors.createError(\"{ballerina}FromJsonStringWithTypeError\", e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8077e15459944ea37f0c4a73d99bad2da6fe288f"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU5MDU5NQ==", "bodyText": "Ack", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440590595", "createdAt": "2020-06-16T05:14:38Z", "author": {"login": "dulajdilshan"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonStringWithType.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.JSONParser;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.io.Reader;\n+import java.io.StringReader;\n+\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ * Converts a string in JSON format to a user-specified type.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonStringWithType\",\n+        args = {\n+                @Argument(name = \"str\", type = TypeKind.STRING),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonStringWithType {\n+\n+    public static Object fromJsonStringWithType(Strand strand, BString value, TypedescValue t) {\n+\n+        String str = value.getValue();\n+        if (str.equals(\"null\")) {\n+            return null;\n+        }\n+        Reader reader = new StringReader(str);\n+        try {\n+            Object jsonFromString = JSONParser.parse(reader);\n+            return FromJsonWithType.fromJsonWithType(strand, jsonFromString, t);\n+        } catch (BallerinaException e) {\n+            return BallerinaErrors.createError(\"{ballerina}FromJsonStringWithTypeError\", e.getMessage());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2MDM1Mw=="}, "originalCommit": {"oid": "8077e15459944ea37f0c4a73d99bad2da6fe288f"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NDAzNDg0OnYy", "diffSide": "RIGHT", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMDo0OTo0MlrOGkCPJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNTo1NjowMVrOGkMOwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzODU2Ng==", "bodyText": "Why are we trying to convert it to an XML value if there aren't any convertible types? Consider the following example,\nimport ballerina/io;\n\npublic function main() {\n    string foo = \"Foo\";\n    var v = foo.fromJsonWithType(int);\n    io:println(v);\n}\nThe above fails with the following panic:\nerror {ballerina/lang.typedesc}ConversionError message='string' value cannot be converted to 'int': failed to parse xml: Unexpected character 'F' (code 70) in prolog; expected '<'\n at [row,col {unknown-source}]: [1,1]\n\nIt says string value cannot be converted to int but then has an XML parsing error as well.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440438566", "createdAt": "2020-06-15T20:49:42Z", "author": {"login": "pubudu91"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        // typedesc<json>.constructFrom like usage\n+        if (describingType.getTag() == TypeTags.TYPEDESC_TAG) {\n+            return convert(((BTypedescType) t.getDescribingType()).getConstraint(), v, t, strand);\n+        }\n+        // json.constructFrom like usage\n+        return convert(describingType, v, t, strand);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue) {\n+        return convert(convertType, inputValue, null, null);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue, TypedescValue t, Strand strand) {\n+        try {\n+            return convert(inputValue, convertType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+        return convert(value, targetType, unresolvedValues, false, t, strand);\n+    }\n+\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  boolean allowAmbiguity, TypedescValue t, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+        List<BType> convertibleTypes;\n+        convertibleTypes = TypeConverter.getConvertibleTypes(value, targetType);\n+        if (convertibleTypes.isEmpty()) {\n+            if (TypeChecker.getType(value).getTag() == TypeTags.STRING_TAG) {\n+                try {\n+                    return XMLFactory.parse(((StringValue) value).getValue());\n+                } catch (Throwable e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1801ce4a280eb6c65f11988f2a0adb5b56788a7e"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU5NzYwNQ==", "bodyText": "The spec says that fromJsonWithType should do the inverse of the toJson which converts xml into a  string.\nSo, fromJsonWithType should be able to convert an appropriate string to an xml.\nChanging the behaviour of TypeConverter.getConvertibleTypes() to support this would also work, but will affect cloneWithType method and future methods to be implemented (if there are)\nI'll fix showing xml conversion error", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440597605", "createdAt": "2020-06-16T05:39:59Z", "author": {"login": "dulajdilshan"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        // typedesc<json>.constructFrom like usage\n+        if (describingType.getTag() == TypeTags.TYPEDESC_TAG) {\n+            return convert(((BTypedescType) t.getDescribingType()).getConstraint(), v, t, strand);\n+        }\n+        // json.constructFrom like usage\n+        return convert(describingType, v, t, strand);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue) {\n+        return convert(convertType, inputValue, null, null);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue, TypedescValue t, Strand strand) {\n+        try {\n+            return convert(inputValue, convertType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+        return convert(value, targetType, unresolvedValues, false, t, strand);\n+    }\n+\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  boolean allowAmbiguity, TypedescValue t, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+        List<BType> convertibleTypes;\n+        convertibleTypes = TypeConverter.getConvertibleTypes(value, targetType);\n+        if (convertibleTypes.isEmpty()) {\n+            if (TypeChecker.getType(value).getTag() == TypeTags.STRING_TAG) {\n+                try {\n+                    return XMLFactory.parse(((StringValue) value).getValue());\n+                } catch (Throwable e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzODU2Ng=="}, "originalCommit": {"oid": "1801ce4a280eb6c65f11988f2a0adb5b56788a7e"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU5OTM1Mw==", "bodyText": "Yeah, it doesn't make sense to try and convert to XML if I didn't specify an XML typedesc", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440599353", "createdAt": "2020-06-16T05:46:05Z", "author": {"login": "pubudu91"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        // typedesc<json>.constructFrom like usage\n+        if (describingType.getTag() == TypeTags.TYPEDESC_TAG) {\n+            return convert(((BTypedescType) t.getDescribingType()).getConstraint(), v, t, strand);\n+        }\n+        // json.constructFrom like usage\n+        return convert(describingType, v, t, strand);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue) {\n+        return convert(convertType, inputValue, null, null);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue, TypedescValue t, Strand strand) {\n+        try {\n+            return convert(inputValue, convertType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+        return convert(value, targetType, unresolvedValues, false, t, strand);\n+    }\n+\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  boolean allowAmbiguity, TypedescValue t, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+        List<BType> convertibleTypes;\n+        convertibleTypes = TypeConverter.getConvertibleTypes(value, targetType);\n+        if (convertibleTypes.isEmpty()) {\n+            if (TypeChecker.getType(value).getTag() == TypeTags.STRING_TAG) {\n+                try {\n+                    return XMLFactory.parse(((StringValue) value).getValue());\n+                } catch (Throwable e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzODU2Ng=="}, "originalCommit": {"oid": "1801ce4a280eb6c65f11988f2a0adb5b56788a7e"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwMjMwNA==", "bodyText": "Yeah. Thanks!", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440602304", "createdAt": "2020-06-16T05:56:01Z", "author": {"login": "dulajdilshan"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        // typedesc<json>.constructFrom like usage\n+        if (describingType.getTag() == TypeTags.TYPEDESC_TAG) {\n+            return convert(((BTypedescType) t.getDescribingType()).getConstraint(), v, t, strand);\n+        }\n+        // json.constructFrom like usage\n+        return convert(describingType, v, t, strand);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue) {\n+        return convert(convertType, inputValue, null, null);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue, TypedescValue t, Strand strand) {\n+        try {\n+            return convert(inputValue, convertType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+        return convert(value, targetType, unresolvedValues, false, t, strand);\n+    }\n+\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  boolean allowAmbiguity, TypedescValue t, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+        List<BType> convertibleTypes;\n+        convertibleTypes = TypeConverter.getConvertibleTypes(value, targetType);\n+        if (convertibleTypes.isEmpty()) {\n+            if (TypeChecker.getType(value).getTag() == TypeTags.STRING_TAG) {\n+                try {\n+                    return XMLFactory.parse(((StringValue) value).getValue());\n+                } catch (Throwable e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzODU2Ng=="}, "originalCommit": {"oid": "1801ce4a280eb6c65f11988f2a0adb5b56788a7e"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NTExNzE1OnYy", "diffSide": "RIGHT", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNjoxMjozN1rOGkMkWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNjoyMjoyMFrOGkMy3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwNzgzMg==", "bodyText": "Shall we add an upper bound for the subtypes as well for the following? If we add another anydata type, this will break.\ntargetType.getTag() >= TypeTags.XML_ELEMENT_TAG", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440607832", "createdAt": "2020-06-16T06:12:37Z", "author": {"login": "pubudu91"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        // typedesc<json>.constructFrom like usage\n+        if (describingType.getTag() == TypeTags.TYPEDESC_TAG) {\n+            return convert(((BTypedescType) t.getDescribingType()).getConstraint(), v, t, strand);\n+        }\n+        // json.constructFrom like usage\n+        return convert(describingType, v, t, strand);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue) {\n+        return convert(convertType, inputValue, null, null);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue, TypedescValue t, Strand strand) {\n+        try {\n+            return convert(inputValue, convertType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+        return convert(value, targetType, unresolvedValues, false, t, strand);\n+    }\n+\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  boolean allowAmbiguity, TypedescValue t, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+        List<BType> convertibleTypes;\n+        convertibleTypes = TypeConverter.getConvertibleTypes(value, targetType);\n+        if (convertibleTypes.isEmpty()) {\n+            if (TypeChecker.getType(value).getTag() == TypeTags.STRING_TAG &&\n+                    (targetType.getTag() >= TypeTags.XML_ELEMENT_TAG || targetType.getTag() == TypeTags.XML_TAG)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f7f31f56391c00bca0e631d0db24e25c803ff64"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYxMTU0OA==", "bodyText": "okay", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440611548", "createdAt": "2020-06-16T06:22:20Z", "author": {"login": "dulajdilshan"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        // typedesc<json>.constructFrom like usage\n+        if (describingType.getTag() == TypeTags.TYPEDESC_TAG) {\n+            return convert(((BTypedescType) t.getDescribingType()).getConstraint(), v, t, strand);\n+        }\n+        // json.constructFrom like usage\n+        return convert(describingType, v, t, strand);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue) {\n+        return convert(convertType, inputValue, null, null);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue, TypedescValue t, Strand strand) {\n+        try {\n+            return convert(inputValue, convertType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+        return convert(value, targetType, unresolvedValues, false, t, strand);\n+    }\n+\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  boolean allowAmbiguity, TypedescValue t, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+        List<BType> convertibleTypes;\n+        convertibleTypes = TypeConverter.getConvertibleTypes(value, targetType);\n+        if (convertibleTypes.isEmpty()) {\n+            if (TypeChecker.getType(value).getTag() == TypeTags.STRING_TAG &&\n+                    (targetType.getTag() >= TypeTags.XML_ELEMENT_TAG || targetType.getTag() == TypeTags.XML_TAG)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwNzgzMg=="}, "originalCommit": {"oid": "0f7f31f56391c00bca0e631d0db24e25c803ff64"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NTE0MjcxOnYy", "diffSide": "RIGHT", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNjoyMzoyMlrOGkM0Tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNjoyMzoyMlrOGkM0Tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYxMTkxOA==", "bodyText": "Since this array type is not going to change, how about adding it to BTypes, instead of creating a new JSON array type each time?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440611918", "createdAt": "2020-06-16T06:23:22Z", "author": {"login": "pubudu91"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        // typedesc<json>.constructFrom like usage\n+        if (describingType.getTag() == TypeTags.TYPEDESC_TAG) {\n+            return convert(((BTypedescType) t.getDescribingType()).getConstraint(), v, t, strand);\n+        }\n+        // json.constructFrom like usage\n+        return convert(describingType, v, t, strand);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue) {\n+        return convert(convertType, inputValue, null, null);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue, TypedescValue t, Strand strand) {\n+        try {\n+            return convert(inputValue, convertType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+        return convert(value, targetType, unresolvedValues, false, t, strand);\n+    }\n+\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  boolean allowAmbiguity, TypedescValue t, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+        List<BType> convertibleTypes;\n+        convertibleTypes = TypeConverter.getConvertibleTypes(value, targetType);\n+        if (convertibleTypes.isEmpty()) {\n+            if (TypeChecker.getType(value).getTag() == TypeTags.STRING_TAG &&\n+                    (targetType.getTag() >= TypeTags.XML_ELEMENT_TAG || targetType.getTag() == TypeTags.XML_TAG)) {\n+                try {\n+                    return XMLFactory.parse(((StringValue) value).getValue());\n+                } catch (Throwable e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+            }\n+            throw createConversionError(value, targetType);\n+        } else if (!allowAmbiguity && convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType sourceType = TypeChecker.getType(value);\n+        BType matchingType = convertibleTypes.get(0);\n+        // handle primitive values\n+        if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+            if (TypeChecker.checkIsType(value, matchingType)) {\n+                return value;\n+            } else {\n+                // Has to be a numeric conversion.\n+                return TypeConverter.convertValues(matchingType, value);\n+            }\n+        }\n+\n+        return convert((RefValue) value, matchingType, unresolvedValues, t, strand);\n+    }\n+\n+    private static Object convert(RefValue value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, value.getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        Object newValue;\n+        switch (value.getType().getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, targetType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, targetType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+            case TypeTags.ERROR_TAG:\n+                newValue = value.copy(new HashMap<>());\n+                break;\n+            default:\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMap(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                     TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();\n+                    putToMap(newMap, entry, constraintType, unresolvedValues, t, strand);\n+                }\n+                return newMap;\n+            case TypeTags.RECORD_TYPE_TAG:\n+                BRecordType recordType = (BRecordType) targetType;\n+                MapValueImpl<BString, Object> newRecord;\n+                if (t != null && t.getDescribingType() == targetType) {\n+                    newRecord = (MapValueImpl<BString, Object>) t.instantiate(strand);\n+                } else {\n+                    newRecord = (MapValueImpl<BString, Object>) BallerinaValues\n+                            .createRecordValue(recordType.getPackage(), recordType.getName());\n+                }\n+\n+                BType restFieldType = recordType.restFieldType;\n+                Map<String, BType> targetTypeField = new HashMap<>();\n+                for (BField field : recordType.getFields().values()) {\n+                    targetTypeField.put(field.getFieldName(), field.getFieldType());\n+                }\n+\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType fieldType = targetTypeField.getOrDefault(entry.getKey().toString(), restFieldType);\n+                    putToMap(newRecord, entry, fieldType, unresolvedValues, t, strand);\n+                }\n+                return newRecord;\n+            case TypeTags.JSON_TAG:\n+                BType matchingType = TypeConverter.resolveMatchingTypeForUnion(map, targetType);\n+                return convert(map, matchingType, unresolvedValues, t, strand);\n+            default:\n+                break;\n+        }\n+        // should never reach here\n+        throw BallerinaErrors.createConversionError(map, targetType);\n+    }\n+\n+\n+    private static Object convertArray(ArrayValue array, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                       TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.ARRAY_TAG:\n+                BArrayType arrayType = (BArrayType) targetType;\n+                ArrayValueImpl newArray = new ArrayValueImpl(arrayType);\n+                for (int i = 0; i < array.size(); i++) {\n+                    Object newValue = convert(array.get(i), arrayType.getElementType(), unresolvedValues, t, strand);\n+                    newArray.add(i, newValue);\n+                }\n+                return newArray;\n+            case TypeTags.TUPLE_TAG:\n+                BTupleType tupleType = (BTupleType) targetType;\n+                TupleValueImpl newTuple = new TupleValueImpl(tupleType);\n+                int minLen = tupleType.getTupleTypes().size();\n+                for (int i = 0; i < array.size(); i++) {\n+                    BType elementType = (i < minLen) ? tupleType.getTupleTypes().get(i) : tupleType.getRestType();\n+                    Object newValue = convert(array.get(i), elementType, unresolvedValues, t, strand);\n+                    newTuple.add(i, newValue);\n+                }\n+                return newTuple;\n+            case TypeTags.JSON_TAG:\n+                newArray = new ArrayValueImpl(new BArrayType(BTypes.typeJSON));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b347b097d8ac0c0ee19ac2c060a0824b1366dc9"}, "originalPosition": 260}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NTI2MDg1OnYy", "diffSide": "RIGHT", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNzowNzozNlrOGkN91A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxMDo0NzozMVrOGkVx2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYzMDc0MA==", "bodyText": "This should be thrown right? Since the signature of toJson() is json", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440630740", "createdAt": "2020-06-16T07:07:36Z", "author": {"login": "pubudu91"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.JSON),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        BType sourceType = TypeChecker.getType(value);\n+        BType targetJsonType = BTypes.typeJSON;\n+        if (!isConvertibleToJson(value, new ArrayList<>())) {\n+            if (sourceType.getTag() >= TypeTags.XML_ELEMENT_TAG || sourceType.getTag() == TypeTags.XML_TAG) {\n+                return ToString.toString(strand, value);\n+            } else {\n+                throw createConversionError(value, targetJsonType);\n+            }\n+        }\n+\n+        // handle primitive values\n+        if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+            if (TypeChecker.checkIsType(value, targetJsonType)) {\n+                return value;\n+            } else {\n+                // Has to be a numeric conversion.\n+                return TypeConverter.convertValues(targetJsonType, value);\n+            }\n+        }\n+\n+        return convert((RefValue) value, targetJsonType, new ArrayList<>(), strand);\n+    }\n+\n+    private static Object convert(RefValue value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  Strand strand) {\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, value.getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        Object newValue;\n+        switch (value.getType().getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, targetType, unresolvedValues, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, targetType, unresolvedValues, strand);\n+                break;\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    return createConversionError(value, targetType, e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b347b097d8ac0c0ee19ac2c060a0824b1366dc9"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc1ODc0NQ==", "bodyText": "Ack. Thanks", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440758745", "createdAt": "2020-06-16T10:47:31Z", "author": {"login": "dulajdilshan"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.JSON),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        BType sourceType = TypeChecker.getType(value);\n+        BType targetJsonType = BTypes.typeJSON;\n+        if (!isConvertibleToJson(value, new ArrayList<>())) {\n+            if (sourceType.getTag() >= TypeTags.XML_ELEMENT_TAG || sourceType.getTag() == TypeTags.XML_TAG) {\n+                return ToString.toString(strand, value);\n+            } else {\n+                throw createConversionError(value, targetJsonType);\n+            }\n+        }\n+\n+        // handle primitive values\n+        if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+            if (TypeChecker.checkIsType(value, targetJsonType)) {\n+                return value;\n+            } else {\n+                // Has to be a numeric conversion.\n+                return TypeConverter.convertValues(targetJsonType, value);\n+            }\n+        }\n+\n+        return convert((RefValue) value, targetJsonType, new ArrayList<>(), strand);\n+    }\n+\n+    private static Object convert(RefValue value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  Strand strand) {\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, value.getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        Object newValue;\n+        switch (value.getType().getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, targetType, unresolvedValues, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, targetType, unresolvedValues, strand);\n+                break;\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    return createConversionError(value, targetType, e.getMessage());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYzMDc0MA=="}, "originalCommit": {"oid": "7b347b097d8ac0c0ee19ac2c060a0824b1366dc9"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NTYwMzIxOnYy", "diffSide": "LEFT", "path": "misc/testerina/modules/report-tools/package-lock.json", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwODo0MzowMFrOGkRVcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwOTo0NToyN1rOGkTsMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY4NTkzNg==", "bodyText": "Why are we committing this and the next file?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440685936", "createdAt": "2020-06-16T08:43:00Z", "author": {"login": "MaryamZi"}, "path": "misc/testerina/modules/report-tools/package-lock.json", "diffHunk": "@@ -1,6 +1,6 @@\n {\n   \"name\": \"@ballerina/testerina-report\",\n-  \"version\": \"2.0.0-Preview1-M3\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b347b097d8ac0c0ee19ac2c060a0824b1366dc9"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDcyNDUzMQ==", "bodyText": "I'll correct it", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440724531", "createdAt": "2020-06-16T09:45:27Z", "author": {"login": "dulajdilshan"}, "path": "misc/testerina/modules/report-tools/package-lock.json", "diffHunk": "@@ -1,6 +1,6 @@\n {\n   \"name\": \"@ballerina/testerina-report\",\n-  \"version\": \"2.0.0-Preview1-M3\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY4NTkzNg=="}, "originalCommit": {"oid": "7b347b097d8ac0c0ee19ac2c060a0824b1366dc9"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MzA1MDU3OnYy", "diffSide": "RIGHT", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwOTo1NTozOVrOGm51ZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwOTo1NTozOVrOGm51ZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ0NjYyOQ==", "bodyText": "Should return", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r443446629", "createdAt": "2020-06-22T09:55:39Z", "author": {"login": "dulajdilshan"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        // typedesc<json>.constructFrom like usage\n+        if (describingType.getTag() == TypeTags.TYPEDESC_TAG) {\n+            return convert(((BTypedescType) t.getDescribingType()).getConstraint(), v, t, strand);\n+        }\n+        // json.constructFrom like usage\n+        return convert(describingType, v, t, strand);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue, TypedescValue t, Strand strand) {\n+        try {\n+            return convert(inputValue, convertType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+        return convert(value, targetType, unresolvedValues, false, t, strand);\n+    }\n+\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  boolean allowAmbiguity, TypedescValue t, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+        List<BType> convertibleTypes;\n+        convertibleTypes = getConvertibleTypesFromJson(value, targetType);\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a2f3b589925768e932552b23987b87aed442edb"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MzA1NDUwOnYy", "diffSide": "RIGHT", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwOTo1Njo0NFrOGm53zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwOTo1Njo0NFrOGm53zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ0NzI0Ng==", "bodyText": "no need isambiguity", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r443447246", "createdAt": "2020-06-22T09:56:44Z", "author": {"login": "dulajdilshan"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        // typedesc<json>.constructFrom like usage\n+        if (describingType.getTag() == TypeTags.TYPEDESC_TAG) {\n+            return convert(((BTypedescType) t.getDescribingType()).getConstraint(), v, t, strand);\n+        }\n+        // json.constructFrom like usage\n+        return convert(describingType, v, t, strand);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue, TypedescValue t, Strand strand) {\n+        try {\n+            return convert(inputValue, convertType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+        return convert(value, targetType, unresolvedValues, false, t, strand);\n+    }\n+\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  boolean allowAmbiguity, TypedescValue t, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+        List<BType> convertibleTypes;\n+        convertibleTypes = getConvertibleTypesFromJson(value, targetType);\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (!allowAmbiguity && convertibleTypes.size() > 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a2f3b589925768e932552b23987b87aed442edb"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MzE3ODM2OnYy", "diffSide": "RIGHT", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDozNDowMFrOGm7Egw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDozNDowMFrOGm7Egw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ2Njg4Mw==", "bodyText": "Error put as a cause", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r443466883", "createdAt": "2020-06-22T10:34:00Z", "author": {"login": "dulajdilshan"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        // typedesc<json>.constructFrom like usage\n+        if (describingType.getTag() == TypeTags.TYPEDESC_TAG) {\n+            return convert(((BTypedescType) t.getDescribingType()).getConstraint(), v, t, strand);\n+        }\n+        // json.constructFrom like usage\n+        return convert(describingType, v, t, strand);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue, TypedescValue t, Strand strand) {\n+        try {\n+            return convert(inputValue, convertType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+        return convert(value, targetType, unresolvedValues, false, t, strand);\n+    }\n+\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  boolean allowAmbiguity, TypedescValue t, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+        List<BType> convertibleTypes;\n+        convertibleTypes = getConvertibleTypesFromJson(value, targetType);\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (!allowAmbiguity && convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType sourceType = TypeChecker.getType(value);\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        // handle string (xml as string) to xml conversion\n+        if (TypeChecker.getType(value).getTag() == TypeTags.STRING_TAG &&\n+                ((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG && matchingType.getTag() <= TypeTags.XML_TEXT_TAG)\n+                        || matchingType.getTag() == TypeTags.XML_TAG)) {\n+            try {\n+                return XMLFactory.parse(((StringValue) value).getValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a2f3b589925768e932552b23987b87aed442edb"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMjI1MDI4OnYy", "diffSide": "RIGHT", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TableJSONDataSource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMzowMDo1MVrOGsvr0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNzo1NDowN1rOGucWeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3MTc5NA==", "bodyText": "Can't we do something like\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            Object val = record.get(key);\n          \n          \n            \n                            BString strVal = org.ballerinalang.jvm.StringUtils.fromString(\n          \n          \n            \n                                    org.ballerinalang.jvm.values.utils.StringUtils.getStringValue(val));\n          \n          \n            \n                            jsonObject.put(StringUtils.fromString(name), strVal);\n          \n          \n            \n            //                jsonObject.put(StringUtils.fromString(name), record.getStringValue(key));\n          \n          \n            \n                            BString strVal = StringUtils.fromString(\n          \n          \n            \n                                    org.ballerinalang.jvm.values.utils.StringUtils.getStringValue(record.get(key)));\n          \n          \n            \n                            jsonObject.put(StringUtils.fromString(name), strVal);\n          \n      \n    \n    \n  \n\ninstead?\nLet's also remove commented out code.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449571794", "createdAt": "2020-07-03T13:00:51Z", "author": {"login": "MaryamZi"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TableJSONDataSource.java", "diffHunk": "@@ -159,7 +159,11 @@ private static void constructJsonData(MapValueImpl record, MapValue<BString, Obj\n                         getStructData(record.getMapValue(key), structFields, index, key));\n                 break;\n             case TypeTags.XML_TAG:\n-                jsonObject.put(StringUtils.fromString(name), record.getStringValue(key));\n+                Object val = record.get(key);\n+                BString strVal = org.ballerinalang.jvm.StringUtils.fromString(\n+                        org.ballerinalang.jvm.values.utils.StringUtils.getStringValue(val));\n+                jsonObject.put(StringUtils.fromString(name), strVal);\n+//                jsonObject.put(StringUtils.fromString(name), record.getStringValue(key));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM1MjE4NA==", "bodyText": "Ack", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451352184", "createdAt": "2020-07-08T07:54:07Z", "author": {"login": "dulajdilshan"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TableJSONDataSource.java", "diffHunk": "@@ -159,7 +159,11 @@ private static void constructJsonData(MapValueImpl record, MapValue<BString, Obj\n                         getStructData(record.getMapValue(key), structFields, index, key));\n                 break;\n             case TypeTags.XML_TAG:\n-                jsonObject.put(StringUtils.fromString(name), record.getStringValue(key));\n+                Object val = record.get(key);\n+                BString strVal = org.ballerinalang.jvm.StringUtils.fromString(\n+                        org.ballerinalang.jvm.values.utils.StringUtils.getStringValue(val));\n+                jsonObject.put(StringUtils.fromString(name), strVal);\n+//                jsonObject.put(StringUtils.fromString(name), record.getStringValue(key));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3MTc5NA=="}, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMjczMDYzOnYy", "diffSide": "RIGHT", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxNjowMTo0OVrOGs0Mtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNzo1NzoxNlrOGucdtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY0NTc1MQ==", "bodyText": "In this value type check, we check for simple basic types and string right? Since they are always json, wondering if we can skip the next line and directly return true.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449645751", "createdAt": "2020-07-03T16:01:49Z", "author": {"login": "MaryamZi"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -343,6 +343,56 @@ public static boolean isSameType(BType sourceType, BType targetType) {\n         return false;\n     }\n \n+    public static boolean isConvertibleToJson(Object sourceValue, List<TypeValuePair> unresolvedValues) {\n+\n+        BType sourceType = TypeChecker.getType(sourceValue);\n+\n+        if (TypeChecker.checkIsLikeType(sourceValue, BTypes.typeJSON, true)) {\n+            return true;\n+        }\n+\n+        if (sourceType.getTag() == TypeTags.ARRAY_TAG) {\n+            ArrayValue source = (ArrayValue) sourceValue;\n+            BType elementType = ((BArrayType) source.getType()).getElementType();\n+            if (BTypes.isValueType(elementType)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM1NDAzOA==", "bodyText": "Ack", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451354038", "createdAt": "2020-07-08T07:57:16Z", "author": {"login": "dulajdilshan"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -343,6 +343,56 @@ public static boolean isSameType(BType sourceType, BType targetType) {\n         return false;\n     }\n \n+    public static boolean isConvertibleToJson(Object sourceValue, List<TypeValuePair> unresolvedValues) {\n+\n+        BType sourceType = TypeChecker.getType(sourceValue);\n+\n+        if (TypeChecker.checkIsLikeType(sourceValue, BTypes.typeJSON, true)) {\n+            return true;\n+        }\n+\n+        if (sourceType.getTag() == TypeTags.ARRAY_TAG) {\n+            ArrayValue source = (ArrayValue) sourceValue;\n+            BType elementType = ((BArrayType) source.getType()).getElementType();\n+            if (BTypes.isValueType(elementType)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY0NTc1MQ=="}, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMjgyNTg4OnYy", "diffSide": "RIGHT", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxNjo1NTo1NlrOGs1Dag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxODo0NDoxM1rOGu010Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1OTc1NA==", "bodyText": "Do we need this isConvertibleToJson check at all? toJson can only be called on anydata values right? And unless they have cycles (which seems to be checked independent of this check), it is pretty much guaranteed that they can be converted to json?\n\n  \n    \n      ballerina-lang/langlib/lang.value/src/main/ballerina/src/lang.value/value.bal\n    \n    \n         Line 133\n      in\n      39bbe77\n    \n    \n    \n    \n\n        \n          \n           public function toJson(anydata v) returns json = external;", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449659754", "createdAt": "2020-07-03T16:55:56Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc1MzQyNQ==", "bodyText": "Ack. Thanks", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451753425", "createdAt": "2020-07-08T18:44:13Z", "author": {"login": "dulajdilshan"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1OTc1NA=="}, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMjgyNjkzOnYy", "diffSide": "RIGHT", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxNjo1NjozOFrOGs1D_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwODowMToxMlrOGucnOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1OTkwMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    BType targetJsonType = BTypes.typeJSON;\n          \n          \n            \n                    try {\n          \n          \n            \n                        return convert(value, targetJsonType, new ArrayList<>(), strand);\n          \n          \n            \n                    try {\n          \n          \n            \n                        return convert(value, BTypes.typeJSON, new ArrayList<>(), strand);", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449659900", "createdAt": "2020-07-03T16:56:38Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM1NjQ3Mw==", "bodyText": "Ack", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451356473", "createdAt": "2020-07-08T08:01:12Z", "author": {"login": "dulajdilshan"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1OTkwMA=="}, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMjgyOTcxOnYy", "diffSide": "RIGHT", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxNjo1ODozM1rOGs1FoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwODoxMzo0NVrOGudDJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2MDMyMQ==", "bodyText": "Isn't the target type always json? Makes this check always true right?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449660321", "createdAt": "2020-07-03T16:58:33Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM2MzYyMg==", "bodyText": "Ack", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451363622", "createdAt": "2020-07-08T08:13:45Z", "author": {"login": "dulajdilshan"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2MDMyMQ=="}, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMjg2Nzk2OnYy", "diffSide": "RIGHT", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxNzoyNjowOFrOGs1b4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwMzowNDo1OVrOGvAFRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2NjAxOQ==", "bodyText": "Once we remove error from anydata, we won't reach here right? For the time-being I think we can panic if reach here.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449666019", "createdAt": "2020-07-03T17:26:08Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {\n+            return createConversionError(value, targetType);\n+        }\n+\n+        Object newValue;\n+        switch (TypeChecker.getType(value).getTag()) {\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TUPLE_TAG:\n+            case TypeTags.ARRAY_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, unresolvedValues, strand);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+                break;\n+            case TypeTags.RECORD_TYPE_TAG:\n+            case TypeTags.MAP_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, new BMapType(BTypes.typeJSON),\n+                        unresolvedValues, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkzNzYwNg==", "bodyText": "Ack", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451937606", "createdAt": "2020-07-09T03:04:59Z", "author": {"login": "dulajdilshan"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {\n+            return createConversionError(value, targetType);\n+        }\n+\n+        Object newValue;\n+        switch (TypeChecker.getType(value).getTag()) {\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TUPLE_TAG:\n+            case TypeTags.ARRAY_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, unresolvedValues, strand);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+                break;\n+            case TypeTags.RECORD_TYPE_TAG:\n+            case TypeTags.MAP_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, new BMapType(BTypes.typeJSON),\n+                        unresolvedValues, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2NjAxOQ=="}, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMjg3ODA0OnYy", "diffSide": "RIGHT", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxNzozMzoxMFrOGs1hfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNDowMjo0MlrOGvSnmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2NzQ1Mw==", "bodyText": "We get here only for simple basic types and string, and we don't have to do any conversions here right?\nIMO, we can move this to after the null check and remove this here.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449667453", "createdAt": "2020-07-03T17:33:10Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {\n+            return createConversionError(value, targetType);\n+        }\n+\n+        Object newValue;\n+        switch (TypeChecker.getType(value).getTag()) {\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TUPLE_TAG:\n+            case TypeTags.ARRAY_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, unresolvedValues, strand);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+                break;\n+            case TypeTags.RECORD_TYPE_TAG:\n+            case TypeTags.MAP_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, new BMapType(BTypes.typeJSON),\n+                        unresolvedValues, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2ODE4OA==", "bodyText": "Also, assuming this is for simple basic types, they are always JSON. So we don't have to check getConvertibleTypes.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449668188", "createdAt": "2020-07-03T17:37:04Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {\n+            return createConversionError(value, targetType);\n+        }\n+\n+        Object newValue;\n+        switch (TypeChecker.getType(value).getTag()) {\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TUPLE_TAG:\n+            case TypeTags.ARRAY_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, unresolvedValues, strand);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+                break;\n+            case TypeTags.RECORD_TYPE_TAG:\n+            case TypeTags.MAP_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, new BMapType(BTypes.typeJSON),\n+                        unresolvedValues, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2NzQ1Mw=="}, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI0MTMwNA==", "bodyText": "Changed.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r452241304", "createdAt": "2020-07-09T14:02:42Z", "author": {"login": "dulajdilshan"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {\n+            return createConversionError(value, targetType);\n+        }\n+\n+        Object newValue;\n+        switch (TypeChecker.getType(value).getTag()) {\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TUPLE_TAG:\n+            case TypeTags.ARRAY_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, unresolvedValues, strand);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+                break;\n+            case TypeTags.RECORD_TYPE_TAG:\n+            case TypeTags.MAP_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, new BMapType(BTypes.typeJSON),\n+                        unresolvedValues, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2NzQ1Mw=="}, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMjg4NTkzOnYy", "diffSide": "RIGHT", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxNzozOTowM1rOGs1l4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxODo1OTo0OFrOGu1WKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2ODU3OA==", "bodyText": "targetType is always map<json> right? We can have a constant/final variable for the type in this class or BTypes, or move the type creation to within this method.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449668578", "createdAt": "2020-07-03T17:39:03Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {\n+            return createConversionError(value, targetType);\n+        }\n+\n+        Object newValue;\n+        switch (TypeChecker.getType(value).getTag()) {\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TUPLE_TAG:\n+            case TypeTags.ARRAY_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, unresolvedValues, strand);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+                break;\n+            case TypeTags.RECORD_TYPE_TAG:\n+            case TypeTags.MAP_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, new BMapType(BTypes.typeJSON),\n+                        unresolvedValues, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                List<BType> convertibleTypes = TypeConverter.getConvertibleTypes(value, BTypes.typeJSON);\n+                if (convertibleTypes.size() == 0) {\n+                    throw createConversionError(value, targetType);\n+                } else if (convertibleTypes.size() > 1) {\n+                    throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+                }\n+\n+                BType sourceType = TypeChecker.getType(value);\n+                BType matchingType = convertibleTypes.get(0);\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                } else {\n+                    throw createConversionError(value, targetType);\n+                }\n+                break;\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMapToJson(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MTcwNg==", "bodyText": "Ack", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451761706", "createdAt": "2020-07-08T18:59:48Z", "author": {"login": "dulajdilshan"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {\n+            return createConversionError(value, targetType);\n+        }\n+\n+        Object newValue;\n+        switch (TypeChecker.getType(value).getTag()) {\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TUPLE_TAG:\n+            case TypeTags.ARRAY_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, unresolvedValues, strand);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+                break;\n+            case TypeTags.RECORD_TYPE_TAG:\n+            case TypeTags.MAP_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, new BMapType(BTypes.typeJSON),\n+                        unresolvedValues, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                List<BType> convertibleTypes = TypeConverter.getConvertibleTypes(value, BTypes.typeJSON);\n+                if (convertibleTypes.size() == 0) {\n+                    throw createConversionError(value, targetType);\n+                } else if (convertibleTypes.size() > 1) {\n+                    throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+                }\n+\n+                BType sourceType = TypeChecker.getType(value);\n+                BType matchingType = convertibleTypes.get(0);\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                } else {\n+                    throw createConversionError(value, targetType);\n+                }\n+                break;\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMapToJson(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2ODU3OA=="}, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMjg4ODI1OnYy", "diffSide": "RIGHT", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxNzo0MDo0OVrOGs1nJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxMzo1MToyOVrOGupCvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2ODkwMg==", "bodyText": "We should have extracted this out to a variable. But then again since this is always json, we can use the JSON type in BTypes.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449668902", "createdAt": "2020-07-03T17:40:49Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {\n+            return createConversionError(value, targetType);\n+        }\n+\n+        Object newValue;\n+        switch (TypeChecker.getType(value).getTag()) {\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TUPLE_TAG:\n+            case TypeTags.ARRAY_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, unresolvedValues, strand);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+                break;\n+            case TypeTags.RECORD_TYPE_TAG:\n+            case TypeTags.MAP_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, new BMapType(BTypes.typeJSON),\n+                        unresolvedValues, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                List<BType> convertibleTypes = TypeConverter.getConvertibleTypes(value, BTypes.typeJSON);\n+                if (convertibleTypes.size() == 0) {\n+                    throw createConversionError(value, targetType);\n+                } else if (convertibleTypes.size() > 1) {\n+                    throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+                }\n+\n+                BType sourceType = TypeChecker.getType(value);\n+                BType matchingType = convertibleTypes.get(0);\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                } else {\n+                    throw createConversionError(value, targetType);\n+                }\n+                break;\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMapToJson(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                           Strand strand) {\n+        MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+        for (Map.Entry entry : map.entrySet()) {\n+            BType constraintType = ((BMapType) targetType).getConstrainedType();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTU2MDEyNA==", "bodyText": "Ack", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451560124", "createdAt": "2020-07-08T13:51:29Z", "author": {"login": "dulajdilshan"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {\n+            return createConversionError(value, targetType);\n+        }\n+\n+        Object newValue;\n+        switch (TypeChecker.getType(value).getTag()) {\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TUPLE_TAG:\n+            case TypeTags.ARRAY_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, unresolvedValues, strand);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+                break;\n+            case TypeTags.RECORD_TYPE_TAG:\n+            case TypeTags.MAP_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, new BMapType(BTypes.typeJSON),\n+                        unresolvedValues, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                List<BType> convertibleTypes = TypeConverter.getConvertibleTypes(value, BTypes.typeJSON);\n+                if (convertibleTypes.size() == 0) {\n+                    throw createConversionError(value, targetType);\n+                } else if (convertibleTypes.size() > 1) {\n+                    throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+                }\n+\n+                BType sourceType = TypeChecker.getType(value);\n+                BType matchingType = convertibleTypes.get(0);\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                } else {\n+                    throw createConversionError(value, targetType);\n+                }\n+                break;\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMapToJson(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                           Strand strand) {\n+        MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+        for (Map.Entry entry : map.entrySet()) {\n+            BType constraintType = ((BMapType) targetType).getConstrainedType();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2ODkwMg=="}, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 164}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMjg5MTg4OnYy", "diffSide": "RIGHT", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxNzo0MzozMVrOGs1pHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxMzo0ODoyOFrOGuo6XA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2OTQwNg==", "bodyText": "Can't we use BTypes.typeJsonArray you've introduced?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449669406", "createdAt": "2020-07-03T17:43:31Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {\n+            return createConversionError(value, targetType);\n+        }\n+\n+        Object newValue;\n+        switch (TypeChecker.getType(value).getTag()) {\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TUPLE_TAG:\n+            case TypeTags.ARRAY_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, unresolvedValues, strand);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+                break;\n+            case TypeTags.RECORD_TYPE_TAG:\n+            case TypeTags.MAP_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, new BMapType(BTypes.typeJSON),\n+                        unresolvedValues, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                List<BType> convertibleTypes = TypeConverter.getConvertibleTypes(value, BTypes.typeJSON);\n+                if (convertibleTypes.size() == 0) {\n+                    throw createConversionError(value, targetType);\n+                } else if (convertibleTypes.size() > 1) {\n+                    throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+                }\n+\n+                BType sourceType = TypeChecker.getType(value);\n+                BType matchingType = convertibleTypes.get(0);\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                } else {\n+                    throw createConversionError(value, targetType);\n+                }\n+                break;\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMapToJson(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                           Strand strand) {\n+        MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+        for (Map.Entry entry : map.entrySet()) {\n+            BType constraintType = ((BMapType) targetType).getConstrainedType();\n+            putToMap(newMap, entry, constraintType, unresolvedValues, strand);\n+        }\n+        return newMap;\n+    }\n+\n+    private static Object convertArrayToJson(ArrayValue array, List<TypeValuePair> unresolvedValues,\n+                                             Strand strand) {\n+        ArrayValueImpl newArray = new ArrayValueImpl(new BArrayType(BTypes.typeJSON));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTU1Nzk4MA==", "bodyText": "Ack", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451557980", "createdAt": "2020-07-08T13:48:28Z", "author": {"login": "dulajdilshan"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {\n+            return createConversionError(value, targetType);\n+        }\n+\n+        Object newValue;\n+        switch (TypeChecker.getType(value).getTag()) {\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TUPLE_TAG:\n+            case TypeTags.ARRAY_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, unresolvedValues, strand);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+                break;\n+            case TypeTags.RECORD_TYPE_TAG:\n+            case TypeTags.MAP_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, new BMapType(BTypes.typeJSON),\n+                        unresolvedValues, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                List<BType> convertibleTypes = TypeConverter.getConvertibleTypes(value, BTypes.typeJSON);\n+                if (convertibleTypes.size() == 0) {\n+                    throw createConversionError(value, targetType);\n+                } else if (convertibleTypes.size() > 1) {\n+                    throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+                }\n+\n+                BType sourceType = TypeChecker.getType(value);\n+                BType matchingType = convertibleTypes.get(0);\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                } else {\n+                    throw createConversionError(value, targetType);\n+                }\n+                break;\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMapToJson(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                           Strand strand) {\n+        MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+        for (Map.Entry entry : map.entrySet()) {\n+            BType constraintType = ((BMapType) targetType).getConstrainedType();\n+            putToMap(newMap, entry, constraintType, unresolvedValues, strand);\n+        }\n+        return newMap;\n+    }\n+\n+    private static Object convertArrayToJson(ArrayValue array, List<TypeValuePair> unresolvedValues,\n+                                             Strand strand) {\n+        ArrayValueImpl newArray = new ArrayValueImpl(new BArrayType(BTypes.typeJSON));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2OTQwNg=="}, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 172}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMjg5MjcxOnYy", "diffSide": "RIGHT", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxNzo0NDoxNlrOGs1pqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxMzo0ODoxMVrOGuo5ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2OTU0NQ==", "bodyText": "We don't need a separate method for this right?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449669545", "createdAt": "2020-07-03T17:44:16Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {\n+            return createConversionError(value, targetType);\n+        }\n+\n+        Object newValue;\n+        switch (TypeChecker.getType(value).getTag()) {\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TUPLE_TAG:\n+            case TypeTags.ARRAY_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, unresolvedValues, strand);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+                break;\n+            case TypeTags.RECORD_TYPE_TAG:\n+            case TypeTags.MAP_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, new BMapType(BTypes.typeJSON),\n+                        unresolvedValues, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                List<BType> convertibleTypes = TypeConverter.getConvertibleTypes(value, BTypes.typeJSON);\n+                if (convertibleTypes.size() == 0) {\n+                    throw createConversionError(value, targetType);\n+                } else if (convertibleTypes.size() > 1) {\n+                    throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+                }\n+\n+                BType sourceType = TypeChecker.getType(value);\n+                BType matchingType = convertibleTypes.get(0);\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                } else {\n+                    throw createConversionError(value, targetType);\n+                }\n+                break;\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMapToJson(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                           Strand strand) {\n+        MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+        for (Map.Entry entry : map.entrySet()) {\n+            BType constraintType = ((BMapType) targetType).getConstrainedType();\n+            putToMap(newMap, entry, constraintType, unresolvedValues, strand);\n+        }\n+        return newMap;\n+    }\n+\n+    private static Object convertArrayToJson(ArrayValue array, List<TypeValuePair> unresolvedValues,\n+                                             Strand strand) {\n+        ArrayValueImpl newArray = new ArrayValueImpl(new BArrayType(BTypes.typeJSON));\n+        for (int i = 0; i < array.size(); i++) {\n+            Object newValue = convert(array.get(i), BTypes.typeJSON, unresolvedValues, strand);\n+            newArray.add(i, newValue);\n+        }\n+        return newArray;\n+    }\n+\n+    private static void putToMap(MapValue<BString, Object> map, Map.Entry entry, BType fieldType,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTU1Nzc5MA==", "bodyText": "Ack", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451557790", "createdAt": "2020-07-08T13:48:11Z", "author": {"login": "dulajdilshan"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {\n+            return createConversionError(value, targetType);\n+        }\n+\n+        Object newValue;\n+        switch (TypeChecker.getType(value).getTag()) {\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TUPLE_TAG:\n+            case TypeTags.ARRAY_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, unresolvedValues, strand);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+                break;\n+            case TypeTags.RECORD_TYPE_TAG:\n+            case TypeTags.MAP_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, new BMapType(BTypes.typeJSON),\n+                        unresolvedValues, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                List<BType> convertibleTypes = TypeConverter.getConvertibleTypes(value, BTypes.typeJSON);\n+                if (convertibleTypes.size() == 0) {\n+                    throw createConversionError(value, targetType);\n+                } else if (convertibleTypes.size() > 1) {\n+                    throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+                }\n+\n+                BType sourceType = TypeChecker.getType(value);\n+                BType matchingType = convertibleTypes.get(0);\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                } else {\n+                    throw createConversionError(value, targetType);\n+                }\n+                break;\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMapToJson(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                           Strand strand) {\n+        MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+        for (Map.Entry entry : map.entrySet()) {\n+            BType constraintType = ((BMapType) targetType).getConstrainedType();\n+            putToMap(newMap, entry, constraintType, unresolvedValues, strand);\n+        }\n+        return newMap;\n+    }\n+\n+    private static Object convertArrayToJson(ArrayValue array, List<TypeValuePair> unresolvedValues,\n+                                             Strand strand) {\n+        ArrayValueImpl newArray = new ArrayValueImpl(new BArrayType(BTypes.typeJSON));\n+        for (int i = 0; i < array.size(); i++) {\n+            Object newValue = convert(array.get(i), BTypes.typeJSON, unresolvedValues, strand);\n+            newArray.add(i, newValue);\n+        }\n+        return newArray;\n+    }\n+\n+    private static void putToMap(MapValue<BString, Object> map, Map.Entry entry, BType fieldType,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2OTU0NQ=="}, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 180}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMjkyMzY1OnYy", "diffSide": "RIGHT", "path": "langlib/langlib-test/src/test/java/org/ballerinalang/langlib/test/LangLibValueTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxODowNjozNlrOGs16hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQyMjowNDoyMFrOGu6xsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY3Mzg2Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Test(enabled = true)\n          \n          \n            \n            @Test", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449673862", "createdAt": "2020-07-03T18:06:36Z", "author": {"login": "MaryamZi"}, "path": "langlib/langlib-test/src/test/java/org/ballerinalang/langlib/test/LangLibValueTest.java", "diffHunk": "@@ -41,7 +41,7 @@\n  *\n  * @since 1.0\n  */\n-@Test(enabled = false)\n+@Test(enabled = true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY3NzYzNA==", "bodyText": "We can just remove (enabled = false). Please fix everywhere.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449677634", "createdAt": "2020-07-03T18:26:39Z", "author": {"login": "MaryamZi"}, "path": "langlib/langlib-test/src/test/java/org/ballerinalang/langlib/test/LangLibValueTest.java", "diffHunk": "@@ -41,7 +41,7 @@\n  *\n  * @since 1.0\n  */\n-@Test(enabled = false)\n+@Test(enabled = true)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY3Mzg2Mg=="}, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg1MDY3NA==", "bodyText": "Ack", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451850674", "createdAt": "2020-07-08T22:04:20Z", "author": {"login": "dulajdilshan"}, "path": "langlib/langlib-test/src/test/java/org/ballerinalang/langlib/test/LangLibValueTest.java", "diffHunk": "@@ -41,7 +41,7 @@\n  *\n  * @since 1.0\n  */\n-@Test(enabled = false)\n+@Test(enabled = true)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY3Mzg2Mg=="}, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMjk1MzY2OnYy", "diffSide": "RIGHT", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxODoyOTo1N1rOGs2Ljw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQyMDozMTozMlrOGu4L9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY3ODIyMw==", "bodyText": "Do we have to remove since we'll be creating a new list for each call to the method? Can you check others too.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449678223", "createdAt": "2020-07-03T18:29:57Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {\n+                    try {\n+                        newValue = XMLFactory.parse(((StringValue) value).getValue());\n+                        break;\n+                    } catch (Throwable e) {\n+                        throw createConversionError(value, targetType, e.getMessage());\n+                    }\n+                }\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                    break;\n+                }\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM4ODAzMQ==", "bodyText": "Ack", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451388031", "createdAt": "2020-07-08T08:53:40Z", "author": {"login": "dulajdilshan"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {\n+                    try {\n+                        newValue = XMLFactory.parse(((StringValue) value).getValue());\n+                        break;\n+                    } catch (Throwable e) {\n+                        throw createConversionError(value, targetType, e.getMessage());\n+                    }\n+                }\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                    break;\n+                }\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY3ODIyMw=="}, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwODI0NA==", "bodyText": "But, There can be situations like\npublic function main() {\n    json anObject = { name : \"anObject\", value : 10, sub : { subName : \"subObject\", subValue : 10 }};\n    string k = anObject.toJsonString();\n}\nif we remove this line :unresolvedValues.remove(typeValuePair); ,  10 will be duplicated inside unresolvedValues the fail. won't it?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451808244", "createdAt": "2020-07-08T20:31:32Z", "author": {"login": "dulajdilshan"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {\n+                    try {\n+                        newValue = XMLFactory.parse(((StringValue) value).getValue());\n+                        break;\n+                    } catch (Throwable e) {\n+                        throw createConversionError(value, targetType, e.getMessage());\n+                    }\n+                }\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                    break;\n+                }\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY3ODIyMw=="}, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMjk3NTk1OnYy", "diffSide": "RIGHT", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxODo0Nzo0MVrOGs2X-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwODoyNjozMFrOGudg6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY4MTQwMw==", "bodyText": "We need to consider maps also right? And arrays/tuples?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449681403", "createdAt": "2020-07-03T18:47:41Z", "author": {"login": "MaryamZi"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "diffHunk": "@@ -263,7 +264,44 @@ static boolean isConvertibleToFloatingPointTypes(Object value) {\n         return convertibleTypes;\n     }\n \n-    private static boolean isConvertibleToRecordType(Object sourceValue, BRecordType targetType,\n+    public static List<BType> getConvertibleTypesFromJson(Object value, BType targetType,\n+                                                          List<TypeValuePair> unresolvedValues) {\n+        List<BType> convertibleTypes = new ArrayList<>();\n+\n+        int targetTypeTag = targetType.getTag();\n+\n+        convertibleTypes.addAll(TypeConverter.getConvertibleTypes(value, targetType));\n+\n+        if (convertibleTypes.size() == 0) {\n+            switch (targetTypeTag) {\n+                case TypeTags.RECORD_TYPE_TAG:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM3MTI0MA==", "bodyText": "They were caught in this method call in line: 310\nTypeConverter.getConvertibleTypes(value, targetType)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451371240", "createdAt": "2020-07-08T08:26:30Z", "author": {"login": "dulajdilshan"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "diffHunk": "@@ -263,7 +264,44 @@ static boolean isConvertibleToFloatingPointTypes(Object value) {\n         return convertibleTypes;\n     }\n \n-    private static boolean isConvertibleToRecordType(Object sourceValue, BRecordType targetType,\n+    public static List<BType> getConvertibleTypesFromJson(Object value, BType targetType,\n+                                                          List<TypeValuePair> unresolvedValues) {\n+        List<BType> convertibleTypes = new ArrayList<>();\n+\n+        int targetTypeTag = targetType.getTag();\n+\n+        convertibleTypes.addAll(TypeConverter.getConvertibleTypes(value, targetType));\n+\n+        if (convertibleTypes.size() == 0) {\n+            switch (targetTypeTag) {\n+                case TypeTags.RECORD_TYPE_TAG:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY4MTQwMw=="}, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMDU5NjkyOnYy", "diffSide": "RIGHT", "path": "langlib/langlib-test/src/test/resources/test-src/valuelib_test.bal", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMTo0Mjo0N1rOGt6xEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwODoyNzowNFrOGudiTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgwMTkzOA==", "bodyText": "Can you also include a couple of tests where,\n\nthe variable type is anydata\nthe variable type is a record with an xml field", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r450801938", "createdAt": "2020-07-07T11:42:47Z", "author": {"login": "pubudu91"}, "path": "langlib/langlib-test/src/test/resources/test-src/valuelib_test.bal", "diffHunk": "@@ -50,6 +50,33 @@ function testToJsonString() returns map<string> {\n     return result;\n }\n \n+function testToJsonStringForNonJsonTypes() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM3MTU5Ng==", "bodyText": "Sure.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451371596", "createdAt": "2020-07-08T08:27:04Z", "author": {"login": "dulajdilshan"}, "path": "langlib/langlib-test/src/test/resources/test-src/valuelib_test.bal", "diffHunk": "@@ -50,6 +50,33 @@ function testToJsonString() returns map<string> {\n     return result;\n }\n \n+function testToJsonStringForNonJsonTypes() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgwMTkzOA=="}, "originalCommit": {"oid": "39bbe770806904ada758446ee80c9df6cfeed410"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzOTE0MTQzOnYy", "diffSide": "RIGHT", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TableJSONDataSource.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNjozMjowOVrOGyF-qQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNjozMzowNlrOGyGBDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE3OTk0NQ==", "bodyText": "This same method gets called for jsonutils:fromTable right? In that context, I am not sure if converting to string is the expected behaviour. I think what is expected is the result of applying jsonutils:fromXML. Shall we create an issue to track clarifying this with the stdlib team?\nI guess this is broken atm anyway, since record.getStringValue(key) is called for XML.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455179945", "createdAt": "2020-07-15T16:32:09Z", "author": {"login": "MaryamZi"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TableJSONDataSource.java", "diffHunk": "@@ -159,7 +159,9 @@ private static void constructJsonData(MapValueImpl record, MapValue<BString, Obj\n                         getStructData(record.getMapValue(key), structFields, index, key));\n                 break;\n             case TypeTags.XML_TAG:\n-                jsonObject.put(StringUtils.fromString(name), record.getStringValue(key));\n+                BString strVal = org.ballerinalang.jvm.StringUtils.fromString(\n+                        org.ballerinalang.jvm.values.utils.StringUtils.getStringValue(record.get(key)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE4MDU1OQ==", "bodyText": "Checked with\nimport ballerina/jsonutils;\n\ntype Foo record {|\n    int i;\n    xml x;\n|};\n\npublic function main() {\n    table<Foo> tb = table [\n        {i: 1, x: xml `<foo>FOO</foo>`}\n    ];\n\n    json j = jsonutils:fromTable(tb);\n}\nFails with\n$ ballerina run qwe.bal \nCompiling source\n        qwe.bal\nRunning executables\n\nerror: java.lang.ClassCastException message=org.ballerinalang.jvm.values.XMLItem cannot be cast to org.ballerinalang.jvm.values.api.BString\n        at ballerina.0_5_0:externFromTable(jsonutils.bal:63)\n           ballerina.0_5_0:fromTable(jsonutils.bal:60)\n           qwe:main(qwe.bal:13)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455180559", "createdAt": "2020-07-15T16:33:06Z", "author": {"login": "MaryamZi"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TableJSONDataSource.java", "diffHunk": "@@ -159,7 +159,9 @@ private static void constructJsonData(MapValueImpl record, MapValue<BString, Obj\n                         getStructData(record.getMapValue(key), structFields, index, key));\n                 break;\n             case TypeTags.XML_TAG:\n-                jsonObject.put(StringUtils.fromString(name), record.getStringValue(key));\n+                BString strVal = org.ballerinalang.jvm.StringUtils.fromString(\n+                        org.ballerinalang.jvm.values.utils.StringUtils.getStringValue(record.get(key)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE3OTk0NQ=="}, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzOTQzMjA1OnYy", "diffSide": "RIGHT", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNzo0MDo1M1rOGyI3zQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMDo0MzowMFrOGylYHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIyNzM0MQ==", "bodyText": "TypeConverter.getConvertibleTypes(value, targetType) calls isConvertibleToRecordType with isFromJson set to false right?\nWhat if targetType is a union of two records, say Foo|Bar, and the value is convertible to Foo even when  isFromJson is false in isConvertibleToRecordType, but it is only convertible to Bar when isFromJson is true?\nSo IINM, from L273 when we reach here convertibleTypes will only have Foo and we return that in L301. But if we actually check isConvertibleToRecordType(value, (BRecordType) targetType, true, unresolvedValues) it'll evaluate to true for Bar, and there'll actually be 2 convertible types?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455227341", "createdAt": "2020-07-15T17:40:53Z", "author": {"login": "MaryamZi"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "diffHunk": "@@ -263,7 +264,44 @@ static boolean isConvertibleToFloatingPointTypes(Object value) {\n         return convertibleTypes;\n     }\n \n-    private static boolean isConvertibleToRecordType(Object sourceValue, BRecordType targetType,\n+    public static List<BType> getConvertibleTypesFromJson(Object value, BType targetType,\n+                                                          List<TypeValuePair> unresolvedValues) {\n+        List<BType> convertibleTypes = new ArrayList<>();\n+\n+        int targetTypeTag = targetType.getTag();\n+\n+        convertibleTypes.addAll(TypeConverter.getConvertibleTypes(value, targetType));\n+\n+        if (convertibleTypes.size() == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI1NDI5NQ==", "bodyText": "For example\nimport ballerina/io;\n\ntype Foo record {|\n    int i;\n    xml x;\n|};\n\ntype Bar record {|\n    int i;\n    string x;\n|};\n\ntype FooBar Foo|Bar;\n\npublic function main() {\n    json j = {i: 1, x: \"<abc>ABC</abc>\"};\n\n    // No error.\n    io:println(j.fromJsonWithType(Foo)); // i=1 x=<abc>ABC</abc>\n    // No error.\n    io:println(j.fromJsonWithType(Bar)); // i=1 x=<abc>ABC</abc>\n\n    // Then this should be ambiguous?\n    io:println(j.fromJsonWithType(FooBar)); // i=1 x=<abc>ABC</abc>\n}", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455254295", "createdAt": "2020-07-15T18:24:43Z", "author": {"login": "MaryamZi"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "diffHunk": "@@ -263,7 +264,44 @@ static boolean isConvertibleToFloatingPointTypes(Object value) {\n         return convertibleTypes;\n     }\n \n-    private static boolean isConvertibleToRecordType(Object sourceValue, BRecordType targetType,\n+    public static List<BType> getConvertibleTypesFromJson(Object value, BType targetType,\n+                                                          List<TypeValuePair> unresolvedValues) {\n+        List<BType> convertibleTypes = new ArrayList<>();\n+\n+        int targetTypeTag = targetType.getTag();\n+\n+        convertibleTypes.addAll(TypeConverter.getConvertibleTypes(value, targetType));\n+\n+        if (convertibleTypes.size() == 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIyNzM0MQ=="}, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU4MDIzMw==", "bodyText": "Shouldn't this be okay according to this ?\nLet's take this\n io:println(j.fromJsonWithType(FooBar));\nWhen we reach L273, convertibleTypes will have only have Bar.  isn't it?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455580233", "createdAt": "2020-07-16T07:49:48Z", "author": {"login": "dulajdilshan"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "diffHunk": "@@ -263,7 +264,44 @@ static boolean isConvertibleToFloatingPointTypes(Object value) {\n         return convertibleTypes;\n     }\n \n-    private static boolean isConvertibleToRecordType(Object sourceValue, BRecordType targetType,\n+    public static List<BType> getConvertibleTypesFromJson(Object value, BType targetType,\n+                                                          List<TypeValuePair> unresolvedValues) {\n+        List<BType> convertibleTypes = new ArrayList<>();\n+\n+        int targetTypeTag = targetType.getTag();\n+\n+        convertibleTypes.addAll(TypeConverter.getConvertibleTypes(value, targetType));\n+\n+        if (convertibleTypes.size() == 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIyNzM0MQ=="}, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY5NDM2Nw==", "bodyText": "Ah, didn't know of the \"fromJsonWithType should only do something different from cloneWithType if cloneWithType would produce an error.\" part.\nYeah, this behaviour is correct then. Thanks!", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455694367", "createdAt": "2020-07-16T10:43:00Z", "author": {"login": "MaryamZi"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "diffHunk": "@@ -263,7 +264,44 @@ static boolean isConvertibleToFloatingPointTypes(Object value) {\n         return convertibleTypes;\n     }\n \n-    private static boolean isConvertibleToRecordType(Object sourceValue, BRecordType targetType,\n+    public static List<BType> getConvertibleTypesFromJson(Object value, BType targetType,\n+                                                          List<TypeValuePair> unresolvedValues) {\n+        List<BType> convertibleTypes = new ArrayList<>();\n+\n+        int targetTypeTag = targetType.getTag();\n+\n+        convertibleTypes.addAll(TypeConverter.getConvertibleTypes(value, targetType));\n+\n+        if (convertibleTypes.size() == 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIyNzM0MQ=="}, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzOTY2MDU4OnYy", "diffSide": "RIGHT", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxODo0MTowN1rOGyLG6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwODoyNToxNFrOGygZvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI2Mzk3OA==", "bodyText": "Re: the constraint, the spec says\n\nThe type specified by a row-type-parameter must be a subtype of map<any|error>\n\nSo it is always a record or a map right? Do we need this check?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455263978", "createdAt": "2020-07-15T18:41:07Z", "author": {"login": "MaryamZi"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "diffHunk": "@@ -263,7 +264,44 @@ static boolean isConvertibleToFloatingPointTypes(Object value) {\n         return convertibleTypes;\n     }\n \n-    private static boolean isConvertibleToRecordType(Object sourceValue, BRecordType targetType,\n+    public static List<BType> getConvertibleTypesFromJson(Object value, BType targetType,\n+                                                          List<TypeValuePair> unresolvedValues) {\n+        List<BType> convertibleTypes = new ArrayList<>();\n+\n+        int targetTypeTag = targetType.getTag();\n+\n+        convertibleTypes.addAll(TypeConverter.getConvertibleTypes(value, targetType));\n+\n+        if (convertibleTypes.size() == 0) {\n+            switch (targetTypeTag) {\n+                case TypeTags.RECORD_TYPE_TAG:\n+                    if (isConvertibleToRecordType(value, (BRecordType) targetType, true, unresolvedValues)) {\n+                        convertibleTypes.add(targetType);\n+                    }\n+                    break;\n+                case TypeTags.TABLE_TAG:\n+                    if (((BTableType) targetType).getConstrainedType().getTag() == TypeTags.RECORD_TYPE_TAG ||\n+                            ((BTableType) targetType).getConstrainedType().getTag() == TypeTags.MAP_TAG) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYxMjg2MA==", "bodyText": "I think yes. because  If I remove the above-mentioned check,\ntype TableString table<string>;\npublic function main() {\n    json j = [\n        \"cake\",\n        \"buscuit\"\n    ];\n    table<string>|error tabString = j.fromJsonWithType(TableString);\n}\nThis works without giving a prior error for table<string>", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455612860", "createdAt": "2020-07-16T08:25:14Z", "author": {"login": "dulajdilshan"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "diffHunk": "@@ -263,7 +264,44 @@ static boolean isConvertibleToFloatingPointTypes(Object value) {\n         return convertibleTypes;\n     }\n \n-    private static boolean isConvertibleToRecordType(Object sourceValue, BRecordType targetType,\n+    public static List<BType> getConvertibleTypesFromJson(Object value, BType targetType,\n+                                                          List<TypeValuePair> unresolvedValues) {\n+        List<BType> convertibleTypes = new ArrayList<>();\n+\n+        int targetTypeTag = targetType.getTag();\n+\n+        convertibleTypes.addAll(TypeConverter.getConvertibleTypes(value, targetType));\n+\n+        if (convertibleTypes.size() == 0) {\n+            switch (targetTypeTag) {\n+                case TypeTags.RECORD_TYPE_TAG:\n+                    if (isConvertibleToRecordType(value, (BRecordType) targetType, true, unresolvedValues)) {\n+                        convertibleTypes.add(targetType);\n+                    }\n+                    break;\n+                case TypeTags.TABLE_TAG:\n+                    if (((BTableType) targetType).getConstrainedType().getTag() == TypeTags.RECORD_TYPE_TAG ||\n+                            ((BTableType) targetType).getConstrainedType().getTag() == TypeTags.MAP_TAG) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI2Mzk3OA=="}, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzOTcyMzA0OnYy", "diffSide": "RIGHT", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxODo1ODoyMlrOGyLtSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwODoyOToyNFrOGygj1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI3MzgwMg==", "bodyText": "Do we need this default case?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455273802", "createdAt": "2020-07-15T18:58:22Z", "author": {"login": "MaryamZi"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "diffHunk": "@@ -263,7 +264,44 @@ static boolean isConvertibleToFloatingPointTypes(Object value) {\n         return convertibleTypes;\n     }\n \n-    private static boolean isConvertibleToRecordType(Object sourceValue, BRecordType targetType,\n+    public static List<BType> getConvertibleTypesFromJson(Object value, BType targetType,\n+                                                          List<TypeValuePair> unresolvedValues) {\n+        List<BType> convertibleTypes = new ArrayList<>();\n+\n+        int targetTypeTag = targetType.getTag();\n+\n+        convertibleTypes.addAll(TypeConverter.getConvertibleTypes(value, targetType));\n+\n+        if (convertibleTypes.size() == 0) {\n+            switch (targetTypeTag) {\n+                case TypeTags.RECORD_TYPE_TAG:\n+                    if (isConvertibleToRecordType(value, (BRecordType) targetType, true, unresolvedValues)) {\n+                        convertibleTypes.add(targetType);\n+                    }\n+                    break;\n+                case TypeTags.TABLE_TAG:\n+                    if (((BTableType) targetType).getConstrainedType().getTag() == TypeTags.RECORD_TYPE_TAG ||\n+                            ((BTableType) targetType).getConstrainedType().getTag() == TypeTags.MAP_TAG) {\n+                        convertibleTypes.add(targetType);\n+                    }\n+                    break;\n+                case TypeTags.XML_TAG:\n+                case TypeTags.XML_ELEMENT_TAG:\n+                case TypeTags.XML_COMMENT_TAG:\n+                case TypeTags.XML_PI_TAG:\n+                case TypeTags.XML_TEXT_TAG:\n+                    if (TypeChecker.getType(value).getTag() == TypeTags.STRING_TAG) {\n+                        convertibleTypes.add(targetType);\n+                    }\n+                    break;\n+                default:\n+                    break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYxNTQ0Ng==", "bodyText": "Ack", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455615446", "createdAt": "2020-07-16T08:29:24Z", "author": {"login": "dulajdilshan"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "diffHunk": "@@ -263,7 +264,44 @@ static boolean isConvertibleToFloatingPointTypes(Object value) {\n         return convertibleTypes;\n     }\n \n-    private static boolean isConvertibleToRecordType(Object sourceValue, BRecordType targetType,\n+    public static List<BType> getConvertibleTypesFromJson(Object value, BType targetType,\n+                                                          List<TypeValuePair> unresolvedValues) {\n+        List<BType> convertibleTypes = new ArrayList<>();\n+\n+        int targetTypeTag = targetType.getTag();\n+\n+        convertibleTypes.addAll(TypeConverter.getConvertibleTypes(value, targetType));\n+\n+        if (convertibleTypes.size() == 0) {\n+            switch (targetTypeTag) {\n+                case TypeTags.RECORD_TYPE_TAG:\n+                    if (isConvertibleToRecordType(value, (BRecordType) targetType, true, unresolvedValues)) {\n+                        convertibleTypes.add(targetType);\n+                    }\n+                    break;\n+                case TypeTags.TABLE_TAG:\n+                    if (((BTableType) targetType).getConstrainedType().getTag() == TypeTags.RECORD_TYPE_TAG ||\n+                            ((BTableType) targetType).getConstrainedType().getTag() == TypeTags.MAP_TAG) {\n+                        convertibleTypes.add(targetType);\n+                    }\n+                    break;\n+                case TypeTags.XML_TAG:\n+                case TypeTags.XML_ELEMENT_TAG:\n+                case TypeTags.XML_COMMENT_TAG:\n+                case TypeTags.XML_PI_TAG:\n+                case TypeTags.XML_TEXT_TAG:\n+                    if (TypeChecker.getType(value).getTag() == TypeTags.STRING_TAG) {\n+                        convertibleTypes.add(targetType);\n+                    }\n+                    break;\n+                default:\n+                    break;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI3MzgwMg=="}, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzOTc2NDUyOnYy", "diffSide": "RIGHT", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxOToxMDowOVrOGyMG4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxOToxMDowOVrOGyMG4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI4MDM1Mg==", "bodyText": "The only difference in the if and else blocks is the method called right? The arguments are all the same? Instead of the isFromJson parameter can we not use something like a functional interface, which I believe is what @rdhananjaya also suggested once.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455280352", "createdAt": "2020-07-15T19:10:09Z", "author": {"login": "MaryamZi"}, "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "diffHunk": "@@ -299,17 +337,33 @@ private static boolean isConvertibleToRecordType(Object sourceValue, BRecordType\n             Map.Entry valueEntry = (Map.Entry) object;\n             String fieldName = valueEntry.getKey().toString();\n \n-            if (targetFieldTypes.containsKey(fieldName)) {\n-                if (getConvertibleTypes(valueEntry.getValue(), targetFieldTypes.get(fieldName),\n-                                        unresolvedValues).size() != 1) {\n+            if (isFromJson) {\n+                if (targetFieldTypes.containsKey(fieldName)) {\n+                    if (getConvertibleTypesFromJson(valueEntry.getValue(), targetFieldTypes.get(fieldName),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzOTgzMzEyOnYy", "diffSide": "RIGHT", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonStringWithType.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxOToyOTozMlrOGyMw-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwNjozMDozNFrOGyb5JA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5MTEyOQ==", "bodyText": "We need to check if the target type is nilable.\nThe folowing crashes.\ntype IntMap map<int>;\n\npublic function main() {\n    string s = \"null\";\n\n    map<int> m = checkpanic s.fromJsonStringWithType(IntMap); // doesn't panic\n\n    int i = m.get(\"first\");\n}\nThe get fails with an NPE in the internal log.\n[2020-07-16 00:57:59,786] SEVERE {b7a.log.crash} - null \njava.lang.NullPointerException\n\tat org.ballerinalang.langlib.map.Get.get(Get.java:45)\n\tat ballerina.lang_map.1_1_0.map.get(map.bal:51)\n\tat qwe.main(qwe.bal:8)\n\tat ___init.$lambda$main$(.)\n\tat org.ballerinalang.jvm.scheduling.SchedulerItem.execute(Scheduler.java:500)\n\tat org.ballerinalang.jvm.scheduling.Scheduler.run(Scheduler.java:276)\n\tat org.ballerinalang.jvm.scheduling.Scheduler.runSafely(Scheduler.java:244)\n\tat java.lang.Thread.run(Thread.java:745)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455291129", "createdAt": "2020-07-15T19:29:32Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonStringWithType.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.JSONParser;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ * Converts a string in JSON format to a user-specified type.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonStringWithType\",\n+        args = {\n+                @Argument(name = \"str\", type = TypeKind.STRING),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonStringWithType {\n+\n+    public static Object fromJsonStringWithType(Strand strand, BString value, TypedescValue t) {\n+\n+        String str = value.getValue();\n+        if (str.equals(\"null\")) {\n+            return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5MjY0OQ==", "bodyText": "Do we need to special case \"null\" anyway? The JSONParser and FromJsonWithType.fromJsonWithType will handle this properly right?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455292649", "createdAt": "2020-07-15T19:32:23Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonStringWithType.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.JSONParser;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ * Converts a string in JSON format to a user-specified type.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonStringWithType\",\n+        args = {\n+                @Argument(name = \"str\", type = TypeKind.STRING),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonStringWithType {\n+\n+    public static Object fromJsonStringWithType(Strand strand, BString value, TypedescValue t) {\n+\n+        String str = value.getValue();\n+        if (str.equals(\"null\")) {\n+            return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5MTEyOQ=="}, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTUzODk4MA==", "bodyText": "Ack.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455538980", "createdAt": "2020-07-16T06:30:34Z", "author": {"login": "dulajdilshan"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonStringWithType.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.JSONParser;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ * Converts a string in JSON format to a user-specified type.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonStringWithType\",\n+        args = {\n+                @Argument(name = \"str\", type = TypeKind.STRING),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonStringWithType {\n+\n+    public static Object fromJsonStringWithType(Strand strand, BString value, TypedescValue t) {\n+\n+        String str = value.getValue();\n+        if (str.equals(\"null\")) {\n+            return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5MTEyOQ=="}, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzOTg2ODM3OnYy", "diffSide": "RIGHT", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxOTo0MDoxN1rOGyNG1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwNjo0MToxOFrOGycK1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5NjcyNQ==", "bodyText": "A json value can never hold an error. Do we need this case?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455296725", "createdAt": "2020-07-15T19:40:17Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU0MzUxMQ==", "bodyText": "Ack", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455543511", "createdAt": "2020-07-16T06:41:18Z", "author": {"login": "dulajdilshan"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5NjcyNQ=="}, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzOTk2OTYwOnYy", "diffSide": "RIGHT", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMDoxMDozM1rOGyOF0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwNjo1NjoyNFrOGycmnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxMjg0OA==", "bodyText": "Can't we use org.ballerinalang.jvm.types.TypeTags#isXMLTypeTag here instead?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455312848", "createdAt": "2020-07-15T20:10:33Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU1MDYyMw==", "bodyText": "Sure", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455550623", "createdAt": "2020-07-16T06:56:24Z", "author": {"login": "dulajdilshan"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxMjg0OA=="}, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MDAxMDQ4OnYy", "diffSide": "RIGHT", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMDoyMjozOVrOGyOe0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwNzoxMDowNFrOGydAMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxOTI0OQ==", "bodyText": "We should move this out of the for loop, or we'll be extracting the constraint per entry.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455319249", "createdAt": "2020-07-15T20:22:39Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {\n+                    try {\n+                        newValue = XMLFactory.parse(((StringValue) value).getValue());\n+                        break;\n+                    } catch (Throwable e) {\n+                        throw createConversionError(value, targetType, e.getMessage());\n+                    }\n+                }\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                    break;\n+                }\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMap(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                     TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU1NzE3MA==", "bodyText": "Ack", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455557170", "createdAt": "2020-07-16T07:10:04Z", "author": {"login": "dulajdilshan"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {\n+                    try {\n+                        newValue = XMLFactory.parse(((StringValue) value).getValue());\n+                        break;\n+                    } catch (Throwable e) {\n+                        throw createConversionError(value, targetType, e.getMessage());\n+                    }\n+                }\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                    break;\n+                }\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMap(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                     TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxOTI0OQ=="}, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 167}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MDAyMTk5OnYy", "diffSide": "RIGHT", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMDoyNjowMVrOGyOl3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwODozNDoyMlrOGygvvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyMTA1Mg==", "bodyText": "This also we don't need right?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455321052", "createdAt": "2020-07-15T20:26:01Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {\n+                    try {\n+                        newValue = XMLFactory.parse(((StringValue) value).getValue());\n+                        break;\n+                    } catch (Throwable e) {\n+                        throw createConversionError(value, targetType, e.getMessage());\n+                    }\n+                }\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                    break;\n+                }\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMap(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                     TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();\n+                    putToMap(newMap, entry, constraintType, unresolvedValues, t, strand);\n+                }\n+                return newMap;\n+            case TypeTags.RECORD_TYPE_TAG:\n+                BRecordType recordType = (BRecordType) targetType;\n+                MapValueImpl<BString, Object> newRecord;\n+                if (t != null && t.getDescribingType() == targetType) {\n+                    newRecord = (MapValueImpl<BString, Object>) t.instantiate(strand);\n+                } else {\n+                    newRecord = (MapValueImpl<BString, Object>) BallerinaValues\n+                            .createRecordValue(recordType.getPackage(), recordType.getName());\n+                }\n+\n+                BType restFieldType = recordType.restFieldType;\n+                Map<String, BType> targetTypeField = new HashMap<>();\n+                for (BField field : recordType.getFields().values()) {\n+                    targetTypeField.put(field.getFieldName(), field.getFieldType());\n+                }\n+\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType fieldType = targetTypeField.getOrDefault(entry.getKey().toString(), restFieldType);\n+                    putToMap(newRecord, entry, fieldType, unresolvedValues, t, strand);\n+                }\n+                return newRecord;\n+            case TypeTags.JSON_TAG:\n+                BType matchingType = TypeConverter.resolveMatchingTypeForUnion(map, targetType);\n+                return convert(map, matchingType, unresolvedValues, t, strand);\n+            default:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 195}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYxODQ5NQ==", "bodyText": "Ack", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455618495", "createdAt": "2020-07-16T08:34:22Z", "author": {"login": "dulajdilshan"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {\n+                    try {\n+                        newValue = XMLFactory.parse(((StringValue) value).getValue());\n+                        break;\n+                    } catch (Throwable e) {\n+                        throw createConversionError(value, targetType, e.getMessage());\n+                    }\n+                }\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                    break;\n+                }\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMap(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                     TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();\n+                    putToMap(newMap, entry, constraintType, unresolvedValues, t, strand);\n+                }\n+                return newMap;\n+            case TypeTags.RECORD_TYPE_TAG:\n+                BRecordType recordType = (BRecordType) targetType;\n+                MapValueImpl<BString, Object> newRecord;\n+                if (t != null && t.getDescribingType() == targetType) {\n+                    newRecord = (MapValueImpl<BString, Object>) t.instantiate(strand);\n+                } else {\n+                    newRecord = (MapValueImpl<BString, Object>) BallerinaValues\n+                            .createRecordValue(recordType.getPackage(), recordType.getName());\n+                }\n+\n+                BType restFieldType = recordType.restFieldType;\n+                Map<String, BType> targetTypeField = new HashMap<>();\n+                for (BField field : recordType.getFields().values()) {\n+                    targetTypeField.put(field.getFieldName(), field.getFieldType());\n+                }\n+\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType fieldType = targetTypeField.getOrDefault(entry.getKey().toString(), restFieldType);\n+                    putToMap(newRecord, entry, fieldType, unresolvedValues, t, strand);\n+                }\n+                return newRecord;\n+            case TypeTags.JSON_TAG:\n+                BType matchingType = TypeConverter.resolveMatchingTypeForUnion(map, targetType);\n+                return convert(map, matchingType, unresolvedValues, t, strand);\n+            default:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyMTA1Mg=="}, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 195}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MDAzMjgxOnYy", "diffSide": "RIGHT", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMDoyOToxN1rOGyOsoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMDo1OToyN1rOGyl5Fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyMjc4NA==", "bodyText": "Better to pass the targetType itself instead of BTypes.typeJSON since it could be json & readonly.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455322784", "createdAt": "2020-07-15T20:29:17Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {\n+                    try {\n+                        newValue = XMLFactory.parse(((StringValue) value).getValue());\n+                        break;\n+                    } catch (Throwable e) {\n+                        throw createConversionError(value, targetType, e.getMessage());\n+                    }\n+                }\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                    break;\n+                }\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMap(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                     TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();\n+                    putToMap(newMap, entry, constraintType, unresolvedValues, t, strand);\n+                }\n+                return newMap;\n+            case TypeTags.RECORD_TYPE_TAG:\n+                BRecordType recordType = (BRecordType) targetType;\n+                MapValueImpl<BString, Object> newRecord;\n+                if (t != null && t.getDescribingType() == targetType) {\n+                    newRecord = (MapValueImpl<BString, Object>) t.instantiate(strand);\n+                } else {\n+                    newRecord = (MapValueImpl<BString, Object>) BallerinaValues\n+                            .createRecordValue(recordType.getPackage(), recordType.getName());\n+                }\n+\n+                BType restFieldType = recordType.restFieldType;\n+                Map<String, BType> targetTypeField = new HashMap<>();\n+                for (BField field : recordType.getFields().values()) {\n+                    targetTypeField.put(field.getFieldName(), field.getFieldType());\n+                }\n+\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType fieldType = targetTypeField.getOrDefault(entry.getKey().toString(), restFieldType);\n+                    putToMap(newRecord, entry, fieldType, unresolvedValues, t, strand);\n+                }\n+                return newRecord;\n+            case TypeTags.JSON_TAG:\n+                BType matchingType = TypeConverter.resolveMatchingTypeForUnion(map, targetType);\n+                return convert(map, matchingType, unresolvedValues, t, strand);\n+            default:\n+                break;\n+        }\n+        // should never reach here\n+        throw BallerinaErrors.createConversionError(map, targetType);\n+    }\n+\n+\n+    private static Object convertArray(ArrayValue array, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                       TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.ARRAY_TAG:\n+                BArrayType arrayType = (BArrayType) targetType;\n+                ArrayValueImpl newArray = new ArrayValueImpl(arrayType);\n+                for (int i = 0; i < array.size(); i++) {\n+                    Object newValue = convert(array.get(i), arrayType.getElementType(), unresolvedValues, t, strand);\n+                    newArray.add(i, newValue);\n+                }\n+                return newArray;\n+            case TypeTags.TUPLE_TAG:\n+                BTupleType tupleType = (BTupleType) targetType;\n+                TupleValueImpl newTuple = new TupleValueImpl(tupleType);\n+                int minLen = tupleType.getTupleTypes().size();\n+                for (int i = 0; i < array.size(); i++) {\n+                    BType elementType = (i < minLen) ? tupleType.getTupleTypes().get(i) : tupleType.getRestType();\n+                    Object newValue = convert(array.get(i), elementType, unresolvedValues, t, strand);\n+                    newTuple.add(i, newValue);\n+                }\n+                return newTuple;\n+            case TypeTags.JSON_TAG:\n+                newArray = new ArrayValueImpl((BArrayType) BTypes.typeJsonArray);\n+                for (int i = 0; i < array.size(); i++) {\n+                    Object newValue = convert(array.get(i), BTypes.typeJSON, unresolvedValues, t, strand);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 227}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTcwMjgwNw==", "bodyText": "ok", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455702807", "createdAt": "2020-07-16T10:59:27Z", "author": {"login": "dulajdilshan"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {\n+                    try {\n+                        newValue = XMLFactory.parse(((StringValue) value).getValue());\n+                        break;\n+                    } catch (Throwable e) {\n+                        throw createConversionError(value, targetType, e.getMessage());\n+                    }\n+                }\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                    break;\n+                }\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMap(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                     TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();\n+                    putToMap(newMap, entry, constraintType, unresolvedValues, t, strand);\n+                }\n+                return newMap;\n+            case TypeTags.RECORD_TYPE_TAG:\n+                BRecordType recordType = (BRecordType) targetType;\n+                MapValueImpl<BString, Object> newRecord;\n+                if (t != null && t.getDescribingType() == targetType) {\n+                    newRecord = (MapValueImpl<BString, Object>) t.instantiate(strand);\n+                } else {\n+                    newRecord = (MapValueImpl<BString, Object>) BallerinaValues\n+                            .createRecordValue(recordType.getPackage(), recordType.getName());\n+                }\n+\n+                BType restFieldType = recordType.restFieldType;\n+                Map<String, BType> targetTypeField = new HashMap<>();\n+                for (BField field : recordType.getFields().values()) {\n+                    targetTypeField.put(field.getFieldName(), field.getFieldType());\n+                }\n+\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType fieldType = targetTypeField.getOrDefault(entry.getKey().toString(), restFieldType);\n+                    putToMap(newRecord, entry, fieldType, unresolvedValues, t, strand);\n+                }\n+                return newRecord;\n+            case TypeTags.JSON_TAG:\n+                BType matchingType = TypeConverter.resolveMatchingTypeForUnion(map, targetType);\n+                return convert(map, matchingType, unresolvedValues, t, strand);\n+            default:\n+                break;\n+        }\n+        // should never reach here\n+        throw BallerinaErrors.createConversionError(map, targetType);\n+    }\n+\n+\n+    private static Object convertArray(ArrayValue array, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                       TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.ARRAY_TAG:\n+                BArrayType arrayType = (BArrayType) targetType;\n+                ArrayValueImpl newArray = new ArrayValueImpl(arrayType);\n+                for (int i = 0; i < array.size(); i++) {\n+                    Object newValue = convert(array.get(i), arrayType.getElementType(), unresolvedValues, t, strand);\n+                    newArray.add(i, newValue);\n+                }\n+                return newArray;\n+            case TypeTags.TUPLE_TAG:\n+                BTupleType tupleType = (BTupleType) targetType;\n+                TupleValueImpl newTuple = new TupleValueImpl(tupleType);\n+                int minLen = tupleType.getTupleTypes().size();\n+                for (int i = 0; i < array.size(); i++) {\n+                    BType elementType = (i < minLen) ? tupleType.getTupleTypes().get(i) : tupleType.getRestType();\n+                    Object newValue = convert(array.get(i), elementType, unresolvedValues, t, strand);\n+                    newTuple.add(i, newValue);\n+                }\n+                return newTuple;\n+            case TypeTags.JSON_TAG:\n+                newArray = new ArrayValueImpl((BArrayType) BTypes.typeJsonArray);\n+                for (int i = 0; i < array.size(); i++) {\n+                    Object newValue = convert(array.get(i), BTypes.typeJSON, unresolvedValues, t, strand);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyMjc4NA=="}, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 227}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MDAzOTE3OnYy", "diffSide": "RIGHT", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMDozMToxMlrOGyOwnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMDo1MzozNlrOGyltPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyMzgwNw==", "bodyText": "Why do we create a new type?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455323807", "createdAt": "2020-07-15T20:31:12Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {\n+                    try {\n+                        newValue = XMLFactory.parse(((StringValue) value).getValue());\n+                        break;\n+                    } catch (Throwable e) {\n+                        throw createConversionError(value, targetType, e.getMessage());\n+                    }\n+                }\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                    break;\n+                }\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMap(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                     TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();\n+                    putToMap(newMap, entry, constraintType, unresolvedValues, t, strand);\n+                }\n+                return newMap;\n+            case TypeTags.RECORD_TYPE_TAG:\n+                BRecordType recordType = (BRecordType) targetType;\n+                MapValueImpl<BString, Object> newRecord;\n+                if (t != null && t.getDescribingType() == targetType) {\n+                    newRecord = (MapValueImpl<BString, Object>) t.instantiate(strand);\n+                } else {\n+                    newRecord = (MapValueImpl<BString, Object>) BallerinaValues\n+                            .createRecordValue(recordType.getPackage(), recordType.getName());\n+                }\n+\n+                BType restFieldType = recordType.restFieldType;\n+                Map<String, BType> targetTypeField = new HashMap<>();\n+                for (BField field : recordType.getFields().values()) {\n+                    targetTypeField.put(field.getFieldName(), field.getFieldType());\n+                }\n+\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType fieldType = targetTypeField.getOrDefault(entry.getKey().toString(), restFieldType);\n+                    putToMap(newRecord, entry, fieldType, unresolvedValues, t, strand);\n+                }\n+                return newRecord;\n+            case TypeTags.JSON_TAG:\n+                BType matchingType = TypeConverter.resolveMatchingTypeForUnion(map, targetType);\n+                return convert(map, matchingType, unresolvedValues, t, strand);\n+            default:\n+                break;\n+        }\n+        // should never reach here\n+        throw BallerinaErrors.createConversionError(map, targetType);\n+    }\n+\n+\n+    private static Object convertArray(ArrayValue array, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                       TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.ARRAY_TAG:\n+                BArrayType arrayType = (BArrayType) targetType;\n+                ArrayValueImpl newArray = new ArrayValueImpl(arrayType);\n+                for (int i = 0; i < array.size(); i++) {\n+                    Object newValue = convert(array.get(i), arrayType.getElementType(), unresolvedValues, t, strand);\n+                    newArray.add(i, newValue);\n+                }\n+                return newArray;\n+            case TypeTags.TUPLE_TAG:\n+                BTupleType tupleType = (BTupleType) targetType;\n+                TupleValueImpl newTuple = new TupleValueImpl(tupleType);\n+                int minLen = tupleType.getTupleTypes().size();\n+                for (int i = 0; i < array.size(); i++) {\n+                    BType elementType = (i < minLen) ? tupleType.getTupleTypes().get(i) : tupleType.getRestType();\n+                    Object newValue = convert(array.get(i), elementType, unresolvedValues, t, strand);\n+                    newTuple.add(i, newValue);\n+                }\n+                return newTuple;\n+            case TypeTags.JSON_TAG:\n+                newArray = new ArrayValueImpl((BArrayType) BTypes.typeJsonArray);\n+                for (int i = 0; i < array.size(); i++) {\n+                    Object newValue = convert(array.get(i), BTypes.typeJSON, unresolvedValues, t, strand);\n+                    newArray.add(i, newValue);\n+                }\n+                return newArray;\n+            case TypeTags.TABLE_TAG:\n+                BTableType tableType = (BTableType) targetType;\n+\n+                BTableType newTableType = new BTableType(tableType.getConstrainedType(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY5OTc3Mw==", "bodyText": "Removed", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455699773", "createdAt": "2020-07-16T10:53:36Z", "author": {"login": "dulajdilshan"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {\n+                    try {\n+                        newValue = XMLFactory.parse(((StringValue) value).getValue());\n+                        break;\n+                    } catch (Throwable e) {\n+                        throw createConversionError(value, targetType, e.getMessage());\n+                    }\n+                }\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                    break;\n+                }\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMap(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                     TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();\n+                    putToMap(newMap, entry, constraintType, unresolvedValues, t, strand);\n+                }\n+                return newMap;\n+            case TypeTags.RECORD_TYPE_TAG:\n+                BRecordType recordType = (BRecordType) targetType;\n+                MapValueImpl<BString, Object> newRecord;\n+                if (t != null && t.getDescribingType() == targetType) {\n+                    newRecord = (MapValueImpl<BString, Object>) t.instantiate(strand);\n+                } else {\n+                    newRecord = (MapValueImpl<BString, Object>) BallerinaValues\n+                            .createRecordValue(recordType.getPackage(), recordType.getName());\n+                }\n+\n+                BType restFieldType = recordType.restFieldType;\n+                Map<String, BType> targetTypeField = new HashMap<>();\n+                for (BField field : recordType.getFields().values()) {\n+                    targetTypeField.put(field.getFieldName(), field.getFieldType());\n+                }\n+\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType fieldType = targetTypeField.getOrDefault(entry.getKey().toString(), restFieldType);\n+                    putToMap(newRecord, entry, fieldType, unresolvedValues, t, strand);\n+                }\n+                return newRecord;\n+            case TypeTags.JSON_TAG:\n+                BType matchingType = TypeConverter.resolveMatchingTypeForUnion(map, targetType);\n+                return convert(map, matchingType, unresolvedValues, t, strand);\n+            default:\n+                break;\n+        }\n+        // should never reach here\n+        throw BallerinaErrors.createConversionError(map, targetType);\n+    }\n+\n+\n+    private static Object convertArray(ArrayValue array, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                       TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.ARRAY_TAG:\n+                BArrayType arrayType = (BArrayType) targetType;\n+                ArrayValueImpl newArray = new ArrayValueImpl(arrayType);\n+                for (int i = 0; i < array.size(); i++) {\n+                    Object newValue = convert(array.get(i), arrayType.getElementType(), unresolvedValues, t, strand);\n+                    newArray.add(i, newValue);\n+                }\n+                return newArray;\n+            case TypeTags.TUPLE_TAG:\n+                BTupleType tupleType = (BTupleType) targetType;\n+                TupleValueImpl newTuple = new TupleValueImpl(tupleType);\n+                int minLen = tupleType.getTupleTypes().size();\n+                for (int i = 0; i < array.size(); i++) {\n+                    BType elementType = (i < minLen) ? tupleType.getTupleTypes().get(i) : tupleType.getRestType();\n+                    Object newValue = convert(array.get(i), elementType, unresolvedValues, t, strand);\n+                    newTuple.add(i, newValue);\n+                }\n+                return newTuple;\n+            case TypeTags.JSON_TAG:\n+                newArray = new ArrayValueImpl((BArrayType) BTypes.typeJsonArray);\n+                for (int i = 0; i < array.size(); i++) {\n+                    Object newValue = convert(array.get(i), BTypes.typeJSON, unresolvedValues, t, strand);\n+                    newArray.add(i, newValue);\n+                }\n+                return newArray;\n+            case TypeTags.TABLE_TAG:\n+                BTableType tableType = (BTableType) targetType;\n+\n+                BTableType newTableType = new BTableType(tableType.getConstrainedType(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyMzgwNw=="}, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 234}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MDEyMjYyOnYy", "diffSide": "RIGHT", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMDo1NTo1N1rOGyPjjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMToyODozMVrOGymxTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMzNjg0Ng==", "bodyText": "Do we ever reach here? All the numeric basic types are both anydata and json. So, I don't think you'll ever have to do a numeric conversion?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455336846", "createdAt": "2020-07-15T20:55:57Z", "author": {"login": "MaryamZi"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        try {\n+            return convert(value, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        BType jsonType = BTypes.typeJSON;\n+\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+            if (TypeChecker.checkIsType(value, jsonType)) {\n+                return value;\n+            } else {\n+                // Has to be a numeric conversion.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTcxNzE5OQ==", "bodyText": "Got it", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455717199", "createdAt": "2020-07-16T11:28:31Z", "author": {"login": "dulajdilshan"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        try {\n+            return convert(value, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        BType jsonType = BTypes.typeJSON;\n+\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+            if (TypeChecker.checkIsType(value, jsonType)) {\n+                return value;\n+            } else {\n+                // Has to be a numeric conversion.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMzNjg0Ng=="}, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MTg4MzE1OnYy", "diffSide": "RIGHT", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwODoyMDoxN1rOGygNgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMTozNjo0NVrOGynBYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYwOTcyOQ==", "bodyText": "Do we need this null check here? t can never be null right?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455609729", "createdAt": "2020-07-16T08:20:17Z", "author": {"login": "pubudu91"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {\n+                    try {\n+                        newValue = XMLFactory.parse(((StringValue) value).getValue());\n+                        break;\n+                    } catch (Throwable e) {\n+                        throw createConversionError(value, targetType, e.getMessage());\n+                    }\n+                }\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                    break;\n+                }\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMap(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                     TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();\n+                    putToMap(newMap, entry, constraintType, unresolvedValues, t, strand);\n+                }\n+                return newMap;\n+            case TypeTags.RECORD_TYPE_TAG:\n+                BRecordType recordType = (BRecordType) targetType;\n+                MapValueImpl<BString, Object> newRecord;\n+                if (t != null && t.getDescribingType() == targetType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTcyMTMxNA==", "bodyText": "Ack", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455721314", "createdAt": "2020-07-16T11:36:45Z", "author": {"login": "dulajdilshan"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {\n+                    try {\n+                        newValue = XMLFactory.parse(((StringValue) value).getValue());\n+                        break;\n+                    } catch (Throwable e) {\n+                        throw createConversionError(value, targetType, e.getMessage());\n+                    }\n+                }\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                    break;\n+                }\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMap(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                     TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();\n+                    putToMap(newMap, entry, constraintType, unresolvedValues, t, strand);\n+                }\n+                return newMap;\n+            case TypeTags.RECORD_TYPE_TAG:\n+                BRecordType recordType = (BRecordType) targetType;\n+                MapValueImpl<BString, Object> newRecord;\n+                if (t != null && t.getDescribingType() == targetType) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYwOTcyOQ=="}, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 174}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MTk0MDk0OnYy", "diffSide": "RIGHT", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwODozNDo0MVrOGygwhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNTowNjowMlrOGyvX9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYxODY5NA==", "bodyText": "Is there a need to pass both t and describingType?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455618694", "createdAt": "2020-07-16T08:34:41Z", "author": {"login": "pubudu91"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTc3Nzg5NA==", "bodyText": "I followed the same implementation as in the cloneWithType.\nconvert method is get called later. Sometimes, t and targetType both are  needed", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455777894", "createdAt": "2020-07-16T13:17:47Z", "author": {"login": "dulajdilshan"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYxODY5NA=="}, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg1ODE2Ng==", "bodyText": "My point was if you have t, you can always get the type from it. Anyways, not a major issue. Just gives the impression that target type can be some other type than what's described by t", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455858166", "createdAt": "2020-07-16T15:06:02Z", "author": {"login": "pubudu91"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYxODY5NA=="}, "originalCommit": {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MzQ4MTUwOnYy", "diffSide": "RIGHT", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonStringWithType.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNToxMDoxMlrOGyvj6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNToxMDoxMlrOGyvj6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg2MTIyNQ==", "bodyText": "I think what @MaryamZi meant was to simply pass str to the JSON parser without special casing \"null\".", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455861225", "createdAt": "2020-07-16T15:10:12Z", "author": {"login": "pubudu91"}, "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonStringWithType.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.JSONParser;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ * Converts a string in JSON format to a user-specified type.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonStringWithType\",\n+        args = {\n+                @Argument(name = \"str\", type = TypeKind.STRING),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonStringWithType {\n+\n+    public static Object fromJsonStringWithType(Strand strand, BString value, TypedescValue t) {\n+\n+        String str = value.getValue();\n+        try {\n+            if (str.equals(\"null\")) {\n+                return FromJsonWithType.fromJsonWithType(strand, null, t);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "344e13a81c953c6fc2e2b7af0d156eba0227532d"}, "originalPosition": 62}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3374, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}