{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkzMjYzODA4", "number": 26113, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDoxNDo0N1rOEv9ZBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDoxNDo0N1rOEv9ZBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzI0MzU3OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/IsolationAnalyzer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDoxNDo0N1rOHlPS-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDoxNDo0N1rOHlPS-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgwOTk3Ng==", "bodyText": "Can we break this logic into multiple methods?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26113#discussion_r508809976", "createdAt": "2020-10-20T20:14:47Z", "author": {"login": "hasithaa"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/IsolationAnalyzer.java", "diffHunk": "@@ -1372,11 +1412,333 @@ private void analyzeInvocation(BLangInvocation invocationExpr) {\n             }\n         }\n \n-        if (isObjectFieldDefaultValueRequiringIsolation(env)) {\n+        if (objectFieldDefaultValueRequiringIsolation) {\n             dlog.error(invocationExpr.pos, DiagnosticCode.INVALID_NON_ISOLATED_INVOCATION_AS_OBJECT_DEFAULT);\n         }\n     }\n \n+    private void analyzeArgs(List<BLangExpression> requiredArgs, List<BLangExpression> restArgs) {\n+        List<BLangExpression> args = new ArrayList<>(requiredArgs);\n+        args.addAll(restArgs);\n+        for (BLangExpression argExpr : args) {\n+            analyzeNode(argExpr, env);\n+        }\n+    }\n+\n+    private void analyzeAndSetArrowFuncFlagForIsolatedParamArg(BLangExpression arg) {\n+        if (arg.getKind() == NodeKind.REST_ARGS_EXPR) {\n+            BLangExpression expr = ((BLangRestArgsExpression) arg).expr;\n+            if (expr.getKind() != NodeKind.LIST_CONSTRUCTOR_EXPR) {\n+                analyzeNode(arg, env);\n+                return;\n+            }\n+\n+            for (BLangExpression expression : ((BLangListConstructorExpr) expr).exprs) {\n+                analyzeAndSetArrowFuncFlagForIsolatedParamArg(expression);\n+            }\n+            return;\n+        }\n+\n+        boolean namedArg = arg.getKind() == NodeKind.NAMED_ARGS_EXPR;\n+        BLangExpression argExpr = namedArg ? ((BLangNamedArgsExpression) arg).expr : arg;\n+\n+        if (argExpr.getKind() != NodeKind.ARROW_EXPR) {\n+            analyzeNode(argExpr, env);\n+            return;\n+        }\n+\n+        boolean prevInferredIsolatedness = this.inferredIsolated;\n+        this.inferredIsolated = true;\n+\n+        analyzeNode(argExpr, env);\n+\n+        if (this.inferredIsolated) {\n+            BInvokableType invokableType = (BInvokableType) argExpr.type;\n+            BInvokableTypeSymbol tsymbol = (BInvokableTypeSymbol) invokableType.tsymbol;\n+\n+            BInvokableTypeSymbol dupInvokableTypeSymbol = new BInvokableTypeSymbol(tsymbol.tag,\n+                                                                                   tsymbol.flags | Flags.ISOLATED,\n+                                                                                   tsymbol.pkgID, null, tsymbol.owner,\n+                                                                                   tsymbol.pos, tsymbol.origin);\n+            BInvokableType dupInvokableType = new BInvokableType(invokableType.paramTypes, invokableType.restType,\n+                                                                 invokableType.retType, dupInvokableTypeSymbol);\n+            dupInvokableType.flags |= Flags.ISOLATED;\n+            dupInvokableTypeSymbol.type = dupInvokableType;\n+            argExpr.type = dupInvokableType;\n+\n+            if (namedArg) {\n+                arg.type = dupInvokableType;\n+            }\n+        }\n+        this.inferredIsolated = prevInferredIsolatedness && this.inferredIsolated;\n+    }\n+\n+    private void analyzeArgIsolatedness(List<BLangExpression> requiredArgs, List<BLangExpression> restArgs,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a835a7a6720c035a343db5ad08846e916a19c3b"}, "originalPosition": 189}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 49, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}