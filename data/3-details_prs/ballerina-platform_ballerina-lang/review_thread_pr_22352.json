{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk2NDA3MDA3", "number": 22352, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMDoxODowMVrODvfpaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMDozNzozN1rODvgECg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMTI4MTY5OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMDoxODowMVrOGB8zgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMDoxODowMVrOGB8zgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY5Nzk4NA==", "bodyText": "restArgs.get(restArgs.size() - 1)\nI think we can extract this or related logic to a variable. This is used multiple times. This will simplify the code increasing readability.\nL5083, L5088, L5098, L5115 (condition)", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22352#discussion_r404697984", "createdAt": "2020-04-07T10:18:01Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5065,36 +5071,154 @@ private void reorderArguments(BLangInvocation iExpr) {\n         }\n \n         BInvokableSymbol invokableSymbol = (BInvokableSymbol) symbol;\n+\n+        List<BLangExpression> restArgs = iExpr.restArgs;\n+        int originalRequiredArgCount = iExpr.requiredArgs.size();\n+\n+        // Constructs used when the vararg provides args for required/defaultable params.\n+        BLangExpression varargRef = null;\n+        BLangBlockStmt blockStmt = null;\n+\n+        if (!iExpr.restArgs.isEmpty() &&\n+                restArgs.get(restArgs.size() - 1).getKind() == NodeKind.REST_ARGS_EXPR &&", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3de0504b70b2f24c86cb079c3baca7e5f2e45cc"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMTI4NDUyOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMDoxODo0N1rOGB81MA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwNTowMToyM1rOGCfDrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY5ODQxNg==", "bodyText": "Doesn't iExpr.restArgs already has an ArrayList ?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22352#discussion_r404698416", "createdAt": "2020-04-07T10:18:47Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5065,36 +5071,154 @@ private void reorderArguments(BLangInvocation iExpr) {\n         }\n \n         BInvokableSymbol invokableSymbol = (BInvokableSymbol) symbol;\n+\n+        List<BLangExpression> restArgs = iExpr.restArgs;\n+        int originalRequiredArgCount = iExpr.requiredArgs.size();\n+\n+        // Constructs used when the vararg provides args for required/defaultable params.\n+        BLangExpression varargRef = null;\n+        BLangBlockStmt blockStmt = null;\n+\n+        if (!iExpr.restArgs.isEmpty() &&\n+                restArgs.get(restArgs.size() - 1).getKind() == NodeKind.REST_ARGS_EXPR &&\n+                iExpr.requiredArgs.size() < invokableSymbol.params.size()) {\n+            // All or part of the args for the required and defaultable parameters are provided via the vararg.\n+            // We have to first evaluate the vararg's expression, define a variable, and pass a reference to it\n+            // to use for member access when adding such required arguments from the vararg.\n+            BLangExpression expr = ((BLangRestArgsExpression) restArgs.get(restArgs.size() - 1)).expr;\n+            DiagnosticPos varargExpPos = expr.pos;\n+            BType varargVarType = expr.type;\n+            String varargVarName = DESUGARED_VARARG_KEY + this.varargCount++;\n+\n+            BVarSymbol varargVarSymbol = new BVarSymbol(0, names.fromString(varargVarName), this.env.scope.owner.pkgID,\n+                                                        varargVarType, this.env.scope.owner);\n+            varargRef = ASTBuilderUtil.createVariableRef(varargExpPos, varargVarSymbol);\n+\n+            BLangSimpleVariable var = createVariable(varargExpPos, varargVarName, varargVarType,\n+                                                     ((BLangRestArgsExpression) restArgs.get(restArgs.size() - 1)).expr,\n+                                                     varargVarSymbol);\n+\n+            BLangSimpleVariableDef varDef = ASTBuilderUtil.createVariableDef(varargExpPos);\n+            varDef.var = var;\n+            varDef.type = varargVarType;\n+\n+            blockStmt = createBlockStmt(varargExpPos);\n+            blockStmt.stmts.add(varDef);\n+        }\n+\n         if (!invokableSymbol.params.isEmpty()) {\n             // Re-order the arguments\n-            reorderNamedArgs(iExpr, invokableSymbol);\n+            reorderNamedArgs(iExpr, invokableSymbol, varargRef);\n         }\n \n-        if (invokableSymbol.restParam == null) {\n+        // There are no rest args at all or args for the rest param are only given as individual args (i.e., no vararg).\n+        if (restArgs.isEmpty() || restArgs.get(restArgs.size() - 1).getKind() != NodeKind.REST_ARGS_EXPR) {\n+            if (invokableSymbol.restParam == null) {\n+                return;\n+            }\n+\n+            BLangArrayLiteral arrayLiteral = (BLangArrayLiteral) TreeBuilder.createArrayLiteralExpressionNode();\n+            List<BLangExpression> exprs = new ArrayList<>();\n+\n+            BArrayType arrayType = (BArrayType) invokableSymbol.restParam.type;\n+            BType elemType = arrayType.eType;\n+\n+            for (BLangExpression restArg : restArgs) {\n+                exprs.add(addConversionExprIfRequired(restArg, elemType));\n+            }\n+\n+            arrayLiteral.exprs = exprs;\n+            arrayLiteral.type = arrayType;\n+            iExpr.restArgs = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3de0504b70b2f24c86cb079c3baca7e5f2e45cc"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI1OTE4Mg==", "bodyText": "It does, but we want to overwrite it here. I've updated this to create a list only if it is not empty already.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22352#discussion_r405259182", "createdAt": "2020-04-08T05:01:23Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5065,36 +5071,154 @@ private void reorderArguments(BLangInvocation iExpr) {\n         }\n \n         BInvokableSymbol invokableSymbol = (BInvokableSymbol) symbol;\n+\n+        List<BLangExpression> restArgs = iExpr.restArgs;\n+        int originalRequiredArgCount = iExpr.requiredArgs.size();\n+\n+        // Constructs used when the vararg provides args for required/defaultable params.\n+        BLangExpression varargRef = null;\n+        BLangBlockStmt blockStmt = null;\n+\n+        if (!iExpr.restArgs.isEmpty() &&\n+                restArgs.get(restArgs.size() - 1).getKind() == NodeKind.REST_ARGS_EXPR &&\n+                iExpr.requiredArgs.size() < invokableSymbol.params.size()) {\n+            // All or part of the args for the required and defaultable parameters are provided via the vararg.\n+            // We have to first evaluate the vararg's expression, define a variable, and pass a reference to it\n+            // to use for member access when adding such required arguments from the vararg.\n+            BLangExpression expr = ((BLangRestArgsExpression) restArgs.get(restArgs.size() - 1)).expr;\n+            DiagnosticPos varargExpPos = expr.pos;\n+            BType varargVarType = expr.type;\n+            String varargVarName = DESUGARED_VARARG_KEY + this.varargCount++;\n+\n+            BVarSymbol varargVarSymbol = new BVarSymbol(0, names.fromString(varargVarName), this.env.scope.owner.pkgID,\n+                                                        varargVarType, this.env.scope.owner);\n+            varargRef = ASTBuilderUtil.createVariableRef(varargExpPos, varargVarSymbol);\n+\n+            BLangSimpleVariable var = createVariable(varargExpPos, varargVarName, varargVarType,\n+                                                     ((BLangRestArgsExpression) restArgs.get(restArgs.size() - 1)).expr,\n+                                                     varargVarSymbol);\n+\n+            BLangSimpleVariableDef varDef = ASTBuilderUtil.createVariableDef(varargExpPos);\n+            varDef.var = var;\n+            varDef.type = varargVarType;\n+\n+            blockStmt = createBlockStmt(varargExpPos);\n+            blockStmt.stmts.add(varDef);\n+        }\n+\n         if (!invokableSymbol.params.isEmpty()) {\n             // Re-order the arguments\n-            reorderNamedArgs(iExpr, invokableSymbol);\n+            reorderNamedArgs(iExpr, invokableSymbol, varargRef);\n         }\n \n-        if (invokableSymbol.restParam == null) {\n+        // There are no rest args at all or args for the rest param are only given as individual args (i.e., no vararg).\n+        if (restArgs.isEmpty() || restArgs.get(restArgs.size() - 1).getKind() != NodeKind.REST_ARGS_EXPR) {\n+            if (invokableSymbol.restParam == null) {\n+                return;\n+            }\n+\n+            BLangArrayLiteral arrayLiteral = (BLangArrayLiteral) TreeBuilder.createArrayLiteralExpressionNode();\n+            List<BLangExpression> exprs = new ArrayList<>();\n+\n+            BArrayType arrayType = (BArrayType) invokableSymbol.restParam.type;\n+            BType elemType = arrayType.eType;\n+\n+            for (BLangExpression restArg : restArgs) {\n+                exprs.add(addConversionExprIfRequired(restArg, elemType));\n+            }\n+\n+            arrayLiteral.exprs = exprs;\n+            arrayLiteral.type = arrayType;\n+            iExpr.restArgs = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY5ODQxNg=="}, "originalCommit": {"oid": "a3de0504b70b2f24c86cb079c3baca7e5f2e45cc"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMTI4ODQ4OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMDoxOTo0NlrOGB83gA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwNTowMjozOVrOGCfE-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY5OTAwOA==", "bodyText": "Do we need this exprs? It can directly be arrayLiteral.exprs", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22352#discussion_r404699008", "createdAt": "2020-04-07T10:19:46Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5065,36 +5071,154 @@ private void reorderArguments(BLangInvocation iExpr) {\n         }\n \n         BInvokableSymbol invokableSymbol = (BInvokableSymbol) symbol;\n+\n+        List<BLangExpression> restArgs = iExpr.restArgs;\n+        int originalRequiredArgCount = iExpr.requiredArgs.size();\n+\n+        // Constructs used when the vararg provides args for required/defaultable params.\n+        BLangExpression varargRef = null;\n+        BLangBlockStmt blockStmt = null;\n+\n+        if (!iExpr.restArgs.isEmpty() &&\n+                restArgs.get(restArgs.size() - 1).getKind() == NodeKind.REST_ARGS_EXPR &&\n+                iExpr.requiredArgs.size() < invokableSymbol.params.size()) {\n+            // All or part of the args for the required and defaultable parameters are provided via the vararg.\n+            // We have to first evaluate the vararg's expression, define a variable, and pass a reference to it\n+            // to use for member access when adding such required arguments from the vararg.\n+            BLangExpression expr = ((BLangRestArgsExpression) restArgs.get(restArgs.size() - 1)).expr;\n+            DiagnosticPos varargExpPos = expr.pos;\n+            BType varargVarType = expr.type;\n+            String varargVarName = DESUGARED_VARARG_KEY + this.varargCount++;\n+\n+            BVarSymbol varargVarSymbol = new BVarSymbol(0, names.fromString(varargVarName), this.env.scope.owner.pkgID,\n+                                                        varargVarType, this.env.scope.owner);\n+            varargRef = ASTBuilderUtil.createVariableRef(varargExpPos, varargVarSymbol);\n+\n+            BLangSimpleVariable var = createVariable(varargExpPos, varargVarName, varargVarType,\n+                                                     ((BLangRestArgsExpression) restArgs.get(restArgs.size() - 1)).expr,\n+                                                     varargVarSymbol);\n+\n+            BLangSimpleVariableDef varDef = ASTBuilderUtil.createVariableDef(varargExpPos);\n+            varDef.var = var;\n+            varDef.type = varargVarType;\n+\n+            blockStmt = createBlockStmt(varargExpPos);\n+            blockStmt.stmts.add(varDef);\n+        }\n+\n         if (!invokableSymbol.params.isEmpty()) {\n             // Re-order the arguments\n-            reorderNamedArgs(iExpr, invokableSymbol);\n+            reorderNamedArgs(iExpr, invokableSymbol, varargRef);\n         }\n \n-        if (invokableSymbol.restParam == null) {\n+        // There are no rest args at all or args for the rest param are only given as individual args (i.e., no vararg).\n+        if (restArgs.isEmpty() || restArgs.get(restArgs.size() - 1).getKind() != NodeKind.REST_ARGS_EXPR) {\n+            if (invokableSymbol.restParam == null) {\n+                return;\n+            }\n+\n+            BLangArrayLiteral arrayLiteral = (BLangArrayLiteral) TreeBuilder.createArrayLiteralExpressionNode();\n+            List<BLangExpression> exprs = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3de0504b70b2f24c86cb079c3baca7e5f2e45cc"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI1OTUxMg==", "bodyText": "Then we have to do in L5127\narrayLiteral.exprs.add(addConversionExprIfRequired(restArg, elemType));\n\nI'd rather complete the list and then set it.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22352#discussion_r405259512", "createdAt": "2020-04-08T05:02:39Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5065,36 +5071,154 @@ private void reorderArguments(BLangInvocation iExpr) {\n         }\n \n         BInvokableSymbol invokableSymbol = (BInvokableSymbol) symbol;\n+\n+        List<BLangExpression> restArgs = iExpr.restArgs;\n+        int originalRequiredArgCount = iExpr.requiredArgs.size();\n+\n+        // Constructs used when the vararg provides args for required/defaultable params.\n+        BLangExpression varargRef = null;\n+        BLangBlockStmt blockStmt = null;\n+\n+        if (!iExpr.restArgs.isEmpty() &&\n+                restArgs.get(restArgs.size() - 1).getKind() == NodeKind.REST_ARGS_EXPR &&\n+                iExpr.requiredArgs.size() < invokableSymbol.params.size()) {\n+            // All or part of the args for the required and defaultable parameters are provided via the vararg.\n+            // We have to first evaluate the vararg's expression, define a variable, and pass a reference to it\n+            // to use for member access when adding such required arguments from the vararg.\n+            BLangExpression expr = ((BLangRestArgsExpression) restArgs.get(restArgs.size() - 1)).expr;\n+            DiagnosticPos varargExpPos = expr.pos;\n+            BType varargVarType = expr.type;\n+            String varargVarName = DESUGARED_VARARG_KEY + this.varargCount++;\n+\n+            BVarSymbol varargVarSymbol = new BVarSymbol(0, names.fromString(varargVarName), this.env.scope.owner.pkgID,\n+                                                        varargVarType, this.env.scope.owner);\n+            varargRef = ASTBuilderUtil.createVariableRef(varargExpPos, varargVarSymbol);\n+\n+            BLangSimpleVariable var = createVariable(varargExpPos, varargVarName, varargVarType,\n+                                                     ((BLangRestArgsExpression) restArgs.get(restArgs.size() - 1)).expr,\n+                                                     varargVarSymbol);\n+\n+            BLangSimpleVariableDef varDef = ASTBuilderUtil.createVariableDef(varargExpPos);\n+            varDef.var = var;\n+            varDef.type = varargVarType;\n+\n+            blockStmt = createBlockStmt(varargExpPos);\n+            blockStmt.stmts.add(varDef);\n+        }\n+\n         if (!invokableSymbol.params.isEmpty()) {\n             // Re-order the arguments\n-            reorderNamedArgs(iExpr, invokableSymbol);\n+            reorderNamedArgs(iExpr, invokableSymbol, varargRef);\n         }\n \n-        if (invokableSymbol.restParam == null) {\n+        // There are no rest args at all or args for the rest param are only given as individual args (i.e., no vararg).\n+        if (restArgs.isEmpty() || restArgs.get(restArgs.size() - 1).getKind() != NodeKind.REST_ARGS_EXPR) {\n+            if (invokableSymbol.restParam == null) {\n+                return;\n+            }\n+\n+            BLangArrayLiteral arrayLiteral = (BLangArrayLiteral) TreeBuilder.createArrayLiteralExpressionNode();\n+            List<BLangExpression> exprs = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY5OTAwOA=="}, "originalCommit": {"oid": "a3de0504b70b2f24c86cb079c3baca7e5f2e45cc"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMTI5NTk5OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMDoyMTo0OFrOGB88Qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMDoyMTo0OFrOGB88Qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcwMDIyNw==", "bodyText": "iExpr.requiredArgs.size()is already extracted to variable originalRequiredArgCount", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22352#discussion_r404700227", "createdAt": "2020-04-07T10:21:48Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5065,36 +5071,154 @@ private void reorderArguments(BLangInvocation iExpr) {\n         }\n \n         BInvokableSymbol invokableSymbol = (BInvokableSymbol) symbol;\n+\n+        List<BLangExpression> restArgs = iExpr.restArgs;\n+        int originalRequiredArgCount = iExpr.requiredArgs.size();\n+\n+        // Constructs used when the vararg provides args for required/defaultable params.\n+        BLangExpression varargRef = null;\n+        BLangBlockStmt blockStmt = null;\n+\n+        if (!iExpr.restArgs.isEmpty() &&\n+                restArgs.get(restArgs.size() - 1).getKind() == NodeKind.REST_ARGS_EXPR &&\n+                iExpr.requiredArgs.size() < invokableSymbol.params.size()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3de0504b70b2f24c86cb079c3baca7e5f2e45cc"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMTM0NDMxOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMDozNTo1NFrOGB9asg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwNDo0NjoxMlrOGCe1NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcwODAxOA==", "bodyText": "Where does this change?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22352#discussion_r404708018", "createdAt": "2020-04-07T10:35:54Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5065,36 +5071,154 @@ private void reorderArguments(BLangInvocation iExpr) {\n         }\n \n         BInvokableSymbol invokableSymbol = (BInvokableSymbol) symbol;\n+\n+        List<BLangExpression> restArgs = iExpr.restArgs;\n+        int originalRequiredArgCount = iExpr.requiredArgs.size();\n+\n+        // Constructs used when the vararg provides args for required/defaultable params.\n+        BLangExpression varargRef = null;\n+        BLangBlockStmt blockStmt = null;\n+\n+        if (!iExpr.restArgs.isEmpty() &&\n+                restArgs.get(restArgs.size() - 1).getKind() == NodeKind.REST_ARGS_EXPR &&\n+                iExpr.requiredArgs.size() < invokableSymbol.params.size()) {\n+            // All or part of the args for the required and defaultable parameters are provided via the vararg.\n+            // We have to first evaluate the vararg's expression, define a variable, and pass a reference to it\n+            // to use for member access when adding such required arguments from the vararg.\n+            BLangExpression expr = ((BLangRestArgsExpression) restArgs.get(restArgs.size() - 1)).expr;\n+            DiagnosticPos varargExpPos = expr.pos;\n+            BType varargVarType = expr.type;\n+            String varargVarName = DESUGARED_VARARG_KEY + this.varargCount++;\n+\n+            BVarSymbol varargVarSymbol = new BVarSymbol(0, names.fromString(varargVarName), this.env.scope.owner.pkgID,\n+                                                        varargVarType, this.env.scope.owner);\n+            varargRef = ASTBuilderUtil.createVariableRef(varargExpPos, varargVarSymbol);\n+\n+            BLangSimpleVariable var = createVariable(varargExpPos, varargVarName, varargVarType,\n+                                                     ((BLangRestArgsExpression) restArgs.get(restArgs.size() - 1)).expr,\n+                                                     varargVarSymbol);\n+\n+            BLangSimpleVariableDef varDef = ASTBuilderUtil.createVariableDef(varargExpPos);\n+            varDef.var = var;\n+            varDef.type = varargVarType;\n+\n+            blockStmt = createBlockStmt(varargExpPos);\n+            blockStmt.stmts.add(varDef);\n+        }\n+\n         if (!invokableSymbol.params.isEmpty()) {\n             // Re-order the arguments\n-            reorderNamedArgs(iExpr, invokableSymbol);\n+            reorderNamedArgs(iExpr, invokableSymbol, varargRef);\n         }\n \n-        if (invokableSymbol.restParam == null) {\n+        // There are no rest args at all or args for the rest param are only given as individual args (i.e., no vararg).\n+        if (restArgs.isEmpty() || restArgs.get(restArgs.size() - 1).getKind() != NodeKind.REST_ARGS_EXPR) {\n+            if (invokableSymbol.restParam == null) {\n+                return;\n+            }\n+\n+            BLangArrayLiteral arrayLiteral = (BLangArrayLiteral) TreeBuilder.createArrayLiteralExpressionNode();\n+            List<BLangExpression> exprs = new ArrayList<>();\n+\n+            BArrayType arrayType = (BArrayType) invokableSymbol.restParam.type;\n+            BType elemType = arrayType.eType;\n+\n+            for (BLangExpression restArg : restArgs) {\n+                exprs.add(addConversionExprIfRequired(restArg, elemType));\n+            }\n+\n+            arrayLiteral.exprs = exprs;\n+            arrayLiteral.type = arrayType;\n+            iExpr.restArgs = new ArrayList<>();\n+            iExpr.restArgs.add(arrayLiteral);\n             return;\n         }\n \n-        // Create an array out of all the rest arguments, and pass it as a single argument.\n-        // If there is only one optional argument and its type is restArg (i.e: ...x), then\n-        // leave it as is.\n-        if (iExpr.restArgs.size() == 1 && iExpr.restArgs.get(0).getKind() == NodeKind.REST_ARGS_EXPR) {\n+        // There are no individual rest args, but there is a single vararg.\n+        if (restArgs.size() == 1 && restArgs.get(0).getKind() == NodeKind.REST_ARGS_EXPR) {\n+\n+            // If the number of expressions in `iExpr.requiredArgs` hasn't changed, the vararg only contained\n+            // arguments for the rest parameter.\n+            if (iExpr.requiredArgs.size() == originalRequiredArgCount) {\n+                return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3de0504b70b2f24c86cb079c3baca7e5f2e45cc"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI1NTQ3Ng==", "bodyText": "In reorderNamedArgs.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22352#discussion_r405255476", "createdAt": "2020-04-08T04:46:12Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5065,36 +5071,154 @@ private void reorderArguments(BLangInvocation iExpr) {\n         }\n \n         BInvokableSymbol invokableSymbol = (BInvokableSymbol) symbol;\n+\n+        List<BLangExpression> restArgs = iExpr.restArgs;\n+        int originalRequiredArgCount = iExpr.requiredArgs.size();\n+\n+        // Constructs used when the vararg provides args for required/defaultable params.\n+        BLangExpression varargRef = null;\n+        BLangBlockStmt blockStmt = null;\n+\n+        if (!iExpr.restArgs.isEmpty() &&\n+                restArgs.get(restArgs.size() - 1).getKind() == NodeKind.REST_ARGS_EXPR &&\n+                iExpr.requiredArgs.size() < invokableSymbol.params.size()) {\n+            // All or part of the args for the required and defaultable parameters are provided via the vararg.\n+            // We have to first evaluate the vararg's expression, define a variable, and pass a reference to it\n+            // to use for member access when adding such required arguments from the vararg.\n+            BLangExpression expr = ((BLangRestArgsExpression) restArgs.get(restArgs.size() - 1)).expr;\n+            DiagnosticPos varargExpPos = expr.pos;\n+            BType varargVarType = expr.type;\n+            String varargVarName = DESUGARED_VARARG_KEY + this.varargCount++;\n+\n+            BVarSymbol varargVarSymbol = new BVarSymbol(0, names.fromString(varargVarName), this.env.scope.owner.pkgID,\n+                                                        varargVarType, this.env.scope.owner);\n+            varargRef = ASTBuilderUtil.createVariableRef(varargExpPos, varargVarSymbol);\n+\n+            BLangSimpleVariable var = createVariable(varargExpPos, varargVarName, varargVarType,\n+                                                     ((BLangRestArgsExpression) restArgs.get(restArgs.size() - 1)).expr,\n+                                                     varargVarSymbol);\n+\n+            BLangSimpleVariableDef varDef = ASTBuilderUtil.createVariableDef(varargExpPos);\n+            varDef.var = var;\n+            varDef.type = varargVarType;\n+\n+            blockStmt = createBlockStmt(varargExpPos);\n+            blockStmt.stmts.add(varDef);\n+        }\n+\n         if (!invokableSymbol.params.isEmpty()) {\n             // Re-order the arguments\n-            reorderNamedArgs(iExpr, invokableSymbol);\n+            reorderNamedArgs(iExpr, invokableSymbol, varargRef);\n         }\n \n-        if (invokableSymbol.restParam == null) {\n+        // There are no rest args at all or args for the rest param are only given as individual args (i.e., no vararg).\n+        if (restArgs.isEmpty() || restArgs.get(restArgs.size() - 1).getKind() != NodeKind.REST_ARGS_EXPR) {\n+            if (invokableSymbol.restParam == null) {\n+                return;\n+            }\n+\n+            BLangArrayLiteral arrayLiteral = (BLangArrayLiteral) TreeBuilder.createArrayLiteralExpressionNode();\n+            List<BLangExpression> exprs = new ArrayList<>();\n+\n+            BArrayType arrayType = (BArrayType) invokableSymbol.restParam.type;\n+            BType elemType = arrayType.eType;\n+\n+            for (BLangExpression restArg : restArgs) {\n+                exprs.add(addConversionExprIfRequired(restArg, elemType));\n+            }\n+\n+            arrayLiteral.exprs = exprs;\n+            arrayLiteral.type = arrayType;\n+            iExpr.restArgs = new ArrayList<>();\n+            iExpr.restArgs.add(arrayLiteral);\n             return;\n         }\n \n-        // Create an array out of all the rest arguments, and pass it as a single argument.\n-        // If there is only one optional argument and its type is restArg (i.e: ...x), then\n-        // leave it as is.\n-        if (iExpr.restArgs.size() == 1 && iExpr.restArgs.get(0).getKind() == NodeKind.REST_ARGS_EXPR) {\n+        // There are no individual rest args, but there is a single vararg.\n+        if (restArgs.size() == 1 && restArgs.get(0).getKind() == NodeKind.REST_ARGS_EXPR) {\n+\n+            // If the number of expressions in `iExpr.requiredArgs` hasn't changed, the vararg only contained\n+            // arguments for the rest parameter.\n+            if (iExpr.requiredArgs.size() == originalRequiredArgCount) {\n+                return;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcwODAxOA=="}, "originalCommit": {"oid": "a3de0504b70b2f24c86cb079c3baca7e5f2e45cc"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMTM0NzMwOnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMDozNjo0OFrOGB9cig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwNDo1NjowNlrOGCe-dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcwODQ5MA==", "bodyText": "Is it better to rename type to reflect it is actually the type of rest param?", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22352#discussion_r404708490", "createdAt": "2020-04-07T10:36:48Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5065,36 +5071,154 @@ private void reorderArguments(BLangInvocation iExpr) {\n         }\n \n         BInvokableSymbol invokableSymbol = (BInvokableSymbol) symbol;\n+\n+        List<BLangExpression> restArgs = iExpr.restArgs;\n+        int originalRequiredArgCount = iExpr.requiredArgs.size();\n+\n+        // Constructs used when the vararg provides args for required/defaultable params.\n+        BLangExpression varargRef = null;\n+        BLangBlockStmt blockStmt = null;\n+\n+        if (!iExpr.restArgs.isEmpty() &&\n+                restArgs.get(restArgs.size() - 1).getKind() == NodeKind.REST_ARGS_EXPR &&\n+                iExpr.requiredArgs.size() < invokableSymbol.params.size()) {\n+            // All or part of the args for the required and defaultable parameters are provided via the vararg.\n+            // We have to first evaluate the vararg's expression, define a variable, and pass a reference to it\n+            // to use for member access when adding such required arguments from the vararg.\n+            BLangExpression expr = ((BLangRestArgsExpression) restArgs.get(restArgs.size() - 1)).expr;\n+            DiagnosticPos varargExpPos = expr.pos;\n+            BType varargVarType = expr.type;\n+            String varargVarName = DESUGARED_VARARG_KEY + this.varargCount++;\n+\n+            BVarSymbol varargVarSymbol = new BVarSymbol(0, names.fromString(varargVarName), this.env.scope.owner.pkgID,\n+                                                        varargVarType, this.env.scope.owner);\n+            varargRef = ASTBuilderUtil.createVariableRef(varargExpPos, varargVarSymbol);\n+\n+            BLangSimpleVariable var = createVariable(varargExpPos, varargVarName, varargVarType,\n+                                                     ((BLangRestArgsExpression) restArgs.get(restArgs.size() - 1)).expr,\n+                                                     varargVarSymbol);\n+\n+            BLangSimpleVariableDef varDef = ASTBuilderUtil.createVariableDef(varargExpPos);\n+            varDef.var = var;\n+            varDef.type = varargVarType;\n+\n+            blockStmt = createBlockStmt(varargExpPos);\n+            blockStmt.stmts.add(varDef);\n+        }\n+\n         if (!invokableSymbol.params.isEmpty()) {\n             // Re-order the arguments\n-            reorderNamedArgs(iExpr, invokableSymbol);\n+            reorderNamedArgs(iExpr, invokableSymbol, varargRef);\n         }\n \n-        if (invokableSymbol.restParam == null) {\n+        // There are no rest args at all or args for the rest param are only given as individual args (i.e., no vararg).\n+        if (restArgs.isEmpty() || restArgs.get(restArgs.size() - 1).getKind() != NodeKind.REST_ARGS_EXPR) {\n+            if (invokableSymbol.restParam == null) {\n+                return;\n+            }\n+\n+            BLangArrayLiteral arrayLiteral = (BLangArrayLiteral) TreeBuilder.createArrayLiteralExpressionNode();\n+            List<BLangExpression> exprs = new ArrayList<>();\n+\n+            BArrayType arrayType = (BArrayType) invokableSymbol.restParam.type;\n+            BType elemType = arrayType.eType;\n+\n+            for (BLangExpression restArg : restArgs) {\n+                exprs.add(addConversionExprIfRequired(restArg, elemType));\n+            }\n+\n+            arrayLiteral.exprs = exprs;\n+            arrayLiteral.type = arrayType;\n+            iExpr.restArgs = new ArrayList<>();\n+            iExpr.restArgs.add(arrayLiteral);\n             return;\n         }\n \n-        // Create an array out of all the rest arguments, and pass it as a single argument.\n-        // If there is only one optional argument and its type is restArg (i.e: ...x), then\n-        // leave it as is.\n-        if (iExpr.restArgs.size() == 1 && iExpr.restArgs.get(0).getKind() == NodeKind.REST_ARGS_EXPR) {\n+        // There are no individual rest args, but there is a single vararg.\n+        if (restArgs.size() == 1 && restArgs.get(0).getKind() == NodeKind.REST_ARGS_EXPR) {\n+\n+            // If the number of expressions in `iExpr.requiredArgs` hasn't changed, the vararg only contained\n+            // arguments for the rest parameter.\n+            if (iExpr.requiredArgs.size() == originalRequiredArgCount) {\n+                return;\n+            }\n+\n+            // Args for some or all of the required/defaultable parameters have been provided via the vararg.\n+            // Remove the first required arg and add a statement expression instead.\n+            // The removed first arg is set as the expression and the vararg expression definition is set as\n+            // statement(s).\n+            BLangExpression firstNonRestArg = iExpr.requiredArgs.remove(0);\n+            BLangStatementExpression stmtExpression = createStatementExpression(blockStmt, firstNonRestArg);\n+            stmtExpression.type = firstNonRestArg.type;\n+            iExpr.requiredArgs.add(0, stmtExpression);\n+\n+            // The original value passed as the vararg has to now be sliced to pass only the args for the rest param,\n+            // if there is a rest param.\n+            if (invokableSymbol.restParam == null) {\n+                return;\n+            }\n+\n+            BLangLiteral startIndex = createIntLiteral(invokableSymbol.params.size() - originalRequiredArgCount);\n+            BLangInvocation sliceInvocation =\n+                    createLangLibInvocationNode(SLICE_LANGLIB_METHOD, varargRef,\n+                                                new ArrayList<BLangExpression>() {{\n+                                                    add(startIndex);\n+                                                }},\n+                                                varargRef.type, varargRef.pos);\n+            restArgs.remove(0);\n+            restArgs.add(addConversionExprIfRequired(sliceInvocation, invokableSymbol.restParam.type));\n             return;\n         }\n+\n+        // Now the `restArgs` list has both individual rest args and a vararg, all for the rest param.\n+        // We create a new array with the individual rest args and push the list passed as the vararg to it.\n+        BArrayType type = (BArrayType) invokableSymbol.restParam.type;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3de0504b70b2f24c86cb079c3baca7e5f2e45cc"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI1Nzg0Ng==", "bodyText": "Renamed to restParamType.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22352#discussion_r405257846", "createdAt": "2020-04-08T04:56:06Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5065,36 +5071,154 @@ private void reorderArguments(BLangInvocation iExpr) {\n         }\n \n         BInvokableSymbol invokableSymbol = (BInvokableSymbol) symbol;\n+\n+        List<BLangExpression> restArgs = iExpr.restArgs;\n+        int originalRequiredArgCount = iExpr.requiredArgs.size();\n+\n+        // Constructs used when the vararg provides args for required/defaultable params.\n+        BLangExpression varargRef = null;\n+        BLangBlockStmt blockStmt = null;\n+\n+        if (!iExpr.restArgs.isEmpty() &&\n+                restArgs.get(restArgs.size() - 1).getKind() == NodeKind.REST_ARGS_EXPR &&\n+                iExpr.requiredArgs.size() < invokableSymbol.params.size()) {\n+            // All or part of the args for the required and defaultable parameters are provided via the vararg.\n+            // We have to first evaluate the vararg's expression, define a variable, and pass a reference to it\n+            // to use for member access when adding such required arguments from the vararg.\n+            BLangExpression expr = ((BLangRestArgsExpression) restArgs.get(restArgs.size() - 1)).expr;\n+            DiagnosticPos varargExpPos = expr.pos;\n+            BType varargVarType = expr.type;\n+            String varargVarName = DESUGARED_VARARG_KEY + this.varargCount++;\n+\n+            BVarSymbol varargVarSymbol = new BVarSymbol(0, names.fromString(varargVarName), this.env.scope.owner.pkgID,\n+                                                        varargVarType, this.env.scope.owner);\n+            varargRef = ASTBuilderUtil.createVariableRef(varargExpPos, varargVarSymbol);\n+\n+            BLangSimpleVariable var = createVariable(varargExpPos, varargVarName, varargVarType,\n+                                                     ((BLangRestArgsExpression) restArgs.get(restArgs.size() - 1)).expr,\n+                                                     varargVarSymbol);\n+\n+            BLangSimpleVariableDef varDef = ASTBuilderUtil.createVariableDef(varargExpPos);\n+            varDef.var = var;\n+            varDef.type = varargVarType;\n+\n+            blockStmt = createBlockStmt(varargExpPos);\n+            blockStmt.stmts.add(varDef);\n+        }\n+\n         if (!invokableSymbol.params.isEmpty()) {\n             // Re-order the arguments\n-            reorderNamedArgs(iExpr, invokableSymbol);\n+            reorderNamedArgs(iExpr, invokableSymbol, varargRef);\n         }\n \n-        if (invokableSymbol.restParam == null) {\n+        // There are no rest args at all or args for the rest param are only given as individual args (i.e., no vararg).\n+        if (restArgs.isEmpty() || restArgs.get(restArgs.size() - 1).getKind() != NodeKind.REST_ARGS_EXPR) {\n+            if (invokableSymbol.restParam == null) {\n+                return;\n+            }\n+\n+            BLangArrayLiteral arrayLiteral = (BLangArrayLiteral) TreeBuilder.createArrayLiteralExpressionNode();\n+            List<BLangExpression> exprs = new ArrayList<>();\n+\n+            BArrayType arrayType = (BArrayType) invokableSymbol.restParam.type;\n+            BType elemType = arrayType.eType;\n+\n+            for (BLangExpression restArg : restArgs) {\n+                exprs.add(addConversionExprIfRequired(restArg, elemType));\n+            }\n+\n+            arrayLiteral.exprs = exprs;\n+            arrayLiteral.type = arrayType;\n+            iExpr.restArgs = new ArrayList<>();\n+            iExpr.restArgs.add(arrayLiteral);\n             return;\n         }\n \n-        // Create an array out of all the rest arguments, and pass it as a single argument.\n-        // If there is only one optional argument and its type is restArg (i.e: ...x), then\n-        // leave it as is.\n-        if (iExpr.restArgs.size() == 1 && iExpr.restArgs.get(0).getKind() == NodeKind.REST_ARGS_EXPR) {\n+        // There are no individual rest args, but there is a single vararg.\n+        if (restArgs.size() == 1 && restArgs.get(0).getKind() == NodeKind.REST_ARGS_EXPR) {\n+\n+            // If the number of expressions in `iExpr.requiredArgs` hasn't changed, the vararg only contained\n+            // arguments for the rest parameter.\n+            if (iExpr.requiredArgs.size() == originalRequiredArgCount) {\n+                return;\n+            }\n+\n+            // Args for some or all of the required/defaultable parameters have been provided via the vararg.\n+            // Remove the first required arg and add a statement expression instead.\n+            // The removed first arg is set as the expression and the vararg expression definition is set as\n+            // statement(s).\n+            BLangExpression firstNonRestArg = iExpr.requiredArgs.remove(0);\n+            BLangStatementExpression stmtExpression = createStatementExpression(blockStmt, firstNonRestArg);\n+            stmtExpression.type = firstNonRestArg.type;\n+            iExpr.requiredArgs.add(0, stmtExpression);\n+\n+            // The original value passed as the vararg has to now be sliced to pass only the args for the rest param,\n+            // if there is a rest param.\n+            if (invokableSymbol.restParam == null) {\n+                return;\n+            }\n+\n+            BLangLiteral startIndex = createIntLiteral(invokableSymbol.params.size() - originalRequiredArgCount);\n+            BLangInvocation sliceInvocation =\n+                    createLangLibInvocationNode(SLICE_LANGLIB_METHOD, varargRef,\n+                                                new ArrayList<BLangExpression>() {{\n+                                                    add(startIndex);\n+                                                }},\n+                                                varargRef.type, varargRef.pos);\n+            restArgs.remove(0);\n+            restArgs.add(addConversionExprIfRequired(sliceInvocation, invokableSymbol.restParam.type));\n             return;\n         }\n+\n+        // Now the `restArgs` list has both individual rest args and a vararg, all for the rest param.\n+        // We create a new array with the individual rest args and push the list passed as the vararg to it.\n+        BArrayType type = (BArrayType) invokableSymbol.restParam.type;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcwODQ5MA=="}, "originalCommit": {"oid": "a3de0504b70b2f24c86cb079c3baca7e5f2e45cc"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMTM0OTg2OnYy", "diffSide": "RIGHT", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMDozNzozN1rOGB9eEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwNDo1NDo0MlrOGCe9MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcwODg4Mw==", "bodyText": "This can be arrayLiteral.exprs = new ArrayList<>();", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22352#discussion_r404708883", "createdAt": "2020-04-07T10:37:37Z", "author": {"login": "KRVPerera"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5065,36 +5071,154 @@ private void reorderArguments(BLangInvocation iExpr) {\n         }\n \n         BInvokableSymbol invokableSymbol = (BInvokableSymbol) symbol;\n+\n+        List<BLangExpression> restArgs = iExpr.restArgs;\n+        int originalRequiredArgCount = iExpr.requiredArgs.size();\n+\n+        // Constructs used when the vararg provides args for required/defaultable params.\n+        BLangExpression varargRef = null;\n+        BLangBlockStmt blockStmt = null;\n+\n+        if (!iExpr.restArgs.isEmpty() &&\n+                restArgs.get(restArgs.size() - 1).getKind() == NodeKind.REST_ARGS_EXPR &&\n+                iExpr.requiredArgs.size() < invokableSymbol.params.size()) {\n+            // All or part of the args for the required and defaultable parameters are provided via the vararg.\n+            // We have to first evaluate the vararg's expression, define a variable, and pass a reference to it\n+            // to use for member access when adding such required arguments from the vararg.\n+            BLangExpression expr = ((BLangRestArgsExpression) restArgs.get(restArgs.size() - 1)).expr;\n+            DiagnosticPos varargExpPos = expr.pos;\n+            BType varargVarType = expr.type;\n+            String varargVarName = DESUGARED_VARARG_KEY + this.varargCount++;\n+\n+            BVarSymbol varargVarSymbol = new BVarSymbol(0, names.fromString(varargVarName), this.env.scope.owner.pkgID,\n+                                                        varargVarType, this.env.scope.owner);\n+            varargRef = ASTBuilderUtil.createVariableRef(varargExpPos, varargVarSymbol);\n+\n+            BLangSimpleVariable var = createVariable(varargExpPos, varargVarName, varargVarType,\n+                                                     ((BLangRestArgsExpression) restArgs.get(restArgs.size() - 1)).expr,\n+                                                     varargVarSymbol);\n+\n+            BLangSimpleVariableDef varDef = ASTBuilderUtil.createVariableDef(varargExpPos);\n+            varDef.var = var;\n+            varDef.type = varargVarType;\n+\n+            blockStmt = createBlockStmt(varargExpPos);\n+            blockStmt.stmts.add(varDef);\n+        }\n+\n         if (!invokableSymbol.params.isEmpty()) {\n             // Re-order the arguments\n-            reorderNamedArgs(iExpr, invokableSymbol);\n+            reorderNamedArgs(iExpr, invokableSymbol, varargRef);\n         }\n \n-        if (invokableSymbol.restParam == null) {\n+        // There are no rest args at all or args for the rest param are only given as individual args (i.e., no vararg).\n+        if (restArgs.isEmpty() || restArgs.get(restArgs.size() - 1).getKind() != NodeKind.REST_ARGS_EXPR) {\n+            if (invokableSymbol.restParam == null) {\n+                return;\n+            }\n+\n+            BLangArrayLiteral arrayLiteral = (BLangArrayLiteral) TreeBuilder.createArrayLiteralExpressionNode();\n+            List<BLangExpression> exprs = new ArrayList<>();\n+\n+            BArrayType arrayType = (BArrayType) invokableSymbol.restParam.type;\n+            BType elemType = arrayType.eType;\n+\n+            for (BLangExpression restArg : restArgs) {\n+                exprs.add(addConversionExprIfRequired(restArg, elemType));\n+            }\n+\n+            arrayLiteral.exprs = exprs;\n+            arrayLiteral.type = arrayType;\n+            iExpr.restArgs = new ArrayList<>();\n+            iExpr.restArgs.add(arrayLiteral);\n             return;\n         }\n \n-        // Create an array out of all the rest arguments, and pass it as a single argument.\n-        // If there is only one optional argument and its type is restArg (i.e: ...x), then\n-        // leave it as is.\n-        if (iExpr.restArgs.size() == 1 && iExpr.restArgs.get(0).getKind() == NodeKind.REST_ARGS_EXPR) {\n+        // There are no individual rest args, but there is a single vararg.\n+        if (restArgs.size() == 1 && restArgs.get(0).getKind() == NodeKind.REST_ARGS_EXPR) {\n+\n+            // If the number of expressions in `iExpr.requiredArgs` hasn't changed, the vararg only contained\n+            // arguments for the rest parameter.\n+            if (iExpr.requiredArgs.size() == originalRequiredArgCount) {\n+                return;\n+            }\n+\n+            // Args for some or all of the required/defaultable parameters have been provided via the vararg.\n+            // Remove the first required arg and add a statement expression instead.\n+            // The removed first arg is set as the expression and the vararg expression definition is set as\n+            // statement(s).\n+            BLangExpression firstNonRestArg = iExpr.requiredArgs.remove(0);\n+            BLangStatementExpression stmtExpression = createStatementExpression(blockStmt, firstNonRestArg);\n+            stmtExpression.type = firstNonRestArg.type;\n+            iExpr.requiredArgs.add(0, stmtExpression);\n+\n+            // The original value passed as the vararg has to now be sliced to pass only the args for the rest param,\n+            // if there is a rest param.\n+            if (invokableSymbol.restParam == null) {\n+                return;\n+            }\n+\n+            BLangLiteral startIndex = createIntLiteral(invokableSymbol.params.size() - originalRequiredArgCount);\n+            BLangInvocation sliceInvocation =\n+                    createLangLibInvocationNode(SLICE_LANGLIB_METHOD, varargRef,\n+                                                new ArrayList<BLangExpression>() {{\n+                                                    add(startIndex);\n+                                                }},\n+                                                varargRef.type, varargRef.pos);\n+            restArgs.remove(0);\n+            restArgs.add(addConversionExprIfRequired(sliceInvocation, invokableSymbol.restParam.type));\n             return;\n         }\n+\n+        // Now the `restArgs` list has both individual rest args and a vararg, all for the rest param.\n+        // We create a new array with the individual rest args and push the list passed as the vararg to it.\n+        BArrayType type = (BArrayType) invokableSymbol.restParam.type;\n+\n         BLangArrayLiteral arrayLiteral = (BLangArrayLiteral) TreeBuilder.createArrayLiteralExpressionNode();\n-        arrayLiteral.type = invokableSymbol.restParam.type;\n+        arrayLiteral.type = type;\n \n-        BType elemType = ((BArrayType) arrayLiteral.type).eType;\n-        List<BLangExpression> rewrittenRestArgs = new ArrayList<>();\n-        for (BLangExpression restArg : iExpr.restArgs) {\n-            rewrittenRestArgs.add(addConversionExprIfRequired(restArg, elemType));\n+        BType elemType = type.eType;\n+        DiagnosticPos pos = restArgs.get(0).pos;\n+\n+        List<BLangExpression> exprs = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3de0504b70b2f24c86cb079c3baca7e5f2e45cc"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI1NzUyMQ==", "bodyText": "Then we have to do in L5186\narrayLiteral.exprs.add(addConversionExprIfRequired(restArgs.get(i), elemType));\n\nI'd rather complete the list and then set it.", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22352#discussion_r405257521", "createdAt": "2020-04-08T04:54:42Z", "author": {"login": "MaryamZi"}, "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5065,36 +5071,154 @@ private void reorderArguments(BLangInvocation iExpr) {\n         }\n \n         BInvokableSymbol invokableSymbol = (BInvokableSymbol) symbol;\n+\n+        List<BLangExpression> restArgs = iExpr.restArgs;\n+        int originalRequiredArgCount = iExpr.requiredArgs.size();\n+\n+        // Constructs used when the vararg provides args for required/defaultable params.\n+        BLangExpression varargRef = null;\n+        BLangBlockStmt blockStmt = null;\n+\n+        if (!iExpr.restArgs.isEmpty() &&\n+                restArgs.get(restArgs.size() - 1).getKind() == NodeKind.REST_ARGS_EXPR &&\n+                iExpr.requiredArgs.size() < invokableSymbol.params.size()) {\n+            // All or part of the args for the required and defaultable parameters are provided via the vararg.\n+            // We have to first evaluate the vararg's expression, define a variable, and pass a reference to it\n+            // to use for member access when adding such required arguments from the vararg.\n+            BLangExpression expr = ((BLangRestArgsExpression) restArgs.get(restArgs.size() - 1)).expr;\n+            DiagnosticPos varargExpPos = expr.pos;\n+            BType varargVarType = expr.type;\n+            String varargVarName = DESUGARED_VARARG_KEY + this.varargCount++;\n+\n+            BVarSymbol varargVarSymbol = new BVarSymbol(0, names.fromString(varargVarName), this.env.scope.owner.pkgID,\n+                                                        varargVarType, this.env.scope.owner);\n+            varargRef = ASTBuilderUtil.createVariableRef(varargExpPos, varargVarSymbol);\n+\n+            BLangSimpleVariable var = createVariable(varargExpPos, varargVarName, varargVarType,\n+                                                     ((BLangRestArgsExpression) restArgs.get(restArgs.size() - 1)).expr,\n+                                                     varargVarSymbol);\n+\n+            BLangSimpleVariableDef varDef = ASTBuilderUtil.createVariableDef(varargExpPos);\n+            varDef.var = var;\n+            varDef.type = varargVarType;\n+\n+            blockStmt = createBlockStmt(varargExpPos);\n+            blockStmt.stmts.add(varDef);\n+        }\n+\n         if (!invokableSymbol.params.isEmpty()) {\n             // Re-order the arguments\n-            reorderNamedArgs(iExpr, invokableSymbol);\n+            reorderNamedArgs(iExpr, invokableSymbol, varargRef);\n         }\n \n-        if (invokableSymbol.restParam == null) {\n+        // There are no rest args at all or args for the rest param are only given as individual args (i.e., no vararg).\n+        if (restArgs.isEmpty() || restArgs.get(restArgs.size() - 1).getKind() != NodeKind.REST_ARGS_EXPR) {\n+            if (invokableSymbol.restParam == null) {\n+                return;\n+            }\n+\n+            BLangArrayLiteral arrayLiteral = (BLangArrayLiteral) TreeBuilder.createArrayLiteralExpressionNode();\n+            List<BLangExpression> exprs = new ArrayList<>();\n+\n+            BArrayType arrayType = (BArrayType) invokableSymbol.restParam.type;\n+            BType elemType = arrayType.eType;\n+\n+            for (BLangExpression restArg : restArgs) {\n+                exprs.add(addConversionExprIfRequired(restArg, elemType));\n+            }\n+\n+            arrayLiteral.exprs = exprs;\n+            arrayLiteral.type = arrayType;\n+            iExpr.restArgs = new ArrayList<>();\n+            iExpr.restArgs.add(arrayLiteral);\n             return;\n         }\n \n-        // Create an array out of all the rest arguments, and pass it as a single argument.\n-        // If there is only one optional argument and its type is restArg (i.e: ...x), then\n-        // leave it as is.\n-        if (iExpr.restArgs.size() == 1 && iExpr.restArgs.get(0).getKind() == NodeKind.REST_ARGS_EXPR) {\n+        // There are no individual rest args, but there is a single vararg.\n+        if (restArgs.size() == 1 && restArgs.get(0).getKind() == NodeKind.REST_ARGS_EXPR) {\n+\n+            // If the number of expressions in `iExpr.requiredArgs` hasn't changed, the vararg only contained\n+            // arguments for the rest parameter.\n+            if (iExpr.requiredArgs.size() == originalRequiredArgCount) {\n+                return;\n+            }\n+\n+            // Args for some or all of the required/defaultable parameters have been provided via the vararg.\n+            // Remove the first required arg and add a statement expression instead.\n+            // The removed first arg is set as the expression and the vararg expression definition is set as\n+            // statement(s).\n+            BLangExpression firstNonRestArg = iExpr.requiredArgs.remove(0);\n+            BLangStatementExpression stmtExpression = createStatementExpression(blockStmt, firstNonRestArg);\n+            stmtExpression.type = firstNonRestArg.type;\n+            iExpr.requiredArgs.add(0, stmtExpression);\n+\n+            // The original value passed as the vararg has to now be sliced to pass only the args for the rest param,\n+            // if there is a rest param.\n+            if (invokableSymbol.restParam == null) {\n+                return;\n+            }\n+\n+            BLangLiteral startIndex = createIntLiteral(invokableSymbol.params.size() - originalRequiredArgCount);\n+            BLangInvocation sliceInvocation =\n+                    createLangLibInvocationNode(SLICE_LANGLIB_METHOD, varargRef,\n+                                                new ArrayList<BLangExpression>() {{\n+                                                    add(startIndex);\n+                                                }},\n+                                                varargRef.type, varargRef.pos);\n+            restArgs.remove(0);\n+            restArgs.add(addConversionExprIfRequired(sliceInvocation, invokableSymbol.restParam.type));\n             return;\n         }\n+\n+        // Now the `restArgs` list has both individual rest args and a vararg, all for the rest param.\n+        // We create a new array with the individual rest args and push the list passed as the vararg to it.\n+        BArrayType type = (BArrayType) invokableSymbol.restParam.type;\n+\n         BLangArrayLiteral arrayLiteral = (BLangArrayLiteral) TreeBuilder.createArrayLiteralExpressionNode();\n-        arrayLiteral.type = invokableSymbol.restParam.type;\n+        arrayLiteral.type = type;\n \n-        BType elemType = ((BArrayType) arrayLiteral.type).eType;\n-        List<BLangExpression> rewrittenRestArgs = new ArrayList<>();\n-        for (BLangExpression restArg : iExpr.restArgs) {\n-            rewrittenRestArgs.add(addConversionExprIfRequired(restArg, elemType));\n+        BType elemType = type.eType;\n+        DiagnosticPos pos = restArgs.get(0).pos;\n+\n+        List<BLangExpression> exprs = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcwODg4Mw=="}, "originalCommit": {"oid": "a3de0504b70b2f24c86cb079c3baca7e5f2e45cc"}, "originalPosition": 151}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4477, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}