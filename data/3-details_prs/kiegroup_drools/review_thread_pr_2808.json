{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg1NzAzNzU3", "number": 2808, "reviewThreads": {"totalCount": 33, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNzo1MTowNlrODmZtjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwOTo1MjoxMFrODnxdNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNTkzNzQxOnYy", "diffSide": "RIGHT", "path": "kie-pmml-new/kie-pmml-commons/src/main/java/org/kie/pmml/commons/model/abstracts/KiePMMLBase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNzo1MTowNlrOFzzIiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMToxNDoyOVrOF1_-AA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg1OTQ2Nw==", "bodyText": "Can you please add javadoc and add prefix Abstract?", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r389859467", "createdAt": "2020-03-09T17:51:06Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-new/kie-pmml-commons/src/main/java/org/kie/pmml/commons/model/abstracts/KiePMMLBase.java", "diffHunk": "@@ -15,18 +15,23 @@\n  */\n package org.kie.pmml.commons.model.abstracts;\n \n-import java.io.Serializable;\n-import java.util.Objects;\n+import java.util.Collections;\n+import java.util.List;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.function.Supplier;\n \n-public class KiePMMLIDed implements Serializable {\n+import org.kie.pmml.commons.model.KiePMMLExtension;\n \n-    private static final long serialVersionUID = -2153680489671276928L;\n+public abstract class KiePMMLBase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a68e7e68b439401a4d7a232b0f86700998e459a"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE2NjkxMg==", "bodyText": "@danielezonca\nDone", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r392166912", "createdAt": "2020-03-13T11:14:29Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-new/kie-pmml-commons/src/main/java/org/kie/pmml/commons/model/abstracts/KiePMMLBase.java", "diffHunk": "@@ -15,18 +15,23 @@\n  */\n package org.kie.pmml.commons.model.abstracts;\n \n-import java.io.Serializable;\n-import java.util.Objects;\n+import java.util.Collections;\n+import java.util.List;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.function.Supplier;\n \n-public class KiePMMLIDed implements Serializable {\n+import org.kie.pmml.commons.model.KiePMMLExtension;\n \n-    private static final long serialVersionUID = -2153680489671276928L;\n+public abstract class KiePMMLBase {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg1OTQ2Nw=="}, "originalCommit": {"oid": "5a68e7e68b439401a4d7a232b0f86700998e459a"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxODU0NzgzOnYy", "diffSide": "RIGHT", "path": "kie-pmml-new/kie-pmml-benchmarks/kie-pmml-benchmarks-regression/src/main/java/org/kie/pmml/benchmarks/regression/CategoricalBatchBenchmark.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMjowNTowOFrOF0MAaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwOTowODoxOFrOF0uUgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI2Njk4NQ==", "bodyText": "I would suggest to not add code which is commented out. If it is absolutely necessary please add also some description with reason why is this code commented out.", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390266985", "createdAt": "2020-03-10T12:05:08Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-benchmarks/kie-pmml-benchmarks-regression/src/main/java/org/kie/pmml/benchmarks/regression/CategoricalBatchBenchmark.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.benchmarks.regression;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+\n+@BenchmarkMode(Mode.Throughput)\n+@State(Scope.Thread)\n+@Warmup(iterations = 2)\n+@Measurement(iterations = 5)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@Fork(jvmArgs = {\"-Xms8172m\", \"-Xmx8172m\"}, value = 5)\n+public class CategoricalBatchBenchmark {\n+\n+    private static final String modelName = \"Sample for logistic regression\";\n+    private static final String fileName = \"CategoricalRegressionSample.pmml\";\n+    private static final String inputDataFile = \"CategoricalRegressionSample.csv\";\n+//", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDgyOTE4NA==", "bodyText": "@jiripetrlik\nSorry, forgot that. I'm going to review that class to see if it is needed at all.", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390829184", "createdAt": "2020-03-11T09:08:18Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-new/kie-pmml-benchmarks/kie-pmml-benchmarks-regression/src/main/java/org/kie/pmml/benchmarks/regression/CategoricalBatchBenchmark.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.benchmarks.regression;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+\n+@BenchmarkMode(Mode.Throughput)\n+@State(Scope.Thread)\n+@Warmup(iterations = 2)\n+@Measurement(iterations = 5)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@Fork(jvmArgs = {\"-Xms8172m\", \"-Xmx8172m\"}, value = 5)\n+public class CategoricalBatchBenchmark {\n+\n+    private static final String modelName = \"Sample for logistic regression\";\n+    private static final String fileName = \"CategoricalRegressionSample.pmml\";\n+    private static final String inputDataFile = \"CategoricalRegressionSample.csv\";\n+//", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI2Njk4NQ=="}, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxODU1ODY5OnYy", "diffSide": "RIGHT", "path": "kie-pmml-new/kie-pmml-benchmarks/kie-pmml-benchmarks-regression/src/main/resources/CategoricalRegressionSample.csv", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMjowODoyOFrOF0MG4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNToxNjowM1rOF07mfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI2ODY0MQ==", "bodyText": "It seems like quite a big file to be add to git. Can't we simply use subset of these data? Or if we need long data file can't we generate CSV programaticaly from tests.", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390268641", "createdAt": "2020-03-10T12:08:28Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-benchmarks/kie-pmml-benchmarks-regression/src/main/resources/CategoricalRegressionSample.csv", "diffHunk": "@@ -0,0 +1,1900 @@\n+Age,Employment,Education,Marital,Occupation,Income,Gender,Deductions,Hours,Adjusted", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDgyOTY0NA==", "bodyText": "@jiripetrlik\nI'm going to review if such file is needed at all and - eventually - how to replace/reduce it", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390829644", "createdAt": "2020-03-11T09:09:09Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-new/kie-pmml-benchmarks/kie-pmml-benchmarks-regression/src/main/resources/CategoricalRegressionSample.csv", "diffHunk": "@@ -0,0 +1,1900 @@\n+Age,Employment,Education,Marital,Occupation,Income,Gender,Deductions,Hours,Adjusted", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI2ODY0MQ=="}, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA0Njc4MA==", "bodyText": "@jiripetrlik\nRemoved", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r391046780", "createdAt": "2020-03-11T15:16:03Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-new/kie-pmml-benchmarks/kie-pmml-benchmarks-regression/src/main/resources/CategoricalRegressionSample.csv", "diffHunk": "@@ -0,0 +1,1900 @@\n+Age,Employment,Education,Marital,Occupation,Income,Gender,Deductions,Hours,Adjusted", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI2ODY0MQ=="}, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxODU2NTc4OnYy", "diffSide": "RIGHT", "path": "kie-pmml-new/kie-pmml-commons/src/main/java/org/kie/pmml/commons/Constants.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMjoxMDo0OVrOF0MLMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwOTowOTo1MFrOF0uXrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI2OTc0NQ==", "bodyText": "Is this really necessary? I would guess that nobody will try to initiate class with constants and if so it will not cause any damage.", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390269745", "createdAt": "2020-03-10T12:10:49Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-commons/src/main/java/org/kie/pmml/commons/Constants.java", "diffHunk": "@@ -0,0 +1,30 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.commons;\n+\n+public class Constants {\n+\n+    public static final String RELEASE_ID = \"org.kie:kie-pmml-new:7.34.0-SNAPSHOT\";\n+\n+    public static final String UNEXPECTED_OP_TYPE = \"Unexpected opType %s\";\n+    public static final String EXPECTED_TWO_ENTRIES_RETRIEVED = \"Expected two entries, retrieved %d\";\n+    public static final String UNEXPECTED_OPERATION_TYPE = \"Unexpected Operation Type %s\";\n+    public static final String UNEXPECTED_NORMALIZATION_METHOD = \"Unexpected Normalization Method %s\";\n+\n+    private Constants() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDgyOTk5OQ==", "bodyText": "@jiripetrlik\nAll those \"private\" constructor are due to some SONAR complaints.", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390829999", "createdAt": "2020-03-11T09:09:50Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-new/kie-pmml-commons/src/main/java/org/kie/pmml/commons/Constants.java", "diffHunk": "@@ -0,0 +1,30 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.commons;\n+\n+public class Constants {\n+\n+    public static final String RELEASE_ID = \"org.kie:kie-pmml-new:7.34.0-SNAPSHOT\";\n+\n+    public static final String UNEXPECTED_OP_TYPE = \"Unexpected opType %s\";\n+    public static final String EXPECTED_TWO_ENTRIES_RETRIEVED = \"Expected two entries, retrieved %d\";\n+    public static final String UNEXPECTED_OPERATION_TYPE = \"Unexpected Operation Type %s\";\n+    public static final String UNEXPECTED_NORMALIZATION_METHOD = \"Unexpected Normalization Method %s\";\n+\n+    private Constants() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI2OTc0NQ=="}, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxODU4MTY4OnYy", "diffSide": "RIGHT", "path": "kie-pmml-new/kie-pmml-compiler/kie-pmml-compiler-commons/src/main/java/org/kie/pmml/compiler/commons/implementations/KiePMMLModelRetriever.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMjoxNTo1OFrOF0MU8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwOToxMDowN1rOF0uYPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI3MjI0Mw==", "bodyText": "Is this necessary?", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390272243", "createdAt": "2020-03-10T12:15:58Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-compiler/kie-pmml-compiler-commons/src/main/java/org/kie/pmml/compiler/commons/implementations/KiePMMLModelRetriever.java", "diffHunk": "@@ -31,6 +31,9 @@\n     private static final Logger logger = LoggerFactory.getLogger(KiePMMLModelRetriever.class.getName());\n     private static final ModelImplementationProviderFinder modelImplementationProviderFinder = new ModelImplementationProviderFinderImpl();\n \n+    private KiePMMLModelRetriever() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDgzMDE0Mg==", "bodyText": "@jiripetrlik\nAs above....", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390830142", "createdAt": "2020-03-11T09:10:07Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-new/kie-pmml-compiler/kie-pmml-compiler-commons/src/main/java/org/kie/pmml/compiler/commons/implementations/KiePMMLModelRetriever.java", "diffHunk": "@@ -31,6 +31,9 @@\n     private static final Logger logger = LoggerFactory.getLogger(KiePMMLModelRetriever.class.getName());\n     private static final ModelImplementationProviderFinder modelImplementationProviderFinder = new ModelImplementationProviderFinderImpl();\n \n+    private KiePMMLModelRetriever() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI3MjI0Mw=="}, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxODU4MzQwOnYy", "diffSide": "RIGHT", "path": "kie-pmml-new/kie-pmml-compiler/kie-pmml-compiler-commons/src/main/java/org/kie/pmml/compiler/commons/utils/KiePMMLUtil.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMjoxNjozM1rOF0MV_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMjoxNjozM1rOF0MV_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI3MjUxMQ==", "bodyText": "Again. Is this necessary? Instantiation will not cause any harm to the app.", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390272511", "createdAt": "2020-03-10T12:16:33Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-compiler/kie-pmml-compiler-commons/src/main/java/org/kie/pmml/compiler/commons/utils/KiePMMLUtil.java", "diffHunk": "@@ -29,6 +29,10 @@\n  */\n public class KiePMMLUtil {\n \n+    private KiePMMLUtil() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxODU5MTc3OnYy", "diffSide": "RIGHT", "path": "kie-pmml-new/kie-pmml-compiler/kie-pmml-compiler-commons/src/test/java/org/kie/pmml/compiler/commons/mocks/KiePMMLTestingModel.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMjoxOToyMFrOF0MbEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNTowNzozOVrOF07OHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI3MzgxMQ==", "bodyText": "Seems a little bit suspicious. Do we really want to always return null here? Don't we forget to add implementation?", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390273811", "createdAt": "2020-03-10T12:19:20Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-compiler/kie-pmml-compiler-commons/src/test/java/org/kie/pmml/compiler/commons/mocks/KiePMMLTestingModel.java", "diffHunk": "@@ -25,5 +29,12 @@\n \n     public static final PMML_MODEL PMML_MODEL_TYPE = PMML_MODEL.REGRESSION_MODEL;\n \n-    private static final long serialVersionUID = -3197536256173718262L;\n+    protected KiePMMLTestingModel(String name, List<KiePMMLExtension> extensions) {\n+        super(name);\n+    }\n+\n+    @Override\n+    public Object evaluate(Map<String, Object> requestData) {\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA0MDU0MQ==", "bodyText": "@jiripetrlik\nThis model is used only to test the ModelImplementationProvider  without any actual model implementation: does this makes sense ?", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r391040541", "createdAt": "2020-03-11T15:07:39Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-new/kie-pmml-compiler/kie-pmml-compiler-commons/src/test/java/org/kie/pmml/compiler/commons/mocks/KiePMMLTestingModel.java", "diffHunk": "@@ -25,5 +29,12 @@\n \n     public static final PMML_MODEL PMML_MODEL_TYPE = PMML_MODEL.REGRESSION_MODEL;\n \n-    private static final long serialVersionUID = -3197536256173718262L;\n+    protected KiePMMLTestingModel(String name, List<KiePMMLExtension> extensions) {\n+        super(name);\n+    }\n+\n+    @Override\n+    public Object evaluate(Map<String, Object> requestData) {\n+        return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI3MzgxMQ=="}, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxODU5NTc0OnYy", "diffSide": "RIGHT", "path": "kie-pmml-new/kie-pmml-evaluator/kie-pmml-evaluator-core/src/main/java/org/kie/pmml/evaluator/core/utils/Converter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMjoyMDo0MVrOF0Mdlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMjoyMDo0MVrOF0Mdlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI3NDQ1NA==", "bodyText": "Please remove commented code.", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390274454", "createdAt": "2020-03-10T12:20:41Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-evaluator/kie-pmml-evaluator-core/src/main/java/org/kie/pmml/evaluator/core/utils/Converter.java", "diffHunk": "@@ -25,15 +26,43 @@\n  */\n public class Converter {\n \n+    private Converter() {\n+        // Avoid instantiation\n+    }\n+\n     /**\n      * <b>Extract</b> the objects from the <code>ParameterInfo</code> values of the given map.\n      * @param parameterMap\n      * @return\n      */\n     public static Map<String, Object> getUnwrappedParametersMap(Map<String, ParameterInfo> parameterMap) {\n-        return parameterMap.entrySet()\n-                .stream()\n-                .collect(Collectors.toMap(Map.Entry::getKey,\n-                                          e -> e.getValue().getValue()));\n+        Map<String, Object> toReturn = new HashMap<>();\n+        for (Map.Entry<String, ParameterInfo> entry : parameterMap.entrySet()) {\n+            toReturn.put(entry.getKey(), entry.getValue().getValue());\n+        }\n+        return toReturn;\n+//", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxODYwOTAwOnYy", "diffSide": "RIGHT", "path": "kie-pmml-new/kie-pmml-evaluator/kie-pmml-evaluator-core/src/main/java/org/kie/pmml/evaluator/core/utils/Converter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMjoyNTowM1rOF0Ml6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMjoyNTowM1rOF0Ml6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI3NjU4Ng==", "bodyText": "Please remove commented code.", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390276586", "createdAt": "2020-03-10T12:25:03Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-evaluator/kie-pmml-evaluator-core/src/main/java/org/kie/pmml/evaluator/core/utils/Converter.java", "diffHunk": "@@ -25,15 +26,43 @@\n  */\n public class Converter {\n \n+    private Converter() {\n+        // Avoid instantiation\n+    }\n+\n     /**\n      * <b>Extract</b> the objects from the <code>ParameterInfo</code> values of the given map.\n      * @param parameterMap\n      * @return\n      */\n     public static Map<String, Object> getUnwrappedParametersMap(Map<String, ParameterInfo> parameterMap) {\n-        return parameterMap.entrySet()\n-                .stream()\n-                .collect(Collectors.toMap(Map.Entry::getKey,\n-                                          e -> e.getValue().getValue()));\n+        Map<String, Object> toReturn = new HashMap<>();\n+        for (Map.Entry<String, ParameterInfo> entry : parameterMap.entrySet()) {\n+            toReturn.put(entry.getKey(), entry.getValue().getValue());\n+        }\n+        return toReturn;\n+//\n+//        return parameterMap.entrySet()\n+//                .stream()\n+//                .collect(Collectors.toMap(Map.Entry::getKey,\n+//                                          e -> e.getValue().getValue()));\n+    }\n+\n+    /**\n+     * <b>Extract</b> the objects from the <code>ParameterInfo</code> of the given collection.\n+     * @param parameterInfos\n+     * @return\n+     */\n+    public static Map<String, Object> getUnwrappedParametersMap(Collection<ParameterInfo> parameterInfos) {\n+        Map<String, Object> toReturn = new HashMap<>();\n+        for (ParameterInfo parameterInfo : parameterInfos) {\n+            toReturn.put(parameterInfo.getName(), parameterInfo.getValue());\n+        }\n+        return toReturn;\n+//\n+//        return parameterInfos", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxODY0ODY0OnYy", "diffSide": "RIGHT", "path": "kie-pmml-new/kie-pmml-integration-tests/src/test/java/org/kie/pmml/compiler/executor/PMMLKiePMMLRegressionCompilerImplTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMjozODowNlrOF0M-Xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNToxMzoyNVrOF07e7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI4Mjg0Ng==", "bodyText": "One idea. What about to use Assertj in the future. It provides much more rich asserts and also messages about failures are much more verbose.", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390282846", "createdAt": "2020-03-10T12:38:06Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-integration-tests/src/test/java/org/kie/pmml/compiler/executor/PMMLKiePMMLRegressionCompilerImplTest.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.pmml.compiler.executor;\n+\n+import java.util.List;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.KieBuilder;\n+import org.kie.api.builder.KieFileSystem;\n+import org.kie.pmml.commons.model.KiePMMLModel;\n+import org.kie.pmml.commons.model.enums.MINING_FUNCTION;\n+import org.kie.pmml.models.regression.model.KiePMMLRegressionModel;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.kie.test.util.filesystem.FileUtils.getFileInputStream;\n+\n+public class PMMLKiePMMLRegressionCompilerImplTest {\n+\n+    private static final PMMLCompiler EXECUTOR = new PMMLCompilerImpl();\n+\n+    private KieBuilder kieBuilder;\n+\n+    @Before\n+    public void setup() {\n+        KieServices ks = KieServices.Factory.get();\n+        KieFileSystem kfs = ks.newKieFileSystem();\n+        kieBuilder = ks.newKieBuilder(kfs);\n+    }\n+\n+    @Test\n+    public void getModels() throws Exception {\n+        final List<KiePMMLModel> results = EXECUTOR.getModels(getFileInputStream(\"LinearRegressionSample.pmml\"), kieBuilder);\n+        assertNotNull(results);\n+        assertEquals(1, results.size());\n+        assertTrue(results.get(0) instanceof KiePMMLRegressionModel);\n+        commonVerifyKiePMMLRegressionModel((KiePMMLRegressionModel) results.get(0));\n+    }\n+\n+    // TODO {gcardosi} Carbon-copy of org.kie.pmml.regression.evaluator.RegressionModelImplementationProviderTest\n+\n+    private void commonVerifyKiePMMLRegressionModel(KiePMMLRegressionModel retrieved) {\n+        assertNotNull(retrieved);\n+        assertEquals(MINING_FUNCTION.REGRESSION, retrieved.getMiningFunction());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA0NDg0NA==", "bodyText": "@jiripetrlik\nTBH, I never had the need of using it - so probably what it adds has never been essential for me;  org.junit.Assert also seems more consistent with most of the code I saw inside drools. So, I would prefer to keep it as it is unless I find a need.", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r391044844", "createdAt": "2020-03-11T15:13:25Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-new/kie-pmml-integration-tests/src/test/java/org/kie/pmml/compiler/executor/PMMLKiePMMLRegressionCompilerImplTest.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.pmml.compiler.executor;\n+\n+import java.util.List;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.KieBuilder;\n+import org.kie.api.builder.KieFileSystem;\n+import org.kie.pmml.commons.model.KiePMMLModel;\n+import org.kie.pmml.commons.model.enums.MINING_FUNCTION;\n+import org.kie.pmml.models.regression.model.KiePMMLRegressionModel;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.kie.test.util.filesystem.FileUtils.getFileInputStream;\n+\n+public class PMMLKiePMMLRegressionCompilerImplTest {\n+\n+    private static final PMMLCompiler EXECUTOR = new PMMLCompilerImpl();\n+\n+    private KieBuilder kieBuilder;\n+\n+    @Before\n+    public void setup() {\n+        KieServices ks = KieServices.Factory.get();\n+        KieFileSystem kfs = ks.newKieFileSystem();\n+        kieBuilder = ks.newKieBuilder(kfs);\n+    }\n+\n+    @Test\n+    public void getModels() throws Exception {\n+        final List<KiePMMLModel> results = EXECUTOR.getModels(getFileInputStream(\"LinearRegressionSample.pmml\"), kieBuilder);\n+        assertNotNull(results);\n+        assertEquals(1, results.size());\n+        assertTrue(results.get(0) instanceof KiePMMLRegressionModel);\n+        commonVerifyKiePMMLRegressionModel((KiePMMLRegressionModel) results.get(0));\n+    }\n+\n+    // TODO {gcardosi} Carbon-copy of org.kie.pmml.regression.evaluator.RegressionModelImplementationProviderTest\n+\n+    private void commonVerifyKiePMMLRegressionModel(KiePMMLRegressionModel retrieved) {\n+        assertNotNull(retrieved);\n+        assertEquals(MINING_FUNCTION.REGRESSION, retrieved.getMiningFunction());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI4Mjg0Ng=="}, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxODY2NDQwOnYy", "diffSide": "RIGHT", "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/test/java/org/kie/pmml/models/regression/compiler/executor/RegressionModelImplementationProviderTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMjo0MzowNVrOF0NH-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMjo0MzowNVrOF0NH-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI4NTMwNQ==", "bodyText": "Please remove this empty method.", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390285305", "createdAt": "2020-03-10T12:43:05Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/test/java/org/kie/pmml/models/regression/compiler/executor/RegressionModelImplementationProviderTest.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.pmml.models.regression.compiler.executor;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.dmg.pmml.PMML;\n+import org.dmg.pmml.regression.RegressionModel;\n+import org.junit.Test;\n+import org.kie.pmml.commons.model.enums.PMML_MODEL;\n+import org.kie.pmml.compiler.testutils.TestUtils;\n+import org.kie.pmml.models.regression.model.KiePMMLRegressionModel;\n+import org.kie.pmml.models.regression.model.predictors.KiePMMLCategoricalPredictor;\n+import org.kie.pmml.models.regression.model.predictors.KiePMMLNumericPredictor;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+//import org.kie.pmml.models.regression.model.KiePMMLRegressionTable;\n+\n+public class RegressionModelImplementationProviderTest {\n+\n+    private final static RegressionModelImplementationProvider PROVIDER = new RegressionModelImplementationProvider();\n+    private final static String RELEASE_ID = \"org.drools:kie-pmml-models-testing:1.0\";\n+    private static final String SOURCE_1 = \"LinearRegressionSample.xml\";\n+    private static final String SOURCE_2 = \"test_regression.pmml\";\n+    private static final String SOURCE_3 = \"test_regression_clax.pmml\";\n+\n+    @Test\n+    public void getPMMLModelType() {\n+        assertEquals(PMML_MODEL.REGRESSION_MODEL, PROVIDER.getPMMLModelType());\n+    }\n+\n+    @Test\n+    public void getKiePMMLModel() throws Exception {\n+        final PMML pmml = TestUtils.loadFromFile(SOURCE_1);\n+        assertNotNull(pmml);\n+        assertEquals(1, pmml.getModels().size());\n+        assertTrue(pmml.getModels().get(0) instanceof RegressionModel);\n+        commonVerifyKiePMMLRegressionModel(PROVIDER.getKiePMMLModel(pmml.getDataDictionary(), (RegressionModel) pmml.getModels().get(0), RELEASE_ID));\n+    }\n+\n+    @Test\n+    public void validateSource2() throws Exception {\n+        commonValidateSource(SOURCE_2);\n+    }\n+\n+    @Test\n+    public void validateSource3() throws Exception {\n+        commonValidateSource(SOURCE_3);\n+    }\n+\n+    private void commonValidateSource(String sourceFile) throws Exception {\n+        final PMML pmml = TestUtils.loadFromFile(sourceFile);\n+        assertNotNull(pmml);\n+        assertEquals(1, pmml.getModels().size());\n+        assertTrue(pmml.getModels().get(0) instanceof RegressionModel);\n+        PROVIDER.validate(pmml.getDataDictionary(), (RegressionModel) pmml.getModels().get(0));\n+    }\n+\n+    private void commonVerifyKiePMMLRegressionModel(KiePMMLRegressionModel retrieved) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxODY2NDg5OnYy", "diffSide": "RIGHT", "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/test/java/org/kie/pmml/models/regression/compiler/executor/RegressionModelImplementationProviderTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMjo0MzoxMVrOF0NIQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMjo0MzoxMVrOF0NIQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI4NTM3Nw==", "bodyText": "Please remove this empty method.", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390285377", "createdAt": "2020-03-10T12:43:11Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/test/java/org/kie/pmml/models/regression/compiler/executor/RegressionModelImplementationProviderTest.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.pmml.models.regression.compiler.executor;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.dmg.pmml.PMML;\n+import org.dmg.pmml.regression.RegressionModel;\n+import org.junit.Test;\n+import org.kie.pmml.commons.model.enums.PMML_MODEL;\n+import org.kie.pmml.compiler.testutils.TestUtils;\n+import org.kie.pmml.models.regression.model.KiePMMLRegressionModel;\n+import org.kie.pmml.models.regression.model.predictors.KiePMMLCategoricalPredictor;\n+import org.kie.pmml.models.regression.model.predictors.KiePMMLNumericPredictor;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+//import org.kie.pmml.models.regression.model.KiePMMLRegressionTable;\n+\n+public class RegressionModelImplementationProviderTest {\n+\n+    private final static RegressionModelImplementationProvider PROVIDER = new RegressionModelImplementationProvider();\n+    private final static String RELEASE_ID = \"org.drools:kie-pmml-models-testing:1.0\";\n+    private static final String SOURCE_1 = \"LinearRegressionSample.xml\";\n+    private static final String SOURCE_2 = \"test_regression.pmml\";\n+    private static final String SOURCE_3 = \"test_regression_clax.pmml\";\n+\n+    @Test\n+    public void getPMMLModelType() {\n+        assertEquals(PMML_MODEL.REGRESSION_MODEL, PROVIDER.getPMMLModelType());\n+    }\n+\n+    @Test\n+    public void getKiePMMLModel() throws Exception {\n+        final PMML pmml = TestUtils.loadFromFile(SOURCE_1);\n+        assertNotNull(pmml);\n+        assertEquals(1, pmml.getModels().size());\n+        assertTrue(pmml.getModels().get(0) instanceof RegressionModel);\n+        commonVerifyKiePMMLRegressionModel(PROVIDER.getKiePMMLModel(pmml.getDataDictionary(), (RegressionModel) pmml.getModels().get(0), RELEASE_ID));\n+    }\n+\n+    @Test\n+    public void validateSource2() throws Exception {\n+        commonValidateSource(SOURCE_2);\n+    }\n+\n+    @Test\n+    public void validateSource3() throws Exception {\n+        commonValidateSource(SOURCE_3);\n+    }\n+\n+    private void commonValidateSource(String sourceFile) throws Exception {\n+        final PMML pmml = TestUtils.loadFromFile(sourceFile);\n+        assertNotNull(pmml);\n+        assertEquals(1, pmml.getModels().size());\n+        assertTrue(pmml.getModels().get(0) instanceof RegressionModel);\n+        PROVIDER.validate(pmml.getDataDictionary(), (RegressionModel) pmml.getModels().get(0));\n+    }\n+\n+    private void commonVerifyKiePMMLRegressionModel(KiePMMLRegressionModel retrieved) {\n+//        assertNotNull(retrieved);\n+//        assertEquals(MINING_FUNCTION.REGRESSION, retrieved.getMiningFunction());\n+//        assertTrue(retrieved.getAlgorithmName().isPresent());\n+//        assertEquals(\"linearRegression\", retrieved.getAlgorithmName().get());\n+//        assertFalse(retrieved.getModelType().isPresent());\n+//        assertEquals(\"number_of_claims\", retrieved.getTargetField());\n+//        assertEquals(OP_TYPE.CONTINUOUS, retrieved.getTargetOpType());\n+//        assertEquals(REGRESSION_NORMALIZATION_METHOD.NONE, retrieved.getRegressionNormalizationMethod());\n+//        assertTrue(retrieved.isScorable());\n+//        assertTrue(retrieved.isRegression());\n+//        assertEquals(1, retrieved.getRegressionTables().size());\n+//        commonVerifyKiePMMLRegressionTable(retrieved.getRegressionTables().get(0));\n+    }\n+\n+//    private void commonVerifyKiePMMLRegressionTable(KiePMMLRegressionTable retrieved) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxODY2NTIxOnYy", "diffSide": "RIGHT", "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/test/java/org/kie/pmml/models/regression/compiler/executor/RegressionModelImplementationProviderTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMjo0MzoxN1rOF0NIdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMjo0MzoxN1rOF0NIdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI4NTQzMA==", "bodyText": "Please remove this empty method.", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390285430", "createdAt": "2020-03-10T12:43:17Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/test/java/org/kie/pmml/models/regression/compiler/executor/RegressionModelImplementationProviderTest.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.pmml.models.regression.compiler.executor;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.dmg.pmml.PMML;\n+import org.dmg.pmml.regression.RegressionModel;\n+import org.junit.Test;\n+import org.kie.pmml.commons.model.enums.PMML_MODEL;\n+import org.kie.pmml.compiler.testutils.TestUtils;\n+import org.kie.pmml.models.regression.model.KiePMMLRegressionModel;\n+import org.kie.pmml.models.regression.model.predictors.KiePMMLCategoricalPredictor;\n+import org.kie.pmml.models.regression.model.predictors.KiePMMLNumericPredictor;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+//import org.kie.pmml.models.regression.model.KiePMMLRegressionTable;\n+\n+public class RegressionModelImplementationProviderTest {\n+\n+    private final static RegressionModelImplementationProvider PROVIDER = new RegressionModelImplementationProvider();\n+    private final static String RELEASE_ID = \"org.drools:kie-pmml-models-testing:1.0\";\n+    private static final String SOURCE_1 = \"LinearRegressionSample.xml\";\n+    private static final String SOURCE_2 = \"test_regression.pmml\";\n+    private static final String SOURCE_3 = \"test_regression_clax.pmml\";\n+\n+    @Test\n+    public void getPMMLModelType() {\n+        assertEquals(PMML_MODEL.REGRESSION_MODEL, PROVIDER.getPMMLModelType());\n+    }\n+\n+    @Test\n+    public void getKiePMMLModel() throws Exception {\n+        final PMML pmml = TestUtils.loadFromFile(SOURCE_1);\n+        assertNotNull(pmml);\n+        assertEquals(1, pmml.getModels().size());\n+        assertTrue(pmml.getModels().get(0) instanceof RegressionModel);\n+        commonVerifyKiePMMLRegressionModel(PROVIDER.getKiePMMLModel(pmml.getDataDictionary(), (RegressionModel) pmml.getModels().get(0), RELEASE_ID));\n+    }\n+\n+    @Test\n+    public void validateSource2() throws Exception {\n+        commonValidateSource(SOURCE_2);\n+    }\n+\n+    @Test\n+    public void validateSource3() throws Exception {\n+        commonValidateSource(SOURCE_3);\n+    }\n+\n+    private void commonValidateSource(String sourceFile) throws Exception {\n+        final PMML pmml = TestUtils.loadFromFile(sourceFile);\n+        assertNotNull(pmml);\n+        assertEquals(1, pmml.getModels().size());\n+        assertTrue(pmml.getModels().get(0) instanceof RegressionModel);\n+        PROVIDER.validate(pmml.getDataDictionary(), (RegressionModel) pmml.getModels().get(0));\n+    }\n+\n+    private void commonVerifyKiePMMLRegressionModel(KiePMMLRegressionModel retrieved) {\n+//        assertNotNull(retrieved);\n+//        assertEquals(MINING_FUNCTION.REGRESSION, retrieved.getMiningFunction());\n+//        assertTrue(retrieved.getAlgorithmName().isPresent());\n+//        assertEquals(\"linearRegression\", retrieved.getAlgorithmName().get());\n+//        assertFalse(retrieved.getModelType().isPresent());\n+//        assertEquals(\"number_of_claims\", retrieved.getTargetField());\n+//        assertEquals(OP_TYPE.CONTINUOUS, retrieved.getTargetOpType());\n+//        assertEquals(REGRESSION_NORMALIZATION_METHOD.NONE, retrieved.getRegressionNormalizationMethod());\n+//        assertTrue(retrieved.isScorable());\n+//        assertTrue(retrieved.isRegression());\n+//        assertEquals(1, retrieved.getRegressionTables().size());\n+//        commonVerifyKiePMMLRegressionTable(retrieved.getRegressionTables().get(0));\n+    }\n+\n+//    private void commonVerifyKiePMMLRegressionTable(KiePMMLRegressionTable retrieved) {\n+//        assertNotNull(retrieved);\n+//        assertEquals(132.37, retrieved.getIntercept());\n+//        assertFalse(retrieved.getTargetCategory().isPresent());\n+//        assertTrue(retrieved.getNumericPredictors().isPresent());\n+//        assertEquals(2, retrieved.getNumericPredictors().get().size());\n+//        assertTrue(retrieved.getCategoricalPredictors().isPresent());\n+//        assertEquals(2, retrieved.getCategoricalPredictors().get().size());\n+//        commonVerifyNumericPredictors(retrieved, \"age\", 1, 7.1);\n+//        commonVerifyNumericPredictors(retrieved, \"salary\", 1, 0.01);\n+//        commonVerifyCategoricalPredictors(retrieved, \"car_location\");\n+//    }\n+\n+//    private void commonVerifyNumericPredictors(KiePMMLRegressionTable retrieved, String name, int exponent, double coefficient) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxODY2NTUwOnYy", "diffSide": "RIGHT", "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/test/java/org/kie/pmml/models/regression/compiler/executor/RegressionModelImplementationProviderTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMjo0MzoyMlrOF0NIqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMjo0MzoyMlrOF0NIqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI4NTQ4MA==", "bodyText": "Please remove this empty method.", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390285480", "createdAt": "2020-03-10T12:43:22Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/test/java/org/kie/pmml/models/regression/compiler/executor/RegressionModelImplementationProviderTest.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.pmml.models.regression.compiler.executor;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.dmg.pmml.PMML;\n+import org.dmg.pmml.regression.RegressionModel;\n+import org.junit.Test;\n+import org.kie.pmml.commons.model.enums.PMML_MODEL;\n+import org.kie.pmml.compiler.testutils.TestUtils;\n+import org.kie.pmml.models.regression.model.KiePMMLRegressionModel;\n+import org.kie.pmml.models.regression.model.predictors.KiePMMLCategoricalPredictor;\n+import org.kie.pmml.models.regression.model.predictors.KiePMMLNumericPredictor;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+//import org.kie.pmml.models.regression.model.KiePMMLRegressionTable;\n+\n+public class RegressionModelImplementationProviderTest {\n+\n+    private final static RegressionModelImplementationProvider PROVIDER = new RegressionModelImplementationProvider();\n+    private final static String RELEASE_ID = \"org.drools:kie-pmml-models-testing:1.0\";\n+    private static final String SOURCE_1 = \"LinearRegressionSample.xml\";\n+    private static final String SOURCE_2 = \"test_regression.pmml\";\n+    private static final String SOURCE_3 = \"test_regression_clax.pmml\";\n+\n+    @Test\n+    public void getPMMLModelType() {\n+        assertEquals(PMML_MODEL.REGRESSION_MODEL, PROVIDER.getPMMLModelType());\n+    }\n+\n+    @Test\n+    public void getKiePMMLModel() throws Exception {\n+        final PMML pmml = TestUtils.loadFromFile(SOURCE_1);\n+        assertNotNull(pmml);\n+        assertEquals(1, pmml.getModels().size());\n+        assertTrue(pmml.getModels().get(0) instanceof RegressionModel);\n+        commonVerifyKiePMMLRegressionModel(PROVIDER.getKiePMMLModel(pmml.getDataDictionary(), (RegressionModel) pmml.getModels().get(0), RELEASE_ID));\n+    }\n+\n+    @Test\n+    public void validateSource2() throws Exception {\n+        commonValidateSource(SOURCE_2);\n+    }\n+\n+    @Test\n+    public void validateSource3() throws Exception {\n+        commonValidateSource(SOURCE_3);\n+    }\n+\n+    private void commonValidateSource(String sourceFile) throws Exception {\n+        final PMML pmml = TestUtils.loadFromFile(sourceFile);\n+        assertNotNull(pmml);\n+        assertEquals(1, pmml.getModels().size());\n+        assertTrue(pmml.getModels().get(0) instanceof RegressionModel);\n+        PROVIDER.validate(pmml.getDataDictionary(), (RegressionModel) pmml.getModels().get(0));\n+    }\n+\n+    private void commonVerifyKiePMMLRegressionModel(KiePMMLRegressionModel retrieved) {\n+//        assertNotNull(retrieved);\n+//        assertEquals(MINING_FUNCTION.REGRESSION, retrieved.getMiningFunction());\n+//        assertTrue(retrieved.getAlgorithmName().isPresent());\n+//        assertEquals(\"linearRegression\", retrieved.getAlgorithmName().get());\n+//        assertFalse(retrieved.getModelType().isPresent());\n+//        assertEquals(\"number_of_claims\", retrieved.getTargetField());\n+//        assertEquals(OP_TYPE.CONTINUOUS, retrieved.getTargetOpType());\n+//        assertEquals(REGRESSION_NORMALIZATION_METHOD.NONE, retrieved.getRegressionNormalizationMethod());\n+//        assertTrue(retrieved.isScorable());\n+//        assertTrue(retrieved.isRegression());\n+//        assertEquals(1, retrieved.getRegressionTables().size());\n+//        commonVerifyKiePMMLRegressionTable(retrieved.getRegressionTables().get(0));\n+    }\n+\n+//    private void commonVerifyKiePMMLRegressionTable(KiePMMLRegressionTable retrieved) {\n+//        assertNotNull(retrieved);\n+//        assertEquals(132.37, retrieved.getIntercept());\n+//        assertFalse(retrieved.getTargetCategory().isPresent());\n+//        assertTrue(retrieved.getNumericPredictors().isPresent());\n+//        assertEquals(2, retrieved.getNumericPredictors().get().size());\n+//        assertTrue(retrieved.getCategoricalPredictors().isPresent());\n+//        assertEquals(2, retrieved.getCategoricalPredictors().get().size());\n+//        commonVerifyNumericPredictors(retrieved, \"age\", 1, 7.1);\n+//        commonVerifyNumericPredictors(retrieved, \"salary\", 1, 0.01);\n+//        commonVerifyCategoricalPredictors(retrieved, \"car_location\");\n+//    }\n+\n+//    private void commonVerifyNumericPredictors(KiePMMLRegressionTable retrieved, String name, int exponent, double coefficient) {\n+//        final Optional<KiePMMLNumericPredictor> optionalPredictor = retrieved.getKiePMMLNumericPredictorByName(name);\n+//        assertTrue(optionalPredictor.isPresent());\n+//        commonVerifyNumericPredictor(optionalPredictor.get(), name, exponent, coefficient);\n+//    }\n+\n+    private void commonVerifyNumericPredictor(KiePMMLNumericPredictor retrieved, String name, int exponent, double coefficient) {\n+        assertEquals(name, retrieved.getName());\n+        assertEquals(exponent, retrieved.getExponent());\n+        assertEquals(coefficient, retrieved.getCoefficient());\n+    }\n+\n+//    private void commonVerifyCategoricalPredictors(KiePMMLRegressionTable retrieved, String name) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxODY3NDExOnYy", "diffSide": "RIGHT", "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/test/java/org/kie/pmml/models/regression/compiler/factories/KiePMMLRegressionModelFactoryTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMjo0NTo1MVrOF0NNxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMjo0NTo1MVrOF0NNxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI4Njc5MQ==", "bodyText": "Would it be possible to split this stream into multiple steps? I personally don't like such long streams because it is usually very poorly readable and it is hard to figure out what is happening.", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390286791", "createdAt": "2020-03-10T12:45:51Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/test/java/org/kie/pmml/models/regression/compiler/factories/KiePMMLRegressionModelFactoryTest.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.pmml.models.regression.compiler.factories;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import org.dmg.pmml.DataDictionary;\n+import org.dmg.pmml.DataField;\n+import org.dmg.pmml.MiningField;\n+import org.dmg.pmml.MiningFunction;\n+import org.dmg.pmml.MiningSchema;\n+import org.dmg.pmml.OpType;\n+import org.dmg.pmml.regression.CategoricalPredictor;\n+import org.dmg.pmml.regression.NumericPredictor;\n+import org.dmg.pmml.regression.PredictorTerm;\n+import org.dmg.pmml.regression.RegressionModel;\n+import org.dmg.pmml.regression.RegressionTable;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.kie.pmml.models.regression.model.KiePMMLRegressionModel;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.kie.pmml.compiler.commons.testutils.PMMLModelTestUtils.getCategoricalPredictor;\n+import static org.kie.pmml.compiler.commons.testutils.PMMLModelTestUtils.getDataDictionary;\n+import static org.kie.pmml.compiler.commons.testutils.PMMLModelTestUtils.getDataField;\n+import static org.kie.pmml.compiler.commons.testutils.PMMLModelTestUtils.getMiningField;\n+import static org.kie.pmml.compiler.commons.testutils.PMMLModelTestUtils.getMiningSchema;\n+import static org.kie.pmml.compiler.commons.testutils.PMMLModelTestUtils.getNumericPredictor;\n+import static org.kie.pmml.compiler.commons.testutils.PMMLModelTestUtils.getPredictorTerm;\n+import static org.kie.pmml.compiler.commons.testutils.PMMLModelTestUtils.getRegressionModel;\n+import static org.kie.pmml.compiler.commons.testutils.PMMLModelTestUtils.getRegressionTable;\n+import static org.kie.pmml.models.regression.compiler.factories.KiePMMLRegressionModelFactory.getKiePMMLRegressionModel;\n+\n+@RunWith(Parameterized.class)\n+public class KiePMMLRegressionModelFactoryTest {\n+\n+    private List<RegressionTable> regressionTables;\n+    private List<DataField> dataFields;\n+    private List<MiningField> miningFields;\n+    private MiningField targetMiningField;\n+    private DataDictionary dataDictionary;\n+    private MiningSchema miningSchema;\n+    private RegressionModel regressionModel;\n+\n+    public KiePMMLRegressionModelFactoryTest(String modelName, double tableIntercept, Object tableTargetCategory) {\n+        Random random = new Random();\n+        Set<String> fieldNames = new HashSet<>();\n+        regressionTables = IntStream.range(0, 3).mapToObj(i -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxODY3NTY1OnYy", "diffSide": "RIGHT", "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/test/java/org/kie/pmml/models/regression/compiler/factories/KiePMMLRegressionTableClassificationFactoryTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMjo0NjoyMFrOF0NOuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMjo0NjoyMFrOF0NOuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI4NzAzMg==", "bodyText": "Can we uncomment this assert?", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390287032", "createdAt": "2020-03-10T12:46:20Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/test/java/org/kie/pmml/models/regression/compiler/factories/KiePMMLRegressionTableClassificationFactoryTest.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.pmml.models.regression.compiler.factories;\n+\n+import java.nio.file.Files;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.IntStream;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.validator.Java8Validator;\n+import com.github.javaparser.ast.validator.ProblemReporter;\n+import org.dmg.pmml.regression.CategoricalPredictor;\n+import org.dmg.pmml.regression.NumericPredictor;\n+import org.dmg.pmml.regression.PredictorTerm;\n+import org.dmg.pmml.regression.RegressionModel;\n+import org.dmg.pmml.regression.RegressionTable;\n+import org.junit.Test;\n+import org.kie.pmml.commons.model.KiePMMLOutputField;\n+import org.kie.pmml.commons.model.enums.RESULT_FEATURE;\n+import org.kie.pmml.compiler.commons.testutils.PMMLModelTestUtils;\n+import org.kie.pmml.models.regression.model.tuples.KiePMMLTableSourceCategory;\n+import org.kie.test.util.filesystem.FileUtils;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.kie.pmml.compiler.commons.testutils.PMMLModelTestUtils.getCategoricalPredictor;\n+import static org.kie.pmml.compiler.commons.testutils.PMMLModelTestUtils.getNumericPredictor;\n+import static org.kie.pmml.compiler.commons.testutils.PMMLModelTestUtils.getPredictorTerm;\n+\n+public class KiePMMLRegressionTableClassificationFactoryTest {\n+\n+    private List<CategoricalPredictor> categoricalPredictors;\n+    private List<NumericPredictor> numericPredictors;\n+    private List<PredictorTerm> predictorTerms;\n+\n+    @Test\n+    public void getRegressionTableTest() throws Exception {\n+        RegressionTable regressionTableProf = getRegressionTable(3.5, \"professional\");\n+        RegressionTable regressionTableCler = getRegressionTable(27.4, \"clerical\");\n+        List<RegressionTable> regressionTables = Arrays.asList(regressionTableProf, regressionTableCler);\n+        KiePMMLOutputField outputFieldCat = getOutputField(\"CAT-1\", RESULT_FEATURE.PROBABILITY, \"CatPred-1\");\n+        KiePMMLOutputField outputFieldNum = getOutputField(\"NUM-1\", RESULT_FEATURE.PROBABILITY, \"NumPred-0\");\n+        KiePMMLOutputField outputFieldPrev = getOutputField(\"PREV\", RESULT_FEATURE.PREDICTED_VALUE, null);\n+        List<KiePMMLOutputField> outputFields = Arrays.asList(outputFieldCat, outputFieldNum, outputFieldPrev);\n+        Map<String, KiePMMLTableSourceCategory> retrieved = KiePMMLRegressionTableClassificationFactory.getRegressionTables(regressionTables, RegressionModel.NormalizationMethod.SOFTMAX, outputFields, \"targetField\");\n+        assertNotNull(retrieved);\n+        assertEquals(3, retrieved.size());\n+//        assertTrue(retrieved.containsKey(\"KiePMMLRegressionTableClassification1\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxODY3ODMxOnYy", "diffSide": "RIGHT", "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-evaluator/src/main/java/org/kie/pmml/models/regression/evaluator/PMMLRegressionModelExecutor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMjo0NzowOFrOF0NQUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMjo0NzowOFrOF0NQUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI4NzQ0Mg==", "bodyText": "Please remove commented code.", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390287442", "createdAt": "2020-03-10T12:47:08Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-evaluator/src/main/java/org/kie/pmml/models/regression/evaluator/PMMLRegressionModelExecutor.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.evaluator;\n+\n+import java.util.Map;\n+\n+import org.kie.api.pmml.PMML4Result;\n+import org.kie.pmml.commons.model.KiePMMLModel;\n+import org.kie.pmml.commons.model.enums.PMML_MODEL;\n+import org.kie.pmml.evaluator.api.executor.PMMLContext;\n+import org.kie.pmml.evaluator.core.executor.PMMLModelExecutor;\n+\n+import static org.kie.pmml.commons.enums.StatusCode.OK;\n+import static org.kie.pmml.evaluator.core.utils.Converter.getUnwrappedParametersMap;\n+\n+public class PMMLRegressionModelExecutor implements PMMLModelExecutor {\n+\n+    private static final String INVALID_NORMALIZATION_METHOD = \"Invalid Normalization Method %s\";\n+    private static final String EXPECTED_AT_LEAST_TWO_REGRESSION_TABLES_RETRIEVED = \"Expected at least two RegressionTables, retrieved %s\";\n+    private static final String EXPECTED_TWO_REGRESSION_TABLES_RETRIEVED = \"Expected two RegressionTables, retrieved %s\";\n+    private static final String EXPECTED_A_KIE_PMMLREGRESSION_MODEL_RECEIVED = \"Expected a KiePMMLRegressionModel, received %s \";\n+    private static final String TARGET_FIELD_REQUIRED_RETRIEVED = \"TargetField required, retrieved %s\";\n+    private static final String EXPECTED_ONE_REGRESSION_TABLE_RETRIEVED = \"Expected one RegressionTable, retrieved %s\";\n+    private static final String INVALID_TARGET_TYPE = \"Invalid target type %s\";\n+\n+    @Override\n+    public PMML_MODEL getPMMLModelType() {\n+        return PMML_MODEL.REGRESSION_MODEL;\n+    }\n+\n+    @Override\n+    public PMML4Result evaluate(KiePMMLModel model, PMMLContext pmmlContext, String releaseId) {\n+        validate(model);\n+        PMML4Result toReturn = new PMML4Result();\n+        String targetField = model.getTargetField();\n+        final Map<String, Object> requestData = getUnwrappedParametersMap(pmmlContext.getRequestData().getMappedRequestParams());\n+        Object result = model.evaluate(requestData);\n+        toReturn.addResultVariable(targetField, result);\n+        toReturn.setResultObjectName(targetField);\n+        toReturn.setResultCode(OK.getName());\n+        model.getOutputFieldsMap().forEach(toReturn::addResultVariable);\n+        return toReturn;\n+\n+//        final KiePMMLRegressionModel regressionModel = (KiePMMLRegressionModel) model;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxODY4MTk2OnYy", "diffSide": "RIGHT", "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-evaluator/src/main/java/org/kie/pmml/models/regression/evaluator/PMMLRegressionModelExecutor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMjo0ODoxNlrOF0NSnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNDozNjowMFrOF05w4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI4ODAyOQ==", "bodyText": "We can add some warning into logs. Something like \"Validation was skipped because of backward compatibility\".", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390288029", "createdAt": "2020-03-10T12:48:16Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-evaluator/src/main/java/org/kie/pmml/models/regression/evaluator/PMMLRegressionModelExecutor.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.evaluator;\n+\n+import java.util.Map;\n+\n+import org.kie.api.pmml.PMML4Result;\n+import org.kie.pmml.commons.model.KiePMMLModel;\n+import org.kie.pmml.commons.model.enums.PMML_MODEL;\n+import org.kie.pmml.evaluator.api.executor.PMMLContext;\n+import org.kie.pmml.evaluator.core.executor.PMMLModelExecutor;\n+\n+import static org.kie.pmml.commons.enums.StatusCode.OK;\n+import static org.kie.pmml.evaluator.core.utils.Converter.getUnwrappedParametersMap;\n+\n+public class PMMLRegressionModelExecutor implements PMMLModelExecutor {\n+\n+    private static final String INVALID_NORMALIZATION_METHOD = \"Invalid Normalization Method %s\";\n+    private static final String EXPECTED_AT_LEAST_TWO_REGRESSION_TABLES_RETRIEVED = \"Expected at least two RegressionTables, retrieved %s\";\n+    private static final String EXPECTED_TWO_REGRESSION_TABLES_RETRIEVED = \"Expected two RegressionTables, retrieved %s\";\n+    private static final String EXPECTED_A_KIE_PMMLREGRESSION_MODEL_RECEIVED = \"Expected a KiePMMLRegressionModel, received %s \";\n+    private static final String TARGET_FIELD_REQUIRED_RETRIEVED = \"TargetField required, retrieved %s\";\n+    private static final String EXPECTED_ONE_REGRESSION_TABLE_RETRIEVED = \"Expected one RegressionTable, retrieved %s\";\n+    private static final String INVALID_TARGET_TYPE = \"Invalid target type %s\";\n+\n+    @Override\n+    public PMML_MODEL getPMMLModelType() {\n+        return PMML_MODEL.REGRESSION_MODEL;\n+    }\n+\n+    @Override\n+    public PMML4Result evaluate(KiePMMLModel model, PMMLContext pmmlContext, String releaseId) {\n+        validate(model);\n+        PMML4Result toReturn = new PMML4Result();\n+        String targetField = model.getTargetField();\n+        final Map<String, Object> requestData = getUnwrappedParametersMap(pmmlContext.getRequestData().getMappedRequestParams());\n+        Object result = model.evaluate(requestData);\n+        toReturn.addResultVariable(targetField, result);\n+        toReturn.setResultObjectName(targetField);\n+        toReturn.setResultCode(OK.getName());\n+        model.getOutputFieldsMap().forEach(toReturn::addResultVariable);\n+        return toReturn;\n+\n+//        final KiePMMLRegressionModel regressionModel = (KiePMMLRegressionModel) model;\n+//        return (regressionModel).isRegression() ? evaluateRegression(regressionModel, pmmlContext) : PMMLClassificationModelEvaluator.evaluateClassification(regressionModel, pmmlContext);\n+    }\n+\n+    private void validate(KiePMMLModel toValidate) {\n+        // NO OP - backward compatibility", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAxNjY3NA==", "bodyText": "@jiripetrlik\nRestored validation", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r391016674", "createdAt": "2020-03-11T14:36:00Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-evaluator/src/main/java/org/kie/pmml/models/regression/evaluator/PMMLRegressionModelExecutor.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.evaluator;\n+\n+import java.util.Map;\n+\n+import org.kie.api.pmml.PMML4Result;\n+import org.kie.pmml.commons.model.KiePMMLModel;\n+import org.kie.pmml.commons.model.enums.PMML_MODEL;\n+import org.kie.pmml.evaluator.api.executor.PMMLContext;\n+import org.kie.pmml.evaluator.core.executor.PMMLModelExecutor;\n+\n+import static org.kie.pmml.commons.enums.StatusCode.OK;\n+import static org.kie.pmml.evaluator.core.utils.Converter.getUnwrappedParametersMap;\n+\n+public class PMMLRegressionModelExecutor implements PMMLModelExecutor {\n+\n+    private static final String INVALID_NORMALIZATION_METHOD = \"Invalid Normalization Method %s\";\n+    private static final String EXPECTED_AT_LEAST_TWO_REGRESSION_TABLES_RETRIEVED = \"Expected at least two RegressionTables, retrieved %s\";\n+    private static final String EXPECTED_TWO_REGRESSION_TABLES_RETRIEVED = \"Expected two RegressionTables, retrieved %s\";\n+    private static final String EXPECTED_A_KIE_PMMLREGRESSION_MODEL_RECEIVED = \"Expected a KiePMMLRegressionModel, received %s \";\n+    private static final String TARGET_FIELD_REQUIRED_RETRIEVED = \"TargetField required, retrieved %s\";\n+    private static final String EXPECTED_ONE_REGRESSION_TABLE_RETRIEVED = \"Expected one RegressionTable, retrieved %s\";\n+    private static final String INVALID_TARGET_TYPE = \"Invalid target type %s\";\n+\n+    @Override\n+    public PMML_MODEL getPMMLModelType() {\n+        return PMML_MODEL.REGRESSION_MODEL;\n+    }\n+\n+    @Override\n+    public PMML4Result evaluate(KiePMMLModel model, PMMLContext pmmlContext, String releaseId) {\n+        validate(model);\n+        PMML4Result toReturn = new PMML4Result();\n+        String targetField = model.getTargetField();\n+        final Map<String, Object> requestData = getUnwrappedParametersMap(pmmlContext.getRequestData().getMappedRequestParams());\n+        Object result = model.evaluate(requestData);\n+        toReturn.addResultVariable(targetField, result);\n+        toReturn.setResultObjectName(targetField);\n+        toReturn.setResultCode(OK.getName());\n+        model.getOutputFieldsMap().forEach(toReturn::addResultVariable);\n+        return toReturn;\n+\n+//        final KiePMMLRegressionModel regressionModel = (KiePMMLRegressionModel) model;\n+//        return (regressionModel).isRegression() ? evaluateRegression(regressionModel, pmmlContext) : PMMLClassificationModelEvaluator.evaluateClassification(regressionModel, pmmlContext);\n+    }\n+\n+    private void validate(KiePMMLModel toValidate) {\n+        // NO OP - backward compatibility", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI4ODAyOQ=="}, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxODY4MzIzOnYy", "diffSide": "RIGHT", "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-evaluator/src/main/java/org/kie/pmml/models/regression/evaluator/PMMLRegressionModelExecutor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMjo0ODozN1rOF0NTYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMjo0ODozN1rOF0NTYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI4ODIyNg==", "bodyText": "Again either uncomment or remove this code.", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390288226", "createdAt": "2020-03-10T12:48:37Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-evaluator/src/main/java/org/kie/pmml/models/regression/evaluator/PMMLRegressionModelExecutor.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.evaluator;\n+\n+import java.util.Map;\n+\n+import org.kie.api.pmml.PMML4Result;\n+import org.kie.pmml.commons.model.KiePMMLModel;\n+import org.kie.pmml.commons.model.enums.PMML_MODEL;\n+import org.kie.pmml.evaluator.api.executor.PMMLContext;\n+import org.kie.pmml.evaluator.core.executor.PMMLModelExecutor;\n+\n+import static org.kie.pmml.commons.enums.StatusCode.OK;\n+import static org.kie.pmml.evaluator.core.utils.Converter.getUnwrappedParametersMap;\n+\n+public class PMMLRegressionModelExecutor implements PMMLModelExecutor {\n+\n+    private static final String INVALID_NORMALIZATION_METHOD = \"Invalid Normalization Method %s\";\n+    private static final String EXPECTED_AT_LEAST_TWO_REGRESSION_TABLES_RETRIEVED = \"Expected at least two RegressionTables, retrieved %s\";\n+    private static final String EXPECTED_TWO_REGRESSION_TABLES_RETRIEVED = \"Expected two RegressionTables, retrieved %s\";\n+    private static final String EXPECTED_A_KIE_PMMLREGRESSION_MODEL_RECEIVED = \"Expected a KiePMMLRegressionModel, received %s \";\n+    private static final String TARGET_FIELD_REQUIRED_RETRIEVED = \"TargetField required, retrieved %s\";\n+    private static final String EXPECTED_ONE_REGRESSION_TABLE_RETRIEVED = \"Expected one RegressionTable, retrieved %s\";\n+    private static final String INVALID_TARGET_TYPE = \"Invalid target type %s\";\n+\n+    @Override\n+    public PMML_MODEL getPMMLModelType() {\n+        return PMML_MODEL.REGRESSION_MODEL;\n+    }\n+\n+    @Override\n+    public PMML4Result evaluate(KiePMMLModel model, PMMLContext pmmlContext, String releaseId) {\n+        validate(model);\n+        PMML4Result toReturn = new PMML4Result();\n+        String targetField = model.getTargetField();\n+        final Map<String, Object> requestData = getUnwrappedParametersMap(pmmlContext.getRequestData().getMappedRequestParams());\n+        Object result = model.evaluate(requestData);\n+        toReturn.addResultVariable(targetField, result);\n+        toReturn.setResultObjectName(targetField);\n+        toReturn.setResultCode(OK.getName());\n+        model.getOutputFieldsMap().forEach(toReturn::addResultVariable);\n+        return toReturn;\n+\n+//        final KiePMMLRegressionModel regressionModel = (KiePMMLRegressionModel) model;\n+//        return (regressionModel).isRegression() ? evaluateRegression(regressionModel, pmmlContext) : PMMLClassificationModelEvaluator.evaluateClassification(regressionModel, pmmlContext);\n+    }\n+\n+    private void validate(KiePMMLModel toValidate) {\n+        // NO OP - backward compatibility\n+    }\n+\n+//    private void validate(KiePMMLModel toValidate) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxODY4NDY4OnYy", "diffSide": "RIGHT", "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-evaluator/src/test/java/org/kie/pmml/models/regression/evaluator/PMMLRegressionModelExecutorTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMjo0OTowMlrOF0NURQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMjo0OTowMlrOF0NURQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI4ODQ1Mw==", "bodyText": "Please uncomment or remove.", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390288453", "createdAt": "2020-03-10T12:49:02Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-evaluator/src/test/java/org/kie/pmml/models/regression/evaluator/PMMLRegressionModelExecutorTest.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package org.kie.pmml.models.regression.evaluator;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.pmml.commons.model.enums.PMML_MODEL;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+public class PMMLRegressionModelExecutorTest {\n+\n+    private static final String REGRESSION_MODEL_NAME = \"LinReg\";\n+    private static final String REGRESSION_TARGET_FIELD_NAME = \"fld4\";\n+    private static final String CLASSIFICATION_MODEL_NAME = \"Sample for logistic regression\";\n+    private static final String CLASSIFICATION_TARGET_FIELD_NAME = \"jobcat\";\n+    private static final String RELEASE_ID = \"RELEASE_ID\";\n+\n+    private PMMLRegressionModelExecutor executor;\n+\n+    @Before\n+    public void setUp() {\n+        executor = new PMMLRegressionModelExecutor();\n+    }\n+\n+    @Test\n+    public void getPMMLModelType() {\n+        assertEquals(PMML_MODEL.REGRESSION_MODEL, executor.getPMMLModelType());\n+    }\n+\n+//    @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxODY5MTEyOnYy", "diffSide": "RIGHT", "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-model/src/main/resources/KiePMMLEvaluateMethodTemplate.tmpl", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMjo1MDo1NFrOF0NYXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxMDozNjo0OFrOF0xaIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI4OTUwMA==", "bodyText": "Seems suspicious. Don't you forget to uncomment this code?", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390289500", "createdAt": "2020-03-10T12:50:54Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-model/src/main/resources/KiePMMLEvaluateMethodTemplate.tmpl", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.model;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+\n+public class KiePMMLEvaluateMethodTemplate {\n+\n+    private double evaluateNumericWithExponent(double input) {\n+        double coefficient = 5;\n+        double exponent = 2;\n+        // Considering exponent because it is != 1\n+        return Math.pow(input, exponent) * coefficient;\n+    }\n+\n+    private double evaluateNumericWithoutExponent(double input) {\n+        double coefficient = 1;\n+        // Ignoring exponent because it is 1\n+        return input * coefficient;\n+    }\n+\n+    private double evaluateCategorical(Object input) {\n+//        if (Objects.equals(\"x\", input)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDg3OTc3Nw==", "bodyText": "@jiripetrlik\nI use \"tmpl\" files as templates for code generation. JavaParser strip out all commented code. I leave it there as personal reminder", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390879777", "createdAt": "2020-03-11T10:36:48Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-model/src/main/resources/KiePMMLEvaluateMethodTemplate.tmpl", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.model;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+\n+public class KiePMMLEvaluateMethodTemplate {\n+\n+    private double evaluateNumericWithExponent(double input) {\n+        double coefficient = 5;\n+        double exponent = 2;\n+        // Considering exponent because it is != 1\n+        return Math.pow(input, exponent) * coefficient;\n+    }\n+\n+    private double evaluateNumericWithoutExponent(double input) {\n+        double coefficient = 1;\n+        // Ignoring exponent because it is 1\n+        return input * coefficient;\n+    }\n+\n+    private double evaluateCategorical(Object input) {\n+//        if (Objects.equals(\"x\", input)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI4OTUwMA=="}, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxODY5NDUyOnYy", "diffSide": "RIGHT", "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-model/src/test/java/org/kie/pmml/models/regression/model/KiePMMLRegressionModelTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMjo1MTo1MVrOF0Nadg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxMToyMzoyM1rOF0y6aQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI5MDAzOA==", "bodyText": "I don't understand what is going on here.", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390290038", "createdAt": "2020-03-10T12:51:51Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-model/src/test/java/org/kie/pmml/models/regression/model/KiePMMLRegressionModelTest.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.pmml.models.regression.model;\n+\n+import org.kie.pmml.commons.model.enums.MINING_FUNCTION;\n+import org.kie.pmml.commons.model.enums.OP_TYPE;\n+import org.kie.pmml.models.regression.model.enums.MODEL_TYPE;\n+import org.kie.pmml.models.regression.model.enums.REGRESSION_NORMALIZATION_METHOD;\n+\n+public class KiePMMLRegressionModelTest {\n+\n+    private static final String MODEL_NAME = \"MODEL_NAME\";\n+    private static final String ALGORITHM_NAME = \"multinom\";\n+    private static final MINING_FUNCTION _MINING_FUNCTION = MINING_FUNCTION.REGRESSION;\n+    private static final MODEL_TYPE _MODEL_TYPE = MODEL_TYPE.LINEAR_REGRESSION;\n+    private static final REGRESSION_NORMALIZATION_METHOD _REGRESSION_NORMALIZATION_METHOD = REGRESSION_NORMALIZATION_METHOD.SIMPLEMAX;\n+    private static final boolean SCORABLE = true;\n+    private static final String TARGETFIELD_NAME = \"TARGETFIELD_NAME\";\n+    private static final OP_TYPE _OP_TYPE = OP_TYPE.CONTINUOUS;\n+//\n+//    @Test\n+//    public void buildWithAll() {\n+////        final KiePMMLRegressionModel retrieved = KiePMMLRegressionModel.builder(MODEL_NAME, Collections.emptyList(), _MINING_FUNCTION, REGRESSION_TABLES, _OP_TYPE)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDkwNDQyNQ==", "bodyText": "@jiripetrlik\nAll those tests are a left-over of previous implementation. I'm going to rewrite needed ones", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390904425", "createdAt": "2020-03-11T11:23:23Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-model/src/test/java/org/kie/pmml/models/regression/model/KiePMMLRegressionModelTest.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.pmml.models.regression.model;\n+\n+import org.kie.pmml.commons.model.enums.MINING_FUNCTION;\n+import org.kie.pmml.commons.model.enums.OP_TYPE;\n+import org.kie.pmml.models.regression.model.enums.MODEL_TYPE;\n+import org.kie.pmml.models.regression.model.enums.REGRESSION_NORMALIZATION_METHOD;\n+\n+public class KiePMMLRegressionModelTest {\n+\n+    private static final String MODEL_NAME = \"MODEL_NAME\";\n+    private static final String ALGORITHM_NAME = \"multinom\";\n+    private static final MINING_FUNCTION _MINING_FUNCTION = MINING_FUNCTION.REGRESSION;\n+    private static final MODEL_TYPE _MODEL_TYPE = MODEL_TYPE.LINEAR_REGRESSION;\n+    private static final REGRESSION_NORMALIZATION_METHOD _REGRESSION_NORMALIZATION_METHOD = REGRESSION_NORMALIZATION_METHOD.SIMPLEMAX;\n+    private static final boolean SCORABLE = true;\n+    private static final String TARGETFIELD_NAME = \"TARGETFIELD_NAME\";\n+    private static final OP_TYPE _OP_TYPE = OP_TYPE.CONTINUOUS;\n+//\n+//    @Test\n+//    public void buildWithAll() {\n+////        final KiePMMLRegressionModel retrieved = KiePMMLRegressionModel.builder(MODEL_NAME, Collections.emptyList(), _MINING_FUNCTION, REGRESSION_TABLES, _OP_TYPE)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI5MDAzOA=="}, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDAyNzc2OnYy", "diffSide": "RIGHT", "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/main/java/org/kie/pmml/models/regression/compiler/executor/RegressionModelImplementationProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwODoxMTowOVrOF16v6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMToxNDoyMlrOF1_9yQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA4MTM4NQ==", "bodyText": "Please remove", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r392081385", "createdAt": "2020-03-13T08:11:09Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/main/java/org/kie/pmml/models/regression/compiler/executor/RegressionModelImplementationProvider.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.compiler.executor;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import org.dmg.pmml.DataDictionary;\n+import org.dmg.pmml.MiningFunction;\n+import org.dmg.pmml.OpType;\n+import org.dmg.pmml.regression.RegressionModel;\n+import org.kie.pmml.commons.exceptions.KiePMMLException;\n+import org.kie.pmml.commons.model.enums.OP_TYPE;\n+import org.kie.pmml.commons.model.enums.PMML_MODEL;\n+import org.kie.pmml.commons.model.tuples.KiePMMLNameOpType;\n+import org.kie.pmml.compiler.api.provider.ModelImplementationProvider;\n+import org.kie.pmml.models.regression.compiler.factories.KiePMMLRegressionModelFactory;\n+import org.kie.pmml.models.regression.model.KiePMMLRegressionModel;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.pmml.compiler.commons.utils.ModelUtils.getOpType;\n+import static org.kie.pmml.compiler.commons.utils.ModelUtils.getTargetFields;\n+//import static org.kie.pmml.models.regression.model.KiePMMLRegressionModel.PMML_MODEL_TYPE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c4a838980a18a8428b253ee431087beb471fe8d"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE2Njg1Nw==", "bodyText": "@danielezonca\nDone", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r392166857", "createdAt": "2020-03-13T11:14:22Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/main/java/org/kie/pmml/models/regression/compiler/executor/RegressionModelImplementationProvider.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.compiler.executor;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import org.dmg.pmml.DataDictionary;\n+import org.dmg.pmml.MiningFunction;\n+import org.dmg.pmml.OpType;\n+import org.dmg.pmml.regression.RegressionModel;\n+import org.kie.pmml.commons.exceptions.KiePMMLException;\n+import org.kie.pmml.commons.model.enums.OP_TYPE;\n+import org.kie.pmml.commons.model.enums.PMML_MODEL;\n+import org.kie.pmml.commons.model.tuples.KiePMMLNameOpType;\n+import org.kie.pmml.compiler.api.provider.ModelImplementationProvider;\n+import org.kie.pmml.models.regression.compiler.factories.KiePMMLRegressionModelFactory;\n+import org.kie.pmml.models.regression.model.KiePMMLRegressionModel;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.pmml.compiler.commons.utils.ModelUtils.getOpType;\n+import static org.kie.pmml.compiler.commons.utils.ModelUtils.getTargetFields;\n+//import static org.kie.pmml.models.regression.model.KiePMMLRegressionModel.PMML_MODEL_TYPE;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA4MTM4NQ=="}, "originalCommit": {"oid": "3c4a838980a18a8428b253ee431087beb471fe8d"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDA5Nzk5OnYy", "diffSide": "RIGHT", "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/main/java/org/kie/pmml/models/regression/compiler/factories/KiePMMLRegressionTableClassificationFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwODo0MDowN1rOF17buA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMToxNDoxMlrOF1_9cQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA5MjYwMA==", "bodyText": "Is it possible? What about an exception or at least a log?", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r392092600", "createdAt": "2020-03-13T08:40:07Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/main/java/org/kie/pmml/models/regression/compiler/factories/KiePMMLRegressionTableClassificationFactory.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.compiler.factories;\n+\n+import java.io.IOException;\n+import java.util.AbstractMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.BooleanLiteralExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.SimpleName;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import org.dmg.pmml.OpType;\n+import org.dmg.pmml.regression.RegressionModel;\n+import org.dmg.pmml.regression.RegressionTable;\n+import org.kie.pmml.commons.exceptions.KiePMMLInternalException;\n+import org.kie.pmml.commons.model.KiePMMLOutputField;\n+import org.kie.pmml.commons.model.enums.OP_TYPE;\n+import org.kie.pmml.models.regression.model.enums.REGRESSION_NORMALIZATION_METHOD;\n+import org.kie.pmml.models.regression.model.tuples.KiePMMLTableSourceCategory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.pmml.models.regression.compiler.factories.KiePMMLRegressionTableRegressionFactory.addMethod;\n+import static org.kie.pmml.models.regression.compiler.factories.KiePMMLRegressionTableRegressionFactory.populateGetTargetCategory;\n+\n+public class KiePMMLRegressionTableClassificationFactory {\n+\n+    public static final String KIE_PMML_REGRESSION_TABLE_CLASSIFICATION_TEMPLATE_JAVA = \"KiePMMLRegressionTableClassificationTemplate.tmpl\";\n+    private static final Logger logger = LoggerFactory.getLogger(KiePMMLRegressionTableClassificationFactory.class.getName());\n+    private static final String MAIN_CLASS_NOT_FOUND = \"Main class not found\";\n+    private static final String KIE_PMML_GET_PROBABILITY_MAP_METHOD_TEMPLATE_JAVA = \"KiePMMLGetProbabilityMapMethodTemplate.tmpl\";\n+    private static final String KIE_PMML_GET_PROBABILITY_MAP_METHOD_TEMPLATE = \"KiePMMLGetProbabilityMapMethodTemplate\";\n+    private static final String KIE_PMML_REGRESSION_TABLE_CLASSIFICATION_TEMPLATE = \"KiePMMLRegressionTableClassificationTemplate\";\n+    private static AtomicInteger classArity = new AtomicInteger(0);\n+    private static CompilationUnit templateEvaluate;\n+    private static CompilationUnit cloneEvaluate;\n+\n+    private KiePMMLRegressionTableClassificationFactory() {\n+        // Avoid instantiation\n+    }\n+\n+    public static Map<String, KiePMMLTableSourceCategory> getRegressionTables(final List<RegressionTable> regressionTables, final RegressionModel.NormalizationMethod normalizationMethod, final OpType opType, final List<KiePMMLOutputField> outputFields, final String targetField) throws IOException {\n+        logger.debug(\"getRegressionTables {}\", regressionTables);\n+        CompilationUnit templateCU = StaticJavaParser.parseResource(KIE_PMML_REGRESSION_TABLE_CLASSIFICATION_TEMPLATE_JAVA);\n+        Map<String, KiePMMLTableSourceCategory> toReturn = KiePMMLRegressionTableRegressionFactory.getRegressionTables(regressionTables, RegressionModel.NormalizationMethod.NONE, targetField);\n+        Map.Entry<String, String> regressionTableEntry = getRegressionTable(templateCU, toReturn, normalizationMethod, opType, outputFields, targetField);\n+        toReturn.put(regressionTableEntry.getKey(), new KiePMMLTableSourceCategory(regressionTableEntry.getValue(), \"\"));\n+        return toReturn;\n+    }\n+\n+    public static Map.Entry<String, String> getRegressionTable(final CompilationUnit templateCU, final Map<String, KiePMMLTableSourceCategory> regressionTablesMap, final RegressionModel.NormalizationMethod normalizationMethod, final OpType opType, final List<KiePMMLOutputField> outputFields, final String targetField) throws IOException {\n+        logger.debug(\"getRegressionTable {}\", regressionTablesMap);\n+        CompilationUnit cloneCU = templateCU.clone();\n+        final REGRESSION_NORMALIZATION_METHOD regressionNormalizationMethod = REGRESSION_NORMALIZATION_METHOD.byName(normalizationMethod.value());\n+        final OP_TYPE op_type = OP_TYPE.byName(opType.value());\n+        ClassOrInterfaceDeclaration tableTemplate = cloneCU.getClassByName(KIE_PMML_REGRESSION_TABLE_CLASSIFICATION_TEMPLATE)\n+                .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+        String className = \"KiePMMLRegressionTableClassification\" + classArity.addAndGet(1);\n+        tableTemplate.setName(className);\n+        populateGetProbabilityMapMethod(normalizationMethod, tableTemplate);\n+        populateOutputFieldsMap(tableTemplate, outputFields);\n+        populateIsBinaryMethod(opType, regressionTablesMap.size(), tableTemplate);\n+        tableTemplate.getDefaultConstructor().ifPresent(constructorDeclaration -> {\n+            setConstructor(constructorDeclaration, tableTemplate.getName(), targetField, regressionNormalizationMethod, op_type);\n+            addMapPopulation(constructorDeclaration.getBody(), regressionTablesMap);\n+        });\n+        populateGetTargetCategory(tableTemplate, null);\n+        return new AbstractMap.SimpleEntry<>(className, cloneCU.toString());\n+    }\n+\n+    /**\n+     * Set the <b>targetField</b> values inside the constructor\n+     * @param constructorDeclaration\n+     * @param generatedClassName\n+     * @param targetField\n+     */\n+    private static void setConstructor(final ConstructorDeclaration constructorDeclaration, final SimpleName generatedClassName, final String targetField, final REGRESSION_NORMALIZATION_METHOD regressionNormalizationMethod, final OP_TYPE opType) {\n+        constructorDeclaration.setName(generatedClassName);\n+        final BlockStmt body = constructorDeclaration.getBody();\n+        final List<AssignExpr> assignExprs = body.findAll(AssignExpr.class);\n+        assignExprs.forEach(assignExpr -> {\n+            final String propertyName = assignExpr.getTarget().asNameExpr().getNameAsString();\n+            switch (propertyName) {\n+                case \"targetField\":\n+                    assignExpr.setValue(new StringLiteralExpr(targetField));\n+                    break;\n+                case \"regressionNormalizationMethod\":\n+                    assignExpr.setValue(new NameExpr(regressionNormalizationMethod.getClass().getSimpleName() + \".\" + regressionNormalizationMethod.name()));\n+                    break;\n+                case \"opType\":\n+                    assignExpr.setValue(new NameExpr(opType.getClass().getSimpleName() + \".\" + opType.name()));\n+                    break;\n+                default:\n+                    // NOOP", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c4a838980a18a8428b253ee431087beb471fe8d"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE2Njc2OQ==", "bodyText": "@danielezonca\nDone", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r392166769", "createdAt": "2020-03-13T11:14:12Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/main/java/org/kie/pmml/models/regression/compiler/factories/KiePMMLRegressionTableClassificationFactory.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.compiler.factories;\n+\n+import java.io.IOException;\n+import java.util.AbstractMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.BooleanLiteralExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.SimpleName;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import org.dmg.pmml.OpType;\n+import org.dmg.pmml.regression.RegressionModel;\n+import org.dmg.pmml.regression.RegressionTable;\n+import org.kie.pmml.commons.exceptions.KiePMMLInternalException;\n+import org.kie.pmml.commons.model.KiePMMLOutputField;\n+import org.kie.pmml.commons.model.enums.OP_TYPE;\n+import org.kie.pmml.models.regression.model.enums.REGRESSION_NORMALIZATION_METHOD;\n+import org.kie.pmml.models.regression.model.tuples.KiePMMLTableSourceCategory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.pmml.models.regression.compiler.factories.KiePMMLRegressionTableRegressionFactory.addMethod;\n+import static org.kie.pmml.models.regression.compiler.factories.KiePMMLRegressionTableRegressionFactory.populateGetTargetCategory;\n+\n+public class KiePMMLRegressionTableClassificationFactory {\n+\n+    public static final String KIE_PMML_REGRESSION_TABLE_CLASSIFICATION_TEMPLATE_JAVA = \"KiePMMLRegressionTableClassificationTemplate.tmpl\";\n+    private static final Logger logger = LoggerFactory.getLogger(KiePMMLRegressionTableClassificationFactory.class.getName());\n+    private static final String MAIN_CLASS_NOT_FOUND = \"Main class not found\";\n+    private static final String KIE_PMML_GET_PROBABILITY_MAP_METHOD_TEMPLATE_JAVA = \"KiePMMLGetProbabilityMapMethodTemplate.tmpl\";\n+    private static final String KIE_PMML_GET_PROBABILITY_MAP_METHOD_TEMPLATE = \"KiePMMLGetProbabilityMapMethodTemplate\";\n+    private static final String KIE_PMML_REGRESSION_TABLE_CLASSIFICATION_TEMPLATE = \"KiePMMLRegressionTableClassificationTemplate\";\n+    private static AtomicInteger classArity = new AtomicInteger(0);\n+    private static CompilationUnit templateEvaluate;\n+    private static CompilationUnit cloneEvaluate;\n+\n+    private KiePMMLRegressionTableClassificationFactory() {\n+        // Avoid instantiation\n+    }\n+\n+    public static Map<String, KiePMMLTableSourceCategory> getRegressionTables(final List<RegressionTable> regressionTables, final RegressionModel.NormalizationMethod normalizationMethod, final OpType opType, final List<KiePMMLOutputField> outputFields, final String targetField) throws IOException {\n+        logger.debug(\"getRegressionTables {}\", regressionTables);\n+        CompilationUnit templateCU = StaticJavaParser.parseResource(KIE_PMML_REGRESSION_TABLE_CLASSIFICATION_TEMPLATE_JAVA);\n+        Map<String, KiePMMLTableSourceCategory> toReturn = KiePMMLRegressionTableRegressionFactory.getRegressionTables(regressionTables, RegressionModel.NormalizationMethod.NONE, targetField);\n+        Map.Entry<String, String> regressionTableEntry = getRegressionTable(templateCU, toReturn, normalizationMethod, opType, outputFields, targetField);\n+        toReturn.put(regressionTableEntry.getKey(), new KiePMMLTableSourceCategory(regressionTableEntry.getValue(), \"\"));\n+        return toReturn;\n+    }\n+\n+    public static Map.Entry<String, String> getRegressionTable(final CompilationUnit templateCU, final Map<String, KiePMMLTableSourceCategory> regressionTablesMap, final RegressionModel.NormalizationMethod normalizationMethod, final OpType opType, final List<KiePMMLOutputField> outputFields, final String targetField) throws IOException {\n+        logger.debug(\"getRegressionTable {}\", regressionTablesMap);\n+        CompilationUnit cloneCU = templateCU.clone();\n+        final REGRESSION_NORMALIZATION_METHOD regressionNormalizationMethod = REGRESSION_NORMALIZATION_METHOD.byName(normalizationMethod.value());\n+        final OP_TYPE op_type = OP_TYPE.byName(opType.value());\n+        ClassOrInterfaceDeclaration tableTemplate = cloneCU.getClassByName(KIE_PMML_REGRESSION_TABLE_CLASSIFICATION_TEMPLATE)\n+                .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+        String className = \"KiePMMLRegressionTableClassification\" + classArity.addAndGet(1);\n+        tableTemplate.setName(className);\n+        populateGetProbabilityMapMethod(normalizationMethod, tableTemplate);\n+        populateOutputFieldsMap(tableTemplate, outputFields);\n+        populateIsBinaryMethod(opType, regressionTablesMap.size(), tableTemplate);\n+        tableTemplate.getDefaultConstructor().ifPresent(constructorDeclaration -> {\n+            setConstructor(constructorDeclaration, tableTemplate.getName(), targetField, regressionNormalizationMethod, op_type);\n+            addMapPopulation(constructorDeclaration.getBody(), regressionTablesMap);\n+        });\n+        populateGetTargetCategory(tableTemplate, null);\n+        return new AbstractMap.SimpleEntry<>(className, cloneCU.toString());\n+    }\n+\n+    /**\n+     * Set the <b>targetField</b> values inside the constructor\n+     * @param constructorDeclaration\n+     * @param generatedClassName\n+     * @param targetField\n+     */\n+    private static void setConstructor(final ConstructorDeclaration constructorDeclaration, final SimpleName generatedClassName, final String targetField, final REGRESSION_NORMALIZATION_METHOD regressionNormalizationMethod, final OP_TYPE opType) {\n+        constructorDeclaration.setName(generatedClassName);\n+        final BlockStmt body = constructorDeclaration.getBody();\n+        final List<AssignExpr> assignExprs = body.findAll(AssignExpr.class);\n+        assignExprs.forEach(assignExpr -> {\n+            final String propertyName = assignExpr.getTarget().asNameExpr().getNameAsString();\n+            switch (propertyName) {\n+                case \"targetField\":\n+                    assignExpr.setValue(new StringLiteralExpr(targetField));\n+                    break;\n+                case \"regressionNormalizationMethod\":\n+                    assignExpr.setValue(new NameExpr(regressionNormalizationMethod.getClass().getSimpleName() + \".\" + regressionNormalizationMethod.name()));\n+                    break;\n+                case \"opType\":\n+                    assignExpr.setValue(new NameExpr(opType.getClass().getSimpleName() + \".\" + opType.name()));\n+                    break;\n+                default:\n+                    // NOOP", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA5MjYwMA=="}, "originalCommit": {"oid": "3c4a838980a18a8428b253ee431087beb471fe8d"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDA5ODQ2OnYy", "diffSide": "RIGHT", "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/main/java/org/kie/pmml/models/regression/compiler/factories/KiePMMLRegressionTableClassificationFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwODo0MDoxOVrOF17cEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMToxNDowMlrOF1_9Ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA5MjY4OA==", "bodyText": "Same comment", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r392092688", "createdAt": "2020-03-13T08:40:19Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/main/java/org/kie/pmml/models/regression/compiler/factories/KiePMMLRegressionTableClassificationFactory.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.compiler.factories;\n+\n+import java.io.IOException;\n+import java.util.AbstractMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.BooleanLiteralExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.SimpleName;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import org.dmg.pmml.OpType;\n+import org.dmg.pmml.regression.RegressionModel;\n+import org.dmg.pmml.regression.RegressionTable;\n+import org.kie.pmml.commons.exceptions.KiePMMLInternalException;\n+import org.kie.pmml.commons.model.KiePMMLOutputField;\n+import org.kie.pmml.commons.model.enums.OP_TYPE;\n+import org.kie.pmml.models.regression.model.enums.REGRESSION_NORMALIZATION_METHOD;\n+import org.kie.pmml.models.regression.model.tuples.KiePMMLTableSourceCategory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.pmml.models.regression.compiler.factories.KiePMMLRegressionTableRegressionFactory.addMethod;\n+import static org.kie.pmml.models.regression.compiler.factories.KiePMMLRegressionTableRegressionFactory.populateGetTargetCategory;\n+\n+public class KiePMMLRegressionTableClassificationFactory {\n+\n+    public static final String KIE_PMML_REGRESSION_TABLE_CLASSIFICATION_TEMPLATE_JAVA = \"KiePMMLRegressionTableClassificationTemplate.tmpl\";\n+    private static final Logger logger = LoggerFactory.getLogger(KiePMMLRegressionTableClassificationFactory.class.getName());\n+    private static final String MAIN_CLASS_NOT_FOUND = \"Main class not found\";\n+    private static final String KIE_PMML_GET_PROBABILITY_MAP_METHOD_TEMPLATE_JAVA = \"KiePMMLGetProbabilityMapMethodTemplate.tmpl\";\n+    private static final String KIE_PMML_GET_PROBABILITY_MAP_METHOD_TEMPLATE = \"KiePMMLGetProbabilityMapMethodTemplate\";\n+    private static final String KIE_PMML_REGRESSION_TABLE_CLASSIFICATION_TEMPLATE = \"KiePMMLRegressionTableClassificationTemplate\";\n+    private static AtomicInteger classArity = new AtomicInteger(0);\n+    private static CompilationUnit templateEvaluate;\n+    private static CompilationUnit cloneEvaluate;\n+\n+    private KiePMMLRegressionTableClassificationFactory() {\n+        // Avoid instantiation\n+    }\n+\n+    public static Map<String, KiePMMLTableSourceCategory> getRegressionTables(final List<RegressionTable> regressionTables, final RegressionModel.NormalizationMethod normalizationMethod, final OpType opType, final List<KiePMMLOutputField> outputFields, final String targetField) throws IOException {\n+        logger.debug(\"getRegressionTables {}\", regressionTables);\n+        CompilationUnit templateCU = StaticJavaParser.parseResource(KIE_PMML_REGRESSION_TABLE_CLASSIFICATION_TEMPLATE_JAVA);\n+        Map<String, KiePMMLTableSourceCategory> toReturn = KiePMMLRegressionTableRegressionFactory.getRegressionTables(regressionTables, RegressionModel.NormalizationMethod.NONE, targetField);\n+        Map.Entry<String, String> regressionTableEntry = getRegressionTable(templateCU, toReturn, normalizationMethod, opType, outputFields, targetField);\n+        toReturn.put(regressionTableEntry.getKey(), new KiePMMLTableSourceCategory(regressionTableEntry.getValue(), \"\"));\n+        return toReturn;\n+    }\n+\n+    public static Map.Entry<String, String> getRegressionTable(final CompilationUnit templateCU, final Map<String, KiePMMLTableSourceCategory> regressionTablesMap, final RegressionModel.NormalizationMethod normalizationMethod, final OpType opType, final List<KiePMMLOutputField> outputFields, final String targetField) throws IOException {\n+        logger.debug(\"getRegressionTable {}\", regressionTablesMap);\n+        CompilationUnit cloneCU = templateCU.clone();\n+        final REGRESSION_NORMALIZATION_METHOD regressionNormalizationMethod = REGRESSION_NORMALIZATION_METHOD.byName(normalizationMethod.value());\n+        final OP_TYPE op_type = OP_TYPE.byName(opType.value());\n+        ClassOrInterfaceDeclaration tableTemplate = cloneCU.getClassByName(KIE_PMML_REGRESSION_TABLE_CLASSIFICATION_TEMPLATE)\n+                .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+        String className = \"KiePMMLRegressionTableClassification\" + classArity.addAndGet(1);\n+        tableTemplate.setName(className);\n+        populateGetProbabilityMapMethod(normalizationMethod, tableTemplate);\n+        populateOutputFieldsMap(tableTemplate, outputFields);\n+        populateIsBinaryMethod(opType, regressionTablesMap.size(), tableTemplate);\n+        tableTemplate.getDefaultConstructor().ifPresent(constructorDeclaration -> {\n+            setConstructor(constructorDeclaration, tableTemplate.getName(), targetField, regressionNormalizationMethod, op_type);\n+            addMapPopulation(constructorDeclaration.getBody(), regressionTablesMap);\n+        });\n+        populateGetTargetCategory(tableTemplate, null);\n+        return new AbstractMap.SimpleEntry<>(className, cloneCU.toString());\n+    }\n+\n+    /**\n+     * Set the <b>targetField</b> values inside the constructor\n+     * @param constructorDeclaration\n+     * @param generatedClassName\n+     * @param targetField\n+     */\n+    private static void setConstructor(final ConstructorDeclaration constructorDeclaration, final SimpleName generatedClassName, final String targetField, final REGRESSION_NORMALIZATION_METHOD regressionNormalizationMethod, final OP_TYPE opType) {\n+        constructorDeclaration.setName(generatedClassName);\n+        final BlockStmt body = constructorDeclaration.getBody();\n+        final List<AssignExpr> assignExprs = body.findAll(AssignExpr.class);\n+        assignExprs.forEach(assignExpr -> {\n+            final String propertyName = assignExpr.getTarget().asNameExpr().getNameAsString();\n+            switch (propertyName) {\n+                case \"targetField\":\n+                    assignExpr.setValue(new StringLiteralExpr(targetField));\n+                    break;\n+                case \"regressionNormalizationMethod\":\n+                    assignExpr.setValue(new NameExpr(regressionNormalizationMethod.getClass().getSimpleName() + \".\" + regressionNormalizationMethod.name()));\n+                    break;\n+                case \"opType\":\n+                    assignExpr.setValue(new NameExpr(opType.getClass().getSimpleName() + \".\" + opType.name()));\n+                    break;\n+                default:\n+                    // NOOP\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Add entries <b>category/KiePMMLRegressionTable</b> inside the constructor\n+     * @param body\n+     * @param regressionTablesMap\n+     */\n+    private static void addMapPopulation(final BlockStmt body, final Map<String, KiePMMLTableSourceCategory> regressionTablesMap) {\n+        regressionTablesMap.forEach((className, tableSourceCategory) -> {\n+            ObjectCreationExpr objectCreationExpr = new ObjectCreationExpr();\n+            objectCreationExpr.setType(className);\n+            NodeList<Expression> expressions = NodeList.nodeList(new StringLiteralExpr(tableSourceCategory.getCategory()), objectCreationExpr);\n+            body.addStatement(new MethodCallExpr(new NameExpr(\"categoryTableMap\"), \"put\", expressions));\n+        });\n+    }\n+\n+    /**\n+     * Add entries <b>output field/output value</b> inside <b>populateOutputFieldsMap</b> method\n+     * @param tableTemplate\n+     * @param outputFields\n+     */\n+    private static void populateOutputFieldsMap(final ClassOrInterfaceDeclaration tableTemplate, final List<KiePMMLOutputField> outputFields) {\n+        final MethodDeclaration methodDeclaration = tableTemplate.getMethodsByName(\"populateOutputFieldsMap\").get(0);\n+        methodDeclaration.getBody().ifPresent(body -> populateOutputFieldsMap(body, outputFields));\n+    }\n+\n+    /**\n+     * Add entries <b>output field/output value</b> inside <b>populateOutputFieldsMap</b> method\n+     * @param body\n+     * @param outputFields\n+     */\n+    private static void populateOutputFieldsMap(final BlockStmt body, final List<KiePMMLOutputField> outputFields) {\n+        outputFields.forEach(outputField -> {\n+            StringLiteralExpr key = new StringLiteralExpr(outputField.getName());\n+            Expression value = null;\n+            switch (outputField.getResultFeature()) {\n+                case PREDICTED_VALUE:\n+                    value = new MethodCallExpr(new NameExpr(\"predictedEntry\"), \"getKey\");\n+                    break;\n+                case PROBABILITY:\n+                    if (outputField.getValue() != null) {\n+                        NodeList<Expression> expressions = NodeList.nodeList(new StringLiteralExpr(outputField.getValue().toString()));\n+                        value = new MethodCallExpr(new NameExpr(\"probabilityMap\"), \"get\", expressions);\n+                    } else if (outputField.getTargetField().isPresent()) {\n+                        NodeList<Expression> expressions = NodeList.nodeList(new StringLiteralExpr(outputField.getTargetField().get()));\n+                        value = new MethodCallExpr(new NameExpr(\"probabilityMap\"), \"get\", expressions);\n+                    }\n+                    break;\n+                default:\n+                    // All other possibilities not analyzed, yet", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c4a838980a18a8428b253ee431087beb471fe8d"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE2NjY5MA==", "bodyText": "@danielezonca\nDone", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r392166690", "createdAt": "2020-03-13T11:14:02Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/main/java/org/kie/pmml/models/regression/compiler/factories/KiePMMLRegressionTableClassificationFactory.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.compiler.factories;\n+\n+import java.io.IOException;\n+import java.util.AbstractMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.BooleanLiteralExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.SimpleName;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import org.dmg.pmml.OpType;\n+import org.dmg.pmml.regression.RegressionModel;\n+import org.dmg.pmml.regression.RegressionTable;\n+import org.kie.pmml.commons.exceptions.KiePMMLInternalException;\n+import org.kie.pmml.commons.model.KiePMMLOutputField;\n+import org.kie.pmml.commons.model.enums.OP_TYPE;\n+import org.kie.pmml.models.regression.model.enums.REGRESSION_NORMALIZATION_METHOD;\n+import org.kie.pmml.models.regression.model.tuples.KiePMMLTableSourceCategory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.pmml.models.regression.compiler.factories.KiePMMLRegressionTableRegressionFactory.addMethod;\n+import static org.kie.pmml.models.regression.compiler.factories.KiePMMLRegressionTableRegressionFactory.populateGetTargetCategory;\n+\n+public class KiePMMLRegressionTableClassificationFactory {\n+\n+    public static final String KIE_PMML_REGRESSION_TABLE_CLASSIFICATION_TEMPLATE_JAVA = \"KiePMMLRegressionTableClassificationTemplate.tmpl\";\n+    private static final Logger logger = LoggerFactory.getLogger(KiePMMLRegressionTableClassificationFactory.class.getName());\n+    private static final String MAIN_CLASS_NOT_FOUND = \"Main class not found\";\n+    private static final String KIE_PMML_GET_PROBABILITY_MAP_METHOD_TEMPLATE_JAVA = \"KiePMMLGetProbabilityMapMethodTemplate.tmpl\";\n+    private static final String KIE_PMML_GET_PROBABILITY_MAP_METHOD_TEMPLATE = \"KiePMMLGetProbabilityMapMethodTemplate\";\n+    private static final String KIE_PMML_REGRESSION_TABLE_CLASSIFICATION_TEMPLATE = \"KiePMMLRegressionTableClassificationTemplate\";\n+    private static AtomicInteger classArity = new AtomicInteger(0);\n+    private static CompilationUnit templateEvaluate;\n+    private static CompilationUnit cloneEvaluate;\n+\n+    private KiePMMLRegressionTableClassificationFactory() {\n+        // Avoid instantiation\n+    }\n+\n+    public static Map<String, KiePMMLTableSourceCategory> getRegressionTables(final List<RegressionTable> regressionTables, final RegressionModel.NormalizationMethod normalizationMethod, final OpType opType, final List<KiePMMLOutputField> outputFields, final String targetField) throws IOException {\n+        logger.debug(\"getRegressionTables {}\", regressionTables);\n+        CompilationUnit templateCU = StaticJavaParser.parseResource(KIE_PMML_REGRESSION_TABLE_CLASSIFICATION_TEMPLATE_JAVA);\n+        Map<String, KiePMMLTableSourceCategory> toReturn = KiePMMLRegressionTableRegressionFactory.getRegressionTables(regressionTables, RegressionModel.NormalizationMethod.NONE, targetField);\n+        Map.Entry<String, String> regressionTableEntry = getRegressionTable(templateCU, toReturn, normalizationMethod, opType, outputFields, targetField);\n+        toReturn.put(regressionTableEntry.getKey(), new KiePMMLTableSourceCategory(regressionTableEntry.getValue(), \"\"));\n+        return toReturn;\n+    }\n+\n+    public static Map.Entry<String, String> getRegressionTable(final CompilationUnit templateCU, final Map<String, KiePMMLTableSourceCategory> regressionTablesMap, final RegressionModel.NormalizationMethod normalizationMethod, final OpType opType, final List<KiePMMLOutputField> outputFields, final String targetField) throws IOException {\n+        logger.debug(\"getRegressionTable {}\", regressionTablesMap);\n+        CompilationUnit cloneCU = templateCU.clone();\n+        final REGRESSION_NORMALIZATION_METHOD regressionNormalizationMethod = REGRESSION_NORMALIZATION_METHOD.byName(normalizationMethod.value());\n+        final OP_TYPE op_type = OP_TYPE.byName(opType.value());\n+        ClassOrInterfaceDeclaration tableTemplate = cloneCU.getClassByName(KIE_PMML_REGRESSION_TABLE_CLASSIFICATION_TEMPLATE)\n+                .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+        String className = \"KiePMMLRegressionTableClassification\" + classArity.addAndGet(1);\n+        tableTemplate.setName(className);\n+        populateGetProbabilityMapMethod(normalizationMethod, tableTemplate);\n+        populateOutputFieldsMap(tableTemplate, outputFields);\n+        populateIsBinaryMethod(opType, regressionTablesMap.size(), tableTemplate);\n+        tableTemplate.getDefaultConstructor().ifPresent(constructorDeclaration -> {\n+            setConstructor(constructorDeclaration, tableTemplate.getName(), targetField, regressionNormalizationMethod, op_type);\n+            addMapPopulation(constructorDeclaration.getBody(), regressionTablesMap);\n+        });\n+        populateGetTargetCategory(tableTemplate, null);\n+        return new AbstractMap.SimpleEntry<>(className, cloneCU.toString());\n+    }\n+\n+    /**\n+     * Set the <b>targetField</b> values inside the constructor\n+     * @param constructorDeclaration\n+     * @param generatedClassName\n+     * @param targetField\n+     */\n+    private static void setConstructor(final ConstructorDeclaration constructorDeclaration, final SimpleName generatedClassName, final String targetField, final REGRESSION_NORMALIZATION_METHOD regressionNormalizationMethod, final OP_TYPE opType) {\n+        constructorDeclaration.setName(generatedClassName);\n+        final BlockStmt body = constructorDeclaration.getBody();\n+        final List<AssignExpr> assignExprs = body.findAll(AssignExpr.class);\n+        assignExprs.forEach(assignExpr -> {\n+            final String propertyName = assignExpr.getTarget().asNameExpr().getNameAsString();\n+            switch (propertyName) {\n+                case \"targetField\":\n+                    assignExpr.setValue(new StringLiteralExpr(targetField));\n+                    break;\n+                case \"regressionNormalizationMethod\":\n+                    assignExpr.setValue(new NameExpr(regressionNormalizationMethod.getClass().getSimpleName() + \".\" + regressionNormalizationMethod.name()));\n+                    break;\n+                case \"opType\":\n+                    assignExpr.setValue(new NameExpr(opType.getClass().getSimpleName() + \".\" + opType.name()));\n+                    break;\n+                default:\n+                    // NOOP\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Add entries <b>category/KiePMMLRegressionTable</b> inside the constructor\n+     * @param body\n+     * @param regressionTablesMap\n+     */\n+    private static void addMapPopulation(final BlockStmt body, final Map<String, KiePMMLTableSourceCategory> regressionTablesMap) {\n+        regressionTablesMap.forEach((className, tableSourceCategory) -> {\n+            ObjectCreationExpr objectCreationExpr = new ObjectCreationExpr();\n+            objectCreationExpr.setType(className);\n+            NodeList<Expression> expressions = NodeList.nodeList(new StringLiteralExpr(tableSourceCategory.getCategory()), objectCreationExpr);\n+            body.addStatement(new MethodCallExpr(new NameExpr(\"categoryTableMap\"), \"put\", expressions));\n+        });\n+    }\n+\n+    /**\n+     * Add entries <b>output field/output value</b> inside <b>populateOutputFieldsMap</b> method\n+     * @param tableTemplate\n+     * @param outputFields\n+     */\n+    private static void populateOutputFieldsMap(final ClassOrInterfaceDeclaration tableTemplate, final List<KiePMMLOutputField> outputFields) {\n+        final MethodDeclaration methodDeclaration = tableTemplate.getMethodsByName(\"populateOutputFieldsMap\").get(0);\n+        methodDeclaration.getBody().ifPresent(body -> populateOutputFieldsMap(body, outputFields));\n+    }\n+\n+    /**\n+     * Add entries <b>output field/output value</b> inside <b>populateOutputFieldsMap</b> method\n+     * @param body\n+     * @param outputFields\n+     */\n+    private static void populateOutputFieldsMap(final BlockStmt body, final List<KiePMMLOutputField> outputFields) {\n+        outputFields.forEach(outputField -> {\n+            StringLiteralExpr key = new StringLiteralExpr(outputField.getName());\n+            Expression value = null;\n+            switch (outputField.getResultFeature()) {\n+                case PREDICTED_VALUE:\n+                    value = new MethodCallExpr(new NameExpr(\"predictedEntry\"), \"getKey\");\n+                    break;\n+                case PROBABILITY:\n+                    if (outputField.getValue() != null) {\n+                        NodeList<Expression> expressions = NodeList.nodeList(new StringLiteralExpr(outputField.getValue().toString()));\n+                        value = new MethodCallExpr(new NameExpr(\"probabilityMap\"), \"get\", expressions);\n+                    } else if (outputField.getTargetField().isPresent()) {\n+                        NodeList<Expression> expressions = NodeList.nodeList(new StringLiteralExpr(outputField.getTargetField().get()));\n+                        value = new MethodCallExpr(new NameExpr(\"probabilityMap\"), \"get\", expressions);\n+                    }\n+                    break;\n+                default:\n+                    // All other possibilities not analyzed, yet", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA5MjY4OA=="}, "originalCommit": {"oid": "3c4a838980a18a8428b253ee431087beb471fe8d"}, "originalPosition": 175}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDEwNzcxOnYy", "diffSide": "RIGHT", "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/main/java/org/kie/pmml/models/regression/compiler/factories/KiePMMLRegressionTableRegressionFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwODo0MzoyNFrOF17hrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMToxMzo1NFrOF1_85Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA5NDEyNw==", "bodyText": "Same comment", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r392094127", "createdAt": "2020-03-13T08:43:24Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/main/java/org/kie/pmml/models/regression/compiler/factories/KiePMMLRegressionTableRegressionFactory.java", "diffHunk": "@@ -0,0 +1,410 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.compiler.factories;\n+\n+import java.io.IOException;\n+import java.util.AbstractMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.DoubleLiteralExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.MethodReferenceExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.expr.ThisExpr;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.IfStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import org.dmg.pmml.regression.CategoricalPredictor;\n+import org.dmg.pmml.regression.NumericPredictor;\n+import org.dmg.pmml.regression.PredictorTerm;\n+import org.dmg.pmml.regression.RegressionModel;\n+import org.dmg.pmml.regression.RegressionTable;\n+import org.kie.pmml.models.regression.model.tuples.KiePMMLTableSourceCategory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+\n+public class KiePMMLRegressionTableRegressionFactory {\n+\n+    public static final String KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE_JAVA = \"KiePMMLRegressionTableRegressionTemplate.tmpl\";\n+    private static final Logger logger = LoggerFactory.getLogger(KiePMMLRegressionTableRegressionFactory.class.getName());\n+    private static final String MAIN_CLASS_NOT_FOUND = \"Main class not found\";\n+    private static final String KIE_PMML_EVALUATE_METHOD_TEMPLATE_JAVA = \"KiePMMLEvaluateMethodTemplate.tmpl\";\n+    private static final String KIE_PMML_EVALUATE_METHOD_TEMPLATE = \"KiePMMLEvaluateMethodTemplate\";\n+    private static final String KIE_PMML_UPDATE_RESULT_METHOD_TEMPLATE_JAVA = \"KiePMMLUpdateResultMethodTemplate.tmpl\";\n+    private static final String KIE_PMML_UPDATE_RESULT_METHOD_TEMPLATE = \"KiePMMLUpdateResultMethodTemplate\";\n+    private static final String KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE = \"KiePMMLRegressionTableRegressionTemplate\";\n+    private static final String COEFFICIENT = \"coefficient\";\n+    private static final String EXPONENT = \"exponent\";\n+    private static AtomicInteger classArity = new AtomicInteger(0);\n+    private static AtomicInteger predictorsArity = new AtomicInteger(0);\n+    private static CompilationUnit templateEvaluate;\n+    private static CompilationUnit cloneEvaluate;\n+\n+    private KiePMMLRegressionTableRegressionFactory() {\n+        // Avoid instantiation\n+    }\n+\n+    public static Map<String, KiePMMLTableSourceCategory> getRegressionTables(final List<RegressionTable> regressionTables, final RegressionModel.NormalizationMethod normalizationMethod, final String targetField) throws IOException {\n+        logger.debug(\"getRegressionTables {}\", regressionTables);\n+        CompilationUnit templateCU = StaticJavaParser.parseResource(KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE_JAVA);\n+        Map<String, KiePMMLTableSourceCategory> toReturn = new HashMap<>();\n+        for (RegressionTable regressionTable : regressionTables) {\n+            final Map.Entry<String, String> regressionTableEntry = getRegressionTable(templateCU, regressionTable, normalizationMethod, targetField);\n+            String targetCategory = regressionTable.getTargetCategory() != null ? regressionTable.getTargetCategory().toString() : \"\";\n+            toReturn.put(regressionTableEntry.getKey(), new KiePMMLTableSourceCategory(regressionTableEntry.getValue(), targetCategory));\n+        }\n+        return toReturn;\n+    }\n+\n+    public static AbstractMap.Entry<String, String> getRegressionTable(final CompilationUnit templateCU, final RegressionTable regressionTable, final RegressionModel.NormalizationMethod normalizationMethod, final String targetField) {\n+        logger.debug(\"getRegressionTable {}\", regressionTable);\n+        CompilationUnit cloneCU = templateCU.clone();\n+        ClassOrInterfaceDeclaration tableTemplate = cloneCU.getClassByName(KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE)\n+                .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+        String className = \"KiePMMLRegressionTableRegression\" + classArity.addAndGet(1);\n+        tableTemplate.setName(className);\n+        setConstructor(regressionTable, tableTemplate, targetField);\n+        final Map<String, MethodDeclaration> numericPredictorsMap = addNumericPredictors(regressionTable.getNumericPredictors(), tableTemplate);\n+        final Map<String, MethodDeclaration> categoricalPredictorsMap = addCategoricalPredictors(regressionTable.getCategoricalPredictors(), tableTemplate);\n+        final Map<String, MethodDeclaration> predictorTermsMap = addPredictorTerms(regressionTable.getPredictorTerms(), tableTemplate);\n+        tableTemplate.getDefaultConstructor().ifPresent(constructorDeclaration -> {\n+            final BlockStmt body = constructorDeclaration.getBody();\n+            addMapPopulation(numericPredictorsMap, body, \"numericFunctionMap\");\n+            addMapPopulation(categoricalPredictorsMap, body, \"categoricalFunctionMap\");\n+            addMapPopulation(predictorTermsMap, body, \"predictorTermsFunctionMap\");\n+        });\n+        populateGetTargetCategory(tableTemplate, regressionTable.getTargetCategory());\n+        populateUpdateResult(tableTemplate, normalizationMethod);\n+        return new AbstractMap.SimpleEntry<>(className, cloneCU.toString());\n+    }\n+\n+    /**\n+     * Add entries <b>fieldName/function</b> inside the constructor\n+     * @param toAdd\n+     * @param body\n+     * @param mapName\n+     */\n+    private static void addMapPopulation(final Map<String, MethodDeclaration> toAdd, final BlockStmt body, final String mapName) {\n+        toAdd.forEach((s, methodDeclaration) -> {\n+            MethodReferenceExpr methodReferenceExpr = new MethodReferenceExpr();\n+            methodReferenceExpr.setScope(new ThisExpr());\n+            methodReferenceExpr.setIdentifier(methodDeclaration.getNameAsString());\n+            NodeList<Expression> expressions = NodeList.nodeList(new StringLiteralExpr(s), methodReferenceExpr);\n+            body.addStatement(new MethodCallExpr(new NameExpr(mapName), \"put\", expressions));\n+        });\n+    }\n+\n+    /**\n+     * Set the <b>intercept</b> and <b>targetField</b> values inside the constructor\n+     * @param regressionTable\n+     * @param tableTemplate\n+     * @param targetField\n+     */\n+    private static void setConstructor(final RegressionTable regressionTable, final ClassOrInterfaceDeclaration tableTemplate, final String targetField) {\n+        tableTemplate.getDefaultConstructor().ifPresent(constructorDeclaration -> {\n+            constructorDeclaration.setName(tableTemplate.getName());\n+            final BlockStmt body = constructorDeclaration.getBody();\n+            final List<AssignExpr> assignExprs = body.findAll(AssignExpr.class);\n+            assignExprs.forEach(assignExpr -> {\n+                if (assignExpr.getTarget().asNameExpr().getNameAsString().equals(\"intercept\")) {\n+                    assignExpr.setValue(new DoubleLiteralExpr(String.valueOf(regressionTable.getIntercept().doubleValue())));\n+                } else if (assignExpr.getTarget().asNameExpr().getNameAsString().equals(\"targetField\")) {\n+                    assignExpr.setValue(new StringLiteralExpr(targetField));\n+                }\n+            });\n+        });\n+    }\n+\n+    /**\n+     * Add <b>NumericPredictor</b>s <code>MethodDeclaration</code> to the class\n+     * @param numericPredictors\n+     * @param tableTemplate\n+     * @return\n+     */\n+    private static Map<String, MethodDeclaration> addNumericPredictors(final List<NumericPredictor> numericPredictors, final ClassOrInterfaceDeclaration tableTemplate) {\n+        predictorsArity.set(0);\n+        return numericPredictors.stream()\n+                .map(numericPredictor -> new AbstractMap.SimpleEntry<>(numericPredictor.getName().getValue(),\n+                                                                       addNumericPredictor(numericPredictor, tableTemplate, predictorsArity.addAndGet(1))))\n+                .filter(entry -> entry.getValue().isPresent())\n+                .collect(Collectors.toMap(AbstractMap.SimpleEntry::getKey,\n+                                          entry -> entry.getValue().get()));\n+    }\n+\n+    /**\n+     * Add a <b>NumericPredictor</b> <code>MethodDeclaration</code> to the class\n+     * @param numericPredictor\n+     * @param tableTemplate\n+     * @param predictorArity\n+     * @return\n+     */\n+    private static Optional<MethodDeclaration> addNumericPredictor(final NumericPredictor numericPredictor, final ClassOrInterfaceDeclaration tableTemplate, int predictorArity) {\n+        try {\n+            templateEvaluate = StaticJavaParser.parseResource(KIE_PMML_EVALUATE_METHOD_TEMPLATE_JAVA);\n+            cloneEvaluate = templateEvaluate.clone();\n+            ClassOrInterfaceDeclaration evaluateTemplateClass = cloneEvaluate.getClassByName(KIE_PMML_EVALUATE_METHOD_TEMPLATE)\n+                    .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+            MethodDeclaration methodTemplate;\n+            if (Objects.equals(1, numericPredictor.getExponent())) {\n+                methodTemplate = getNumericPredictorWithoutExponentTemplate(numericPredictor, evaluateTemplateClass);\n+            } else {\n+                methodTemplate = getNumericPredictorWithExponentTemplate(numericPredictor, evaluateTemplateClass);\n+            }\n+            return addMethod(methodTemplate, tableTemplate, \"evaluateNumericPredictor\" + predictorArity);\n+        } catch (Exception e) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * Add a <b>NumericPredictor</b> <code>MethodDeclaration</code> with <b>exponent != 1</b> to the class\n+     * @param numericPredictor\n+     * @param evaluateTemplateClass\n+     * @return\n+     */\n+    private static MethodDeclaration getNumericPredictorWithExponentTemplate(final NumericPredictor numericPredictor, final ClassOrInterfaceDeclaration evaluateTemplateClass) {\n+        final MethodDeclaration toReturn = evaluateTemplateClass.getMethodsByName(\"evaluateNumericWithExponent\").get(0);\n+        toReturn.getBody().ifPresent(body -> {\n+            final List<VariableDeclarator> variableDeclarators = body.findAll(VariableDeclarator.class);\n+            variableDeclarators.forEach(variableDeclarator -> {\n+                String initializer = null;\n+                if (variableDeclarator.getName().asString().equals(COEFFICIENT)) {\n+                    initializer = String.valueOf(numericPredictor.getCoefficient().doubleValue());\n+                } else if (variableDeclarator.getName().asString().equals(EXPONENT)) {\n+                    initializer = String.valueOf(numericPredictor.getExponent().doubleValue());\n+                }\n+                if (initializer != null) {\n+                    variableDeclarator.setInitializer(initializer);\n+                }\n+            });\n+        });\n+        return toReturn;\n+    }\n+\n+    /**\n+     * Add a <b>NumericPredictor</b> <code>MethodDeclaration</code> with <b>exponent == 1</b> to the class\n+     * @param numericPredictor\n+     * @param evaluateTemplateClass\n+     * @return\n+     */\n+    private static MethodDeclaration getNumericPredictorWithoutExponentTemplate(final NumericPredictor numericPredictor, final ClassOrInterfaceDeclaration evaluateTemplateClass) {\n+        final MethodDeclaration toReturn = evaluateTemplateClass.getMethodsByName(\"evaluateNumericWithoutExponent\").get(0);\n+        toReturn.getBody().ifPresent(body -> {\n+            final List<VariableDeclarator> variableDeclarators = body.findAll(VariableDeclarator.class);\n+            variableDeclarators.stream().filter(variableDeclarator -> variableDeclarator.getName().asString().equals(COEFFICIENT))\n+                    .forEach(variableDeclarator -> variableDeclarator.setInitializer(String.valueOf(numericPredictor.getCoefficient().doubleValue())));\n+        });\n+        return toReturn;\n+    }\n+\n+    /**\n+     * Add <b>CategoricalPredictor</b>s <code>MethodDeclaration</code> to the class\n+     * @param categoricalPredictors\n+     * @param tableTemplate\n+     * @return\n+     */\n+    private static Map<String, MethodDeclaration> addCategoricalPredictors(final List<CategoricalPredictor> categoricalPredictors, final ClassOrInterfaceDeclaration tableTemplate) {\n+        predictorsArity.set(0);\n+        final Map<String, List<CategoricalPredictor>> groupedCollectors = categoricalPredictors.stream()\n+                .collect(groupingBy(categoricalPredictor -> categoricalPredictor.getField().getValue()));\n+        return groupedCollectors.entrySet().stream()\n+                .map(entry -> new AbstractMap.SimpleEntry<>(entry.getKey(),\n+                                                            addGroupedCategoricalPredictor(entry.getValue(), tableTemplate, predictorsArity.addAndGet(1))))\n+                .filter(entry -> entry.getValue().isPresent())\n+                .collect(Collectors.toMap(AbstractMap.SimpleEntry::getKey,\n+                                          entry -> entry.getValue().get()));\n+    }\n+\n+    /**\n+     * Add a <b>CategoricalPredictor</b> <code>MethodDeclaration</code> to the class\n+     * @param categoricalPredictors\n+     * @param tableTemplate\n+     * @param predictorArity\n+     * @return\n+     */\n+    private static Optional<MethodDeclaration> addGroupedCategoricalPredictor(final List<CategoricalPredictor> categoricalPredictors, final ClassOrInterfaceDeclaration tableTemplate, int predictorArity) {\n+        try {\n+            templateEvaluate = StaticJavaParser.parseResource(KIE_PMML_EVALUATE_METHOD_TEMPLATE_JAVA);\n+            cloneEvaluate = templateEvaluate.clone();\n+            ClassOrInterfaceDeclaration evaluateTemplateClass = cloneEvaluate.getClassByName(KIE_PMML_EVALUATE_METHOD_TEMPLATE)\n+                    .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+            MethodDeclaration methodTemplate = evaluateTemplateClass.getMethodsByName(\"evaluateCategorical\").get(0);\n+            methodTemplate.getBody().ifPresent(body -> {\n+                IfStmt ifStmt = new IfStmt();\n+                for (int i = 0; i < categoricalPredictors.size(); i++) {\n+                    CategoricalPredictor categoricalPredictor = categoricalPredictors.get(i);\n+                    Expression lhe;\n+                    if (categoricalPredictor.getValue() instanceof String) {\n+                        lhe = new StringLiteralExpr((String) categoricalPredictor.getValue());\n+                    } else {\n+                        lhe = new NameExpr(categoricalPredictor.getValue().toString());\n+                    }\n+                    NodeList<Expression> expressions = NodeList.nodeList(lhe, new NameExpr(\"input\"));\n+                    MethodCallExpr conditionExpr = new MethodCallExpr(new NameExpr(\"Objects\"), \"equals\", expressions);\n+                    if (i == 0) {\n+                        ifStmt.setCondition(conditionExpr);\n+                        ifStmt.setThenStmt(new ReturnStmt(new DoubleLiteralExpr(String.valueOf(categoricalPredictor.getCoefficient()))));\n+                        body.addStatement(ifStmt);\n+                    } else {\n+                        IfStmt elseIf = new IfStmt();\n+                        elseIf.setCondition(conditionExpr);\n+                        elseIf.setThenStmt(new ReturnStmt(new DoubleLiteralExpr(String.valueOf(categoricalPredictor.getCoefficient()))));\n+                        ifStmt.setElseStmt(elseIf);\n+                        ifStmt = elseIf;\n+                    }\n+                }\n+                ifStmt.setElseStmt(new ReturnStmt(new DoubleLiteralExpr(\"0.0\")));\n+            });\n+            return addMethod(methodTemplate, tableTemplate, \"evaluateCategoricalPredictor\" + predictorArity);\n+        } catch (Exception e) {\n+            //\n+            return Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * Add <b>PredictorTerm</b>s <code>MethodDeclaration</code> to the class\n+     * @param predictorTerms\n+     * @param tableTemplate\n+     * @return\n+     */\n+    private static Map<String, MethodDeclaration> addPredictorTerms(final List<PredictorTerm> predictorTerms, final ClassOrInterfaceDeclaration tableTemplate) {\n+        predictorsArity.set(0);\n+        return predictorTerms.stream()\n+                .map(predictorTerm -> {\n+                    int arity = predictorsArity.addAndGet(1);\n+                    return new AbstractMap.SimpleEntry<>(predictorTerm.getName() != null ? predictorTerm.getName().getValue() : \"predictorTerm\" + arity,\n+                                                         addPredictorTerm(predictorTerm, tableTemplate, arity));\n+                })\n+                .filter(entry -> entry.getValue().isPresent())\n+                .collect(Collectors.toMap(AbstractMap.SimpleEntry::getKey,\n+                                          entry -> entry.getValue().get()));\n+    }\n+\n+    /**\n+     * Add a <b>PredictorTerm</b> <code>MethodDeclaration</code> to the class\n+     * @param predictorTerm\n+     * @param tableTemplate\n+     * @param predictorArity\n+     * @return\n+     */\n+    private static Optional<MethodDeclaration> addPredictorTerm(final PredictorTerm predictorTerm, final ClassOrInterfaceDeclaration tableTemplate, int predictorArity) {\n+        try {\n+            templateEvaluate = StaticJavaParser.parseResource(KIE_PMML_EVALUATE_METHOD_TEMPLATE_JAVA);\n+            cloneEvaluate = templateEvaluate.clone();\n+            ClassOrInterfaceDeclaration evaluateTemplateClass = cloneEvaluate.getClassByName(KIE_PMML_EVALUATE_METHOD_TEMPLATE)\n+                    .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+            MethodDeclaration methodTemplate = evaluateTemplateClass.getMethodsByName(\"evaluatePredictor\").get(0);\n+            methodTemplate.getBody().ifPresent(body -> {\n+                final List<VariableDeclarator> variableDeclarators = body.findAll(VariableDeclarator.class);\n+                variableDeclarators.forEach(variableDeclarator -> {\n+                    if (variableDeclarator.getName().asString().equals(\"fieldRefs\")) {\n+                        final List<Expression> nodeList = predictorTerm.getFieldRefs().stream()\n+                                .map(fieldRef -> new StringLiteralExpr(fieldRef.getField().getValue()))\n+                                .collect(Collectors.toList());\n+                        NodeList<Expression> expressions = NodeList.nodeList(nodeList);\n+                        MethodCallExpr methodCallExpr = new MethodCallExpr(new NameExpr(\"Arrays\"), \"asList\", expressions);\n+                        variableDeclarator.setInitializer(methodCallExpr);\n+                    } else if (variableDeclarator.getName().asString().equals(COEFFICIENT)) {\n+                        variableDeclarator.setInitializer(String.valueOf(predictorTerm.getCoefficient().doubleValue()));\n+                    }\n+                });\n+            });\n+            return addMethod(methodTemplate, tableTemplate, \"evaluatePredictorTerm\" + predictorArity);\n+        } catch (Exception e) {\n+            //", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c4a838980a18a8428b253ee431087beb471fe8d"}, "originalPosition": 345}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE2NjYyOQ==", "bodyText": "@danielezonca\nDone with a slight refactoring: getting rid of  Optionals and thrown Exceptions", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r392166629", "createdAt": "2020-03-13T11:13:54Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/main/java/org/kie/pmml/models/regression/compiler/factories/KiePMMLRegressionTableRegressionFactory.java", "diffHunk": "@@ -0,0 +1,410 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.compiler.factories;\n+\n+import java.io.IOException;\n+import java.util.AbstractMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.DoubleLiteralExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.MethodReferenceExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.expr.ThisExpr;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.IfStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import org.dmg.pmml.regression.CategoricalPredictor;\n+import org.dmg.pmml.regression.NumericPredictor;\n+import org.dmg.pmml.regression.PredictorTerm;\n+import org.dmg.pmml.regression.RegressionModel;\n+import org.dmg.pmml.regression.RegressionTable;\n+import org.kie.pmml.models.regression.model.tuples.KiePMMLTableSourceCategory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+\n+public class KiePMMLRegressionTableRegressionFactory {\n+\n+    public static final String KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE_JAVA = \"KiePMMLRegressionTableRegressionTemplate.tmpl\";\n+    private static final Logger logger = LoggerFactory.getLogger(KiePMMLRegressionTableRegressionFactory.class.getName());\n+    private static final String MAIN_CLASS_NOT_FOUND = \"Main class not found\";\n+    private static final String KIE_PMML_EVALUATE_METHOD_TEMPLATE_JAVA = \"KiePMMLEvaluateMethodTemplate.tmpl\";\n+    private static final String KIE_PMML_EVALUATE_METHOD_TEMPLATE = \"KiePMMLEvaluateMethodTemplate\";\n+    private static final String KIE_PMML_UPDATE_RESULT_METHOD_TEMPLATE_JAVA = \"KiePMMLUpdateResultMethodTemplate.tmpl\";\n+    private static final String KIE_PMML_UPDATE_RESULT_METHOD_TEMPLATE = \"KiePMMLUpdateResultMethodTemplate\";\n+    private static final String KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE = \"KiePMMLRegressionTableRegressionTemplate\";\n+    private static final String COEFFICIENT = \"coefficient\";\n+    private static final String EXPONENT = \"exponent\";\n+    private static AtomicInteger classArity = new AtomicInteger(0);\n+    private static AtomicInteger predictorsArity = new AtomicInteger(0);\n+    private static CompilationUnit templateEvaluate;\n+    private static CompilationUnit cloneEvaluate;\n+\n+    private KiePMMLRegressionTableRegressionFactory() {\n+        // Avoid instantiation\n+    }\n+\n+    public static Map<String, KiePMMLTableSourceCategory> getRegressionTables(final List<RegressionTable> regressionTables, final RegressionModel.NormalizationMethod normalizationMethod, final String targetField) throws IOException {\n+        logger.debug(\"getRegressionTables {}\", regressionTables);\n+        CompilationUnit templateCU = StaticJavaParser.parseResource(KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE_JAVA);\n+        Map<String, KiePMMLTableSourceCategory> toReturn = new HashMap<>();\n+        for (RegressionTable regressionTable : regressionTables) {\n+            final Map.Entry<String, String> regressionTableEntry = getRegressionTable(templateCU, regressionTable, normalizationMethod, targetField);\n+            String targetCategory = regressionTable.getTargetCategory() != null ? regressionTable.getTargetCategory().toString() : \"\";\n+            toReturn.put(regressionTableEntry.getKey(), new KiePMMLTableSourceCategory(regressionTableEntry.getValue(), targetCategory));\n+        }\n+        return toReturn;\n+    }\n+\n+    public static AbstractMap.Entry<String, String> getRegressionTable(final CompilationUnit templateCU, final RegressionTable regressionTable, final RegressionModel.NormalizationMethod normalizationMethod, final String targetField) {\n+        logger.debug(\"getRegressionTable {}\", regressionTable);\n+        CompilationUnit cloneCU = templateCU.clone();\n+        ClassOrInterfaceDeclaration tableTemplate = cloneCU.getClassByName(KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE)\n+                .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+        String className = \"KiePMMLRegressionTableRegression\" + classArity.addAndGet(1);\n+        tableTemplate.setName(className);\n+        setConstructor(regressionTable, tableTemplate, targetField);\n+        final Map<String, MethodDeclaration> numericPredictorsMap = addNumericPredictors(regressionTable.getNumericPredictors(), tableTemplate);\n+        final Map<String, MethodDeclaration> categoricalPredictorsMap = addCategoricalPredictors(regressionTable.getCategoricalPredictors(), tableTemplate);\n+        final Map<String, MethodDeclaration> predictorTermsMap = addPredictorTerms(regressionTable.getPredictorTerms(), tableTemplate);\n+        tableTemplate.getDefaultConstructor().ifPresent(constructorDeclaration -> {\n+            final BlockStmt body = constructorDeclaration.getBody();\n+            addMapPopulation(numericPredictorsMap, body, \"numericFunctionMap\");\n+            addMapPopulation(categoricalPredictorsMap, body, \"categoricalFunctionMap\");\n+            addMapPopulation(predictorTermsMap, body, \"predictorTermsFunctionMap\");\n+        });\n+        populateGetTargetCategory(tableTemplate, regressionTable.getTargetCategory());\n+        populateUpdateResult(tableTemplate, normalizationMethod);\n+        return new AbstractMap.SimpleEntry<>(className, cloneCU.toString());\n+    }\n+\n+    /**\n+     * Add entries <b>fieldName/function</b> inside the constructor\n+     * @param toAdd\n+     * @param body\n+     * @param mapName\n+     */\n+    private static void addMapPopulation(final Map<String, MethodDeclaration> toAdd, final BlockStmt body, final String mapName) {\n+        toAdd.forEach((s, methodDeclaration) -> {\n+            MethodReferenceExpr methodReferenceExpr = new MethodReferenceExpr();\n+            methodReferenceExpr.setScope(new ThisExpr());\n+            methodReferenceExpr.setIdentifier(methodDeclaration.getNameAsString());\n+            NodeList<Expression> expressions = NodeList.nodeList(new StringLiteralExpr(s), methodReferenceExpr);\n+            body.addStatement(new MethodCallExpr(new NameExpr(mapName), \"put\", expressions));\n+        });\n+    }\n+\n+    /**\n+     * Set the <b>intercept</b> and <b>targetField</b> values inside the constructor\n+     * @param regressionTable\n+     * @param tableTemplate\n+     * @param targetField\n+     */\n+    private static void setConstructor(final RegressionTable regressionTable, final ClassOrInterfaceDeclaration tableTemplate, final String targetField) {\n+        tableTemplate.getDefaultConstructor().ifPresent(constructorDeclaration -> {\n+            constructorDeclaration.setName(tableTemplate.getName());\n+            final BlockStmt body = constructorDeclaration.getBody();\n+            final List<AssignExpr> assignExprs = body.findAll(AssignExpr.class);\n+            assignExprs.forEach(assignExpr -> {\n+                if (assignExpr.getTarget().asNameExpr().getNameAsString().equals(\"intercept\")) {\n+                    assignExpr.setValue(new DoubleLiteralExpr(String.valueOf(regressionTable.getIntercept().doubleValue())));\n+                } else if (assignExpr.getTarget().asNameExpr().getNameAsString().equals(\"targetField\")) {\n+                    assignExpr.setValue(new StringLiteralExpr(targetField));\n+                }\n+            });\n+        });\n+    }\n+\n+    /**\n+     * Add <b>NumericPredictor</b>s <code>MethodDeclaration</code> to the class\n+     * @param numericPredictors\n+     * @param tableTemplate\n+     * @return\n+     */\n+    private static Map<String, MethodDeclaration> addNumericPredictors(final List<NumericPredictor> numericPredictors, final ClassOrInterfaceDeclaration tableTemplate) {\n+        predictorsArity.set(0);\n+        return numericPredictors.stream()\n+                .map(numericPredictor -> new AbstractMap.SimpleEntry<>(numericPredictor.getName().getValue(),\n+                                                                       addNumericPredictor(numericPredictor, tableTemplate, predictorsArity.addAndGet(1))))\n+                .filter(entry -> entry.getValue().isPresent())\n+                .collect(Collectors.toMap(AbstractMap.SimpleEntry::getKey,\n+                                          entry -> entry.getValue().get()));\n+    }\n+\n+    /**\n+     * Add a <b>NumericPredictor</b> <code>MethodDeclaration</code> to the class\n+     * @param numericPredictor\n+     * @param tableTemplate\n+     * @param predictorArity\n+     * @return\n+     */\n+    private static Optional<MethodDeclaration> addNumericPredictor(final NumericPredictor numericPredictor, final ClassOrInterfaceDeclaration tableTemplate, int predictorArity) {\n+        try {\n+            templateEvaluate = StaticJavaParser.parseResource(KIE_PMML_EVALUATE_METHOD_TEMPLATE_JAVA);\n+            cloneEvaluate = templateEvaluate.clone();\n+            ClassOrInterfaceDeclaration evaluateTemplateClass = cloneEvaluate.getClassByName(KIE_PMML_EVALUATE_METHOD_TEMPLATE)\n+                    .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+            MethodDeclaration methodTemplate;\n+            if (Objects.equals(1, numericPredictor.getExponent())) {\n+                methodTemplate = getNumericPredictorWithoutExponentTemplate(numericPredictor, evaluateTemplateClass);\n+            } else {\n+                methodTemplate = getNumericPredictorWithExponentTemplate(numericPredictor, evaluateTemplateClass);\n+            }\n+            return addMethod(methodTemplate, tableTemplate, \"evaluateNumericPredictor\" + predictorArity);\n+        } catch (Exception e) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * Add a <b>NumericPredictor</b> <code>MethodDeclaration</code> with <b>exponent != 1</b> to the class\n+     * @param numericPredictor\n+     * @param evaluateTemplateClass\n+     * @return\n+     */\n+    private static MethodDeclaration getNumericPredictorWithExponentTemplate(final NumericPredictor numericPredictor, final ClassOrInterfaceDeclaration evaluateTemplateClass) {\n+        final MethodDeclaration toReturn = evaluateTemplateClass.getMethodsByName(\"evaluateNumericWithExponent\").get(0);\n+        toReturn.getBody().ifPresent(body -> {\n+            final List<VariableDeclarator> variableDeclarators = body.findAll(VariableDeclarator.class);\n+            variableDeclarators.forEach(variableDeclarator -> {\n+                String initializer = null;\n+                if (variableDeclarator.getName().asString().equals(COEFFICIENT)) {\n+                    initializer = String.valueOf(numericPredictor.getCoefficient().doubleValue());\n+                } else if (variableDeclarator.getName().asString().equals(EXPONENT)) {\n+                    initializer = String.valueOf(numericPredictor.getExponent().doubleValue());\n+                }\n+                if (initializer != null) {\n+                    variableDeclarator.setInitializer(initializer);\n+                }\n+            });\n+        });\n+        return toReturn;\n+    }\n+\n+    /**\n+     * Add a <b>NumericPredictor</b> <code>MethodDeclaration</code> with <b>exponent == 1</b> to the class\n+     * @param numericPredictor\n+     * @param evaluateTemplateClass\n+     * @return\n+     */\n+    private static MethodDeclaration getNumericPredictorWithoutExponentTemplate(final NumericPredictor numericPredictor, final ClassOrInterfaceDeclaration evaluateTemplateClass) {\n+        final MethodDeclaration toReturn = evaluateTemplateClass.getMethodsByName(\"evaluateNumericWithoutExponent\").get(0);\n+        toReturn.getBody().ifPresent(body -> {\n+            final List<VariableDeclarator> variableDeclarators = body.findAll(VariableDeclarator.class);\n+            variableDeclarators.stream().filter(variableDeclarator -> variableDeclarator.getName().asString().equals(COEFFICIENT))\n+                    .forEach(variableDeclarator -> variableDeclarator.setInitializer(String.valueOf(numericPredictor.getCoefficient().doubleValue())));\n+        });\n+        return toReturn;\n+    }\n+\n+    /**\n+     * Add <b>CategoricalPredictor</b>s <code>MethodDeclaration</code> to the class\n+     * @param categoricalPredictors\n+     * @param tableTemplate\n+     * @return\n+     */\n+    private static Map<String, MethodDeclaration> addCategoricalPredictors(final List<CategoricalPredictor> categoricalPredictors, final ClassOrInterfaceDeclaration tableTemplate) {\n+        predictorsArity.set(0);\n+        final Map<String, List<CategoricalPredictor>> groupedCollectors = categoricalPredictors.stream()\n+                .collect(groupingBy(categoricalPredictor -> categoricalPredictor.getField().getValue()));\n+        return groupedCollectors.entrySet().stream()\n+                .map(entry -> new AbstractMap.SimpleEntry<>(entry.getKey(),\n+                                                            addGroupedCategoricalPredictor(entry.getValue(), tableTemplate, predictorsArity.addAndGet(1))))\n+                .filter(entry -> entry.getValue().isPresent())\n+                .collect(Collectors.toMap(AbstractMap.SimpleEntry::getKey,\n+                                          entry -> entry.getValue().get()));\n+    }\n+\n+    /**\n+     * Add a <b>CategoricalPredictor</b> <code>MethodDeclaration</code> to the class\n+     * @param categoricalPredictors\n+     * @param tableTemplate\n+     * @param predictorArity\n+     * @return\n+     */\n+    private static Optional<MethodDeclaration> addGroupedCategoricalPredictor(final List<CategoricalPredictor> categoricalPredictors, final ClassOrInterfaceDeclaration tableTemplate, int predictorArity) {\n+        try {\n+            templateEvaluate = StaticJavaParser.parseResource(KIE_PMML_EVALUATE_METHOD_TEMPLATE_JAVA);\n+            cloneEvaluate = templateEvaluate.clone();\n+            ClassOrInterfaceDeclaration evaluateTemplateClass = cloneEvaluate.getClassByName(KIE_PMML_EVALUATE_METHOD_TEMPLATE)\n+                    .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+            MethodDeclaration methodTemplate = evaluateTemplateClass.getMethodsByName(\"evaluateCategorical\").get(0);\n+            methodTemplate.getBody().ifPresent(body -> {\n+                IfStmt ifStmt = new IfStmt();\n+                for (int i = 0; i < categoricalPredictors.size(); i++) {\n+                    CategoricalPredictor categoricalPredictor = categoricalPredictors.get(i);\n+                    Expression lhe;\n+                    if (categoricalPredictor.getValue() instanceof String) {\n+                        lhe = new StringLiteralExpr((String) categoricalPredictor.getValue());\n+                    } else {\n+                        lhe = new NameExpr(categoricalPredictor.getValue().toString());\n+                    }\n+                    NodeList<Expression> expressions = NodeList.nodeList(lhe, new NameExpr(\"input\"));\n+                    MethodCallExpr conditionExpr = new MethodCallExpr(new NameExpr(\"Objects\"), \"equals\", expressions);\n+                    if (i == 0) {\n+                        ifStmt.setCondition(conditionExpr);\n+                        ifStmt.setThenStmt(new ReturnStmt(new DoubleLiteralExpr(String.valueOf(categoricalPredictor.getCoefficient()))));\n+                        body.addStatement(ifStmt);\n+                    } else {\n+                        IfStmt elseIf = new IfStmt();\n+                        elseIf.setCondition(conditionExpr);\n+                        elseIf.setThenStmt(new ReturnStmt(new DoubleLiteralExpr(String.valueOf(categoricalPredictor.getCoefficient()))));\n+                        ifStmt.setElseStmt(elseIf);\n+                        ifStmt = elseIf;\n+                    }\n+                }\n+                ifStmt.setElseStmt(new ReturnStmt(new DoubleLiteralExpr(\"0.0\")));\n+            });\n+            return addMethod(methodTemplate, tableTemplate, \"evaluateCategoricalPredictor\" + predictorArity);\n+        } catch (Exception e) {\n+            //\n+            return Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * Add <b>PredictorTerm</b>s <code>MethodDeclaration</code> to the class\n+     * @param predictorTerms\n+     * @param tableTemplate\n+     * @return\n+     */\n+    private static Map<String, MethodDeclaration> addPredictorTerms(final List<PredictorTerm> predictorTerms, final ClassOrInterfaceDeclaration tableTemplate) {\n+        predictorsArity.set(0);\n+        return predictorTerms.stream()\n+                .map(predictorTerm -> {\n+                    int arity = predictorsArity.addAndGet(1);\n+                    return new AbstractMap.SimpleEntry<>(predictorTerm.getName() != null ? predictorTerm.getName().getValue() : \"predictorTerm\" + arity,\n+                                                         addPredictorTerm(predictorTerm, tableTemplate, arity));\n+                })\n+                .filter(entry -> entry.getValue().isPresent())\n+                .collect(Collectors.toMap(AbstractMap.SimpleEntry::getKey,\n+                                          entry -> entry.getValue().get()));\n+    }\n+\n+    /**\n+     * Add a <b>PredictorTerm</b> <code>MethodDeclaration</code> to the class\n+     * @param predictorTerm\n+     * @param tableTemplate\n+     * @param predictorArity\n+     * @return\n+     */\n+    private static Optional<MethodDeclaration> addPredictorTerm(final PredictorTerm predictorTerm, final ClassOrInterfaceDeclaration tableTemplate, int predictorArity) {\n+        try {\n+            templateEvaluate = StaticJavaParser.parseResource(KIE_PMML_EVALUATE_METHOD_TEMPLATE_JAVA);\n+            cloneEvaluate = templateEvaluate.clone();\n+            ClassOrInterfaceDeclaration evaluateTemplateClass = cloneEvaluate.getClassByName(KIE_PMML_EVALUATE_METHOD_TEMPLATE)\n+                    .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+            MethodDeclaration methodTemplate = evaluateTemplateClass.getMethodsByName(\"evaluatePredictor\").get(0);\n+            methodTemplate.getBody().ifPresent(body -> {\n+                final List<VariableDeclarator> variableDeclarators = body.findAll(VariableDeclarator.class);\n+                variableDeclarators.forEach(variableDeclarator -> {\n+                    if (variableDeclarator.getName().asString().equals(\"fieldRefs\")) {\n+                        final List<Expression> nodeList = predictorTerm.getFieldRefs().stream()\n+                                .map(fieldRef -> new StringLiteralExpr(fieldRef.getField().getValue()))\n+                                .collect(Collectors.toList());\n+                        NodeList<Expression> expressions = NodeList.nodeList(nodeList);\n+                        MethodCallExpr methodCallExpr = new MethodCallExpr(new NameExpr(\"Arrays\"), \"asList\", expressions);\n+                        variableDeclarator.setInitializer(methodCallExpr);\n+                    } else if (variableDeclarator.getName().asString().equals(COEFFICIENT)) {\n+                        variableDeclarator.setInitializer(String.valueOf(predictorTerm.getCoefficient().doubleValue()));\n+                    }\n+                });\n+            });\n+            return addMethod(methodTemplate, tableTemplate, \"evaluatePredictorTerm\" + predictorArity);\n+        } catch (Exception e) {\n+            //", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA5NDEyNw=="}, "originalCommit": {"oid": "3c4a838980a18a8428b253ee431087beb471fe8d"}, "originalPosition": 345}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDEwODMxOnYy", "diffSide": "RIGHT", "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/main/java/org/kie/pmml/models/regression/compiler/factories/KiePMMLRegressionTableRegressionFactory.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwODo0MzozNVrOF17iAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMToxMzo0N1rOF1_8rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA5NDIxMA==", "bodyText": "Same comment", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r392094210", "createdAt": "2020-03-13T08:43:35Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/main/java/org/kie/pmml/models/regression/compiler/factories/KiePMMLRegressionTableRegressionFactory.java", "diffHunk": "@@ -0,0 +1,410 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.compiler.factories;\n+\n+import java.io.IOException;\n+import java.util.AbstractMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.DoubleLiteralExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.MethodReferenceExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.expr.ThisExpr;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.IfStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import org.dmg.pmml.regression.CategoricalPredictor;\n+import org.dmg.pmml.regression.NumericPredictor;\n+import org.dmg.pmml.regression.PredictorTerm;\n+import org.dmg.pmml.regression.RegressionModel;\n+import org.dmg.pmml.regression.RegressionTable;\n+import org.kie.pmml.models.regression.model.tuples.KiePMMLTableSourceCategory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+\n+public class KiePMMLRegressionTableRegressionFactory {\n+\n+    public static final String KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE_JAVA = \"KiePMMLRegressionTableRegressionTemplate.tmpl\";\n+    private static final Logger logger = LoggerFactory.getLogger(KiePMMLRegressionTableRegressionFactory.class.getName());\n+    private static final String MAIN_CLASS_NOT_FOUND = \"Main class not found\";\n+    private static final String KIE_PMML_EVALUATE_METHOD_TEMPLATE_JAVA = \"KiePMMLEvaluateMethodTemplate.tmpl\";\n+    private static final String KIE_PMML_EVALUATE_METHOD_TEMPLATE = \"KiePMMLEvaluateMethodTemplate\";\n+    private static final String KIE_PMML_UPDATE_RESULT_METHOD_TEMPLATE_JAVA = \"KiePMMLUpdateResultMethodTemplate.tmpl\";\n+    private static final String KIE_PMML_UPDATE_RESULT_METHOD_TEMPLATE = \"KiePMMLUpdateResultMethodTemplate\";\n+    private static final String KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE = \"KiePMMLRegressionTableRegressionTemplate\";\n+    private static final String COEFFICIENT = \"coefficient\";\n+    private static final String EXPONENT = \"exponent\";\n+    private static AtomicInteger classArity = new AtomicInteger(0);\n+    private static AtomicInteger predictorsArity = new AtomicInteger(0);\n+    private static CompilationUnit templateEvaluate;\n+    private static CompilationUnit cloneEvaluate;\n+\n+    private KiePMMLRegressionTableRegressionFactory() {\n+        // Avoid instantiation\n+    }\n+\n+    public static Map<String, KiePMMLTableSourceCategory> getRegressionTables(final List<RegressionTable> regressionTables, final RegressionModel.NormalizationMethod normalizationMethod, final String targetField) throws IOException {\n+        logger.debug(\"getRegressionTables {}\", regressionTables);\n+        CompilationUnit templateCU = StaticJavaParser.parseResource(KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE_JAVA);\n+        Map<String, KiePMMLTableSourceCategory> toReturn = new HashMap<>();\n+        for (RegressionTable regressionTable : regressionTables) {\n+            final Map.Entry<String, String> regressionTableEntry = getRegressionTable(templateCU, regressionTable, normalizationMethod, targetField);\n+            String targetCategory = regressionTable.getTargetCategory() != null ? regressionTable.getTargetCategory().toString() : \"\";\n+            toReturn.put(regressionTableEntry.getKey(), new KiePMMLTableSourceCategory(regressionTableEntry.getValue(), targetCategory));\n+        }\n+        return toReturn;\n+    }\n+\n+    public static AbstractMap.Entry<String, String> getRegressionTable(final CompilationUnit templateCU, final RegressionTable regressionTable, final RegressionModel.NormalizationMethod normalizationMethod, final String targetField) {\n+        logger.debug(\"getRegressionTable {}\", regressionTable);\n+        CompilationUnit cloneCU = templateCU.clone();\n+        ClassOrInterfaceDeclaration tableTemplate = cloneCU.getClassByName(KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE)\n+                .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+        String className = \"KiePMMLRegressionTableRegression\" + classArity.addAndGet(1);\n+        tableTemplate.setName(className);\n+        setConstructor(regressionTable, tableTemplate, targetField);\n+        final Map<String, MethodDeclaration> numericPredictorsMap = addNumericPredictors(regressionTable.getNumericPredictors(), tableTemplate);\n+        final Map<String, MethodDeclaration> categoricalPredictorsMap = addCategoricalPredictors(regressionTable.getCategoricalPredictors(), tableTemplate);\n+        final Map<String, MethodDeclaration> predictorTermsMap = addPredictorTerms(regressionTable.getPredictorTerms(), tableTemplate);\n+        tableTemplate.getDefaultConstructor().ifPresent(constructorDeclaration -> {\n+            final BlockStmt body = constructorDeclaration.getBody();\n+            addMapPopulation(numericPredictorsMap, body, \"numericFunctionMap\");\n+            addMapPopulation(categoricalPredictorsMap, body, \"categoricalFunctionMap\");\n+            addMapPopulation(predictorTermsMap, body, \"predictorTermsFunctionMap\");\n+        });\n+        populateGetTargetCategory(tableTemplate, regressionTable.getTargetCategory());\n+        populateUpdateResult(tableTemplate, normalizationMethod);\n+        return new AbstractMap.SimpleEntry<>(className, cloneCU.toString());\n+    }\n+\n+    /**\n+     * Add entries <b>fieldName/function</b> inside the constructor\n+     * @param toAdd\n+     * @param body\n+     * @param mapName\n+     */\n+    private static void addMapPopulation(final Map<String, MethodDeclaration> toAdd, final BlockStmt body, final String mapName) {\n+        toAdd.forEach((s, methodDeclaration) -> {\n+            MethodReferenceExpr methodReferenceExpr = new MethodReferenceExpr();\n+            methodReferenceExpr.setScope(new ThisExpr());\n+            methodReferenceExpr.setIdentifier(methodDeclaration.getNameAsString());\n+            NodeList<Expression> expressions = NodeList.nodeList(new StringLiteralExpr(s), methodReferenceExpr);\n+            body.addStatement(new MethodCallExpr(new NameExpr(mapName), \"put\", expressions));\n+        });\n+    }\n+\n+    /**\n+     * Set the <b>intercept</b> and <b>targetField</b> values inside the constructor\n+     * @param regressionTable\n+     * @param tableTemplate\n+     * @param targetField\n+     */\n+    private static void setConstructor(final RegressionTable regressionTable, final ClassOrInterfaceDeclaration tableTemplate, final String targetField) {\n+        tableTemplate.getDefaultConstructor().ifPresent(constructorDeclaration -> {\n+            constructorDeclaration.setName(tableTemplate.getName());\n+            final BlockStmt body = constructorDeclaration.getBody();\n+            final List<AssignExpr> assignExprs = body.findAll(AssignExpr.class);\n+            assignExprs.forEach(assignExpr -> {\n+                if (assignExpr.getTarget().asNameExpr().getNameAsString().equals(\"intercept\")) {\n+                    assignExpr.setValue(new DoubleLiteralExpr(String.valueOf(regressionTable.getIntercept().doubleValue())));\n+                } else if (assignExpr.getTarget().asNameExpr().getNameAsString().equals(\"targetField\")) {\n+                    assignExpr.setValue(new StringLiteralExpr(targetField));\n+                }\n+            });\n+        });\n+    }\n+\n+    /**\n+     * Add <b>NumericPredictor</b>s <code>MethodDeclaration</code> to the class\n+     * @param numericPredictors\n+     * @param tableTemplate\n+     * @return\n+     */\n+    private static Map<String, MethodDeclaration> addNumericPredictors(final List<NumericPredictor> numericPredictors, final ClassOrInterfaceDeclaration tableTemplate) {\n+        predictorsArity.set(0);\n+        return numericPredictors.stream()\n+                .map(numericPredictor -> new AbstractMap.SimpleEntry<>(numericPredictor.getName().getValue(),\n+                                                                       addNumericPredictor(numericPredictor, tableTemplate, predictorsArity.addAndGet(1))))\n+                .filter(entry -> entry.getValue().isPresent())\n+                .collect(Collectors.toMap(AbstractMap.SimpleEntry::getKey,\n+                                          entry -> entry.getValue().get()));\n+    }\n+\n+    /**\n+     * Add a <b>NumericPredictor</b> <code>MethodDeclaration</code> to the class\n+     * @param numericPredictor\n+     * @param tableTemplate\n+     * @param predictorArity\n+     * @return\n+     */\n+    private static Optional<MethodDeclaration> addNumericPredictor(final NumericPredictor numericPredictor, final ClassOrInterfaceDeclaration tableTemplate, int predictorArity) {\n+        try {\n+            templateEvaluate = StaticJavaParser.parseResource(KIE_PMML_EVALUATE_METHOD_TEMPLATE_JAVA);\n+            cloneEvaluate = templateEvaluate.clone();\n+            ClassOrInterfaceDeclaration evaluateTemplateClass = cloneEvaluate.getClassByName(KIE_PMML_EVALUATE_METHOD_TEMPLATE)\n+                    .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+            MethodDeclaration methodTemplate;\n+            if (Objects.equals(1, numericPredictor.getExponent())) {\n+                methodTemplate = getNumericPredictorWithoutExponentTemplate(numericPredictor, evaluateTemplateClass);\n+            } else {\n+                methodTemplate = getNumericPredictorWithExponentTemplate(numericPredictor, evaluateTemplateClass);\n+            }\n+            return addMethod(methodTemplate, tableTemplate, \"evaluateNumericPredictor\" + predictorArity);\n+        } catch (Exception e) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * Add a <b>NumericPredictor</b> <code>MethodDeclaration</code> with <b>exponent != 1</b> to the class\n+     * @param numericPredictor\n+     * @param evaluateTemplateClass\n+     * @return\n+     */\n+    private static MethodDeclaration getNumericPredictorWithExponentTemplate(final NumericPredictor numericPredictor, final ClassOrInterfaceDeclaration evaluateTemplateClass) {\n+        final MethodDeclaration toReturn = evaluateTemplateClass.getMethodsByName(\"evaluateNumericWithExponent\").get(0);\n+        toReturn.getBody().ifPresent(body -> {\n+            final List<VariableDeclarator> variableDeclarators = body.findAll(VariableDeclarator.class);\n+            variableDeclarators.forEach(variableDeclarator -> {\n+                String initializer = null;\n+                if (variableDeclarator.getName().asString().equals(COEFFICIENT)) {\n+                    initializer = String.valueOf(numericPredictor.getCoefficient().doubleValue());\n+                } else if (variableDeclarator.getName().asString().equals(EXPONENT)) {\n+                    initializer = String.valueOf(numericPredictor.getExponent().doubleValue());\n+                }\n+                if (initializer != null) {\n+                    variableDeclarator.setInitializer(initializer);\n+                }\n+            });\n+        });\n+        return toReturn;\n+    }\n+\n+    /**\n+     * Add a <b>NumericPredictor</b> <code>MethodDeclaration</code> with <b>exponent == 1</b> to the class\n+     * @param numericPredictor\n+     * @param evaluateTemplateClass\n+     * @return\n+     */\n+    private static MethodDeclaration getNumericPredictorWithoutExponentTemplate(final NumericPredictor numericPredictor, final ClassOrInterfaceDeclaration evaluateTemplateClass) {\n+        final MethodDeclaration toReturn = evaluateTemplateClass.getMethodsByName(\"evaluateNumericWithoutExponent\").get(0);\n+        toReturn.getBody().ifPresent(body -> {\n+            final List<VariableDeclarator> variableDeclarators = body.findAll(VariableDeclarator.class);\n+            variableDeclarators.stream().filter(variableDeclarator -> variableDeclarator.getName().asString().equals(COEFFICIENT))\n+                    .forEach(variableDeclarator -> variableDeclarator.setInitializer(String.valueOf(numericPredictor.getCoefficient().doubleValue())));\n+        });\n+        return toReturn;\n+    }\n+\n+    /**\n+     * Add <b>CategoricalPredictor</b>s <code>MethodDeclaration</code> to the class\n+     * @param categoricalPredictors\n+     * @param tableTemplate\n+     * @return\n+     */\n+    private static Map<String, MethodDeclaration> addCategoricalPredictors(final List<CategoricalPredictor> categoricalPredictors, final ClassOrInterfaceDeclaration tableTemplate) {\n+        predictorsArity.set(0);\n+        final Map<String, List<CategoricalPredictor>> groupedCollectors = categoricalPredictors.stream()\n+                .collect(groupingBy(categoricalPredictor -> categoricalPredictor.getField().getValue()));\n+        return groupedCollectors.entrySet().stream()\n+                .map(entry -> new AbstractMap.SimpleEntry<>(entry.getKey(),\n+                                                            addGroupedCategoricalPredictor(entry.getValue(), tableTemplate, predictorsArity.addAndGet(1))))\n+                .filter(entry -> entry.getValue().isPresent())\n+                .collect(Collectors.toMap(AbstractMap.SimpleEntry::getKey,\n+                                          entry -> entry.getValue().get()));\n+    }\n+\n+    /**\n+     * Add a <b>CategoricalPredictor</b> <code>MethodDeclaration</code> to the class\n+     * @param categoricalPredictors\n+     * @param tableTemplate\n+     * @param predictorArity\n+     * @return\n+     */\n+    private static Optional<MethodDeclaration> addGroupedCategoricalPredictor(final List<CategoricalPredictor> categoricalPredictors, final ClassOrInterfaceDeclaration tableTemplate, int predictorArity) {\n+        try {\n+            templateEvaluate = StaticJavaParser.parseResource(KIE_PMML_EVALUATE_METHOD_TEMPLATE_JAVA);\n+            cloneEvaluate = templateEvaluate.clone();\n+            ClassOrInterfaceDeclaration evaluateTemplateClass = cloneEvaluate.getClassByName(KIE_PMML_EVALUATE_METHOD_TEMPLATE)\n+                    .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+            MethodDeclaration methodTemplate = evaluateTemplateClass.getMethodsByName(\"evaluateCategorical\").get(0);\n+            methodTemplate.getBody().ifPresent(body -> {\n+                IfStmt ifStmt = new IfStmt();\n+                for (int i = 0; i < categoricalPredictors.size(); i++) {\n+                    CategoricalPredictor categoricalPredictor = categoricalPredictors.get(i);\n+                    Expression lhe;\n+                    if (categoricalPredictor.getValue() instanceof String) {\n+                        lhe = new StringLiteralExpr((String) categoricalPredictor.getValue());\n+                    } else {\n+                        lhe = new NameExpr(categoricalPredictor.getValue().toString());\n+                    }\n+                    NodeList<Expression> expressions = NodeList.nodeList(lhe, new NameExpr(\"input\"));\n+                    MethodCallExpr conditionExpr = new MethodCallExpr(new NameExpr(\"Objects\"), \"equals\", expressions);\n+                    if (i == 0) {\n+                        ifStmt.setCondition(conditionExpr);\n+                        ifStmt.setThenStmt(new ReturnStmt(new DoubleLiteralExpr(String.valueOf(categoricalPredictor.getCoefficient()))));\n+                        body.addStatement(ifStmt);\n+                    } else {\n+                        IfStmt elseIf = new IfStmt();\n+                        elseIf.setCondition(conditionExpr);\n+                        elseIf.setThenStmt(new ReturnStmt(new DoubleLiteralExpr(String.valueOf(categoricalPredictor.getCoefficient()))));\n+                        ifStmt.setElseStmt(elseIf);\n+                        ifStmt = elseIf;\n+                    }\n+                }\n+                ifStmt.setElseStmt(new ReturnStmt(new DoubleLiteralExpr(\"0.0\")));\n+            });\n+            return addMethod(methodTemplate, tableTemplate, \"evaluateCategoricalPredictor\" + predictorArity);\n+        } catch (Exception e) {\n+            //\n+            return Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * Add <b>PredictorTerm</b>s <code>MethodDeclaration</code> to the class\n+     * @param predictorTerms\n+     * @param tableTemplate\n+     * @return\n+     */\n+    private static Map<String, MethodDeclaration> addPredictorTerms(final List<PredictorTerm> predictorTerms, final ClassOrInterfaceDeclaration tableTemplate) {\n+        predictorsArity.set(0);\n+        return predictorTerms.stream()\n+                .map(predictorTerm -> {\n+                    int arity = predictorsArity.addAndGet(1);\n+                    return new AbstractMap.SimpleEntry<>(predictorTerm.getName() != null ? predictorTerm.getName().getValue() : \"predictorTerm\" + arity,\n+                                                         addPredictorTerm(predictorTerm, tableTemplate, arity));\n+                })\n+                .filter(entry -> entry.getValue().isPresent())\n+                .collect(Collectors.toMap(AbstractMap.SimpleEntry::getKey,\n+                                          entry -> entry.getValue().get()));\n+    }\n+\n+    /**\n+     * Add a <b>PredictorTerm</b> <code>MethodDeclaration</code> to the class\n+     * @param predictorTerm\n+     * @param tableTemplate\n+     * @param predictorArity\n+     * @return\n+     */\n+    private static Optional<MethodDeclaration> addPredictorTerm(final PredictorTerm predictorTerm, final ClassOrInterfaceDeclaration tableTemplate, int predictorArity) {\n+        try {\n+            templateEvaluate = StaticJavaParser.parseResource(KIE_PMML_EVALUATE_METHOD_TEMPLATE_JAVA);\n+            cloneEvaluate = templateEvaluate.clone();\n+            ClassOrInterfaceDeclaration evaluateTemplateClass = cloneEvaluate.getClassByName(KIE_PMML_EVALUATE_METHOD_TEMPLATE)\n+                    .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+            MethodDeclaration methodTemplate = evaluateTemplateClass.getMethodsByName(\"evaluatePredictor\").get(0);\n+            methodTemplate.getBody().ifPresent(body -> {\n+                final List<VariableDeclarator> variableDeclarators = body.findAll(VariableDeclarator.class);\n+                variableDeclarators.forEach(variableDeclarator -> {\n+                    if (variableDeclarator.getName().asString().equals(\"fieldRefs\")) {\n+                        final List<Expression> nodeList = predictorTerm.getFieldRefs().stream()\n+                                .map(fieldRef -> new StringLiteralExpr(fieldRef.getField().getValue()))\n+                                .collect(Collectors.toList());\n+                        NodeList<Expression> expressions = NodeList.nodeList(nodeList);\n+                        MethodCallExpr methodCallExpr = new MethodCallExpr(new NameExpr(\"Arrays\"), \"asList\", expressions);\n+                        variableDeclarator.setInitializer(methodCallExpr);\n+                    } else if (variableDeclarator.getName().asString().equals(COEFFICIENT)) {\n+                        variableDeclarator.setInitializer(String.valueOf(predictorTerm.getCoefficient().doubleValue()));\n+                    }\n+                });\n+            });\n+            return addMethod(methodTemplate, tableTemplate, \"evaluatePredictorTerm\" + predictorArity);\n+        } catch (Exception e) {\n+            //\n+            return Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * Add a <code>MethodDeclaration</code> to the class\n+     * @param methodTemplate\n+     * @param tableTemplate\n+     * @param evaluateMethodName\n+     * @return\n+     */\n+    protected static Optional<MethodDeclaration> addMethod(final MethodDeclaration methodTemplate, final ClassOrInterfaceDeclaration tableTemplate, final String evaluateMethodName) {\n+        return methodTemplate.getBody().map(body -> {\n+            final MethodDeclaration toReturn = tableTemplate.addMethod(evaluateMethodName).setBody(body);\n+            toReturn.setModifiers(methodTemplate.getModifiers());\n+            methodTemplate.getParameters().forEach(toReturn::addParameter);\n+            toReturn.setType(methodTemplate.getType());\n+            return toReturn;\n+        });\n+    }\n+\n+    /**\n+     * Populate the <b>getTargetCategory</b> method of the class\n+     * @param tableTemplate\n+     * @param targetCategory\n+     * @return\n+     */\n+    protected static void populateGetTargetCategory(final ClassOrInterfaceDeclaration tableTemplate, final Object targetCategory) {\n+        MethodDeclaration methodDeclaration = tableTemplate.getMethodsByName(\"getTargetCategory\").get(0);\n+        methodDeclaration.getBody().ifPresent(body -> {\n+            ReturnStmt returnStmt = new ReturnStmt();\n+            if (targetCategory == null) {\n+                returnStmt.setExpression(new NameExpr(\"null\"));\n+            } else if (targetCategory instanceof String) {\n+                returnStmt.setExpression(new StringLiteralExpr((String) targetCategory));\n+            } else {\n+                returnStmt.setExpression(new NameExpr(targetCategory.toString()));\n+            }\n+            body.addStatement(returnStmt);\n+        });\n+    }\n+\n+    /**\n+     * Populate the <b>getTargetCategory</b> method of the class\n+     * @param tableTemplate\n+     * @param normalizationMethod\n+     * @return\n+     */\n+    protected static void populateUpdateResult(final ClassOrInterfaceDeclaration tableTemplate, final RegressionModel.NormalizationMethod normalizationMethod) {\n+        try {\n+            templateEvaluate = StaticJavaParser.parseResource(KIE_PMML_UPDATE_RESULT_METHOD_TEMPLATE_JAVA);\n+            cloneEvaluate = templateEvaluate.clone();\n+            ClassOrInterfaceDeclaration evaluateTemplateClass = cloneEvaluate.getClassByName(KIE_PMML_UPDATE_RESULT_METHOD_TEMPLATE)\n+                    .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+            String methodName = String.format(\"update%sResult\", normalizationMethod.name());\n+            MethodDeclaration methodTemplate = evaluateTemplateClass.getMethodsByName(methodName).get(0);\n+            methodTemplate.getBody().ifPresent(body -> {\n+                MethodDeclaration targetMethod = tableTemplate.getMethodsByName(\"updateResult\").get(0);\n+                targetMethod.setBody(body);\n+            });\n+        } catch (Exception e) {\n+            //", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c4a838980a18a8428b253ee431087beb471fe8d"}, "originalPosition": 407}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE2NjU3NA==", "bodyText": "@danielezonca\nSee above...", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r392166574", "createdAt": "2020-03-13T11:13:47Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/main/java/org/kie/pmml/models/regression/compiler/factories/KiePMMLRegressionTableRegressionFactory.java", "diffHunk": "@@ -0,0 +1,410 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.compiler.factories;\n+\n+import java.io.IOException;\n+import java.util.AbstractMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.DoubleLiteralExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.MethodReferenceExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.expr.ThisExpr;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.IfStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import org.dmg.pmml.regression.CategoricalPredictor;\n+import org.dmg.pmml.regression.NumericPredictor;\n+import org.dmg.pmml.regression.PredictorTerm;\n+import org.dmg.pmml.regression.RegressionModel;\n+import org.dmg.pmml.regression.RegressionTable;\n+import org.kie.pmml.models.regression.model.tuples.KiePMMLTableSourceCategory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+\n+public class KiePMMLRegressionTableRegressionFactory {\n+\n+    public static final String KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE_JAVA = \"KiePMMLRegressionTableRegressionTemplate.tmpl\";\n+    private static final Logger logger = LoggerFactory.getLogger(KiePMMLRegressionTableRegressionFactory.class.getName());\n+    private static final String MAIN_CLASS_NOT_FOUND = \"Main class not found\";\n+    private static final String KIE_PMML_EVALUATE_METHOD_TEMPLATE_JAVA = \"KiePMMLEvaluateMethodTemplate.tmpl\";\n+    private static final String KIE_PMML_EVALUATE_METHOD_TEMPLATE = \"KiePMMLEvaluateMethodTemplate\";\n+    private static final String KIE_PMML_UPDATE_RESULT_METHOD_TEMPLATE_JAVA = \"KiePMMLUpdateResultMethodTemplate.tmpl\";\n+    private static final String KIE_PMML_UPDATE_RESULT_METHOD_TEMPLATE = \"KiePMMLUpdateResultMethodTemplate\";\n+    private static final String KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE = \"KiePMMLRegressionTableRegressionTemplate\";\n+    private static final String COEFFICIENT = \"coefficient\";\n+    private static final String EXPONENT = \"exponent\";\n+    private static AtomicInteger classArity = new AtomicInteger(0);\n+    private static AtomicInteger predictorsArity = new AtomicInteger(0);\n+    private static CompilationUnit templateEvaluate;\n+    private static CompilationUnit cloneEvaluate;\n+\n+    private KiePMMLRegressionTableRegressionFactory() {\n+        // Avoid instantiation\n+    }\n+\n+    public static Map<String, KiePMMLTableSourceCategory> getRegressionTables(final List<RegressionTable> regressionTables, final RegressionModel.NormalizationMethod normalizationMethod, final String targetField) throws IOException {\n+        logger.debug(\"getRegressionTables {}\", regressionTables);\n+        CompilationUnit templateCU = StaticJavaParser.parseResource(KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE_JAVA);\n+        Map<String, KiePMMLTableSourceCategory> toReturn = new HashMap<>();\n+        for (RegressionTable regressionTable : regressionTables) {\n+            final Map.Entry<String, String> regressionTableEntry = getRegressionTable(templateCU, regressionTable, normalizationMethod, targetField);\n+            String targetCategory = regressionTable.getTargetCategory() != null ? regressionTable.getTargetCategory().toString() : \"\";\n+            toReturn.put(regressionTableEntry.getKey(), new KiePMMLTableSourceCategory(regressionTableEntry.getValue(), targetCategory));\n+        }\n+        return toReturn;\n+    }\n+\n+    public static AbstractMap.Entry<String, String> getRegressionTable(final CompilationUnit templateCU, final RegressionTable regressionTable, final RegressionModel.NormalizationMethod normalizationMethod, final String targetField) {\n+        logger.debug(\"getRegressionTable {}\", regressionTable);\n+        CompilationUnit cloneCU = templateCU.clone();\n+        ClassOrInterfaceDeclaration tableTemplate = cloneCU.getClassByName(KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE)\n+                .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+        String className = \"KiePMMLRegressionTableRegression\" + classArity.addAndGet(1);\n+        tableTemplate.setName(className);\n+        setConstructor(regressionTable, tableTemplate, targetField);\n+        final Map<String, MethodDeclaration> numericPredictorsMap = addNumericPredictors(regressionTable.getNumericPredictors(), tableTemplate);\n+        final Map<String, MethodDeclaration> categoricalPredictorsMap = addCategoricalPredictors(regressionTable.getCategoricalPredictors(), tableTemplate);\n+        final Map<String, MethodDeclaration> predictorTermsMap = addPredictorTerms(regressionTable.getPredictorTerms(), tableTemplate);\n+        tableTemplate.getDefaultConstructor().ifPresent(constructorDeclaration -> {\n+            final BlockStmt body = constructorDeclaration.getBody();\n+            addMapPopulation(numericPredictorsMap, body, \"numericFunctionMap\");\n+            addMapPopulation(categoricalPredictorsMap, body, \"categoricalFunctionMap\");\n+            addMapPopulation(predictorTermsMap, body, \"predictorTermsFunctionMap\");\n+        });\n+        populateGetTargetCategory(tableTemplate, regressionTable.getTargetCategory());\n+        populateUpdateResult(tableTemplate, normalizationMethod);\n+        return new AbstractMap.SimpleEntry<>(className, cloneCU.toString());\n+    }\n+\n+    /**\n+     * Add entries <b>fieldName/function</b> inside the constructor\n+     * @param toAdd\n+     * @param body\n+     * @param mapName\n+     */\n+    private static void addMapPopulation(final Map<String, MethodDeclaration> toAdd, final BlockStmt body, final String mapName) {\n+        toAdd.forEach((s, methodDeclaration) -> {\n+            MethodReferenceExpr methodReferenceExpr = new MethodReferenceExpr();\n+            methodReferenceExpr.setScope(new ThisExpr());\n+            methodReferenceExpr.setIdentifier(methodDeclaration.getNameAsString());\n+            NodeList<Expression> expressions = NodeList.nodeList(new StringLiteralExpr(s), methodReferenceExpr);\n+            body.addStatement(new MethodCallExpr(new NameExpr(mapName), \"put\", expressions));\n+        });\n+    }\n+\n+    /**\n+     * Set the <b>intercept</b> and <b>targetField</b> values inside the constructor\n+     * @param regressionTable\n+     * @param tableTemplate\n+     * @param targetField\n+     */\n+    private static void setConstructor(final RegressionTable regressionTable, final ClassOrInterfaceDeclaration tableTemplate, final String targetField) {\n+        tableTemplate.getDefaultConstructor().ifPresent(constructorDeclaration -> {\n+            constructorDeclaration.setName(tableTemplate.getName());\n+            final BlockStmt body = constructorDeclaration.getBody();\n+            final List<AssignExpr> assignExprs = body.findAll(AssignExpr.class);\n+            assignExprs.forEach(assignExpr -> {\n+                if (assignExpr.getTarget().asNameExpr().getNameAsString().equals(\"intercept\")) {\n+                    assignExpr.setValue(new DoubleLiteralExpr(String.valueOf(regressionTable.getIntercept().doubleValue())));\n+                } else if (assignExpr.getTarget().asNameExpr().getNameAsString().equals(\"targetField\")) {\n+                    assignExpr.setValue(new StringLiteralExpr(targetField));\n+                }\n+            });\n+        });\n+    }\n+\n+    /**\n+     * Add <b>NumericPredictor</b>s <code>MethodDeclaration</code> to the class\n+     * @param numericPredictors\n+     * @param tableTemplate\n+     * @return\n+     */\n+    private static Map<String, MethodDeclaration> addNumericPredictors(final List<NumericPredictor> numericPredictors, final ClassOrInterfaceDeclaration tableTemplate) {\n+        predictorsArity.set(0);\n+        return numericPredictors.stream()\n+                .map(numericPredictor -> new AbstractMap.SimpleEntry<>(numericPredictor.getName().getValue(),\n+                                                                       addNumericPredictor(numericPredictor, tableTemplate, predictorsArity.addAndGet(1))))\n+                .filter(entry -> entry.getValue().isPresent())\n+                .collect(Collectors.toMap(AbstractMap.SimpleEntry::getKey,\n+                                          entry -> entry.getValue().get()));\n+    }\n+\n+    /**\n+     * Add a <b>NumericPredictor</b> <code>MethodDeclaration</code> to the class\n+     * @param numericPredictor\n+     * @param tableTemplate\n+     * @param predictorArity\n+     * @return\n+     */\n+    private static Optional<MethodDeclaration> addNumericPredictor(final NumericPredictor numericPredictor, final ClassOrInterfaceDeclaration tableTemplate, int predictorArity) {\n+        try {\n+            templateEvaluate = StaticJavaParser.parseResource(KIE_PMML_EVALUATE_METHOD_TEMPLATE_JAVA);\n+            cloneEvaluate = templateEvaluate.clone();\n+            ClassOrInterfaceDeclaration evaluateTemplateClass = cloneEvaluate.getClassByName(KIE_PMML_EVALUATE_METHOD_TEMPLATE)\n+                    .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+            MethodDeclaration methodTemplate;\n+            if (Objects.equals(1, numericPredictor.getExponent())) {\n+                methodTemplate = getNumericPredictorWithoutExponentTemplate(numericPredictor, evaluateTemplateClass);\n+            } else {\n+                methodTemplate = getNumericPredictorWithExponentTemplate(numericPredictor, evaluateTemplateClass);\n+            }\n+            return addMethod(methodTemplate, tableTemplate, \"evaluateNumericPredictor\" + predictorArity);\n+        } catch (Exception e) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * Add a <b>NumericPredictor</b> <code>MethodDeclaration</code> with <b>exponent != 1</b> to the class\n+     * @param numericPredictor\n+     * @param evaluateTemplateClass\n+     * @return\n+     */\n+    private static MethodDeclaration getNumericPredictorWithExponentTemplate(final NumericPredictor numericPredictor, final ClassOrInterfaceDeclaration evaluateTemplateClass) {\n+        final MethodDeclaration toReturn = evaluateTemplateClass.getMethodsByName(\"evaluateNumericWithExponent\").get(0);\n+        toReturn.getBody().ifPresent(body -> {\n+            final List<VariableDeclarator> variableDeclarators = body.findAll(VariableDeclarator.class);\n+            variableDeclarators.forEach(variableDeclarator -> {\n+                String initializer = null;\n+                if (variableDeclarator.getName().asString().equals(COEFFICIENT)) {\n+                    initializer = String.valueOf(numericPredictor.getCoefficient().doubleValue());\n+                } else if (variableDeclarator.getName().asString().equals(EXPONENT)) {\n+                    initializer = String.valueOf(numericPredictor.getExponent().doubleValue());\n+                }\n+                if (initializer != null) {\n+                    variableDeclarator.setInitializer(initializer);\n+                }\n+            });\n+        });\n+        return toReturn;\n+    }\n+\n+    /**\n+     * Add a <b>NumericPredictor</b> <code>MethodDeclaration</code> with <b>exponent == 1</b> to the class\n+     * @param numericPredictor\n+     * @param evaluateTemplateClass\n+     * @return\n+     */\n+    private static MethodDeclaration getNumericPredictorWithoutExponentTemplate(final NumericPredictor numericPredictor, final ClassOrInterfaceDeclaration evaluateTemplateClass) {\n+        final MethodDeclaration toReturn = evaluateTemplateClass.getMethodsByName(\"evaluateNumericWithoutExponent\").get(0);\n+        toReturn.getBody().ifPresent(body -> {\n+            final List<VariableDeclarator> variableDeclarators = body.findAll(VariableDeclarator.class);\n+            variableDeclarators.stream().filter(variableDeclarator -> variableDeclarator.getName().asString().equals(COEFFICIENT))\n+                    .forEach(variableDeclarator -> variableDeclarator.setInitializer(String.valueOf(numericPredictor.getCoefficient().doubleValue())));\n+        });\n+        return toReturn;\n+    }\n+\n+    /**\n+     * Add <b>CategoricalPredictor</b>s <code>MethodDeclaration</code> to the class\n+     * @param categoricalPredictors\n+     * @param tableTemplate\n+     * @return\n+     */\n+    private static Map<String, MethodDeclaration> addCategoricalPredictors(final List<CategoricalPredictor> categoricalPredictors, final ClassOrInterfaceDeclaration tableTemplate) {\n+        predictorsArity.set(0);\n+        final Map<String, List<CategoricalPredictor>> groupedCollectors = categoricalPredictors.stream()\n+                .collect(groupingBy(categoricalPredictor -> categoricalPredictor.getField().getValue()));\n+        return groupedCollectors.entrySet().stream()\n+                .map(entry -> new AbstractMap.SimpleEntry<>(entry.getKey(),\n+                                                            addGroupedCategoricalPredictor(entry.getValue(), tableTemplate, predictorsArity.addAndGet(1))))\n+                .filter(entry -> entry.getValue().isPresent())\n+                .collect(Collectors.toMap(AbstractMap.SimpleEntry::getKey,\n+                                          entry -> entry.getValue().get()));\n+    }\n+\n+    /**\n+     * Add a <b>CategoricalPredictor</b> <code>MethodDeclaration</code> to the class\n+     * @param categoricalPredictors\n+     * @param tableTemplate\n+     * @param predictorArity\n+     * @return\n+     */\n+    private static Optional<MethodDeclaration> addGroupedCategoricalPredictor(final List<CategoricalPredictor> categoricalPredictors, final ClassOrInterfaceDeclaration tableTemplate, int predictorArity) {\n+        try {\n+            templateEvaluate = StaticJavaParser.parseResource(KIE_PMML_EVALUATE_METHOD_TEMPLATE_JAVA);\n+            cloneEvaluate = templateEvaluate.clone();\n+            ClassOrInterfaceDeclaration evaluateTemplateClass = cloneEvaluate.getClassByName(KIE_PMML_EVALUATE_METHOD_TEMPLATE)\n+                    .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+            MethodDeclaration methodTemplate = evaluateTemplateClass.getMethodsByName(\"evaluateCategorical\").get(0);\n+            methodTemplate.getBody().ifPresent(body -> {\n+                IfStmt ifStmt = new IfStmt();\n+                for (int i = 0; i < categoricalPredictors.size(); i++) {\n+                    CategoricalPredictor categoricalPredictor = categoricalPredictors.get(i);\n+                    Expression lhe;\n+                    if (categoricalPredictor.getValue() instanceof String) {\n+                        lhe = new StringLiteralExpr((String) categoricalPredictor.getValue());\n+                    } else {\n+                        lhe = new NameExpr(categoricalPredictor.getValue().toString());\n+                    }\n+                    NodeList<Expression> expressions = NodeList.nodeList(lhe, new NameExpr(\"input\"));\n+                    MethodCallExpr conditionExpr = new MethodCallExpr(new NameExpr(\"Objects\"), \"equals\", expressions);\n+                    if (i == 0) {\n+                        ifStmt.setCondition(conditionExpr);\n+                        ifStmt.setThenStmt(new ReturnStmt(new DoubleLiteralExpr(String.valueOf(categoricalPredictor.getCoefficient()))));\n+                        body.addStatement(ifStmt);\n+                    } else {\n+                        IfStmt elseIf = new IfStmt();\n+                        elseIf.setCondition(conditionExpr);\n+                        elseIf.setThenStmt(new ReturnStmt(new DoubleLiteralExpr(String.valueOf(categoricalPredictor.getCoefficient()))));\n+                        ifStmt.setElseStmt(elseIf);\n+                        ifStmt = elseIf;\n+                    }\n+                }\n+                ifStmt.setElseStmt(new ReturnStmt(new DoubleLiteralExpr(\"0.0\")));\n+            });\n+            return addMethod(methodTemplate, tableTemplate, \"evaluateCategoricalPredictor\" + predictorArity);\n+        } catch (Exception e) {\n+            //\n+            return Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * Add <b>PredictorTerm</b>s <code>MethodDeclaration</code> to the class\n+     * @param predictorTerms\n+     * @param tableTemplate\n+     * @return\n+     */\n+    private static Map<String, MethodDeclaration> addPredictorTerms(final List<PredictorTerm> predictorTerms, final ClassOrInterfaceDeclaration tableTemplate) {\n+        predictorsArity.set(0);\n+        return predictorTerms.stream()\n+                .map(predictorTerm -> {\n+                    int arity = predictorsArity.addAndGet(1);\n+                    return new AbstractMap.SimpleEntry<>(predictorTerm.getName() != null ? predictorTerm.getName().getValue() : \"predictorTerm\" + arity,\n+                                                         addPredictorTerm(predictorTerm, tableTemplate, arity));\n+                })\n+                .filter(entry -> entry.getValue().isPresent())\n+                .collect(Collectors.toMap(AbstractMap.SimpleEntry::getKey,\n+                                          entry -> entry.getValue().get()));\n+    }\n+\n+    /**\n+     * Add a <b>PredictorTerm</b> <code>MethodDeclaration</code> to the class\n+     * @param predictorTerm\n+     * @param tableTemplate\n+     * @param predictorArity\n+     * @return\n+     */\n+    private static Optional<MethodDeclaration> addPredictorTerm(final PredictorTerm predictorTerm, final ClassOrInterfaceDeclaration tableTemplate, int predictorArity) {\n+        try {\n+            templateEvaluate = StaticJavaParser.parseResource(KIE_PMML_EVALUATE_METHOD_TEMPLATE_JAVA);\n+            cloneEvaluate = templateEvaluate.clone();\n+            ClassOrInterfaceDeclaration evaluateTemplateClass = cloneEvaluate.getClassByName(KIE_PMML_EVALUATE_METHOD_TEMPLATE)\n+                    .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+            MethodDeclaration methodTemplate = evaluateTemplateClass.getMethodsByName(\"evaluatePredictor\").get(0);\n+            methodTemplate.getBody().ifPresent(body -> {\n+                final List<VariableDeclarator> variableDeclarators = body.findAll(VariableDeclarator.class);\n+                variableDeclarators.forEach(variableDeclarator -> {\n+                    if (variableDeclarator.getName().asString().equals(\"fieldRefs\")) {\n+                        final List<Expression> nodeList = predictorTerm.getFieldRefs().stream()\n+                                .map(fieldRef -> new StringLiteralExpr(fieldRef.getField().getValue()))\n+                                .collect(Collectors.toList());\n+                        NodeList<Expression> expressions = NodeList.nodeList(nodeList);\n+                        MethodCallExpr methodCallExpr = new MethodCallExpr(new NameExpr(\"Arrays\"), \"asList\", expressions);\n+                        variableDeclarator.setInitializer(methodCallExpr);\n+                    } else if (variableDeclarator.getName().asString().equals(COEFFICIENT)) {\n+                        variableDeclarator.setInitializer(String.valueOf(predictorTerm.getCoefficient().doubleValue()));\n+                    }\n+                });\n+            });\n+            return addMethod(methodTemplate, tableTemplate, \"evaluatePredictorTerm\" + predictorArity);\n+        } catch (Exception e) {\n+            //\n+            return Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * Add a <code>MethodDeclaration</code> to the class\n+     * @param methodTemplate\n+     * @param tableTemplate\n+     * @param evaluateMethodName\n+     * @return\n+     */\n+    protected static Optional<MethodDeclaration> addMethod(final MethodDeclaration methodTemplate, final ClassOrInterfaceDeclaration tableTemplate, final String evaluateMethodName) {\n+        return methodTemplate.getBody().map(body -> {\n+            final MethodDeclaration toReturn = tableTemplate.addMethod(evaluateMethodName).setBody(body);\n+            toReturn.setModifiers(methodTemplate.getModifiers());\n+            methodTemplate.getParameters().forEach(toReturn::addParameter);\n+            toReturn.setType(methodTemplate.getType());\n+            return toReturn;\n+        });\n+    }\n+\n+    /**\n+     * Populate the <b>getTargetCategory</b> method of the class\n+     * @param tableTemplate\n+     * @param targetCategory\n+     * @return\n+     */\n+    protected static void populateGetTargetCategory(final ClassOrInterfaceDeclaration tableTemplate, final Object targetCategory) {\n+        MethodDeclaration methodDeclaration = tableTemplate.getMethodsByName(\"getTargetCategory\").get(0);\n+        methodDeclaration.getBody().ifPresent(body -> {\n+            ReturnStmt returnStmt = new ReturnStmt();\n+            if (targetCategory == null) {\n+                returnStmt.setExpression(new NameExpr(\"null\"));\n+            } else if (targetCategory instanceof String) {\n+                returnStmt.setExpression(new StringLiteralExpr((String) targetCategory));\n+            } else {\n+                returnStmt.setExpression(new NameExpr(targetCategory.toString()));\n+            }\n+            body.addStatement(returnStmt);\n+        });\n+    }\n+\n+    /**\n+     * Populate the <b>getTargetCategory</b> method of the class\n+     * @param tableTemplate\n+     * @param normalizationMethod\n+     * @return\n+     */\n+    protected static void populateUpdateResult(final ClassOrInterfaceDeclaration tableTemplate, final RegressionModel.NormalizationMethod normalizationMethod) {\n+        try {\n+            templateEvaluate = StaticJavaParser.parseResource(KIE_PMML_UPDATE_RESULT_METHOD_TEMPLATE_JAVA);\n+            cloneEvaluate = templateEvaluate.clone();\n+            ClassOrInterfaceDeclaration evaluateTemplateClass = cloneEvaluate.getClassByName(KIE_PMML_UPDATE_RESULT_METHOD_TEMPLATE)\n+                    .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+            String methodName = String.format(\"update%sResult\", normalizationMethod.name());\n+            MethodDeclaration methodTemplate = evaluateTemplateClass.getMethodsByName(methodName).get(0);\n+            methodTemplate.getBody().ifPresent(body -> {\n+                MethodDeclaration targetMethod = tableTemplate.getMethodsByName(\"updateResult\").get(0);\n+                targetMethod.setBody(body);\n+            });\n+        } catch (Exception e) {\n+            //", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA5NDIxMA=="}, "originalCommit": {"oid": "3c4a838980a18a8428b253ee431087beb471fe8d"}, "originalPosition": 407}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDEwOTU2OnYy", "diffSide": "RIGHT", "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/main/java/org/kie/pmml/models/regression/compiler/factories/KiePMMLRegressionTableRegressionFactory.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwODo0Mzo1OFrOF17isA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMToxMzo0MlrOF1_8hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA5NDM4NA==", "bodyText": "Same comment", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r392094384", "createdAt": "2020-03-13T08:43:58Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/main/java/org/kie/pmml/models/regression/compiler/factories/KiePMMLRegressionTableRegressionFactory.java", "diffHunk": "@@ -0,0 +1,410 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.compiler.factories;\n+\n+import java.io.IOException;\n+import java.util.AbstractMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.DoubleLiteralExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.MethodReferenceExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.expr.ThisExpr;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.IfStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import org.dmg.pmml.regression.CategoricalPredictor;\n+import org.dmg.pmml.regression.NumericPredictor;\n+import org.dmg.pmml.regression.PredictorTerm;\n+import org.dmg.pmml.regression.RegressionModel;\n+import org.dmg.pmml.regression.RegressionTable;\n+import org.kie.pmml.models.regression.model.tuples.KiePMMLTableSourceCategory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+\n+public class KiePMMLRegressionTableRegressionFactory {\n+\n+    public static final String KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE_JAVA = \"KiePMMLRegressionTableRegressionTemplate.tmpl\";\n+    private static final Logger logger = LoggerFactory.getLogger(KiePMMLRegressionTableRegressionFactory.class.getName());\n+    private static final String MAIN_CLASS_NOT_FOUND = \"Main class not found\";\n+    private static final String KIE_PMML_EVALUATE_METHOD_TEMPLATE_JAVA = \"KiePMMLEvaluateMethodTemplate.tmpl\";\n+    private static final String KIE_PMML_EVALUATE_METHOD_TEMPLATE = \"KiePMMLEvaluateMethodTemplate\";\n+    private static final String KIE_PMML_UPDATE_RESULT_METHOD_TEMPLATE_JAVA = \"KiePMMLUpdateResultMethodTemplate.tmpl\";\n+    private static final String KIE_PMML_UPDATE_RESULT_METHOD_TEMPLATE = \"KiePMMLUpdateResultMethodTemplate\";\n+    private static final String KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE = \"KiePMMLRegressionTableRegressionTemplate\";\n+    private static final String COEFFICIENT = \"coefficient\";\n+    private static final String EXPONENT = \"exponent\";\n+    private static AtomicInteger classArity = new AtomicInteger(0);\n+    private static AtomicInteger predictorsArity = new AtomicInteger(0);\n+    private static CompilationUnit templateEvaluate;\n+    private static CompilationUnit cloneEvaluate;\n+\n+    private KiePMMLRegressionTableRegressionFactory() {\n+        // Avoid instantiation\n+    }\n+\n+    public static Map<String, KiePMMLTableSourceCategory> getRegressionTables(final List<RegressionTable> regressionTables, final RegressionModel.NormalizationMethod normalizationMethod, final String targetField) throws IOException {\n+        logger.debug(\"getRegressionTables {}\", regressionTables);\n+        CompilationUnit templateCU = StaticJavaParser.parseResource(KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE_JAVA);\n+        Map<String, KiePMMLTableSourceCategory> toReturn = new HashMap<>();\n+        for (RegressionTable regressionTable : regressionTables) {\n+            final Map.Entry<String, String> regressionTableEntry = getRegressionTable(templateCU, regressionTable, normalizationMethod, targetField);\n+            String targetCategory = regressionTable.getTargetCategory() != null ? regressionTable.getTargetCategory().toString() : \"\";\n+            toReturn.put(regressionTableEntry.getKey(), new KiePMMLTableSourceCategory(regressionTableEntry.getValue(), targetCategory));\n+        }\n+        return toReturn;\n+    }\n+\n+    public static AbstractMap.Entry<String, String> getRegressionTable(final CompilationUnit templateCU, final RegressionTable regressionTable, final RegressionModel.NormalizationMethod normalizationMethod, final String targetField) {\n+        logger.debug(\"getRegressionTable {}\", regressionTable);\n+        CompilationUnit cloneCU = templateCU.clone();\n+        ClassOrInterfaceDeclaration tableTemplate = cloneCU.getClassByName(KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE)\n+                .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+        String className = \"KiePMMLRegressionTableRegression\" + classArity.addAndGet(1);\n+        tableTemplate.setName(className);\n+        setConstructor(regressionTable, tableTemplate, targetField);\n+        final Map<String, MethodDeclaration> numericPredictorsMap = addNumericPredictors(regressionTable.getNumericPredictors(), tableTemplate);\n+        final Map<String, MethodDeclaration> categoricalPredictorsMap = addCategoricalPredictors(regressionTable.getCategoricalPredictors(), tableTemplate);\n+        final Map<String, MethodDeclaration> predictorTermsMap = addPredictorTerms(regressionTable.getPredictorTerms(), tableTemplate);\n+        tableTemplate.getDefaultConstructor().ifPresent(constructorDeclaration -> {\n+            final BlockStmt body = constructorDeclaration.getBody();\n+            addMapPopulation(numericPredictorsMap, body, \"numericFunctionMap\");\n+            addMapPopulation(categoricalPredictorsMap, body, \"categoricalFunctionMap\");\n+            addMapPopulation(predictorTermsMap, body, \"predictorTermsFunctionMap\");\n+        });\n+        populateGetTargetCategory(tableTemplate, regressionTable.getTargetCategory());\n+        populateUpdateResult(tableTemplate, normalizationMethod);\n+        return new AbstractMap.SimpleEntry<>(className, cloneCU.toString());\n+    }\n+\n+    /**\n+     * Add entries <b>fieldName/function</b> inside the constructor\n+     * @param toAdd\n+     * @param body\n+     * @param mapName\n+     */\n+    private static void addMapPopulation(final Map<String, MethodDeclaration> toAdd, final BlockStmt body, final String mapName) {\n+        toAdd.forEach((s, methodDeclaration) -> {\n+            MethodReferenceExpr methodReferenceExpr = new MethodReferenceExpr();\n+            methodReferenceExpr.setScope(new ThisExpr());\n+            methodReferenceExpr.setIdentifier(methodDeclaration.getNameAsString());\n+            NodeList<Expression> expressions = NodeList.nodeList(new StringLiteralExpr(s), methodReferenceExpr);\n+            body.addStatement(new MethodCallExpr(new NameExpr(mapName), \"put\", expressions));\n+        });\n+    }\n+\n+    /**\n+     * Set the <b>intercept</b> and <b>targetField</b> values inside the constructor\n+     * @param regressionTable\n+     * @param tableTemplate\n+     * @param targetField\n+     */\n+    private static void setConstructor(final RegressionTable regressionTable, final ClassOrInterfaceDeclaration tableTemplate, final String targetField) {\n+        tableTemplate.getDefaultConstructor().ifPresent(constructorDeclaration -> {\n+            constructorDeclaration.setName(tableTemplate.getName());\n+            final BlockStmt body = constructorDeclaration.getBody();\n+            final List<AssignExpr> assignExprs = body.findAll(AssignExpr.class);\n+            assignExprs.forEach(assignExpr -> {\n+                if (assignExpr.getTarget().asNameExpr().getNameAsString().equals(\"intercept\")) {\n+                    assignExpr.setValue(new DoubleLiteralExpr(String.valueOf(regressionTable.getIntercept().doubleValue())));\n+                } else if (assignExpr.getTarget().asNameExpr().getNameAsString().equals(\"targetField\")) {\n+                    assignExpr.setValue(new StringLiteralExpr(targetField));\n+                }\n+            });\n+        });\n+    }\n+\n+    /**\n+     * Add <b>NumericPredictor</b>s <code>MethodDeclaration</code> to the class\n+     * @param numericPredictors\n+     * @param tableTemplate\n+     * @return\n+     */\n+    private static Map<String, MethodDeclaration> addNumericPredictors(final List<NumericPredictor> numericPredictors, final ClassOrInterfaceDeclaration tableTemplate) {\n+        predictorsArity.set(0);\n+        return numericPredictors.stream()\n+                .map(numericPredictor -> new AbstractMap.SimpleEntry<>(numericPredictor.getName().getValue(),\n+                                                                       addNumericPredictor(numericPredictor, tableTemplate, predictorsArity.addAndGet(1))))\n+                .filter(entry -> entry.getValue().isPresent())\n+                .collect(Collectors.toMap(AbstractMap.SimpleEntry::getKey,\n+                                          entry -> entry.getValue().get()));\n+    }\n+\n+    /**\n+     * Add a <b>NumericPredictor</b> <code>MethodDeclaration</code> to the class\n+     * @param numericPredictor\n+     * @param tableTemplate\n+     * @param predictorArity\n+     * @return\n+     */\n+    private static Optional<MethodDeclaration> addNumericPredictor(final NumericPredictor numericPredictor, final ClassOrInterfaceDeclaration tableTemplate, int predictorArity) {\n+        try {\n+            templateEvaluate = StaticJavaParser.parseResource(KIE_PMML_EVALUATE_METHOD_TEMPLATE_JAVA);\n+            cloneEvaluate = templateEvaluate.clone();\n+            ClassOrInterfaceDeclaration evaluateTemplateClass = cloneEvaluate.getClassByName(KIE_PMML_EVALUATE_METHOD_TEMPLATE)\n+                    .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+            MethodDeclaration methodTemplate;\n+            if (Objects.equals(1, numericPredictor.getExponent())) {\n+                methodTemplate = getNumericPredictorWithoutExponentTemplate(numericPredictor, evaluateTemplateClass);\n+            } else {\n+                methodTemplate = getNumericPredictorWithExponentTemplate(numericPredictor, evaluateTemplateClass);\n+            }\n+            return addMethod(methodTemplate, tableTemplate, \"evaluateNumericPredictor\" + predictorArity);\n+        } catch (Exception e) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * Add a <b>NumericPredictor</b> <code>MethodDeclaration</code> with <b>exponent != 1</b> to the class\n+     * @param numericPredictor\n+     * @param evaluateTemplateClass\n+     * @return\n+     */\n+    private static MethodDeclaration getNumericPredictorWithExponentTemplate(final NumericPredictor numericPredictor, final ClassOrInterfaceDeclaration evaluateTemplateClass) {\n+        final MethodDeclaration toReturn = evaluateTemplateClass.getMethodsByName(\"evaluateNumericWithExponent\").get(0);\n+        toReturn.getBody().ifPresent(body -> {\n+            final List<VariableDeclarator> variableDeclarators = body.findAll(VariableDeclarator.class);\n+            variableDeclarators.forEach(variableDeclarator -> {\n+                String initializer = null;\n+                if (variableDeclarator.getName().asString().equals(COEFFICIENT)) {\n+                    initializer = String.valueOf(numericPredictor.getCoefficient().doubleValue());\n+                } else if (variableDeclarator.getName().asString().equals(EXPONENT)) {\n+                    initializer = String.valueOf(numericPredictor.getExponent().doubleValue());\n+                }\n+                if (initializer != null) {\n+                    variableDeclarator.setInitializer(initializer);\n+                }\n+            });\n+        });\n+        return toReturn;\n+    }\n+\n+    /**\n+     * Add a <b>NumericPredictor</b> <code>MethodDeclaration</code> with <b>exponent == 1</b> to the class\n+     * @param numericPredictor\n+     * @param evaluateTemplateClass\n+     * @return\n+     */\n+    private static MethodDeclaration getNumericPredictorWithoutExponentTemplate(final NumericPredictor numericPredictor, final ClassOrInterfaceDeclaration evaluateTemplateClass) {\n+        final MethodDeclaration toReturn = evaluateTemplateClass.getMethodsByName(\"evaluateNumericWithoutExponent\").get(0);\n+        toReturn.getBody().ifPresent(body -> {\n+            final List<VariableDeclarator> variableDeclarators = body.findAll(VariableDeclarator.class);\n+            variableDeclarators.stream().filter(variableDeclarator -> variableDeclarator.getName().asString().equals(COEFFICIENT))\n+                    .forEach(variableDeclarator -> variableDeclarator.setInitializer(String.valueOf(numericPredictor.getCoefficient().doubleValue())));\n+        });\n+        return toReturn;\n+    }\n+\n+    /**\n+     * Add <b>CategoricalPredictor</b>s <code>MethodDeclaration</code> to the class\n+     * @param categoricalPredictors\n+     * @param tableTemplate\n+     * @return\n+     */\n+    private static Map<String, MethodDeclaration> addCategoricalPredictors(final List<CategoricalPredictor> categoricalPredictors, final ClassOrInterfaceDeclaration tableTemplate) {\n+        predictorsArity.set(0);\n+        final Map<String, List<CategoricalPredictor>> groupedCollectors = categoricalPredictors.stream()\n+                .collect(groupingBy(categoricalPredictor -> categoricalPredictor.getField().getValue()));\n+        return groupedCollectors.entrySet().stream()\n+                .map(entry -> new AbstractMap.SimpleEntry<>(entry.getKey(),\n+                                                            addGroupedCategoricalPredictor(entry.getValue(), tableTemplate, predictorsArity.addAndGet(1))))\n+                .filter(entry -> entry.getValue().isPresent())\n+                .collect(Collectors.toMap(AbstractMap.SimpleEntry::getKey,\n+                                          entry -> entry.getValue().get()));\n+    }\n+\n+    /**\n+     * Add a <b>CategoricalPredictor</b> <code>MethodDeclaration</code> to the class\n+     * @param categoricalPredictors\n+     * @param tableTemplate\n+     * @param predictorArity\n+     * @return\n+     */\n+    private static Optional<MethodDeclaration> addGroupedCategoricalPredictor(final List<CategoricalPredictor> categoricalPredictors, final ClassOrInterfaceDeclaration tableTemplate, int predictorArity) {\n+        try {\n+            templateEvaluate = StaticJavaParser.parseResource(KIE_PMML_EVALUATE_METHOD_TEMPLATE_JAVA);\n+            cloneEvaluate = templateEvaluate.clone();\n+            ClassOrInterfaceDeclaration evaluateTemplateClass = cloneEvaluate.getClassByName(KIE_PMML_EVALUATE_METHOD_TEMPLATE)\n+                    .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+            MethodDeclaration methodTemplate = evaluateTemplateClass.getMethodsByName(\"evaluateCategorical\").get(0);\n+            methodTemplate.getBody().ifPresent(body -> {\n+                IfStmt ifStmt = new IfStmt();\n+                for (int i = 0; i < categoricalPredictors.size(); i++) {\n+                    CategoricalPredictor categoricalPredictor = categoricalPredictors.get(i);\n+                    Expression lhe;\n+                    if (categoricalPredictor.getValue() instanceof String) {\n+                        lhe = new StringLiteralExpr((String) categoricalPredictor.getValue());\n+                    } else {\n+                        lhe = new NameExpr(categoricalPredictor.getValue().toString());\n+                    }\n+                    NodeList<Expression> expressions = NodeList.nodeList(lhe, new NameExpr(\"input\"));\n+                    MethodCallExpr conditionExpr = new MethodCallExpr(new NameExpr(\"Objects\"), \"equals\", expressions);\n+                    if (i == 0) {\n+                        ifStmt.setCondition(conditionExpr);\n+                        ifStmt.setThenStmt(new ReturnStmt(new DoubleLiteralExpr(String.valueOf(categoricalPredictor.getCoefficient()))));\n+                        body.addStatement(ifStmt);\n+                    } else {\n+                        IfStmt elseIf = new IfStmt();\n+                        elseIf.setCondition(conditionExpr);\n+                        elseIf.setThenStmt(new ReturnStmt(new DoubleLiteralExpr(String.valueOf(categoricalPredictor.getCoefficient()))));\n+                        ifStmt.setElseStmt(elseIf);\n+                        ifStmt = elseIf;\n+                    }\n+                }\n+                ifStmt.setElseStmt(new ReturnStmt(new DoubleLiteralExpr(\"0.0\")));\n+            });\n+            return addMethod(methodTemplate, tableTemplate, \"evaluateCategoricalPredictor\" + predictorArity);\n+        } catch (Exception e) {\n+            //", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c4a838980a18a8428b253ee431087beb471fe8d"}, "originalPosition": 290}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE2NjUzNA==", "bodyText": "@danielezonca\nSee above...", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r392166534", "createdAt": "2020-03-13T11:13:42Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/main/java/org/kie/pmml/models/regression/compiler/factories/KiePMMLRegressionTableRegressionFactory.java", "diffHunk": "@@ -0,0 +1,410 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.compiler.factories;\n+\n+import java.io.IOException;\n+import java.util.AbstractMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.DoubleLiteralExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.MethodReferenceExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.expr.ThisExpr;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.IfStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import org.dmg.pmml.regression.CategoricalPredictor;\n+import org.dmg.pmml.regression.NumericPredictor;\n+import org.dmg.pmml.regression.PredictorTerm;\n+import org.dmg.pmml.regression.RegressionModel;\n+import org.dmg.pmml.regression.RegressionTable;\n+import org.kie.pmml.models.regression.model.tuples.KiePMMLTableSourceCategory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+\n+public class KiePMMLRegressionTableRegressionFactory {\n+\n+    public static final String KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE_JAVA = \"KiePMMLRegressionTableRegressionTemplate.tmpl\";\n+    private static final Logger logger = LoggerFactory.getLogger(KiePMMLRegressionTableRegressionFactory.class.getName());\n+    private static final String MAIN_CLASS_NOT_FOUND = \"Main class not found\";\n+    private static final String KIE_PMML_EVALUATE_METHOD_TEMPLATE_JAVA = \"KiePMMLEvaluateMethodTemplate.tmpl\";\n+    private static final String KIE_PMML_EVALUATE_METHOD_TEMPLATE = \"KiePMMLEvaluateMethodTemplate\";\n+    private static final String KIE_PMML_UPDATE_RESULT_METHOD_TEMPLATE_JAVA = \"KiePMMLUpdateResultMethodTemplate.tmpl\";\n+    private static final String KIE_PMML_UPDATE_RESULT_METHOD_TEMPLATE = \"KiePMMLUpdateResultMethodTemplate\";\n+    private static final String KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE = \"KiePMMLRegressionTableRegressionTemplate\";\n+    private static final String COEFFICIENT = \"coefficient\";\n+    private static final String EXPONENT = \"exponent\";\n+    private static AtomicInteger classArity = new AtomicInteger(0);\n+    private static AtomicInteger predictorsArity = new AtomicInteger(0);\n+    private static CompilationUnit templateEvaluate;\n+    private static CompilationUnit cloneEvaluate;\n+\n+    private KiePMMLRegressionTableRegressionFactory() {\n+        // Avoid instantiation\n+    }\n+\n+    public static Map<String, KiePMMLTableSourceCategory> getRegressionTables(final List<RegressionTable> regressionTables, final RegressionModel.NormalizationMethod normalizationMethod, final String targetField) throws IOException {\n+        logger.debug(\"getRegressionTables {}\", regressionTables);\n+        CompilationUnit templateCU = StaticJavaParser.parseResource(KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE_JAVA);\n+        Map<String, KiePMMLTableSourceCategory> toReturn = new HashMap<>();\n+        for (RegressionTable regressionTable : regressionTables) {\n+            final Map.Entry<String, String> regressionTableEntry = getRegressionTable(templateCU, regressionTable, normalizationMethod, targetField);\n+            String targetCategory = regressionTable.getTargetCategory() != null ? regressionTable.getTargetCategory().toString() : \"\";\n+            toReturn.put(regressionTableEntry.getKey(), new KiePMMLTableSourceCategory(regressionTableEntry.getValue(), targetCategory));\n+        }\n+        return toReturn;\n+    }\n+\n+    public static AbstractMap.Entry<String, String> getRegressionTable(final CompilationUnit templateCU, final RegressionTable regressionTable, final RegressionModel.NormalizationMethod normalizationMethod, final String targetField) {\n+        logger.debug(\"getRegressionTable {}\", regressionTable);\n+        CompilationUnit cloneCU = templateCU.clone();\n+        ClassOrInterfaceDeclaration tableTemplate = cloneCU.getClassByName(KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE)\n+                .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+        String className = \"KiePMMLRegressionTableRegression\" + classArity.addAndGet(1);\n+        tableTemplate.setName(className);\n+        setConstructor(regressionTable, tableTemplate, targetField);\n+        final Map<String, MethodDeclaration> numericPredictorsMap = addNumericPredictors(regressionTable.getNumericPredictors(), tableTemplate);\n+        final Map<String, MethodDeclaration> categoricalPredictorsMap = addCategoricalPredictors(regressionTable.getCategoricalPredictors(), tableTemplate);\n+        final Map<String, MethodDeclaration> predictorTermsMap = addPredictorTerms(regressionTable.getPredictorTerms(), tableTemplate);\n+        tableTemplate.getDefaultConstructor().ifPresent(constructorDeclaration -> {\n+            final BlockStmt body = constructorDeclaration.getBody();\n+            addMapPopulation(numericPredictorsMap, body, \"numericFunctionMap\");\n+            addMapPopulation(categoricalPredictorsMap, body, \"categoricalFunctionMap\");\n+            addMapPopulation(predictorTermsMap, body, \"predictorTermsFunctionMap\");\n+        });\n+        populateGetTargetCategory(tableTemplate, regressionTable.getTargetCategory());\n+        populateUpdateResult(tableTemplate, normalizationMethod);\n+        return new AbstractMap.SimpleEntry<>(className, cloneCU.toString());\n+    }\n+\n+    /**\n+     * Add entries <b>fieldName/function</b> inside the constructor\n+     * @param toAdd\n+     * @param body\n+     * @param mapName\n+     */\n+    private static void addMapPopulation(final Map<String, MethodDeclaration> toAdd, final BlockStmt body, final String mapName) {\n+        toAdd.forEach((s, methodDeclaration) -> {\n+            MethodReferenceExpr methodReferenceExpr = new MethodReferenceExpr();\n+            methodReferenceExpr.setScope(new ThisExpr());\n+            methodReferenceExpr.setIdentifier(methodDeclaration.getNameAsString());\n+            NodeList<Expression> expressions = NodeList.nodeList(new StringLiteralExpr(s), methodReferenceExpr);\n+            body.addStatement(new MethodCallExpr(new NameExpr(mapName), \"put\", expressions));\n+        });\n+    }\n+\n+    /**\n+     * Set the <b>intercept</b> and <b>targetField</b> values inside the constructor\n+     * @param regressionTable\n+     * @param tableTemplate\n+     * @param targetField\n+     */\n+    private static void setConstructor(final RegressionTable regressionTable, final ClassOrInterfaceDeclaration tableTemplate, final String targetField) {\n+        tableTemplate.getDefaultConstructor().ifPresent(constructorDeclaration -> {\n+            constructorDeclaration.setName(tableTemplate.getName());\n+            final BlockStmt body = constructorDeclaration.getBody();\n+            final List<AssignExpr> assignExprs = body.findAll(AssignExpr.class);\n+            assignExprs.forEach(assignExpr -> {\n+                if (assignExpr.getTarget().asNameExpr().getNameAsString().equals(\"intercept\")) {\n+                    assignExpr.setValue(new DoubleLiteralExpr(String.valueOf(regressionTable.getIntercept().doubleValue())));\n+                } else if (assignExpr.getTarget().asNameExpr().getNameAsString().equals(\"targetField\")) {\n+                    assignExpr.setValue(new StringLiteralExpr(targetField));\n+                }\n+            });\n+        });\n+    }\n+\n+    /**\n+     * Add <b>NumericPredictor</b>s <code>MethodDeclaration</code> to the class\n+     * @param numericPredictors\n+     * @param tableTemplate\n+     * @return\n+     */\n+    private static Map<String, MethodDeclaration> addNumericPredictors(final List<NumericPredictor> numericPredictors, final ClassOrInterfaceDeclaration tableTemplate) {\n+        predictorsArity.set(0);\n+        return numericPredictors.stream()\n+                .map(numericPredictor -> new AbstractMap.SimpleEntry<>(numericPredictor.getName().getValue(),\n+                                                                       addNumericPredictor(numericPredictor, tableTemplate, predictorsArity.addAndGet(1))))\n+                .filter(entry -> entry.getValue().isPresent())\n+                .collect(Collectors.toMap(AbstractMap.SimpleEntry::getKey,\n+                                          entry -> entry.getValue().get()));\n+    }\n+\n+    /**\n+     * Add a <b>NumericPredictor</b> <code>MethodDeclaration</code> to the class\n+     * @param numericPredictor\n+     * @param tableTemplate\n+     * @param predictorArity\n+     * @return\n+     */\n+    private static Optional<MethodDeclaration> addNumericPredictor(final NumericPredictor numericPredictor, final ClassOrInterfaceDeclaration tableTemplate, int predictorArity) {\n+        try {\n+            templateEvaluate = StaticJavaParser.parseResource(KIE_PMML_EVALUATE_METHOD_TEMPLATE_JAVA);\n+            cloneEvaluate = templateEvaluate.clone();\n+            ClassOrInterfaceDeclaration evaluateTemplateClass = cloneEvaluate.getClassByName(KIE_PMML_EVALUATE_METHOD_TEMPLATE)\n+                    .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+            MethodDeclaration methodTemplate;\n+            if (Objects.equals(1, numericPredictor.getExponent())) {\n+                methodTemplate = getNumericPredictorWithoutExponentTemplate(numericPredictor, evaluateTemplateClass);\n+            } else {\n+                methodTemplate = getNumericPredictorWithExponentTemplate(numericPredictor, evaluateTemplateClass);\n+            }\n+            return addMethod(methodTemplate, tableTemplate, \"evaluateNumericPredictor\" + predictorArity);\n+        } catch (Exception e) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * Add a <b>NumericPredictor</b> <code>MethodDeclaration</code> with <b>exponent != 1</b> to the class\n+     * @param numericPredictor\n+     * @param evaluateTemplateClass\n+     * @return\n+     */\n+    private static MethodDeclaration getNumericPredictorWithExponentTemplate(final NumericPredictor numericPredictor, final ClassOrInterfaceDeclaration evaluateTemplateClass) {\n+        final MethodDeclaration toReturn = evaluateTemplateClass.getMethodsByName(\"evaluateNumericWithExponent\").get(0);\n+        toReturn.getBody().ifPresent(body -> {\n+            final List<VariableDeclarator> variableDeclarators = body.findAll(VariableDeclarator.class);\n+            variableDeclarators.forEach(variableDeclarator -> {\n+                String initializer = null;\n+                if (variableDeclarator.getName().asString().equals(COEFFICIENT)) {\n+                    initializer = String.valueOf(numericPredictor.getCoefficient().doubleValue());\n+                } else if (variableDeclarator.getName().asString().equals(EXPONENT)) {\n+                    initializer = String.valueOf(numericPredictor.getExponent().doubleValue());\n+                }\n+                if (initializer != null) {\n+                    variableDeclarator.setInitializer(initializer);\n+                }\n+            });\n+        });\n+        return toReturn;\n+    }\n+\n+    /**\n+     * Add a <b>NumericPredictor</b> <code>MethodDeclaration</code> with <b>exponent == 1</b> to the class\n+     * @param numericPredictor\n+     * @param evaluateTemplateClass\n+     * @return\n+     */\n+    private static MethodDeclaration getNumericPredictorWithoutExponentTemplate(final NumericPredictor numericPredictor, final ClassOrInterfaceDeclaration evaluateTemplateClass) {\n+        final MethodDeclaration toReturn = evaluateTemplateClass.getMethodsByName(\"evaluateNumericWithoutExponent\").get(0);\n+        toReturn.getBody().ifPresent(body -> {\n+            final List<VariableDeclarator> variableDeclarators = body.findAll(VariableDeclarator.class);\n+            variableDeclarators.stream().filter(variableDeclarator -> variableDeclarator.getName().asString().equals(COEFFICIENT))\n+                    .forEach(variableDeclarator -> variableDeclarator.setInitializer(String.valueOf(numericPredictor.getCoefficient().doubleValue())));\n+        });\n+        return toReturn;\n+    }\n+\n+    /**\n+     * Add <b>CategoricalPredictor</b>s <code>MethodDeclaration</code> to the class\n+     * @param categoricalPredictors\n+     * @param tableTemplate\n+     * @return\n+     */\n+    private static Map<String, MethodDeclaration> addCategoricalPredictors(final List<CategoricalPredictor> categoricalPredictors, final ClassOrInterfaceDeclaration tableTemplate) {\n+        predictorsArity.set(0);\n+        final Map<String, List<CategoricalPredictor>> groupedCollectors = categoricalPredictors.stream()\n+                .collect(groupingBy(categoricalPredictor -> categoricalPredictor.getField().getValue()));\n+        return groupedCollectors.entrySet().stream()\n+                .map(entry -> new AbstractMap.SimpleEntry<>(entry.getKey(),\n+                                                            addGroupedCategoricalPredictor(entry.getValue(), tableTemplate, predictorsArity.addAndGet(1))))\n+                .filter(entry -> entry.getValue().isPresent())\n+                .collect(Collectors.toMap(AbstractMap.SimpleEntry::getKey,\n+                                          entry -> entry.getValue().get()));\n+    }\n+\n+    /**\n+     * Add a <b>CategoricalPredictor</b> <code>MethodDeclaration</code> to the class\n+     * @param categoricalPredictors\n+     * @param tableTemplate\n+     * @param predictorArity\n+     * @return\n+     */\n+    private static Optional<MethodDeclaration> addGroupedCategoricalPredictor(final List<CategoricalPredictor> categoricalPredictors, final ClassOrInterfaceDeclaration tableTemplate, int predictorArity) {\n+        try {\n+            templateEvaluate = StaticJavaParser.parseResource(KIE_PMML_EVALUATE_METHOD_TEMPLATE_JAVA);\n+            cloneEvaluate = templateEvaluate.clone();\n+            ClassOrInterfaceDeclaration evaluateTemplateClass = cloneEvaluate.getClassByName(KIE_PMML_EVALUATE_METHOD_TEMPLATE)\n+                    .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+            MethodDeclaration methodTemplate = evaluateTemplateClass.getMethodsByName(\"evaluateCategorical\").get(0);\n+            methodTemplate.getBody().ifPresent(body -> {\n+                IfStmt ifStmt = new IfStmt();\n+                for (int i = 0; i < categoricalPredictors.size(); i++) {\n+                    CategoricalPredictor categoricalPredictor = categoricalPredictors.get(i);\n+                    Expression lhe;\n+                    if (categoricalPredictor.getValue() instanceof String) {\n+                        lhe = new StringLiteralExpr((String) categoricalPredictor.getValue());\n+                    } else {\n+                        lhe = new NameExpr(categoricalPredictor.getValue().toString());\n+                    }\n+                    NodeList<Expression> expressions = NodeList.nodeList(lhe, new NameExpr(\"input\"));\n+                    MethodCallExpr conditionExpr = new MethodCallExpr(new NameExpr(\"Objects\"), \"equals\", expressions);\n+                    if (i == 0) {\n+                        ifStmt.setCondition(conditionExpr);\n+                        ifStmt.setThenStmt(new ReturnStmt(new DoubleLiteralExpr(String.valueOf(categoricalPredictor.getCoefficient()))));\n+                        body.addStatement(ifStmt);\n+                    } else {\n+                        IfStmt elseIf = new IfStmt();\n+                        elseIf.setCondition(conditionExpr);\n+                        elseIf.setThenStmt(new ReturnStmt(new DoubleLiteralExpr(String.valueOf(categoricalPredictor.getCoefficient()))));\n+                        ifStmt.setElseStmt(elseIf);\n+                        ifStmt = elseIf;\n+                    }\n+                }\n+                ifStmt.setElseStmt(new ReturnStmt(new DoubleLiteralExpr(\"0.0\")));\n+            });\n+            return addMethod(methodTemplate, tableTemplate, \"evaluateCategoricalPredictor\" + predictorArity);\n+        } catch (Exception e) {\n+            //", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA5NDM4NA=="}, "originalCommit": {"oid": "3c4a838980a18a8428b253ee431087beb471fe8d"}, "originalPosition": 290}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDExMDQyOnYy", "diffSide": "RIGHT", "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/main/java/org/kie/pmml/models/regression/compiler/factories/KiePMMLRegressionTableRegressionFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwODo0NDoxOVrOF17jOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMToxMzozN1rOF1_8Tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA5NDUyMA==", "bodyText": "Are you sure this could happen? We are working with a template created by us", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r392094520", "createdAt": "2020-03-13T08:44:19Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/main/java/org/kie/pmml/models/regression/compiler/factories/KiePMMLRegressionTableRegressionFactory.java", "diffHunk": "@@ -0,0 +1,410 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.compiler.factories;\n+\n+import java.io.IOException;\n+import java.util.AbstractMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.DoubleLiteralExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.MethodReferenceExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.expr.ThisExpr;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.IfStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import org.dmg.pmml.regression.CategoricalPredictor;\n+import org.dmg.pmml.regression.NumericPredictor;\n+import org.dmg.pmml.regression.PredictorTerm;\n+import org.dmg.pmml.regression.RegressionModel;\n+import org.dmg.pmml.regression.RegressionTable;\n+import org.kie.pmml.models.regression.model.tuples.KiePMMLTableSourceCategory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+\n+public class KiePMMLRegressionTableRegressionFactory {\n+\n+    public static final String KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE_JAVA = \"KiePMMLRegressionTableRegressionTemplate.tmpl\";\n+    private static final Logger logger = LoggerFactory.getLogger(KiePMMLRegressionTableRegressionFactory.class.getName());\n+    private static final String MAIN_CLASS_NOT_FOUND = \"Main class not found\";\n+    private static final String KIE_PMML_EVALUATE_METHOD_TEMPLATE_JAVA = \"KiePMMLEvaluateMethodTemplate.tmpl\";\n+    private static final String KIE_PMML_EVALUATE_METHOD_TEMPLATE = \"KiePMMLEvaluateMethodTemplate\";\n+    private static final String KIE_PMML_UPDATE_RESULT_METHOD_TEMPLATE_JAVA = \"KiePMMLUpdateResultMethodTemplate.tmpl\";\n+    private static final String KIE_PMML_UPDATE_RESULT_METHOD_TEMPLATE = \"KiePMMLUpdateResultMethodTemplate\";\n+    private static final String KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE = \"KiePMMLRegressionTableRegressionTemplate\";\n+    private static final String COEFFICIENT = \"coefficient\";\n+    private static final String EXPONENT = \"exponent\";\n+    private static AtomicInteger classArity = new AtomicInteger(0);\n+    private static AtomicInteger predictorsArity = new AtomicInteger(0);\n+    private static CompilationUnit templateEvaluate;\n+    private static CompilationUnit cloneEvaluate;\n+\n+    private KiePMMLRegressionTableRegressionFactory() {\n+        // Avoid instantiation\n+    }\n+\n+    public static Map<String, KiePMMLTableSourceCategory> getRegressionTables(final List<RegressionTable> regressionTables, final RegressionModel.NormalizationMethod normalizationMethod, final String targetField) throws IOException {\n+        logger.debug(\"getRegressionTables {}\", regressionTables);\n+        CompilationUnit templateCU = StaticJavaParser.parseResource(KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE_JAVA);\n+        Map<String, KiePMMLTableSourceCategory> toReturn = new HashMap<>();\n+        for (RegressionTable regressionTable : regressionTables) {\n+            final Map.Entry<String, String> regressionTableEntry = getRegressionTable(templateCU, regressionTable, normalizationMethod, targetField);\n+            String targetCategory = regressionTable.getTargetCategory() != null ? regressionTable.getTargetCategory().toString() : \"\";\n+            toReturn.put(regressionTableEntry.getKey(), new KiePMMLTableSourceCategory(regressionTableEntry.getValue(), targetCategory));\n+        }\n+        return toReturn;\n+    }\n+\n+    public static AbstractMap.Entry<String, String> getRegressionTable(final CompilationUnit templateCU, final RegressionTable regressionTable, final RegressionModel.NormalizationMethod normalizationMethod, final String targetField) {\n+        logger.debug(\"getRegressionTable {}\", regressionTable);\n+        CompilationUnit cloneCU = templateCU.clone();\n+        ClassOrInterfaceDeclaration tableTemplate = cloneCU.getClassByName(KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE)\n+                .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+        String className = \"KiePMMLRegressionTableRegression\" + classArity.addAndGet(1);\n+        tableTemplate.setName(className);\n+        setConstructor(regressionTable, tableTemplate, targetField);\n+        final Map<String, MethodDeclaration> numericPredictorsMap = addNumericPredictors(regressionTable.getNumericPredictors(), tableTemplate);\n+        final Map<String, MethodDeclaration> categoricalPredictorsMap = addCategoricalPredictors(regressionTable.getCategoricalPredictors(), tableTemplate);\n+        final Map<String, MethodDeclaration> predictorTermsMap = addPredictorTerms(regressionTable.getPredictorTerms(), tableTemplate);\n+        tableTemplate.getDefaultConstructor().ifPresent(constructorDeclaration -> {\n+            final BlockStmt body = constructorDeclaration.getBody();\n+            addMapPopulation(numericPredictorsMap, body, \"numericFunctionMap\");\n+            addMapPopulation(categoricalPredictorsMap, body, \"categoricalFunctionMap\");\n+            addMapPopulation(predictorTermsMap, body, \"predictorTermsFunctionMap\");\n+        });\n+        populateGetTargetCategory(tableTemplate, regressionTable.getTargetCategory());\n+        populateUpdateResult(tableTemplate, normalizationMethod);\n+        return new AbstractMap.SimpleEntry<>(className, cloneCU.toString());\n+    }\n+\n+    /**\n+     * Add entries <b>fieldName/function</b> inside the constructor\n+     * @param toAdd\n+     * @param body\n+     * @param mapName\n+     */\n+    private static void addMapPopulation(final Map<String, MethodDeclaration> toAdd, final BlockStmt body, final String mapName) {\n+        toAdd.forEach((s, methodDeclaration) -> {\n+            MethodReferenceExpr methodReferenceExpr = new MethodReferenceExpr();\n+            methodReferenceExpr.setScope(new ThisExpr());\n+            methodReferenceExpr.setIdentifier(methodDeclaration.getNameAsString());\n+            NodeList<Expression> expressions = NodeList.nodeList(new StringLiteralExpr(s), methodReferenceExpr);\n+            body.addStatement(new MethodCallExpr(new NameExpr(mapName), \"put\", expressions));\n+        });\n+    }\n+\n+    /**\n+     * Set the <b>intercept</b> and <b>targetField</b> values inside the constructor\n+     * @param regressionTable\n+     * @param tableTemplate\n+     * @param targetField\n+     */\n+    private static void setConstructor(final RegressionTable regressionTable, final ClassOrInterfaceDeclaration tableTemplate, final String targetField) {\n+        tableTemplate.getDefaultConstructor().ifPresent(constructorDeclaration -> {\n+            constructorDeclaration.setName(tableTemplate.getName());\n+            final BlockStmt body = constructorDeclaration.getBody();\n+            final List<AssignExpr> assignExprs = body.findAll(AssignExpr.class);\n+            assignExprs.forEach(assignExpr -> {\n+                if (assignExpr.getTarget().asNameExpr().getNameAsString().equals(\"intercept\")) {\n+                    assignExpr.setValue(new DoubleLiteralExpr(String.valueOf(regressionTable.getIntercept().doubleValue())));\n+                } else if (assignExpr.getTarget().asNameExpr().getNameAsString().equals(\"targetField\")) {\n+                    assignExpr.setValue(new StringLiteralExpr(targetField));\n+                }\n+            });\n+        });\n+    }\n+\n+    /**\n+     * Add <b>NumericPredictor</b>s <code>MethodDeclaration</code> to the class\n+     * @param numericPredictors\n+     * @param tableTemplate\n+     * @return\n+     */\n+    private static Map<String, MethodDeclaration> addNumericPredictors(final List<NumericPredictor> numericPredictors, final ClassOrInterfaceDeclaration tableTemplate) {\n+        predictorsArity.set(0);\n+        return numericPredictors.stream()\n+                .map(numericPredictor -> new AbstractMap.SimpleEntry<>(numericPredictor.getName().getValue(),\n+                                                                       addNumericPredictor(numericPredictor, tableTemplate, predictorsArity.addAndGet(1))))\n+                .filter(entry -> entry.getValue().isPresent())\n+                .collect(Collectors.toMap(AbstractMap.SimpleEntry::getKey,\n+                                          entry -> entry.getValue().get()));\n+    }\n+\n+    /**\n+     * Add a <b>NumericPredictor</b> <code>MethodDeclaration</code> to the class\n+     * @param numericPredictor\n+     * @param tableTemplate\n+     * @param predictorArity\n+     * @return\n+     */\n+    private static Optional<MethodDeclaration> addNumericPredictor(final NumericPredictor numericPredictor, final ClassOrInterfaceDeclaration tableTemplate, int predictorArity) {\n+        try {\n+            templateEvaluate = StaticJavaParser.parseResource(KIE_PMML_EVALUATE_METHOD_TEMPLATE_JAVA);\n+            cloneEvaluate = templateEvaluate.clone();\n+            ClassOrInterfaceDeclaration evaluateTemplateClass = cloneEvaluate.getClassByName(KIE_PMML_EVALUATE_METHOD_TEMPLATE)\n+                    .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+            MethodDeclaration methodTemplate;\n+            if (Objects.equals(1, numericPredictor.getExponent())) {\n+                methodTemplate = getNumericPredictorWithoutExponentTemplate(numericPredictor, evaluateTemplateClass);\n+            } else {\n+                methodTemplate = getNumericPredictorWithExponentTemplate(numericPredictor, evaluateTemplateClass);\n+            }\n+            return addMethod(methodTemplate, tableTemplate, \"evaluateNumericPredictor\" + predictorArity);\n+        } catch (Exception e) {\n+            return Optional.empty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c4a838980a18a8428b253ee431087beb471fe8d"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE2NjQ3OQ==", "bodyText": "@danielezonca\nSee above...", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r392166479", "createdAt": "2020-03-13T11:13:37Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/main/java/org/kie/pmml/models/regression/compiler/factories/KiePMMLRegressionTableRegressionFactory.java", "diffHunk": "@@ -0,0 +1,410 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.compiler.factories;\n+\n+import java.io.IOException;\n+import java.util.AbstractMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.DoubleLiteralExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.MethodReferenceExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.expr.ThisExpr;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.IfStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import org.dmg.pmml.regression.CategoricalPredictor;\n+import org.dmg.pmml.regression.NumericPredictor;\n+import org.dmg.pmml.regression.PredictorTerm;\n+import org.dmg.pmml.regression.RegressionModel;\n+import org.dmg.pmml.regression.RegressionTable;\n+import org.kie.pmml.models.regression.model.tuples.KiePMMLTableSourceCategory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+\n+public class KiePMMLRegressionTableRegressionFactory {\n+\n+    public static final String KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE_JAVA = \"KiePMMLRegressionTableRegressionTemplate.tmpl\";\n+    private static final Logger logger = LoggerFactory.getLogger(KiePMMLRegressionTableRegressionFactory.class.getName());\n+    private static final String MAIN_CLASS_NOT_FOUND = \"Main class not found\";\n+    private static final String KIE_PMML_EVALUATE_METHOD_TEMPLATE_JAVA = \"KiePMMLEvaluateMethodTemplate.tmpl\";\n+    private static final String KIE_PMML_EVALUATE_METHOD_TEMPLATE = \"KiePMMLEvaluateMethodTemplate\";\n+    private static final String KIE_PMML_UPDATE_RESULT_METHOD_TEMPLATE_JAVA = \"KiePMMLUpdateResultMethodTemplate.tmpl\";\n+    private static final String KIE_PMML_UPDATE_RESULT_METHOD_TEMPLATE = \"KiePMMLUpdateResultMethodTemplate\";\n+    private static final String KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE = \"KiePMMLRegressionTableRegressionTemplate\";\n+    private static final String COEFFICIENT = \"coefficient\";\n+    private static final String EXPONENT = \"exponent\";\n+    private static AtomicInteger classArity = new AtomicInteger(0);\n+    private static AtomicInteger predictorsArity = new AtomicInteger(0);\n+    private static CompilationUnit templateEvaluate;\n+    private static CompilationUnit cloneEvaluate;\n+\n+    private KiePMMLRegressionTableRegressionFactory() {\n+        // Avoid instantiation\n+    }\n+\n+    public static Map<String, KiePMMLTableSourceCategory> getRegressionTables(final List<RegressionTable> regressionTables, final RegressionModel.NormalizationMethod normalizationMethod, final String targetField) throws IOException {\n+        logger.debug(\"getRegressionTables {}\", regressionTables);\n+        CompilationUnit templateCU = StaticJavaParser.parseResource(KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE_JAVA);\n+        Map<String, KiePMMLTableSourceCategory> toReturn = new HashMap<>();\n+        for (RegressionTable regressionTable : regressionTables) {\n+            final Map.Entry<String, String> regressionTableEntry = getRegressionTable(templateCU, regressionTable, normalizationMethod, targetField);\n+            String targetCategory = regressionTable.getTargetCategory() != null ? regressionTable.getTargetCategory().toString() : \"\";\n+            toReturn.put(regressionTableEntry.getKey(), new KiePMMLTableSourceCategory(regressionTableEntry.getValue(), targetCategory));\n+        }\n+        return toReturn;\n+    }\n+\n+    public static AbstractMap.Entry<String, String> getRegressionTable(final CompilationUnit templateCU, final RegressionTable regressionTable, final RegressionModel.NormalizationMethod normalizationMethod, final String targetField) {\n+        logger.debug(\"getRegressionTable {}\", regressionTable);\n+        CompilationUnit cloneCU = templateCU.clone();\n+        ClassOrInterfaceDeclaration tableTemplate = cloneCU.getClassByName(KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE)\n+                .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+        String className = \"KiePMMLRegressionTableRegression\" + classArity.addAndGet(1);\n+        tableTemplate.setName(className);\n+        setConstructor(regressionTable, tableTemplate, targetField);\n+        final Map<String, MethodDeclaration> numericPredictorsMap = addNumericPredictors(regressionTable.getNumericPredictors(), tableTemplate);\n+        final Map<String, MethodDeclaration> categoricalPredictorsMap = addCategoricalPredictors(regressionTable.getCategoricalPredictors(), tableTemplate);\n+        final Map<String, MethodDeclaration> predictorTermsMap = addPredictorTerms(regressionTable.getPredictorTerms(), tableTemplate);\n+        tableTemplate.getDefaultConstructor().ifPresent(constructorDeclaration -> {\n+            final BlockStmt body = constructorDeclaration.getBody();\n+            addMapPopulation(numericPredictorsMap, body, \"numericFunctionMap\");\n+            addMapPopulation(categoricalPredictorsMap, body, \"categoricalFunctionMap\");\n+            addMapPopulation(predictorTermsMap, body, \"predictorTermsFunctionMap\");\n+        });\n+        populateGetTargetCategory(tableTemplate, regressionTable.getTargetCategory());\n+        populateUpdateResult(tableTemplate, normalizationMethod);\n+        return new AbstractMap.SimpleEntry<>(className, cloneCU.toString());\n+    }\n+\n+    /**\n+     * Add entries <b>fieldName/function</b> inside the constructor\n+     * @param toAdd\n+     * @param body\n+     * @param mapName\n+     */\n+    private static void addMapPopulation(final Map<String, MethodDeclaration> toAdd, final BlockStmt body, final String mapName) {\n+        toAdd.forEach((s, methodDeclaration) -> {\n+            MethodReferenceExpr methodReferenceExpr = new MethodReferenceExpr();\n+            methodReferenceExpr.setScope(new ThisExpr());\n+            methodReferenceExpr.setIdentifier(methodDeclaration.getNameAsString());\n+            NodeList<Expression> expressions = NodeList.nodeList(new StringLiteralExpr(s), methodReferenceExpr);\n+            body.addStatement(new MethodCallExpr(new NameExpr(mapName), \"put\", expressions));\n+        });\n+    }\n+\n+    /**\n+     * Set the <b>intercept</b> and <b>targetField</b> values inside the constructor\n+     * @param regressionTable\n+     * @param tableTemplate\n+     * @param targetField\n+     */\n+    private static void setConstructor(final RegressionTable regressionTable, final ClassOrInterfaceDeclaration tableTemplate, final String targetField) {\n+        tableTemplate.getDefaultConstructor().ifPresent(constructorDeclaration -> {\n+            constructorDeclaration.setName(tableTemplate.getName());\n+            final BlockStmt body = constructorDeclaration.getBody();\n+            final List<AssignExpr> assignExprs = body.findAll(AssignExpr.class);\n+            assignExprs.forEach(assignExpr -> {\n+                if (assignExpr.getTarget().asNameExpr().getNameAsString().equals(\"intercept\")) {\n+                    assignExpr.setValue(new DoubleLiteralExpr(String.valueOf(regressionTable.getIntercept().doubleValue())));\n+                } else if (assignExpr.getTarget().asNameExpr().getNameAsString().equals(\"targetField\")) {\n+                    assignExpr.setValue(new StringLiteralExpr(targetField));\n+                }\n+            });\n+        });\n+    }\n+\n+    /**\n+     * Add <b>NumericPredictor</b>s <code>MethodDeclaration</code> to the class\n+     * @param numericPredictors\n+     * @param tableTemplate\n+     * @return\n+     */\n+    private static Map<String, MethodDeclaration> addNumericPredictors(final List<NumericPredictor> numericPredictors, final ClassOrInterfaceDeclaration tableTemplate) {\n+        predictorsArity.set(0);\n+        return numericPredictors.stream()\n+                .map(numericPredictor -> new AbstractMap.SimpleEntry<>(numericPredictor.getName().getValue(),\n+                                                                       addNumericPredictor(numericPredictor, tableTemplate, predictorsArity.addAndGet(1))))\n+                .filter(entry -> entry.getValue().isPresent())\n+                .collect(Collectors.toMap(AbstractMap.SimpleEntry::getKey,\n+                                          entry -> entry.getValue().get()));\n+    }\n+\n+    /**\n+     * Add a <b>NumericPredictor</b> <code>MethodDeclaration</code> to the class\n+     * @param numericPredictor\n+     * @param tableTemplate\n+     * @param predictorArity\n+     * @return\n+     */\n+    private static Optional<MethodDeclaration> addNumericPredictor(final NumericPredictor numericPredictor, final ClassOrInterfaceDeclaration tableTemplate, int predictorArity) {\n+        try {\n+            templateEvaluate = StaticJavaParser.parseResource(KIE_PMML_EVALUATE_METHOD_TEMPLATE_JAVA);\n+            cloneEvaluate = templateEvaluate.clone();\n+            ClassOrInterfaceDeclaration evaluateTemplateClass = cloneEvaluate.getClassByName(KIE_PMML_EVALUATE_METHOD_TEMPLATE)\n+                    .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+            MethodDeclaration methodTemplate;\n+            if (Objects.equals(1, numericPredictor.getExponent())) {\n+                methodTemplate = getNumericPredictorWithoutExponentTemplate(numericPredictor, evaluateTemplateClass);\n+            } else {\n+                methodTemplate = getNumericPredictorWithExponentTemplate(numericPredictor, evaluateTemplateClass);\n+            }\n+            return addMethod(methodTemplate, tableTemplate, \"evaluateNumericPredictor\" + predictorArity);\n+        } catch (Exception e) {\n+            return Optional.empty();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA5NDUyMA=="}, "originalCommit": {"oid": "3c4a838980a18a8428b253ee431087beb471fe8d"}, "originalPosition": 185}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDEzNDg4OnYy", "diffSide": "RIGHT", "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-model/src/main/java/org/kie/pmml/models/regression/model/KiePMMLRegressionTable.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwODo1MjoyNFrOF17x_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMToxMzozMlrOF1_8Lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA5ODMwMw==", "bodyText": "Is this method optional?", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r392098303", "createdAt": "2020-03-13T08:52:24Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-model/src/main/java/org/kie/pmml/models/regression/model/KiePMMLRegressionTable.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.model;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+public abstract class KiePMMLRegressionTable {\n+\n+    protected Map<String, Function<Double, Double>> numericFunctionMap = new HashMap<>();\n+    protected Map<String, Function<Object, Double>> categoricalFunctionMap = new HashMap<>();\n+    protected Map<String, Function<Map<String, Object>, Double>> predictorTermsFunctionMap = new HashMap<>();\n+    protected double intercept;\n+    protected String targetField;\n+\n+    public abstract Object getTargetCategory();\n+\n+    public Object evaluateRegression(Map<String, Object> input) {\n+        final AtomicReference<Double> result = new AtomicReference<>(intercept);\n+        final Map<String, Double> resultMap = new HashMap<>();\n+        for (Map.Entry<String, Function<Double, Double>> entry : numericFunctionMap.entrySet()) {\n+            String key = entry.getKey();\n+            if (input.containsKey(key)) {\n+                resultMap.put(key, entry.getValue().apply(((Number) input.get(key)).doubleValue()));\n+            }\n+        }\n+        for (Map.Entry<String, Function<Object, Double>> entry : categoricalFunctionMap.entrySet()) {\n+            String key = entry.getKey();\n+            if (input.containsKey(key)) {\n+                resultMap.put(key, entry.getValue().apply(input.get(key)));\n+            }\n+        }\n+        for (Map.Entry<String, Function<Map<String, Object>, Double>> entry : predictorTermsFunctionMap.entrySet()) {\n+            resultMap.put(entry.getKey(), entry.getValue().apply(input));\n+        }\n+        resultMap.values().forEach(value -> result.accumulateAndGet(value, Double::sum));\n+        updateResult(result);\n+        return result.get();\n+    }\n+\n+    public Map<String, Object> getOutputFieldsMap() {\n+        return new HashMap<>();\n+    }\n+\n+    public String getTargetField() {\n+        return targetField;\n+    }\n+\n+    public Map<String, Function<Double, Double>> getNumericFunctionMap() {\n+        return numericFunctionMap;\n+    }\n+\n+    public Map<String, Function<Object, Double>> getCategoricalFunctionMap() {\n+        return categoricalFunctionMap;\n+    }\n+\n+    public Map<String, Function<Map<String, Object>, Double>> getPredictorTermsFunctionMap() {\n+        return predictorTermsFunctionMap;\n+    }\n+\n+    public double getIntercept() {\n+        return intercept;\n+    }\n+\n+    protected void updateResult(final AtomicReference<Double> toUpdate) {\n+        // NONE", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c4a838980a18a8428b253ee431087beb471fe8d"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE2NjQ0Ng==", "bodyText": "@danielezonca\nIs not used inside ClassificationTable; but since this latter extends RegressionTable, I kept empty implementation in ClassificationTable and changed to abstract in RegressionTable", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r392166446", "createdAt": "2020-03-13T11:13:32Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-model/src/main/java/org/kie/pmml/models/regression/model/KiePMMLRegressionTable.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.model;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+public abstract class KiePMMLRegressionTable {\n+\n+    protected Map<String, Function<Double, Double>> numericFunctionMap = new HashMap<>();\n+    protected Map<String, Function<Object, Double>> categoricalFunctionMap = new HashMap<>();\n+    protected Map<String, Function<Map<String, Object>, Double>> predictorTermsFunctionMap = new HashMap<>();\n+    protected double intercept;\n+    protected String targetField;\n+\n+    public abstract Object getTargetCategory();\n+\n+    public Object evaluateRegression(Map<String, Object> input) {\n+        final AtomicReference<Double> result = new AtomicReference<>(intercept);\n+        final Map<String, Double> resultMap = new HashMap<>();\n+        for (Map.Entry<String, Function<Double, Double>> entry : numericFunctionMap.entrySet()) {\n+            String key = entry.getKey();\n+            if (input.containsKey(key)) {\n+                resultMap.put(key, entry.getValue().apply(((Number) input.get(key)).doubleValue()));\n+            }\n+        }\n+        for (Map.Entry<String, Function<Object, Double>> entry : categoricalFunctionMap.entrySet()) {\n+            String key = entry.getKey();\n+            if (input.containsKey(key)) {\n+                resultMap.put(key, entry.getValue().apply(input.get(key)));\n+            }\n+        }\n+        for (Map.Entry<String, Function<Map<String, Object>, Double>> entry : predictorTermsFunctionMap.entrySet()) {\n+            resultMap.put(entry.getKey(), entry.getValue().apply(input));\n+        }\n+        resultMap.values().forEach(value -> result.accumulateAndGet(value, Double::sum));\n+        updateResult(result);\n+        return result.get();\n+    }\n+\n+    public Map<String, Object> getOutputFieldsMap() {\n+        return new HashMap<>();\n+    }\n+\n+    public String getTargetField() {\n+        return targetField;\n+    }\n+\n+    public Map<String, Function<Double, Double>> getNumericFunctionMap() {\n+        return numericFunctionMap;\n+    }\n+\n+    public Map<String, Function<Object, Double>> getCategoricalFunctionMap() {\n+        return categoricalFunctionMap;\n+    }\n+\n+    public Map<String, Function<Map<String, Object>, Double>> getPredictorTermsFunctionMap() {\n+        return predictorTermsFunctionMap;\n+    }\n+\n+    public double getIntercept() {\n+        return intercept;\n+    }\n+\n+    protected void updateResult(final AtomicReference<Double> toUpdate) {\n+        // NONE", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA5ODMwMw=="}, "originalCommit": {"oid": "3c4a838980a18a8428b253ee431087beb471fe8d"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDIzMjE5OnYy", "diffSide": "RIGHT", "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-model/src/main/java/org/kie/pmml/models/regression/model/KiePMMLRegressionClassificationTable.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwOToyNTo0NFrOF18vEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMToxMzoyOFrOF1_8GA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjExMzkzNw==", "bodyText": "Is it optional?", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r392113937", "createdAt": "2020-03-13T09:25:44Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-model/src/main/java/org/kie/pmml/models/regression/model/KiePMMLRegressionClassificationTable.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.model;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.DoubleUnaryOperator;\n+\n+import org.kie.pmml.commons.exceptions.KiePMMLException;\n+import org.kie.pmml.commons.model.KiePMMLOutputField;\n+import org.kie.pmml.commons.model.enums.OP_TYPE;\n+import org.kie.pmml.models.regression.model.enums.REGRESSION_NORMALIZATION_METHOD;\n+\n+import static org.kie.pmml.commons.Constants.EXPECTED_TWO_ENTRIES_RETRIEVED;\n+\n+public abstract class KiePMMLRegressionClassificationTable extends KiePMMLRegressionTable {\n+\n+    protected REGRESSION_NORMALIZATION_METHOD regressionNormalizationMethod;\n+    protected OP_TYPE opType;\n+    protected List<KiePMMLOutputField> outputFields = new ArrayList<>();\n+    protected Map<String, Object> outputFieldsMap = new HashMap<>();\n+    protected Map<String, KiePMMLRegressionTable> categoryTableMap = new HashMap<>();\n+\n+    public Object evaluateRegression(Map<String, Object> input) {\n+        final LinkedHashMap<String, Double> resultMap = new LinkedHashMap<>();\n+        for (Map.Entry<String, KiePMMLRegressionTable> entry : categoryTableMap.entrySet()) {\n+            resultMap.put(entry.getKey(), (Double) entry.getValue().evaluateRegression(input));\n+        }\n+        final LinkedHashMap<String, Double> probabilityMap = getProbabilityMap(resultMap);\n+        final Map.Entry<String, Double> predictedEntry = Collections.max(probabilityMap.entrySet(), Map.Entry.comparingByValue());\n+        probabilityMap.put(targetField, predictedEntry.getValue());\n+        populateOutputFieldsMap(predictedEntry, probabilityMap);\n+        outputFieldsMap.put(targetField, predictedEntry.getKey());\n+        return predictedEntry.getKey();\n+    }\n+\n+    public abstract boolean isBinary();/* {\n+        return Objects.equals(OP_TYPE.CATEGORICAL, targetOpType) && (targetValues != null && targetValues.size() == 2);\n+    }*/\n+\n+    protected abstract LinkedHashMap<String, Double> getProbabilityMap(final LinkedHashMap<String, Double> resultMap);\n+\n+    protected abstract void populateOutputFieldsMap(final Map.Entry<String, Double> predictedEntry, final LinkedHashMap<String, Double> probabilityMap);\n+\n+    protected void updateResult(final AtomicReference<Double> toUpdate) {\n+        // NOOP", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c4a838980a18a8428b253ee431087beb471fe8d"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE2NjQyNA==", "bodyText": "@danielezonca\nSee above", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r392166424", "createdAt": "2020-03-13T11:13:28Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-model/src/main/java/org/kie/pmml/models/regression/model/KiePMMLRegressionClassificationTable.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.model;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.DoubleUnaryOperator;\n+\n+import org.kie.pmml.commons.exceptions.KiePMMLException;\n+import org.kie.pmml.commons.model.KiePMMLOutputField;\n+import org.kie.pmml.commons.model.enums.OP_TYPE;\n+import org.kie.pmml.models.regression.model.enums.REGRESSION_NORMALIZATION_METHOD;\n+\n+import static org.kie.pmml.commons.Constants.EXPECTED_TWO_ENTRIES_RETRIEVED;\n+\n+public abstract class KiePMMLRegressionClassificationTable extends KiePMMLRegressionTable {\n+\n+    protected REGRESSION_NORMALIZATION_METHOD regressionNormalizationMethod;\n+    protected OP_TYPE opType;\n+    protected List<KiePMMLOutputField> outputFields = new ArrayList<>();\n+    protected Map<String, Object> outputFieldsMap = new HashMap<>();\n+    protected Map<String, KiePMMLRegressionTable> categoryTableMap = new HashMap<>();\n+\n+    public Object evaluateRegression(Map<String, Object> input) {\n+        final LinkedHashMap<String, Double> resultMap = new LinkedHashMap<>();\n+        for (Map.Entry<String, KiePMMLRegressionTable> entry : categoryTableMap.entrySet()) {\n+            resultMap.put(entry.getKey(), (Double) entry.getValue().evaluateRegression(input));\n+        }\n+        final LinkedHashMap<String, Double> probabilityMap = getProbabilityMap(resultMap);\n+        final Map.Entry<String, Double> predictedEntry = Collections.max(probabilityMap.entrySet(), Map.Entry.comparingByValue());\n+        probabilityMap.put(targetField, predictedEntry.getValue());\n+        populateOutputFieldsMap(predictedEntry, probabilityMap);\n+        outputFieldsMap.put(targetField, predictedEntry.getKey());\n+        return predictedEntry.getKey();\n+    }\n+\n+    public abstract boolean isBinary();/* {\n+        return Objects.equals(OP_TYPE.CATEGORICAL, targetOpType) && (targetValues != null && targetValues.size() == 2);\n+    }*/\n+\n+    protected abstract LinkedHashMap<String, Double> getProbabilityMap(final LinkedHashMap<String, Double> resultMap);\n+\n+    protected abstract void populateOutputFieldsMap(final Map.Entry<String, Double> predictedEntry, final LinkedHashMap<String, Double> probabilityMap);\n+\n+    protected void updateResult(final AtomicReference<Double> toUpdate) {\n+        // NOOP", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjExMzkzNw=="}, "originalCommit": {"oid": "3c4a838980a18a8428b253ee431087beb471fe8d"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDIzNTc2OnYy", "diffSide": "RIGHT", "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-model/src/main/java/org/kie/pmml/models/regression/model/KiePMMLRegressionClassificationTable.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwOToyNjo1N1rOF18xVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMToxMzoyNFrOF1_8AA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjExNDUxOQ==", "bodyText": "Can you remove the comment?", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r392114519", "createdAt": "2020-03-13T09:26:57Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-model/src/main/java/org/kie/pmml/models/regression/model/KiePMMLRegressionClassificationTable.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.model;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.DoubleUnaryOperator;\n+\n+import org.kie.pmml.commons.exceptions.KiePMMLException;\n+import org.kie.pmml.commons.model.KiePMMLOutputField;\n+import org.kie.pmml.commons.model.enums.OP_TYPE;\n+import org.kie.pmml.models.regression.model.enums.REGRESSION_NORMALIZATION_METHOD;\n+\n+import static org.kie.pmml.commons.Constants.EXPECTED_TWO_ENTRIES_RETRIEVED;\n+\n+public abstract class KiePMMLRegressionClassificationTable extends KiePMMLRegressionTable {\n+\n+    protected REGRESSION_NORMALIZATION_METHOD regressionNormalizationMethod;\n+    protected OP_TYPE opType;\n+    protected List<KiePMMLOutputField> outputFields = new ArrayList<>();\n+    protected Map<String, Object> outputFieldsMap = new HashMap<>();\n+    protected Map<String, KiePMMLRegressionTable> categoryTableMap = new HashMap<>();\n+\n+    public Object evaluateRegression(Map<String, Object> input) {\n+        final LinkedHashMap<String, Double> resultMap = new LinkedHashMap<>();\n+        for (Map.Entry<String, KiePMMLRegressionTable> entry : categoryTableMap.entrySet()) {\n+            resultMap.put(entry.getKey(), (Double) entry.getValue().evaluateRegression(input));\n+        }\n+        final LinkedHashMap<String, Double> probabilityMap = getProbabilityMap(resultMap);\n+        final Map.Entry<String, Double> predictedEntry = Collections.max(probabilityMap.entrySet(), Map.Entry.comparingByValue());\n+        probabilityMap.put(targetField, predictedEntry.getValue());\n+        populateOutputFieldsMap(predictedEntry, probabilityMap);\n+        outputFieldsMap.put(targetField, predictedEntry.getKey());\n+        return predictedEntry.getKey();\n+    }\n+\n+    public abstract boolean isBinary();/* {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c4a838980a18a8428b253ee431087beb471fe8d"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE2NjQwMA==", "bodyText": "@danielezonca\nDone", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r392166400", "createdAt": "2020-03-13T11:13:24Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-model/src/main/java/org/kie/pmml/models/regression/model/KiePMMLRegressionClassificationTable.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.model;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.DoubleUnaryOperator;\n+\n+import org.kie.pmml.commons.exceptions.KiePMMLException;\n+import org.kie.pmml.commons.model.KiePMMLOutputField;\n+import org.kie.pmml.commons.model.enums.OP_TYPE;\n+import org.kie.pmml.models.regression.model.enums.REGRESSION_NORMALIZATION_METHOD;\n+\n+import static org.kie.pmml.commons.Constants.EXPECTED_TWO_ENTRIES_RETRIEVED;\n+\n+public abstract class KiePMMLRegressionClassificationTable extends KiePMMLRegressionTable {\n+\n+    protected REGRESSION_NORMALIZATION_METHOD regressionNormalizationMethod;\n+    protected OP_TYPE opType;\n+    protected List<KiePMMLOutputField> outputFields = new ArrayList<>();\n+    protected Map<String, Object> outputFieldsMap = new HashMap<>();\n+    protected Map<String, KiePMMLRegressionTable> categoryTableMap = new HashMap<>();\n+\n+    public Object evaluateRegression(Map<String, Object> input) {\n+        final LinkedHashMap<String, Double> resultMap = new LinkedHashMap<>();\n+        for (Map.Entry<String, KiePMMLRegressionTable> entry : categoryTableMap.entrySet()) {\n+            resultMap.put(entry.getKey(), (Double) entry.getValue().evaluateRegression(input));\n+        }\n+        final LinkedHashMap<String, Double> probabilityMap = getProbabilityMap(resultMap);\n+        final Map.Entry<String, Double> predictedEntry = Collections.max(probabilityMap.entrySet(), Map.Entry.comparingByValue());\n+        probabilityMap.put(targetField, predictedEntry.getValue());\n+        populateOutputFieldsMap(predictedEntry, probabilityMap);\n+        outputFieldsMap.put(targetField, predictedEntry.getKey());\n+        return predictedEntry.getKey();\n+    }\n+\n+    public abstract boolean isBinary();/* {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjExNDUxOQ=="}, "originalCommit": {"oid": "3c4a838980a18a8428b253ee431087beb471fe8d"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDMxMzUxOnYy", "diffSide": "RIGHT", "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/main/java/org/kie/pmml/models/regression/compiler/utils/KiePMMLCode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwOTo1MjoxMFrOF19ijA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMToxMzoyMFrOF1_77g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjEyNzExNg==", "bodyText": "I think it is more clear to have KiePMMLSourceCode and KiePMMLByteCode to clarify when they are used", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r392127116", "createdAt": "2020-03-13T09:52:10Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/main/java/org/kie/pmml/models/regression/compiler/utils/KiePMMLCode.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.compiler.utils;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.URI;\n+\n+import javax.tools.SimpleJavaFileObject;\n+\n+public class KiePMMLCode extends SimpleJavaFileObject {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c4a838980a18a8428b253ee431087beb471fe8d"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE2NjM4Mg==", "bodyText": "@danielezonca\nDone", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r392166382", "createdAt": "2020-03-13T11:13:20Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/main/java/org/kie/pmml/models/regression/compiler/utils/KiePMMLCode.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.compiler.utils;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.URI;\n+\n+import javax.tools.SimpleJavaFileObject;\n+\n+public class KiePMMLCode extends SimpleJavaFileObject {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjEyNzExNg=="}, "originalCommit": {"oid": "3c4a838980a18a8428b253ee431087beb471fe8d"}, "originalPosition": 25}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2594, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}