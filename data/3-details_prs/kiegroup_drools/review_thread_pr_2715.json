{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYxMzM0MTE1", "number": 2715, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNDoxODo0NlrODYtejg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNDoyNToyN1rODYthzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MjM3NTE4OnYy", "diffSide": "RIGHT", "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/CanonicalKieModule.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNDoxODo0NlrOFeuduw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNDoxODo0NlrOFeuduw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc2Mjg3NQ==", "bodyText": "Detect the case where rules are the same (= lambda expressions are the same) but lambda class class names are different (= whole lambda class source codes are different). In this case, I set ChangeType.MERGE. To compile, you need to apply this change to droolsjbpm-knowledge repo.\nhttps://gist.github.com/tkobayas/9dadafbdc2f87beb9127c079bd8f8c57", "url": "https://github.com/kiegroup/drools/pull/2715#discussion_r367762875", "createdAt": "2020-01-17T04:18:46Z", "author": {"login": "tkobayas"}, "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/CanonicalKieModule.java", "diffHunk": "@@ -543,6 +544,11 @@ private void addModifiedItemsToChangeSet( ResourceChangeSet mainChangeSet, Map<S\n             if ( compare == 0 ) {\n                 if ( !areEqualInModel( currentOld, currentNew ) ) {\n                     registerChange( mainChangeSet, changes, type, ChangeType.UPDATED, currentOld );\n+                } else {\n+                    // Considered as equal in model. It means LambdaHash are equal. So now check class name hash\n+                    if (currentOld instanceof RuleImpl && RuleImpl.areDifferentInLambdaClassNameHash( (RuleImpl)currentOld, (RuleImpl)currentNew )) {\n+                        registerChange( mainChangeSet, changes, type, ChangeType.MERGE, currentOld );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf39f645c3610190045d43c08a5dcc8e481c5a83"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MjM3ODM3OnYy", "diffSide": "RIGHT", "path": "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/RuleImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNDoyMDozNVrOFeufYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNDoyMDozNVrOFeufYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc2MzI5OA==", "bodyText": "This method only checks LambdaConsequnece for now. If this is the right approach, I would need to check LambdaPredicate and LambdaExtractor as well.", "url": "https://github.com/kiegroup/drools/pull/2715#discussion_r367763298", "createdAt": "2020-01-17T04:20:35Z", "author": {"login": "tkobayas"}, "path": "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/RuleImpl.java", "diffHunk": "@@ -125,4 +126,17 @@ public boolean isEqualTo( ModelComponent o ) {\n     public String toString() {\n         return \"Rule: \" +  pkg + \".\" + name + \" (view: \" + view + \", consequences: \" + consequences + \")\";\n     }\n+\n+    public static boolean areDifferentInLambdaClassNameHash(RuleImpl o1, RuleImpl o2) {\n+        System.out.println(\"areDifferentInLambdaClassNameHash : \" + o1.getName());\n+        String consequenceName1 = ((IntrospectableLambda) o1.getDefaultConsequence().getBlock()).getLambda().getClass().getName();\n+        String consequenceName2 = ((IntrospectableLambda) o2.getDefaultConsequence().getBlock()).getLambda().getClass().getName();\n+        System.out.println(\"  consequenceName1 = \" + consequenceName1);\n+        System.out.println(\"  consequenceName2 = \" + consequenceName2);\n+        if (!consequenceName1.equals(consequenceName2)) {\n+            System.out.println(\"  Different!!!\");\n+            return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf39f645c3610190045d43c08a5dcc8e481c5a83"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MjM4MDY4OnYy", "diffSide": "RIGHT", "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/CanonicalKieBaseUpdater.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNDoyMjo0N1rOFeugwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNDoyMjo0N1rOFeugwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc2MzY1MA==", "bodyText": "This method only replaces LambdaConsequnece for now. If this is the right approach, I would need to replace LambdaPredicate and LambdaExtractor as well. I'm not sure how much work will be required though (and there are any side effects).", "url": "https://github.com/kiegroup/drools/pull/2715#discussion_r367763650", "createdAt": "2020-01-17T04:22:47Z", "author": {"login": "tkobayas"}, "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/CanonicalKieBaseUpdater.java", "diffHunk": "@@ -188,6 +199,12 @@ public void run() {\n         }\n     }\n \n+    private void mergeRuleWithLambda(RuleImpl oldRule, RuleImpl newRule) {\n+        Consequence newConsequence = newRule.getConsequence();\n+        oldRule.setConsequence(newConsequence);\n+        System.out.println(\"mergeRuleWithLambda!!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf39f645c3610190045d43c08a5dcc8e481c5a83"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MjM4MzUwOnYy", "diffSide": "RIGHT", "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/lambdareplace/MaterializedLambda.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNDoyNToyN1rOFeuiZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNDoyNToyN1rOFeuiZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc2NDA3MA==", "bodyText": "I added a public static final field \"EXPRESSION_HASH\" to validate the equality of materialized Lambda. This field is used in LambdaIntrospector.", "url": "https://github.com/kiegroup/drools/pull/2715#discussion_r367764070", "createdAt": "2020-01-17T04:25:27Z", "author": {"login": "tkobayas"}, "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/lambdareplace/MaterializedLambda.java", "diffHunk": "@@ -107,10 +114,13 @@ void setMethodParameter(MethodDeclaration methodDeclaration) {\n     }\n \n     private EnumDeclaration create(CompilationUnit compilationUnit) {\n-        EnumDeclaration lambdaClass = compilationUnit.addEnum(className);\n+        EnumDeclaration lambdaClass = compilationUnit.addEnum(temporaryClassName);\n         lambdaClass.addAnnotation(org.drools.compiler.kie.builder.MaterializedLambda.class.getCanonicalName());\n         lambdaClass.setImplementedTypes(createImplementedType());\n         lambdaClass.addEntry(new EnumConstantDeclaration(\"INSTANCE\"));\n+\n+        lambdaClass.addFieldWithInitializer(String.class, \"EXPRESSION_HASH\", StaticJavaParser.parseExpression(\"\\\"\" + (md5Hash(lambdaExpr.toString())) + \"\\\"\"),\n+                                            Modifier.Keyword.PUBLIC, Modifier.Keyword.STATIC, Modifier.Keyword.FINAL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf39f645c3610190045d43c08a5dcc8e481c5a83"}, "originalPosition": 56}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2617, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}