{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQzOTg3NzMx", "number": 2973, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMDo0MjozOFrOELNYOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMzowMjoyNVrOELPmgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMTg4OTg1OnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-compiler/kie-pmml-compiler-commons/src/test/java/org/kie/pmml/compiler/commons/utils/KiePMMLModelFactoryUtilsTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMDo0MjozOFrOGssRLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMTo1MjowNFrOGst8lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTUxNTgyMA==", "bodyText": "Can you please remove this print or replace it with an assertion?", "url": "https://github.com/kiegroup/drools/pull/2973#discussion_r449515820", "createdAt": "2020-07-03T10:42:38Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-trusty/kie-pmml-compiler/kie-pmml-compiler-commons/src/test/java/org/kie/pmml/compiler/commons/utils/KiePMMLModelFactoryUtilsTest.java", "diffHunk": "@@ -86,6 +86,7 @@ public void addTransformationsInClassOrInterfaceDeclaration() {\n         model.getLocalTransformations().getDerivedFields().forEach(derivedField -> commonVerifyDerivedFieldTransformation(derivedField, null, \"localTransformationsMap\"));\n         commonVerifyConstructorClass(\"commonTransformationsMap\");\n         commonVerifyConstructorClass(\"localTransformationsMap\");\n+        System.out.println(classOrInterfaceDeclaration.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37d5fb3d62a91ae32fa0205a3240dc0827b0538d"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU0MzMxOA==", "bodyText": "@danielezonca\ndone", "url": "https://github.com/kiegroup/drools/pull/2973#discussion_r449543318", "createdAt": "2020-07-03T11:52:04Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-trusty/kie-pmml-compiler/kie-pmml-compiler-commons/src/test/java/org/kie/pmml/compiler/commons/utils/KiePMMLModelFactoryUtilsTest.java", "diffHunk": "@@ -86,6 +86,7 @@ public void addTransformationsInClassOrInterfaceDeclaration() {\n         model.getLocalTransformations().getDerivedFields().forEach(derivedField -> commonVerifyDerivedFieldTransformation(derivedField, null, \"localTransformationsMap\"));\n         commonVerifyConstructorClass(\"commonTransformationsMap\");\n         commonVerifyConstructorClass(\"localTransformationsMap\");\n+        System.out.println(classOrInterfaceDeclaration.toString());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTUxNTgyMA=="}, "originalCommit": {"oid": "37d5fb3d62a91ae32fa0205a3240dc0827b0538d"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMTg5NTM0OnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-compiler/kie-pmml-compiler-commons/src/main/java/org/kie/pmml/compiler/commons/utils/ModelUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMDo0NDo0MlrOGssUqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMTo1MjowMFrOGst8cQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTUxNjcxNA==", "bodyText": "What about rename it as getBoxedClassName? I think it is enough to explicit that in case of primitive type, it will be replaced with boxed class", "url": "https://github.com/kiegroup/drools/pull/2973#discussion_r449516714", "createdAt": "2020-07-03T10:44:42Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-trusty/kie-pmml-compiler/kie-pmml-compiler-commons/src/main/java/org/kie/pmml/compiler/commons/utils/ModelUtils.java", "diffHunk": "@@ -150,4 +154,23 @@ public static DATA_TYPE getDataType(DataDictionary dataDictionary, String target\n                 .map(dataField -> DATA_TYPE.byName(dataField.getDataType().value()));\n         return toReturn.orElseThrow(() -> new KiePMMLInternalException(String.format(\"Failed to find DataType for field %s\", targetFieldName)));\n     }\n+\n+    /**\n+     * Retrieve the <b>mapped</b> class name of the given <code>ParameterField</code>, <b>eventually</b> boxed (for primitive ones)\n+     * @param parameterField\n+     * @return\n+     */\n+    public static String getEventuallyBoxedClassName(ParameterField parameterField) {\n+        return  parameterField.getDataType() == null ? Object.class.getName() : getEventuallyBoxedClassName(parameterField.getDataType());\n+    }\n+\n+    /**\n+     * Retrieve the <b>mapped</b> class name of the given <code>DataType</code>, <b>eventually</b> boxed (for primitive ones)\n+     * @param dataType\n+     * @return\n+     */\n+    public static String getEventuallyBoxedClassName(DataType dataType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37d5fb3d62a91ae32fa0205a3240dc0827b0538d"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU0MzI4MQ==", "bodyText": "@danielezonca\ndone", "url": "https://github.com/kiegroup/drools/pull/2973#discussion_r449543281", "createdAt": "2020-07-03T11:52:00Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-trusty/kie-pmml-compiler/kie-pmml-compiler-commons/src/main/java/org/kie/pmml/compiler/commons/utils/ModelUtils.java", "diffHunk": "@@ -150,4 +154,23 @@ public static DATA_TYPE getDataType(DataDictionary dataDictionary, String target\n                 .map(dataField -> DATA_TYPE.byName(dataField.getDataType().value()));\n         return toReturn.orElseThrow(() -> new KiePMMLInternalException(String.format(\"Failed to find DataType for field %s\", targetFieldName)));\n     }\n+\n+    /**\n+     * Retrieve the <b>mapped</b> class name of the given <code>ParameterField</code>, <b>eventually</b> boxed (for primitive ones)\n+     * @param parameterField\n+     * @return\n+     */\n+    public static String getEventuallyBoxedClassName(ParameterField parameterField) {\n+        return  parameterField.getDataType() == null ? Object.class.getName() : getEventuallyBoxedClassName(parameterField.getDataType());\n+    }\n+\n+    /**\n+     * Retrieve the <b>mapped</b> class name of the given <code>DataType</code>, <b>eventually</b> boxed (for primitive ones)\n+     * @param dataType\n+     * @return\n+     */\n+    public static String getEventuallyBoxedClassName(DataType dataType) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTUxNjcxNA=="}, "originalCommit": {"oid": "37d5fb3d62a91ae32fa0205a3240dc0827b0538d"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMTkwNDMyOnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-compiler/kie-pmml-compiler-commons/src/main/java/org/kie/pmml/compiler/commons/utils/ExpressionFunctionUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMDo0Nzo1MVrOGssaNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMTo1MTo1NlrOGst8XA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTUxODEzMw==", "bodyText": "To be removed", "url": "https://github.com/kiegroup/drools/pull/2973#discussion_r449518133", "createdAt": "2020-07-03T10:47:51Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-trusty/kie-pmml-compiler/kie-pmml-compiler-commons/src/main/java/org/kie/pmml/compiler/commons/utils/ExpressionFunctionUtils.java", "diffHunk": "@@ -162,95 +393,112 @@ static MethodDeclaration getFieldRefExpressionMethodDeclaration(final String met\n         // kiePMMLNameValue.map(KiePMMLNameValue::getValue).orElse( (fieldRef.getMapMissingTo() )\n         MethodCallExpr expression = new MethodCallExpr(\"orElse\");\n         expression.setScope(expressionScope);\n-        com.github.javaparser.ast.expr.Expression orElseExpression =  fieldRef.getMapMissingTo() != null ? new StringLiteralExpr(fieldRef.getMapMissingTo()) : new NullLiteralExpr();\n+        com.github.javaparser.ast.expr.Expression orElseExpression = fieldRef.getMapMissingTo() != null ? new StringLiteralExpr(fieldRef.getMapMissingTo()) : new NullLiteralExpr();\n         expression.setArguments(NodeList.nodeList(orElseExpression));\n \n-        // return kiePMMLNameValue.map(KiePMMLNameValue::getValue).orElse( (fieldRef.getMapMissingTo() )\n-        ReturnStmt returnStmt = new ReturnStmt();\n-        returnStmt.setExpression(expression);\n-        body.addStatement(returnStmt);\n-        MethodDeclaration toReturn = getExpressionMethodDeclaration(methodName, parameterTypes);\n+        // Object variableName = kiePMMLNameValue.map(KiePMMLNameValue::getValue).orElse( (fieldRef.getMapMissingTo() )\n+        VariableDeclarator variableDeclarator = new VariableDeclarator();\n         ClassOrInterfaceType classOrInterfaceType = parseClassOrInterfaceType(Object.class.getName());\n-        toReturn.setType(classOrInterfaceType);\n-        toReturn.setBody(body);\n+        variableDeclarator.setType(classOrInterfaceType);\n+        variableDeclarator.setName(variableName);\n+        variableDeclarator.setInitializer(expression);\n+        VariableDeclarationExpr variableDeclarationExpr = new VariableDeclarationExpr();\n+        variableDeclarationExpr.setVariables(NodeList.nodeList(variableDeclarator));\n+        toReturn.addStatement(variableDeclarationExpr);\n+\n         return toReturn;\n     }\n \n     /**\n-     * \n-     * @param methodName\n+     *\n+     * @param variableName\n      * @param lag\n+     * @param returnedType\n      * @param parameterTypes\n      * @return\n      */\n-    static MethodDeclaration getLagExpressionMethodDeclaration(final String methodName, final Lag lag, final List<ClassOrInterfaceType> parameterTypes) {\n-        MethodDeclaration toReturn = getExpressionMethodDeclaration(methodName, parameterTypes);\n-        return toReturn;\n+    static BlockStmt getLagExpressionBlockStmt(final String variableName, final Lag lag,  final ClassOrInterfaceType returnedType, final List<ClassOrInterfaceType> parameterTypes) {\n+        throw new KiePMMLException(\"Lag not managed, yet\");\n     }\n \n     /**\n-     * \n-     * @param methodName\n+     *\n+     * @param variableName\n      * @param mapValues\n+     * @param returnedType\n      * @param parameterTypes\n      * @return\n      */\n-    static MethodDeclaration getMapValuesExpressionMethodDeclaration(final String methodName, final MapValues mapValues, final List<ClassOrInterfaceType> parameterTypes) {\n-        MethodDeclaration toReturn = getExpressionMethodDeclaration(methodName, parameterTypes);\n-        return toReturn;\n+    static BlockStmt getMapValuesExpressionBlockStmt(final String variableName, final MapValues mapValues,  final ClassOrInterfaceType returnedType, final List<ClassOrInterfaceType> parameterTypes) {\n+        throw new KiePMMLException(\"MapValues not managed, yet\");\n     }\n \n     /**\n-     * \n-     * @param methodName\n+     *\n+     * @param variableName\n      * @param normContinuous\n+     * @param returnedType\n      * @param parameterTypes\n      * @return\n      */\n-    static MethodDeclaration getNormContinuousExpressionMethodDeclaration(final String methodName, final NormContinuous normContinuous, final List<ClassOrInterfaceType> parameterTypes) {\n-        MethodDeclaration toReturn = getExpressionMethodDeclaration(methodName, parameterTypes);\n-        return toReturn;\n+    static BlockStmt getNormContinuousExpressionBlockStmt(final String variableName, final NormContinuous normContinuous,  final ClassOrInterfaceType returnedType, final List<ClassOrInterfaceType> parameterTypes) {\n+        throw new KiePMMLException(\"NormContinuous not managed, yet\");\n     }\n \n     /**\n-     * \n-     * @param methodName\n+     *\n+     *\n+     * @param variableName\n      * @param normDiscrete\n+     * @param returnedType\n      * @param parameterTypes\n      * @return\n      */\n-    static MethodDeclaration getNormDiscreteExpressionMethodDeclaration(final String methodName, final NormDiscrete normDiscrete, final List<ClassOrInterfaceType> parameterTypes) {\n-        MethodDeclaration toReturn = getExpressionMethodDeclaration(methodName, parameterTypes);\n-        return toReturn;\n+    static BlockStmt getNormDiscreteExpressionBlockStmt(final String variableName, final NormDiscrete normDiscrete, final ClassOrInterfaceType returnedType,  final List<ClassOrInterfaceType> parameterTypes) {\n+        throw new KiePMMLException(\"NormDiscrete not managed, yet\");\n     }\n \n     /**\n-     * \n-     * @param methodName\n+     *\n+     * @param variableName\n      * @param textIndex\n+     * @param returnedType\n      * @param parameterTypes\n      * @return\n      */\n-    static MethodDeclaration getTextIndexExpressionMethodDeclaration(final String methodName, final TextIndex textIndex, final List<ClassOrInterfaceType> parameterTypes) {\n-        MethodDeclaration toReturn = getExpressionMethodDeclaration(methodName, parameterTypes);\n-        return toReturn;\n+    static BlockStmt getTextIndexExpressionBlockStmt(final String variableName, final TextIndex textIndex,  final ClassOrInterfaceType returnedType, final List<ClassOrInterfaceType> parameterTypes) {\n+        throw new KiePMMLException(\"TextIndex not managed, yet\");\n     }\n \n-\n     /**\n      * Return\n      * <pre>\n-     *     empty  methodName(List<KiePMMLNameValue> param1) {\n+     *     (<i>returnedType</i>)  (<i>methodName</i>)(List<KiePMMLNameValue> param1) {\n+     *              <i>body</i>\n+     *              return <i>variableName</i>;\n      *     }\n      * </pre>\n-     * \n      * @param methodName\n      * @param parameterTypes\n      * @return\n      */\n-    static MethodDeclaration getExpressionMethodDeclaration(final String methodName, final List<ClassOrInterfaceType> parameterTypes) {\n-        return getMethodDeclaration(methodName, parameterTypes);\n-    }\n-\n+    /**\n+     *\n+     * @param methodName\n+     * @param variableName\n+     * @param body\n+     * @param returnedType\n+     * @param parameterTypes\n+     * @return\n+     */\n+    static MethodDeclaration getExpressionMethodDeclaration(final String methodName, final String variableName, final BlockStmt body, final ClassOrInterfaceType returnedType, final List<ClassOrInterfaceType> parameterTypes) {\n+//        return getMethodDeclaration(methodName, parameterTypes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37d5fb3d62a91ae32fa0205a3240dc0827b0538d"}, "originalPosition": 541}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU0MzI2MA==", "bodyText": "@danielezonca\ndone", "url": "https://github.com/kiegroup/drools/pull/2973#discussion_r449543260", "createdAt": "2020-07-03T11:51:56Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-trusty/kie-pmml-compiler/kie-pmml-compiler-commons/src/main/java/org/kie/pmml/compiler/commons/utils/ExpressionFunctionUtils.java", "diffHunk": "@@ -162,95 +393,112 @@ static MethodDeclaration getFieldRefExpressionMethodDeclaration(final String met\n         // kiePMMLNameValue.map(KiePMMLNameValue::getValue).orElse( (fieldRef.getMapMissingTo() )\n         MethodCallExpr expression = new MethodCallExpr(\"orElse\");\n         expression.setScope(expressionScope);\n-        com.github.javaparser.ast.expr.Expression orElseExpression =  fieldRef.getMapMissingTo() != null ? new StringLiteralExpr(fieldRef.getMapMissingTo()) : new NullLiteralExpr();\n+        com.github.javaparser.ast.expr.Expression orElseExpression = fieldRef.getMapMissingTo() != null ? new StringLiteralExpr(fieldRef.getMapMissingTo()) : new NullLiteralExpr();\n         expression.setArguments(NodeList.nodeList(orElseExpression));\n \n-        // return kiePMMLNameValue.map(KiePMMLNameValue::getValue).orElse( (fieldRef.getMapMissingTo() )\n-        ReturnStmt returnStmt = new ReturnStmt();\n-        returnStmt.setExpression(expression);\n-        body.addStatement(returnStmt);\n-        MethodDeclaration toReturn = getExpressionMethodDeclaration(methodName, parameterTypes);\n+        // Object variableName = kiePMMLNameValue.map(KiePMMLNameValue::getValue).orElse( (fieldRef.getMapMissingTo() )\n+        VariableDeclarator variableDeclarator = new VariableDeclarator();\n         ClassOrInterfaceType classOrInterfaceType = parseClassOrInterfaceType(Object.class.getName());\n-        toReturn.setType(classOrInterfaceType);\n-        toReturn.setBody(body);\n+        variableDeclarator.setType(classOrInterfaceType);\n+        variableDeclarator.setName(variableName);\n+        variableDeclarator.setInitializer(expression);\n+        VariableDeclarationExpr variableDeclarationExpr = new VariableDeclarationExpr();\n+        variableDeclarationExpr.setVariables(NodeList.nodeList(variableDeclarator));\n+        toReturn.addStatement(variableDeclarationExpr);\n+\n         return toReturn;\n     }\n \n     /**\n-     * \n-     * @param methodName\n+     *\n+     * @param variableName\n      * @param lag\n+     * @param returnedType\n      * @param parameterTypes\n      * @return\n      */\n-    static MethodDeclaration getLagExpressionMethodDeclaration(final String methodName, final Lag lag, final List<ClassOrInterfaceType> parameterTypes) {\n-        MethodDeclaration toReturn = getExpressionMethodDeclaration(methodName, parameterTypes);\n-        return toReturn;\n+    static BlockStmt getLagExpressionBlockStmt(final String variableName, final Lag lag,  final ClassOrInterfaceType returnedType, final List<ClassOrInterfaceType> parameterTypes) {\n+        throw new KiePMMLException(\"Lag not managed, yet\");\n     }\n \n     /**\n-     * \n-     * @param methodName\n+     *\n+     * @param variableName\n      * @param mapValues\n+     * @param returnedType\n      * @param parameterTypes\n      * @return\n      */\n-    static MethodDeclaration getMapValuesExpressionMethodDeclaration(final String methodName, final MapValues mapValues, final List<ClassOrInterfaceType> parameterTypes) {\n-        MethodDeclaration toReturn = getExpressionMethodDeclaration(methodName, parameterTypes);\n-        return toReturn;\n+    static BlockStmt getMapValuesExpressionBlockStmt(final String variableName, final MapValues mapValues,  final ClassOrInterfaceType returnedType, final List<ClassOrInterfaceType> parameterTypes) {\n+        throw new KiePMMLException(\"MapValues not managed, yet\");\n     }\n \n     /**\n-     * \n-     * @param methodName\n+     *\n+     * @param variableName\n      * @param normContinuous\n+     * @param returnedType\n      * @param parameterTypes\n      * @return\n      */\n-    static MethodDeclaration getNormContinuousExpressionMethodDeclaration(final String methodName, final NormContinuous normContinuous, final List<ClassOrInterfaceType> parameterTypes) {\n-        MethodDeclaration toReturn = getExpressionMethodDeclaration(methodName, parameterTypes);\n-        return toReturn;\n+    static BlockStmt getNormContinuousExpressionBlockStmt(final String variableName, final NormContinuous normContinuous,  final ClassOrInterfaceType returnedType, final List<ClassOrInterfaceType> parameterTypes) {\n+        throw new KiePMMLException(\"NormContinuous not managed, yet\");\n     }\n \n     /**\n-     * \n-     * @param methodName\n+     *\n+     *\n+     * @param variableName\n      * @param normDiscrete\n+     * @param returnedType\n      * @param parameterTypes\n      * @return\n      */\n-    static MethodDeclaration getNormDiscreteExpressionMethodDeclaration(final String methodName, final NormDiscrete normDiscrete, final List<ClassOrInterfaceType> parameterTypes) {\n-        MethodDeclaration toReturn = getExpressionMethodDeclaration(methodName, parameterTypes);\n-        return toReturn;\n+    static BlockStmt getNormDiscreteExpressionBlockStmt(final String variableName, final NormDiscrete normDiscrete, final ClassOrInterfaceType returnedType,  final List<ClassOrInterfaceType> parameterTypes) {\n+        throw new KiePMMLException(\"NormDiscrete not managed, yet\");\n     }\n \n     /**\n-     * \n-     * @param methodName\n+     *\n+     * @param variableName\n      * @param textIndex\n+     * @param returnedType\n      * @param parameterTypes\n      * @return\n      */\n-    static MethodDeclaration getTextIndexExpressionMethodDeclaration(final String methodName, final TextIndex textIndex, final List<ClassOrInterfaceType> parameterTypes) {\n-        MethodDeclaration toReturn = getExpressionMethodDeclaration(methodName, parameterTypes);\n-        return toReturn;\n+    static BlockStmt getTextIndexExpressionBlockStmt(final String variableName, final TextIndex textIndex,  final ClassOrInterfaceType returnedType, final List<ClassOrInterfaceType> parameterTypes) {\n+        throw new KiePMMLException(\"TextIndex not managed, yet\");\n     }\n \n-\n     /**\n      * Return\n      * <pre>\n-     *     empty  methodName(List<KiePMMLNameValue> param1) {\n+     *     (<i>returnedType</i>)  (<i>methodName</i>)(List<KiePMMLNameValue> param1) {\n+     *              <i>body</i>\n+     *              return <i>variableName</i>;\n      *     }\n      * </pre>\n-     * \n      * @param methodName\n      * @param parameterTypes\n      * @return\n      */\n-    static MethodDeclaration getExpressionMethodDeclaration(final String methodName, final List<ClassOrInterfaceType> parameterTypes) {\n-        return getMethodDeclaration(methodName, parameterTypes);\n-    }\n-\n+    /**\n+     *\n+     * @param methodName\n+     * @param variableName\n+     * @param body\n+     * @param returnedType\n+     * @param parameterTypes\n+     * @return\n+     */\n+    static MethodDeclaration getExpressionMethodDeclaration(final String methodName, final String variableName, final BlockStmt body, final ClassOrInterfaceType returnedType, final List<ClassOrInterfaceType> parameterTypes) {\n+//        return getMethodDeclaration(methodName, parameterTypes);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTUxODEzMw=="}, "originalCommit": {"oid": "37d5fb3d62a91ae32fa0205a3240dc0827b0538d"}, "originalPosition": 541}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMTk0MDcxOnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-compiler/kie-pmml-compiler-commons/src/test/java/org/kie/pmml/compiler/commons/utils/DefineFunctionUtilsTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMTowMToyNlrOGsswPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMjozMToyNlrOGsu5YA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTUyMzc3Mg==", "bodyText": "I think it is more readable just to catch KiePMMLException with an empty block. Wdyt?", "url": "https://github.com/kiegroup/drools/pull/2973#discussion_r449523772", "createdAt": "2020-07-03T11:01:26Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-trusty/kie-pmml-compiler/kie-pmml-compiler-commons/src/test/java/org/kie/pmml/compiler/commons/utils/DefineFunctionUtilsTest.java", "diffHunk": "@@ -0,0 +1,231 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.pmml.compiler.commons.utils;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import org.dmg.pmml.Aggregate;\n+import org.dmg.pmml.DefineFunction;\n+import org.dmg.pmml.Discretize;\n+import org.dmg.pmml.Expression;\n+import org.dmg.pmml.Lag;\n+import org.dmg.pmml.MapValues;\n+import org.dmg.pmml.NormContinuous;\n+import org.dmg.pmml.NormDiscrete;\n+import org.dmg.pmml.ParameterField;\n+import org.dmg.pmml.TextIndex;\n+import org.dmg.pmml.Visitor;\n+import org.dmg.pmml.VisitorAction;\n+import org.junit.Test;\n+import org.kie.pmml.commons.exceptions.KiePMMLException;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.kie.pmml.compiler.commons.testutils.PMMLModelTestUtils.getParameterFields;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtilsTest.applySupplier;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtilsTest.constantSupplier;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtilsTest.fieldRefSupplier;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtilsTest.supportedExpressionSupplier;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtilsTest.unsupportedExpressionSupplier;\n+import static org.kie.pmml.compiler.commons.utils.ModelUtils.getEventuallyBoxedClassName;\n+\n+public class DefineFunctionUtilsTest {\n+\n+    private static final Function<Supplier<Expression>, DefineFunction> defineFunctionCreator = supplier -> {\n+        Expression expression = supplier.get();\n+        DefineFunction defineFunction = new DefineFunction();\n+        defineFunction.setName(\"DEFINE_FUNCTION_\" + expression.getClass().getSimpleName());\n+        defineFunction.setExpression(expression);\n+        return defineFunction;\n+    };\n+\n+    @Test(expected = KiePMMLException.class)\n+    public void getDefineFunctionsMethodMapUnsupportedExpression() {\n+        List<DefineFunction> defineFunctions = unsupportedExpressionSupplier.stream().map(defineFunctionCreator).collect(Collectors.toList());\n+        DefineFunctionUtils.getDefineFunctionsMethodMap(defineFunctions);\n+    }\n+\n+    @Test\n+    public void getDefineFunctionsMethodMapSupportedExpression() {\n+        List<DefineFunction> defineFunctions = supportedExpressionSupplier.stream().map(defineFunctionCreator).collect(Collectors.toList());\n+        Map<String, MethodDeclaration> retrieved = DefineFunctionUtils.getDefineFunctionsMethodMap(defineFunctions);\n+        assertEquals(defineFunctions.size(), retrieved.size());\n+    }\n+\n+    @Test\n+    public void getDefineFunctionMethodDeclarationUnsupportedExpression() {\n+        for (Supplier<Expression> supplier : unsupportedExpressionSupplier) {\n+            DefineFunction defineFunction = defineFunctionCreator.apply(supplier);\n+            try {\n+                DefineFunctionUtils.getDefineFunctionMethodDeclaration(defineFunction);\n+                fail(String.format(\"Expecting KiePMMLException for %s\", defineFunction));\n+            } catch (Exception e) {\n+                assertTrue(e instanceof KiePMMLException);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37d5fb3d62a91ae32fa0205a3240dc0827b0538d"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU0MTU2Mw==", "bodyText": "@danielezonca\nTBH, being them tests, I would prefer to explicitly declare an assertion. That way if the assertion fails, testing framework correctly manage it - instead of re-throwing an un-catched exception (I prefer to have an \"Expected KiePMMLException, retrieved ...\" error message instead of a stacktrace)", "url": "https://github.com/kiegroup/drools/pull/2973#discussion_r449541563", "createdAt": "2020-07-03T11:47:40Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-trusty/kie-pmml-compiler/kie-pmml-compiler-commons/src/test/java/org/kie/pmml/compiler/commons/utils/DefineFunctionUtilsTest.java", "diffHunk": "@@ -0,0 +1,231 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.pmml.compiler.commons.utils;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import org.dmg.pmml.Aggregate;\n+import org.dmg.pmml.DefineFunction;\n+import org.dmg.pmml.Discretize;\n+import org.dmg.pmml.Expression;\n+import org.dmg.pmml.Lag;\n+import org.dmg.pmml.MapValues;\n+import org.dmg.pmml.NormContinuous;\n+import org.dmg.pmml.NormDiscrete;\n+import org.dmg.pmml.ParameterField;\n+import org.dmg.pmml.TextIndex;\n+import org.dmg.pmml.Visitor;\n+import org.dmg.pmml.VisitorAction;\n+import org.junit.Test;\n+import org.kie.pmml.commons.exceptions.KiePMMLException;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.kie.pmml.compiler.commons.testutils.PMMLModelTestUtils.getParameterFields;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtilsTest.applySupplier;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtilsTest.constantSupplier;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtilsTest.fieldRefSupplier;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtilsTest.supportedExpressionSupplier;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtilsTest.unsupportedExpressionSupplier;\n+import static org.kie.pmml.compiler.commons.utils.ModelUtils.getEventuallyBoxedClassName;\n+\n+public class DefineFunctionUtilsTest {\n+\n+    private static final Function<Supplier<Expression>, DefineFunction> defineFunctionCreator = supplier -> {\n+        Expression expression = supplier.get();\n+        DefineFunction defineFunction = new DefineFunction();\n+        defineFunction.setName(\"DEFINE_FUNCTION_\" + expression.getClass().getSimpleName());\n+        defineFunction.setExpression(expression);\n+        return defineFunction;\n+    };\n+\n+    @Test(expected = KiePMMLException.class)\n+    public void getDefineFunctionsMethodMapUnsupportedExpression() {\n+        List<DefineFunction> defineFunctions = unsupportedExpressionSupplier.stream().map(defineFunctionCreator).collect(Collectors.toList());\n+        DefineFunctionUtils.getDefineFunctionsMethodMap(defineFunctions);\n+    }\n+\n+    @Test\n+    public void getDefineFunctionsMethodMapSupportedExpression() {\n+        List<DefineFunction> defineFunctions = supportedExpressionSupplier.stream().map(defineFunctionCreator).collect(Collectors.toList());\n+        Map<String, MethodDeclaration> retrieved = DefineFunctionUtils.getDefineFunctionsMethodMap(defineFunctions);\n+        assertEquals(defineFunctions.size(), retrieved.size());\n+    }\n+\n+    @Test\n+    public void getDefineFunctionMethodDeclarationUnsupportedExpression() {\n+        for (Supplier<Expression> supplier : unsupportedExpressionSupplier) {\n+            DefineFunction defineFunction = defineFunctionCreator.apply(supplier);\n+            try {\n+                DefineFunctionUtils.getDefineFunctionMethodDeclaration(defineFunction);\n+                fail(String.format(\"Expecting KiePMMLException for %s\", defineFunction));\n+            } catch (Exception e) {\n+                assertTrue(e instanceof KiePMMLException);\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTUyMzc3Mg=="}, "originalCommit": {"oid": "37d5fb3d62a91ae32fa0205a3240dc0827b0538d"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU1NDMzMQ==", "bodyText": "I understand you want to have a better error message but you are not getting it: if that assertTrue will fail you will just get a message like \"Expected :true Actual   :false\"\nYou can use assertj and use assertThatThrownBy", "url": "https://github.com/kiegroup/drools/pull/2973#discussion_r449554331", "createdAt": "2020-07-03T12:19:49Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-trusty/kie-pmml-compiler/kie-pmml-compiler-commons/src/test/java/org/kie/pmml/compiler/commons/utils/DefineFunctionUtilsTest.java", "diffHunk": "@@ -0,0 +1,231 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.pmml.compiler.commons.utils;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import org.dmg.pmml.Aggregate;\n+import org.dmg.pmml.DefineFunction;\n+import org.dmg.pmml.Discretize;\n+import org.dmg.pmml.Expression;\n+import org.dmg.pmml.Lag;\n+import org.dmg.pmml.MapValues;\n+import org.dmg.pmml.NormContinuous;\n+import org.dmg.pmml.NormDiscrete;\n+import org.dmg.pmml.ParameterField;\n+import org.dmg.pmml.TextIndex;\n+import org.dmg.pmml.Visitor;\n+import org.dmg.pmml.VisitorAction;\n+import org.junit.Test;\n+import org.kie.pmml.commons.exceptions.KiePMMLException;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.kie.pmml.compiler.commons.testutils.PMMLModelTestUtils.getParameterFields;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtilsTest.applySupplier;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtilsTest.constantSupplier;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtilsTest.fieldRefSupplier;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtilsTest.supportedExpressionSupplier;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtilsTest.unsupportedExpressionSupplier;\n+import static org.kie.pmml.compiler.commons.utils.ModelUtils.getEventuallyBoxedClassName;\n+\n+public class DefineFunctionUtilsTest {\n+\n+    private static final Function<Supplier<Expression>, DefineFunction> defineFunctionCreator = supplier -> {\n+        Expression expression = supplier.get();\n+        DefineFunction defineFunction = new DefineFunction();\n+        defineFunction.setName(\"DEFINE_FUNCTION_\" + expression.getClass().getSimpleName());\n+        defineFunction.setExpression(expression);\n+        return defineFunction;\n+    };\n+\n+    @Test(expected = KiePMMLException.class)\n+    public void getDefineFunctionsMethodMapUnsupportedExpression() {\n+        List<DefineFunction> defineFunctions = unsupportedExpressionSupplier.stream().map(defineFunctionCreator).collect(Collectors.toList());\n+        DefineFunctionUtils.getDefineFunctionsMethodMap(defineFunctions);\n+    }\n+\n+    @Test\n+    public void getDefineFunctionsMethodMapSupportedExpression() {\n+        List<DefineFunction> defineFunctions = supportedExpressionSupplier.stream().map(defineFunctionCreator).collect(Collectors.toList());\n+        Map<String, MethodDeclaration> retrieved = DefineFunctionUtils.getDefineFunctionsMethodMap(defineFunctions);\n+        assertEquals(defineFunctions.size(), retrieved.size());\n+    }\n+\n+    @Test\n+    public void getDefineFunctionMethodDeclarationUnsupportedExpression() {\n+        for (Supplier<Expression> supplier : unsupportedExpressionSupplier) {\n+            DefineFunction defineFunction = defineFunctionCreator.apply(supplier);\n+            try {\n+                DefineFunctionUtils.getDefineFunctionMethodDeclaration(defineFunction);\n+                fail(String.format(\"Expecting KiePMMLException for %s\", defineFunction));\n+            } catch (Exception e) {\n+                assertTrue(e instanceof KiePMMLException);\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTUyMzc3Mg=="}, "originalCommit": {"oid": "37d5fb3d62a91ae32fa0205a3240dc0827b0538d"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU1ODg4MA==", "bodyText": "@danielezonca\nreplaced with\nassertEquals(KiePMMLException.class, e.getClass());\nto obtain\njava.lang.AssertionError: \nExpected :class org.kie.pmml.commons.exceptions.KiePMMLException\nActual   :class java.lang.IllegalArgumentException\n\nthat is what I wanted", "url": "https://github.com/kiegroup/drools/pull/2973#discussion_r449558880", "createdAt": "2020-07-03T12:31:26Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-trusty/kie-pmml-compiler/kie-pmml-compiler-commons/src/test/java/org/kie/pmml/compiler/commons/utils/DefineFunctionUtilsTest.java", "diffHunk": "@@ -0,0 +1,231 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.pmml.compiler.commons.utils;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import org.dmg.pmml.Aggregate;\n+import org.dmg.pmml.DefineFunction;\n+import org.dmg.pmml.Discretize;\n+import org.dmg.pmml.Expression;\n+import org.dmg.pmml.Lag;\n+import org.dmg.pmml.MapValues;\n+import org.dmg.pmml.NormContinuous;\n+import org.dmg.pmml.NormDiscrete;\n+import org.dmg.pmml.ParameterField;\n+import org.dmg.pmml.TextIndex;\n+import org.dmg.pmml.Visitor;\n+import org.dmg.pmml.VisitorAction;\n+import org.junit.Test;\n+import org.kie.pmml.commons.exceptions.KiePMMLException;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.kie.pmml.compiler.commons.testutils.PMMLModelTestUtils.getParameterFields;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtilsTest.applySupplier;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtilsTest.constantSupplier;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtilsTest.fieldRefSupplier;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtilsTest.supportedExpressionSupplier;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtilsTest.unsupportedExpressionSupplier;\n+import static org.kie.pmml.compiler.commons.utils.ModelUtils.getEventuallyBoxedClassName;\n+\n+public class DefineFunctionUtilsTest {\n+\n+    private static final Function<Supplier<Expression>, DefineFunction> defineFunctionCreator = supplier -> {\n+        Expression expression = supplier.get();\n+        DefineFunction defineFunction = new DefineFunction();\n+        defineFunction.setName(\"DEFINE_FUNCTION_\" + expression.getClass().getSimpleName());\n+        defineFunction.setExpression(expression);\n+        return defineFunction;\n+    };\n+\n+    @Test(expected = KiePMMLException.class)\n+    public void getDefineFunctionsMethodMapUnsupportedExpression() {\n+        List<DefineFunction> defineFunctions = unsupportedExpressionSupplier.stream().map(defineFunctionCreator).collect(Collectors.toList());\n+        DefineFunctionUtils.getDefineFunctionsMethodMap(defineFunctions);\n+    }\n+\n+    @Test\n+    public void getDefineFunctionsMethodMapSupportedExpression() {\n+        List<DefineFunction> defineFunctions = supportedExpressionSupplier.stream().map(defineFunctionCreator).collect(Collectors.toList());\n+        Map<String, MethodDeclaration> retrieved = DefineFunctionUtils.getDefineFunctionsMethodMap(defineFunctions);\n+        assertEquals(defineFunctions.size(), retrieved.size());\n+    }\n+\n+    @Test\n+    public void getDefineFunctionMethodDeclarationUnsupportedExpression() {\n+        for (Supplier<Expression> supplier : unsupportedExpressionSupplier) {\n+            DefineFunction defineFunction = defineFunctionCreator.apply(supplier);\n+            try {\n+                DefineFunctionUtils.getDefineFunctionMethodDeclaration(defineFunction);\n+                fail(String.format(\"Expecting KiePMMLException for %s\", defineFunction));\n+            } catch (Exception e) {\n+                assertTrue(e instanceof KiePMMLException);\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTUyMzc3Mg=="}, "originalCommit": {"oid": "37d5fb3d62a91ae32fa0205a3240dc0827b0538d"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMTk0MjMwOnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-compiler/kie-pmml-compiler-commons/src/test/java/org/kie/pmml/compiler/commons/utils/DefineFunctionUtilsTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMTowMjowOFrOGssxLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMTo0Nzo1NFrOGst2HA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTUyNDAxNA==", "bodyText": "Same as above", "url": "https://github.com/kiegroup/drools/pull/2973#discussion_r449524014", "createdAt": "2020-07-03T11:02:08Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-trusty/kie-pmml-compiler/kie-pmml-compiler-commons/src/test/java/org/kie/pmml/compiler/commons/utils/DefineFunctionUtilsTest.java", "diffHunk": "@@ -0,0 +1,231 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.pmml.compiler.commons.utils;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import org.dmg.pmml.Aggregate;\n+import org.dmg.pmml.DefineFunction;\n+import org.dmg.pmml.Discretize;\n+import org.dmg.pmml.Expression;\n+import org.dmg.pmml.Lag;\n+import org.dmg.pmml.MapValues;\n+import org.dmg.pmml.NormContinuous;\n+import org.dmg.pmml.NormDiscrete;\n+import org.dmg.pmml.ParameterField;\n+import org.dmg.pmml.TextIndex;\n+import org.dmg.pmml.Visitor;\n+import org.dmg.pmml.VisitorAction;\n+import org.junit.Test;\n+import org.kie.pmml.commons.exceptions.KiePMMLException;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.kie.pmml.compiler.commons.testutils.PMMLModelTestUtils.getParameterFields;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtilsTest.applySupplier;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtilsTest.constantSupplier;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtilsTest.fieldRefSupplier;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtilsTest.supportedExpressionSupplier;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtilsTest.unsupportedExpressionSupplier;\n+import static org.kie.pmml.compiler.commons.utils.ModelUtils.getEventuallyBoxedClassName;\n+\n+public class DefineFunctionUtilsTest {\n+\n+    private static final Function<Supplier<Expression>, DefineFunction> defineFunctionCreator = supplier -> {\n+        Expression expression = supplier.get();\n+        DefineFunction defineFunction = new DefineFunction();\n+        defineFunction.setName(\"DEFINE_FUNCTION_\" + expression.getClass().getSimpleName());\n+        defineFunction.setExpression(expression);\n+        return defineFunction;\n+    };\n+\n+    @Test(expected = KiePMMLException.class)\n+    public void getDefineFunctionsMethodMapUnsupportedExpression() {\n+        List<DefineFunction> defineFunctions = unsupportedExpressionSupplier.stream().map(defineFunctionCreator).collect(Collectors.toList());\n+        DefineFunctionUtils.getDefineFunctionsMethodMap(defineFunctions);\n+    }\n+\n+    @Test\n+    public void getDefineFunctionsMethodMapSupportedExpression() {\n+        List<DefineFunction> defineFunctions = supportedExpressionSupplier.stream().map(defineFunctionCreator).collect(Collectors.toList());\n+        Map<String, MethodDeclaration> retrieved = DefineFunctionUtils.getDefineFunctionsMethodMap(defineFunctions);\n+        assertEquals(defineFunctions.size(), retrieved.size());\n+    }\n+\n+    @Test\n+    public void getDefineFunctionMethodDeclarationUnsupportedExpression() {\n+        for (Supplier<Expression> supplier : unsupportedExpressionSupplier) {\n+            DefineFunction defineFunction = defineFunctionCreator.apply(supplier);\n+            try {\n+                DefineFunctionUtils.getDefineFunctionMethodDeclaration(defineFunction);\n+                fail(String.format(\"Expecting KiePMMLException for %s\", defineFunction));\n+            } catch (Exception e) {\n+                assertTrue(e instanceof KiePMMLException);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void getDefineFunctionMethodDeclarationSupportedExpression() {\n+        for (Supplier<Expression> supplier : supportedExpressionSupplier) {\n+            DefineFunction defineFunction = defineFunctionCreator.apply(supplier);\n+            try {\n+                DefineFunctionUtils.getDefineFunctionMethodDeclaration(defineFunction);\n+            } catch (Exception e) {\n+                fail(String.format(\"Unexpected %s for %s\", e, defineFunction.getExpression().getClass()));\n+            }\n+        }\n+    }\n+\n+    @Test(expected = KiePMMLException.class)\n+    public void getDefineFunctionMethodDeclarationWithoutExpression() {\n+        DefineFunctionUtils.getDefineFunctionMethodDeclaration(new DefineFunction());\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void getExpressionMethodDeclarationUnknownExpression() {\n+        Expression expression = new Expression() {\n+            @Override\n+            public VisitorAction accept(Visitor visitor) {\n+                return null;\n+            }\n+        };\n+        DefineFunctionUtils.getExpressionMethodDeclaration(\"\", expression, Collections.emptyList());\n+    }\n+\n+    @Test\n+    public void getExpressionMethodDeclarationUnsupportedExpression() {\n+        for (Supplier<Expression> supplier : unsupportedExpressionSupplier) {\n+            Expression expression = supplier.get();\n+            try {\n+                DefineFunctionUtils.getExpressionMethodDeclaration(\"\", expression, Collections.emptyList());\n+                fail(String.format(\"Expecting KiePMMLException for %s\", expression.getClass()));\n+            } catch (Exception e) {\n+                assertTrue(e instanceof KiePMMLException);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37d5fb3d62a91ae32fa0205a3240dc0827b0538d"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU0MTY2MA==", "bodyText": "@danielezonca\nsee above", "url": "https://github.com/kiegroup/drools/pull/2973#discussion_r449541660", "createdAt": "2020-07-03T11:47:54Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-trusty/kie-pmml-compiler/kie-pmml-compiler-commons/src/test/java/org/kie/pmml/compiler/commons/utils/DefineFunctionUtilsTest.java", "diffHunk": "@@ -0,0 +1,231 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.pmml.compiler.commons.utils;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import org.dmg.pmml.Aggregate;\n+import org.dmg.pmml.DefineFunction;\n+import org.dmg.pmml.Discretize;\n+import org.dmg.pmml.Expression;\n+import org.dmg.pmml.Lag;\n+import org.dmg.pmml.MapValues;\n+import org.dmg.pmml.NormContinuous;\n+import org.dmg.pmml.NormDiscrete;\n+import org.dmg.pmml.ParameterField;\n+import org.dmg.pmml.TextIndex;\n+import org.dmg.pmml.Visitor;\n+import org.dmg.pmml.VisitorAction;\n+import org.junit.Test;\n+import org.kie.pmml.commons.exceptions.KiePMMLException;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.kie.pmml.compiler.commons.testutils.PMMLModelTestUtils.getParameterFields;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtilsTest.applySupplier;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtilsTest.constantSupplier;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtilsTest.fieldRefSupplier;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtilsTest.supportedExpressionSupplier;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtilsTest.unsupportedExpressionSupplier;\n+import static org.kie.pmml.compiler.commons.utils.ModelUtils.getEventuallyBoxedClassName;\n+\n+public class DefineFunctionUtilsTest {\n+\n+    private static final Function<Supplier<Expression>, DefineFunction> defineFunctionCreator = supplier -> {\n+        Expression expression = supplier.get();\n+        DefineFunction defineFunction = new DefineFunction();\n+        defineFunction.setName(\"DEFINE_FUNCTION_\" + expression.getClass().getSimpleName());\n+        defineFunction.setExpression(expression);\n+        return defineFunction;\n+    };\n+\n+    @Test(expected = KiePMMLException.class)\n+    public void getDefineFunctionsMethodMapUnsupportedExpression() {\n+        List<DefineFunction> defineFunctions = unsupportedExpressionSupplier.stream().map(defineFunctionCreator).collect(Collectors.toList());\n+        DefineFunctionUtils.getDefineFunctionsMethodMap(defineFunctions);\n+    }\n+\n+    @Test\n+    public void getDefineFunctionsMethodMapSupportedExpression() {\n+        List<DefineFunction> defineFunctions = supportedExpressionSupplier.stream().map(defineFunctionCreator).collect(Collectors.toList());\n+        Map<String, MethodDeclaration> retrieved = DefineFunctionUtils.getDefineFunctionsMethodMap(defineFunctions);\n+        assertEquals(defineFunctions.size(), retrieved.size());\n+    }\n+\n+    @Test\n+    public void getDefineFunctionMethodDeclarationUnsupportedExpression() {\n+        for (Supplier<Expression> supplier : unsupportedExpressionSupplier) {\n+            DefineFunction defineFunction = defineFunctionCreator.apply(supplier);\n+            try {\n+                DefineFunctionUtils.getDefineFunctionMethodDeclaration(defineFunction);\n+                fail(String.format(\"Expecting KiePMMLException for %s\", defineFunction));\n+            } catch (Exception e) {\n+                assertTrue(e instanceof KiePMMLException);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void getDefineFunctionMethodDeclarationSupportedExpression() {\n+        for (Supplier<Expression> supplier : supportedExpressionSupplier) {\n+            DefineFunction defineFunction = defineFunctionCreator.apply(supplier);\n+            try {\n+                DefineFunctionUtils.getDefineFunctionMethodDeclaration(defineFunction);\n+            } catch (Exception e) {\n+                fail(String.format(\"Unexpected %s for %s\", e, defineFunction.getExpression().getClass()));\n+            }\n+        }\n+    }\n+\n+    @Test(expected = KiePMMLException.class)\n+    public void getDefineFunctionMethodDeclarationWithoutExpression() {\n+        DefineFunctionUtils.getDefineFunctionMethodDeclaration(new DefineFunction());\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void getExpressionMethodDeclarationUnknownExpression() {\n+        Expression expression = new Expression() {\n+            @Override\n+            public VisitorAction accept(Visitor visitor) {\n+                return null;\n+            }\n+        };\n+        DefineFunctionUtils.getExpressionMethodDeclaration(\"\", expression, Collections.emptyList());\n+    }\n+\n+    @Test\n+    public void getExpressionMethodDeclarationUnsupportedExpression() {\n+        for (Supplier<Expression> supplier : unsupportedExpressionSupplier) {\n+            Expression expression = supplier.get();\n+            try {\n+                DefineFunctionUtils.getExpressionMethodDeclaration(\"\", expression, Collections.emptyList());\n+                fail(String.format(\"Expecting KiePMMLException for %s\", expression.getClass()));\n+            } catch (Exception e) {\n+                assertTrue(e instanceof KiePMMLException);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTUyNDAxNA=="}, "originalCommit": {"oid": "37d5fb3d62a91ae32fa0205a3240dc0827b0538d"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMTk0MjU0OnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-compiler/kie-pmml-compiler-commons/src/test/java/org/kie/pmml/compiler/commons/utils/DefineFunctionUtilsTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMTowMjoxN1rOGssxWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMTo0ODoxNFrOGst2mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTUyNDA1OA==", "bodyText": "Same as above", "url": "https://github.com/kiegroup/drools/pull/2973#discussion_r449524058", "createdAt": "2020-07-03T11:02:17Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-trusty/kie-pmml-compiler/kie-pmml-compiler-commons/src/test/java/org/kie/pmml/compiler/commons/utils/DefineFunctionUtilsTest.java", "diffHunk": "@@ -0,0 +1,231 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.pmml.compiler.commons.utils;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import org.dmg.pmml.Aggregate;\n+import org.dmg.pmml.DefineFunction;\n+import org.dmg.pmml.Discretize;\n+import org.dmg.pmml.Expression;\n+import org.dmg.pmml.Lag;\n+import org.dmg.pmml.MapValues;\n+import org.dmg.pmml.NormContinuous;\n+import org.dmg.pmml.NormDiscrete;\n+import org.dmg.pmml.ParameterField;\n+import org.dmg.pmml.TextIndex;\n+import org.dmg.pmml.Visitor;\n+import org.dmg.pmml.VisitorAction;\n+import org.junit.Test;\n+import org.kie.pmml.commons.exceptions.KiePMMLException;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.kie.pmml.compiler.commons.testutils.PMMLModelTestUtils.getParameterFields;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtilsTest.applySupplier;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtilsTest.constantSupplier;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtilsTest.fieldRefSupplier;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtilsTest.supportedExpressionSupplier;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtilsTest.unsupportedExpressionSupplier;\n+import static org.kie.pmml.compiler.commons.utils.ModelUtils.getEventuallyBoxedClassName;\n+\n+public class DefineFunctionUtilsTest {\n+\n+    private static final Function<Supplier<Expression>, DefineFunction> defineFunctionCreator = supplier -> {\n+        Expression expression = supplier.get();\n+        DefineFunction defineFunction = new DefineFunction();\n+        defineFunction.setName(\"DEFINE_FUNCTION_\" + expression.getClass().getSimpleName());\n+        defineFunction.setExpression(expression);\n+        return defineFunction;\n+    };\n+\n+    @Test(expected = KiePMMLException.class)\n+    public void getDefineFunctionsMethodMapUnsupportedExpression() {\n+        List<DefineFunction> defineFunctions = unsupportedExpressionSupplier.stream().map(defineFunctionCreator).collect(Collectors.toList());\n+        DefineFunctionUtils.getDefineFunctionsMethodMap(defineFunctions);\n+    }\n+\n+    @Test\n+    public void getDefineFunctionsMethodMapSupportedExpression() {\n+        List<DefineFunction> defineFunctions = supportedExpressionSupplier.stream().map(defineFunctionCreator).collect(Collectors.toList());\n+        Map<String, MethodDeclaration> retrieved = DefineFunctionUtils.getDefineFunctionsMethodMap(defineFunctions);\n+        assertEquals(defineFunctions.size(), retrieved.size());\n+    }\n+\n+    @Test\n+    public void getDefineFunctionMethodDeclarationUnsupportedExpression() {\n+        for (Supplier<Expression> supplier : unsupportedExpressionSupplier) {\n+            DefineFunction defineFunction = defineFunctionCreator.apply(supplier);\n+            try {\n+                DefineFunctionUtils.getDefineFunctionMethodDeclaration(defineFunction);\n+                fail(String.format(\"Expecting KiePMMLException for %s\", defineFunction));\n+            } catch (Exception e) {\n+                assertTrue(e instanceof KiePMMLException);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void getDefineFunctionMethodDeclarationSupportedExpression() {\n+        for (Supplier<Expression> supplier : supportedExpressionSupplier) {\n+            DefineFunction defineFunction = defineFunctionCreator.apply(supplier);\n+            try {\n+                DefineFunctionUtils.getDefineFunctionMethodDeclaration(defineFunction);\n+            } catch (Exception e) {\n+                fail(String.format(\"Unexpected %s for %s\", e, defineFunction.getExpression().getClass()));\n+            }\n+        }\n+    }\n+\n+    @Test(expected = KiePMMLException.class)\n+    public void getDefineFunctionMethodDeclarationWithoutExpression() {\n+        DefineFunctionUtils.getDefineFunctionMethodDeclaration(new DefineFunction());\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void getExpressionMethodDeclarationUnknownExpression() {\n+        Expression expression = new Expression() {\n+            @Override\n+            public VisitorAction accept(Visitor visitor) {\n+                return null;\n+            }\n+        };\n+        DefineFunctionUtils.getExpressionMethodDeclaration(\"\", expression, Collections.emptyList());\n+    }\n+\n+    @Test\n+    public void getExpressionMethodDeclarationUnsupportedExpression() {\n+        for (Supplier<Expression> supplier : unsupportedExpressionSupplier) {\n+            Expression expression = supplier.get();\n+            try {\n+                DefineFunctionUtils.getExpressionMethodDeclaration(\"\", expression, Collections.emptyList());\n+                fail(String.format(\"Expecting KiePMMLException for %s\", expression.getClass()));\n+            } catch (Exception e) {\n+                assertTrue(e instanceof KiePMMLException);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void getExpressionMethodDeclarationSupportedExpression() {\n+        for (Supplier<Expression> supplier : supportedExpressionSupplier) {\n+            Expression expression = supplier.get();\n+            try {\n+                DefineFunctionUtils.getExpressionMethodDeclaration(\"METHOD_NAME\", expression, Collections.emptyList());\n+            } catch (Exception e) {\n+                fail(String.format(\"Unexpected %s for %s\", e, expression.getClass()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37d5fb3d62a91ae32fa0205a3240dc0827b0538d"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU0MTc4Nw==", "bodyText": "@danielezonca\nsee above", "url": "https://github.com/kiegroup/drools/pull/2973#discussion_r449541787", "createdAt": "2020-07-03T11:48:14Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-trusty/kie-pmml-compiler/kie-pmml-compiler-commons/src/test/java/org/kie/pmml/compiler/commons/utils/DefineFunctionUtilsTest.java", "diffHunk": "@@ -0,0 +1,231 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.pmml.compiler.commons.utils;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import org.dmg.pmml.Aggregate;\n+import org.dmg.pmml.DefineFunction;\n+import org.dmg.pmml.Discretize;\n+import org.dmg.pmml.Expression;\n+import org.dmg.pmml.Lag;\n+import org.dmg.pmml.MapValues;\n+import org.dmg.pmml.NormContinuous;\n+import org.dmg.pmml.NormDiscrete;\n+import org.dmg.pmml.ParameterField;\n+import org.dmg.pmml.TextIndex;\n+import org.dmg.pmml.Visitor;\n+import org.dmg.pmml.VisitorAction;\n+import org.junit.Test;\n+import org.kie.pmml.commons.exceptions.KiePMMLException;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.kie.pmml.compiler.commons.testutils.PMMLModelTestUtils.getParameterFields;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtilsTest.applySupplier;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtilsTest.constantSupplier;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtilsTest.fieldRefSupplier;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtilsTest.supportedExpressionSupplier;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtilsTest.unsupportedExpressionSupplier;\n+import static org.kie.pmml.compiler.commons.utils.ModelUtils.getEventuallyBoxedClassName;\n+\n+public class DefineFunctionUtilsTest {\n+\n+    private static final Function<Supplier<Expression>, DefineFunction> defineFunctionCreator = supplier -> {\n+        Expression expression = supplier.get();\n+        DefineFunction defineFunction = new DefineFunction();\n+        defineFunction.setName(\"DEFINE_FUNCTION_\" + expression.getClass().getSimpleName());\n+        defineFunction.setExpression(expression);\n+        return defineFunction;\n+    };\n+\n+    @Test(expected = KiePMMLException.class)\n+    public void getDefineFunctionsMethodMapUnsupportedExpression() {\n+        List<DefineFunction> defineFunctions = unsupportedExpressionSupplier.stream().map(defineFunctionCreator).collect(Collectors.toList());\n+        DefineFunctionUtils.getDefineFunctionsMethodMap(defineFunctions);\n+    }\n+\n+    @Test\n+    public void getDefineFunctionsMethodMapSupportedExpression() {\n+        List<DefineFunction> defineFunctions = supportedExpressionSupplier.stream().map(defineFunctionCreator).collect(Collectors.toList());\n+        Map<String, MethodDeclaration> retrieved = DefineFunctionUtils.getDefineFunctionsMethodMap(defineFunctions);\n+        assertEquals(defineFunctions.size(), retrieved.size());\n+    }\n+\n+    @Test\n+    public void getDefineFunctionMethodDeclarationUnsupportedExpression() {\n+        for (Supplier<Expression> supplier : unsupportedExpressionSupplier) {\n+            DefineFunction defineFunction = defineFunctionCreator.apply(supplier);\n+            try {\n+                DefineFunctionUtils.getDefineFunctionMethodDeclaration(defineFunction);\n+                fail(String.format(\"Expecting KiePMMLException for %s\", defineFunction));\n+            } catch (Exception e) {\n+                assertTrue(e instanceof KiePMMLException);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void getDefineFunctionMethodDeclarationSupportedExpression() {\n+        for (Supplier<Expression> supplier : supportedExpressionSupplier) {\n+            DefineFunction defineFunction = defineFunctionCreator.apply(supplier);\n+            try {\n+                DefineFunctionUtils.getDefineFunctionMethodDeclaration(defineFunction);\n+            } catch (Exception e) {\n+                fail(String.format(\"Unexpected %s for %s\", e, defineFunction.getExpression().getClass()));\n+            }\n+        }\n+    }\n+\n+    @Test(expected = KiePMMLException.class)\n+    public void getDefineFunctionMethodDeclarationWithoutExpression() {\n+        DefineFunctionUtils.getDefineFunctionMethodDeclaration(new DefineFunction());\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void getExpressionMethodDeclarationUnknownExpression() {\n+        Expression expression = new Expression() {\n+            @Override\n+            public VisitorAction accept(Visitor visitor) {\n+                return null;\n+            }\n+        };\n+        DefineFunctionUtils.getExpressionMethodDeclaration(\"\", expression, Collections.emptyList());\n+    }\n+\n+    @Test\n+    public void getExpressionMethodDeclarationUnsupportedExpression() {\n+        for (Supplier<Expression> supplier : unsupportedExpressionSupplier) {\n+            Expression expression = supplier.get();\n+            try {\n+                DefineFunctionUtils.getExpressionMethodDeclaration(\"\", expression, Collections.emptyList());\n+                fail(String.format(\"Expecting KiePMMLException for %s\", expression.getClass()));\n+            } catch (Exception e) {\n+                assertTrue(e instanceof KiePMMLException);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void getExpressionMethodDeclarationSupportedExpression() {\n+        for (Supplier<Expression> supplier : supportedExpressionSupplier) {\n+            Expression expression = supplier.get();\n+            try {\n+                DefineFunctionUtils.getExpressionMethodDeclaration(\"METHOD_NAME\", expression, Collections.emptyList());\n+            } catch (Exception e) {\n+                fail(String.format(\"Unexpected %s for %s\", e, expression.getClass()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTUyNDA1OA=="}, "originalCommit": {"oid": "37d5fb3d62a91ae32fa0205a3240dc0827b0538d"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMjI1MTE0OnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-compiler/kie-pmml-compiler-commons/src/main/java/org/kie/pmml/compiler/commons/utils/DefineFunctionUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMzowMToxN1rOGsvsZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMzowMToxN1rOGsvsZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3MTk0Mw==", "bodyText": "I still don't like such long lines. Can we split this stream to multiple lines?", "url": "https://github.com/kiegroup/drools/pull/2973#discussion_r449571943", "createdAt": "2020-07-03T13:01:17Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-trusty/kie-pmml-compiler/kie-pmml-compiler-commons/src/main/java/org/kie/pmml/compiler/commons/utils/DefineFunctionUtils.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.compiler.commons.utils;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import org.dmg.pmml.Aggregate;\n+import org.dmg.pmml.Apply;\n+import org.dmg.pmml.Constant;\n+import org.dmg.pmml.DefineFunction;\n+import org.dmg.pmml.Discretize;\n+import org.dmg.pmml.Expression;\n+import org.dmg.pmml.FieldRef;\n+import org.dmg.pmml.Lag;\n+import org.dmg.pmml.MapValues;\n+import org.dmg.pmml.NormContinuous;\n+import org.dmg.pmml.NormDiscrete;\n+import org.dmg.pmml.ParameterField;\n+import org.dmg.pmml.TextIndex;\n+import org.kie.pmml.commons.exceptions.KiePMMLException;\n+import org.kie.pmml.commons.model.tuples.KiePMMLNameValue;\n+\n+import static com.github.javaparser.StaticJavaParser.parseClassOrInterfaceType;\n+import static org.kie.pmml.compiler.commons.utils.CommonCodegenUtils.getTypedClassOrInterfaceType;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtils.getApplyExpressionMethodDeclaration;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtils.getConstantExpressionMethodDeclaration;\n+import static org.kie.pmml.compiler.commons.utils.ExpressionFunctionUtils.getFieldRefExpressionMethodDeclaration;\n+\n+/**\n+ * Class meant to provide <i>helper</i> methods to retrieve <code>Function</code> code-generators\n+ * out of <code>DefineFunction</code>s\n+ */\n+public class DefineFunctionUtils {\n+\n+    private DefineFunctionUtils() {\n+        // Avoid instantiation\n+    }\n+\n+    static Map<String, MethodDeclaration> getDefineFunctionsMethodMap(final List<DefineFunction> defineFunctions) {\n+        Map<String, MethodDeclaration> toReturn = new HashMap<>();\n+        defineFunctions.forEach(defineFunction ->\n+                                        toReturn.put(defineFunction.getName(),\n+                                                     getDefineFunctionMethodDeclaration(defineFunction)));\n+        return toReturn;\n+    }\n+\n+    static MethodDeclaration getDefineFunctionMethodDeclaration(final DefineFunction defineFunction) {\n+        final Expression expression = defineFunction.getExpression();\n+        if (expression != null) {\n+            return getExpressionMethodDeclaration(defineFunction.getName(), expression, defineFunction.getParameterFields());\n+        } else {\n+            throw new KiePMMLException(\"Define Function without Expression are not supported, yet\");\n+        }\n+    }\n+\n+    /**\n+     * @param methodName\n+     * @param expression\n+     * @param parameterFields\n+     * @return\n+     */\n+    static MethodDeclaration getExpressionMethodDeclaration(final String methodName, final Expression expression, List<ParameterField> parameterFields) {\n+        List<ClassOrInterfaceType> parametersClassOrInterfaces = getClassOrInterfaceTypes(parameterFields);\n+        parametersClassOrInterfaces.add(0, getTypedClassOrInterfaceType(List.class.getName(), Collections.singletonList(KiePMMLNameValue.class.getName())));\n+        if (expression instanceof Aggregate) {\n+            return getAggregatedMethodDeclaration(methodName, (Aggregate) expression, parametersClassOrInterfaces);\n+        } else if (expression instanceof Apply) {\n+            return getApplyMethodDeclaration(methodName, (Apply) expression, parametersClassOrInterfaces);\n+        } else if (expression instanceof Constant) {\n+            return getConstantMethodDeclaration(methodName, (Constant) expression, parametersClassOrInterfaces);\n+        } else if (expression instanceof Discretize) {\n+            return getDiscretizeMethodDeclaration(methodName, (Discretize) expression, parametersClassOrInterfaces);\n+        } else if (expression instanceof FieldRef) {\n+            return getFieldRefMethodDeclaration(methodName, (FieldRef) expression, parametersClassOrInterfaces);\n+        } else if (expression instanceof Lag) {\n+            return getLagMethodDeclaration(methodName, (Lag) expression, parametersClassOrInterfaces);\n+        } else if (expression instanceof MapValues) {\n+            return getMapValuesMethodDeclaration(methodName, (MapValues) expression, parametersClassOrInterfaces);\n+        } else if (expression instanceof NormContinuous) {\n+            return getNormContinuousMethodDeclaration(methodName, (NormContinuous) expression, parametersClassOrInterfaces);\n+        } else if (expression instanceof NormDiscrete) {\n+            return getNormDiscreteMethodDeclaration(methodName, (NormDiscrete) expression, parametersClassOrInterfaces);\n+        } else if (expression instanceof TextIndex) {\n+            return getTextIndexMethodDeclaration(methodName, (TextIndex) expression, parametersClassOrInterfaces);\n+        } else {\n+            throw new IllegalArgumentException(String.format(\"Expression %s not managed\", expression.getClass()));\n+        }\n+    }\n+\n+    /**\n+     * @param methodName\n+     * @param aggregate\n+     * @param parameterFields\n+     * @return\n+     */\n+    static MethodDeclaration getAggregatedMethodDeclaration(final String methodName, final Aggregate aggregate, List<ClassOrInterfaceType> parameterFields) {\n+        throw new KiePMMLException(\"Aggregate not managed, yet\");\n+    }\n+\n+    /**\n+     * @param methodName\n+     * @param apply\n+     * @param parameterFields\n+     * @return\n+     */\n+    static MethodDeclaration getApplyMethodDeclaration(final String methodName, final Apply apply, List<ClassOrInterfaceType> parameterFields) {\n+        return getApplyExpressionMethodDeclaration(methodName, apply, parameterFields);\n+    }\n+\n+    /**\n+     * Return\n+     * <pre>\n+     *     (<i>constant_type</i>) constant(<i>methodArity</i>))(List<KiePMMLNameValue> param1) {\n+     *     return (<i>constant_value</i>);\n+     * }\n+     * </pre>\n+     * e.g.\n+     * <pre>\n+     *     double constant10(java.util.List<org.kie.pmml.commons.model.tuples.KiePMMLNameValue> param1) {\n+     *     return 34.6;\n+     * }\n+     * </pre>\n+     * @param methodName\n+     * @param constant\n+     * @param parameterFields\n+     * @return\n+     */\n+    static MethodDeclaration getConstantMethodDeclaration(final String methodName, final Constant constant, List<ClassOrInterfaceType> parameterFields) {\n+        return getConstantExpressionMethodDeclaration(methodName, constant, parameterFields);\n+    }\n+\n+    /**\n+     * @param methodName\n+     * @param discretize\n+     * @param parameterFields\n+     * @return\n+     */\n+    static MethodDeclaration getDiscretizeMethodDeclaration(final String methodName, final Discretize discretize, List<ClassOrInterfaceType> parameterFields) {\n+        throw new KiePMMLException(\"Discretize not managed, yet\");\n+    }\n+\n+    /**\n+     * Returns\n+     * <pre>\n+     * Object FieldRef(<i>methodArity</i>)(java.util.List<KiePMMLNameValue> param1) {\n+     *      Optional<KiePMMLNameValue> kiePMMLNameValue = param1.stream().filter((KiePMMLNameValue lmbdParam) -> Objects.equals(<i>(FieldRef_name)</i>, lmbdParam.getName())).findFirst();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0aa6b069153c5cf498fe4452215f0a75af662988"}, "originalPosition": 165}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMjI1NDEwOnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-compiler/kie-pmml-compiler-commons/src/main/java/org/kie/pmml/compiler/commons/utils/ExpressionFunctionUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMzowMjoyNVrOGsvuLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMzowNjo0NlrOGsv1nQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3MjM5OA==", "bodyText": "Please split to multiple lines.", "url": "https://github.com/kiegroup/drools/pull/2973#discussion_r449572398", "createdAt": "2020-07-03T13:02:25Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-trusty/kie-pmml-compiler/kie-pmml-compiler-commons/src/main/java/org/kie/pmml/compiler/commons/utils/ExpressionFunctionUtils.java", "diffHunk": "@@ -162,95 +393,110 @@ static MethodDeclaration getFieldRefExpressionMethodDeclaration(final String met\n         // kiePMMLNameValue.map(KiePMMLNameValue::getValue).orElse( (fieldRef.getMapMissingTo() )\n         MethodCallExpr expression = new MethodCallExpr(\"orElse\");\n         expression.setScope(expressionScope);\n-        com.github.javaparser.ast.expr.Expression orElseExpression =  fieldRef.getMapMissingTo() != null ? new StringLiteralExpr(fieldRef.getMapMissingTo()) : new NullLiteralExpr();\n+        com.github.javaparser.ast.expr.Expression orElseExpression = fieldRef.getMapMissingTo() != null ? new StringLiteralExpr(fieldRef.getMapMissingTo()) : new NullLiteralExpr();\n         expression.setArguments(NodeList.nodeList(orElseExpression));\n \n-        // return kiePMMLNameValue.map(KiePMMLNameValue::getValue).orElse( (fieldRef.getMapMissingTo() )\n-        ReturnStmt returnStmt = new ReturnStmt();\n-        returnStmt.setExpression(expression);\n-        body.addStatement(returnStmt);\n-        MethodDeclaration toReturn = getExpressionMethodDeclaration(methodName, parameterTypes);\n+        // Object variableName = kiePMMLNameValue.map(KiePMMLNameValue::getValue).orElse( (fieldRef.getMapMissingTo() )\n+        VariableDeclarator variableDeclarator = new VariableDeclarator();\n         ClassOrInterfaceType classOrInterfaceType = parseClassOrInterfaceType(Object.class.getName());\n-        toReturn.setType(classOrInterfaceType);\n-        toReturn.setBody(body);\n+        variableDeclarator.setType(classOrInterfaceType);\n+        variableDeclarator.setName(variableName);\n+        variableDeclarator.setInitializer(expression);\n+        VariableDeclarationExpr variableDeclarationExpr = new VariableDeclarationExpr();\n+        variableDeclarationExpr.setVariables(NodeList.nodeList(variableDeclarator));\n+        toReturn.addStatement(variableDeclarationExpr);\n+\n         return toReturn;\n     }\n \n     /**\n-     * \n-     * @param methodName\n+     *\n+     * @param variableName\n      * @param lag\n+     * @param returnedType\n      * @param parameterTypes\n      * @return\n      */\n-    static MethodDeclaration getLagExpressionMethodDeclaration(final String methodName, final Lag lag, final List<ClassOrInterfaceType> parameterTypes) {\n-        MethodDeclaration toReturn = getExpressionMethodDeclaration(methodName, parameterTypes);\n-        return toReturn;\n+    static BlockStmt getLagExpressionBlockStmt(final String variableName, final Lag lag,  final ClassOrInterfaceType returnedType, final List<ClassOrInterfaceType> parameterTypes) {\n+        throw new KiePMMLException(\"Lag not managed, yet\");\n     }\n \n     /**\n-     * \n-     * @param methodName\n+     *\n+     * @param variableName\n      * @param mapValues\n+     * @param returnedType\n      * @param parameterTypes\n      * @return\n      */\n-    static MethodDeclaration getMapValuesExpressionMethodDeclaration(final String methodName, final MapValues mapValues, final List<ClassOrInterfaceType> parameterTypes) {\n-        MethodDeclaration toReturn = getExpressionMethodDeclaration(methodName, parameterTypes);\n-        return toReturn;\n+    static BlockStmt getMapValuesExpressionBlockStmt(final String variableName, final MapValues mapValues,  final ClassOrInterfaceType returnedType, final List<ClassOrInterfaceType> parameterTypes) {\n+        throw new KiePMMLException(\"MapValues not managed, yet\");\n     }\n \n     /**\n-     * \n-     * @param methodName\n+     *\n+     * @param variableName\n      * @param normContinuous\n+     * @param returnedType\n      * @param parameterTypes\n      * @return\n      */\n-    static MethodDeclaration getNormContinuousExpressionMethodDeclaration(final String methodName, final NormContinuous normContinuous, final List<ClassOrInterfaceType> parameterTypes) {\n-        MethodDeclaration toReturn = getExpressionMethodDeclaration(methodName, parameterTypes);\n-        return toReturn;\n+    static BlockStmt getNormContinuousExpressionBlockStmt(final String variableName, final NormContinuous normContinuous,  final ClassOrInterfaceType returnedType, final List<ClassOrInterfaceType> parameterTypes) {\n+        throw new KiePMMLException(\"NormContinuous not managed, yet\");\n     }\n \n     /**\n-     * \n-     * @param methodName\n+     *\n+     *\n+     * @param variableName\n      * @param normDiscrete\n+     * @param returnedType\n      * @param parameterTypes\n      * @return\n      */\n-    static MethodDeclaration getNormDiscreteExpressionMethodDeclaration(final String methodName, final NormDiscrete normDiscrete, final List<ClassOrInterfaceType> parameterTypes) {\n-        MethodDeclaration toReturn = getExpressionMethodDeclaration(methodName, parameterTypes);\n-        return toReturn;\n+    static BlockStmt getNormDiscreteExpressionBlockStmt(final String variableName, final NormDiscrete normDiscrete, final ClassOrInterfaceType returnedType,  final List<ClassOrInterfaceType> parameterTypes) {\n+        throw new KiePMMLException(\"NormDiscrete not managed, yet\");\n     }\n \n     /**\n-     * \n-     * @param methodName\n+     *\n+     * @param variableName\n      * @param textIndex\n+     * @param returnedType\n      * @param parameterTypes\n      * @return\n      */\n-    static MethodDeclaration getTextIndexExpressionMethodDeclaration(final String methodName, final TextIndex textIndex, final List<ClassOrInterfaceType> parameterTypes) {\n-        MethodDeclaration toReturn = getExpressionMethodDeclaration(methodName, parameterTypes);\n-        return toReturn;\n+    static BlockStmt getTextIndexExpressionBlockStmt(final String variableName, final TextIndex textIndex,  final ClassOrInterfaceType returnedType, final List<ClassOrInterfaceType> parameterTypes) {\n+        throw new KiePMMLException(\"TextIndex not managed, yet\");\n     }\n \n-\n     /**\n      * Return\n      * <pre>\n-     *     empty  methodName(List<KiePMMLNameValue> param1) {\n+     *     (<i>returnedType</i>)  (<i>methodName</i>)(List<KiePMMLNameValue> param1) {\n+     *              <i>body</i>\n+     *              return <i>variableName</i>;\n      *     }\n      * </pre>\n-     * \n      * @param methodName\n      * @param parameterTypes\n      * @return\n      */\n-    static MethodDeclaration getExpressionMethodDeclaration(final String methodName, final List<ClassOrInterfaceType> parameterTypes) {\n-        return getMethodDeclaration(methodName, parameterTypes);\n+    /**\n+     *\n+     * @param methodName\n+     * @param variableName\n+     * @param body\n+     * @param returnedType\n+     * @param parameterTypes\n+     * @return\n+     */\n+    static MethodDeclaration getExpressionMethodDeclaration(final String methodName, final String variableName, final BlockStmt body, final ClassOrInterfaceType returnedType, final List<ClassOrInterfaceType> parameterTypes) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0aa6b069153c5cf498fe4452215f0a75af662988"}, "originalPosition": 538}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3NDMwMQ==", "bodyText": "@jiripetrlik\nFixing in new Ticket", "url": "https://github.com/kiegroup/drools/pull/2973#discussion_r449574301", "createdAt": "2020-07-03T13:06:46Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-trusty/kie-pmml-compiler/kie-pmml-compiler-commons/src/main/java/org/kie/pmml/compiler/commons/utils/ExpressionFunctionUtils.java", "diffHunk": "@@ -162,95 +393,110 @@ static MethodDeclaration getFieldRefExpressionMethodDeclaration(final String met\n         // kiePMMLNameValue.map(KiePMMLNameValue::getValue).orElse( (fieldRef.getMapMissingTo() )\n         MethodCallExpr expression = new MethodCallExpr(\"orElse\");\n         expression.setScope(expressionScope);\n-        com.github.javaparser.ast.expr.Expression orElseExpression =  fieldRef.getMapMissingTo() != null ? new StringLiteralExpr(fieldRef.getMapMissingTo()) : new NullLiteralExpr();\n+        com.github.javaparser.ast.expr.Expression orElseExpression = fieldRef.getMapMissingTo() != null ? new StringLiteralExpr(fieldRef.getMapMissingTo()) : new NullLiteralExpr();\n         expression.setArguments(NodeList.nodeList(orElseExpression));\n \n-        // return kiePMMLNameValue.map(KiePMMLNameValue::getValue).orElse( (fieldRef.getMapMissingTo() )\n-        ReturnStmt returnStmt = new ReturnStmt();\n-        returnStmt.setExpression(expression);\n-        body.addStatement(returnStmt);\n-        MethodDeclaration toReturn = getExpressionMethodDeclaration(methodName, parameterTypes);\n+        // Object variableName = kiePMMLNameValue.map(KiePMMLNameValue::getValue).orElse( (fieldRef.getMapMissingTo() )\n+        VariableDeclarator variableDeclarator = new VariableDeclarator();\n         ClassOrInterfaceType classOrInterfaceType = parseClassOrInterfaceType(Object.class.getName());\n-        toReturn.setType(classOrInterfaceType);\n-        toReturn.setBody(body);\n+        variableDeclarator.setType(classOrInterfaceType);\n+        variableDeclarator.setName(variableName);\n+        variableDeclarator.setInitializer(expression);\n+        VariableDeclarationExpr variableDeclarationExpr = new VariableDeclarationExpr();\n+        variableDeclarationExpr.setVariables(NodeList.nodeList(variableDeclarator));\n+        toReturn.addStatement(variableDeclarationExpr);\n+\n         return toReturn;\n     }\n \n     /**\n-     * \n-     * @param methodName\n+     *\n+     * @param variableName\n      * @param lag\n+     * @param returnedType\n      * @param parameterTypes\n      * @return\n      */\n-    static MethodDeclaration getLagExpressionMethodDeclaration(final String methodName, final Lag lag, final List<ClassOrInterfaceType> parameterTypes) {\n-        MethodDeclaration toReturn = getExpressionMethodDeclaration(methodName, parameterTypes);\n-        return toReturn;\n+    static BlockStmt getLagExpressionBlockStmt(final String variableName, final Lag lag,  final ClassOrInterfaceType returnedType, final List<ClassOrInterfaceType> parameterTypes) {\n+        throw new KiePMMLException(\"Lag not managed, yet\");\n     }\n \n     /**\n-     * \n-     * @param methodName\n+     *\n+     * @param variableName\n      * @param mapValues\n+     * @param returnedType\n      * @param parameterTypes\n      * @return\n      */\n-    static MethodDeclaration getMapValuesExpressionMethodDeclaration(final String methodName, final MapValues mapValues, final List<ClassOrInterfaceType> parameterTypes) {\n-        MethodDeclaration toReturn = getExpressionMethodDeclaration(methodName, parameterTypes);\n-        return toReturn;\n+    static BlockStmt getMapValuesExpressionBlockStmt(final String variableName, final MapValues mapValues,  final ClassOrInterfaceType returnedType, final List<ClassOrInterfaceType> parameterTypes) {\n+        throw new KiePMMLException(\"MapValues not managed, yet\");\n     }\n \n     /**\n-     * \n-     * @param methodName\n+     *\n+     * @param variableName\n      * @param normContinuous\n+     * @param returnedType\n      * @param parameterTypes\n      * @return\n      */\n-    static MethodDeclaration getNormContinuousExpressionMethodDeclaration(final String methodName, final NormContinuous normContinuous, final List<ClassOrInterfaceType> parameterTypes) {\n-        MethodDeclaration toReturn = getExpressionMethodDeclaration(methodName, parameterTypes);\n-        return toReturn;\n+    static BlockStmt getNormContinuousExpressionBlockStmt(final String variableName, final NormContinuous normContinuous,  final ClassOrInterfaceType returnedType, final List<ClassOrInterfaceType> parameterTypes) {\n+        throw new KiePMMLException(\"NormContinuous not managed, yet\");\n     }\n \n     /**\n-     * \n-     * @param methodName\n+     *\n+     *\n+     * @param variableName\n      * @param normDiscrete\n+     * @param returnedType\n      * @param parameterTypes\n      * @return\n      */\n-    static MethodDeclaration getNormDiscreteExpressionMethodDeclaration(final String methodName, final NormDiscrete normDiscrete, final List<ClassOrInterfaceType> parameterTypes) {\n-        MethodDeclaration toReturn = getExpressionMethodDeclaration(methodName, parameterTypes);\n-        return toReturn;\n+    static BlockStmt getNormDiscreteExpressionBlockStmt(final String variableName, final NormDiscrete normDiscrete, final ClassOrInterfaceType returnedType,  final List<ClassOrInterfaceType> parameterTypes) {\n+        throw new KiePMMLException(\"NormDiscrete not managed, yet\");\n     }\n \n     /**\n-     * \n-     * @param methodName\n+     *\n+     * @param variableName\n      * @param textIndex\n+     * @param returnedType\n      * @param parameterTypes\n      * @return\n      */\n-    static MethodDeclaration getTextIndexExpressionMethodDeclaration(final String methodName, final TextIndex textIndex, final List<ClassOrInterfaceType> parameterTypes) {\n-        MethodDeclaration toReturn = getExpressionMethodDeclaration(methodName, parameterTypes);\n-        return toReturn;\n+    static BlockStmt getTextIndexExpressionBlockStmt(final String variableName, final TextIndex textIndex,  final ClassOrInterfaceType returnedType, final List<ClassOrInterfaceType> parameterTypes) {\n+        throw new KiePMMLException(\"TextIndex not managed, yet\");\n     }\n \n-\n     /**\n      * Return\n      * <pre>\n-     *     empty  methodName(List<KiePMMLNameValue> param1) {\n+     *     (<i>returnedType</i>)  (<i>methodName</i>)(List<KiePMMLNameValue> param1) {\n+     *              <i>body</i>\n+     *              return <i>variableName</i>;\n      *     }\n      * </pre>\n-     * \n      * @param methodName\n      * @param parameterTypes\n      * @return\n      */\n-    static MethodDeclaration getExpressionMethodDeclaration(final String methodName, final List<ClassOrInterfaceType> parameterTypes) {\n-        return getMethodDeclaration(methodName, parameterTypes);\n+    /**\n+     *\n+     * @param methodName\n+     * @param variableName\n+     * @param body\n+     * @param returnedType\n+     * @param parameterTypes\n+     * @return\n+     */\n+    static MethodDeclaration getExpressionMethodDeclaration(final String methodName, final String variableName, final BlockStmt body, final ClassOrInterfaceType returnedType, final List<ClassOrInterfaceType> parameterTypes) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3MjM5OA=="}, "originalCommit": {"oid": "0aa6b069153c5cf498fe4452215f0a75af662988"}, "originalPosition": 538}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2372, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}