{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY3MjQxOTgw", "number": 3041, "reviewThreads": {"totalCount": 35, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwOTowMTo0OVrOEX9muw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMjoxMToyNFrOEdMU4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNTYyMDQzOnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/main/java/org/kie/pmml/models/regression/compiler/factories/KiePMMLRegressionTableClassificationFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwOTowMTo0OVrOHACm9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwOTowMTo0OVrOHACm9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwNDc5MA==", "bodyText": "To be removed", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r469804790", "createdAt": "2020-08-13T09:01:49Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/main/java/org/kie/pmml/models/regression/compiler/factories/KiePMMLRegressionTableClassificationFactory.java", "diffHunk": "@@ -71,31 +74,29 @@ private KiePMMLRegressionTableClassificationFactory() {\n \n     public static Map<String, KiePMMLTableSourceCategory> getRegressionTables(final List<RegressionTable> regressionTables, final RegressionModel.NormalizationMethod normalizationMethod, final OpType opType, final List<KiePMMLOutputField> outputFields, final String targetField, final String packageName) throws IOException {\n         logger.trace(\"getRegressionTables {}\", regressionTables);\n-        CompilationUnit templateCU = getFromFileName(KIE_PMML_REGRESSION_TABLE_CLASSIFICATION_TEMPLATE_JAVA);\n         Map<String, KiePMMLTableSourceCategory> toReturn = KiePMMLRegressionTableRegressionFactory.getRegressionTables(regressionTables, RegressionModel.NormalizationMethod.NONE, targetField, packageName);\n-        Map.Entry<String, String> regressionTableEntry = getRegressionTable(templateCU, toReturn, normalizationMethod, opType, outputFields, targetField, packageName);\n+        Map.Entry<String, String> regressionTableEntry = getRegressionTable(toReturn, normalizationMethod, opType, outputFields, targetField, packageName);\n         toReturn.put(regressionTableEntry.getKey(), new KiePMMLTableSourceCategory(regressionTableEntry.getValue(), \"\"));\n         return toReturn;\n     }\n \n-    public static Map.Entry<String, String> getRegressionTable(final CompilationUnit templateCU, final Map<String, KiePMMLTableSourceCategory> regressionTablesMap, final RegressionModel.NormalizationMethod normalizationMethod, final OpType opType, final List<KiePMMLOutputField> outputFields, final String targetField, final String packageName) throws IOException {\n+    public static Map.Entry<String, String> getRegressionTable(final Map<String, KiePMMLTableSourceCategory> regressionTablesMap, final RegressionModel.NormalizationMethod normalizationMethod, final OpType opType, final List<KiePMMLOutputField> outputFields, final String targetField, final String packageName) throws IOException {\n         logger.trace(\"getRegressionTable {}\", regressionTablesMap);\n-        CompilationUnit cloneCU = templateCU.clone();\n-        cloneCU.setPackageDeclaration(packageName);\n+        String className = \"KiePMMLRegressionTableClassification\" + classArity.addAndGet(1);\n+        CompilationUnit cloneCU = JavaParserUtils.getKiePMMLModelCompilationUnit(className, packageName, KIE_PMML_REGRESSION_TABLE_CLASSIFICATION_TEMPLATE_JAVA, KIE_PMML_REGRESSION_TABLE_CLASSIFICATION_TEMPLATE);\n+        ClassOrInterfaceDeclaration tableTemplate = cloneCU.getClassByName(className)\n+                .orElseThrow(() -> new KiePMMLException(MAIN_CLASS_NOT_FOUND + \": \" + className));\n         final REGRESSION_NORMALIZATION_METHOD regressionNormalizationMethod = REGRESSION_NORMALIZATION_METHOD.byName(normalizationMethod.value());\n         final OP_TYPE op_type = opType != null ? OP_TYPE.byName(opType.value()) : null;\n-        ClassOrInterfaceDeclaration tableTemplate = cloneCU.getClassByName(KIE_PMML_REGRESSION_TABLE_CLASSIFICATION_TEMPLATE)\n-                .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n-        String className = \"KiePMMLRegressionTableClassification\" + classArity.addAndGet(1);\n-        tableTemplate.setName(className);\n         populateGetProbabilityMapMethod(normalizationMethod, tableTemplate);\n         populateOutputFieldsMap(tableTemplate, outputFields);\n         populateIsBinaryMethod(opType, regressionTablesMap.size(), tableTemplate);\n         final ConstructorDeclaration constructorDeclaration = tableTemplate.getDefaultConstructor().orElseThrow(() -> new KiePMMLInternalException(String.format(\"Missing default constructor in ClassOrInterfaceDeclaration %s \", tableTemplate.getName())));\n         setConstructor(constructorDeclaration, tableTemplate.getName(), targetField, regressionNormalizationMethod, op_type);\n         addMapPopulation(constructorDeclaration.getBody(), regressionTablesMap);\n         populateGetTargetCategory(tableTemplate, null);\n-        return new AbstractMap.SimpleEntry<>(className, cloneCU.toString());\n+//        return new AbstractMap.SimpleEntry<>(className, cloneCU.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7156fd4086c74609bdf25f73eefa5069064ce44f"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNTYyMTQ0OnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/main/java/org/kie/pmml/models/regression/compiler/factories/KiePMMLRegressionTableRegressionFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwOTowMjoxMFrOHACnpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwOTowMjoxMFrOHACnpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwNDk2Nw==", "bodyText": "To be removed", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r469804967", "createdAt": "2020-08-13T09:02:10Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/main/java/org/kie/pmml/models/regression/compiler/factories/KiePMMLRegressionTableRegressionFactory.java", "diffHunk": "@@ -107,7 +107,8 @@ private KiePMMLRegressionTableRegressionFactory() {\n         addMapPopulation(predictorTermsMap, body, \"predictorTermsFunctionMap\");\n         populateGetTargetCategory(tableTemplate, regressionTable.getTargetCategory());\n         populateUpdateResult(tableTemplate, normalizationMethod);\n-        return new AbstractMap.SimpleEntry<>(className, cloneCU.toString());\n+//        return new AbstractMap.SimpleEntry<>(className, cloneCU.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7156fd4086c74609bdf25f73eefa5069064ce44f"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNTYzMDE2OnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/test/java/org/kie/pmml/models/regression/compiler/executor/RegressionModelImplementationProviderTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwOTowNDozMFrOHACszQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMDoxNzo1N1rOHFd6xA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwNjI4NQ==", "bodyText": "Is this needed? The test fails even if you just throws the Exception so why wrap it in a fail?\nDon't you want to print the stacktrace?", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r469806285", "createdAt": "2020-08-13T09:04:30Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/test/java/org/kie/pmml/models/regression/compiler/executor/RegressionModelImplementationProviderTest.java", "diffHunk": "@@ -46,8 +52,33 @@ public void getKiePMMLModel() throws Exception {\n         assertNotNull(pmml);\n         assertEquals(1, pmml.getModels().size());\n         assertTrue(pmml.getModels().get(0) instanceof RegressionModel);\n-        final KiePMMLRegressionModel kiePMMLModel = PROVIDER.getKiePMMLModel(pmml.getDataDictionary(), pmml.getTransformationDictionary(), (RegressionModel) pmml.getModels().get(0), RELEASE_ID);\n-        assertNotNull(kiePMMLModel);\n+        final KiePMMLRegressionModel retrieved = PROVIDER.getKiePMMLModel(pmml.getDataDictionary(), pmml.getTransformationDictionary(), (RegressionModel) pmml.getModels().get(0), RELEASE_ID);\n+        assertNotNull(retrieved);\n+    }\n+\n+    @Test\n+    public void getKiePMMLModelFromPlugin() throws Exception {\n+        final PMML pmml = TestUtils.loadFromFile(SOURCE_1);\n+        assertNotNull(pmml);\n+        assertEquals(1, pmml.getModels().size());\n+        assertTrue(pmml.getModels().get(0) instanceof RegressionModel);\n+        final String packageName = \"packagename\";\n+        final KiePMMLRegressionModel retrieved = PROVIDER.getKiePMMLModelFromPlugin(\n+                packageName,\n+                pmml.getDataDictionary(),\n+                pmml.getTransformationDictionary(),\n+                (RegressionModel) pmml.getModels().get(0), RELEASE_ID);\n+        assertNotNull(retrieved);\n+        assertTrue(retrieved instanceof KiePMMLRegressionModelWithSources);\n+        KiePMMLRegressionModelWithSources retrievedWithSources = (KiePMMLRegressionModelWithSources)retrieved;\n+        final Map<String, String> sourcesMap = retrievedWithSources.getSourcesMap();\n+        assertNotNull(sourcesMap);\n+        assertFalse(sourcesMap.isEmpty());\n+        try {\n+            KieMemoryCompiler.compile(sourcesMap, Thread.currentThread().getContextClassLoader());\n+        } catch (Exception e) {\n+            fail(e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7156fd4086c74609bdf25f73eefa5069064ce44f"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ5NTEwOA==", "bodyText": "@danielezonca\ndone", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r475495108", "createdAt": "2020-08-24T10:17:57Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/test/java/org/kie/pmml/models/regression/compiler/executor/RegressionModelImplementationProviderTest.java", "diffHunk": "@@ -46,8 +52,33 @@ public void getKiePMMLModel() throws Exception {\n         assertNotNull(pmml);\n         assertEquals(1, pmml.getModels().size());\n         assertTrue(pmml.getModels().get(0) instanceof RegressionModel);\n-        final KiePMMLRegressionModel kiePMMLModel = PROVIDER.getKiePMMLModel(pmml.getDataDictionary(), pmml.getTransformationDictionary(), (RegressionModel) pmml.getModels().get(0), RELEASE_ID);\n-        assertNotNull(kiePMMLModel);\n+        final KiePMMLRegressionModel retrieved = PROVIDER.getKiePMMLModel(pmml.getDataDictionary(), pmml.getTransformationDictionary(), (RegressionModel) pmml.getModels().get(0), RELEASE_ID);\n+        assertNotNull(retrieved);\n+    }\n+\n+    @Test\n+    public void getKiePMMLModelFromPlugin() throws Exception {\n+        final PMML pmml = TestUtils.loadFromFile(SOURCE_1);\n+        assertNotNull(pmml);\n+        assertEquals(1, pmml.getModels().size());\n+        assertTrue(pmml.getModels().get(0) instanceof RegressionModel);\n+        final String packageName = \"packagename\";\n+        final KiePMMLRegressionModel retrieved = PROVIDER.getKiePMMLModelFromPlugin(\n+                packageName,\n+                pmml.getDataDictionary(),\n+                pmml.getTransformationDictionary(),\n+                (RegressionModel) pmml.getModels().get(0), RELEASE_ID);\n+        assertNotNull(retrieved);\n+        assertTrue(retrieved instanceof KiePMMLRegressionModelWithSources);\n+        KiePMMLRegressionModelWithSources retrievedWithSources = (KiePMMLRegressionModelWithSources)retrieved;\n+        final Map<String, String> sourcesMap = retrievedWithSources.getSourcesMap();\n+        assertNotNull(sourcesMap);\n+        assertFalse(sourcesMap.isEmpty());\n+        try {\n+            KieMemoryCompiler.compile(sourcesMap, Thread.currentThread().getContextClassLoader());\n+        } catch (Exception e) {\n+            fail(e.getMessage());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwNjI4NQ=="}, "originalCommit": {"oid": "7156fd4086c74609bdf25f73eefa5069064ce44f"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNTYzNTUxOnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-mining/kie-pmml-models-mining-tests/src/test/resources/simplelogger.properties", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwOTowNTo0NFrOHACvyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwOTowNTo0NFrOHACvyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwNzA1MQ==", "bodyText": "Why are you using debug level for tests?", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r469807051", "createdAt": "2020-08-13T09:05:44Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-mining/kie-pmml-models-mining-tests/src/test/resources/simplelogger.properties", "diffHunk": "@@ -0,0 +1,34 @@\n+# SLF4J's SimpleLogger configuration file\n+# Simple implementation of Logger that sends all enabled log messages, for all defined loggers, to System.err.\n+\n+# Default logging detail level for all instances of SimpleLogger.\n+# Must be one of (\"trace\", \"debug\", \"info\", \"warn\", or \"error\").\n+# If not specified, defaults to \"info\".\n+org.slf4j.simpleLogger.defaultLogLevel=debug", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7156fd4086c74609bdf25f73eefa5069064ce44f"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNTY0ODI0OnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-mining/kie-pmml-models-mining-tests/src/test/java/org/kie/pmml/mining/tests/MixedMiningTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwOTowODozOFrOHAC3KA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwOTowODozOFrOHAC3KA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwODkzNg==", "bodyText": "To be re enabled?", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r469808936", "createdAt": "2020-08-13T09:08:38Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-mining/kie-pmml-models-mining-tests/src/test/java/org/kie/pmml/mining/tests/MixedMiningTest.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.pmml.mining.tests;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.assertj.core.api.Assertions;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.kie.api.pmml.PMML4Result;\n+import org.kie.pmml.evaluator.api.executor.PMMLRuntime;\n+\n+@RunWith(Parameterized.class)\n+public class MixedMiningTest extends AbstractPMMLMiningTest {\n+\n+    private static final String MODEL_NAME = \"MixedMining\";\n+    private static final String TARGET_FIELD = \"categoricalResult\";\n+    private static PMMLRuntime pmmlRuntime;\n+\n+    private String categoricalX;\n+    private String categoricalY;\n+    private double age;\n+    private String occupation;\n+    private String residenceState;\n+    private boolean validLicense;\n+    private double expectedResult;\n+\n+    public MixedMiningTest(String categoricalX,\n+                           String categoricalY,\n+                           double age,\n+                           String occupation,\n+                           String residenceState,\n+                           boolean validLicense,\n+                           double expectedResult) {\n+        this.categoricalX = categoricalX;\n+        this.categoricalY = categoricalY;\n+        this.age = age;\n+        this.occupation = occupation;\n+        this.residenceState = residenceState;\n+        this.validLicense = validLicense;\n+        this.expectedResult = expectedResult;\n+    }\n+\n+    @BeforeClass\n+    public static void setupClass() {\n+        pmmlRuntime = getPMMLRuntime(MODEL_NAME);\n+    }\n+\n+    @Parameterized.Parameters\n+    public static Collection<Object[]> data() {\n+        return Arrays.asList(new Object[][]{\n+                {\"red\", \"classA\", 25.0, \"ASTRONAUT\", \"AP\", true, 2.3724999999999987},\n+//                {\"blue\", \"classA\", 2.3, \"PROGRAMMER\", \"KN\", true, 8.122499999999999},\n+//                {\"yellow\", \"classC\", 333.56, \"INSTRUCTOR\", \"TN\", false, -21.502499999999998},\n+//                {\"orange\", \"classB\", 0.12, \"ASTRONAUT\", \"KN\", true, 7.3725},\n+//                {\"green\", \"classC\", 122.12, \"TEACHER\", \"TN\", false, 36.1225},\n+//                {\"green\", \"classB\", 11.33, \"INSTRUCTOR\", \"AP\", false, 21.1225},\n+//                {\"orange\", \"classB\", 423.2, \"SKYDIVER\", \"KN\", true, 14.872499999999999},", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7156fd4086c74609bdf25f73eefa5069064ce44f"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNTY2NDExOnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-mining/kie-pmml-models-mining-tests/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwOToxMjoyNFrOHADASw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMTowMjo0NlrOHFfhOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgxMTI3NQ==", "bodyText": "Scope test? I expect all these dependences can be test scoped", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r469811275", "createdAt": "2020-08-13T09:12:24Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-mining/kie-pmml-models-mining-tests/pom.xml", "diffHunk": "@@ -0,0 +1,106 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://maven.apache.org/POM/4.0.0\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+  <parent>\n+    <groupId>org.kie</groupId>\n+    <artifactId>kie-pmml-models-mining</artifactId>\n+    <version>7.42.0-SNAPSHOT</version>\n+  </parent>\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <artifactId>kie-pmml-models-mining-tests</artifactId>\n+  <name>KIE :: PMML :: Models :: Mining :: Tests</name>\n+  <description>PMML Mining Tests</description>\n+\n+  <dependencies>\n+    <dependency>\n+      <groupId>org.kie</groupId>\n+      <artifactId>kie-pmml-models-mining-model</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.kie</groupId>\n+      <artifactId>kie-pmml-models-mining-compiler</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.kie</groupId>\n+      <artifactId>kie-pmml-models-mining-evaluator</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>commons-io</groupId>\n+      <artifactId>commons-io</artifactId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7156fd4086c74609bdf25f73eefa5069064ce44f"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyMTMzNg==", "bodyText": "@danielezonca\ndone", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r475521336", "createdAt": "2020-08-24T11:02:46Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-mining/kie-pmml-models-mining-tests/pom.xml", "diffHunk": "@@ -0,0 +1,106 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://maven.apache.org/POM/4.0.0\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+  <parent>\n+    <groupId>org.kie</groupId>\n+    <artifactId>kie-pmml-models-mining</artifactId>\n+    <version>7.42.0-SNAPSHOT</version>\n+  </parent>\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <artifactId>kie-pmml-models-mining-tests</artifactId>\n+  <name>KIE :: PMML :: Models :: Mining :: Tests</name>\n+  <description>PMML Mining Tests</description>\n+\n+  <dependencies>\n+    <dependency>\n+      <groupId>org.kie</groupId>\n+      <artifactId>kie-pmml-models-mining-model</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.kie</groupId>\n+      <artifactId>kie-pmml-models-mining-compiler</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.kie</groupId>\n+      <artifactId>kie-pmml-models-mining-evaluator</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>commons-io</groupId>\n+      <artifactId>commons-io</artifactId>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgxMTI3NQ=="}, "originalCommit": {"oid": "7156fd4086c74609bdf25f73eefa5069064ce44f"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNjQxNjE1OnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-commons/src/main/java/org/kie/pmml/commons/model/predicates/KiePMMLCompoundPredicate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMjo1MjowNFrOHAKGaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMjo1MjowNFrOHAKGaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkyNzUyOA==", "bodyText": "Debug?", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r469927528", "createdAt": "2020-08-13T12:52:04Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-trusty/kie-pmml-commons/src/main/java/org/kie/pmml/commons/model/predicates/KiePMMLCompoundPredicate.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.commons.model.predicates;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.BinaryOperator;\n+\n+import org.kie.pmml.commons.model.KiePMMLExtension;\n+import org.kie.pmml.commons.model.enums.BOOLEAN_OPERATOR;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * @see <a href=http://dmg.org/pmml/v4-4/TreeModel.html#xsdElement_SimplePredicate>SimplePredicate</a>\n+ */\n+public class KiePMMLCompoundPredicate extends KiePMMLPredicate {\n+\n+    private static final long serialVersionUID = -1996390505352151403L;\n+    private static final Logger logger = LoggerFactory.getLogger(KiePMMLCompoundPredicate.class);\n+\n+    private final BOOLEAN_OPERATOR booleanOperator;\n+    private BinaryOperator<Boolean> operatorFunction;\n+    private List<KiePMMLPredicate> kiePMMLPredicates;\n+\n+    private KiePMMLCompoundPredicate(final String name, final List<KiePMMLExtension> extensions, final BOOLEAN_OPERATOR booleanOperator) {\n+        super(name, extensions);\n+        this.booleanOperator = booleanOperator;\n+    }\n+\n+    /**\n+     * Builder to auto-generate the <b>id</b>\n+     * @return\n+     */\n+    public static Builder builder(List<KiePMMLExtension> extensions, BOOLEAN_OPERATOR booleanOperator) {\n+        return new Builder(extensions, booleanOperator);\n+    }\n+\n+    @Override\n+    public boolean evaluate(Map<String, Object> values) {\n+        logger.info(\"{} valuate {}\", this, values);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7156fd4086c74609bdf25f73eefa5069064ce44f"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNjQxNjcwOnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-commons/src/main/java/org/kie/pmml/commons/model/predicates/KiePMMLCompoundPredicate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMjo1MjoxNFrOHAKGxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMjo1MjoxNFrOHAKGxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkyNzYyMA==", "bodyText": "Debug?", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r469927620", "createdAt": "2020-08-13T12:52:14Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-trusty/kie-pmml-commons/src/main/java/org/kie/pmml/commons/model/predicates/KiePMMLCompoundPredicate.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.commons.model.predicates;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.BinaryOperator;\n+\n+import org.kie.pmml.commons.model.KiePMMLExtension;\n+import org.kie.pmml.commons.model.enums.BOOLEAN_OPERATOR;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * @see <a href=http://dmg.org/pmml/v4-4/TreeModel.html#xsdElement_SimplePredicate>SimplePredicate</a>\n+ */\n+public class KiePMMLCompoundPredicate extends KiePMMLPredicate {\n+\n+    private static final long serialVersionUID = -1996390505352151403L;\n+    private static final Logger logger = LoggerFactory.getLogger(KiePMMLCompoundPredicate.class);\n+\n+    private final BOOLEAN_OPERATOR booleanOperator;\n+    private BinaryOperator<Boolean> operatorFunction;\n+    private List<KiePMMLPredicate> kiePMMLPredicates;\n+\n+    private KiePMMLCompoundPredicate(final String name, final List<KiePMMLExtension> extensions, final BOOLEAN_OPERATOR booleanOperator) {\n+        super(name, extensions);\n+        this.booleanOperator = booleanOperator;\n+    }\n+\n+    /**\n+     * Builder to auto-generate the <b>id</b>\n+     * @return\n+     */\n+    public static Builder builder(List<KiePMMLExtension> extensions, BOOLEAN_OPERATOR booleanOperator) {\n+        return new Builder(extensions, booleanOperator);\n+    }\n+\n+    @Override\n+    public boolean evaluate(Map<String, Object> values) {\n+        logger.info(\"{} valuate {}\", this, values);\n+        Boolean toReturn = null;\n+        for (KiePMMLPredicate kiePMMLPredicate : kiePMMLPredicates) {\n+            toReturn = operatorFunction.apply(toReturn, kiePMMLPredicate.evaluate(values));\n+        }\n+        logger.info(\"return {}\", toReturn);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7156fd4086c74609bdf25f73eefa5069064ce44f"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNjQyNDU1OnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-commons/src/main/java/org/kie/pmml/commons/model/predicates/KiePMMLPredicate.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMjo1NDozMlrOHAKLwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMDoxOToxMFrOHFd9Eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkyODg5Ng==", "bodyText": "What about change the name of Abstract_KiePMMLBase_? It sounds like KieBase even if it is not drools related", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r469928896", "createdAt": "2020-08-13T12:54:32Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-trusty/kie-pmml-commons/src/main/java/org/kie/pmml/commons/model/predicates/KiePMMLPredicate.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.commons.model.predicates;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.kie.pmml.commons.model.KiePMMLExtension;\n+import org.kie.pmml.commons.model.abstracts.AbstractKiePMMLBase;\n+\n+/**\n+ * @see <a href=http://dmg.org/pmml/v4-4/TreeModel.html#xsdGroup_PREDICATE>PREDICATE</a>\n+ */\n+public abstract class KiePMMLPredicate extends AbstractKiePMMLBase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7156fd4086c74609bdf25f73eefa5069064ce44f"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ5NTY5OA==", "bodyText": "@danielezonca\ndone", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r475495698", "createdAt": "2020-08-24T10:19:10Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-trusty/kie-pmml-commons/src/main/java/org/kie/pmml/commons/model/predicates/KiePMMLPredicate.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.commons.model.predicates;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.kie.pmml.commons.model.KiePMMLExtension;\n+import org.kie.pmml.commons.model.abstracts.AbstractKiePMMLBase;\n+\n+/**\n+ * @see <a href=http://dmg.org/pmml/v4-4/TreeModel.html#xsdGroup_PREDICATE>PREDICATE</a>\n+ */\n+public abstract class KiePMMLPredicate extends AbstractKiePMMLBase {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkyODg5Ng=="}, "originalCommit": {"oid": "7156fd4086c74609bdf25f73eefa5069064ce44f"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNjQyNjU0OnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-compiler/kie-pmml-compiler-commons/src/main/java/org/kie/pmml/compiler/commons/factories/KiePMMLPredicateFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMjo1NTowMlrOHAKM7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMDo1NjowNVrOHFfVWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkyOTE5OQ==", "bodyText": "To be removed?", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r469929199", "createdAt": "2020-08-13T12:55:02Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-trusty/kie-pmml-compiler/kie-pmml-compiler-commons/src/main/java/org/kie/pmml/compiler/commons/factories/KiePMMLPredicateFactory.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.compiler.commons.factories;\n+\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\n+import org.dmg.pmml.CompoundPredicate;\n+import org.dmg.pmml.DataDictionary;\n+import org.dmg.pmml.DataField;\n+import org.dmg.pmml.DataType;\n+import org.dmg.pmml.False;\n+import org.dmg.pmml.Predicate;\n+import org.dmg.pmml.SimplePredicate;\n+import org.dmg.pmml.True;\n+import org.kie.pmml.commons.exceptions.KieDataFieldException;\n+import org.kie.pmml.commons.exceptions.KiePMMLException;\n+import org.kie.pmml.commons.exceptions.KiePMMLInternalException;\n+import org.kie.pmml.commons.model.enums.BOOLEAN_OPERATOR;\n+import org.kie.pmml.commons.model.enums.DATA_TYPE;\n+import org.kie.pmml.commons.model.enums.OPERATOR;\n+import org.kie.pmml.commons.model.predicates.KiePMMLCompoundPredicate;\n+import org.kie.pmml.commons.model.predicates.KiePMMLFalsePredicate;\n+import org.kie.pmml.commons.model.predicates.KiePMMLPredicate;\n+import org.kie.pmml.commons.model.predicates.KiePMMLSimplePredicate;\n+import org.kie.pmml.commons.model.predicates.KiePMMLTruePredicate;\n+import org.kie.pmml.compiler.commons.utils.JavaParserUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.pmml.commons.utils.KiePMMLModelUtils.getSanitizedClassName;\n+import static org.kie.pmml.compiler.commons.utils.JavaParserUtils.MAIN_CLASS_NOT_FOUND;\n+import static org.kie.pmml.compiler.commons.utils.JavaParserUtils.getFullClassName;\n+\n+public class KiePMMLPredicateFactory {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(KiePMMLPredicateFactory.class.getName());\n+    static final String KIE_PMML_SIMPLE_PREDICATE_TEMPLATE_JAVA = \"KiePMMLSimplePredicateTemplate.tmpl\";\n+    static final String KIE_PMML_SIMPLE_PREDICATE_TEMPLATE = \"KiePMMLSimplePredicateTemplate\";\n+    static final String KIE_PMML_TRUE_PREDICATE_TEMPLATE_JAVA = \"KiePMMLTruePredicateTemplate.tmpl\";\n+    static final String KIE_PMML_TRUE_PREDICATE_TEMPLATE = \"KiePMMLTruePredicateTemplate\";\n+    static final String KIE_PMML_FALSE_PREDICATE_TEMPLATE_JAVA = \"KiePMMLFalsePredicateTemplate.tmpl\";\n+    static final String KIE_PMML_FALSE_PREDICATE_TEMPLATE = \"KiePMMLFalsePredicateTemplate\";\n+\n+\n+    private KiePMMLPredicateFactory() {\n+    }\n+\n+    public static List<KiePMMLPredicate> getPredicates(List<Predicate> predicates, DataDictionary dataDictionary) throws KiePMMLException {\n+        logger.info(\"getPredicates {}\", predicates);\n+        return predicates.stream().map(predicate -> getPredicate(predicate, dataDictionary)).collect(Collectors.toList());\n+    }\n+\n+    public static KiePMMLPredicate getPredicate(Predicate predicate, DataDictionary dataDictionary) {\n+        logger.info(\"getPredicate {}\", predicate);\n+        if (predicate instanceof SimplePredicate) {\n+            final DataType dataType = dataDictionary.getDataFields().stream()\n+                    .filter(dataField -> dataField.getName().getValue().equals(((SimplePredicate) predicate).getField().getValue()))\n+                    .map(DataField::getDataType)\n+                    .findFirst()\n+                    .orElseThrow(() -> new KiePMMLException(\"Failed to find DataField for predicate \" + ((SimplePredicate) predicate).getField().getValue()));\n+            return getKiePMMLSimplePredicate((SimplePredicate) predicate, dataType);\n+        } else if (predicate instanceof CompoundPredicate) {\n+            return getKiePMMLCompoundPredicate((CompoundPredicate) predicate, dataDictionary);\n+        } else if (predicate instanceof True) {\n+            return getKiePMMLTruePredicate((True) predicate);\n+        } else if (predicate instanceof False) {\n+            return getKiePMMLFalsePredicate((False) predicate);\n+        } else {\n+            throw new KiePMMLException(\"Predicate of type \" + predicate.getClass().getName() + \" not managed, yet\");\n+        }\n+    }\n+\n+    public static KiePMMLSimplePredicate getKiePMMLSimplePredicate(SimplePredicate predicate, DataType dataType)  {\n+        return KiePMMLSimplePredicate.builder(predicate.getField().getValue(), Collections.emptyList(), OPERATOR.byName(predicate.getOperator().value()))\n+                .withValue(getActualValue(predicate.getValue(), dataType))\n+                .build();\n+    }\n+\n+    public static KiePMMLCompoundPredicate getKiePMMLCompoundPredicate(CompoundPredicate predicate, DataDictionary dataDictionary) {\n+        return KiePMMLCompoundPredicate.builder(Collections.emptyList(), BOOLEAN_OPERATOR.byName(predicate.getBooleanOperator().value()))\n+                .withKiePMMLPredicates(getPredicates(predicate.getPredicates(), dataDictionary))\n+                .build();\n+    }\n+\n+    public static KiePMMLTruePredicate getKiePMMLTruePredicate(True predicate) throws KiePMMLException {\n+        return KiePMMLTruePredicate.builder(Collections.emptyList())\n+                .build();\n+    }\n+\n+    public static KiePMMLFalsePredicate getKiePMMLFalsePredicate(False predicate) throws KiePMMLException {\n+        return KiePMMLFalsePredicate.builder(Collections.emptyList())\n+                .build();\n+    }\n+\n+    public static Map<String, String> getPredicateSourcesMap(final KiePMMLPredicate kiePMMLPredicate,\n+                                                             final String packageName) {\n+        logger.info(\"getPredicateSourcesMap {}\", kiePMMLPredicate);\n+        if (kiePMMLPredicate instanceof KiePMMLSimplePredicate) {\n+            return getKiePMMLSimplePredicateSourcesMap((KiePMMLSimplePredicate) kiePMMLPredicate, packageName);\n+//        } else if (predicate instanceof CompoundPredicate) {\n+//            return getKiePMMLCompoundPredicate((CompoundPredicate) predicate, dataDictionary);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7156fd4086c74609bdf25f73eefa5069064ce44f"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUxODI5OQ==", "bodyText": "@danielezonca\nimplemented", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r475518299", "createdAt": "2020-08-24T10:56:05Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-trusty/kie-pmml-compiler/kie-pmml-compiler-commons/src/main/java/org/kie/pmml/compiler/commons/factories/KiePMMLPredicateFactory.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.compiler.commons.factories;\n+\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\n+import org.dmg.pmml.CompoundPredicate;\n+import org.dmg.pmml.DataDictionary;\n+import org.dmg.pmml.DataField;\n+import org.dmg.pmml.DataType;\n+import org.dmg.pmml.False;\n+import org.dmg.pmml.Predicate;\n+import org.dmg.pmml.SimplePredicate;\n+import org.dmg.pmml.True;\n+import org.kie.pmml.commons.exceptions.KieDataFieldException;\n+import org.kie.pmml.commons.exceptions.KiePMMLException;\n+import org.kie.pmml.commons.exceptions.KiePMMLInternalException;\n+import org.kie.pmml.commons.model.enums.BOOLEAN_OPERATOR;\n+import org.kie.pmml.commons.model.enums.DATA_TYPE;\n+import org.kie.pmml.commons.model.enums.OPERATOR;\n+import org.kie.pmml.commons.model.predicates.KiePMMLCompoundPredicate;\n+import org.kie.pmml.commons.model.predicates.KiePMMLFalsePredicate;\n+import org.kie.pmml.commons.model.predicates.KiePMMLPredicate;\n+import org.kie.pmml.commons.model.predicates.KiePMMLSimplePredicate;\n+import org.kie.pmml.commons.model.predicates.KiePMMLTruePredicate;\n+import org.kie.pmml.compiler.commons.utils.JavaParserUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.pmml.commons.utils.KiePMMLModelUtils.getSanitizedClassName;\n+import static org.kie.pmml.compiler.commons.utils.JavaParserUtils.MAIN_CLASS_NOT_FOUND;\n+import static org.kie.pmml.compiler.commons.utils.JavaParserUtils.getFullClassName;\n+\n+public class KiePMMLPredicateFactory {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(KiePMMLPredicateFactory.class.getName());\n+    static final String KIE_PMML_SIMPLE_PREDICATE_TEMPLATE_JAVA = \"KiePMMLSimplePredicateTemplate.tmpl\";\n+    static final String KIE_PMML_SIMPLE_PREDICATE_TEMPLATE = \"KiePMMLSimplePredicateTemplate\";\n+    static final String KIE_PMML_TRUE_PREDICATE_TEMPLATE_JAVA = \"KiePMMLTruePredicateTemplate.tmpl\";\n+    static final String KIE_PMML_TRUE_PREDICATE_TEMPLATE = \"KiePMMLTruePredicateTemplate\";\n+    static final String KIE_PMML_FALSE_PREDICATE_TEMPLATE_JAVA = \"KiePMMLFalsePredicateTemplate.tmpl\";\n+    static final String KIE_PMML_FALSE_PREDICATE_TEMPLATE = \"KiePMMLFalsePredicateTemplate\";\n+\n+\n+    private KiePMMLPredicateFactory() {\n+    }\n+\n+    public static List<KiePMMLPredicate> getPredicates(List<Predicate> predicates, DataDictionary dataDictionary) throws KiePMMLException {\n+        logger.info(\"getPredicates {}\", predicates);\n+        return predicates.stream().map(predicate -> getPredicate(predicate, dataDictionary)).collect(Collectors.toList());\n+    }\n+\n+    public static KiePMMLPredicate getPredicate(Predicate predicate, DataDictionary dataDictionary) {\n+        logger.info(\"getPredicate {}\", predicate);\n+        if (predicate instanceof SimplePredicate) {\n+            final DataType dataType = dataDictionary.getDataFields().stream()\n+                    .filter(dataField -> dataField.getName().getValue().equals(((SimplePredicate) predicate).getField().getValue()))\n+                    .map(DataField::getDataType)\n+                    .findFirst()\n+                    .orElseThrow(() -> new KiePMMLException(\"Failed to find DataField for predicate \" + ((SimplePredicate) predicate).getField().getValue()));\n+            return getKiePMMLSimplePredicate((SimplePredicate) predicate, dataType);\n+        } else if (predicate instanceof CompoundPredicate) {\n+            return getKiePMMLCompoundPredicate((CompoundPredicate) predicate, dataDictionary);\n+        } else if (predicate instanceof True) {\n+            return getKiePMMLTruePredicate((True) predicate);\n+        } else if (predicate instanceof False) {\n+            return getKiePMMLFalsePredicate((False) predicate);\n+        } else {\n+            throw new KiePMMLException(\"Predicate of type \" + predicate.getClass().getName() + \" not managed, yet\");\n+        }\n+    }\n+\n+    public static KiePMMLSimplePredicate getKiePMMLSimplePredicate(SimplePredicate predicate, DataType dataType)  {\n+        return KiePMMLSimplePredicate.builder(predicate.getField().getValue(), Collections.emptyList(), OPERATOR.byName(predicate.getOperator().value()))\n+                .withValue(getActualValue(predicate.getValue(), dataType))\n+                .build();\n+    }\n+\n+    public static KiePMMLCompoundPredicate getKiePMMLCompoundPredicate(CompoundPredicate predicate, DataDictionary dataDictionary) {\n+        return KiePMMLCompoundPredicate.builder(Collections.emptyList(), BOOLEAN_OPERATOR.byName(predicate.getBooleanOperator().value()))\n+                .withKiePMMLPredicates(getPredicates(predicate.getPredicates(), dataDictionary))\n+                .build();\n+    }\n+\n+    public static KiePMMLTruePredicate getKiePMMLTruePredicate(True predicate) throws KiePMMLException {\n+        return KiePMMLTruePredicate.builder(Collections.emptyList())\n+                .build();\n+    }\n+\n+    public static KiePMMLFalsePredicate getKiePMMLFalsePredicate(False predicate) throws KiePMMLException {\n+        return KiePMMLFalsePredicate.builder(Collections.emptyList())\n+                .build();\n+    }\n+\n+    public static Map<String, String> getPredicateSourcesMap(final KiePMMLPredicate kiePMMLPredicate,\n+                                                             final String packageName) {\n+        logger.info(\"getPredicateSourcesMap {}\", kiePMMLPredicate);\n+        if (kiePMMLPredicate instanceof KiePMMLSimplePredicate) {\n+            return getKiePMMLSimplePredicateSourcesMap((KiePMMLSimplePredicate) kiePMMLPredicate, packageName);\n+//        } else if (predicate instanceof CompoundPredicate) {\n+//            return getKiePMMLCompoundPredicate((CompoundPredicate) predicate, dataDictionary);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkyOTE5OQ=="}, "originalCommit": {"oid": "7156fd4086c74609bdf25f73eefa5069064ce44f"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNjQzNDU0OnYy", "diffSide": "LEFT", "path": "kie-pmml-trusty/kie-pmml-compiler/kie-pmml-compiler-commons/src/test/java/org/kie/pmml/compiler/commons/implementations/KiePMMLModelRetrieverTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMjo1NzowNlrOHAKRtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMToxMDoxMVrOHFfunA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkzMDQyMw==", "bodyText": "Can you replace these assertions with others?", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r469930423", "createdAt": "2020-08-13T12:57:06Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-trusty/kie-pmml-compiler/kie-pmml-compiler-commons/src/test/java/org/kie/pmml/compiler/commons/implementations/KiePMMLModelRetrieverTest.java", "diffHunk": "@@ -43,8 +43,6 @@ public void getFromCommonDataAndTransformationDictionaryAndModelWithProvider() t\n         pmmlModel = KiePMMLUtil.load(getFileInputStream(MULTIPLE_TARGETS_SOURCE), MULTIPLE_TARGETS_SOURCE);\n         final Optional<KiePMMLModel> retrieved = getFromCommonDataAndTransformationDictionaryAndModel(pmmlModel.getDataDictionary(), pmmlModel.getTransformationDictionary(), pmmlModel.getModels().get(0), null);\n         assertNotNull(retrieved);\n-        assertTrue(retrieved.isPresent());\n-        assertTrue(retrieved.get() instanceof KiePMMLTestingModel);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7156fd4086c74609bdf25f73eefa5069064ce44f"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyNDc2NA==", "bodyText": "@danielezonca\nPreviously, TestingModelImplementationProvider was mapped to RegressionModel, so those tests returned a \"KiePMMLTestingModel\" (sort of a mock).\nBut with MiningModel tests (that needs all the real ModelImplementationProviders), having two ModelImplementationProviders mapped to the same model (Regression) may lead to error. So TestingModelImplementationProvider currently is mapped to a (fake) model, but then those methods returns an empty Optional. I have to find a proper fix for that", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r475524764", "createdAt": "2020-08-24T11:10:11Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-trusty/kie-pmml-compiler/kie-pmml-compiler-commons/src/test/java/org/kie/pmml/compiler/commons/implementations/KiePMMLModelRetrieverTest.java", "diffHunk": "@@ -43,8 +43,6 @@ public void getFromCommonDataAndTransformationDictionaryAndModelWithProvider() t\n         pmmlModel = KiePMMLUtil.load(getFileInputStream(MULTIPLE_TARGETS_SOURCE), MULTIPLE_TARGETS_SOURCE);\n         final Optional<KiePMMLModel> retrieved = getFromCommonDataAndTransformationDictionaryAndModel(pmmlModel.getDataDictionary(), pmmlModel.getTransformationDictionary(), pmmlModel.getModels().get(0), null);\n         assertNotNull(retrieved);\n-        assertTrue(retrieved.isPresent());\n-        assertTrue(retrieved.get() instanceof KiePMMLTestingModel);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkzMDQyMw=="}, "originalCommit": {"oid": "7156fd4086c74609bdf25f73eefa5069064ce44f"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNjQzNTk3OnYy", "diffSide": "LEFT", "path": "kie-pmml-trusty/kie-pmml-compiler/kie-pmml-compiler-commons/src/test/java/org/kie/pmml/compiler/commons/implementations/KiePMMLModelRetrieverTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMjo1NzoyN1rOHAKSkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMToxMDoyOVrOHFfvKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkzMDY0Mg==", "bodyText": "Can you please replace these assertions with others?", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r469930642", "createdAt": "2020-08-13T12:57:27Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-trusty/kie-pmml-compiler/kie-pmml-compiler-commons/src/test/java/org/kie/pmml/compiler/commons/implementations/KiePMMLModelRetrieverTest.java", "diffHunk": "@@ -56,12 +54,10 @@ public void getFromCommonDataAndTransformationDictionaryAndModelWithoutProvider(\n     }\n \n     @Test\n-    public void getFromCommonDataAndTransformationDictionaryAndModelFromPluginlWithProvider() throws Exception {\n+    public void getFromCommonDataAndTransformationDictionaryAndModelFromPluginWithProvider() throws Exception {\n         pmmlModel = KiePMMLUtil.load(getFileInputStream(MULTIPLE_TARGETS_SOURCE), MULTIPLE_TARGETS_SOURCE);\n         final Optional<KiePMMLModel> retrieved = getFromCommonDataAndTransformationDictionaryAndModelFromPlugin(PACKAGE_NAME, pmmlModel.getDataDictionary(), pmmlModel.getTransformationDictionary(), pmmlModel.getModels().get(0), null);\n         assertNotNull(retrieved);\n-        assertTrue(retrieved.isPresent());\n-        assertTrue(retrieved.get() instanceof KiePMMLTestingModel);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7156fd4086c74609bdf25f73eefa5069064ce44f"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyNDkwNQ==", "bodyText": "@danielezonca\nsee above", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r475524905", "createdAt": "2020-08-24T11:10:29Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-trusty/kie-pmml-compiler/kie-pmml-compiler-commons/src/test/java/org/kie/pmml/compiler/commons/implementations/KiePMMLModelRetrieverTest.java", "diffHunk": "@@ -56,12 +54,10 @@ public void getFromCommonDataAndTransformationDictionaryAndModelWithoutProvider(\n     }\n \n     @Test\n-    public void getFromCommonDataAndTransformationDictionaryAndModelFromPluginlWithProvider() throws Exception {\n+    public void getFromCommonDataAndTransformationDictionaryAndModelFromPluginWithProvider() throws Exception {\n         pmmlModel = KiePMMLUtil.load(getFileInputStream(MULTIPLE_TARGETS_SOURCE), MULTIPLE_TARGETS_SOURCE);\n         final Optional<KiePMMLModel> retrieved = getFromCommonDataAndTransformationDictionaryAndModelFromPlugin(PACKAGE_NAME, pmmlModel.getDataDictionary(), pmmlModel.getTransformationDictionary(), pmmlModel.getModels().get(0), null);\n         assertNotNull(retrieved);\n-        assertTrue(retrieved.isPresent());\n-        assertTrue(retrieved.get() instanceof KiePMMLTestingModel);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkzMDY0Mg=="}, "originalCommit": {"oid": "7156fd4086c74609bdf25f73eefa5069064ce44f"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNjQ0MDM5OnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-drools/kie-pmml-models-drools-scorecard/kie-pmml-models-drools-scorecard-compiler/src/main/java/org/kie/pmml/models/drools/scorecard/compiler/factories/KiePMMLScorecardModelFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMjo1ODoyNlrOHAKVFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMjo1ODoyNlrOHAKVFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkzMTI4NQ==", "bodyText": "Revert?", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r469931285", "createdAt": "2020-08-13T12:58:26Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-drools/kie-pmml-models-drools-scorecard/kie-pmml-models-drools-scorecard-compiler/src/main/java/org/kie/pmml/models/drools/scorecard/compiler/factories/KiePMMLScorecardModelFactory.java", "diffHunk": "@@ -113,4 +113,6 @@ static void setSuperInvocation(final Scorecard scorecard, final ConstructorDecla\n             }\n         });\n     }\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7156fd4086c74609bdf25f73eefa5069064ce44f"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNjQ0NDMwOnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-drools/kie-pmml-models-drools-scorecard/kie-pmml-models-drools-scorecard-compiler/src/test/java/org/kie/pmml/models/drools/scorecard/compiler/executor/ScorecardModelImplementationProviderTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMjo1OToxN1rOHAKXQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMjo1OToxN1rOHAKXQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkzMTg0MA==", "bodyText": "Why a new ignored test? If you plan to fix it later please create a ticket and refer it here", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r469931840", "createdAt": "2020-08-13T12:59:17Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-drools/kie-pmml-models-drools-scorecard/kie-pmml-models-drools-scorecard-compiler/src/test/java/org/kie/pmml/models/drools/scorecard/compiler/executor/ScorecardModelImplementationProviderTest.java", "diffHunk": "@@ -41,11 +45,33 @@ public void getPMMLModelType() {\n \n     @Test\n     public void getKiePMMLModel() throws Exception {\n-        final PMML pmml = TestUtils.loadFromFile(SOURCE_1);\n-        assertNotNull(pmml);\n-        assertEquals(1, pmml.getModels().size());\n-        assertTrue(pmml.getModels().get(0) instanceof Scorecard);\n-        final KiePMMLScorecardModel kiePMMLModel = PROVIDER.getKiePMMLModel(pmml.getDataDictionary(), pmml.getTransformationDictionary(), (Scorecard) pmml.getModels().get(0), KNOWLEDGE_BUILDER);\n+        final PMML pmml = getPMML(SOURCE_1);\n+        final KiePMMLScorecardModel kiePMMLModel = PROVIDER.getKiePMMLModel(pmml.getDataDictionary(),\n+                                                                            pmml.getTransformationDictionary(),\n+                                                                            (Scorecard) pmml.getModels().get(0),\n+                                                                            KNOWLEDGE_BUILDER);\n         assertNotNull(kiePMMLModel);\n     }\n+\n+    @Ignore", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7156fd4086c74609bdf25f73eefa5069064ce44f"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNjQ0NTY3OnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-drools/kie-pmml-models-drools-tree/kie-pmml-models-drools-tree-compiler/src/test/java/org/kie/pmml/models/drools/tree/compiler/executor/TreeModelImplementationProviderTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMjo1OTozNlrOHAKYCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMjo1OTozNlrOHAKYCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkzMjA0Mg==", "bodyText": "Same as above", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r469932042", "createdAt": "2020-08-13T12:59:36Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-drools/kie-pmml-models-drools-tree/kie-pmml-models-drools-tree-compiler/src/test/java/org/kie/pmml/models/drools/tree/compiler/executor/TreeModelImplementationProviderTest.java", "diffHunk": "@@ -41,11 +49,30 @@ public void getPMMLModelType() {\n \n     @Test\n     public void getKiePMMLModel() throws Exception {\n-        final PMML pmml = TestUtils.loadFromFile(SOURCE_1);\n-        assertNotNull(pmml);\n-        assertEquals(1, pmml.getModels().size());\n-        assertTrue(pmml.getModels().get(0) instanceof TreeModel);\n+        final PMML pmml = getPMML(SOURCE_1);\n         final KiePMMLTreeModel kiePMMLModel = PROVIDER.getKiePMMLModel(pmml.getDataDictionary(), pmml.getTransformationDictionary(), (TreeModel) pmml.getModels().get(0), KNOWLEDGE_BUILDER);\n         assertNotNull(kiePMMLModel);\n     }\n+\n+    @Ignore", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7156fd4086c74609bdf25f73eefa5069064ce44f"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNjQ0ODA0OnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-mining/kie-pmml-models-mining-compiler/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMzowMDoxMFrOHAKZYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMToxNTozNFrOHFf4jA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkzMjM4NA==", "bodyText": "Is mining a drools model?", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r469932384", "createdAt": "2020-08-13T13:00:10Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-mining/kie-pmml-models-mining-compiler/pom.xml", "diffHunk": "@@ -0,0 +1,80 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://maven.apache.org/POM/4.0.0\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+  <parent>\n+    <groupId>org.kie</groupId>\n+    <artifactId>kie-pmml-models-mining</artifactId>\n+    <version>7.42.0-SNAPSHOT</version>\n+  </parent>\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <artifactId>kie-pmml-models-mining-compiler</artifactId>\n+\n+  <name>KIE :: PMML :: Models :: Mining :: Compiler</name>\n+  <description>PMML Mining Compiler</description>\n+\n+  <dependencies>\n+    <!-- PMML -->\n+    <dependency>\n+      <groupId>org.kie</groupId>\n+      <artifactId>kie-pmml-compiler-commons</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.kie</groupId>\n+      <artifactId>kie-pmml-models-mining-model</artifactId>\n+    </dependency>\n+    <!-- EXTERNAL -->\n+    <dependency>\n+      <groupId>org.kie</groupId>\n+      <artifactId>kie-internal</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.drools</groupId>\n+      <artifactId>drools-compiler</artifactId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7156fd4086c74609bdf25f73eefa5069064ce44f"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyNzMwOA==", "bodyText": "@danielezonca\nremoved", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r475527308", "createdAt": "2020-08-24T11:15:34Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-mining/kie-pmml-models-mining-compiler/pom.xml", "diffHunk": "@@ -0,0 +1,80 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://maven.apache.org/POM/4.0.0\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+  <parent>\n+    <groupId>org.kie</groupId>\n+    <artifactId>kie-pmml-models-mining</artifactId>\n+    <version>7.42.0-SNAPSHOT</version>\n+  </parent>\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <artifactId>kie-pmml-models-mining-compiler</artifactId>\n+\n+  <name>KIE :: PMML :: Models :: Mining :: Compiler</name>\n+  <description>PMML Mining Compiler</description>\n+\n+  <dependencies>\n+    <!-- PMML -->\n+    <dependency>\n+      <groupId>org.kie</groupId>\n+      <artifactId>kie-pmml-compiler-commons</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.kie</groupId>\n+      <artifactId>kie-pmml-models-mining-model</artifactId>\n+    </dependency>\n+    <!-- EXTERNAL -->\n+    <dependency>\n+      <groupId>org.kie</groupId>\n+      <artifactId>kie-internal</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.drools</groupId>\n+      <artifactId>drools-compiler</artifactId>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkzMjM4NA=="}, "originalCommit": {"oid": "7156fd4086c74609bdf25f73eefa5069064ce44f"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNjQ1ODUwOnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-mining/kie-pmml-models-mining-evaluator/src/main/java/org/kie/pmml/models/mining/evaluator/PMMLMiningModelEvaluator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMzowMjo0MVrOHAKfZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMzowMjo0MVrOHAKfZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkzMzkyNg==", "bodyText": "I think this check is duplicated: it is already done inside validate", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r469933926", "createdAt": "2020-08-13T13:02:41Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-mining/kie-pmml-models-mining-evaluator/src/main/java/org/kie/pmml/models/mining/evaluator/PMMLMiningModelEvaluator.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.mining.evaluator;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiConsumer;\n+\n+import org.drools.core.RuleBaseConfiguration;\n+import org.drools.core.impl.InternalKnowledgeBase;\n+import org.drools.core.impl.KnowledgeBaseFactory;\n+import org.drools.core.impl.KnowledgeBaseImpl;\n+import org.drools.core.util.StringUtils;\n+import org.kie.api.KieBase;\n+import org.kie.api.KieBaseConfiguration;\n+import org.kie.api.definition.KiePackage;\n+import org.kie.api.pmml.PMML4Result;\n+import org.kie.api.runtime.KieRuntimeFactory;\n+import org.kie.pmml.commons.exceptions.KiePMMLException;\n+import org.kie.pmml.commons.exceptions.KiePMMLInternalException;\n+import org.kie.pmml.commons.model.KiePMMLModel;\n+import org.kie.pmml.commons.model.enums.PMML_MODEL;\n+import org.kie.pmml.commons.model.predicates.KiePMMLPredicate;\n+import org.kie.pmml.commons.model.tuples.KiePMMLNameValue;\n+import org.kie.pmml.commons.model.tuples.KiePMMLValueWeight;\n+import org.kie.pmml.evaluator.api.exceptions.KiePMMLModelException;\n+import org.kie.pmml.evaluator.api.executor.PMMLContext;\n+import org.kie.pmml.evaluator.api.executor.PMMLRuntime;\n+import org.kie.pmml.evaluator.core.executor.PMMLModelEvaluator;\n+import org.kie.pmml.models.mining.model.KiePMMLMiningModel;\n+import org.kie.pmml.models.mining.model.enums.MULTIPLE_MODEL_METHOD;\n+import org.kie.pmml.models.mining.model.segmentation.KiePMMLSegment;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.pmml.commons.enums.ResultCode.OK;\n+import static org.kie.pmml.evaluator.core.utils.Converter.getUnwrappedParametersMap;\n+\n+/**\n+ * Default <code>PMMLModelExecutor</code> for <b>Mining</b>\n+ */\n+public class PMMLMiningModelEvaluator implements PMMLModelEvaluator {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PMMLMiningModelEvaluator.class.getName());\n+    private static final String EXPECTED_A_KIE_PMMLMINING_MODEL_RECEIVED = \"Expected a KiePMMLMiningModel, received \" +\n+            \"%s \";\n+    private static final String TARGET_FIELD_REQUIRED_RETRIEVED = \"TargetField required, retrieved %s\";\n+    private static final Map<String, InternalKnowledgeBase> MAPPED_KIEBASES = new HashMap<>();\n+\n+    @Override\n+    public PMML_MODEL getPMMLModelType() {\n+        return PMML_MODEL.MINING_MODEL;\n+    }\n+\n+    @Override\n+    public PMML4Result evaluate(final KieBase knowledgeBase,\n+                                final KiePMMLModel model,\n+                                final PMMLContext pmmlContext) {\n+        validate(model);\n+        if (!(model instanceof KiePMMLMiningModel)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7156fd4086c74609bdf25f73eefa5069064ce44f"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNjQ3MjI4OnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-mining/kie-pmml-models-mining-model/pom.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMzowNTo1NFrOHAKnnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMzowNTo1NFrOHAKnnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkzNjAzMQ==", "bodyText": "To be removed", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r469936031", "createdAt": "2020-08-13T13:05:54Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-mining/kie-pmml-models-mining-model/pom.xml", "diffHunk": "@@ -0,0 +1,44 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://maven.apache.org/POM/4.0.0\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+  <parent>\n+    <groupId>org.kie</groupId>\n+    <artifactId>kie-pmml-models-mining</artifactId>\n+    <version>7.42.0-SNAPSHOT</version>\n+  </parent>\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <artifactId>kie-pmml-models-mining-model</artifactId>\n+\n+  <name>KIE :: PMML :: Models :: Mining :: Model</name>\n+  <description>KiePMML Model for Mining implementation</description>\n+\n+  <dependencies>\n+    <!-- PMML -->\n+    <dependency>\n+      <groupId>org.kie</groupId>\n+      <artifactId>kie-pmml-commons</artifactId>\n+    </dependency>\n+    <!-- EXTERNAL -->\n+    <!-- TEST -->\n+    <dependency>\n+      <groupId>org.kie</groupId>\n+      <artifactId>kie-pmml-commons</artifactId>\n+      <classifier>tests</classifier>\n+      <scope>test</scope>\n+    </dependency>\n+  </dependencies>\n+\n+<!--  <dependencyManagement>-->\n+<!--    &lt;!&ndash; TODO MOVE TO kie-pmml-new/pom.xml &ndash;&gt;-->\n+<!--    <dependencies>-->\n+<!--      <dependency>-->\n+<!--        <groupId>org.kie</groupId>-->\n+<!--        <artifactId>kie-pmml-commons</artifactId>-->\n+<!--        <classifier>tests</classifier>-->\n+<!--        <version>${version.org.kie}</version>-->\n+<!--      </dependency>-->\n+<!--    </dependencies>-->\n+<!--  </dependencyManagement>-->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7156fd4086c74609bdf25f73eefa5069064ce44f"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNjQ4Mzk1OnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-mining/kie-pmml-models-mining-model/src/main/java/org/kie/pmml/models/mining/model/KiePMMLMiningModel.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMzowODo1MlrOHAKuqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMzowODo1MlrOHAKuqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkzNzgzMg==", "bodyText": "To be implemented?", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r469937832", "createdAt": "2020-08-13T13:08:52Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-mining/kie-pmml-models-mining-model/src/main/java/org/kie/pmml/models/mining/model/KiePMMLMiningModel.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.mining.model;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import org.kie.pmml.commons.model.HasNestedModels;\n+import org.kie.pmml.commons.model.KiePMMLExtension;\n+import org.kie.pmml.commons.model.KiePMMLModel;\n+import org.kie.pmml.commons.model.enums.MINING_FUNCTION;\n+import org.kie.pmml.commons.model.enums.PMML_MODEL;\n+import org.kie.pmml.models.mining.model.segmentation.KiePMMLSegment;\n+import org.kie.pmml.models.mining.model.segmentation.KiePMMLSegmentation;\n+\n+/**\n+ * @see <a href=http://dmg.org/pmml/v4-3/MultipleModels.html>MiningModel</a>\n+ */\n+public class KiePMMLMiningModel extends KiePMMLModel implements HasNestedModels {\n+\n+    public static final PMML_MODEL PMML_MODEL_TYPE = PMML_MODEL.MINING_MODEL;\n+\n+    protected String algorithmName;\n+    protected boolean scorable = true;\n+    protected KiePMMLSegmentation segmentation;\n+\n+    protected KiePMMLMiningModel(String name, List<KiePMMLExtension> extensions) {\n+        super(name, extensions);\n+    }\n+\n+    public static Builder builder(String name, List<KiePMMLExtension> extensions, MINING_FUNCTION miningFunction) {\n+        return new Builder(name, extensions, miningFunction);\n+    }\n+\n+    @Override\n+    public Object evaluate(final Object knowledgeBase, final Map<String, Object> requestData) {\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7156fd4086c74609bdf25f73eefa5069064ce44f"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNjUwNjkyOnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-mining/kie-pmml-models-mining-evaluator/src/test/java/org/kie/pmml/models/mining/evaluator/PMMLMiningModelEvaluatorTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMzoxNDoxNFrOHAK8bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMzoxNDoxNFrOHAK8bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk0MTM1OQ==", "bodyText": "Please add more tests", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r469941359", "createdAt": "2020-08-13T13:14:14Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-mining/kie-pmml-models-mining-evaluator/src/test/java/org/kie/pmml/models/mining/evaluator/PMMLMiningModelEvaluatorTest.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package  org.kie.pmml.models.mining.evaluator;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.pmml.commons.model.enums.PMML_MODEL;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class PMMLMiningModelEvaluatorTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7156fd4086c74609bdf25f73eefa5069064ce44f"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNjUyNjgwOnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-mining/kie-pmml-models-mining-model/src/main/java/org/kie/pmml/models/mining/model/enums/MULTIPLE_MODEL_METHOD.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMzoxOToxMFrOHALIsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMDowNjozMFrOHFdjiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk0NDQ5Nw==", "bodyText": "General comment related to this class: it should be better to implement different functions as for loop instead of stream for performance. Wdyt?\nFeel free to create a ticket and consider this change for the future", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r469944497", "createdAt": "2020-08-13T13:19:10Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-mining/kie-pmml-models-mining-model/src/main/java/org/kie/pmml/models/mining/model/enums/MULTIPLE_MODEL_METHOD.java", "diffHunk": "@@ -0,0 +1,206 @@\n+package org.kie.pmml.models.mining.model.enums;\n+\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.OptionalDouble;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+import java.util.stream.Stream;\n+\n+import org.kie.pmml.commons.exceptions.KieEnumException;\n+import org.kie.pmml.commons.model.tuples.KiePMMLNameValue;\n+import org.kie.pmml.commons.model.tuples.KiePMMLValueWeight;\n+\n+/**\n+ * @see <a href=http://dmg.org/pmml/v4-4/MultipleModels.html#xsdType_MULTIPLE-MODEL-METHOD>MULTIPLE-MODEL-METHOD</a>\n+ */\n+public enum MULTIPLE_MODEL_METHOD {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7156fd4086c74609bdf25f73eefa5069064ce44f"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ4OTE2MA==", "bodyText": "@danielezonca\nhttps://issues.redhat.com/browse/DROOLS-5593", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r475489160", "createdAt": "2020-08-24T10:06:30Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-mining/kie-pmml-models-mining-model/src/main/java/org/kie/pmml/models/mining/model/enums/MULTIPLE_MODEL_METHOD.java", "diffHunk": "@@ -0,0 +1,206 @@\n+package org.kie.pmml.models.mining.model.enums;\n+\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.OptionalDouble;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+import java.util.stream.Stream;\n+\n+import org.kie.pmml.commons.exceptions.KieEnumException;\n+import org.kie.pmml.commons.model.tuples.KiePMMLNameValue;\n+import org.kie.pmml.commons.model.tuples.KiePMMLValueWeight;\n+\n+/**\n+ * @see <a href=http://dmg.org/pmml/v4-4/MultipleModels.html#xsdType_MULTIPLE-MODEL-METHOD>MULTIPLE-MODEL-METHOD</a>\n+ */\n+public enum MULTIPLE_MODEL_METHOD {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk0NDQ5Nw=="}, "originalCommit": {"oid": "7156fd4086c74609bdf25f73eefa5069064ce44f"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NjM1NDk1OnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/main/java/org/kie/pmml/models/regression/compiler/factories/KiePMMLRegressionModelFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxMDoyMjoxN1rOHBi-bA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwODo1OTozM1rOHFauuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM4MzY2MA==", "bodyText": "Is it possible? Log message?", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r471383660", "createdAt": "2020-08-17T10:22:17Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/main/java/org/kie/pmml/models/regression/compiler/factories/KiePMMLRegressionModelFactory.java", "diffHunk": "@@ -130,25 +137,26 @@ static void populateConstructor(final String generatedClassName,\n                                             final String modelName) {\n         ObjectCreationExpr objectCreationExpr = new ObjectCreationExpr();\n         objectCreationExpr.setType(nestedTable);\n-        constructorDeclaration.setName(generatedClassName);\n+        setConstructorSuperNameInvocation(generatedClassName, constructorDeclaration, modelName);\n         final BlockStmt body = constructorDeclaration.getBody();\n-        body.getStatements().iterator().forEachRemaining(statement -> {\n-            if (statement instanceof ExplicitConstructorInvocationStmt) {\n-                ExplicitConstructorInvocationStmt superStatement = (ExplicitConstructorInvocationStmt) statement;\n-                NameExpr modelNameExpr = (NameExpr) superStatement.getArgument(0);\n-                modelNameExpr.setName(String.format(\"\\\"%s\\\"\", modelName));\n-            }\n-        });\n         final List<AssignExpr> assignExprs = body.findAll(AssignExpr.class);\n         assignExprs.forEach(assignExpr -> {\n-            if (assignExpr.getTarget().asNameExpr().getNameAsString().equals(\"regressionTable\")) {\n-                assignExpr.setValue(objectCreationExpr);\n-            } else if (assignExpr.getTarget().asNameExpr().getNameAsString().equals(\"targetField\")) {\n-                assignExpr.setValue(new StringLiteralExpr(targetField));\n-            } else if (assignExpr.getTarget().asNameExpr().getNameAsString().equals(\"miningFunction\")) {\n-                assignExpr.setValue(new NameExpr(miningFunction.getClass().getName() + \".\" + miningFunction.name()));\n-            } else if (assignExpr.getTarget().asNameExpr().getNameAsString().equals(\"pmmlMODEL\")) {\n-                assignExpr.setValue(new NameExpr(PMML_MODEL.REGRESSION_MODEL.getClass().getName() + \".\" + PMML_MODEL.REGRESSION_MODEL.name()));\n+            final String assignExprName = assignExpr.getTarget().asNameExpr().getNameAsString();\n+            switch (assignExprName) {\n+                case \"regressionTable\":\n+                    assignExpr.setValue(objectCreationExpr);\n+                    break;\n+                case \"targetField\":\n+                    assignExpr.setValue(new StringLiteralExpr(targetField));\n+                    break;\n+                case \"miningFunction\":\n+                    assignExpr.setValue(new NameExpr(miningFunction.getClass().getName() + \".\" + miningFunction.name()));\n+                    break;\n+                case \"pmmlMODEL\":\n+                    assignExpr.setValue(new NameExpr(PMML_MODEL.REGRESSION_MODEL.getClass().getName() + \".\" + PMML_MODEL.REGRESSION_MODEL.name()));\n+                    break;\n+                default:\n+                    // NOOP", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dbaa45fe0723e7d6e234ae9b2e5b03a79cc9ce7"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0Mjg3Mg==", "bodyText": "@danielezonca\ndone", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r475442872", "createdAt": "2020-08-24T08:59:33Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/main/java/org/kie/pmml/models/regression/compiler/factories/KiePMMLRegressionModelFactory.java", "diffHunk": "@@ -130,25 +137,26 @@ static void populateConstructor(final String generatedClassName,\n                                             final String modelName) {\n         ObjectCreationExpr objectCreationExpr = new ObjectCreationExpr();\n         objectCreationExpr.setType(nestedTable);\n-        constructorDeclaration.setName(generatedClassName);\n+        setConstructorSuperNameInvocation(generatedClassName, constructorDeclaration, modelName);\n         final BlockStmt body = constructorDeclaration.getBody();\n-        body.getStatements().iterator().forEachRemaining(statement -> {\n-            if (statement instanceof ExplicitConstructorInvocationStmt) {\n-                ExplicitConstructorInvocationStmt superStatement = (ExplicitConstructorInvocationStmt) statement;\n-                NameExpr modelNameExpr = (NameExpr) superStatement.getArgument(0);\n-                modelNameExpr.setName(String.format(\"\\\"%s\\\"\", modelName));\n-            }\n-        });\n         final List<AssignExpr> assignExprs = body.findAll(AssignExpr.class);\n         assignExprs.forEach(assignExpr -> {\n-            if (assignExpr.getTarget().asNameExpr().getNameAsString().equals(\"regressionTable\")) {\n-                assignExpr.setValue(objectCreationExpr);\n-            } else if (assignExpr.getTarget().asNameExpr().getNameAsString().equals(\"targetField\")) {\n-                assignExpr.setValue(new StringLiteralExpr(targetField));\n-            } else if (assignExpr.getTarget().asNameExpr().getNameAsString().equals(\"miningFunction\")) {\n-                assignExpr.setValue(new NameExpr(miningFunction.getClass().getName() + \".\" + miningFunction.name()));\n-            } else if (assignExpr.getTarget().asNameExpr().getNameAsString().equals(\"pmmlMODEL\")) {\n-                assignExpr.setValue(new NameExpr(PMML_MODEL.REGRESSION_MODEL.getClass().getName() + \".\" + PMML_MODEL.REGRESSION_MODEL.name()));\n+            final String assignExprName = assignExpr.getTarget().asNameExpr().getNameAsString();\n+            switch (assignExprName) {\n+                case \"regressionTable\":\n+                    assignExpr.setValue(objectCreationExpr);\n+                    break;\n+                case \"targetField\":\n+                    assignExpr.setValue(new StringLiteralExpr(targetField));\n+                    break;\n+                case \"miningFunction\":\n+                    assignExpr.setValue(new NameExpr(miningFunction.getClass().getName() + \".\" + miningFunction.name()));\n+                    break;\n+                case \"pmmlMODEL\":\n+                    assignExpr.setValue(new NameExpr(PMML_MODEL.REGRESSION_MODEL.getClass().getName() + \".\" + PMML_MODEL.REGRESSION_MODEL.name()));\n+                    break;\n+                default:\n+                    // NOOP", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM4MzY2MA=="}, "originalCommit": {"oid": "3dbaa45fe0723e7d6e234ae9b2e5b03a79cc9ce7"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NjM1OTU2OnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-commons/src/main/java/org/kie/pmml/commons/model/predicates/KiePMMLCompoundPredicate.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxMDoyMzoyMVrOHBjA6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMDo0NTo1M1rOHFfCPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM4NDI5Ng==", "bodyText": "Can you please create a ticket for this?", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r471384296", "createdAt": "2020-08-17T10:23:21Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-trusty/kie-pmml-commons/src/main/java/org/kie/pmml/commons/model/predicates/KiePMMLCompoundPredicate.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.commons.model.predicates;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.BinaryOperator;\n+\n+import org.kie.pmml.commons.model.KiePMMLExtension;\n+import org.kie.pmml.commons.model.enums.BOOLEAN_OPERATOR;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * @see <a href=http://dmg.org/pmml/v4-4/TreeModel.html#xsdElement_SimplePredicate>SimplePredicate</a>\n+ */\n+public class KiePMMLCompoundPredicate extends KiePMMLPredicate {\n+\n+    private static final long serialVersionUID = -1996390505352151403L;\n+    private static final Logger logger = LoggerFactory.getLogger(KiePMMLCompoundPredicate.class);\n+\n+    private final BOOLEAN_OPERATOR booleanOperator;\n+    private BinaryOperator<Boolean> operatorFunction;\n+    private List<KiePMMLPredicate> kiePMMLPredicates;\n+\n+    private KiePMMLCompoundPredicate(final String name, final List<KiePMMLExtension> extensions, final BOOLEAN_OPERATOR booleanOperator) {\n+        super(name, extensions);\n+        this.booleanOperator = booleanOperator;\n+    }\n+\n+    /**\n+     * Builder to auto-generate the <b>id</b>\n+     * @return\n+     */\n+    public static Builder builder(List<KiePMMLExtension> extensions, BOOLEAN_OPERATOR booleanOperator) {\n+        return new Builder(extensions, booleanOperator);\n+    }\n+\n+    @Override\n+    public boolean evaluate(Map<String, Object> values) {\n+        Boolean toReturn = null;\n+        for (KiePMMLPredicate kiePMMLPredicate : kiePMMLPredicates) {\n+            toReturn = operatorFunction.apply(toReturn, kiePMMLPredicate.evaluate(values));\n+        }\n+        return toReturn != null && toReturn;\n+    }\n+\n+    @Override\n+    public String getId() {\n+        return id;\n+    }\n+\n+    public BOOLEAN_OPERATOR getBooleanOperator() {\n+        return booleanOperator;\n+    }\n+\n+    public List<KiePMMLPredicate> getKiePMMLPredicates() {\n+        return kiePMMLPredicates;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"KiePMMLCompoundPredicate{\" +\n+                \"booleanOperator=\" + booleanOperator +\n+                \", operatorFunction=\" + operatorFunction +\n+                \", kiePMMLPredicates=\" + kiePMMLPredicates +\n+                \", extensions=\" + extensions +\n+                \", id='\" + id + '\\'' +\n+                \", parentId='\" + parentId + '\\'' +\n+                '}';\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        if (!super.equals(o)) {\n+            return false;\n+        }\n+        KiePMMLCompoundPredicate that = (KiePMMLCompoundPredicate) o;\n+        return booleanOperator == that.booleanOperator &&\n+                Objects.equals(operatorFunction, that.operatorFunction) &&\n+                Objects.equals(kiePMMLPredicates, that.kiePMMLPredicates);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(super.hashCode(), booleanOperator, operatorFunction, kiePMMLPredicates);\n+    }\n+\n+    public static class Builder extends KiePMMLPredicate.Builder<KiePMMLCompoundPredicate> {\n+\n+        private Builder(List<KiePMMLExtension> extensions, BOOLEAN_OPERATOR booleanOperator) {\n+            super(\"CompoundPredicate-\", () -> new KiePMMLCompoundPredicate(\"CompoundPredicate\", extensions, booleanOperator));\n+            toBuild.operatorFunction = getInnerBinaryOperator(booleanOperator);\n+        }\n+\n+        public KiePMMLCompoundPredicate.Builder withKiePMMLPredicates(List<KiePMMLPredicate> kiePMMLPredicates) {\n+            kiePMMLPredicates.forEach(predicate -> predicate.setParentId(toBuild.id));\n+            toBuild.kiePMMLPredicates = kiePMMLPredicates;\n+            return this;\n+        }\n+\n+        private BinaryOperator<Boolean> getInnerBinaryOperator(BOOLEAN_OPERATOR booleanOperator) {\n+            switch (booleanOperator) {\n+                // logic here is\n+                // first boolean may be null (initial evaluation) so we start taking the second boolean\n+                case OR:\n+                    return (aBoolean, aBoolean2) -> aBoolean != null ? aBoolean || aBoolean2 : aBoolean2;\n+                case AND:\n+                    return (aBoolean, aBoolean2) -> aBoolean != null ? aBoolean && aBoolean2 : aBoolean2;\n+                case XOR:\n+                    return (aBoolean, aBoolean2) -> aBoolean != null ? aBoolean ^ aBoolean2 : aBoolean2;\n+                // TODO {gcardosi} How to manage?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dbaa45fe0723e7d6e234ae9b2e5b03a79cc9ce7"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUxMzQwNg==", "bodyText": "@danielezonca\nhttps://issues.redhat.com/browse/DROOLS-5594", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r475513406", "createdAt": "2020-08-24T10:45:53Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-trusty/kie-pmml-commons/src/main/java/org/kie/pmml/commons/model/predicates/KiePMMLCompoundPredicate.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.commons.model.predicates;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.BinaryOperator;\n+\n+import org.kie.pmml.commons.model.KiePMMLExtension;\n+import org.kie.pmml.commons.model.enums.BOOLEAN_OPERATOR;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * @see <a href=http://dmg.org/pmml/v4-4/TreeModel.html#xsdElement_SimplePredicate>SimplePredicate</a>\n+ */\n+public class KiePMMLCompoundPredicate extends KiePMMLPredicate {\n+\n+    private static final long serialVersionUID = -1996390505352151403L;\n+    private static final Logger logger = LoggerFactory.getLogger(KiePMMLCompoundPredicate.class);\n+\n+    private final BOOLEAN_OPERATOR booleanOperator;\n+    private BinaryOperator<Boolean> operatorFunction;\n+    private List<KiePMMLPredicate> kiePMMLPredicates;\n+\n+    private KiePMMLCompoundPredicate(final String name, final List<KiePMMLExtension> extensions, final BOOLEAN_OPERATOR booleanOperator) {\n+        super(name, extensions);\n+        this.booleanOperator = booleanOperator;\n+    }\n+\n+    /**\n+     * Builder to auto-generate the <b>id</b>\n+     * @return\n+     */\n+    public static Builder builder(List<KiePMMLExtension> extensions, BOOLEAN_OPERATOR booleanOperator) {\n+        return new Builder(extensions, booleanOperator);\n+    }\n+\n+    @Override\n+    public boolean evaluate(Map<String, Object> values) {\n+        Boolean toReturn = null;\n+        for (KiePMMLPredicate kiePMMLPredicate : kiePMMLPredicates) {\n+            toReturn = operatorFunction.apply(toReturn, kiePMMLPredicate.evaluate(values));\n+        }\n+        return toReturn != null && toReturn;\n+    }\n+\n+    @Override\n+    public String getId() {\n+        return id;\n+    }\n+\n+    public BOOLEAN_OPERATOR getBooleanOperator() {\n+        return booleanOperator;\n+    }\n+\n+    public List<KiePMMLPredicate> getKiePMMLPredicates() {\n+        return kiePMMLPredicates;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"KiePMMLCompoundPredicate{\" +\n+                \"booleanOperator=\" + booleanOperator +\n+                \", operatorFunction=\" + operatorFunction +\n+                \", kiePMMLPredicates=\" + kiePMMLPredicates +\n+                \", extensions=\" + extensions +\n+                \", id='\" + id + '\\'' +\n+                \", parentId='\" + parentId + '\\'' +\n+                '}';\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        if (!super.equals(o)) {\n+            return false;\n+        }\n+        KiePMMLCompoundPredicate that = (KiePMMLCompoundPredicate) o;\n+        return booleanOperator == that.booleanOperator &&\n+                Objects.equals(operatorFunction, that.operatorFunction) &&\n+                Objects.equals(kiePMMLPredicates, that.kiePMMLPredicates);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(super.hashCode(), booleanOperator, operatorFunction, kiePMMLPredicates);\n+    }\n+\n+    public static class Builder extends KiePMMLPredicate.Builder<KiePMMLCompoundPredicate> {\n+\n+        private Builder(List<KiePMMLExtension> extensions, BOOLEAN_OPERATOR booleanOperator) {\n+            super(\"CompoundPredicate-\", () -> new KiePMMLCompoundPredicate(\"CompoundPredicate\", extensions, booleanOperator));\n+            toBuild.operatorFunction = getInnerBinaryOperator(booleanOperator);\n+        }\n+\n+        public KiePMMLCompoundPredicate.Builder withKiePMMLPredicates(List<KiePMMLPredicate> kiePMMLPredicates) {\n+            kiePMMLPredicates.forEach(predicate -> predicate.setParentId(toBuild.id));\n+            toBuild.kiePMMLPredicates = kiePMMLPredicates;\n+            return this;\n+        }\n+\n+        private BinaryOperator<Boolean> getInnerBinaryOperator(BOOLEAN_OPERATOR booleanOperator) {\n+            switch (booleanOperator) {\n+                // logic here is\n+                // first boolean may be null (initial evaluation) so we start taking the second boolean\n+                case OR:\n+                    return (aBoolean, aBoolean2) -> aBoolean != null ? aBoolean || aBoolean2 : aBoolean2;\n+                case AND:\n+                    return (aBoolean, aBoolean2) -> aBoolean != null ? aBoolean && aBoolean2 : aBoolean2;\n+                case XOR:\n+                    return (aBoolean, aBoolean2) -> aBoolean != null ? aBoolean ^ aBoolean2 : aBoolean2;\n+                // TODO {gcardosi} How to manage?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM4NDI5Ng=="}, "originalCommit": {"oid": "3dbaa45fe0723e7d6e234ae9b2e5b03a79cc9ce7"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NzgwNjQ3OnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-drools/kie-pmml-models-drools-common/src/main/java/org/kie/pmml/models/drools/utils/KiePMMLDroolsModelFactoryUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNjo0ODo1NVrOHBwqnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwODo1MzozMVrOHFahEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTYwNzk2Nw==", "bodyText": "Is it possible? Log message?", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r471607967", "createdAt": "2020-08-17T16:48:55Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-drools/kie-pmml-models-drools-common/src/main/java/org/kie/pmml/models/drools/utils/KiePMMLDroolsModelFactoryUtils.java", "diffHunk": "@@ -106,48 +108,24 @@ static void setConstructor(final Model model, final ConstructorDeclaration const\n         final BlockStmt body = constructorDeclaration.getBody();\n         final List<AssignExpr> assignExprs = body.findAll(AssignExpr.class);\n         assignExprs.forEach(assignExpr -> {\n-            if (assignExpr.getTarget().asNameExpr().getNameAsString().equals(\"targetField\")) {\n-                assignExpr.setValue(new StringLiteralExpr(targetField));\n-            } else if (assignExpr.getTarget().asNameExpr().getNameAsString().equals(\"miningFunction\")) {\n-                assignExpr.setValue(new NameExpr(miningFunction.getClass().getName() + \".\" + miningFunction.name()));\n-            } else if (assignExpr.getTarget().asNameExpr().getNameAsString().equals(\"pmmlMODEL\")) {\n-                PMML_MODEL pmmlModel = PMML_MODEL.byName(model.getClass().getSimpleName());\n-                assignExpr.setValue(new NameExpr(pmmlModel.getClass().getName() + \".\" + pmmlModel.name()));\n+            final String assignExprName = assignExpr.getTarget().asNameExpr().getNameAsString();\n+            switch (assignExprName) {\n+                case \"targetField\":\n+                    assignExpr.setValue(new StringLiteralExpr(targetField));\n+                    break;\n+                case \"miningFunction\":\n+                    assignExpr.setValue(new NameExpr(miningFunction.getClass().getName() + \".\" + miningFunction.name()));\n+                    break;\n+                case \"pmmlMODEL\":\n+                    PMML_MODEL pmmlModel = PMML_MODEL.byName(model.getClass().getSimpleName());\n+                    assignExpr.setValue(new NameExpr(pmmlModel.getClass().getName() + \".\" + pmmlModel.name()));\n+                    break;\n+                default:\n+                    // NOOP", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dbaa45fe0723e7d6e234ae9b2e5b03a79cc9ce7"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQzOTM3Ng==", "bodyText": "@danielezonca\ndone", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r475439376", "createdAt": "2020-08-24T08:53:31Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-drools/kie-pmml-models-drools-common/src/main/java/org/kie/pmml/models/drools/utils/KiePMMLDroolsModelFactoryUtils.java", "diffHunk": "@@ -106,48 +108,24 @@ static void setConstructor(final Model model, final ConstructorDeclaration const\n         final BlockStmt body = constructorDeclaration.getBody();\n         final List<AssignExpr> assignExprs = body.findAll(AssignExpr.class);\n         assignExprs.forEach(assignExpr -> {\n-            if (assignExpr.getTarget().asNameExpr().getNameAsString().equals(\"targetField\")) {\n-                assignExpr.setValue(new StringLiteralExpr(targetField));\n-            } else if (assignExpr.getTarget().asNameExpr().getNameAsString().equals(\"miningFunction\")) {\n-                assignExpr.setValue(new NameExpr(miningFunction.getClass().getName() + \".\" + miningFunction.name()));\n-            } else if (assignExpr.getTarget().asNameExpr().getNameAsString().equals(\"pmmlMODEL\")) {\n-                PMML_MODEL pmmlModel = PMML_MODEL.byName(model.getClass().getSimpleName());\n-                assignExpr.setValue(new NameExpr(pmmlModel.getClass().getName() + \".\" + pmmlModel.name()));\n+            final String assignExprName = assignExpr.getTarget().asNameExpr().getNameAsString();\n+            switch (assignExprName) {\n+                case \"targetField\":\n+                    assignExpr.setValue(new StringLiteralExpr(targetField));\n+                    break;\n+                case \"miningFunction\":\n+                    assignExpr.setValue(new NameExpr(miningFunction.getClass().getName() + \".\" + miningFunction.name()));\n+                    break;\n+                case \"pmmlMODEL\":\n+                    PMML_MODEL pmmlModel = PMML_MODEL.byName(model.getClass().getSimpleName());\n+                    assignExpr.setValue(new NameExpr(pmmlModel.getClass().getName() + \".\" + pmmlModel.name()));\n+                    break;\n+                default:\n+                    // NOOP", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTYwNzk2Nw=="}, "originalCommit": {"oid": "3dbaa45fe0723e7d6e234ae9b2e5b03a79cc9ce7"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NzgxMjIzOnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-mining/kie-pmml-models-mining-compiler/src/main/java/org/kie/pmml/models/mining/compiler/factories/KiePMMLMiningModelFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNjo1MDoyN1rOHBwt-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwODo0NjoyMlrOHFaQqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTYwODgyNw==", "bodyText": "Is it possible? Log message?", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r471608827", "createdAt": "2020-08-17T16:50:27Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-mining/kie-pmml-models-mining-compiler/src/main/java/org/kie/pmml/models/mining/compiler/factories/KiePMMLMiningModelFactory.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.mining.compiler.factories;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import org.dmg.pmml.DataDictionary;\n+import org.dmg.pmml.TransformationDictionary;\n+import org.dmg.pmml.mining.MiningModel;\n+import org.kie.internal.builder.KnowledgeBuilder;\n+import org.kie.pmml.commons.exceptions.KiePMMLException;\n+import org.kie.pmml.commons.exceptions.KiePMMLInternalException;\n+import org.kie.pmml.commons.model.KiePMMLExtension;\n+import org.kie.pmml.commons.model.KiePMMLOutputField;\n+import org.kie.pmml.commons.model.enums.MINING_FUNCTION;\n+import org.kie.pmml.commons.model.enums.PMML_MODEL;\n+import org.kie.pmml.compiler.commons.utils.JavaParserUtils;\n+import org.kie.pmml.models.mining.model.KiePMMLMiningModel;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.javaparser.StaticJavaParser.parseClassOrInterfaceType;\n+import static org.kie.pmml.commons.Constants.MISSING_DEFAULT_CONSTRUCTOR;\n+import static org.kie.pmml.commons.utils.KiePMMLModelUtils.getSanitizedClassName;\n+import static org.kie.pmml.commons.utils.KiePMMLModelUtils.getSanitizedPackageName;\n+import static org.kie.pmml.compiler.commons.factories.KiePMMLExtensionFactory.getKiePMMLExtensions;\n+import static org.kie.pmml.compiler.commons.factories.KiePMMLOutputFieldFactory.getOutputFields;\n+import static org.kie.pmml.compiler.commons.utils.JavaParserUtils.MAIN_CLASS_NOT_FOUND;\n+import static org.kie.pmml.compiler.commons.utils.JavaParserUtils.getFullClassName;\n+import static org.kie.pmml.compiler.commons.utils.KiePMMLModelFactoryUtils.addOutputFieldsPopulation;\n+import static org.kie.pmml.compiler.commons.utils.KiePMMLModelFactoryUtils.addTransformationsInClassOrInterfaceDeclaration;\n+import static org.kie.pmml.compiler.commons.utils.KiePMMLModelFactoryUtils.setConstructorSuperNameInvocation;\n+import static org.kie.pmml.compiler.commons.utils.ModelUtils.getTargetFieldName;\n+import static org.kie.pmml.models.mining.compiler.factories.KiePMMLSegmentationFactory.getSegmentation;\n+import static org.kie.pmml.models.mining.compiler.factories.KiePMMLSegmentationFactory.getSegmentationSourcesMap;\n+\n+public class KiePMMLMiningModelFactory {\n+\n+    static final String SEGMENTATIONNAME_TEMPLATE = \"%s_Segmentation\";\n+    private static final Logger logger = LoggerFactory.getLogger(KiePMMLMiningModelFactory.class.getName());\n+    static final String KIE_PMML_MINING_MODEL_TEMPLATE_JAVA = \"KiePMMLMiningModelTemplate.tmpl\";\n+    static final String KIE_PMML_MINING_MODEL_TEMPLATE = \"KiePMMLMiningModelTemplate\";\n+\n+\n+    private KiePMMLMiningModelFactory() {\n+        // Avoid instantiation\n+    }\n+\n+    public static KiePMMLMiningModel getKiePMMLMiningModel(final DataDictionary dataDictionary,\n+                                                           final TransformationDictionary transformationDictionary,\n+                                                           final MiningModel model,\n+                                                           final KnowledgeBuilder kBuilder) {\n+        logger.debug(\"getKiePMMLMiningModel {}\", model);\n+        String name = model.getModelName();\n+        Optional<String> targetFieldName = getTargetFieldName(dataDictionary, model);\n+        List<KiePMMLExtension> extensions = getKiePMMLExtensions(model.getExtensions());\n+        return KiePMMLMiningModel.builder(name, extensions, MINING_FUNCTION.byName(model.getMiningFunction().value()))\n+                .withAlgorithmName(model.getAlgorithmName())\n+                .withScorable(model.isScorable())\n+                .withSegmentation(getSegmentation(dataDictionary,\n+                                                  transformationDictionary,\n+                                                  model.getSegmentation(),\n+                                                  String.format(SEGMENTATIONNAME_TEMPLATE, model.getModelName()),\n+                                                  kBuilder))\n+                .withTargetField(targetFieldName.orElse(null))\n+                .build();\n+    }\n+\n+    public static Map<String, String> getKiePMMLMiningModelSourcesMap(final DataDictionary dataDictionary,\n+                                                                      final TransformationDictionary transformationDictionary,\n+                                                                      final MiningModel model,\n+                                                                      final String parentPackageName,\n+                                                                      final KnowledgeBuilder kBuilder) {\n+        logger.trace(\"getKiePMMLMiningModelSourcesMap {} {} {}\", dataDictionary, model, parentPackageName);\n+        final String segmentationName = String.format(SEGMENTATIONNAME_TEMPLATE, model.getModelName());\n+        final Map<String, String> toReturn = getSegmentationSourcesMap(parentPackageName,\n+                                                                       dataDictionary,\n+                                                                       transformationDictionary,\n+                                                                       model.getSegmentation(),\n+                                                                       segmentationName,\n+                                                                       kBuilder);\n+        String segmentationClass = getSanitizedPackageName(parentPackageName + \".\" + segmentationName) + \".\" + getSanitizedClassName(segmentationName);\n+        if (!toReturn.containsKey(segmentationClass)) {\n+            throw new KiePMMLException(\"Expected generated class \" + segmentationClass + \" not found\");\n+        }\n+        String className = getSanitizedClassName(model.getModelName());\n+        CompilationUnit cloneCU = JavaParserUtils.getKiePMMLModelCompilationUnit(className, parentPackageName, KIE_PMML_MINING_MODEL_TEMPLATE_JAVA, KIE_PMML_MINING_MODEL_TEMPLATE);\n+        ClassOrInterfaceDeclaration modelTemplate = cloneCU.getClassByName(className)\n+                .orElseThrow(() -> new KiePMMLException(MAIN_CLASS_NOT_FOUND + \": \" + className));\n+        String modelName = model.getModelName();\n+        String targetFieldName = getTargetFieldName(dataDictionary, model).orElse(null);\n+        List<KiePMMLOutputField> outputFields = getOutputFields(model);\n+        final ConstructorDeclaration constructorDeclaration = modelTemplate.getDefaultConstructor().orElseThrow(() -> new KiePMMLInternalException(String.format(MISSING_DEFAULT_CONSTRUCTOR, modelTemplate.getName())));\n+        setConstructor(className,\n+                       constructorDeclaration,\n+                       targetFieldName,\n+                       MINING_FUNCTION.byName(model.getMiningFunction().value()),\n+                       modelName,\n+                       segmentationClass);\n+        addOutputFieldsPopulation(constructorDeclaration.getBody(), outputFields);\n+        addTransformationsInClassOrInterfaceDeclaration(modelTemplate, transformationDictionary, model.getLocalTransformations());\n+        toReturn.put(getFullClassName(cloneCU), cloneCU.toString());\n+        return toReturn;\n+    }\n+\n+    static void setConstructor(final String generatedClassName,\n+                               final ConstructorDeclaration constructorDeclaration,\n+                               final String targetField,\n+                               final MINING_FUNCTION miningFunction,\n+                               final String modelName,\n+                               final String segmentationClass) {\n+        setConstructorSuperNameInvocation(generatedClassName, constructorDeclaration, modelName);\n+        final BlockStmt body = constructorDeclaration.getBody();\n+        final List<AssignExpr> assignExprs = body.findAll(AssignExpr.class);\n+        assignExprs.forEach(assignExpr -> {\n+            final String assignExprName = assignExpr.getTarget().asNameExpr().getNameAsString();\n+            switch (assignExprName) {\n+                case \"targetField\":\n+                    assignExpr.setValue(new StringLiteralExpr(targetField));\n+                    break;\n+                case \"miningFunction\":\n+                    assignExpr.setValue(new NameExpr(miningFunction.getClass().getName() + \".\" + miningFunction.name()));\n+                break;\n+                case \"pmmlMODEL\":\n+                    assignExpr.setValue(new NameExpr(PMML_MODEL.MINING_MODEL.getClass().getName() + \".\" + PMML_MODEL.MINING_MODEL.name()));\n+                    break;\n+                case \"segmentation\":\n+                    ClassOrInterfaceType kiePMMLSegmentationClass = parseClassOrInterfaceType(segmentationClass);\n+                    ObjectCreationExpr objectCreationExpr = new ObjectCreationExpr();\n+                    objectCreationExpr.setType(kiePMMLSegmentationClass);\n+                    assignExpr.setValue(objectCreationExpr);\n+                    break;\n+                default:\n+                    // NOOP", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dbaa45fe0723e7d6e234ae9b2e5b03a79cc9ce7"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQzNTE3Nw==", "bodyText": "@danielezonca\ndone", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r475435177", "createdAt": "2020-08-24T08:46:22Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-mining/kie-pmml-models-mining-compiler/src/main/java/org/kie/pmml/models/mining/compiler/factories/KiePMMLMiningModelFactory.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.mining.compiler.factories;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import org.dmg.pmml.DataDictionary;\n+import org.dmg.pmml.TransformationDictionary;\n+import org.dmg.pmml.mining.MiningModel;\n+import org.kie.internal.builder.KnowledgeBuilder;\n+import org.kie.pmml.commons.exceptions.KiePMMLException;\n+import org.kie.pmml.commons.exceptions.KiePMMLInternalException;\n+import org.kie.pmml.commons.model.KiePMMLExtension;\n+import org.kie.pmml.commons.model.KiePMMLOutputField;\n+import org.kie.pmml.commons.model.enums.MINING_FUNCTION;\n+import org.kie.pmml.commons.model.enums.PMML_MODEL;\n+import org.kie.pmml.compiler.commons.utils.JavaParserUtils;\n+import org.kie.pmml.models.mining.model.KiePMMLMiningModel;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.javaparser.StaticJavaParser.parseClassOrInterfaceType;\n+import static org.kie.pmml.commons.Constants.MISSING_DEFAULT_CONSTRUCTOR;\n+import static org.kie.pmml.commons.utils.KiePMMLModelUtils.getSanitizedClassName;\n+import static org.kie.pmml.commons.utils.KiePMMLModelUtils.getSanitizedPackageName;\n+import static org.kie.pmml.compiler.commons.factories.KiePMMLExtensionFactory.getKiePMMLExtensions;\n+import static org.kie.pmml.compiler.commons.factories.KiePMMLOutputFieldFactory.getOutputFields;\n+import static org.kie.pmml.compiler.commons.utils.JavaParserUtils.MAIN_CLASS_NOT_FOUND;\n+import static org.kie.pmml.compiler.commons.utils.JavaParserUtils.getFullClassName;\n+import static org.kie.pmml.compiler.commons.utils.KiePMMLModelFactoryUtils.addOutputFieldsPopulation;\n+import static org.kie.pmml.compiler.commons.utils.KiePMMLModelFactoryUtils.addTransformationsInClassOrInterfaceDeclaration;\n+import static org.kie.pmml.compiler.commons.utils.KiePMMLModelFactoryUtils.setConstructorSuperNameInvocation;\n+import static org.kie.pmml.compiler.commons.utils.ModelUtils.getTargetFieldName;\n+import static org.kie.pmml.models.mining.compiler.factories.KiePMMLSegmentationFactory.getSegmentation;\n+import static org.kie.pmml.models.mining.compiler.factories.KiePMMLSegmentationFactory.getSegmentationSourcesMap;\n+\n+public class KiePMMLMiningModelFactory {\n+\n+    static final String SEGMENTATIONNAME_TEMPLATE = \"%s_Segmentation\";\n+    private static final Logger logger = LoggerFactory.getLogger(KiePMMLMiningModelFactory.class.getName());\n+    static final String KIE_PMML_MINING_MODEL_TEMPLATE_JAVA = \"KiePMMLMiningModelTemplate.tmpl\";\n+    static final String KIE_PMML_MINING_MODEL_TEMPLATE = \"KiePMMLMiningModelTemplate\";\n+\n+\n+    private KiePMMLMiningModelFactory() {\n+        // Avoid instantiation\n+    }\n+\n+    public static KiePMMLMiningModel getKiePMMLMiningModel(final DataDictionary dataDictionary,\n+                                                           final TransformationDictionary transformationDictionary,\n+                                                           final MiningModel model,\n+                                                           final KnowledgeBuilder kBuilder) {\n+        logger.debug(\"getKiePMMLMiningModel {}\", model);\n+        String name = model.getModelName();\n+        Optional<String> targetFieldName = getTargetFieldName(dataDictionary, model);\n+        List<KiePMMLExtension> extensions = getKiePMMLExtensions(model.getExtensions());\n+        return KiePMMLMiningModel.builder(name, extensions, MINING_FUNCTION.byName(model.getMiningFunction().value()))\n+                .withAlgorithmName(model.getAlgorithmName())\n+                .withScorable(model.isScorable())\n+                .withSegmentation(getSegmentation(dataDictionary,\n+                                                  transformationDictionary,\n+                                                  model.getSegmentation(),\n+                                                  String.format(SEGMENTATIONNAME_TEMPLATE, model.getModelName()),\n+                                                  kBuilder))\n+                .withTargetField(targetFieldName.orElse(null))\n+                .build();\n+    }\n+\n+    public static Map<String, String> getKiePMMLMiningModelSourcesMap(final DataDictionary dataDictionary,\n+                                                                      final TransformationDictionary transformationDictionary,\n+                                                                      final MiningModel model,\n+                                                                      final String parentPackageName,\n+                                                                      final KnowledgeBuilder kBuilder) {\n+        logger.trace(\"getKiePMMLMiningModelSourcesMap {} {} {}\", dataDictionary, model, parentPackageName);\n+        final String segmentationName = String.format(SEGMENTATIONNAME_TEMPLATE, model.getModelName());\n+        final Map<String, String> toReturn = getSegmentationSourcesMap(parentPackageName,\n+                                                                       dataDictionary,\n+                                                                       transformationDictionary,\n+                                                                       model.getSegmentation(),\n+                                                                       segmentationName,\n+                                                                       kBuilder);\n+        String segmentationClass = getSanitizedPackageName(parentPackageName + \".\" + segmentationName) + \".\" + getSanitizedClassName(segmentationName);\n+        if (!toReturn.containsKey(segmentationClass)) {\n+            throw new KiePMMLException(\"Expected generated class \" + segmentationClass + \" not found\");\n+        }\n+        String className = getSanitizedClassName(model.getModelName());\n+        CompilationUnit cloneCU = JavaParserUtils.getKiePMMLModelCompilationUnit(className, parentPackageName, KIE_PMML_MINING_MODEL_TEMPLATE_JAVA, KIE_PMML_MINING_MODEL_TEMPLATE);\n+        ClassOrInterfaceDeclaration modelTemplate = cloneCU.getClassByName(className)\n+                .orElseThrow(() -> new KiePMMLException(MAIN_CLASS_NOT_FOUND + \": \" + className));\n+        String modelName = model.getModelName();\n+        String targetFieldName = getTargetFieldName(dataDictionary, model).orElse(null);\n+        List<KiePMMLOutputField> outputFields = getOutputFields(model);\n+        final ConstructorDeclaration constructorDeclaration = modelTemplate.getDefaultConstructor().orElseThrow(() -> new KiePMMLInternalException(String.format(MISSING_DEFAULT_CONSTRUCTOR, modelTemplate.getName())));\n+        setConstructor(className,\n+                       constructorDeclaration,\n+                       targetFieldName,\n+                       MINING_FUNCTION.byName(model.getMiningFunction().value()),\n+                       modelName,\n+                       segmentationClass);\n+        addOutputFieldsPopulation(constructorDeclaration.getBody(), outputFields);\n+        addTransformationsInClassOrInterfaceDeclaration(modelTemplate, transformationDictionary, model.getLocalTransformations());\n+        toReturn.put(getFullClassName(cloneCU), cloneCU.toString());\n+        return toReturn;\n+    }\n+\n+    static void setConstructor(final String generatedClassName,\n+                               final ConstructorDeclaration constructorDeclaration,\n+                               final String targetField,\n+                               final MINING_FUNCTION miningFunction,\n+                               final String modelName,\n+                               final String segmentationClass) {\n+        setConstructorSuperNameInvocation(generatedClassName, constructorDeclaration, modelName);\n+        final BlockStmt body = constructorDeclaration.getBody();\n+        final List<AssignExpr> assignExprs = body.findAll(AssignExpr.class);\n+        assignExprs.forEach(assignExpr -> {\n+            final String assignExprName = assignExpr.getTarget().asNameExpr().getNameAsString();\n+            switch (assignExprName) {\n+                case \"targetField\":\n+                    assignExpr.setValue(new StringLiteralExpr(targetField));\n+                    break;\n+                case \"miningFunction\":\n+                    assignExpr.setValue(new NameExpr(miningFunction.getClass().getName() + \".\" + miningFunction.name()));\n+                break;\n+                case \"pmmlMODEL\":\n+                    assignExpr.setValue(new NameExpr(PMML_MODEL.MINING_MODEL.getClass().getName() + \".\" + PMML_MODEL.MINING_MODEL.name()));\n+                    break;\n+                case \"segmentation\":\n+                    ClassOrInterfaceType kiePMMLSegmentationClass = parseClassOrInterfaceType(segmentationClass);\n+                    ObjectCreationExpr objectCreationExpr = new ObjectCreationExpr();\n+                    objectCreationExpr.setType(kiePMMLSegmentationClass);\n+                    assignExpr.setValue(objectCreationExpr);\n+                    break;\n+                default:\n+                    // NOOP", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTYwODgyNw=="}, "originalCommit": {"oid": "3dbaa45fe0723e7d6e234ae9b2e5b03a79cc9ce7"}, "originalPosition": 158}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NzgxMzMxOnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-mining/kie-pmml-models-mining-compiler/src/main/java/org/kie/pmml/models/mining/compiler/factories/KiePMMLSegmentFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNjo1MDo0NFrOHBwupg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwODo0NjoyN1rOHFaQ4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTYwODk5OA==", "bodyText": "Is it possible? Log message?", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r471608998", "createdAt": "2020-08-17T16:50:44Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-mining/kie-pmml-models-mining-compiler/src/main/java/org/kie/pmml/models/mining/compiler/factories/KiePMMLSegmentFactory.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.mining.compiler.factories;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.DoubleLiteralExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import org.dmg.pmml.DataDictionary;\n+import org.dmg.pmml.TransformationDictionary;\n+import org.dmg.pmml.mining.Segment;\n+import org.kie.internal.builder.KnowledgeBuilder;\n+import org.kie.pmml.commons.exceptions.KiePMMLException;\n+import org.kie.pmml.commons.exceptions.KiePMMLInternalException;\n+import org.kie.pmml.commons.model.HasSourcesMap;\n+import org.kie.pmml.commons.model.KiePMMLModel;\n+import org.kie.pmml.commons.model.predicates.KiePMMLPredicate;\n+import org.kie.pmml.compiler.commons.utils.JavaParserUtils;\n+import org.kie.pmml.models.mining.model.segmentation.KiePMMLSegment;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.javaparser.StaticJavaParser.parseClassOrInterfaceType;\n+import static org.kie.pmml.commons.Constants.MISSING_DEFAULT_CONSTRUCTOR;\n+import static org.kie.pmml.commons.utils.KiePMMLModelUtils.getSanitizedClassName;\n+import static org.kie.pmml.commons.utils.KiePMMLModelUtils.getSanitizedPackageName;\n+import static org.kie.pmml.compiler.commons.factories.KiePMMLExtensionFactory.getKiePMMLExtensions;\n+import static org.kie.pmml.compiler.commons.factories.KiePMMLPredicateFactory.getPredicate;\n+import static org.kie.pmml.compiler.commons.factories.KiePMMLPredicateFactory.getPredicateSourcesMap;\n+import static org.kie.pmml.compiler.commons.implementations.KiePMMLModelRetriever.getFromCommonDataAndTransformationDictionaryAndModel;\n+import static org.kie.pmml.compiler.commons.implementations.KiePMMLModelRetriever.getFromCommonDataAndTransformationDictionaryAndModelFromPlugin;\n+import static org.kie.pmml.compiler.commons.utils.JavaParserUtils.MAIN_CLASS_NOT_FOUND;\n+import static org.kie.pmml.compiler.commons.utils.JavaParserUtils.getFullClassName;\n+import static org.kie.pmml.compiler.commons.utils.KiePMMLModelFactoryUtils.setConstructorSuperNameInvocation;\n+\n+public class KiePMMLSegmentFactory {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(KiePMMLSegmentFactory.class.getName());\n+    static final String KIE_PMML_SEGMENT_TEMPLATE_JAVA = \"KiePMMLSegmentTemplate.tmpl\";\n+    static final String KIE_PMML_SEGMENT_TEMPLATE = \"KiePMMLSegmentTemplate\";\n+\n+    private KiePMMLSegmentFactory() {\n+    }\n+\n+    public static List<KiePMMLSegment> getSegments(final DataDictionary dataDictionary,\n+                                                   final TransformationDictionary transformationDictionary,\n+                                                   final List<Segment> segments,\n+                                                   final KnowledgeBuilder kBuilder) {\n+        logger.debug(\"getSegments {}\", segments);\n+        return segments.stream().map(segment -> getSegment(dataDictionary, transformationDictionary, segment,\n+                                                           kBuilder)).collect(Collectors.toList());\n+    }\n+\n+    public static KiePMMLSegment getSegment(final DataDictionary dataDictionary,\n+                                            final TransformationDictionary transformationDictionary,\n+                                            final Segment segment,\n+                                            final KnowledgeBuilder kBuilder) {\n+        logger.debug(\"getSegment {}\", segment);\n+        return KiePMMLSegment.builder(segment.getId(),\n+                                      getKiePMMLExtensions(segment.getExtensions()),\n+                                      getPredicate(segment.getPredicate(), dataDictionary),\n+                                      getFromCommonDataAndTransformationDictionaryAndModel(dataDictionary,\n+                                                                                           transformationDictionary,\n+                                                                                           segment.getModel(),\n+                                                                                           kBuilder).orElseThrow(() -> new KiePMMLException(\"Failed to get the KiePMMLModel for segment \" + segment.getModel().getModelName())))\n+                .withWeight(segment.getWeight().doubleValue())\n+                .build();\n+    }\n+\n+    public static Map<String, String> getSegmentsSourcesMap(final String parentPackageName,\n+                                                            final DataDictionary dataDictionary,\n+                                                            final TransformationDictionary transformationDictionary,\n+                                                            final List<Segment> segments,\n+                                                            final KnowledgeBuilder kBuilder) {\n+        logger.debug(\"getSegments {}\", segments);\n+        final Map<String, String> toReturn = new HashMap<>();\n+        segments.forEach(segment -> toReturn.putAll(getSegmentSourcesMap(parentPackageName,\n+                                                                         dataDictionary,\n+                                                                         transformationDictionary, segment,\n+                                                                         kBuilder)));\n+\n+        return toReturn;\n+    }\n+\n+    public static Map<String, String> getSegmentSourcesMap(\n+            final String parentPackageName,\n+            final DataDictionary dataDictionary,\n+            final TransformationDictionary transformationDictionary,\n+            final Segment segment,\n+            final KnowledgeBuilder kBuilder) {\n+        logger.debug(\"getSegment {}\", segment);\n+        final String packageName = getSanitizedPackageName(parentPackageName + \".\" + segment.getId());\n+        KiePMMLModel kiePmmlModel = getFromCommonDataAndTransformationDictionaryAndModelFromPlugin(\n+                packageName,\n+                dataDictionary,\n+                transformationDictionary,\n+                segment.getModel(),\n+                kBuilder)\n+                .orElseThrow(() -> new KiePMMLException(\"Failed to get the KiePMMLModel for segment \" + segment.getModel().getModelName()));\n+        if (!(kiePmmlModel instanceof HasSourcesMap)) {\n+            throw new KiePMMLException(\"Retrieved KiePMMLModel for segment \" + segment.getModel().getModelName() + \" \" +\n+                                               \"does not implement HasSources\");\n+        }\n+        final Map<String, String> toReturn = new HashMap<>(((HasSourcesMap) kiePmmlModel).getSourcesMap());\n+        String kiePMMLModelClass = packageName + \".\" + getSanitizedClassName(segment.getModel().getModelName());\n+        if (!toReturn.containsKey(kiePMMLModelClass)) {\n+            throw new KiePMMLException(\"Expected generated class \" + kiePMMLModelClass + \" not found\");\n+        }\n+        final String className = getSanitizedClassName(segment.getId());\n+        CompilationUnit cloneCU = JavaParserUtils.getKiePMMLModelCompilationUnit(className, packageName, KIE_PMML_SEGMENT_TEMPLATE_JAVA, KIE_PMML_SEGMENT_TEMPLATE);\n+        ClassOrInterfaceDeclaration segmentTemplate = cloneCU.getClassByName(className)\n+                .orElseThrow(() -> new KiePMMLException(MAIN_CLASS_NOT_FOUND + \": \" + className));\n+        final ConstructorDeclaration constructorDeclaration = segmentTemplate.getDefaultConstructor().orElseThrow(() -> new KiePMMLInternalException(String.format(MISSING_DEFAULT_CONSTRUCTOR, segmentTemplate.getName())));\n+        KiePMMLPredicate predicate = getPredicate(segment.getPredicate(), dataDictionary);\n+        toReturn.putAll(getPredicateSourcesMap(predicate, packageName));\n+        String predicateClassName = packageName + \".\" + predicate.getName();\n+        setConstructor(segment.getId(), className, constructorDeclaration, predicateClassName,  kiePMMLModelClass, segment.getWeight().doubleValue());\n+        toReturn.put(getFullClassName(cloneCU), cloneCU.toString());\n+        return toReturn;\n+    }\n+\n+    static void setConstructor(final String segmentName,\n+                               final String generatedClassName,\n+                               final ConstructorDeclaration constructorDeclaration,\n+                               final String predicateClassName,\n+                               final String kiePMMLModelClass,\n+                               final double weight) {\n+        setConstructorSuperNameInvocation(generatedClassName, constructorDeclaration, segmentName);\n+        final BlockStmt body = constructorDeclaration.getBody();\n+        body.getStatements().iterator().forEachRemaining(statement -> {\n+            if (statement instanceof ExplicitConstructorInvocationStmt) {\n+                ExplicitConstructorInvocationStmt superStatement = (ExplicitConstructorInvocationStmt) statement;\n+                NameExpr nameExprs = (NameExpr) superStatement.getArgument(2);\n+                ClassOrInterfaceType classOrInterfaceType = parseClassOrInterfaceType(predicateClassName);\n+                ObjectCreationExpr objectCreationExpr = new ObjectCreationExpr();\n+                objectCreationExpr.setType(classOrInterfaceType);\n+                nameExprs.setName(objectCreationExpr.toString());\n+                nameExprs = (NameExpr) superStatement.getArgument(3);\n+                classOrInterfaceType = parseClassOrInterfaceType(kiePMMLModelClass);\n+                objectCreationExpr = new ObjectCreationExpr();\n+                objectCreationExpr.setType(classOrInterfaceType);\n+                nameExprs.setName(objectCreationExpr.toString());\n+            }\n+        });\n+        final List<AssignExpr> assignExprs = body.findAll(AssignExpr.class);\n+        assignExprs.forEach(assignExpr -> {\n+            final String assignExprName = assignExpr.getTarget().asNameExpr().getNameAsString();\n+            switch (assignExprName) {\n+                case \"weight\":\n+                    assignExpr.setValue(new DoubleLiteralExpr(weight));\n+                    break;\n+                case \"id\":\n+                    assignExpr.setValue(new StringLiteralExpr(segmentName));\n+                    break;\n+                default:\n+                    // NOOP", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dbaa45fe0723e7d6e234ae9b2e5b03a79cc9ce7"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQzNTIzMw==", "bodyText": "@danielezonca\ndone", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r475435233", "createdAt": "2020-08-24T08:46:27Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-trusty/kie-pmml-models/kie-pmml-models-mining/kie-pmml-models-mining-compiler/src/main/java/org/kie/pmml/models/mining/compiler/factories/KiePMMLSegmentFactory.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.mining.compiler.factories;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.DoubleLiteralExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import org.dmg.pmml.DataDictionary;\n+import org.dmg.pmml.TransformationDictionary;\n+import org.dmg.pmml.mining.Segment;\n+import org.kie.internal.builder.KnowledgeBuilder;\n+import org.kie.pmml.commons.exceptions.KiePMMLException;\n+import org.kie.pmml.commons.exceptions.KiePMMLInternalException;\n+import org.kie.pmml.commons.model.HasSourcesMap;\n+import org.kie.pmml.commons.model.KiePMMLModel;\n+import org.kie.pmml.commons.model.predicates.KiePMMLPredicate;\n+import org.kie.pmml.compiler.commons.utils.JavaParserUtils;\n+import org.kie.pmml.models.mining.model.segmentation.KiePMMLSegment;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.javaparser.StaticJavaParser.parseClassOrInterfaceType;\n+import static org.kie.pmml.commons.Constants.MISSING_DEFAULT_CONSTRUCTOR;\n+import static org.kie.pmml.commons.utils.KiePMMLModelUtils.getSanitizedClassName;\n+import static org.kie.pmml.commons.utils.KiePMMLModelUtils.getSanitizedPackageName;\n+import static org.kie.pmml.compiler.commons.factories.KiePMMLExtensionFactory.getKiePMMLExtensions;\n+import static org.kie.pmml.compiler.commons.factories.KiePMMLPredicateFactory.getPredicate;\n+import static org.kie.pmml.compiler.commons.factories.KiePMMLPredicateFactory.getPredicateSourcesMap;\n+import static org.kie.pmml.compiler.commons.implementations.KiePMMLModelRetriever.getFromCommonDataAndTransformationDictionaryAndModel;\n+import static org.kie.pmml.compiler.commons.implementations.KiePMMLModelRetriever.getFromCommonDataAndTransformationDictionaryAndModelFromPlugin;\n+import static org.kie.pmml.compiler.commons.utils.JavaParserUtils.MAIN_CLASS_NOT_FOUND;\n+import static org.kie.pmml.compiler.commons.utils.JavaParserUtils.getFullClassName;\n+import static org.kie.pmml.compiler.commons.utils.KiePMMLModelFactoryUtils.setConstructorSuperNameInvocation;\n+\n+public class KiePMMLSegmentFactory {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(KiePMMLSegmentFactory.class.getName());\n+    static final String KIE_PMML_SEGMENT_TEMPLATE_JAVA = \"KiePMMLSegmentTemplate.tmpl\";\n+    static final String KIE_PMML_SEGMENT_TEMPLATE = \"KiePMMLSegmentTemplate\";\n+\n+    private KiePMMLSegmentFactory() {\n+    }\n+\n+    public static List<KiePMMLSegment> getSegments(final DataDictionary dataDictionary,\n+                                                   final TransformationDictionary transformationDictionary,\n+                                                   final List<Segment> segments,\n+                                                   final KnowledgeBuilder kBuilder) {\n+        logger.debug(\"getSegments {}\", segments);\n+        return segments.stream().map(segment -> getSegment(dataDictionary, transformationDictionary, segment,\n+                                                           kBuilder)).collect(Collectors.toList());\n+    }\n+\n+    public static KiePMMLSegment getSegment(final DataDictionary dataDictionary,\n+                                            final TransformationDictionary transformationDictionary,\n+                                            final Segment segment,\n+                                            final KnowledgeBuilder kBuilder) {\n+        logger.debug(\"getSegment {}\", segment);\n+        return KiePMMLSegment.builder(segment.getId(),\n+                                      getKiePMMLExtensions(segment.getExtensions()),\n+                                      getPredicate(segment.getPredicate(), dataDictionary),\n+                                      getFromCommonDataAndTransformationDictionaryAndModel(dataDictionary,\n+                                                                                           transformationDictionary,\n+                                                                                           segment.getModel(),\n+                                                                                           kBuilder).orElseThrow(() -> new KiePMMLException(\"Failed to get the KiePMMLModel for segment \" + segment.getModel().getModelName())))\n+                .withWeight(segment.getWeight().doubleValue())\n+                .build();\n+    }\n+\n+    public static Map<String, String> getSegmentsSourcesMap(final String parentPackageName,\n+                                                            final DataDictionary dataDictionary,\n+                                                            final TransformationDictionary transformationDictionary,\n+                                                            final List<Segment> segments,\n+                                                            final KnowledgeBuilder kBuilder) {\n+        logger.debug(\"getSegments {}\", segments);\n+        final Map<String, String> toReturn = new HashMap<>();\n+        segments.forEach(segment -> toReturn.putAll(getSegmentSourcesMap(parentPackageName,\n+                                                                         dataDictionary,\n+                                                                         transformationDictionary, segment,\n+                                                                         kBuilder)));\n+\n+        return toReturn;\n+    }\n+\n+    public static Map<String, String> getSegmentSourcesMap(\n+            final String parentPackageName,\n+            final DataDictionary dataDictionary,\n+            final TransformationDictionary transformationDictionary,\n+            final Segment segment,\n+            final KnowledgeBuilder kBuilder) {\n+        logger.debug(\"getSegment {}\", segment);\n+        final String packageName = getSanitizedPackageName(parentPackageName + \".\" + segment.getId());\n+        KiePMMLModel kiePmmlModel = getFromCommonDataAndTransformationDictionaryAndModelFromPlugin(\n+                packageName,\n+                dataDictionary,\n+                transformationDictionary,\n+                segment.getModel(),\n+                kBuilder)\n+                .orElseThrow(() -> new KiePMMLException(\"Failed to get the KiePMMLModel for segment \" + segment.getModel().getModelName()));\n+        if (!(kiePmmlModel instanceof HasSourcesMap)) {\n+            throw new KiePMMLException(\"Retrieved KiePMMLModel for segment \" + segment.getModel().getModelName() + \" \" +\n+                                               \"does not implement HasSources\");\n+        }\n+        final Map<String, String> toReturn = new HashMap<>(((HasSourcesMap) kiePmmlModel).getSourcesMap());\n+        String kiePMMLModelClass = packageName + \".\" + getSanitizedClassName(segment.getModel().getModelName());\n+        if (!toReturn.containsKey(kiePMMLModelClass)) {\n+            throw new KiePMMLException(\"Expected generated class \" + kiePMMLModelClass + \" not found\");\n+        }\n+        final String className = getSanitizedClassName(segment.getId());\n+        CompilationUnit cloneCU = JavaParserUtils.getKiePMMLModelCompilationUnit(className, packageName, KIE_PMML_SEGMENT_TEMPLATE_JAVA, KIE_PMML_SEGMENT_TEMPLATE);\n+        ClassOrInterfaceDeclaration segmentTemplate = cloneCU.getClassByName(className)\n+                .orElseThrow(() -> new KiePMMLException(MAIN_CLASS_NOT_FOUND + \": \" + className));\n+        final ConstructorDeclaration constructorDeclaration = segmentTemplate.getDefaultConstructor().orElseThrow(() -> new KiePMMLInternalException(String.format(MISSING_DEFAULT_CONSTRUCTOR, segmentTemplate.getName())));\n+        KiePMMLPredicate predicate = getPredicate(segment.getPredicate(), dataDictionary);\n+        toReturn.putAll(getPredicateSourcesMap(predicate, packageName));\n+        String predicateClassName = packageName + \".\" + predicate.getName();\n+        setConstructor(segment.getId(), className, constructorDeclaration, predicateClassName,  kiePMMLModelClass, segment.getWeight().doubleValue());\n+        toReturn.put(getFullClassName(cloneCU), cloneCU.toString());\n+        return toReturn;\n+    }\n+\n+    static void setConstructor(final String segmentName,\n+                               final String generatedClassName,\n+                               final ConstructorDeclaration constructorDeclaration,\n+                               final String predicateClassName,\n+                               final String kiePMMLModelClass,\n+                               final double weight) {\n+        setConstructorSuperNameInvocation(generatedClassName, constructorDeclaration, segmentName);\n+        final BlockStmt body = constructorDeclaration.getBody();\n+        body.getStatements().iterator().forEachRemaining(statement -> {\n+            if (statement instanceof ExplicitConstructorInvocationStmt) {\n+                ExplicitConstructorInvocationStmt superStatement = (ExplicitConstructorInvocationStmt) statement;\n+                NameExpr nameExprs = (NameExpr) superStatement.getArgument(2);\n+                ClassOrInterfaceType classOrInterfaceType = parseClassOrInterfaceType(predicateClassName);\n+                ObjectCreationExpr objectCreationExpr = new ObjectCreationExpr();\n+                objectCreationExpr.setType(classOrInterfaceType);\n+                nameExprs.setName(objectCreationExpr.toString());\n+                nameExprs = (NameExpr) superStatement.getArgument(3);\n+                classOrInterfaceType = parseClassOrInterfaceType(kiePMMLModelClass);\n+                objectCreationExpr = new ObjectCreationExpr();\n+                objectCreationExpr.setType(classOrInterfaceType);\n+                nameExprs.setName(objectCreationExpr.toString());\n+            }\n+        });\n+        final List<AssignExpr> assignExprs = body.findAll(AssignExpr.class);\n+        assignExprs.forEach(assignExpr -> {\n+            final String assignExprName = assignExpr.getTarget().asNameExpr().getNameAsString();\n+            switch (assignExprName) {\n+                case \"weight\":\n+                    assignExpr.setValue(new DoubleLiteralExpr(weight));\n+                    break;\n+                case \"id\":\n+                    assignExpr.setValue(new StringLiteralExpr(segmentName));\n+                    break;\n+                default:\n+                    // NOOP", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTYwODk5OA=="}, "originalCommit": {"oid": "3dbaa45fe0723e7d6e234ae9b2e5b03a79cc9ce7"}, "originalPosition": 181}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MDQxNzMxOnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-commons/src/main/java/org/kie/pmml/commons/exceptions/KiePMMLException.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMjowMDozN1rOHINAZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMjozMzo1MlrOHIONrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM2Mzc1MA==", "bodyText": "Do we want to use Java serialization for Exceptions? I think serialization is considered more or less deprecated these days. What is the reason behind this?", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r478363750", "createdAt": "2020-08-27T12:00:37Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-trusty/kie-pmml-commons/src/main/java/org/kie/pmml/commons/exceptions/KiePMMLException.java", "diffHunk": "@@ -20,10 +20,16 @@\n  */\n public class KiePMMLException extends RuntimeException {\n \n+    private static final long serialVersionUID = -6638828457762000141L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52801990de7002c74109aea1c61dd73463246240"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM4MzUzMg==", "bodyText": "@jiripetrlik\nThrowable (the root of all exception) is Serialiazable - I just add the serialVersionUID as per SONAR complaint", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r478383532", "createdAt": "2020-08-27T12:33:52Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-trusty/kie-pmml-commons/src/main/java/org/kie/pmml/commons/exceptions/KiePMMLException.java", "diffHunk": "@@ -20,10 +20,16 @@\n  */\n public class KiePMMLException extends RuntimeException {\n \n+    private static final long serialVersionUID = -6638828457762000141L;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM2Mzc1MA=="}, "originalCommit": {"oid": "52801990de7002c74109aea1c61dd73463246240"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MDQyOTU1OnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-commons/src/main/java/org/kie/pmml/commons/model/predicates/KiePMMLCompoundPredicate.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMjowMzoyMFrOHINHEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMjo0NToyMlrOHIOohw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM2NTQ1Nw==", "bodyText": "Is there something like default binary operator? Shouldn't we rather throw an exception.", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r478365457", "createdAt": "2020-08-27T12:03:20Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-trusty/kie-pmml-commons/src/main/java/org/kie/pmml/commons/model/predicates/KiePMMLCompoundPredicate.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.commons.model.predicates;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.BinaryOperator;\n+\n+import org.kie.pmml.commons.model.KiePMMLExtension;\n+import org.kie.pmml.commons.model.enums.BOOLEAN_OPERATOR;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * @see <a href=http://dmg.org/pmml/v4-4/TreeModel.html#xsdElement_SimplePredicate>SimplePredicate</a>\n+ */\n+public class KiePMMLCompoundPredicate extends KiePMMLPredicate {\n+\n+    private static final long serialVersionUID = -1996390505352151403L;\n+    private static final Logger logger = LoggerFactory.getLogger(KiePMMLCompoundPredicate.class);\n+\n+    private final BOOLEAN_OPERATOR booleanOperator;\n+    private BinaryOperator<Boolean> operatorFunction;\n+    protected List<KiePMMLPredicate> kiePMMLPredicates;\n+\n+    protected KiePMMLCompoundPredicate(final String name, final List<KiePMMLExtension> extensions, final BOOLEAN_OPERATOR booleanOperator) {\n+        super(name, extensions);\n+        this.booleanOperator = booleanOperator;\n+    }\n+\n+    /**\n+     * Builder to auto-generate the <b>id</b>\n+     * @return\n+     */\n+    public static Builder builder(List<KiePMMLExtension> extensions, BOOLEAN_OPERATOR booleanOperator) {\n+        return new Builder(extensions, booleanOperator);\n+    }\n+\n+    @Override\n+    public boolean evaluate(Map<String, Object> values) {\n+        Boolean toReturn = null;\n+        for (KiePMMLPredicate kiePMMLPredicate : kiePMMLPredicates) {\n+            toReturn = operatorFunction.apply(toReturn, kiePMMLPredicate.evaluate(values));\n+        }\n+        return toReturn != null && toReturn;\n+    }\n+\n+    @Override\n+    public String getId() {\n+        return id;\n+    }\n+\n+    public BOOLEAN_OPERATOR getBooleanOperator() {\n+        return booleanOperator;\n+    }\n+\n+    public List<KiePMMLPredicate> getKiePMMLPredicates() {\n+        return kiePMMLPredicates;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"KiePMMLCompoundPredicate{\" +\n+                \"booleanOperator=\" + booleanOperator +\n+                \", operatorFunction=\" + operatorFunction +\n+                \", kiePMMLPredicates=\" + kiePMMLPredicates +\n+                \", extensions=\" + extensions +\n+                \", id='\" + id + '\\'' +\n+                \", parentId='\" + parentId + '\\'' +\n+                '}';\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        if (!super.equals(o)) {\n+            return false;\n+        }\n+        KiePMMLCompoundPredicate that = (KiePMMLCompoundPredicate) o;\n+        return booleanOperator == that.booleanOperator &&\n+                Objects.equals(operatorFunction, that.operatorFunction) &&\n+                Objects.equals(kiePMMLPredicates, that.kiePMMLPredicates);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(super.hashCode(), booleanOperator, operatorFunction, kiePMMLPredicates);\n+    }\n+\n+    public static class Builder extends KiePMMLPredicate.Builder<KiePMMLCompoundPredicate> {\n+\n+        private Builder(List<KiePMMLExtension> extensions, BOOLEAN_OPERATOR booleanOperator) {\n+            super(\"CompoundPredicate-\", () -> new KiePMMLCompoundPredicate(\"CompoundPredicate\", extensions, booleanOperator));\n+            toBuild.operatorFunction = getInnerBinaryOperator(booleanOperator);\n+        }\n+\n+        public KiePMMLCompoundPredicate.Builder withKiePMMLPredicates(List<KiePMMLPredicate> kiePMMLPredicates) {\n+            kiePMMLPredicates.forEach(predicate -> predicate.setParentId(toBuild.id));\n+            toBuild.kiePMMLPredicates = kiePMMLPredicates;\n+            return this;\n+        }\n+\n+        private BinaryOperator<Boolean> getInnerBinaryOperator(BOOLEAN_OPERATOR booleanOperator) {\n+            switch (booleanOperator) {\n+                // logic here is\n+                // first boolean may be null (initial evaluation) so we start taking the second boolean\n+                case OR:\n+                    return (aBoolean, aBoolean2) -> aBoolean != null ? aBoolean || aBoolean2 : aBoolean2;\n+                case AND:\n+                    return (aBoolean, aBoolean2) -> aBoolean != null ? aBoolean && aBoolean2 : aBoolean2;\n+                case XOR:\n+                    return (aBoolean, aBoolean2) -> aBoolean != null ? aBoolean ^ aBoolean2 : aBoolean2;\n+                case SURROGATE:\n+                    // TODO {gcardosi} DROOLS-5594\n+                default:\n+                    return (aBoolean, aBoolean2) -> aBoolean;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52801990de7002c74109aea1c61dd73463246240"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM5MDQwNw==", "bodyText": "@jiripetrlik\nRemoved - throwing exceptions", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r478390407", "createdAt": "2020-08-27T12:45:22Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-trusty/kie-pmml-commons/src/main/java/org/kie/pmml/commons/model/predicates/KiePMMLCompoundPredicate.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.commons.model.predicates;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.BinaryOperator;\n+\n+import org.kie.pmml.commons.model.KiePMMLExtension;\n+import org.kie.pmml.commons.model.enums.BOOLEAN_OPERATOR;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * @see <a href=http://dmg.org/pmml/v4-4/TreeModel.html#xsdElement_SimplePredicate>SimplePredicate</a>\n+ */\n+public class KiePMMLCompoundPredicate extends KiePMMLPredicate {\n+\n+    private static final long serialVersionUID = -1996390505352151403L;\n+    private static final Logger logger = LoggerFactory.getLogger(KiePMMLCompoundPredicate.class);\n+\n+    private final BOOLEAN_OPERATOR booleanOperator;\n+    private BinaryOperator<Boolean> operatorFunction;\n+    protected List<KiePMMLPredicate> kiePMMLPredicates;\n+\n+    protected KiePMMLCompoundPredicate(final String name, final List<KiePMMLExtension> extensions, final BOOLEAN_OPERATOR booleanOperator) {\n+        super(name, extensions);\n+        this.booleanOperator = booleanOperator;\n+    }\n+\n+    /**\n+     * Builder to auto-generate the <b>id</b>\n+     * @return\n+     */\n+    public static Builder builder(List<KiePMMLExtension> extensions, BOOLEAN_OPERATOR booleanOperator) {\n+        return new Builder(extensions, booleanOperator);\n+    }\n+\n+    @Override\n+    public boolean evaluate(Map<String, Object> values) {\n+        Boolean toReturn = null;\n+        for (KiePMMLPredicate kiePMMLPredicate : kiePMMLPredicates) {\n+            toReturn = operatorFunction.apply(toReturn, kiePMMLPredicate.evaluate(values));\n+        }\n+        return toReturn != null && toReturn;\n+    }\n+\n+    @Override\n+    public String getId() {\n+        return id;\n+    }\n+\n+    public BOOLEAN_OPERATOR getBooleanOperator() {\n+        return booleanOperator;\n+    }\n+\n+    public List<KiePMMLPredicate> getKiePMMLPredicates() {\n+        return kiePMMLPredicates;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"KiePMMLCompoundPredicate{\" +\n+                \"booleanOperator=\" + booleanOperator +\n+                \", operatorFunction=\" + operatorFunction +\n+                \", kiePMMLPredicates=\" + kiePMMLPredicates +\n+                \", extensions=\" + extensions +\n+                \", id='\" + id + '\\'' +\n+                \", parentId='\" + parentId + '\\'' +\n+                '}';\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        if (!super.equals(o)) {\n+            return false;\n+        }\n+        KiePMMLCompoundPredicate that = (KiePMMLCompoundPredicate) o;\n+        return booleanOperator == that.booleanOperator &&\n+                Objects.equals(operatorFunction, that.operatorFunction) &&\n+                Objects.equals(kiePMMLPredicates, that.kiePMMLPredicates);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(super.hashCode(), booleanOperator, operatorFunction, kiePMMLPredicates);\n+    }\n+\n+    public static class Builder extends KiePMMLPredicate.Builder<KiePMMLCompoundPredicate> {\n+\n+        private Builder(List<KiePMMLExtension> extensions, BOOLEAN_OPERATOR booleanOperator) {\n+            super(\"CompoundPredicate-\", () -> new KiePMMLCompoundPredicate(\"CompoundPredicate\", extensions, booleanOperator));\n+            toBuild.operatorFunction = getInnerBinaryOperator(booleanOperator);\n+        }\n+\n+        public KiePMMLCompoundPredicate.Builder withKiePMMLPredicates(List<KiePMMLPredicate> kiePMMLPredicates) {\n+            kiePMMLPredicates.forEach(predicate -> predicate.setParentId(toBuild.id));\n+            toBuild.kiePMMLPredicates = kiePMMLPredicates;\n+            return this;\n+        }\n+\n+        private BinaryOperator<Boolean> getInnerBinaryOperator(BOOLEAN_OPERATOR booleanOperator) {\n+            switch (booleanOperator) {\n+                // logic here is\n+                // first boolean may be null (initial evaluation) so we start taking the second boolean\n+                case OR:\n+                    return (aBoolean, aBoolean2) -> aBoolean != null ? aBoolean || aBoolean2 : aBoolean2;\n+                case AND:\n+                    return (aBoolean, aBoolean2) -> aBoolean != null ? aBoolean && aBoolean2 : aBoolean2;\n+                case XOR:\n+                    return (aBoolean, aBoolean2) -> aBoolean != null ? aBoolean ^ aBoolean2 : aBoolean2;\n+                case SURROGATE:\n+                    // TODO {gcardosi} DROOLS-5594\n+                default:\n+                    return (aBoolean, aBoolean2) -> aBoolean;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM2NTQ1Nw=="}, "originalCommit": {"oid": "52801990de7002c74109aea1c61dd73463246240"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MDQzNjUyOnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-commons/src/main/java/org/kie/pmml/commons/model/predicates/KiePMMLSimplePredicate.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMjowNToxNFrOHINLKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMjo0NjowNVrOHIOqgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM2NjUwNg==", "bodyText": "Do we serialize this?", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r478366506", "createdAt": "2020-08-27T12:05:14Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-trusty/kie-pmml-commons/src/main/java/org/kie/pmml/commons/model/predicates/KiePMMLSimplePredicate.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.commons.model.predicates;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import org.kie.pmml.commons.model.KiePMMLExtension;\n+import org.kie.pmml.commons.model.enums.OPERATOR;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * @see <a href=http://dmg.org/pmml/v4-4/TreeModel.html#xsdElement_SimplePredicate>SimplePredicate</a>\n+ */\n+public class KiePMMLSimplePredicate extends KiePMMLPredicate {\n+\n+    private static final long serialVersionUID = -1996390505352151403L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52801990de7002c74109aea1c61dd73463246240"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM5MDkxNQ==", "bodyText": "@jiripetrlik\nremoved", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r478390915", "createdAt": "2020-08-27T12:46:05Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-trusty/kie-pmml-commons/src/main/java/org/kie/pmml/commons/model/predicates/KiePMMLSimplePredicate.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.commons.model.predicates;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import org.kie.pmml.commons.model.KiePMMLExtension;\n+import org.kie.pmml.commons.model.enums.OPERATOR;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * @see <a href=http://dmg.org/pmml/v4-4/TreeModel.html#xsdElement_SimplePredicate>SimplePredicate</a>\n+ */\n+public class KiePMMLSimplePredicate extends KiePMMLPredicate {\n+\n+    private static final long serialVersionUID = -1996390505352151403L;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM2NjUwNg=="}, "originalCommit": {"oid": "52801990de7002c74109aea1c61dd73463246240"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MDQzOTI5OnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-commons/src/main/java/org/kie/pmml/commons/model/predicates/KiePMMLSimplePredicate.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMjowNTo1NFrOHINMuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMjo1NTozOFrOHIPCNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM2NjkwNw==", "bodyText": "Why default true?", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r478366907", "createdAt": "2020-08-27T12:05:54Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-trusty/kie-pmml-commons/src/main/java/org/kie/pmml/commons/model/predicates/KiePMMLSimplePredicate.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.commons.model.predicates;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import org.kie.pmml.commons.model.KiePMMLExtension;\n+import org.kie.pmml.commons.model.enums.OPERATOR;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * @see <a href=http://dmg.org/pmml/v4-4/TreeModel.html#xsdElement_SimplePredicate>SimplePredicate</a>\n+ */\n+public class KiePMMLSimplePredicate extends KiePMMLPredicate {\n+\n+    private static final long serialVersionUID = -1996390505352151403L;\n+    private static final Logger logger = LoggerFactory.getLogger(KiePMMLSimplePredicate.class);\n+\n+    private final OPERATOR operator;\n+    protected Object value;\n+\n+    protected KiePMMLSimplePredicate(final String name, final List<KiePMMLExtension> extensions, final OPERATOR operator) {\n+        super(name, extensions);\n+        this.operator = operator;\n+    }\n+\n+    /**\n+     * Builder to auto-generate the <b>id</b>\n+     * @return\n+     */\n+    public static Builder builder(String name, List<KiePMMLExtension> extensions, OPERATOR operator) {\n+        return new Builder(name, extensions, operator);\n+    }\n+\n+    @Override\n+    public boolean evaluate(Map<String, Object> values) {\n+        boolean toReturn = false;\n+        if (values.containsKey(name)) {\n+            logger.debug(\"found matching parameter, evaluating... \");\n+            toReturn = evaluation(values.get(name));\n+        }\n+        return toReturn;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public OPERATOR getOperator() {\n+        return operator;\n+    }\n+\n+    public Object getValue() {\n+        return value;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"KiePMMLSimplePredicate{\" +\n+                \"operator=\" + operator +\n+                \", name='\" + name + '\\'' +\n+                \", value=\" + value +\n+                \", extensions=\" + extensions +\n+                \", id='\" + id + '\\'' +\n+                \", parentId='\" + parentId + '\\'' +\n+                '}';\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        if (!super.equals(o)) {\n+            return false;\n+        }\n+        KiePMMLSimplePredicate that = (KiePMMLSimplePredicate) o;\n+        return operator == that.operator &&\n+                Objects.equals(name, that.name) &&\n+                Objects.equals(value, that.value);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(super.hashCode(), operator, name, value);\n+    }\n+\n+    protected boolean evaluation(Object inputValue) {\n+        switch (operator) {\n+            case EQUAL:\n+                return value.equals(inputValue);\n+            case NOT_EQUAL:\n+                return !value.equals(inputValue);\n+            case LESS_THAN:\n+                if (inputValue instanceof Number && value instanceof Number) {\n+                    return ((Number) inputValue).doubleValue() < ((Number) value).doubleValue();\n+                } else {\n+                    return false;\n+                }\n+            case LESS_OR_EQUAL:\n+                if (inputValue instanceof Number && value instanceof Number) {\n+                    return ((Number) inputValue).doubleValue() <= ((Number) value).doubleValue();\n+                } else {\n+                    return false;\n+                }\n+            case GREATER_THAN:\n+                if (inputValue instanceof Number && value instanceof Number) {\n+                    return ((Number) inputValue).doubleValue() > ((Number) value).doubleValue();\n+                } else {\n+                    return false;\n+                }\n+            case GREATER_OR_EQUAL:\n+                if (inputValue instanceof Number && value instanceof Number) {\n+                    return ((Number) inputValue).doubleValue() >= ((Number) value).doubleValue();\n+                } else {\n+                    return false;\n+                }\n+            case IS_MISSING:\n+            case IS_NOT_MISSING:\n+            default:\n+                return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52801990de7002c74109aea1c61dd73463246240"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM5Njk4MA==", "bodyText": "@jiripetrlik\nRemoved - throwing exceptions\nsee https://issues.redhat.com/browse/DROOLS-5604", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r478396980", "createdAt": "2020-08-27T12:55:38Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-trusty/kie-pmml-commons/src/main/java/org/kie/pmml/commons/model/predicates/KiePMMLSimplePredicate.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.commons.model.predicates;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import org.kie.pmml.commons.model.KiePMMLExtension;\n+import org.kie.pmml.commons.model.enums.OPERATOR;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * @see <a href=http://dmg.org/pmml/v4-4/TreeModel.html#xsdElement_SimplePredicate>SimplePredicate</a>\n+ */\n+public class KiePMMLSimplePredicate extends KiePMMLPredicate {\n+\n+    private static final long serialVersionUID = -1996390505352151403L;\n+    private static final Logger logger = LoggerFactory.getLogger(KiePMMLSimplePredicate.class);\n+\n+    private final OPERATOR operator;\n+    protected Object value;\n+\n+    protected KiePMMLSimplePredicate(final String name, final List<KiePMMLExtension> extensions, final OPERATOR operator) {\n+        super(name, extensions);\n+        this.operator = operator;\n+    }\n+\n+    /**\n+     * Builder to auto-generate the <b>id</b>\n+     * @return\n+     */\n+    public static Builder builder(String name, List<KiePMMLExtension> extensions, OPERATOR operator) {\n+        return new Builder(name, extensions, operator);\n+    }\n+\n+    @Override\n+    public boolean evaluate(Map<String, Object> values) {\n+        boolean toReturn = false;\n+        if (values.containsKey(name)) {\n+            logger.debug(\"found matching parameter, evaluating... \");\n+            toReturn = evaluation(values.get(name));\n+        }\n+        return toReturn;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public OPERATOR getOperator() {\n+        return operator;\n+    }\n+\n+    public Object getValue() {\n+        return value;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"KiePMMLSimplePredicate{\" +\n+                \"operator=\" + operator +\n+                \", name='\" + name + '\\'' +\n+                \", value=\" + value +\n+                \", extensions=\" + extensions +\n+                \", id='\" + id + '\\'' +\n+                \", parentId='\" + parentId + '\\'' +\n+                '}';\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        if (!super.equals(o)) {\n+            return false;\n+        }\n+        KiePMMLSimplePredicate that = (KiePMMLSimplePredicate) o;\n+        return operator == that.operator &&\n+                Objects.equals(name, that.name) &&\n+                Objects.equals(value, that.value);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(super.hashCode(), operator, name, value);\n+    }\n+\n+    protected boolean evaluation(Object inputValue) {\n+        switch (operator) {\n+            case EQUAL:\n+                return value.equals(inputValue);\n+            case NOT_EQUAL:\n+                return !value.equals(inputValue);\n+            case LESS_THAN:\n+                if (inputValue instanceof Number && value instanceof Number) {\n+                    return ((Number) inputValue).doubleValue() < ((Number) value).doubleValue();\n+                } else {\n+                    return false;\n+                }\n+            case LESS_OR_EQUAL:\n+                if (inputValue instanceof Number && value instanceof Number) {\n+                    return ((Number) inputValue).doubleValue() <= ((Number) value).doubleValue();\n+                } else {\n+                    return false;\n+                }\n+            case GREATER_THAN:\n+                if (inputValue instanceof Number && value instanceof Number) {\n+                    return ((Number) inputValue).doubleValue() > ((Number) value).doubleValue();\n+                } else {\n+                    return false;\n+                }\n+            case GREATER_OR_EQUAL:\n+                if (inputValue instanceof Number && value instanceof Number) {\n+                    return ((Number) inputValue).doubleValue() >= ((Number) value).doubleValue();\n+                } else {\n+                    return false;\n+                }\n+            case IS_MISSING:\n+            case IS_NOT_MISSING:\n+            default:\n+                return true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM2NjkwNw=="}, "originalCommit": {"oid": "52801990de7002c74109aea1c61dd73463246240"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MDQ0MTA1OnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-commons/src/main/java/org/kie/pmml/commons/model/predicates/KiePMMLTruePredicate.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMjowNjoyNFrOHINNxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMjo1Njo1OFrOHIPFZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM2NzE3Mw==", "bodyText": "Remove new lines.", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r478367173", "createdAt": "2020-08-27T12:06:24Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-trusty/kie-pmml-commons/src/main/java/org/kie/pmml/commons/model/predicates/KiePMMLTruePredicate.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.commons.model.predicates;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import org.kie.pmml.commons.model.KiePMMLExtension;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * @see <a href=http://dmg.org/pmml/v4-4/TreeModel.html#xsdElement_True>True</a>\n+ */\n+public class KiePMMLTruePredicate extends KiePMMLPredicate {\n+\n+    private static final long serialVersionUID = -1996390505352151403L;\n+    private static final Logger logger = LoggerFactory.getLogger(KiePMMLTruePredicate.class);\n+\n+    private static final String TRUE = \"True\";\n+\n+    protected KiePMMLTruePredicate(String name, List<KiePMMLExtension> extensions) {\n+        super(name, extensions);\n+    }\n+\n+    /**\n+     * Builder to auto-generate the <b>id</b>\n+     * @return\n+     */\n+    public static Builder builder(List<KiePMMLExtension> extensions) {\n+        return new Builder(extensions);\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52801990de7002c74109aea1c61dd73463246240"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM5Nzc5OQ==", "bodyText": "@jiripetrlik\ndone", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r478397799", "createdAt": "2020-08-27T12:56:58Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-trusty/kie-pmml-commons/src/main/java/org/kie/pmml/commons/model/predicates/KiePMMLTruePredicate.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.commons.model.predicates;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import org.kie.pmml.commons.model.KiePMMLExtension;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * @see <a href=http://dmg.org/pmml/v4-4/TreeModel.html#xsdElement_True>True</a>\n+ */\n+public class KiePMMLTruePredicate extends KiePMMLPredicate {\n+\n+    private static final long serialVersionUID = -1996390505352151403L;\n+    private static final Logger logger = LoggerFactory.getLogger(KiePMMLTruePredicate.class);\n+\n+    private static final String TRUE = \"True\";\n+\n+    protected KiePMMLTruePredicate(String name, List<KiePMMLExtension> extensions) {\n+        super(name, extensions);\n+    }\n+\n+    /**\n+     * Builder to auto-generate the <b>id</b>\n+     * @return\n+     */\n+    public static Builder builder(List<KiePMMLExtension> extensions) {\n+        return new Builder(extensions);\n+    }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM2NzE3Mw=="}, "originalCommit": {"oid": "52801990de7002c74109aea1c61dd73463246240"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MDQ0Mzk3OnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-commons/src/main/resources/KiePMMLCompoundPredicateTemplate.tmpl", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMjowNzowNVrOHINPZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMjo1NzowNFrOHIPFlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM2NzU5MQ==", "bodyText": "Remove new line.", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r478367591", "createdAt": "2020-08-27T12:07:05Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-trusty/kie-pmml-commons/src/main/resources/KiePMMLCompoundPredicateTemplate.tmpl", "diffHunk": "@@ -0,0 +1,29 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.commons.model.predicates;\n+\n+import java.util.Collections;\n+\n+import org.kie.pmml.commons.model.predicates.KiePMMLCompoundPredicate;\n+\n+public class KiePMMLCompoundPredicateTemplate extends KiePMMLCompoundPredicate {\n+\n+    public KiePMMLCompoundPredicateTemplate() {\n+        super(name, Collections.emptyList(), booleanOperator);\n+        kiePMMLPredicates = null;\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52801990de7002c74109aea1c61dd73463246240"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM5Nzg0NQ==", "bodyText": "@jiripetrlik\ndone", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r478397845", "createdAt": "2020-08-27T12:57:04Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-trusty/kie-pmml-commons/src/main/resources/KiePMMLCompoundPredicateTemplate.tmpl", "diffHunk": "@@ -0,0 +1,29 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.commons.model.predicates;\n+\n+import java.util.Collections;\n+\n+import org.kie.pmml.commons.model.predicates.KiePMMLCompoundPredicate;\n+\n+public class KiePMMLCompoundPredicateTemplate extends KiePMMLCompoundPredicate {\n+\n+    public KiePMMLCompoundPredicateTemplate() {\n+        super(name, Collections.emptyList(), booleanOperator);\n+        kiePMMLPredicates = null;\n+    }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM2NzU5MQ=="}, "originalCommit": {"oid": "52801990de7002c74109aea1c61dd73463246240"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MDQ0NjAzOnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-commons/src/test/java/org/kie/pmml/commons/model/predicates/KiePMMLCompoundPredicateTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMjowNzozNlrOHINQlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMjo1Nzo0NlrOHIPHXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM2Nzg5NQ==", "bodyText": "Remove new lines.", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r478367895", "createdAt": "2020-08-27T12:07:36Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-trusty/kie-pmml-commons/src/test/java/org/kie/pmml/commons/model/predicates/KiePMMLCompoundPredicateTest.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.pmml.commons.model.predicates;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import org.junit.Test;\n+import org.kie.pmml.commons.model.enums.ARRAY_TYPE;\n+import org.kie.pmml.commons.model.enums.BOOLEAN_OPERATOR;\n+import org.kie.pmml.commons.model.enums.IN_NOTIN;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+public class KiePMMLCompoundPredicateTest {\n+\n+    private final String COMPOUND_PREDICATE_NAME = \"COMPOUNDPREDICATENAME\";\n+    private final String SIMPLE_SET_PREDICATE_STRING_NAME = \"SIMPLESETPREDICATESTRINGNAME\";\n+    private final String SIMPLE_SET_PREDICATE_INT_NAME = \"SIMPLESETPREDICATEINTNAME\";\n+\n+    @Test\n+    public void evaluateCompoundPredicateSinglePredicate() {\n+        ARRAY_TYPE arrayType = ARRAY_TYPE.STRING;\n+        List<Object> stringValues = getObjects(arrayType, 4);\n+        KiePMMLSimpleSetPredicate kiePMMLSimpleSetPredicateString = getKiePMMLSimpleSetPredicate(SIMPLE_SET_PREDICATE_STRING_NAME,\n+                                                                                                 stringValues,\n+                                                                                                 arrayType,\n+                                                                                                 IN_NOTIN.IN);\n+        KiePMMLCompoundPredicate kiePMMLCompoundPredicate = getKiePMMLCompoundPredicate(BOOLEAN_OPERATOR.AND, Collections.singletonList(kiePMMLSimpleSetPredicateString));\n+        Map<String, Object> inputData = new HashMap<>();\n+        inputData.put(SIMPLE_SET_PREDICATE_STRING_NAME, \"NOT\");\n+        assertFalse(kiePMMLCompoundPredicate.evaluate(inputData));\n+        inputData.put(SIMPLE_SET_PREDICATE_STRING_NAME, stringValues.get(0));\n+        assertTrue(kiePMMLCompoundPredicate.evaluate(inputData));\n+\n+        arrayType = ARRAY_TYPE.INT;\n+        List<Object> intValues = getObjects(arrayType, 4);\n+        KiePMMLSimpleSetPredicate kiePMMLSimpleSetPredicateInt = getKiePMMLSimpleSetPredicate(SIMPLE_SET_PREDICATE_INT_NAME,\n+                                                                                              intValues,\n+                                                                                              arrayType,\n+                                                                                              IN_NOTIN.NOT_IN);\n+        kiePMMLCompoundPredicate = getKiePMMLCompoundPredicate(BOOLEAN_OPERATOR.AND, Collections.singletonList(kiePMMLSimpleSetPredicateInt));\n+        inputData = new HashMap<>();\n+        inputData.put(SIMPLE_SET_PREDICATE_INT_NAME, intValues.get(0));\n+        assertFalse(kiePMMLCompoundPredicate.evaluate(inputData));\n+        inputData.put(SIMPLE_SET_PREDICATE_INT_NAME, \"234\");\n+        assertTrue(kiePMMLCompoundPredicate.evaluate(inputData));\n+    }\n+\n+    @Test\n+    public void evaluateCompoundPredicateAnd() {\n+        ARRAY_TYPE arrayType = ARRAY_TYPE.STRING;\n+        List<Object> stringValues = getObjects(arrayType, 4);\n+        KiePMMLSimpleSetPredicate kiePMMLSimpleSetPredicateString = getKiePMMLSimpleSetPredicate(SIMPLE_SET_PREDICATE_STRING_NAME,\n+                                                                                                 stringValues,\n+                                                                                                 arrayType,\n+                                                                                                 IN_NOTIN.IN);\n+        arrayType = ARRAY_TYPE.INT;\n+        List<Object> intValues = getObjects(arrayType, 4);\n+        KiePMMLSimpleSetPredicate kiePMMLSimpleSetPredicateInt = getKiePMMLSimpleSetPredicate(SIMPLE_SET_PREDICATE_INT_NAME,\n+                                                                                              intValues,\n+                                                                                              arrayType,\n+                                                                                              IN_NOTIN.NOT_IN);\n+        KiePMMLCompoundPredicate kiePMMLCompoundPredicate = getKiePMMLCompoundPredicate(BOOLEAN_OPERATOR.AND,\n+                                                                                        Arrays.asList(kiePMMLSimpleSetPredicateString, kiePMMLSimpleSetPredicateInt));\n+        Map<String, Object> inputData = new HashMap<>();\n+        inputData.put(SIMPLE_SET_PREDICATE_STRING_NAME, stringValues.get(0));\n+        inputData.put(SIMPLE_SET_PREDICATE_INT_NAME, intValues.get(0));\n+        assertFalse(kiePMMLCompoundPredicate.evaluate(inputData));\n+\n+        inputData = new HashMap<>();\n+        inputData.put(SIMPLE_SET_PREDICATE_STRING_NAME, \"NOT\");\n+        inputData.put(SIMPLE_SET_PREDICATE_INT_NAME, \"234\");\n+        assertFalse(kiePMMLCompoundPredicate.evaluate(inputData));\n+\n+        inputData = new HashMap<>();\n+        inputData.put(SIMPLE_SET_PREDICATE_STRING_NAME, stringValues.get(0));\n+        inputData.put(SIMPLE_SET_PREDICATE_INT_NAME, \"234\");\n+        assertTrue(kiePMMLCompoundPredicate.evaluate(inputData));\n+    }\n+\n+    @Test\n+    public void evaluateCompoundPredicateOr() {\n+        ARRAY_TYPE arrayType = ARRAY_TYPE.STRING;\n+        List<Object> stringValues = getObjects(arrayType, 4);\n+        KiePMMLSimpleSetPredicate kiePMMLSimpleSetPredicateString = getKiePMMLSimpleSetPredicate(SIMPLE_SET_PREDICATE_STRING_NAME,\n+                                                                                                 stringValues,\n+                                                                                                 arrayType,\n+                                                                                                 IN_NOTIN.IN);\n+        arrayType = ARRAY_TYPE.INT;\n+        List<Object> intValues = getObjects(arrayType, 4);\n+        KiePMMLSimpleSetPredicate kiePMMLSimpleSetPredicateInt = getKiePMMLSimpleSetPredicate(SIMPLE_SET_PREDICATE_INT_NAME,\n+                                                                                              intValues,\n+                                                                                              arrayType,\n+                                                                                              IN_NOTIN.NOT_IN);\n+        KiePMMLCompoundPredicate kiePMMLCompoundPredicate = getKiePMMLCompoundPredicate(BOOLEAN_OPERATOR.OR,\n+                                                                                        Arrays.asList(kiePMMLSimpleSetPredicateString, kiePMMLSimpleSetPredicateInt));\n+        Map<String, Object> inputData = new HashMap<>();\n+        inputData.put(SIMPLE_SET_PREDICATE_STRING_NAME, \"NOT\");\n+        inputData.put(SIMPLE_SET_PREDICATE_INT_NAME, intValues.get(0));\n+        assertFalse(kiePMMLCompoundPredicate.evaluate(inputData));\n+\n+        inputData.put(SIMPLE_SET_PREDICATE_STRING_NAME, stringValues.get(0));\n+        inputData.put(SIMPLE_SET_PREDICATE_INT_NAME, intValues.get(0));\n+        assertTrue(kiePMMLCompoundPredicate.evaluate(inputData));\n+\n+        inputData = new HashMap<>();\n+        inputData.put(SIMPLE_SET_PREDICATE_STRING_NAME, \"NOT\");\n+        inputData.put(SIMPLE_SET_PREDICATE_INT_NAME, \"234\");\n+        assertTrue(kiePMMLCompoundPredicate.evaluate(inputData));\n+\n+        inputData = new HashMap<>();\n+        inputData.put(SIMPLE_SET_PREDICATE_STRING_NAME, stringValues.get(0));\n+        inputData.put(SIMPLE_SET_PREDICATE_INT_NAME, \"234\");\n+        assertTrue(kiePMMLCompoundPredicate.evaluate(inputData));\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52801990de7002c74109aea1c61dd73463246240"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM5ODMwMQ==", "bodyText": "@jiripetrlik\ndone", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r478398301", "createdAt": "2020-08-27T12:57:46Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-trusty/kie-pmml-commons/src/test/java/org/kie/pmml/commons/model/predicates/KiePMMLCompoundPredicateTest.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.pmml.commons.model.predicates;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import org.junit.Test;\n+import org.kie.pmml.commons.model.enums.ARRAY_TYPE;\n+import org.kie.pmml.commons.model.enums.BOOLEAN_OPERATOR;\n+import org.kie.pmml.commons.model.enums.IN_NOTIN;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+public class KiePMMLCompoundPredicateTest {\n+\n+    private final String COMPOUND_PREDICATE_NAME = \"COMPOUNDPREDICATENAME\";\n+    private final String SIMPLE_SET_PREDICATE_STRING_NAME = \"SIMPLESETPREDICATESTRINGNAME\";\n+    private final String SIMPLE_SET_PREDICATE_INT_NAME = \"SIMPLESETPREDICATEINTNAME\";\n+\n+    @Test\n+    public void evaluateCompoundPredicateSinglePredicate() {\n+        ARRAY_TYPE arrayType = ARRAY_TYPE.STRING;\n+        List<Object> stringValues = getObjects(arrayType, 4);\n+        KiePMMLSimpleSetPredicate kiePMMLSimpleSetPredicateString = getKiePMMLSimpleSetPredicate(SIMPLE_SET_PREDICATE_STRING_NAME,\n+                                                                                                 stringValues,\n+                                                                                                 arrayType,\n+                                                                                                 IN_NOTIN.IN);\n+        KiePMMLCompoundPredicate kiePMMLCompoundPredicate = getKiePMMLCompoundPredicate(BOOLEAN_OPERATOR.AND, Collections.singletonList(kiePMMLSimpleSetPredicateString));\n+        Map<String, Object> inputData = new HashMap<>();\n+        inputData.put(SIMPLE_SET_PREDICATE_STRING_NAME, \"NOT\");\n+        assertFalse(kiePMMLCompoundPredicate.evaluate(inputData));\n+        inputData.put(SIMPLE_SET_PREDICATE_STRING_NAME, stringValues.get(0));\n+        assertTrue(kiePMMLCompoundPredicate.evaluate(inputData));\n+\n+        arrayType = ARRAY_TYPE.INT;\n+        List<Object> intValues = getObjects(arrayType, 4);\n+        KiePMMLSimpleSetPredicate kiePMMLSimpleSetPredicateInt = getKiePMMLSimpleSetPredicate(SIMPLE_SET_PREDICATE_INT_NAME,\n+                                                                                              intValues,\n+                                                                                              arrayType,\n+                                                                                              IN_NOTIN.NOT_IN);\n+        kiePMMLCompoundPredicate = getKiePMMLCompoundPredicate(BOOLEAN_OPERATOR.AND, Collections.singletonList(kiePMMLSimpleSetPredicateInt));\n+        inputData = new HashMap<>();\n+        inputData.put(SIMPLE_SET_PREDICATE_INT_NAME, intValues.get(0));\n+        assertFalse(kiePMMLCompoundPredicate.evaluate(inputData));\n+        inputData.put(SIMPLE_SET_PREDICATE_INT_NAME, \"234\");\n+        assertTrue(kiePMMLCompoundPredicate.evaluate(inputData));\n+    }\n+\n+    @Test\n+    public void evaluateCompoundPredicateAnd() {\n+        ARRAY_TYPE arrayType = ARRAY_TYPE.STRING;\n+        List<Object> stringValues = getObjects(arrayType, 4);\n+        KiePMMLSimpleSetPredicate kiePMMLSimpleSetPredicateString = getKiePMMLSimpleSetPredicate(SIMPLE_SET_PREDICATE_STRING_NAME,\n+                                                                                                 stringValues,\n+                                                                                                 arrayType,\n+                                                                                                 IN_NOTIN.IN);\n+        arrayType = ARRAY_TYPE.INT;\n+        List<Object> intValues = getObjects(arrayType, 4);\n+        KiePMMLSimpleSetPredicate kiePMMLSimpleSetPredicateInt = getKiePMMLSimpleSetPredicate(SIMPLE_SET_PREDICATE_INT_NAME,\n+                                                                                              intValues,\n+                                                                                              arrayType,\n+                                                                                              IN_NOTIN.NOT_IN);\n+        KiePMMLCompoundPredicate kiePMMLCompoundPredicate = getKiePMMLCompoundPredicate(BOOLEAN_OPERATOR.AND,\n+                                                                                        Arrays.asList(kiePMMLSimpleSetPredicateString, kiePMMLSimpleSetPredicateInt));\n+        Map<String, Object> inputData = new HashMap<>();\n+        inputData.put(SIMPLE_SET_PREDICATE_STRING_NAME, stringValues.get(0));\n+        inputData.put(SIMPLE_SET_PREDICATE_INT_NAME, intValues.get(0));\n+        assertFalse(kiePMMLCompoundPredicate.evaluate(inputData));\n+\n+        inputData = new HashMap<>();\n+        inputData.put(SIMPLE_SET_PREDICATE_STRING_NAME, \"NOT\");\n+        inputData.put(SIMPLE_SET_PREDICATE_INT_NAME, \"234\");\n+        assertFalse(kiePMMLCompoundPredicate.evaluate(inputData));\n+\n+        inputData = new HashMap<>();\n+        inputData.put(SIMPLE_SET_PREDICATE_STRING_NAME, stringValues.get(0));\n+        inputData.put(SIMPLE_SET_PREDICATE_INT_NAME, \"234\");\n+        assertTrue(kiePMMLCompoundPredicate.evaluate(inputData));\n+    }\n+\n+    @Test\n+    public void evaluateCompoundPredicateOr() {\n+        ARRAY_TYPE arrayType = ARRAY_TYPE.STRING;\n+        List<Object> stringValues = getObjects(arrayType, 4);\n+        KiePMMLSimpleSetPredicate kiePMMLSimpleSetPredicateString = getKiePMMLSimpleSetPredicate(SIMPLE_SET_PREDICATE_STRING_NAME,\n+                                                                                                 stringValues,\n+                                                                                                 arrayType,\n+                                                                                                 IN_NOTIN.IN);\n+        arrayType = ARRAY_TYPE.INT;\n+        List<Object> intValues = getObjects(arrayType, 4);\n+        KiePMMLSimpleSetPredicate kiePMMLSimpleSetPredicateInt = getKiePMMLSimpleSetPredicate(SIMPLE_SET_PREDICATE_INT_NAME,\n+                                                                                              intValues,\n+                                                                                              arrayType,\n+                                                                                              IN_NOTIN.NOT_IN);\n+        KiePMMLCompoundPredicate kiePMMLCompoundPredicate = getKiePMMLCompoundPredicate(BOOLEAN_OPERATOR.OR,\n+                                                                                        Arrays.asList(kiePMMLSimpleSetPredicateString, kiePMMLSimpleSetPredicateInt));\n+        Map<String, Object> inputData = new HashMap<>();\n+        inputData.put(SIMPLE_SET_PREDICATE_STRING_NAME, \"NOT\");\n+        inputData.put(SIMPLE_SET_PREDICATE_INT_NAME, intValues.get(0));\n+        assertFalse(kiePMMLCompoundPredicate.evaluate(inputData));\n+\n+        inputData.put(SIMPLE_SET_PREDICATE_STRING_NAME, stringValues.get(0));\n+        inputData.put(SIMPLE_SET_PREDICATE_INT_NAME, intValues.get(0));\n+        assertTrue(kiePMMLCompoundPredicate.evaluate(inputData));\n+\n+        inputData = new HashMap<>();\n+        inputData.put(SIMPLE_SET_PREDICATE_STRING_NAME, \"NOT\");\n+        inputData.put(SIMPLE_SET_PREDICATE_INT_NAME, \"234\");\n+        assertTrue(kiePMMLCompoundPredicate.evaluate(inputData));\n+\n+        inputData = new HashMap<>();\n+        inputData.put(SIMPLE_SET_PREDICATE_STRING_NAME, stringValues.get(0));\n+        inputData.put(SIMPLE_SET_PREDICATE_INT_NAME, \"234\");\n+        assertTrue(kiePMMLCompoundPredicate.evaluate(inputData));\n+    }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM2Nzg5NQ=="}, "originalCommit": {"oid": "52801990de7002c74109aea1c61dd73463246240"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MDQ1NjMyOnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-compiler/kie-pmml-compiler-commons/src/main/java/org/kie/pmml/compiler/commons/factories/KiePMMLPredicateFactory.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMjoxMDoxMVrOHINWhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMzowMDoxNlrOHIPOVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM2OTQxNQ==", "bodyText": "Can we make these static methods private?", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r478369415", "createdAt": "2020-08-27T12:10:11Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-trusty/kie-pmml-compiler/kie-pmml-compiler-commons/src/main/java/org/kie/pmml/compiler/commons/factories/KiePMMLPredicateFactory.java", "diffHunk": "@@ -0,0 +1,403 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.compiler.commons.factories;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\n+import com.github.javaparser.ast.stmt.ExpressionStmt;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import org.dmg.pmml.Array;\n+import org.dmg.pmml.CompoundPredicate;\n+import org.dmg.pmml.DataDictionary;\n+import org.dmg.pmml.DataField;\n+import org.dmg.pmml.DataType;\n+import org.dmg.pmml.False;\n+import org.dmg.pmml.Predicate;\n+import org.dmg.pmml.SimplePredicate;\n+import org.dmg.pmml.SimpleSetPredicate;\n+import org.dmg.pmml.True;\n+import org.kie.pmml.commons.exceptions.KiePMMLException;\n+import org.kie.pmml.commons.exceptions.KiePMMLInternalException;\n+import org.kie.pmml.commons.model.enums.ARRAY_TYPE;\n+import org.kie.pmml.commons.model.enums.BOOLEAN_OPERATOR;\n+import org.kie.pmml.commons.model.enums.DATA_TYPE;\n+import org.kie.pmml.commons.model.enums.IN_NOTIN;\n+import org.kie.pmml.commons.model.enums.OPERATOR;\n+import org.kie.pmml.commons.model.predicates.KiePMMLCompoundPredicate;\n+import org.kie.pmml.commons.model.predicates.KiePMMLFalsePredicate;\n+import org.kie.pmml.commons.model.predicates.KiePMMLPredicate;\n+import org.kie.pmml.commons.model.predicates.KiePMMLSimplePredicate;\n+import org.kie.pmml.commons.model.predicates.KiePMMLSimpleSetPredicate;\n+import org.kie.pmml.commons.model.predicates.KiePMMLTruePredicate;\n+import org.kie.pmml.compiler.commons.utils.CommonCodegenUtils;\n+import org.kie.pmml.compiler.commons.utils.JavaParserUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.javaparser.StaticJavaParser.parseClassOrInterfaceType;\n+import static org.kie.pmml.commons.Constants.MISSING_DEFAULT_CONSTRUCTOR;\n+import static org.kie.pmml.commons.Constants.MISSING_VARIABLE_IN_BODY;\n+import static org.kie.pmml.commons.utils.KiePMMLModelUtils.getSanitizedClassName;\n+import static org.kie.pmml.commons.utils.KiePMMLModelUtils.getSanitizedPackageName;\n+import static org.kie.pmml.compiler.commons.utils.JavaParserUtils.MAIN_CLASS_NOT_FOUND;\n+import static org.kie.pmml.compiler.commons.utils.JavaParserUtils.getFullClassName;\n+import static org.kie.pmml.compiler.commons.utils.KiePMMLModelFactoryUtils.setConstructorSuperNameInvocation;\n+\n+public class KiePMMLPredicateFactory {\n+\n+    static final String KIE_PMML_SIMPLE_PREDICATE_TEMPLATE_JAVA = \"KiePMMLSimplePredicateTemplate.tmpl\";\n+    static final String KIE_PMML_SIMPLE_PREDICATE_TEMPLATE = \"KiePMMLSimplePredicateTemplate\";\n+    static final String KIE_PMML_SIMPLE_SET_PREDICATE_TEMPLATE_JAVA = \"KiePMMLSimpleSetPredicateTemplate.tmpl\";\n+    static final String KIE_PMML_SIMPLE_SET_PREDICATE_TEMPLATE = \"KiePMMLSimpleSetPredicateTemplate\";\n+    static final String KIE_PMML_COMPOUND_PREDICATE_TEMPLATE_JAVA = \"KiePMMLCompoundPredicateTemplate.tmpl\";\n+    static final String KIE_PMML_COMPOUND_PREDICATE_TEMPLATE = \"KiePMMLCompoundPredicateTemplate\";\n+    static final String KIE_PMML_TRUE_PREDICATE_TEMPLATE_JAVA = \"KiePMMLTruePredicateTemplate.tmpl\";\n+    static final String KIE_PMML_TRUE_PREDICATE_TEMPLATE = \"KiePMMLTruePredicateTemplate\";\n+    static final String KIE_PMML_FALSE_PREDICATE_TEMPLATE_JAVA = \"KiePMMLFalsePredicateTemplate.tmpl\";\n+    static final String KIE_PMML_FALSE_PREDICATE_TEMPLATE = \"KiePMMLFalsePredicateTemplate\";\n+    private static final Logger logger = LoggerFactory.getLogger(KiePMMLPredicateFactory.class.getName());\n+\n+    private KiePMMLPredicateFactory() {\n+    }\n+\n+    public static List<KiePMMLPredicate> getPredicates(List<Predicate> predicates, DataDictionary dataDictionary) {\n+        logger.info(\"getPredicates {}\", predicates);\n+        return predicates.stream().map(predicate -> getPredicate(predicate, dataDictionary)).collect(Collectors.toList());\n+    }\n+\n+    public static KiePMMLPredicate getPredicate(Predicate predicate, DataDictionary dataDictionary) {\n+        logger.info(\"getPredicate {}\", predicate);\n+        if (predicate instanceof SimplePredicate) {\n+            final DataType dataType = dataDictionary.getDataFields().stream()\n+                    .filter(dataField -> dataField.getName().getValue().equals(((SimplePredicate) predicate).getField().getValue()))\n+                    .map(DataField::getDataType)\n+                    .findFirst()\n+                    .orElseThrow(() -> new KiePMMLException(\"Failed to find DataField for predicate \" + ((SimplePredicate) predicate).getField().getValue()));\n+            return getKiePMMLSimplePredicate((SimplePredicate) predicate, dataType);\n+        } else if (predicate instanceof SimpleSetPredicate) {\n+            return getKiePMMLSimpleSetPredicate((SimpleSetPredicate) predicate);\n+        } else if (predicate instanceof CompoundPredicate) {\n+            return getKiePMMLCompoundPredicate((CompoundPredicate) predicate, dataDictionary);\n+        } else if (predicate instanceof True) {\n+            return getKiePMMLTruePredicate();\n+        } else if (predicate instanceof False) {\n+            return getKiePMMLFalsePredicate();\n+        } else {\n+            throw new KiePMMLException(\"Predicate of type \" + predicate.getClass().getName() + \" not managed, yet\");\n+        }\n+    }\n+\n+    public static KiePMMLSimplePredicate getKiePMMLSimplePredicate(SimplePredicate predicate, DataType dataType) {\n+        return KiePMMLSimplePredicate.builder(predicate.getField().getValue(), Collections.emptyList(),\n+                                              OPERATOR.byName(predicate.getOperator().value()))\n+                .withValue(getActualValue(predicate.getValue(), dataType))\n+                .build();\n+    }\n+\n+    public static KiePMMLSimpleSetPredicate getKiePMMLSimpleSetPredicate(SimpleSetPredicate predicate) {\n+        List<Object> values = getObjectsFromArray(predicate.getArray());\n+        return KiePMMLSimpleSetPredicate.builder(predicate.getField().getValue(),\n+                                                 Collections.emptyList(),\n+                                                 ARRAY_TYPE.byName(predicate.getArray().getType().value()),\n+                                                 IN_NOTIN.byName(predicate.getBooleanOperator().value()))\n+                .withValues(values)\n+                .build();\n+    }\n+\n+    public static KiePMMLCompoundPredicate getKiePMMLCompoundPredicate(CompoundPredicate predicate,\n+                                                                       DataDictionary dataDictionary) {\n+        return KiePMMLCompoundPredicate.builder(Collections.emptyList(),\n+                                                BOOLEAN_OPERATOR.byName(predicate.getBooleanOperator().value()))\n+                .withKiePMMLPredicates(getPredicates(predicate.getPredicates(), dataDictionary))\n+                .build();\n+    }\n+\n+    public static KiePMMLTruePredicate getKiePMMLTruePredicate() {\n+        return KiePMMLTruePredicate.builder(Collections.emptyList())\n+                .build();\n+    }\n+\n+    public static KiePMMLFalsePredicate getKiePMMLFalsePredicate() {\n+        return KiePMMLFalsePredicate.builder(Collections.emptyList())\n+                .build();\n+    }\n+\n+    public static Map<String, String> getPredicateSourcesMap(final KiePMMLPredicate kiePMMLPredicate,\n+                                                             final String packageName) {\n+        logger.info(\"getPredicateSourcesMap {}\", kiePMMLPredicate);\n+        if (kiePMMLPredicate instanceof KiePMMLSimplePredicate) {\n+            return getKiePMMLSimplePredicateSourcesMap((KiePMMLSimplePredicate) kiePMMLPredicate, packageName);\n+        } else if (kiePMMLPredicate instanceof KiePMMLSimpleSetPredicate) {\n+            return getKiePMMLSimpleSetPredicateSourcesMap((KiePMMLSimpleSetPredicate) kiePMMLPredicate, packageName);\n+        } else if (kiePMMLPredicate instanceof KiePMMLCompoundPredicate) {\n+            return getKiePMMLCompoundPredicateSourcesMap((KiePMMLCompoundPredicate) kiePMMLPredicate, packageName);\n+        } else if (kiePMMLPredicate instanceof KiePMMLTruePredicate) {\n+            return getKiePMMLTruePredicateSourcesMap((KiePMMLTruePredicate) kiePMMLPredicate, packageName);\n+        } else if (kiePMMLPredicate instanceof KiePMMLFalsePredicate) {\n+            return getKiePMMLFalsePredicateSourcesMap((KiePMMLFalsePredicate) kiePMMLPredicate, packageName);\n+        } else {\n+            throw new KiePMMLException(\"Predicate of type \" + kiePMMLPredicate.getClass().getName() + \" not managed, \" +\n+                                               \"yet\");\n+        }\n+    }\n+\n+    static Map<String, String> getKiePMMLSimplePredicateSourcesMap(final KiePMMLSimplePredicate kiePMMLSimplePredicate, final String packageName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52801990de7002c74109aea1c61dd73463246240"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQwMDA4Ng==", "bodyText": "@jiripetrlik\nWherever I put the  default (package) modifier, it is for testing purpose", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r478400086", "createdAt": "2020-08-27T13:00:16Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-trusty/kie-pmml-compiler/kie-pmml-compiler-commons/src/main/java/org/kie/pmml/compiler/commons/factories/KiePMMLPredicateFactory.java", "diffHunk": "@@ -0,0 +1,403 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.compiler.commons.factories;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\n+import com.github.javaparser.ast.stmt.ExpressionStmt;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import org.dmg.pmml.Array;\n+import org.dmg.pmml.CompoundPredicate;\n+import org.dmg.pmml.DataDictionary;\n+import org.dmg.pmml.DataField;\n+import org.dmg.pmml.DataType;\n+import org.dmg.pmml.False;\n+import org.dmg.pmml.Predicate;\n+import org.dmg.pmml.SimplePredicate;\n+import org.dmg.pmml.SimpleSetPredicate;\n+import org.dmg.pmml.True;\n+import org.kie.pmml.commons.exceptions.KiePMMLException;\n+import org.kie.pmml.commons.exceptions.KiePMMLInternalException;\n+import org.kie.pmml.commons.model.enums.ARRAY_TYPE;\n+import org.kie.pmml.commons.model.enums.BOOLEAN_OPERATOR;\n+import org.kie.pmml.commons.model.enums.DATA_TYPE;\n+import org.kie.pmml.commons.model.enums.IN_NOTIN;\n+import org.kie.pmml.commons.model.enums.OPERATOR;\n+import org.kie.pmml.commons.model.predicates.KiePMMLCompoundPredicate;\n+import org.kie.pmml.commons.model.predicates.KiePMMLFalsePredicate;\n+import org.kie.pmml.commons.model.predicates.KiePMMLPredicate;\n+import org.kie.pmml.commons.model.predicates.KiePMMLSimplePredicate;\n+import org.kie.pmml.commons.model.predicates.KiePMMLSimpleSetPredicate;\n+import org.kie.pmml.commons.model.predicates.KiePMMLTruePredicate;\n+import org.kie.pmml.compiler.commons.utils.CommonCodegenUtils;\n+import org.kie.pmml.compiler.commons.utils.JavaParserUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.javaparser.StaticJavaParser.parseClassOrInterfaceType;\n+import static org.kie.pmml.commons.Constants.MISSING_DEFAULT_CONSTRUCTOR;\n+import static org.kie.pmml.commons.Constants.MISSING_VARIABLE_IN_BODY;\n+import static org.kie.pmml.commons.utils.KiePMMLModelUtils.getSanitizedClassName;\n+import static org.kie.pmml.commons.utils.KiePMMLModelUtils.getSanitizedPackageName;\n+import static org.kie.pmml.compiler.commons.utils.JavaParserUtils.MAIN_CLASS_NOT_FOUND;\n+import static org.kie.pmml.compiler.commons.utils.JavaParserUtils.getFullClassName;\n+import static org.kie.pmml.compiler.commons.utils.KiePMMLModelFactoryUtils.setConstructorSuperNameInvocation;\n+\n+public class KiePMMLPredicateFactory {\n+\n+    static final String KIE_PMML_SIMPLE_PREDICATE_TEMPLATE_JAVA = \"KiePMMLSimplePredicateTemplate.tmpl\";\n+    static final String KIE_PMML_SIMPLE_PREDICATE_TEMPLATE = \"KiePMMLSimplePredicateTemplate\";\n+    static final String KIE_PMML_SIMPLE_SET_PREDICATE_TEMPLATE_JAVA = \"KiePMMLSimpleSetPredicateTemplate.tmpl\";\n+    static final String KIE_PMML_SIMPLE_SET_PREDICATE_TEMPLATE = \"KiePMMLSimpleSetPredicateTemplate\";\n+    static final String KIE_PMML_COMPOUND_PREDICATE_TEMPLATE_JAVA = \"KiePMMLCompoundPredicateTemplate.tmpl\";\n+    static final String KIE_PMML_COMPOUND_PREDICATE_TEMPLATE = \"KiePMMLCompoundPredicateTemplate\";\n+    static final String KIE_PMML_TRUE_PREDICATE_TEMPLATE_JAVA = \"KiePMMLTruePredicateTemplate.tmpl\";\n+    static final String KIE_PMML_TRUE_PREDICATE_TEMPLATE = \"KiePMMLTruePredicateTemplate\";\n+    static final String KIE_PMML_FALSE_PREDICATE_TEMPLATE_JAVA = \"KiePMMLFalsePredicateTemplate.tmpl\";\n+    static final String KIE_PMML_FALSE_PREDICATE_TEMPLATE = \"KiePMMLFalsePredicateTemplate\";\n+    private static final Logger logger = LoggerFactory.getLogger(KiePMMLPredicateFactory.class.getName());\n+\n+    private KiePMMLPredicateFactory() {\n+    }\n+\n+    public static List<KiePMMLPredicate> getPredicates(List<Predicate> predicates, DataDictionary dataDictionary) {\n+        logger.info(\"getPredicates {}\", predicates);\n+        return predicates.stream().map(predicate -> getPredicate(predicate, dataDictionary)).collect(Collectors.toList());\n+    }\n+\n+    public static KiePMMLPredicate getPredicate(Predicate predicate, DataDictionary dataDictionary) {\n+        logger.info(\"getPredicate {}\", predicate);\n+        if (predicate instanceof SimplePredicate) {\n+            final DataType dataType = dataDictionary.getDataFields().stream()\n+                    .filter(dataField -> dataField.getName().getValue().equals(((SimplePredicate) predicate).getField().getValue()))\n+                    .map(DataField::getDataType)\n+                    .findFirst()\n+                    .orElseThrow(() -> new KiePMMLException(\"Failed to find DataField for predicate \" + ((SimplePredicate) predicate).getField().getValue()));\n+            return getKiePMMLSimplePredicate((SimplePredicate) predicate, dataType);\n+        } else if (predicate instanceof SimpleSetPredicate) {\n+            return getKiePMMLSimpleSetPredicate((SimpleSetPredicate) predicate);\n+        } else if (predicate instanceof CompoundPredicate) {\n+            return getKiePMMLCompoundPredicate((CompoundPredicate) predicate, dataDictionary);\n+        } else if (predicate instanceof True) {\n+            return getKiePMMLTruePredicate();\n+        } else if (predicate instanceof False) {\n+            return getKiePMMLFalsePredicate();\n+        } else {\n+            throw new KiePMMLException(\"Predicate of type \" + predicate.getClass().getName() + \" not managed, yet\");\n+        }\n+    }\n+\n+    public static KiePMMLSimplePredicate getKiePMMLSimplePredicate(SimplePredicate predicate, DataType dataType) {\n+        return KiePMMLSimplePredicate.builder(predicate.getField().getValue(), Collections.emptyList(),\n+                                              OPERATOR.byName(predicate.getOperator().value()))\n+                .withValue(getActualValue(predicate.getValue(), dataType))\n+                .build();\n+    }\n+\n+    public static KiePMMLSimpleSetPredicate getKiePMMLSimpleSetPredicate(SimpleSetPredicate predicate) {\n+        List<Object> values = getObjectsFromArray(predicate.getArray());\n+        return KiePMMLSimpleSetPredicate.builder(predicate.getField().getValue(),\n+                                                 Collections.emptyList(),\n+                                                 ARRAY_TYPE.byName(predicate.getArray().getType().value()),\n+                                                 IN_NOTIN.byName(predicate.getBooleanOperator().value()))\n+                .withValues(values)\n+                .build();\n+    }\n+\n+    public static KiePMMLCompoundPredicate getKiePMMLCompoundPredicate(CompoundPredicate predicate,\n+                                                                       DataDictionary dataDictionary) {\n+        return KiePMMLCompoundPredicate.builder(Collections.emptyList(),\n+                                                BOOLEAN_OPERATOR.byName(predicate.getBooleanOperator().value()))\n+                .withKiePMMLPredicates(getPredicates(predicate.getPredicates(), dataDictionary))\n+                .build();\n+    }\n+\n+    public static KiePMMLTruePredicate getKiePMMLTruePredicate() {\n+        return KiePMMLTruePredicate.builder(Collections.emptyList())\n+                .build();\n+    }\n+\n+    public static KiePMMLFalsePredicate getKiePMMLFalsePredicate() {\n+        return KiePMMLFalsePredicate.builder(Collections.emptyList())\n+                .build();\n+    }\n+\n+    public static Map<String, String> getPredicateSourcesMap(final KiePMMLPredicate kiePMMLPredicate,\n+                                                             final String packageName) {\n+        logger.info(\"getPredicateSourcesMap {}\", kiePMMLPredicate);\n+        if (kiePMMLPredicate instanceof KiePMMLSimplePredicate) {\n+            return getKiePMMLSimplePredicateSourcesMap((KiePMMLSimplePredicate) kiePMMLPredicate, packageName);\n+        } else if (kiePMMLPredicate instanceof KiePMMLSimpleSetPredicate) {\n+            return getKiePMMLSimpleSetPredicateSourcesMap((KiePMMLSimpleSetPredicate) kiePMMLPredicate, packageName);\n+        } else if (kiePMMLPredicate instanceof KiePMMLCompoundPredicate) {\n+            return getKiePMMLCompoundPredicateSourcesMap((KiePMMLCompoundPredicate) kiePMMLPredicate, packageName);\n+        } else if (kiePMMLPredicate instanceof KiePMMLTruePredicate) {\n+            return getKiePMMLTruePredicateSourcesMap((KiePMMLTruePredicate) kiePMMLPredicate, packageName);\n+        } else if (kiePMMLPredicate instanceof KiePMMLFalsePredicate) {\n+            return getKiePMMLFalsePredicateSourcesMap((KiePMMLFalsePredicate) kiePMMLPredicate, packageName);\n+        } else {\n+            throw new KiePMMLException(\"Predicate of type \" + kiePMMLPredicate.getClass().getName() + \" not managed, \" +\n+                                               \"yet\");\n+        }\n+    }\n+\n+    static Map<String, String> getKiePMMLSimplePredicateSourcesMap(final KiePMMLSimplePredicate kiePMMLSimplePredicate, final String packageName) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM2OTQxNQ=="}, "originalCommit": {"oid": "52801990de7002c74109aea1c61dd73463246240"}, "originalPosition": 176}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MDQ2MTE1OnYy", "diffSide": "RIGHT", "path": "kie-pmml-trusty/kie-pmml-compiler/kie-pmml-compiler-commons/src/main/java/org/kie/pmml/compiler/commons/factories/KiePMMLPredicateFactory.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMjoxMToyNFrOHINZWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMzowMjoyMFrOHIPTxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM3MDEzNg==", "bodyText": "Please consider to add some default with exception,", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r478370136", "createdAt": "2020-08-27T12:11:24Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-trusty/kie-pmml-compiler/kie-pmml-compiler-commons/src/main/java/org/kie/pmml/compiler/commons/factories/KiePMMLPredicateFactory.java", "diffHunk": "@@ -0,0 +1,403 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.compiler.commons.factories;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\n+import com.github.javaparser.ast.stmt.ExpressionStmt;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import org.dmg.pmml.Array;\n+import org.dmg.pmml.CompoundPredicate;\n+import org.dmg.pmml.DataDictionary;\n+import org.dmg.pmml.DataField;\n+import org.dmg.pmml.DataType;\n+import org.dmg.pmml.False;\n+import org.dmg.pmml.Predicate;\n+import org.dmg.pmml.SimplePredicate;\n+import org.dmg.pmml.SimpleSetPredicate;\n+import org.dmg.pmml.True;\n+import org.kie.pmml.commons.exceptions.KiePMMLException;\n+import org.kie.pmml.commons.exceptions.KiePMMLInternalException;\n+import org.kie.pmml.commons.model.enums.ARRAY_TYPE;\n+import org.kie.pmml.commons.model.enums.BOOLEAN_OPERATOR;\n+import org.kie.pmml.commons.model.enums.DATA_TYPE;\n+import org.kie.pmml.commons.model.enums.IN_NOTIN;\n+import org.kie.pmml.commons.model.enums.OPERATOR;\n+import org.kie.pmml.commons.model.predicates.KiePMMLCompoundPredicate;\n+import org.kie.pmml.commons.model.predicates.KiePMMLFalsePredicate;\n+import org.kie.pmml.commons.model.predicates.KiePMMLPredicate;\n+import org.kie.pmml.commons.model.predicates.KiePMMLSimplePredicate;\n+import org.kie.pmml.commons.model.predicates.KiePMMLSimpleSetPredicate;\n+import org.kie.pmml.commons.model.predicates.KiePMMLTruePredicate;\n+import org.kie.pmml.compiler.commons.utils.CommonCodegenUtils;\n+import org.kie.pmml.compiler.commons.utils.JavaParserUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.javaparser.StaticJavaParser.parseClassOrInterfaceType;\n+import static org.kie.pmml.commons.Constants.MISSING_DEFAULT_CONSTRUCTOR;\n+import static org.kie.pmml.commons.Constants.MISSING_VARIABLE_IN_BODY;\n+import static org.kie.pmml.commons.utils.KiePMMLModelUtils.getSanitizedClassName;\n+import static org.kie.pmml.commons.utils.KiePMMLModelUtils.getSanitizedPackageName;\n+import static org.kie.pmml.compiler.commons.utils.JavaParserUtils.MAIN_CLASS_NOT_FOUND;\n+import static org.kie.pmml.compiler.commons.utils.JavaParserUtils.getFullClassName;\n+import static org.kie.pmml.compiler.commons.utils.KiePMMLModelFactoryUtils.setConstructorSuperNameInvocation;\n+\n+public class KiePMMLPredicateFactory {\n+\n+    static final String KIE_PMML_SIMPLE_PREDICATE_TEMPLATE_JAVA = \"KiePMMLSimplePredicateTemplate.tmpl\";\n+    static final String KIE_PMML_SIMPLE_PREDICATE_TEMPLATE = \"KiePMMLSimplePredicateTemplate\";\n+    static final String KIE_PMML_SIMPLE_SET_PREDICATE_TEMPLATE_JAVA = \"KiePMMLSimpleSetPredicateTemplate.tmpl\";\n+    static final String KIE_PMML_SIMPLE_SET_PREDICATE_TEMPLATE = \"KiePMMLSimpleSetPredicateTemplate\";\n+    static final String KIE_PMML_COMPOUND_PREDICATE_TEMPLATE_JAVA = \"KiePMMLCompoundPredicateTemplate.tmpl\";\n+    static final String KIE_PMML_COMPOUND_PREDICATE_TEMPLATE = \"KiePMMLCompoundPredicateTemplate\";\n+    static final String KIE_PMML_TRUE_PREDICATE_TEMPLATE_JAVA = \"KiePMMLTruePredicateTemplate.tmpl\";\n+    static final String KIE_PMML_TRUE_PREDICATE_TEMPLATE = \"KiePMMLTruePredicateTemplate\";\n+    static final String KIE_PMML_FALSE_PREDICATE_TEMPLATE_JAVA = \"KiePMMLFalsePredicateTemplate.tmpl\";\n+    static final String KIE_PMML_FALSE_PREDICATE_TEMPLATE = \"KiePMMLFalsePredicateTemplate\";\n+    private static final Logger logger = LoggerFactory.getLogger(KiePMMLPredicateFactory.class.getName());\n+\n+    private KiePMMLPredicateFactory() {\n+    }\n+\n+    public static List<KiePMMLPredicate> getPredicates(List<Predicate> predicates, DataDictionary dataDictionary) {\n+        logger.info(\"getPredicates {}\", predicates);\n+        return predicates.stream().map(predicate -> getPredicate(predicate, dataDictionary)).collect(Collectors.toList());\n+    }\n+\n+    public static KiePMMLPredicate getPredicate(Predicate predicate, DataDictionary dataDictionary) {\n+        logger.info(\"getPredicate {}\", predicate);\n+        if (predicate instanceof SimplePredicate) {\n+            final DataType dataType = dataDictionary.getDataFields().stream()\n+                    .filter(dataField -> dataField.getName().getValue().equals(((SimplePredicate) predicate).getField().getValue()))\n+                    .map(DataField::getDataType)\n+                    .findFirst()\n+                    .orElseThrow(() -> new KiePMMLException(\"Failed to find DataField for predicate \" + ((SimplePredicate) predicate).getField().getValue()));\n+            return getKiePMMLSimplePredicate((SimplePredicate) predicate, dataType);\n+        } else if (predicate instanceof SimpleSetPredicate) {\n+            return getKiePMMLSimpleSetPredicate((SimpleSetPredicate) predicate);\n+        } else if (predicate instanceof CompoundPredicate) {\n+            return getKiePMMLCompoundPredicate((CompoundPredicate) predicate, dataDictionary);\n+        } else if (predicate instanceof True) {\n+            return getKiePMMLTruePredicate();\n+        } else if (predicate instanceof False) {\n+            return getKiePMMLFalsePredicate();\n+        } else {\n+            throw new KiePMMLException(\"Predicate of type \" + predicate.getClass().getName() + \" not managed, yet\");\n+        }\n+    }\n+\n+    public static KiePMMLSimplePredicate getKiePMMLSimplePredicate(SimplePredicate predicate, DataType dataType) {\n+        return KiePMMLSimplePredicate.builder(predicate.getField().getValue(), Collections.emptyList(),\n+                                              OPERATOR.byName(predicate.getOperator().value()))\n+                .withValue(getActualValue(predicate.getValue(), dataType))\n+                .build();\n+    }\n+\n+    public static KiePMMLSimpleSetPredicate getKiePMMLSimpleSetPredicate(SimpleSetPredicate predicate) {\n+        List<Object> values = getObjectsFromArray(predicate.getArray());\n+        return KiePMMLSimpleSetPredicate.builder(predicate.getField().getValue(),\n+                                                 Collections.emptyList(),\n+                                                 ARRAY_TYPE.byName(predicate.getArray().getType().value()),\n+                                                 IN_NOTIN.byName(predicate.getBooleanOperator().value()))\n+                .withValues(values)\n+                .build();\n+    }\n+\n+    public static KiePMMLCompoundPredicate getKiePMMLCompoundPredicate(CompoundPredicate predicate,\n+                                                                       DataDictionary dataDictionary) {\n+        return KiePMMLCompoundPredicate.builder(Collections.emptyList(),\n+                                                BOOLEAN_OPERATOR.byName(predicate.getBooleanOperator().value()))\n+                .withKiePMMLPredicates(getPredicates(predicate.getPredicates(), dataDictionary))\n+                .build();\n+    }\n+\n+    public static KiePMMLTruePredicate getKiePMMLTruePredicate() {\n+        return KiePMMLTruePredicate.builder(Collections.emptyList())\n+                .build();\n+    }\n+\n+    public static KiePMMLFalsePredicate getKiePMMLFalsePredicate() {\n+        return KiePMMLFalsePredicate.builder(Collections.emptyList())\n+                .build();\n+    }\n+\n+    public static Map<String, String> getPredicateSourcesMap(final KiePMMLPredicate kiePMMLPredicate,\n+                                                             final String packageName) {\n+        logger.info(\"getPredicateSourcesMap {}\", kiePMMLPredicate);\n+        if (kiePMMLPredicate instanceof KiePMMLSimplePredicate) {\n+            return getKiePMMLSimplePredicateSourcesMap((KiePMMLSimplePredicate) kiePMMLPredicate, packageName);\n+        } else if (kiePMMLPredicate instanceof KiePMMLSimpleSetPredicate) {\n+            return getKiePMMLSimpleSetPredicateSourcesMap((KiePMMLSimpleSetPredicate) kiePMMLPredicate, packageName);\n+        } else if (kiePMMLPredicate instanceof KiePMMLCompoundPredicate) {\n+            return getKiePMMLCompoundPredicateSourcesMap((KiePMMLCompoundPredicate) kiePMMLPredicate, packageName);\n+        } else if (kiePMMLPredicate instanceof KiePMMLTruePredicate) {\n+            return getKiePMMLTruePredicateSourcesMap((KiePMMLTruePredicate) kiePMMLPredicate, packageName);\n+        } else if (kiePMMLPredicate instanceof KiePMMLFalsePredicate) {\n+            return getKiePMMLFalsePredicateSourcesMap((KiePMMLFalsePredicate) kiePMMLPredicate, packageName);\n+        } else {\n+            throw new KiePMMLException(\"Predicate of type \" + kiePMMLPredicate.getClass().getName() + \" not managed, \" +\n+                                               \"yet\");\n+        }\n+    }\n+\n+    static Map<String, String> getKiePMMLSimplePredicateSourcesMap(final KiePMMLSimplePredicate kiePMMLSimplePredicate, final String packageName) {\n+        String className = getSanitizedClassName(kiePMMLSimplePredicate.getName());\n+        CompilationUnit cloneCU = JavaParserUtils.getKiePMMLModelCompilationUnit(className, packageName,\n+                                                                                 KIE_PMML_SIMPLE_PREDICATE_TEMPLATE_JAVA, KIE_PMML_SIMPLE_PREDICATE_TEMPLATE);\n+        ClassOrInterfaceDeclaration predicateTemplate = cloneCU.getClassByName(className)\n+                .orElseThrow(() -> new KiePMMLException(MAIN_CLASS_NOT_FOUND + \": \" + className));\n+        final ConstructorDeclaration constructorDeclaration = predicateTemplate.getDefaultConstructor()\n+                .orElseThrow(() -> new KiePMMLInternalException(String.format(MISSING_DEFAULT_CONSTRUCTOR,\n+                                                                              predicateTemplate.getName())));\n+        setSimplePredicateConstructor(className,\n+                                      kiePMMLSimplePredicate.getName(),\n+                                      constructorDeclaration,\n+                                      kiePMMLSimplePredicate.getOperator(),\n+                                      kiePMMLSimplePredicate.getValue());\n+        return Collections.singletonMap(getFullClassName(cloneCU), cloneCU.toString());\n+    }\n+\n+    static Map<String, String> getKiePMMLSimpleSetPredicateSourcesMap(final KiePMMLSimpleSetPredicate kiePMMLSimpleSetPredicate,\n+                                                                      final String packageName) {\n+        String className = getSanitizedClassName(kiePMMLSimpleSetPredicate.getName());\n+        CompilationUnit cloneCU = JavaParserUtils.getKiePMMLModelCompilationUnit(className, packageName,\n+                                                                                 KIE_PMML_SIMPLE_SET_PREDICATE_TEMPLATE_JAVA, KIE_PMML_SIMPLE_SET_PREDICATE_TEMPLATE);\n+        ClassOrInterfaceDeclaration predicateTemplate = cloneCU.getClassByName(className)\n+                .orElseThrow(() -> new KiePMMLException(MAIN_CLASS_NOT_FOUND + \": \" + className));\n+        final ConstructorDeclaration constructorDeclaration = predicateTemplate.getDefaultConstructor()\n+                .orElseThrow(() -> new KiePMMLInternalException(String.format(MISSING_DEFAULT_CONSTRUCTOR,\n+                                                                              predicateTemplate.getName())));\n+        setSimpleSetPredicateConstructor(className,\n+                                         kiePMMLSimpleSetPredicate.getName(),\n+                                         constructorDeclaration,\n+                                         kiePMMLSimpleSetPredicate.getArrayType(),\n+                                         kiePMMLSimpleSetPredicate.getInNotIn(),\n+                                         kiePMMLSimpleSetPredicate.getValues());\n+        return Collections.singletonMap(getFullClassName(cloneCU), cloneCU.toString());\n+    }\n+\n+    static Map<String, String> getKiePMMLCompoundPredicateSourcesMap(final KiePMMLCompoundPredicate kiePMMLCompoundPredicate, final String packageName) {\n+        String className = getSanitizedClassName(kiePMMLCompoundPredicate.getName());\n+        final Map<String, String> toReturn = new HashMap<>();\n+        if (kiePMMLCompoundPredicate.getKiePMMLPredicates() != null) {\n+            kiePMMLCompoundPredicate.getKiePMMLPredicates().forEach(kiePMMLPredicate -> toReturn.putAll(getPredicateSourcesMap(kiePMMLPredicate, packageName)));\n+        }\n+        CompilationUnit cloneCU = JavaParserUtils.getKiePMMLModelCompilationUnit(className, packageName,\n+                                                                                 KIE_PMML_COMPOUND_PREDICATE_TEMPLATE_JAVA, KIE_PMML_COMPOUND_PREDICATE_TEMPLATE);\n+        ClassOrInterfaceDeclaration predicateTemplate = cloneCU.getClassByName(className)\n+                .orElseThrow(() -> new KiePMMLException(MAIN_CLASS_NOT_FOUND + \": \" + className));\n+        final ConstructorDeclaration constructorDeclaration = predicateTemplate.getDefaultConstructor()\n+                .orElseThrow(() -> new KiePMMLInternalException(String.format(MISSING_DEFAULT_CONSTRUCTOR,\n+                                                                              predicateTemplate.getName())));\n+        Set<String> predicatesClasses = new HashSet<>();\n+        if (kiePMMLCompoundPredicate.getKiePMMLPredicates() != null) {\n+            predicatesClasses = kiePMMLCompoundPredicate.getKiePMMLPredicates().stream()\n+                    .map(predicate ->  packageName + \".\" + getSanitizedClassName(predicate.getName()))\n+                    .collect(Collectors.toSet());\n+        }\n+        if (!toReturn.keySet().containsAll(predicatesClasses)) {\n+            String missingClasses = String.join(\", \", predicatesClasses);\n+            throw new KiePMMLException(\"Expected generated class \" + missingClasses + \" not found\");\n+        }\n+        setCompoundPredicateConstructor(className,\n+                                        kiePMMLCompoundPredicate.getName(),\n+                                        constructorDeclaration,\n+                                        kiePMMLCompoundPredicate.getBooleanOperator(),\n+                                        predicatesClasses);\n+        toReturn.put(getFullClassName(cloneCU), cloneCU.toString());\n+        return toReturn;\n+    }\n+\n+    static Map<String, String> getKiePMMLTruePredicateSourcesMap(final KiePMMLTruePredicate kiePMMLTruePredicate,\n+                                                                 final String packageName) {\n+        String className = getSanitizedClassName(kiePMMLTruePredicate.getName());\n+        CompilationUnit cloneCU = JavaParserUtils.getKiePMMLModelCompilationUnit(className, packageName,\n+                                                                                 KIE_PMML_TRUE_PREDICATE_TEMPLATE_JAVA, KIE_PMML_TRUE_PREDICATE_TEMPLATE);\n+        ClassOrInterfaceDeclaration predicateTemplate = cloneCU.getClassByName(className)\n+                .orElseThrow(() -> new KiePMMLException(MAIN_CLASS_NOT_FOUND + \": \" + className));\n+        final ConstructorDeclaration constructorDeclaration = predicateTemplate.getDefaultConstructor()\n+                .orElseThrow(() -> new KiePMMLInternalException(String.format(\n+                        MISSING_DEFAULT_CONSTRUCTOR, predicateTemplate.getName())));\n+        setTrueFalsePredicateConstructor(className,\n+                                         kiePMMLTruePredicate.getName(),\n+                                         constructorDeclaration);\n+        return Collections.singletonMap(getFullClassName(cloneCU), cloneCU.toString());\n+    }\n+\n+    static Map<String, String> getKiePMMLFalsePredicateSourcesMap(final KiePMMLFalsePredicate kiePMMLFalsePredicate,\n+                                                                  final String packageName) {\n+        String className = getSanitizedClassName(kiePMMLFalsePredicate.getName());\n+        CompilationUnit cloneCU = JavaParserUtils.getKiePMMLModelCompilationUnit(className, packageName,\n+                                                                                 KIE_PMML_FALSE_PREDICATE_TEMPLATE_JAVA, KIE_PMML_FALSE_PREDICATE_TEMPLATE);\n+        ClassOrInterfaceDeclaration predicateTemplate = cloneCU.getClassByName(className)\n+                .orElseThrow(() -> new KiePMMLException(MAIN_CLASS_NOT_FOUND + \": \" + className));\n+        final ConstructorDeclaration constructorDeclaration = predicateTemplate.getDefaultConstructor()\n+                .orElseThrow(() -> new KiePMMLInternalException(String.format(\n+                        MISSING_DEFAULT_CONSTRUCTOR, predicateTemplate.getName())));\n+        setTrueFalsePredicateConstructor(className,\n+                                         kiePMMLFalsePredicate.getName(),\n+                                         constructorDeclaration);\n+        return Collections.singletonMap(getFullClassName(cloneCU), cloneCU.toString());\n+    }\n+\n+    static void setSimplePredicateConstructor(final String generatedClassName,\n+                                              final String predicateName,\n+                                              final ConstructorDeclaration constructorDeclaration,\n+                                              final OPERATOR operator,\n+                                              final Object value) {\n+        setConstructorSuperNameInvocation(generatedClassName, constructorDeclaration, predicateName);\n+        final BlockStmt body = constructorDeclaration.getBody();\n+        body.getStatements().iterator().forEachRemaining(statement -> {\n+            if (statement instanceof ExplicitConstructorInvocationStmt) {\n+                ExplicitConstructorInvocationStmt superStatement = (ExplicitConstructorInvocationStmt) statement;\n+                NameExpr nameExpr = (NameExpr) superStatement.getArgument(2);\n+                nameExpr.setName(operator.getClass().getCanonicalName() + \".\" + operator.name());\n+            }\n+        });\n+        Expression expression = value instanceof String ? new StringLiteralExpr((String) value) : new NameExpr(value.toString());\n+        CommonCodegenUtils.setAssignExpressionValue(body, \"value\", expression);\n+    }\n+\n+    static void setSimpleSetPredicateConstructor(final String generatedClassName,\n+                                                 final String predicateName,\n+                                                 final ConstructorDeclaration constructorDeclaration,\n+                                                 final ARRAY_TYPE arrayType,\n+                                                 final IN_NOTIN inNotIn,\n+                                                 final List<Object> values) {\n+        setConstructorSuperNameInvocation(generatedClassName, constructorDeclaration, predicateName);\n+        final BlockStmt body = constructorDeclaration.getBody();\n+        body.getStatements().iterator().forEachRemaining(statement -> {\n+            if (statement instanceof ExplicitConstructorInvocationStmt) {\n+                ExplicitConstructorInvocationStmt superStatement = (ExplicitConstructorInvocationStmt) statement;\n+                NameExpr nameExpr = (NameExpr) superStatement.getArgument(2);\n+                nameExpr.setName(arrayType.getClass().getCanonicalName() + \".\" + arrayType.name());\n+                nameExpr = (NameExpr) superStatement.getArgument(3);\n+                nameExpr.setName(inNotIn.getClass().getCanonicalName() + \".\" + inNotIn.name());\n+            }\n+        });\n+        AssignExpr assignExpr = CommonCodegenUtils\n+                .getAssignExpression(body, \"values\")\n+                .orElseThrow(() -> new KiePMMLException(String.format(MISSING_VARIABLE_IN_BODY, \"values\", body)));\n+        ClassOrInterfaceType arrayClass = parseClassOrInterfaceType(ArrayList.class.getName());\n+        ObjectCreationExpr objectCreationExpr = new ObjectCreationExpr();\n+        objectCreationExpr.setType(arrayClass);\n+        assignExpr.setValue(objectCreationExpr);\n+        for (Object value : values) {\n+            Expression valueExpression;\n+            if (arrayType == ARRAY_TYPE.STRING) {\n+                valueExpression = new StringLiteralExpr(value.toString());\n+            } else {\n+                valueExpression = new NameExpr(value.toString());\n+            }\n+            NodeList<Expression> arguments = NodeList.nodeList(valueExpression);\n+            MethodCallExpr methodCallExpr = new MethodCallExpr();\n+            methodCallExpr.setScope(assignExpr.getTarget().asNameExpr());\n+            methodCallExpr.setName(\"add\");\n+            methodCallExpr.setArguments(arguments);\n+            ExpressionStmt expressionStmt = new ExpressionStmt();\n+            expressionStmt.setExpression(methodCallExpr);\n+            body.addStatement(expressionStmt);\n+        }\n+    }\n+\n+    static void setCompoundPredicateConstructor(final String generatedClassName,\n+                                                final String predicateName,\n+                                                final ConstructorDeclaration constructorDeclaration,\n+                                                final BOOLEAN_OPERATOR booleanOperator,\n+                                                final Set<String> predicatesClasses) {\n+        setConstructorSuperNameInvocation(generatedClassName, constructorDeclaration, predicateName);\n+        final BlockStmt body = constructorDeclaration.getBody();\n+        body.getStatements().iterator().forEachRemaining(statement -> {\n+            if (statement instanceof ExplicitConstructorInvocationStmt) {\n+                ExplicitConstructorInvocationStmt superStatement = (ExplicitConstructorInvocationStmt) statement;\n+                NameExpr nameExpr = (NameExpr) superStatement.getArgument(2);\n+                nameExpr.setName(booleanOperator.getClass().getCanonicalName() + \".\" + booleanOperator.name());\n+            }\n+        });\n+        AssignExpr assignExpr = CommonCodegenUtils\n+                .getAssignExpression(body, \"kiePMMLPredicates\")\n+                .orElseThrow(() -> new KiePMMLException(String.format(MISSING_VARIABLE_IN_BODY, \"kiePMMLPredicates\", body)));\n+        ClassOrInterfaceType arrayClass = parseClassOrInterfaceType(ArrayList.class.getName());\n+        ObjectCreationExpr objectCreationExpr = new ObjectCreationExpr();\n+        objectCreationExpr.setType(arrayClass);\n+        assignExpr.setValue(objectCreationExpr);\n+        for (String predicateClass : predicatesClasses) {\n+            ClassOrInterfaceType kiePMMLPredicateClass = parseClassOrInterfaceType(predicateClass);\n+            objectCreationExpr = new ObjectCreationExpr();\n+            objectCreationExpr.setType(kiePMMLPredicateClass);\n+            NodeList<Expression> arguments = NodeList.nodeList(objectCreationExpr);\n+            MethodCallExpr methodCallExpr = new MethodCallExpr();\n+            methodCallExpr.setScope(assignExpr.getTarget().asNameExpr());\n+            methodCallExpr.setName(\"add\");\n+            methodCallExpr.setArguments(arguments);\n+            ExpressionStmt expressionStmt = new ExpressionStmt();\n+            expressionStmt.setExpression(methodCallExpr);\n+            body.addStatement(expressionStmt);\n+        }\n+    }\n+\n+    static void setTrueFalsePredicateConstructor(final String generatedClassName,\n+                                                 final String predicateName,\n+                                                 final ConstructorDeclaration constructorDeclaration) {\n+        setConstructorSuperNameInvocation(generatedClassName, constructorDeclaration, predicateName);\n+    }\n+\n+    static List<Object> getObjectsFromArray(Array source) {\n+        Array.Type type = source.getType();\n+        List<Object> toReturn = new ArrayList<>();\n+        String stringValue = (String) source.getValue();\n+        String[] valuesArray = stringValue.split(\" \");\n+        for (String s : valuesArray) {\n+            switch (type) {\n+                case INT:\n+                    toReturn.add(Integer.valueOf(s));\n+                    break;\n+                case STRING:\n+                    toReturn.add(s);\n+                    break;\n+                case REAL:\n+                    toReturn.add(Double.valueOf(s));\n+                    break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52801990de7002c74109aea1c61dd73463246240"}, "originalPosition": 393}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQwMTQ3Ng==", "bodyText": "@jiripetrlik\ndone", "url": "https://github.com/kiegroup/drools/pull/3041#discussion_r478401476", "createdAt": "2020-08-27T13:02:20Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-trusty/kie-pmml-compiler/kie-pmml-compiler-commons/src/main/java/org/kie/pmml/compiler/commons/factories/KiePMMLPredicateFactory.java", "diffHunk": "@@ -0,0 +1,403 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.compiler.commons.factories;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\n+import com.github.javaparser.ast.stmt.ExpressionStmt;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import org.dmg.pmml.Array;\n+import org.dmg.pmml.CompoundPredicate;\n+import org.dmg.pmml.DataDictionary;\n+import org.dmg.pmml.DataField;\n+import org.dmg.pmml.DataType;\n+import org.dmg.pmml.False;\n+import org.dmg.pmml.Predicate;\n+import org.dmg.pmml.SimplePredicate;\n+import org.dmg.pmml.SimpleSetPredicate;\n+import org.dmg.pmml.True;\n+import org.kie.pmml.commons.exceptions.KiePMMLException;\n+import org.kie.pmml.commons.exceptions.KiePMMLInternalException;\n+import org.kie.pmml.commons.model.enums.ARRAY_TYPE;\n+import org.kie.pmml.commons.model.enums.BOOLEAN_OPERATOR;\n+import org.kie.pmml.commons.model.enums.DATA_TYPE;\n+import org.kie.pmml.commons.model.enums.IN_NOTIN;\n+import org.kie.pmml.commons.model.enums.OPERATOR;\n+import org.kie.pmml.commons.model.predicates.KiePMMLCompoundPredicate;\n+import org.kie.pmml.commons.model.predicates.KiePMMLFalsePredicate;\n+import org.kie.pmml.commons.model.predicates.KiePMMLPredicate;\n+import org.kie.pmml.commons.model.predicates.KiePMMLSimplePredicate;\n+import org.kie.pmml.commons.model.predicates.KiePMMLSimpleSetPredicate;\n+import org.kie.pmml.commons.model.predicates.KiePMMLTruePredicate;\n+import org.kie.pmml.compiler.commons.utils.CommonCodegenUtils;\n+import org.kie.pmml.compiler.commons.utils.JavaParserUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.javaparser.StaticJavaParser.parseClassOrInterfaceType;\n+import static org.kie.pmml.commons.Constants.MISSING_DEFAULT_CONSTRUCTOR;\n+import static org.kie.pmml.commons.Constants.MISSING_VARIABLE_IN_BODY;\n+import static org.kie.pmml.commons.utils.KiePMMLModelUtils.getSanitizedClassName;\n+import static org.kie.pmml.commons.utils.KiePMMLModelUtils.getSanitizedPackageName;\n+import static org.kie.pmml.compiler.commons.utils.JavaParserUtils.MAIN_CLASS_NOT_FOUND;\n+import static org.kie.pmml.compiler.commons.utils.JavaParserUtils.getFullClassName;\n+import static org.kie.pmml.compiler.commons.utils.KiePMMLModelFactoryUtils.setConstructorSuperNameInvocation;\n+\n+public class KiePMMLPredicateFactory {\n+\n+    static final String KIE_PMML_SIMPLE_PREDICATE_TEMPLATE_JAVA = \"KiePMMLSimplePredicateTemplate.tmpl\";\n+    static final String KIE_PMML_SIMPLE_PREDICATE_TEMPLATE = \"KiePMMLSimplePredicateTemplate\";\n+    static final String KIE_PMML_SIMPLE_SET_PREDICATE_TEMPLATE_JAVA = \"KiePMMLSimpleSetPredicateTemplate.tmpl\";\n+    static final String KIE_PMML_SIMPLE_SET_PREDICATE_TEMPLATE = \"KiePMMLSimpleSetPredicateTemplate\";\n+    static final String KIE_PMML_COMPOUND_PREDICATE_TEMPLATE_JAVA = \"KiePMMLCompoundPredicateTemplate.tmpl\";\n+    static final String KIE_PMML_COMPOUND_PREDICATE_TEMPLATE = \"KiePMMLCompoundPredicateTemplate\";\n+    static final String KIE_PMML_TRUE_PREDICATE_TEMPLATE_JAVA = \"KiePMMLTruePredicateTemplate.tmpl\";\n+    static final String KIE_PMML_TRUE_PREDICATE_TEMPLATE = \"KiePMMLTruePredicateTemplate\";\n+    static final String KIE_PMML_FALSE_PREDICATE_TEMPLATE_JAVA = \"KiePMMLFalsePredicateTemplate.tmpl\";\n+    static final String KIE_PMML_FALSE_PREDICATE_TEMPLATE = \"KiePMMLFalsePredicateTemplate\";\n+    private static final Logger logger = LoggerFactory.getLogger(KiePMMLPredicateFactory.class.getName());\n+\n+    private KiePMMLPredicateFactory() {\n+    }\n+\n+    public static List<KiePMMLPredicate> getPredicates(List<Predicate> predicates, DataDictionary dataDictionary) {\n+        logger.info(\"getPredicates {}\", predicates);\n+        return predicates.stream().map(predicate -> getPredicate(predicate, dataDictionary)).collect(Collectors.toList());\n+    }\n+\n+    public static KiePMMLPredicate getPredicate(Predicate predicate, DataDictionary dataDictionary) {\n+        logger.info(\"getPredicate {}\", predicate);\n+        if (predicate instanceof SimplePredicate) {\n+            final DataType dataType = dataDictionary.getDataFields().stream()\n+                    .filter(dataField -> dataField.getName().getValue().equals(((SimplePredicate) predicate).getField().getValue()))\n+                    .map(DataField::getDataType)\n+                    .findFirst()\n+                    .orElseThrow(() -> new KiePMMLException(\"Failed to find DataField for predicate \" + ((SimplePredicate) predicate).getField().getValue()));\n+            return getKiePMMLSimplePredicate((SimplePredicate) predicate, dataType);\n+        } else if (predicate instanceof SimpleSetPredicate) {\n+            return getKiePMMLSimpleSetPredicate((SimpleSetPredicate) predicate);\n+        } else if (predicate instanceof CompoundPredicate) {\n+            return getKiePMMLCompoundPredicate((CompoundPredicate) predicate, dataDictionary);\n+        } else if (predicate instanceof True) {\n+            return getKiePMMLTruePredicate();\n+        } else if (predicate instanceof False) {\n+            return getKiePMMLFalsePredicate();\n+        } else {\n+            throw new KiePMMLException(\"Predicate of type \" + predicate.getClass().getName() + \" not managed, yet\");\n+        }\n+    }\n+\n+    public static KiePMMLSimplePredicate getKiePMMLSimplePredicate(SimplePredicate predicate, DataType dataType) {\n+        return KiePMMLSimplePredicate.builder(predicate.getField().getValue(), Collections.emptyList(),\n+                                              OPERATOR.byName(predicate.getOperator().value()))\n+                .withValue(getActualValue(predicate.getValue(), dataType))\n+                .build();\n+    }\n+\n+    public static KiePMMLSimpleSetPredicate getKiePMMLSimpleSetPredicate(SimpleSetPredicate predicate) {\n+        List<Object> values = getObjectsFromArray(predicate.getArray());\n+        return KiePMMLSimpleSetPredicate.builder(predicate.getField().getValue(),\n+                                                 Collections.emptyList(),\n+                                                 ARRAY_TYPE.byName(predicate.getArray().getType().value()),\n+                                                 IN_NOTIN.byName(predicate.getBooleanOperator().value()))\n+                .withValues(values)\n+                .build();\n+    }\n+\n+    public static KiePMMLCompoundPredicate getKiePMMLCompoundPredicate(CompoundPredicate predicate,\n+                                                                       DataDictionary dataDictionary) {\n+        return KiePMMLCompoundPredicate.builder(Collections.emptyList(),\n+                                                BOOLEAN_OPERATOR.byName(predicate.getBooleanOperator().value()))\n+                .withKiePMMLPredicates(getPredicates(predicate.getPredicates(), dataDictionary))\n+                .build();\n+    }\n+\n+    public static KiePMMLTruePredicate getKiePMMLTruePredicate() {\n+        return KiePMMLTruePredicate.builder(Collections.emptyList())\n+                .build();\n+    }\n+\n+    public static KiePMMLFalsePredicate getKiePMMLFalsePredicate() {\n+        return KiePMMLFalsePredicate.builder(Collections.emptyList())\n+                .build();\n+    }\n+\n+    public static Map<String, String> getPredicateSourcesMap(final KiePMMLPredicate kiePMMLPredicate,\n+                                                             final String packageName) {\n+        logger.info(\"getPredicateSourcesMap {}\", kiePMMLPredicate);\n+        if (kiePMMLPredicate instanceof KiePMMLSimplePredicate) {\n+            return getKiePMMLSimplePredicateSourcesMap((KiePMMLSimplePredicate) kiePMMLPredicate, packageName);\n+        } else if (kiePMMLPredicate instanceof KiePMMLSimpleSetPredicate) {\n+            return getKiePMMLSimpleSetPredicateSourcesMap((KiePMMLSimpleSetPredicate) kiePMMLPredicate, packageName);\n+        } else if (kiePMMLPredicate instanceof KiePMMLCompoundPredicate) {\n+            return getKiePMMLCompoundPredicateSourcesMap((KiePMMLCompoundPredicate) kiePMMLPredicate, packageName);\n+        } else if (kiePMMLPredicate instanceof KiePMMLTruePredicate) {\n+            return getKiePMMLTruePredicateSourcesMap((KiePMMLTruePredicate) kiePMMLPredicate, packageName);\n+        } else if (kiePMMLPredicate instanceof KiePMMLFalsePredicate) {\n+            return getKiePMMLFalsePredicateSourcesMap((KiePMMLFalsePredicate) kiePMMLPredicate, packageName);\n+        } else {\n+            throw new KiePMMLException(\"Predicate of type \" + kiePMMLPredicate.getClass().getName() + \" not managed, \" +\n+                                               \"yet\");\n+        }\n+    }\n+\n+    static Map<String, String> getKiePMMLSimplePredicateSourcesMap(final KiePMMLSimplePredicate kiePMMLSimplePredicate, final String packageName) {\n+        String className = getSanitizedClassName(kiePMMLSimplePredicate.getName());\n+        CompilationUnit cloneCU = JavaParserUtils.getKiePMMLModelCompilationUnit(className, packageName,\n+                                                                                 KIE_PMML_SIMPLE_PREDICATE_TEMPLATE_JAVA, KIE_PMML_SIMPLE_PREDICATE_TEMPLATE);\n+        ClassOrInterfaceDeclaration predicateTemplate = cloneCU.getClassByName(className)\n+                .orElseThrow(() -> new KiePMMLException(MAIN_CLASS_NOT_FOUND + \": \" + className));\n+        final ConstructorDeclaration constructorDeclaration = predicateTemplate.getDefaultConstructor()\n+                .orElseThrow(() -> new KiePMMLInternalException(String.format(MISSING_DEFAULT_CONSTRUCTOR,\n+                                                                              predicateTemplate.getName())));\n+        setSimplePredicateConstructor(className,\n+                                      kiePMMLSimplePredicate.getName(),\n+                                      constructorDeclaration,\n+                                      kiePMMLSimplePredicate.getOperator(),\n+                                      kiePMMLSimplePredicate.getValue());\n+        return Collections.singletonMap(getFullClassName(cloneCU), cloneCU.toString());\n+    }\n+\n+    static Map<String, String> getKiePMMLSimpleSetPredicateSourcesMap(final KiePMMLSimpleSetPredicate kiePMMLSimpleSetPredicate,\n+                                                                      final String packageName) {\n+        String className = getSanitizedClassName(kiePMMLSimpleSetPredicate.getName());\n+        CompilationUnit cloneCU = JavaParserUtils.getKiePMMLModelCompilationUnit(className, packageName,\n+                                                                                 KIE_PMML_SIMPLE_SET_PREDICATE_TEMPLATE_JAVA, KIE_PMML_SIMPLE_SET_PREDICATE_TEMPLATE);\n+        ClassOrInterfaceDeclaration predicateTemplate = cloneCU.getClassByName(className)\n+                .orElseThrow(() -> new KiePMMLException(MAIN_CLASS_NOT_FOUND + \": \" + className));\n+        final ConstructorDeclaration constructorDeclaration = predicateTemplate.getDefaultConstructor()\n+                .orElseThrow(() -> new KiePMMLInternalException(String.format(MISSING_DEFAULT_CONSTRUCTOR,\n+                                                                              predicateTemplate.getName())));\n+        setSimpleSetPredicateConstructor(className,\n+                                         kiePMMLSimpleSetPredicate.getName(),\n+                                         constructorDeclaration,\n+                                         kiePMMLSimpleSetPredicate.getArrayType(),\n+                                         kiePMMLSimpleSetPredicate.getInNotIn(),\n+                                         kiePMMLSimpleSetPredicate.getValues());\n+        return Collections.singletonMap(getFullClassName(cloneCU), cloneCU.toString());\n+    }\n+\n+    static Map<String, String> getKiePMMLCompoundPredicateSourcesMap(final KiePMMLCompoundPredicate kiePMMLCompoundPredicate, final String packageName) {\n+        String className = getSanitizedClassName(kiePMMLCompoundPredicate.getName());\n+        final Map<String, String> toReturn = new HashMap<>();\n+        if (kiePMMLCompoundPredicate.getKiePMMLPredicates() != null) {\n+            kiePMMLCompoundPredicate.getKiePMMLPredicates().forEach(kiePMMLPredicate -> toReturn.putAll(getPredicateSourcesMap(kiePMMLPredicate, packageName)));\n+        }\n+        CompilationUnit cloneCU = JavaParserUtils.getKiePMMLModelCompilationUnit(className, packageName,\n+                                                                                 KIE_PMML_COMPOUND_PREDICATE_TEMPLATE_JAVA, KIE_PMML_COMPOUND_PREDICATE_TEMPLATE);\n+        ClassOrInterfaceDeclaration predicateTemplate = cloneCU.getClassByName(className)\n+                .orElseThrow(() -> new KiePMMLException(MAIN_CLASS_NOT_FOUND + \": \" + className));\n+        final ConstructorDeclaration constructorDeclaration = predicateTemplate.getDefaultConstructor()\n+                .orElseThrow(() -> new KiePMMLInternalException(String.format(MISSING_DEFAULT_CONSTRUCTOR,\n+                                                                              predicateTemplate.getName())));\n+        Set<String> predicatesClasses = new HashSet<>();\n+        if (kiePMMLCompoundPredicate.getKiePMMLPredicates() != null) {\n+            predicatesClasses = kiePMMLCompoundPredicate.getKiePMMLPredicates().stream()\n+                    .map(predicate ->  packageName + \".\" + getSanitizedClassName(predicate.getName()))\n+                    .collect(Collectors.toSet());\n+        }\n+        if (!toReturn.keySet().containsAll(predicatesClasses)) {\n+            String missingClasses = String.join(\", \", predicatesClasses);\n+            throw new KiePMMLException(\"Expected generated class \" + missingClasses + \" not found\");\n+        }\n+        setCompoundPredicateConstructor(className,\n+                                        kiePMMLCompoundPredicate.getName(),\n+                                        constructorDeclaration,\n+                                        kiePMMLCompoundPredicate.getBooleanOperator(),\n+                                        predicatesClasses);\n+        toReturn.put(getFullClassName(cloneCU), cloneCU.toString());\n+        return toReturn;\n+    }\n+\n+    static Map<String, String> getKiePMMLTruePredicateSourcesMap(final KiePMMLTruePredicate kiePMMLTruePredicate,\n+                                                                 final String packageName) {\n+        String className = getSanitizedClassName(kiePMMLTruePredicate.getName());\n+        CompilationUnit cloneCU = JavaParserUtils.getKiePMMLModelCompilationUnit(className, packageName,\n+                                                                                 KIE_PMML_TRUE_PREDICATE_TEMPLATE_JAVA, KIE_PMML_TRUE_PREDICATE_TEMPLATE);\n+        ClassOrInterfaceDeclaration predicateTemplate = cloneCU.getClassByName(className)\n+                .orElseThrow(() -> new KiePMMLException(MAIN_CLASS_NOT_FOUND + \": \" + className));\n+        final ConstructorDeclaration constructorDeclaration = predicateTemplate.getDefaultConstructor()\n+                .orElseThrow(() -> new KiePMMLInternalException(String.format(\n+                        MISSING_DEFAULT_CONSTRUCTOR, predicateTemplate.getName())));\n+        setTrueFalsePredicateConstructor(className,\n+                                         kiePMMLTruePredicate.getName(),\n+                                         constructorDeclaration);\n+        return Collections.singletonMap(getFullClassName(cloneCU), cloneCU.toString());\n+    }\n+\n+    static Map<String, String> getKiePMMLFalsePredicateSourcesMap(final KiePMMLFalsePredicate kiePMMLFalsePredicate,\n+                                                                  final String packageName) {\n+        String className = getSanitizedClassName(kiePMMLFalsePredicate.getName());\n+        CompilationUnit cloneCU = JavaParserUtils.getKiePMMLModelCompilationUnit(className, packageName,\n+                                                                                 KIE_PMML_FALSE_PREDICATE_TEMPLATE_JAVA, KIE_PMML_FALSE_PREDICATE_TEMPLATE);\n+        ClassOrInterfaceDeclaration predicateTemplate = cloneCU.getClassByName(className)\n+                .orElseThrow(() -> new KiePMMLException(MAIN_CLASS_NOT_FOUND + \": \" + className));\n+        final ConstructorDeclaration constructorDeclaration = predicateTemplate.getDefaultConstructor()\n+                .orElseThrow(() -> new KiePMMLInternalException(String.format(\n+                        MISSING_DEFAULT_CONSTRUCTOR, predicateTemplate.getName())));\n+        setTrueFalsePredicateConstructor(className,\n+                                         kiePMMLFalsePredicate.getName(),\n+                                         constructorDeclaration);\n+        return Collections.singletonMap(getFullClassName(cloneCU), cloneCU.toString());\n+    }\n+\n+    static void setSimplePredicateConstructor(final String generatedClassName,\n+                                              final String predicateName,\n+                                              final ConstructorDeclaration constructorDeclaration,\n+                                              final OPERATOR operator,\n+                                              final Object value) {\n+        setConstructorSuperNameInvocation(generatedClassName, constructorDeclaration, predicateName);\n+        final BlockStmt body = constructorDeclaration.getBody();\n+        body.getStatements().iterator().forEachRemaining(statement -> {\n+            if (statement instanceof ExplicitConstructorInvocationStmt) {\n+                ExplicitConstructorInvocationStmt superStatement = (ExplicitConstructorInvocationStmt) statement;\n+                NameExpr nameExpr = (NameExpr) superStatement.getArgument(2);\n+                nameExpr.setName(operator.getClass().getCanonicalName() + \".\" + operator.name());\n+            }\n+        });\n+        Expression expression = value instanceof String ? new StringLiteralExpr((String) value) : new NameExpr(value.toString());\n+        CommonCodegenUtils.setAssignExpressionValue(body, \"value\", expression);\n+    }\n+\n+    static void setSimpleSetPredicateConstructor(final String generatedClassName,\n+                                                 final String predicateName,\n+                                                 final ConstructorDeclaration constructorDeclaration,\n+                                                 final ARRAY_TYPE arrayType,\n+                                                 final IN_NOTIN inNotIn,\n+                                                 final List<Object> values) {\n+        setConstructorSuperNameInvocation(generatedClassName, constructorDeclaration, predicateName);\n+        final BlockStmt body = constructorDeclaration.getBody();\n+        body.getStatements().iterator().forEachRemaining(statement -> {\n+            if (statement instanceof ExplicitConstructorInvocationStmt) {\n+                ExplicitConstructorInvocationStmt superStatement = (ExplicitConstructorInvocationStmt) statement;\n+                NameExpr nameExpr = (NameExpr) superStatement.getArgument(2);\n+                nameExpr.setName(arrayType.getClass().getCanonicalName() + \".\" + arrayType.name());\n+                nameExpr = (NameExpr) superStatement.getArgument(3);\n+                nameExpr.setName(inNotIn.getClass().getCanonicalName() + \".\" + inNotIn.name());\n+            }\n+        });\n+        AssignExpr assignExpr = CommonCodegenUtils\n+                .getAssignExpression(body, \"values\")\n+                .orElseThrow(() -> new KiePMMLException(String.format(MISSING_VARIABLE_IN_BODY, \"values\", body)));\n+        ClassOrInterfaceType arrayClass = parseClassOrInterfaceType(ArrayList.class.getName());\n+        ObjectCreationExpr objectCreationExpr = new ObjectCreationExpr();\n+        objectCreationExpr.setType(arrayClass);\n+        assignExpr.setValue(objectCreationExpr);\n+        for (Object value : values) {\n+            Expression valueExpression;\n+            if (arrayType == ARRAY_TYPE.STRING) {\n+                valueExpression = new StringLiteralExpr(value.toString());\n+            } else {\n+                valueExpression = new NameExpr(value.toString());\n+            }\n+            NodeList<Expression> arguments = NodeList.nodeList(valueExpression);\n+            MethodCallExpr methodCallExpr = new MethodCallExpr();\n+            methodCallExpr.setScope(assignExpr.getTarget().asNameExpr());\n+            methodCallExpr.setName(\"add\");\n+            methodCallExpr.setArguments(arguments);\n+            ExpressionStmt expressionStmt = new ExpressionStmt();\n+            expressionStmt.setExpression(methodCallExpr);\n+            body.addStatement(expressionStmt);\n+        }\n+    }\n+\n+    static void setCompoundPredicateConstructor(final String generatedClassName,\n+                                                final String predicateName,\n+                                                final ConstructorDeclaration constructorDeclaration,\n+                                                final BOOLEAN_OPERATOR booleanOperator,\n+                                                final Set<String> predicatesClasses) {\n+        setConstructorSuperNameInvocation(generatedClassName, constructorDeclaration, predicateName);\n+        final BlockStmt body = constructorDeclaration.getBody();\n+        body.getStatements().iterator().forEachRemaining(statement -> {\n+            if (statement instanceof ExplicitConstructorInvocationStmt) {\n+                ExplicitConstructorInvocationStmt superStatement = (ExplicitConstructorInvocationStmt) statement;\n+                NameExpr nameExpr = (NameExpr) superStatement.getArgument(2);\n+                nameExpr.setName(booleanOperator.getClass().getCanonicalName() + \".\" + booleanOperator.name());\n+            }\n+        });\n+        AssignExpr assignExpr = CommonCodegenUtils\n+                .getAssignExpression(body, \"kiePMMLPredicates\")\n+                .orElseThrow(() -> new KiePMMLException(String.format(MISSING_VARIABLE_IN_BODY, \"kiePMMLPredicates\", body)));\n+        ClassOrInterfaceType arrayClass = parseClassOrInterfaceType(ArrayList.class.getName());\n+        ObjectCreationExpr objectCreationExpr = new ObjectCreationExpr();\n+        objectCreationExpr.setType(arrayClass);\n+        assignExpr.setValue(objectCreationExpr);\n+        for (String predicateClass : predicatesClasses) {\n+            ClassOrInterfaceType kiePMMLPredicateClass = parseClassOrInterfaceType(predicateClass);\n+            objectCreationExpr = new ObjectCreationExpr();\n+            objectCreationExpr.setType(kiePMMLPredicateClass);\n+            NodeList<Expression> arguments = NodeList.nodeList(objectCreationExpr);\n+            MethodCallExpr methodCallExpr = new MethodCallExpr();\n+            methodCallExpr.setScope(assignExpr.getTarget().asNameExpr());\n+            methodCallExpr.setName(\"add\");\n+            methodCallExpr.setArguments(arguments);\n+            ExpressionStmt expressionStmt = new ExpressionStmt();\n+            expressionStmt.setExpression(methodCallExpr);\n+            body.addStatement(expressionStmt);\n+        }\n+    }\n+\n+    static void setTrueFalsePredicateConstructor(final String generatedClassName,\n+                                                 final String predicateName,\n+                                                 final ConstructorDeclaration constructorDeclaration) {\n+        setConstructorSuperNameInvocation(generatedClassName, constructorDeclaration, predicateName);\n+    }\n+\n+    static List<Object> getObjectsFromArray(Array source) {\n+        Array.Type type = source.getType();\n+        List<Object> toReturn = new ArrayList<>();\n+        String stringValue = (String) source.getValue();\n+        String[] valuesArray = stringValue.split(\" \");\n+        for (String s : valuesArray) {\n+            switch (type) {\n+                case INT:\n+                    toReturn.add(Integer.valueOf(s));\n+                    break;\n+                case STRING:\n+                    toReturn.add(s);\n+                    break;\n+                case REAL:\n+                    toReturn.add(Double.valueOf(s));\n+                    break;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM3MDEzNg=="}, "originalCommit": {"oid": "52801990de7002c74109aea1c61dd73463246240"}, "originalPosition": 393}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2434, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}