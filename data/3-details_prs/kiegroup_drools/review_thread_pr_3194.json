{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEwODU4MzM3", "number": 3194, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwODoxODo0M1rOEysiTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNjoxNzoxNlrOEy5FlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNTkzOTMyOnYy", "diffSide": "RIGHT", "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/KiePackagesBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwODoxODo0M1rOHpecIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwODoxODo0M1rOHpecIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI1MjM4NA==", "bodyText": "Is it possible to wrap this logic in a method to improve readability?\n/**\n * When rule has only AND as top level, it is possible to precalculate requiredDeclarations as optimization \n */\nprivate Declaration[] getRequiredDeclarationsIfPossible( RuleContext ctx, Consequence consequence, String name ) {\n        boolean ruleHasFirstLevelOr = ruleHasFirstLevelOr(ctx.getRule());\n        Variable[] consequenceVars = consequence.getDeclarations();\n        String[] requiredDeclarationNames = new String[consequenceVars.length];\n        Declaration[] requiredDeclarations = ruleHasFirstLevelOr ? null : new Declaration[consequenceVars.length];\n        for (int i = 0; i < consequenceVars.length; i++) {\n            requiredDeclarationNames[i] = consequenceVars[i].getName();\n            if (!ruleHasFirstLevelOr) {\n                requiredDeclarations[i] = ctx.getRule().getDeclaration( requiredDeclarationNames[i] );\n            }\n        }\n\n        ctx.getRule().setRequiredDeclarationsForConsequence( name, requiredDeclarationNames );\n        return requiredDeclarations;\n}", "url": "https://github.com/kiegroup/drools/pull/3194#discussion_r513252384", "createdAt": "2020-10-28T08:18:43Z", "author": {"login": "danielezonca"}, "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/KiePackagesBuilder.java", "diffHunk": "@@ -375,30 +375,50 @@ private void addQueryPattern( Query query, QueryImpl queryImpl, RuleContext ctx\n         queryImpl.setParameters( declarations );\n     }\n \n-    private void processConsequences( RuleContext ctx, Rule rule ) {\n-        for (Map.Entry<String, Consequence> entry : rule.getConsequences().entrySet()) {\n+    private void processConsequences( RuleContext ctx, Map<String, Consequence> consequences ) {\n+        for (Map.Entry<String, Consequence> entry : consequences.entrySet()) {\n             processConsequence( ctx, entry.getValue(), entry.getKey() );\n         }\n     }\n \n     private void processConsequence( RuleContext ctx, Consequence consequence, String name ) {\n+        boolean ruleHasFirstLevelOr = ruleHasFirstLevelOr(ctx.getRule());\n+        Variable[] consequenceVars = consequence.getDeclarations();\n+        String[] requiredDeclarationNames = new String[consequenceVars.length];\n+        Declaration[] requiredDeclarations = ruleHasFirstLevelOr ? null : new Declaration[consequenceVars.length];\n+        for (int i = 0; i < consequenceVars.length; i++) {\n+            requiredDeclarationNames[i] = consequenceVars[i].getName();\n+            if (!ruleHasFirstLevelOr) {\n+                requiredDeclarations[i] = ctx.getRule().getDeclaration( requiredDeclarationNames[i] );\n+            }\n+        }\n+\n+        ctx.getRule().setRequiredDeclarationsForConsequence( name, requiredDeclarationNames );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d887b0a52f53e7a5e4c1256388dc8eafca60a22d"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNTk0OTA1OnYy", "diffSide": "RIGHT", "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/consequence/LambdaConsequence.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwODoyMToxNFrOHpeh1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwODoyMToxNFrOHpeh1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI1Mzg0Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } else {\n          \n          \n            \n                    // declarations is not null when first level rule is AND so it is possible to calculate them upfront\n          \n          \n            \n                    } else {", "url": "https://github.com/kiegroup/drools/pull/3194#discussion_r513253846", "createdAt": "2020-10-28T08:21:14Z", "author": {"login": "danielezonca"}, "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/consequence/LambdaConsequence.java", "diffHunk": "@@ -43,23 +52,28 @@ public String getName() {\n \n     @Override\n     public void evaluate( KnowledgeHelper knowledgeHelper, WorkingMemory workingMemory ) throws Exception {\n-        Declaration[] declarations = ((RuleTerminalNode)knowledgeHelper.getMatch().getTuple().getTupleSink()).getRequiredDeclarations();\n-        Object[] facts = declarationsToFacts( knowledgeHelper, workingMemory, knowledgeHelper.getTuple(), declarations, consequence.getVariables(), consequence.isUsingDrools() );\n+        Object[] facts;\n+        if ( this.declarations == null ) {\n+            Declaration[] declarations = (( RuleTerminalNode ) knowledgeHelper.getMatch().getTuple().getTupleSink()).getRequiredDeclarations();\n+            facts = declarationsToFacts( knowledgeHelper, ( InternalWorkingMemory ) workingMemory, knowledgeHelper.getTuple(), declarations, consequence.getVariables(), consequence.isUsingDrools() );\n+        } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d887b0a52f53e7a5e4c1256388dc8eafca60a22d"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNTk1MjMxOnYy", "diffSide": "RIGHT", "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/consequence/LambdaConsequence.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwODoyMjowN1rOHpej0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwODozMjo0OFrOHpe70g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI1NDM1NQ==", "bodyText": "Is this an additional/unrelated bugfix/improvement?", "url": "https://github.com/kiegroup/drools/pull/3194#discussion_r513254355", "createdAt": "2020-10-28T08:22:07Z", "author": {"login": "danielezonca"}, "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/consequence/LambdaConsequence.java", "diffHunk": "@@ -69,19 +83,184 @@ public void evaluate( KnowledgeHelper knowledgeHelper, WorkingMemory workingMemo\n             if ( var.isFact() ) {\n                 Declaration declaration = declarations[declrCounter++];\n                 InternalFactHandle fh = getOriginalFactHandle( tuple.get( declaration ) );\n-                if (useDrools) {\n-                    ( (DroolsImpl) facts[0] ).registerFactHandle( fh );\n+                if ( useDrools ) {\n+                    (( DroolsImpl ) facts[0]).registerFactHandle( fh );\n                 }\n-                facts[factsOffset++] = declaration.getValue( (InternalWorkingMemory ) workingMemory, fh.getObject() );\n+                facts[factsOffset++] = declaration.getValue( workingMemory, fh.getObject() );\n             } else {\n                 facts[factsOffset++] = workingMemory.getGlobal( var.getName() );\n             }\n         }\n         return facts;\n     }\n \n-    private static InternalFactHandle getOriginalFactHandle(InternalFactHandle handle) {\n-        InternalFactHandle linkedFH = handle.isEvent() ? ((EventFactHandle )handle).getLinkedFactHandle() : null;\n+    private static InternalFactHandle getOriginalFactHandle( InternalFactHandle handle ) {\n+        if ( !handle.isEvent() ) {\n+            return handle;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d887b0a52f53e7a5e4c1256388dc8eafca60a22d"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI2MDQ5OA==", "bodyText": "If look at the old code\n    private static InternalFactHandle getOriginalFactHandle( InternalFactHandle handle ) {\n        InternalFactHandle linkedFH = handle.isEvent() ? ((EventFactHandle )handle).getLinkedFactHandle() : null;\n        return linkedFH != null ? linkedFH : handle;\n    }\n\n\nand at the new one\n    private static InternalFactHandle getOriginalFactHandle( InternalFactHandle handle ) {\n        if ( !handle.isEvent() ) {\n            return handle;\n        }\n        InternalFactHandle linkedFH = (( EventFactHandle ) handle).getLinkedFactHandle();\n        return linkedFH != null ? linkedFH : handle;\n    }\n\nyou will realize that the 2 codes are functionally identical: if the handle is not an event nothing has to be done and the handle can be used as it is. I just wanted to make this thing more explicit and avoid a useless second null check in that case.", "url": "https://github.com/kiegroup/drools/pull/3194#discussion_r513260498", "createdAt": "2020-10-28T08:32:48Z", "author": {"login": "mariofusco"}, "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/consequence/LambdaConsequence.java", "diffHunk": "@@ -69,19 +83,184 @@ public void evaluate( KnowledgeHelper knowledgeHelper, WorkingMemory workingMemo\n             if ( var.isFact() ) {\n                 Declaration declaration = declarations[declrCounter++];\n                 InternalFactHandle fh = getOriginalFactHandle( tuple.get( declaration ) );\n-                if (useDrools) {\n-                    ( (DroolsImpl) facts[0] ).registerFactHandle( fh );\n+                if ( useDrools ) {\n+                    (( DroolsImpl ) facts[0]).registerFactHandle( fh );\n                 }\n-                facts[factsOffset++] = declaration.getValue( (InternalWorkingMemory ) workingMemory, fh.getObject() );\n+                facts[factsOffset++] = declaration.getValue( workingMemory, fh.getObject() );\n             } else {\n                 facts[factsOffset++] = workingMemory.getGlobal( var.getName() );\n             }\n         }\n         return facts;\n     }\n \n-    private static InternalFactHandle getOriginalFactHandle(InternalFactHandle handle) {\n-        InternalFactHandle linkedFH = handle.isEvent() ? ((EventFactHandle )handle).getLinkedFactHandle() : null;\n+    private static InternalFactHandle getOriginalFactHandle( InternalFactHandle handle ) {\n+        if ( !handle.isEvent() ) {\n+            return handle;\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI1NDM1NQ=="}, "originalCommit": {"oid": "d887b0a52f53e7a5e4c1256388dc8eafca60a22d"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNzk1MjUxOnYy", "diffSide": "RIGHT", "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/KiePackagesBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNjowODoxMFrOHpx5QQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNjowODoxMFrOHpx5QQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU3MTEzNw==", "bodyText": "Can you please first introduce the optimization and then explain why it is not applicable to OR? :)", "url": "https://github.com/kiegroup/drools/pull/3194#discussion_r513571137", "createdAt": "2020-10-28T16:08:10Z", "author": {"login": "danielezonca"}, "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/KiePackagesBuilder.java", "diffHunk": "@@ -375,30 +375,54 @@ private void addQueryPattern( Query query, QueryImpl queryImpl, RuleContext ctx\n         queryImpl.setParameters( declarations );\n     }\n \n-    private void processConsequences( RuleContext ctx, Rule rule ) {\n-        for (Map.Entry<String, Consequence> entry : rule.getConsequences().entrySet()) {\n+    private void processConsequences( RuleContext ctx, Map<String, Consequence> consequences ) {\n+        for (Map.Entry<String, Consequence> entry : consequences.entrySet()) {\n             processConsequence( ctx, entry.getValue(), entry.getKey() );\n         }\n     }\n \n     private void processConsequence( RuleContext ctx, Consequence consequence, String name ) {\n+        // If there's an OR in the rule the fired tuple hasn't fixed structure and size because it dependens\n+        // on which branch of the OR gets activated. In this case no optimization is possible and it's usless\n+        // to precalculate the declartions at compile time.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e28754f3289232005c0aba1ef3d96ed59612112"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNzk5NTcyOnYy", "diffSide": "RIGHT", "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/consequence/LambdaConsequence.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNjoxNzoxNlrOHpyU9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNjoxNzoxNlrOHpyU9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU3ODIyOA==", "bodyText": "Can you refer the optimization here too (in the future we will not have the PR to see the whole code together :) )?", "url": "https://github.com/kiegroup/drools/pull/3194#discussion_r513578228", "createdAt": "2020-10-28T16:17:16Z", "author": {"login": "danielezonca"}, "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/consequence/LambdaConsequence.java", "diffHunk": "@@ -69,19 +84,196 @@ public void evaluate( KnowledgeHelper knowledgeHelper, WorkingMemory workingMemo\n             if ( var.isFact() ) {\n                 Declaration declaration = declarations[declrCounter++];\n                 InternalFactHandle fh = getOriginalFactHandle( tuple.get( declaration ) );\n-                if (useDrools) {\n-                    ( (DroolsImpl) facts[0] ).registerFactHandle( fh );\n+                if ( useDrools ) {\n+                    (( DroolsImpl ) facts[0]).registerFactHandle( fh );\n                 }\n-                facts[factsOffset++] = declaration.getValue( (InternalWorkingMemory ) workingMemory, fh.getObject() );\n+                facts[factsOffset++] = declaration.getValue( workingMemory, fh.getObject() );\n             } else {\n                 facts[factsOffset++] = workingMemory.getGlobal( var.getName() );\n             }\n         }\n         return facts;\n     }\n \n-    private static InternalFactHandle getOriginalFactHandle(InternalFactHandle handle) {\n-        InternalFactHandle linkedFH = handle.isEvent() ? ((EventFactHandle )handle).getLinkedFactHandle() : null;\n+    private static InternalFactHandle getOriginalFactHandle( InternalFactHandle handle ) {\n+        if ( !handle.isEvent() ) {\n+            return handle;\n+        }\n+        InternalFactHandle linkedFH = (( EventFactHandle ) handle).getLinkedFactHandle();\n         return linkedFH != null ? linkedFH : handle;\n     }\n-}\n+\n+    private Object[] fetchFacts( KnowledgeHelper knowledgeHelper, InternalWorkingMemory workingMemory ) {\n+        Tuple tuple = knowledgeHelper.getTuple();\n+        if (factSuppliers == null) {\n+            return initConsequence(knowledgeHelper, workingMemory, tuple);\n+        }\n+        Object[] facts = new Object[factSuppliers.length];\n+        for (int i = 0; i < facts.length; i++) {\n+            tuple = factSuppliers[i].get( facts, knowledgeHelper, workingMemory, tuple );\n+        }\n+        return facts;\n+    }\n+\n+    private Object[] initConsequence( KnowledgeHelper knowledgeHelper, InternalWorkingMemory workingMemory, Tuple tuple ) {\n+        Variable[] vars = consequence.getVariables();\n+        List<FactSupplier> factSuppliers = new ArrayList<>();\n+\n+        Object[] facts;\n+        int factsOffset = 0;\n+        if ( consequence.isUsingDrools() ) {\n+            factsOffset++;\n+            factSuppliers.add( DroolsImplSupplier.INSTANCE );\n+            facts = new Object[vars.length + 1];\n+            facts[0] = new DroolsImpl( knowledgeHelper, workingMemory );\n+        } else {\n+            facts = new Object[vars.length];\n+        }\n+\n+        int declrCounter = 0;\n+        for (Variable var : vars) {\n+            if ( var.isFact() ) {\n+                factSuppliers.add( new TupleFactSupplier(factsOffset, declarations[declrCounter++], consequence.isUsingDrools()) );\n+            } else {\n+                facts[factsOffset] = workingMemory.getGlobal( var.getName() );\n+                factSuppliers.add( new GlobalSupplier(factsOffset, var.getName()) );\n+            }\n+            factsOffset++;\n+        }\n+\n+        // At this point the FactSuppliers (each of them supplying a single argument to be passed to the consequence)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e28754f3289232005c0aba1ef3d96ed59612112"}, "originalPosition": 131}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2258, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}