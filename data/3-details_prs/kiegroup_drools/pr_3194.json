{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEwODU4MzM3", "number": 3194, "title": "[DROOLS-5730] improve performances of arguments fetch in executable m\u2026", "bodyText": "", "createdAt": "2020-10-27T15:49:26Z", "url": "https://github.com/kiegroup/drools/pull/3194", "merged": true, "mergeCommit": {"oid": "959902347c7bb38f2767844d1f47a4fabbdb05f9"}, "closed": true, "closedAt": "2020-10-29T09:15:44Z", "author": {"login": "mariofusco"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdWqfbzgH2gAyNTEwODU4MzM3OjEwMWIyZjhlMDBmM2FlYmFiODljZTEwNGFjYjcyNjJkNDQ2ZWNiZjM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdXN3OngFqTUxOTQyNzM0OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "101b2f8e00f3aebab89ce104acb7262d446ecbf3", "author": {"user": {"login": "mariofusco", "name": "Mario Fusco"}}, "url": "https://github.com/kiegroup/drools/commit/101b2f8e00f3aebab89ce104acb7262d446ecbf3", "committedDate": "2020-10-27T15:13:55Z", "message": "[DROOLS-5730] improve performances of arguments fetch in executable model consequence"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d887b0a52f53e7a5e4c1256388dc8eafca60a22d", "author": {"user": {"login": "mariofusco", "name": "Mario Fusco"}}, "url": "https://github.com/kiegroup/drools/commit/d887b0a52f53e7a5e4c1256388dc8eafca60a22d", "committedDate": "2020-10-27T17:02:33Z", "message": "wip"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4NDEyMjg0", "url": "https://github.com/kiegroup/drools/pull/3194#pullrequestreview-518412284", "createdAt": "2020-10-28T08:18:43Z", "commit": {"oid": "d887b0a52f53e7a5e4c1256388dc8eafca60a22d"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwODoxODo0M1rOHpecIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwODoyMjowN1rOHpej0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI1MjM4NA==", "bodyText": "Is it possible to wrap this logic in a method to improve readability?\n/**\n * When rule has only AND as top level, it is possible to precalculate requiredDeclarations as optimization \n */\nprivate Declaration[] getRequiredDeclarationsIfPossible( RuleContext ctx, Consequence consequence, String name ) {\n        boolean ruleHasFirstLevelOr = ruleHasFirstLevelOr(ctx.getRule());\n        Variable[] consequenceVars = consequence.getDeclarations();\n        String[] requiredDeclarationNames = new String[consequenceVars.length];\n        Declaration[] requiredDeclarations = ruleHasFirstLevelOr ? null : new Declaration[consequenceVars.length];\n        for (int i = 0; i < consequenceVars.length; i++) {\n            requiredDeclarationNames[i] = consequenceVars[i].getName();\n            if (!ruleHasFirstLevelOr) {\n                requiredDeclarations[i] = ctx.getRule().getDeclaration( requiredDeclarationNames[i] );\n            }\n        }\n\n        ctx.getRule().setRequiredDeclarationsForConsequence( name, requiredDeclarationNames );\n        return requiredDeclarations;\n}", "url": "https://github.com/kiegroup/drools/pull/3194#discussion_r513252384", "createdAt": "2020-10-28T08:18:43Z", "author": {"login": "danielezonca"}, "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/KiePackagesBuilder.java", "diffHunk": "@@ -375,30 +375,50 @@ private void addQueryPattern( Query query, QueryImpl queryImpl, RuleContext ctx\n         queryImpl.setParameters( declarations );\n     }\n \n-    private void processConsequences( RuleContext ctx, Rule rule ) {\n-        for (Map.Entry<String, Consequence> entry : rule.getConsequences().entrySet()) {\n+    private void processConsequences( RuleContext ctx, Map<String, Consequence> consequences ) {\n+        for (Map.Entry<String, Consequence> entry : consequences.entrySet()) {\n             processConsequence( ctx, entry.getValue(), entry.getKey() );\n         }\n     }\n \n     private void processConsequence( RuleContext ctx, Consequence consequence, String name ) {\n+        boolean ruleHasFirstLevelOr = ruleHasFirstLevelOr(ctx.getRule());\n+        Variable[] consequenceVars = consequence.getDeclarations();\n+        String[] requiredDeclarationNames = new String[consequenceVars.length];\n+        Declaration[] requiredDeclarations = ruleHasFirstLevelOr ? null : new Declaration[consequenceVars.length];\n+        for (int i = 0; i < consequenceVars.length; i++) {\n+            requiredDeclarationNames[i] = consequenceVars[i].getName();\n+            if (!ruleHasFirstLevelOr) {\n+                requiredDeclarations[i] = ctx.getRule().getDeclaration( requiredDeclarationNames[i] );\n+            }\n+        }\n+\n+        ctx.getRule().setRequiredDeclarationsForConsequence( name, requiredDeclarationNames );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d887b0a52f53e7a5e4c1256388dc8eafca60a22d"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI1Mzg0Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } else {\n          \n          \n            \n                    // declarations is not null when first level rule is AND so it is possible to calculate them upfront\n          \n          \n            \n                    } else {", "url": "https://github.com/kiegroup/drools/pull/3194#discussion_r513253846", "createdAt": "2020-10-28T08:21:14Z", "author": {"login": "danielezonca"}, "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/consequence/LambdaConsequence.java", "diffHunk": "@@ -43,23 +52,28 @@ public String getName() {\n \n     @Override\n     public void evaluate( KnowledgeHelper knowledgeHelper, WorkingMemory workingMemory ) throws Exception {\n-        Declaration[] declarations = ((RuleTerminalNode)knowledgeHelper.getMatch().getTuple().getTupleSink()).getRequiredDeclarations();\n-        Object[] facts = declarationsToFacts( knowledgeHelper, workingMemory, knowledgeHelper.getTuple(), declarations, consequence.getVariables(), consequence.isUsingDrools() );\n+        Object[] facts;\n+        if ( this.declarations == null ) {\n+            Declaration[] declarations = (( RuleTerminalNode ) knowledgeHelper.getMatch().getTuple().getTupleSink()).getRequiredDeclarations();\n+            facts = declarationsToFacts( knowledgeHelper, ( InternalWorkingMemory ) workingMemory, knowledgeHelper.getTuple(), declarations, consequence.getVariables(), consequence.isUsingDrools() );\n+        } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d887b0a52f53e7a5e4c1256388dc8eafca60a22d"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI1NDM1NQ==", "bodyText": "Is this an additional/unrelated bugfix/improvement?", "url": "https://github.com/kiegroup/drools/pull/3194#discussion_r513254355", "createdAt": "2020-10-28T08:22:07Z", "author": {"login": "danielezonca"}, "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/consequence/LambdaConsequence.java", "diffHunk": "@@ -69,19 +83,184 @@ public void evaluate( KnowledgeHelper knowledgeHelper, WorkingMemory workingMemo\n             if ( var.isFact() ) {\n                 Declaration declaration = declarations[declrCounter++];\n                 InternalFactHandle fh = getOriginalFactHandle( tuple.get( declaration ) );\n-                if (useDrools) {\n-                    ( (DroolsImpl) facts[0] ).registerFactHandle( fh );\n+                if ( useDrools ) {\n+                    (( DroolsImpl ) facts[0]).registerFactHandle( fh );\n                 }\n-                facts[factsOffset++] = declaration.getValue( (InternalWorkingMemory ) workingMemory, fh.getObject() );\n+                facts[factsOffset++] = declaration.getValue( workingMemory, fh.getObject() );\n             } else {\n                 facts[factsOffset++] = workingMemory.getGlobal( var.getName() );\n             }\n         }\n         return facts;\n     }\n \n-    private static InternalFactHandle getOriginalFactHandle(InternalFactHandle handle) {\n-        InternalFactHandle linkedFH = handle.isEvent() ? ((EventFactHandle )handle).getLinkedFactHandle() : null;\n+    private static InternalFactHandle getOriginalFactHandle( InternalFactHandle handle ) {\n+        if ( !handle.isEvent() ) {\n+            return handle;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d887b0a52f53e7a5e4c1256388dc8eafca60a22d"}, "originalPosition": 85}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e28754f3289232005c0aba1ef3d96ed59612112", "author": {"user": {"login": "mariofusco", "name": "Mario Fusco"}}, "url": "https://github.com/kiegroup/drools/commit/3e28754f3289232005c0aba1ef3d96ed59612112", "committedDate": "2020-10-28T08:55:04Z", "message": "fix multithreading use of LambdaConsequence + add a few comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4NzkxNDMz", "url": "https://github.com/kiegroup/drools/pull/3194#pullrequestreview-518791433", "createdAt": "2020-10-28T15:28:57Z", "commit": {"oid": "3e28754f3289232005c0aba1ef3d96ed59612112"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4ODM1MDMx", "url": "https://github.com/kiegroup/drools/pull/3194#pullrequestreview-518835031", "createdAt": "2020-10-28T16:08:10Z", "commit": {"oid": "3e28754f3289232005c0aba1ef3d96ed59612112"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNjowODoxMFrOHpx5QQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNjoxNzoxNlrOHpyU9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU3MTEzNw==", "bodyText": "Can you please first introduce the optimization and then explain why it is not applicable to OR? :)", "url": "https://github.com/kiegroup/drools/pull/3194#discussion_r513571137", "createdAt": "2020-10-28T16:08:10Z", "author": {"login": "danielezonca"}, "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/KiePackagesBuilder.java", "diffHunk": "@@ -375,30 +375,54 @@ private void addQueryPattern( Query query, QueryImpl queryImpl, RuleContext ctx\n         queryImpl.setParameters( declarations );\n     }\n \n-    private void processConsequences( RuleContext ctx, Rule rule ) {\n-        for (Map.Entry<String, Consequence> entry : rule.getConsequences().entrySet()) {\n+    private void processConsequences( RuleContext ctx, Map<String, Consequence> consequences ) {\n+        for (Map.Entry<String, Consequence> entry : consequences.entrySet()) {\n             processConsequence( ctx, entry.getValue(), entry.getKey() );\n         }\n     }\n \n     private void processConsequence( RuleContext ctx, Consequence consequence, String name ) {\n+        // If there's an OR in the rule the fired tuple hasn't fixed structure and size because it dependens\n+        // on which branch of the OR gets activated. In this case no optimization is possible and it's usless\n+        // to precalculate the declartions at compile time.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e28754f3289232005c0aba1ef3d96ed59612112"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU3ODIyOA==", "bodyText": "Can you refer the optimization here too (in the future we will not have the PR to see the whole code together :) )?", "url": "https://github.com/kiegroup/drools/pull/3194#discussion_r513578228", "createdAt": "2020-10-28T16:17:16Z", "author": {"login": "danielezonca"}, "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/consequence/LambdaConsequence.java", "diffHunk": "@@ -69,19 +84,196 @@ public void evaluate( KnowledgeHelper knowledgeHelper, WorkingMemory workingMemo\n             if ( var.isFact() ) {\n                 Declaration declaration = declarations[declrCounter++];\n                 InternalFactHandle fh = getOriginalFactHandle( tuple.get( declaration ) );\n-                if (useDrools) {\n-                    ( (DroolsImpl) facts[0] ).registerFactHandle( fh );\n+                if ( useDrools ) {\n+                    (( DroolsImpl ) facts[0]).registerFactHandle( fh );\n                 }\n-                facts[factsOffset++] = declaration.getValue( (InternalWorkingMemory ) workingMemory, fh.getObject() );\n+                facts[factsOffset++] = declaration.getValue( workingMemory, fh.getObject() );\n             } else {\n                 facts[factsOffset++] = workingMemory.getGlobal( var.getName() );\n             }\n         }\n         return facts;\n     }\n \n-    private static InternalFactHandle getOriginalFactHandle(InternalFactHandle handle) {\n-        InternalFactHandle linkedFH = handle.isEvent() ? ((EventFactHandle )handle).getLinkedFactHandle() : null;\n+    private static InternalFactHandle getOriginalFactHandle( InternalFactHandle handle ) {\n+        if ( !handle.isEvent() ) {\n+            return handle;\n+        }\n+        InternalFactHandle linkedFH = (( EventFactHandle ) handle).getLinkedFactHandle();\n         return linkedFH != null ? linkedFH : handle;\n     }\n-}\n+\n+    private Object[] fetchFacts( KnowledgeHelper knowledgeHelper, InternalWorkingMemory workingMemory ) {\n+        Tuple tuple = knowledgeHelper.getTuple();\n+        if (factSuppliers == null) {\n+            return initConsequence(knowledgeHelper, workingMemory, tuple);\n+        }\n+        Object[] facts = new Object[factSuppliers.length];\n+        for (int i = 0; i < facts.length; i++) {\n+            tuple = factSuppliers[i].get( facts, knowledgeHelper, workingMemory, tuple );\n+        }\n+        return facts;\n+    }\n+\n+    private Object[] initConsequence( KnowledgeHelper knowledgeHelper, InternalWorkingMemory workingMemory, Tuple tuple ) {\n+        Variable[] vars = consequence.getVariables();\n+        List<FactSupplier> factSuppliers = new ArrayList<>();\n+\n+        Object[] facts;\n+        int factsOffset = 0;\n+        if ( consequence.isUsingDrools() ) {\n+            factsOffset++;\n+            factSuppliers.add( DroolsImplSupplier.INSTANCE );\n+            facts = new Object[vars.length + 1];\n+            facts[0] = new DroolsImpl( knowledgeHelper, workingMemory );\n+        } else {\n+            facts = new Object[vars.length];\n+        }\n+\n+        int declrCounter = 0;\n+        for (Variable var : vars) {\n+            if ( var.isFact() ) {\n+                factSuppliers.add( new TupleFactSupplier(factsOffset, declarations[declrCounter++], consequence.isUsingDrools()) );\n+            } else {\n+                facts[factsOffset] = workingMemory.getGlobal( var.getName() );\n+                factSuppliers.add( new GlobalSupplier(factsOffset, var.getName()) );\n+            }\n+            factsOffset++;\n+        }\n+\n+        // At this point the FactSuppliers (each of them supplying a single argument to be passed to the consequence)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e28754f3289232005c0aba1ef3d96ed59612112"}, "originalPosition": 131}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1df73e5ba100d99c28b3f4ad55fe1e1da17f546b", "author": {"user": {"login": "mariofusco", "name": "Mario Fusco"}}, "url": "https://github.com/kiegroup/drools/commit/1df73e5ba100d99c28b3f4ad55fe1e1da17f546b", "committedDate": "2020-10-28T18:05:41Z", "message": "wip"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5NDI3MzQ4", "url": "https://github.com/kiegroup/drools/pull/3194#pullrequestreview-519427348", "createdAt": "2020-10-29T08:26:35Z", "commit": {"oid": "1df73e5ba100d99c28b3f4ad55fe1e1da17f546b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1723, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}