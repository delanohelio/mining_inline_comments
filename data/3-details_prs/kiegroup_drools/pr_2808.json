{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg1NzAzNzU3", "number": 2808, "title": "Drools 3339 - Regression model - codegeneration version", "bodyText": "@danielezonca @jiripetrlik @mariofusco\nRegression model implementation with code generation\nSee http://issues.jboss.org/browse/DROOLS-3339", "createdAt": "2020-03-09T16:58:02Z", "url": "https://github.com/kiegroup/drools/pull/2808", "merged": true, "mergeCommit": {"oid": "b7d9c769f587b9c4029440007cecd45cc650b414"}, "closed": true, "closedAt": "2020-03-13T13:12:17Z", "author": {"login": "gitgabrio"}, "timelineItems": {"totalCount": 151, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcGhM8bAH2gAyMzg1NzAzNzU3OjRkYTVkNWM2NDMyMWFlN2M3OTNhYmZhZWU5MWY0ZTczN2I5ZDhjOTY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcNPiDSAFqTM3NDI2MjkzNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "4da5d5c64321ae7c793abfaee91f4e737b9d8c96", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/4da5d5c64321ae7c793abfaee91f4e737b9d8c96", "committedDate": "2020-02-21T15:10:38Z", "message": "[DROOLS-3339] Refactored RegressionModelEvaluator; add tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37f1125fa98dcef8ca3b4a3a8fe28ce1ff8b1679", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/37f1125fa98dcef8ca3b4a3a8fe28ce1ff8b1679", "committedDate": "2020-02-21T15:10:58Z", "message": "Merge branch 'DROOLS-3339' of github.com:gitgabrio/drools into DROOLS-3339"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00ea60ab257982a7d92000d8ec0f7bbcb226d24c", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/00ea60ab257982a7d92000d8ec0f7bbcb226d24c", "committedDate": "2020-02-21T15:57:32Z", "message": "[DROOLS-3339] Implemented PMMLRegressionModelUtilsTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "14ac8f587abd3a4ebafdeac88b062bd683c009cc", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/14ac8f587abd3a4ebafdeac88b062bd683c009cc", "committedDate": "2020-02-21T16:25:20Z", "message": "[DROOLS-3339] Implemented PMMLRegressionModelExecutorTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f47b01f07d59c736a888a15ccb4658b87c449b74", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/f47b01f07d59c736a888a15ccb4658b87c449b74", "committedDate": "2020-02-21T17:06:02Z", "message": "[DROOLS-3339] Implemented Predictors tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37c74e4d74010729e0f0f251297fdbea32b4b72d", "author": {"user": {"login": "jiripetrlik", "name": "Jiri Petrlik"}}, "url": "https://github.com/kiegroup/drools/commit/37c74e4d74010729e0f0f251297fdbea32b4b72d", "committedDate": "2020-02-24T07:34:09Z", "message": "[DROOLS-3339] Implement PMMLRegressionModelExecutorTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3025a45b6a4ee98dd9adb19a23f1bb16f467c76", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/a3025a45b6a4ee98dd9adb19a23f1bb16f467c76", "committedDate": "2020-02-24T09:07:37Z", "message": "Merge remote-tracking branch 'origin/master' into DROOLS-3339"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "854804b8b30b95811ec21b83e1dac088abe8ff69", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/854804b8b30b95811ec21b83e1dac088abe8ff69", "committedDate": "2020-02-24T09:36:37Z", "message": "[DROOLS-3339] Fixing Sonar remarks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b307015ec9f007b90bed3156b0e2db163da5b9bd", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/b307015ec9f007b90bed3156b0e2db163da5b9bd", "committedDate": "2020-02-24T09:56:01Z", "message": "[DROOLS-3339] Fixing Sonar remarks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d091b2956da21419b7163c689700d657a1275a20", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/d091b2956da21419b7163c689700d657a1275a20", "committedDate": "2020-02-25T09:19:48Z", "message": "Merge remote-tracking branch 'origin/master' into DROOLS-3339"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eba8c8d1288cbd4febfe558070fdcfa6d3c87b5c", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/eba8c8d1288cbd4febfe558070fdcfa6d3c87b5c", "committedDate": "2020-02-25T09:35:43Z", "message": "[DROOLS-3339] Removed \"Optional\" properties from model"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79580cb2f0f338739877d84819a59f7bf0c83e60", "author": {"user": {"login": "jiripetrlik", "name": "Jiri Petrlik"}}, "url": "https://github.com/kiegroup/drools/commit/79580cb2f0f338739877d84819a59f7bf0c83e60", "committedDate": "2020-02-25T13:46:48Z", "message": "[DROOLS-5099] Tests for logistic regression"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0dd335e9461490fd383426b56f686a47b1621cb0", "author": {"user": {"login": "jiripetrlik", "name": "Jiri Petrlik"}}, "url": "https://github.com/kiegroup/drools/commit/0dd335e9461490fd383426b56f686a47b1621cb0", "committedDate": "2020-02-26T08:33:50Z", "message": "[DROOLS-5099] Test also probabilities in logistic regression"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec04311c9fa0125ce290e0a724af4742a7a5d7e1", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/ec04311c9fa0125ce290e0a724af4742a7a5d7e1", "committedDate": "2020-02-26T10:55:22Z", "message": "[DROOLS-3339] Simplify abstract hierarchy. Removing \"Serializable\" interfaces"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54b118f3684e399e5f7ae88415acd5017320010c", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/54b118f3684e399e5f7ae88415acd5017320010c", "committedDate": "2020-02-26T11:00:58Z", "message": "Merge remote-tracking branch 'gitgabrio/DROOLS-3339' into DROOLS-3339\n\n# Conflicts:\n#\tkie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-tests/src/test/resources/logisticRegressionIrisData.pmml"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "93bb545160635776edbb2a6ba351baf8c0e9faed", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/93bb545160635776edbb2a6ba351baf8c0e9faed", "committedDate": "2020-02-26T11:02:37Z", "message": "[DROOLS-3339] Simplify abstract hierarchy. Removing \"Serializable\" interfaces"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d52dac54b5ed45e882205af2c9bdfbc16e251118", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/d52dac54b5ed45e882205af2c9bdfbc16e251118", "committedDate": "2020-02-26T11:42:46Z", "message": "Merge remote-tracking branch 'origin/master' into DROOLS-3339"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "948a5663dee77d9388d8d06e62d00c30e75c7fae", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/948a5663dee77d9388d8d06e62d00c30e75c7fae", "committedDate": "2020-02-26T11:43:38Z", "message": "[DROOLS-3339] Fixed as per PR suggestions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "70667b0d96ec38cfcb48b5f45b3d64fd344aeadf", "author": {"user": {"login": "jiripetrlik", "name": "Jiri Petrlik"}}, "url": "https://github.com/kiegroup/drools/commit/70667b0d96ec38cfcb48b5f45b3d64fd344aeadf", "committedDate": "2020-02-26T14:24:09Z", "message": "[DROOLS-5099] Test for normalization methods in regression"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a5d93f55eb90d0785fe639115121f1215833e60", "author": {"user": {"login": "jiripetrlik", "name": "Jiri Petrlik"}}, "url": "https://github.com/kiegroup/drools/commit/7a5d93f55eb90d0785fe639115121f1215833e60", "committedDate": "2020-02-27T09:41:58Z", "message": "[DROOLS-5099] WIP: Test logistic regression normalization methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2478197c0f7507b33b967a2ceaec11b1c6276b74", "author": {"user": {"login": "jiripetrlik", "name": "Jiri Petrlik"}}, "url": "https://github.com/kiegroup/drools/commit/2478197c0f7507b33b967a2ceaec11b1c6276b74", "committedDate": "2020-02-27T13:20:24Z", "message": "[DROOLS-5099] Finish test for logistic regression normalization methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a29b4f9bb617b7b94872adb48e79931eca628f4f", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/a29b4f9bb617b7b94872adb48e79931eca628f4f", "committedDate": "2020-02-27T13:29:22Z", "message": "Merge remote-tracking branch 'origin/master' into DROOLS-3339_codegen"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c0ac56e578b99255d8a2331ec59b229fbee09ee", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/6c0ac56e578b99255d8a2331ec59b229fbee09ee", "committedDate": "2020-02-27T13:29:43Z", "message": "Merge remote-tracking branch 'gitgabrio/DROOLS-3339' into DROOLS-3339_codegen"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c72bcd216a2a2d242b0496f4a6b765d3077ba9d", "author": {"user": {"login": "jiripetrlik", "name": "Jiri Petrlik"}}, "url": "https://github.com/kiegroup/drools/commit/9c72bcd216a2a2d242b0496f4a6b765d3077ba9d", "committedDate": "2020-02-27T14:23:56Z", "message": "[DROOLS-5099] Improve PMML loading"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d0520bcca8f79bba1e5c63d0d3e476e32509774", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/9d0520bcca8f79bba1e5c63d0d3e476e32509774", "committedDate": "2020-03-02T08:15:40Z", "message": "[DROOLS-3339] Generating RegressionTable source"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f0989d33321cbc62d6eaa4e134b63294c004abd", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/4f0989d33321cbc62d6eaa4e134b63294c004abd", "committedDate": "2020-03-04T10:25:48Z", "message": "[DROOLS-3339] Compiling generated classes. Returned new instance of generated model"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf30eb7c0f698b780547c7ed27f58f40bb94b739", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/cf30eb7c0f698b780547c7ed27f58f40bb94b739", "committedDate": "2020-03-04T10:27:26Z", "message": "Merge remote-tracking branch 'origin/master' into DROOLS-3339_codegen\n\n# Conflicts:\n#\tkie-pmml-new/kie-pmml-commons/pom.xml"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "530d7d82f569f6f1aa73869be59a2d2a3e64c84b", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/530d7d82f569f6f1aa73869be59a2d2a3e64c84b", "committedDate": "2020-03-04T10:28:47Z", "message": "Merge remote-tracking branch 'gitgabrio/DROOLS-3339' into DROOLS-3339_codegen"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a20c6672ca819280483c940657836605cc153260", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/a20c6672ca819280483c940657836605cc153260", "committedDate": "2020-03-04T16:51:22Z", "message": "[DROOLS-3339] Test working"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c40f0dc16c13f0ef8e06aea471bd253df4efb8c3", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/c40f0dc16c13f0ef8e06aea471bd253df4efb8c3", "committedDate": "2020-03-05T11:40:06Z", "message": "[DROOLS-3339] Fixing ClassificationTableTemplate - add missing import"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d9a2440e3f9f38264b2e7ea66a9cbebd9c7f7694", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/d9a2440e3f9f38264b2e7ea66a9cbebd9c7f7694", "committedDate": "2020-03-05T14:00:34Z", "message": "[DROOLS-3339] Begin benchmark implementation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bcd571e4e478a331b554c97482adc11d94d44069", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/bcd571e4e478a331b554c97482adc11d94d44069", "committedDate": "2020-03-05T16:37:42Z", "message": "[DROOLS-3339] Updated codegen benchmark"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "708945f540249a2b148252ea576f43e419185700", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/708945f540249a2b148252ea576f43e419185700", "committedDate": "2020-03-06T08:31:33Z", "message": "[DROOLS-3339] Refactoring inner compiler"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a92ab3198a846858bfac3d003099f0525cb8d262", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/a92ab3198a846858bfac3d003099f0525cb8d262", "committedDate": "2020-03-06T13:19:58Z", "message": "[DROOLS-3339] Refactoring inner compiler"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5d310e15270f28e31a8bcdce78805f1460dd51b5", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/5d310e15270f28e31a8bcdce78805f1460dd51b5", "committedDate": "2020-03-09T08:26:54Z", "message": "[DROOLS-3339] Keep working on Benchmarks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee5b1f2f9c539b5514264ae365f8891da5c2e217", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/ee5b1f2f9c539b5514264ae365f8891da5c2e217", "committedDate": "2020-03-09T09:10:50Z", "message": "Merge remote-tracking branch 'origin/master' into DROOLS-3339_codegen"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c0cc347a28c948783ef233b9f218e0343315d54", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/6c0cc347a28c948783ef233b9f218e0343315d54", "committedDate": "2020-03-09T09:32:56Z", "message": "[DROOLS-3339] Fix broken tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "061fd36e8bc6da2bccbcd72435e492d20a0ead51", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/061fd36e8bc6da2bccbcd72435e492d20a0ead51", "committedDate": "2020-03-09T12:14:24Z", "message": "[DROOLS-3339] Fix benchmarks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b8ec487c4445c6bd0f52a071dc56819132fd20ba", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/b8ec487c4445c6bd0f52a071dc56819132fd20ba", "committedDate": "2020-03-09T15:56:57Z", "message": "[DROOLS-3339] Fix import"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a68e7e68b439401a4d7a232b0f86700998e459a", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/5a68e7e68b439401a4d7a232b0f86700998e459a", "committedDate": "2020-03-09T16:52:43Z", "message": "[DROOLS-3339] Fix benchmark"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/7543d6c235681cdd6561a8bb4e5b520cafa64c7d", "committedDate": "2020-03-09T18:22:13Z", "message": "[DROOLS-3339] Rename test classes. Minor fix inside Classification table generation. Remove stream from templates"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxODkyMjk2", "url": "https://github.com/kiegroup/drools/pull/2808#pullrequestreview-371892296", "createdAt": "2020-03-10T12:05:08Z", "commit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "state": "COMMENTED", "comments": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMjowNTowOFrOF0MAaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMjo1MTo1MVrOF0Nadg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI2Njk4NQ==", "bodyText": "I would suggest to not add code which is commented out. If it is absolutely necessary please add also some description with reason why is this code commented out.", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390266985", "createdAt": "2020-03-10T12:05:08Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-benchmarks/kie-pmml-benchmarks-regression/src/main/java/org/kie/pmml/benchmarks/regression/CategoricalBatchBenchmark.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.benchmarks.regression;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+\n+@BenchmarkMode(Mode.Throughput)\n+@State(Scope.Thread)\n+@Warmup(iterations = 2)\n+@Measurement(iterations = 5)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@Fork(jvmArgs = {\"-Xms8172m\", \"-Xmx8172m\"}, value = 5)\n+public class CategoricalBatchBenchmark {\n+\n+    private static final String modelName = \"Sample for logistic regression\";\n+    private static final String fileName = \"CategoricalRegressionSample.pmml\";\n+    private static final String inputDataFile = \"CategoricalRegressionSample.csv\";\n+//", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI2ODY0MQ==", "bodyText": "It seems like quite a big file to be add to git. Can't we simply use subset of these data? Or if we need long data file can't we generate CSV programaticaly from tests.", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390268641", "createdAt": "2020-03-10T12:08:28Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-benchmarks/kie-pmml-benchmarks-regression/src/main/resources/CategoricalRegressionSample.csv", "diffHunk": "@@ -0,0 +1,1900 @@\n+Age,Employment,Education,Marital,Occupation,Income,Gender,Deductions,Hours,Adjusted", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI2OTc0NQ==", "bodyText": "Is this really necessary? I would guess that nobody will try to initiate class with constants and if so it will not cause any damage.", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390269745", "createdAt": "2020-03-10T12:10:49Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-commons/src/main/java/org/kie/pmml/commons/Constants.java", "diffHunk": "@@ -0,0 +1,30 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.commons;\n+\n+public class Constants {\n+\n+    public static final String RELEASE_ID = \"org.kie:kie-pmml-new:7.34.0-SNAPSHOT\";\n+\n+    public static final String UNEXPECTED_OP_TYPE = \"Unexpected opType %s\";\n+    public static final String EXPECTED_TWO_ENTRIES_RETRIEVED = \"Expected two entries, retrieved %d\";\n+    public static final String UNEXPECTED_OPERATION_TYPE = \"Unexpected Operation Type %s\";\n+    public static final String UNEXPECTED_NORMALIZATION_METHOD = \"Unexpected Normalization Method %s\";\n+\n+    private Constants() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI3MjI0Mw==", "bodyText": "Is this necessary?", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390272243", "createdAt": "2020-03-10T12:15:58Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-compiler/kie-pmml-compiler-commons/src/main/java/org/kie/pmml/compiler/commons/implementations/KiePMMLModelRetriever.java", "diffHunk": "@@ -31,6 +31,9 @@\n     private static final Logger logger = LoggerFactory.getLogger(KiePMMLModelRetriever.class.getName());\n     private static final ModelImplementationProviderFinder modelImplementationProviderFinder = new ModelImplementationProviderFinderImpl();\n \n+    private KiePMMLModelRetriever() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI3MjUxMQ==", "bodyText": "Again. Is this necessary? Instantiation will not cause any harm to the app.", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390272511", "createdAt": "2020-03-10T12:16:33Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-compiler/kie-pmml-compiler-commons/src/main/java/org/kie/pmml/compiler/commons/utils/KiePMMLUtil.java", "diffHunk": "@@ -29,6 +29,10 @@\n  */\n public class KiePMMLUtil {\n \n+    private KiePMMLUtil() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI3MzgxMQ==", "bodyText": "Seems a little bit suspicious. Do we really want to always return null here? Don't we forget to add implementation?", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390273811", "createdAt": "2020-03-10T12:19:20Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-compiler/kie-pmml-compiler-commons/src/test/java/org/kie/pmml/compiler/commons/mocks/KiePMMLTestingModel.java", "diffHunk": "@@ -25,5 +29,12 @@\n \n     public static final PMML_MODEL PMML_MODEL_TYPE = PMML_MODEL.REGRESSION_MODEL;\n \n-    private static final long serialVersionUID = -3197536256173718262L;\n+    protected KiePMMLTestingModel(String name, List<KiePMMLExtension> extensions) {\n+        super(name);\n+    }\n+\n+    @Override\n+    public Object evaluate(Map<String, Object> requestData) {\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI3NDQ1NA==", "bodyText": "Please remove commented code.", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390274454", "createdAt": "2020-03-10T12:20:41Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-evaluator/kie-pmml-evaluator-core/src/main/java/org/kie/pmml/evaluator/core/utils/Converter.java", "diffHunk": "@@ -25,15 +26,43 @@\n  */\n public class Converter {\n \n+    private Converter() {\n+        // Avoid instantiation\n+    }\n+\n     /**\n      * <b>Extract</b> the objects from the <code>ParameterInfo</code> values of the given map.\n      * @param parameterMap\n      * @return\n      */\n     public static Map<String, Object> getUnwrappedParametersMap(Map<String, ParameterInfo> parameterMap) {\n-        return parameterMap.entrySet()\n-                .stream()\n-                .collect(Collectors.toMap(Map.Entry::getKey,\n-                                          e -> e.getValue().getValue()));\n+        Map<String, Object> toReturn = new HashMap<>();\n+        for (Map.Entry<String, ParameterInfo> entry : parameterMap.entrySet()) {\n+            toReturn.put(entry.getKey(), entry.getValue().getValue());\n+        }\n+        return toReturn;\n+//", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI3NjU4Ng==", "bodyText": "Please remove commented code.", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390276586", "createdAt": "2020-03-10T12:25:03Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-evaluator/kie-pmml-evaluator-core/src/main/java/org/kie/pmml/evaluator/core/utils/Converter.java", "diffHunk": "@@ -25,15 +26,43 @@\n  */\n public class Converter {\n \n+    private Converter() {\n+        // Avoid instantiation\n+    }\n+\n     /**\n      * <b>Extract</b> the objects from the <code>ParameterInfo</code> values of the given map.\n      * @param parameterMap\n      * @return\n      */\n     public static Map<String, Object> getUnwrappedParametersMap(Map<String, ParameterInfo> parameterMap) {\n-        return parameterMap.entrySet()\n-                .stream()\n-                .collect(Collectors.toMap(Map.Entry::getKey,\n-                                          e -> e.getValue().getValue()));\n+        Map<String, Object> toReturn = new HashMap<>();\n+        for (Map.Entry<String, ParameterInfo> entry : parameterMap.entrySet()) {\n+            toReturn.put(entry.getKey(), entry.getValue().getValue());\n+        }\n+        return toReturn;\n+//\n+//        return parameterMap.entrySet()\n+//                .stream()\n+//                .collect(Collectors.toMap(Map.Entry::getKey,\n+//                                          e -> e.getValue().getValue()));\n+    }\n+\n+    /**\n+     * <b>Extract</b> the objects from the <code>ParameterInfo</code> of the given collection.\n+     * @param parameterInfos\n+     * @return\n+     */\n+    public static Map<String, Object> getUnwrappedParametersMap(Collection<ParameterInfo> parameterInfos) {\n+        Map<String, Object> toReturn = new HashMap<>();\n+        for (ParameterInfo parameterInfo : parameterInfos) {\n+            toReturn.put(parameterInfo.getName(), parameterInfo.getValue());\n+        }\n+        return toReturn;\n+//\n+//        return parameterInfos", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI4Mjg0Ng==", "bodyText": "One idea. What about to use Assertj in the future. It provides much more rich asserts and also messages about failures are much more verbose.", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390282846", "createdAt": "2020-03-10T12:38:06Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-integration-tests/src/test/java/org/kie/pmml/compiler/executor/PMMLKiePMMLRegressionCompilerImplTest.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.pmml.compiler.executor;\n+\n+import java.util.List;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.KieBuilder;\n+import org.kie.api.builder.KieFileSystem;\n+import org.kie.pmml.commons.model.KiePMMLModel;\n+import org.kie.pmml.commons.model.enums.MINING_FUNCTION;\n+import org.kie.pmml.models.regression.model.KiePMMLRegressionModel;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.kie.test.util.filesystem.FileUtils.getFileInputStream;\n+\n+public class PMMLKiePMMLRegressionCompilerImplTest {\n+\n+    private static final PMMLCompiler EXECUTOR = new PMMLCompilerImpl();\n+\n+    private KieBuilder kieBuilder;\n+\n+    @Before\n+    public void setup() {\n+        KieServices ks = KieServices.Factory.get();\n+        KieFileSystem kfs = ks.newKieFileSystem();\n+        kieBuilder = ks.newKieBuilder(kfs);\n+    }\n+\n+    @Test\n+    public void getModels() throws Exception {\n+        final List<KiePMMLModel> results = EXECUTOR.getModels(getFileInputStream(\"LinearRegressionSample.pmml\"), kieBuilder);\n+        assertNotNull(results);\n+        assertEquals(1, results.size());\n+        assertTrue(results.get(0) instanceof KiePMMLRegressionModel);\n+        commonVerifyKiePMMLRegressionModel((KiePMMLRegressionModel) results.get(0));\n+    }\n+\n+    // TODO {gcardosi} Carbon-copy of org.kie.pmml.regression.evaluator.RegressionModelImplementationProviderTest\n+\n+    private void commonVerifyKiePMMLRegressionModel(KiePMMLRegressionModel retrieved) {\n+        assertNotNull(retrieved);\n+        assertEquals(MINING_FUNCTION.REGRESSION, retrieved.getMiningFunction());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI4NTMwNQ==", "bodyText": "Please remove this empty method.", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390285305", "createdAt": "2020-03-10T12:43:05Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/test/java/org/kie/pmml/models/regression/compiler/executor/RegressionModelImplementationProviderTest.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.pmml.models.regression.compiler.executor;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.dmg.pmml.PMML;\n+import org.dmg.pmml.regression.RegressionModel;\n+import org.junit.Test;\n+import org.kie.pmml.commons.model.enums.PMML_MODEL;\n+import org.kie.pmml.compiler.testutils.TestUtils;\n+import org.kie.pmml.models.regression.model.KiePMMLRegressionModel;\n+import org.kie.pmml.models.regression.model.predictors.KiePMMLCategoricalPredictor;\n+import org.kie.pmml.models.regression.model.predictors.KiePMMLNumericPredictor;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+//import org.kie.pmml.models.regression.model.KiePMMLRegressionTable;\n+\n+public class RegressionModelImplementationProviderTest {\n+\n+    private final static RegressionModelImplementationProvider PROVIDER = new RegressionModelImplementationProvider();\n+    private final static String RELEASE_ID = \"org.drools:kie-pmml-models-testing:1.0\";\n+    private static final String SOURCE_1 = \"LinearRegressionSample.xml\";\n+    private static final String SOURCE_2 = \"test_regression.pmml\";\n+    private static final String SOURCE_3 = \"test_regression_clax.pmml\";\n+\n+    @Test\n+    public void getPMMLModelType() {\n+        assertEquals(PMML_MODEL.REGRESSION_MODEL, PROVIDER.getPMMLModelType());\n+    }\n+\n+    @Test\n+    public void getKiePMMLModel() throws Exception {\n+        final PMML pmml = TestUtils.loadFromFile(SOURCE_1);\n+        assertNotNull(pmml);\n+        assertEquals(1, pmml.getModels().size());\n+        assertTrue(pmml.getModels().get(0) instanceof RegressionModel);\n+        commonVerifyKiePMMLRegressionModel(PROVIDER.getKiePMMLModel(pmml.getDataDictionary(), (RegressionModel) pmml.getModels().get(0), RELEASE_ID));\n+    }\n+\n+    @Test\n+    public void validateSource2() throws Exception {\n+        commonValidateSource(SOURCE_2);\n+    }\n+\n+    @Test\n+    public void validateSource3() throws Exception {\n+        commonValidateSource(SOURCE_3);\n+    }\n+\n+    private void commonValidateSource(String sourceFile) throws Exception {\n+        final PMML pmml = TestUtils.loadFromFile(sourceFile);\n+        assertNotNull(pmml);\n+        assertEquals(1, pmml.getModels().size());\n+        assertTrue(pmml.getModels().get(0) instanceof RegressionModel);\n+        PROVIDER.validate(pmml.getDataDictionary(), (RegressionModel) pmml.getModels().get(0));\n+    }\n+\n+    private void commonVerifyKiePMMLRegressionModel(KiePMMLRegressionModel retrieved) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI4NTM3Nw==", "bodyText": "Please remove this empty method.", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390285377", "createdAt": "2020-03-10T12:43:11Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/test/java/org/kie/pmml/models/regression/compiler/executor/RegressionModelImplementationProviderTest.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.pmml.models.regression.compiler.executor;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.dmg.pmml.PMML;\n+import org.dmg.pmml.regression.RegressionModel;\n+import org.junit.Test;\n+import org.kie.pmml.commons.model.enums.PMML_MODEL;\n+import org.kie.pmml.compiler.testutils.TestUtils;\n+import org.kie.pmml.models.regression.model.KiePMMLRegressionModel;\n+import org.kie.pmml.models.regression.model.predictors.KiePMMLCategoricalPredictor;\n+import org.kie.pmml.models.regression.model.predictors.KiePMMLNumericPredictor;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+//import org.kie.pmml.models.regression.model.KiePMMLRegressionTable;\n+\n+public class RegressionModelImplementationProviderTest {\n+\n+    private final static RegressionModelImplementationProvider PROVIDER = new RegressionModelImplementationProvider();\n+    private final static String RELEASE_ID = \"org.drools:kie-pmml-models-testing:1.0\";\n+    private static final String SOURCE_1 = \"LinearRegressionSample.xml\";\n+    private static final String SOURCE_2 = \"test_regression.pmml\";\n+    private static final String SOURCE_3 = \"test_regression_clax.pmml\";\n+\n+    @Test\n+    public void getPMMLModelType() {\n+        assertEquals(PMML_MODEL.REGRESSION_MODEL, PROVIDER.getPMMLModelType());\n+    }\n+\n+    @Test\n+    public void getKiePMMLModel() throws Exception {\n+        final PMML pmml = TestUtils.loadFromFile(SOURCE_1);\n+        assertNotNull(pmml);\n+        assertEquals(1, pmml.getModels().size());\n+        assertTrue(pmml.getModels().get(0) instanceof RegressionModel);\n+        commonVerifyKiePMMLRegressionModel(PROVIDER.getKiePMMLModel(pmml.getDataDictionary(), (RegressionModel) pmml.getModels().get(0), RELEASE_ID));\n+    }\n+\n+    @Test\n+    public void validateSource2() throws Exception {\n+        commonValidateSource(SOURCE_2);\n+    }\n+\n+    @Test\n+    public void validateSource3() throws Exception {\n+        commonValidateSource(SOURCE_3);\n+    }\n+\n+    private void commonValidateSource(String sourceFile) throws Exception {\n+        final PMML pmml = TestUtils.loadFromFile(sourceFile);\n+        assertNotNull(pmml);\n+        assertEquals(1, pmml.getModels().size());\n+        assertTrue(pmml.getModels().get(0) instanceof RegressionModel);\n+        PROVIDER.validate(pmml.getDataDictionary(), (RegressionModel) pmml.getModels().get(0));\n+    }\n+\n+    private void commonVerifyKiePMMLRegressionModel(KiePMMLRegressionModel retrieved) {\n+//        assertNotNull(retrieved);\n+//        assertEquals(MINING_FUNCTION.REGRESSION, retrieved.getMiningFunction());\n+//        assertTrue(retrieved.getAlgorithmName().isPresent());\n+//        assertEquals(\"linearRegression\", retrieved.getAlgorithmName().get());\n+//        assertFalse(retrieved.getModelType().isPresent());\n+//        assertEquals(\"number_of_claims\", retrieved.getTargetField());\n+//        assertEquals(OP_TYPE.CONTINUOUS, retrieved.getTargetOpType());\n+//        assertEquals(REGRESSION_NORMALIZATION_METHOD.NONE, retrieved.getRegressionNormalizationMethod());\n+//        assertTrue(retrieved.isScorable());\n+//        assertTrue(retrieved.isRegression());\n+//        assertEquals(1, retrieved.getRegressionTables().size());\n+//        commonVerifyKiePMMLRegressionTable(retrieved.getRegressionTables().get(0));\n+    }\n+\n+//    private void commonVerifyKiePMMLRegressionTable(KiePMMLRegressionTable retrieved) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI4NTQzMA==", "bodyText": "Please remove this empty method.", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390285430", "createdAt": "2020-03-10T12:43:17Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/test/java/org/kie/pmml/models/regression/compiler/executor/RegressionModelImplementationProviderTest.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.pmml.models.regression.compiler.executor;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.dmg.pmml.PMML;\n+import org.dmg.pmml.regression.RegressionModel;\n+import org.junit.Test;\n+import org.kie.pmml.commons.model.enums.PMML_MODEL;\n+import org.kie.pmml.compiler.testutils.TestUtils;\n+import org.kie.pmml.models.regression.model.KiePMMLRegressionModel;\n+import org.kie.pmml.models.regression.model.predictors.KiePMMLCategoricalPredictor;\n+import org.kie.pmml.models.regression.model.predictors.KiePMMLNumericPredictor;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+//import org.kie.pmml.models.regression.model.KiePMMLRegressionTable;\n+\n+public class RegressionModelImplementationProviderTest {\n+\n+    private final static RegressionModelImplementationProvider PROVIDER = new RegressionModelImplementationProvider();\n+    private final static String RELEASE_ID = \"org.drools:kie-pmml-models-testing:1.0\";\n+    private static final String SOURCE_1 = \"LinearRegressionSample.xml\";\n+    private static final String SOURCE_2 = \"test_regression.pmml\";\n+    private static final String SOURCE_3 = \"test_regression_clax.pmml\";\n+\n+    @Test\n+    public void getPMMLModelType() {\n+        assertEquals(PMML_MODEL.REGRESSION_MODEL, PROVIDER.getPMMLModelType());\n+    }\n+\n+    @Test\n+    public void getKiePMMLModel() throws Exception {\n+        final PMML pmml = TestUtils.loadFromFile(SOURCE_1);\n+        assertNotNull(pmml);\n+        assertEquals(1, pmml.getModels().size());\n+        assertTrue(pmml.getModels().get(0) instanceof RegressionModel);\n+        commonVerifyKiePMMLRegressionModel(PROVIDER.getKiePMMLModel(pmml.getDataDictionary(), (RegressionModel) pmml.getModels().get(0), RELEASE_ID));\n+    }\n+\n+    @Test\n+    public void validateSource2() throws Exception {\n+        commonValidateSource(SOURCE_2);\n+    }\n+\n+    @Test\n+    public void validateSource3() throws Exception {\n+        commonValidateSource(SOURCE_3);\n+    }\n+\n+    private void commonValidateSource(String sourceFile) throws Exception {\n+        final PMML pmml = TestUtils.loadFromFile(sourceFile);\n+        assertNotNull(pmml);\n+        assertEquals(1, pmml.getModels().size());\n+        assertTrue(pmml.getModels().get(0) instanceof RegressionModel);\n+        PROVIDER.validate(pmml.getDataDictionary(), (RegressionModel) pmml.getModels().get(0));\n+    }\n+\n+    private void commonVerifyKiePMMLRegressionModel(KiePMMLRegressionModel retrieved) {\n+//        assertNotNull(retrieved);\n+//        assertEquals(MINING_FUNCTION.REGRESSION, retrieved.getMiningFunction());\n+//        assertTrue(retrieved.getAlgorithmName().isPresent());\n+//        assertEquals(\"linearRegression\", retrieved.getAlgorithmName().get());\n+//        assertFalse(retrieved.getModelType().isPresent());\n+//        assertEquals(\"number_of_claims\", retrieved.getTargetField());\n+//        assertEquals(OP_TYPE.CONTINUOUS, retrieved.getTargetOpType());\n+//        assertEquals(REGRESSION_NORMALIZATION_METHOD.NONE, retrieved.getRegressionNormalizationMethod());\n+//        assertTrue(retrieved.isScorable());\n+//        assertTrue(retrieved.isRegression());\n+//        assertEquals(1, retrieved.getRegressionTables().size());\n+//        commonVerifyKiePMMLRegressionTable(retrieved.getRegressionTables().get(0));\n+    }\n+\n+//    private void commonVerifyKiePMMLRegressionTable(KiePMMLRegressionTable retrieved) {\n+//        assertNotNull(retrieved);\n+//        assertEquals(132.37, retrieved.getIntercept());\n+//        assertFalse(retrieved.getTargetCategory().isPresent());\n+//        assertTrue(retrieved.getNumericPredictors().isPresent());\n+//        assertEquals(2, retrieved.getNumericPredictors().get().size());\n+//        assertTrue(retrieved.getCategoricalPredictors().isPresent());\n+//        assertEquals(2, retrieved.getCategoricalPredictors().get().size());\n+//        commonVerifyNumericPredictors(retrieved, \"age\", 1, 7.1);\n+//        commonVerifyNumericPredictors(retrieved, \"salary\", 1, 0.01);\n+//        commonVerifyCategoricalPredictors(retrieved, \"car_location\");\n+//    }\n+\n+//    private void commonVerifyNumericPredictors(KiePMMLRegressionTable retrieved, String name, int exponent, double coefficient) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI4NTQ4MA==", "bodyText": "Please remove this empty method.", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390285480", "createdAt": "2020-03-10T12:43:22Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/test/java/org/kie/pmml/models/regression/compiler/executor/RegressionModelImplementationProviderTest.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.pmml.models.regression.compiler.executor;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.dmg.pmml.PMML;\n+import org.dmg.pmml.regression.RegressionModel;\n+import org.junit.Test;\n+import org.kie.pmml.commons.model.enums.PMML_MODEL;\n+import org.kie.pmml.compiler.testutils.TestUtils;\n+import org.kie.pmml.models.regression.model.KiePMMLRegressionModel;\n+import org.kie.pmml.models.regression.model.predictors.KiePMMLCategoricalPredictor;\n+import org.kie.pmml.models.regression.model.predictors.KiePMMLNumericPredictor;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+//import org.kie.pmml.models.regression.model.KiePMMLRegressionTable;\n+\n+public class RegressionModelImplementationProviderTest {\n+\n+    private final static RegressionModelImplementationProvider PROVIDER = new RegressionModelImplementationProvider();\n+    private final static String RELEASE_ID = \"org.drools:kie-pmml-models-testing:1.0\";\n+    private static final String SOURCE_1 = \"LinearRegressionSample.xml\";\n+    private static final String SOURCE_2 = \"test_regression.pmml\";\n+    private static final String SOURCE_3 = \"test_regression_clax.pmml\";\n+\n+    @Test\n+    public void getPMMLModelType() {\n+        assertEquals(PMML_MODEL.REGRESSION_MODEL, PROVIDER.getPMMLModelType());\n+    }\n+\n+    @Test\n+    public void getKiePMMLModel() throws Exception {\n+        final PMML pmml = TestUtils.loadFromFile(SOURCE_1);\n+        assertNotNull(pmml);\n+        assertEquals(1, pmml.getModels().size());\n+        assertTrue(pmml.getModels().get(0) instanceof RegressionModel);\n+        commonVerifyKiePMMLRegressionModel(PROVIDER.getKiePMMLModel(pmml.getDataDictionary(), (RegressionModel) pmml.getModels().get(0), RELEASE_ID));\n+    }\n+\n+    @Test\n+    public void validateSource2() throws Exception {\n+        commonValidateSource(SOURCE_2);\n+    }\n+\n+    @Test\n+    public void validateSource3() throws Exception {\n+        commonValidateSource(SOURCE_3);\n+    }\n+\n+    private void commonValidateSource(String sourceFile) throws Exception {\n+        final PMML pmml = TestUtils.loadFromFile(sourceFile);\n+        assertNotNull(pmml);\n+        assertEquals(1, pmml.getModels().size());\n+        assertTrue(pmml.getModels().get(0) instanceof RegressionModel);\n+        PROVIDER.validate(pmml.getDataDictionary(), (RegressionModel) pmml.getModels().get(0));\n+    }\n+\n+    private void commonVerifyKiePMMLRegressionModel(KiePMMLRegressionModel retrieved) {\n+//        assertNotNull(retrieved);\n+//        assertEquals(MINING_FUNCTION.REGRESSION, retrieved.getMiningFunction());\n+//        assertTrue(retrieved.getAlgorithmName().isPresent());\n+//        assertEquals(\"linearRegression\", retrieved.getAlgorithmName().get());\n+//        assertFalse(retrieved.getModelType().isPresent());\n+//        assertEquals(\"number_of_claims\", retrieved.getTargetField());\n+//        assertEquals(OP_TYPE.CONTINUOUS, retrieved.getTargetOpType());\n+//        assertEquals(REGRESSION_NORMALIZATION_METHOD.NONE, retrieved.getRegressionNormalizationMethod());\n+//        assertTrue(retrieved.isScorable());\n+//        assertTrue(retrieved.isRegression());\n+//        assertEquals(1, retrieved.getRegressionTables().size());\n+//        commonVerifyKiePMMLRegressionTable(retrieved.getRegressionTables().get(0));\n+    }\n+\n+//    private void commonVerifyKiePMMLRegressionTable(KiePMMLRegressionTable retrieved) {\n+//        assertNotNull(retrieved);\n+//        assertEquals(132.37, retrieved.getIntercept());\n+//        assertFalse(retrieved.getTargetCategory().isPresent());\n+//        assertTrue(retrieved.getNumericPredictors().isPresent());\n+//        assertEquals(2, retrieved.getNumericPredictors().get().size());\n+//        assertTrue(retrieved.getCategoricalPredictors().isPresent());\n+//        assertEquals(2, retrieved.getCategoricalPredictors().get().size());\n+//        commonVerifyNumericPredictors(retrieved, \"age\", 1, 7.1);\n+//        commonVerifyNumericPredictors(retrieved, \"salary\", 1, 0.01);\n+//        commonVerifyCategoricalPredictors(retrieved, \"car_location\");\n+//    }\n+\n+//    private void commonVerifyNumericPredictors(KiePMMLRegressionTable retrieved, String name, int exponent, double coefficient) {\n+//        final Optional<KiePMMLNumericPredictor> optionalPredictor = retrieved.getKiePMMLNumericPredictorByName(name);\n+//        assertTrue(optionalPredictor.isPresent());\n+//        commonVerifyNumericPredictor(optionalPredictor.get(), name, exponent, coefficient);\n+//    }\n+\n+    private void commonVerifyNumericPredictor(KiePMMLNumericPredictor retrieved, String name, int exponent, double coefficient) {\n+        assertEquals(name, retrieved.getName());\n+        assertEquals(exponent, retrieved.getExponent());\n+        assertEquals(coefficient, retrieved.getCoefficient());\n+    }\n+\n+//    private void commonVerifyCategoricalPredictors(KiePMMLRegressionTable retrieved, String name) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI4Njc5MQ==", "bodyText": "Would it be possible to split this stream into multiple steps? I personally don't like such long streams because it is usually very poorly readable and it is hard to figure out what is happening.", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390286791", "createdAt": "2020-03-10T12:45:51Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/test/java/org/kie/pmml/models/regression/compiler/factories/KiePMMLRegressionModelFactoryTest.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.pmml.models.regression.compiler.factories;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import org.dmg.pmml.DataDictionary;\n+import org.dmg.pmml.DataField;\n+import org.dmg.pmml.MiningField;\n+import org.dmg.pmml.MiningFunction;\n+import org.dmg.pmml.MiningSchema;\n+import org.dmg.pmml.OpType;\n+import org.dmg.pmml.regression.CategoricalPredictor;\n+import org.dmg.pmml.regression.NumericPredictor;\n+import org.dmg.pmml.regression.PredictorTerm;\n+import org.dmg.pmml.regression.RegressionModel;\n+import org.dmg.pmml.regression.RegressionTable;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.kie.pmml.models.regression.model.KiePMMLRegressionModel;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.kie.pmml.compiler.commons.testutils.PMMLModelTestUtils.getCategoricalPredictor;\n+import static org.kie.pmml.compiler.commons.testutils.PMMLModelTestUtils.getDataDictionary;\n+import static org.kie.pmml.compiler.commons.testutils.PMMLModelTestUtils.getDataField;\n+import static org.kie.pmml.compiler.commons.testutils.PMMLModelTestUtils.getMiningField;\n+import static org.kie.pmml.compiler.commons.testutils.PMMLModelTestUtils.getMiningSchema;\n+import static org.kie.pmml.compiler.commons.testutils.PMMLModelTestUtils.getNumericPredictor;\n+import static org.kie.pmml.compiler.commons.testutils.PMMLModelTestUtils.getPredictorTerm;\n+import static org.kie.pmml.compiler.commons.testutils.PMMLModelTestUtils.getRegressionModel;\n+import static org.kie.pmml.compiler.commons.testutils.PMMLModelTestUtils.getRegressionTable;\n+import static org.kie.pmml.models.regression.compiler.factories.KiePMMLRegressionModelFactory.getKiePMMLRegressionModel;\n+\n+@RunWith(Parameterized.class)\n+public class KiePMMLRegressionModelFactoryTest {\n+\n+    private List<RegressionTable> regressionTables;\n+    private List<DataField> dataFields;\n+    private List<MiningField> miningFields;\n+    private MiningField targetMiningField;\n+    private DataDictionary dataDictionary;\n+    private MiningSchema miningSchema;\n+    private RegressionModel regressionModel;\n+\n+    public KiePMMLRegressionModelFactoryTest(String modelName, double tableIntercept, Object tableTargetCategory) {\n+        Random random = new Random();\n+        Set<String> fieldNames = new HashSet<>();\n+        regressionTables = IntStream.range(0, 3).mapToObj(i -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI4NzAzMg==", "bodyText": "Can we uncomment this assert?", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390287032", "createdAt": "2020-03-10T12:46:20Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/test/java/org/kie/pmml/models/regression/compiler/factories/KiePMMLRegressionTableClassificationFactoryTest.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.pmml.models.regression.compiler.factories;\n+\n+import java.nio.file.Files;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.IntStream;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.validator.Java8Validator;\n+import com.github.javaparser.ast.validator.ProblemReporter;\n+import org.dmg.pmml.regression.CategoricalPredictor;\n+import org.dmg.pmml.regression.NumericPredictor;\n+import org.dmg.pmml.regression.PredictorTerm;\n+import org.dmg.pmml.regression.RegressionModel;\n+import org.dmg.pmml.regression.RegressionTable;\n+import org.junit.Test;\n+import org.kie.pmml.commons.model.KiePMMLOutputField;\n+import org.kie.pmml.commons.model.enums.RESULT_FEATURE;\n+import org.kie.pmml.compiler.commons.testutils.PMMLModelTestUtils;\n+import org.kie.pmml.models.regression.model.tuples.KiePMMLTableSourceCategory;\n+import org.kie.test.util.filesystem.FileUtils;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.kie.pmml.compiler.commons.testutils.PMMLModelTestUtils.getCategoricalPredictor;\n+import static org.kie.pmml.compiler.commons.testutils.PMMLModelTestUtils.getNumericPredictor;\n+import static org.kie.pmml.compiler.commons.testutils.PMMLModelTestUtils.getPredictorTerm;\n+\n+public class KiePMMLRegressionTableClassificationFactoryTest {\n+\n+    private List<CategoricalPredictor> categoricalPredictors;\n+    private List<NumericPredictor> numericPredictors;\n+    private List<PredictorTerm> predictorTerms;\n+\n+    @Test\n+    public void getRegressionTableTest() throws Exception {\n+        RegressionTable regressionTableProf = getRegressionTable(3.5, \"professional\");\n+        RegressionTable regressionTableCler = getRegressionTable(27.4, \"clerical\");\n+        List<RegressionTable> regressionTables = Arrays.asList(regressionTableProf, regressionTableCler);\n+        KiePMMLOutputField outputFieldCat = getOutputField(\"CAT-1\", RESULT_FEATURE.PROBABILITY, \"CatPred-1\");\n+        KiePMMLOutputField outputFieldNum = getOutputField(\"NUM-1\", RESULT_FEATURE.PROBABILITY, \"NumPred-0\");\n+        KiePMMLOutputField outputFieldPrev = getOutputField(\"PREV\", RESULT_FEATURE.PREDICTED_VALUE, null);\n+        List<KiePMMLOutputField> outputFields = Arrays.asList(outputFieldCat, outputFieldNum, outputFieldPrev);\n+        Map<String, KiePMMLTableSourceCategory> retrieved = KiePMMLRegressionTableClassificationFactory.getRegressionTables(regressionTables, RegressionModel.NormalizationMethod.SOFTMAX, outputFields, \"targetField\");\n+        assertNotNull(retrieved);\n+        assertEquals(3, retrieved.size());\n+//        assertTrue(retrieved.containsKey(\"KiePMMLRegressionTableClassification1\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI4NzQ0Mg==", "bodyText": "Please remove commented code.", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390287442", "createdAt": "2020-03-10T12:47:08Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-evaluator/src/main/java/org/kie/pmml/models/regression/evaluator/PMMLRegressionModelExecutor.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.evaluator;\n+\n+import java.util.Map;\n+\n+import org.kie.api.pmml.PMML4Result;\n+import org.kie.pmml.commons.model.KiePMMLModel;\n+import org.kie.pmml.commons.model.enums.PMML_MODEL;\n+import org.kie.pmml.evaluator.api.executor.PMMLContext;\n+import org.kie.pmml.evaluator.core.executor.PMMLModelExecutor;\n+\n+import static org.kie.pmml.commons.enums.StatusCode.OK;\n+import static org.kie.pmml.evaluator.core.utils.Converter.getUnwrappedParametersMap;\n+\n+public class PMMLRegressionModelExecutor implements PMMLModelExecutor {\n+\n+    private static final String INVALID_NORMALIZATION_METHOD = \"Invalid Normalization Method %s\";\n+    private static final String EXPECTED_AT_LEAST_TWO_REGRESSION_TABLES_RETRIEVED = \"Expected at least two RegressionTables, retrieved %s\";\n+    private static final String EXPECTED_TWO_REGRESSION_TABLES_RETRIEVED = \"Expected two RegressionTables, retrieved %s\";\n+    private static final String EXPECTED_A_KIE_PMMLREGRESSION_MODEL_RECEIVED = \"Expected a KiePMMLRegressionModel, received %s \";\n+    private static final String TARGET_FIELD_REQUIRED_RETRIEVED = \"TargetField required, retrieved %s\";\n+    private static final String EXPECTED_ONE_REGRESSION_TABLE_RETRIEVED = \"Expected one RegressionTable, retrieved %s\";\n+    private static final String INVALID_TARGET_TYPE = \"Invalid target type %s\";\n+\n+    @Override\n+    public PMML_MODEL getPMMLModelType() {\n+        return PMML_MODEL.REGRESSION_MODEL;\n+    }\n+\n+    @Override\n+    public PMML4Result evaluate(KiePMMLModel model, PMMLContext pmmlContext, String releaseId) {\n+        validate(model);\n+        PMML4Result toReturn = new PMML4Result();\n+        String targetField = model.getTargetField();\n+        final Map<String, Object> requestData = getUnwrappedParametersMap(pmmlContext.getRequestData().getMappedRequestParams());\n+        Object result = model.evaluate(requestData);\n+        toReturn.addResultVariable(targetField, result);\n+        toReturn.setResultObjectName(targetField);\n+        toReturn.setResultCode(OK.getName());\n+        model.getOutputFieldsMap().forEach(toReturn::addResultVariable);\n+        return toReturn;\n+\n+//        final KiePMMLRegressionModel regressionModel = (KiePMMLRegressionModel) model;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI4ODAyOQ==", "bodyText": "We can add some warning into logs. Something like \"Validation was skipped because of backward compatibility\".", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390288029", "createdAt": "2020-03-10T12:48:16Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-evaluator/src/main/java/org/kie/pmml/models/regression/evaluator/PMMLRegressionModelExecutor.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.evaluator;\n+\n+import java.util.Map;\n+\n+import org.kie.api.pmml.PMML4Result;\n+import org.kie.pmml.commons.model.KiePMMLModel;\n+import org.kie.pmml.commons.model.enums.PMML_MODEL;\n+import org.kie.pmml.evaluator.api.executor.PMMLContext;\n+import org.kie.pmml.evaluator.core.executor.PMMLModelExecutor;\n+\n+import static org.kie.pmml.commons.enums.StatusCode.OK;\n+import static org.kie.pmml.evaluator.core.utils.Converter.getUnwrappedParametersMap;\n+\n+public class PMMLRegressionModelExecutor implements PMMLModelExecutor {\n+\n+    private static final String INVALID_NORMALIZATION_METHOD = \"Invalid Normalization Method %s\";\n+    private static final String EXPECTED_AT_LEAST_TWO_REGRESSION_TABLES_RETRIEVED = \"Expected at least two RegressionTables, retrieved %s\";\n+    private static final String EXPECTED_TWO_REGRESSION_TABLES_RETRIEVED = \"Expected two RegressionTables, retrieved %s\";\n+    private static final String EXPECTED_A_KIE_PMMLREGRESSION_MODEL_RECEIVED = \"Expected a KiePMMLRegressionModel, received %s \";\n+    private static final String TARGET_FIELD_REQUIRED_RETRIEVED = \"TargetField required, retrieved %s\";\n+    private static final String EXPECTED_ONE_REGRESSION_TABLE_RETRIEVED = \"Expected one RegressionTable, retrieved %s\";\n+    private static final String INVALID_TARGET_TYPE = \"Invalid target type %s\";\n+\n+    @Override\n+    public PMML_MODEL getPMMLModelType() {\n+        return PMML_MODEL.REGRESSION_MODEL;\n+    }\n+\n+    @Override\n+    public PMML4Result evaluate(KiePMMLModel model, PMMLContext pmmlContext, String releaseId) {\n+        validate(model);\n+        PMML4Result toReturn = new PMML4Result();\n+        String targetField = model.getTargetField();\n+        final Map<String, Object> requestData = getUnwrappedParametersMap(pmmlContext.getRequestData().getMappedRequestParams());\n+        Object result = model.evaluate(requestData);\n+        toReturn.addResultVariable(targetField, result);\n+        toReturn.setResultObjectName(targetField);\n+        toReturn.setResultCode(OK.getName());\n+        model.getOutputFieldsMap().forEach(toReturn::addResultVariable);\n+        return toReturn;\n+\n+//        final KiePMMLRegressionModel regressionModel = (KiePMMLRegressionModel) model;\n+//        return (regressionModel).isRegression() ? evaluateRegression(regressionModel, pmmlContext) : PMMLClassificationModelEvaluator.evaluateClassification(regressionModel, pmmlContext);\n+    }\n+\n+    private void validate(KiePMMLModel toValidate) {\n+        // NO OP - backward compatibility", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI4ODIyNg==", "bodyText": "Again either uncomment or remove this code.", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390288226", "createdAt": "2020-03-10T12:48:37Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-evaluator/src/main/java/org/kie/pmml/models/regression/evaluator/PMMLRegressionModelExecutor.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.evaluator;\n+\n+import java.util.Map;\n+\n+import org.kie.api.pmml.PMML4Result;\n+import org.kie.pmml.commons.model.KiePMMLModel;\n+import org.kie.pmml.commons.model.enums.PMML_MODEL;\n+import org.kie.pmml.evaluator.api.executor.PMMLContext;\n+import org.kie.pmml.evaluator.core.executor.PMMLModelExecutor;\n+\n+import static org.kie.pmml.commons.enums.StatusCode.OK;\n+import static org.kie.pmml.evaluator.core.utils.Converter.getUnwrappedParametersMap;\n+\n+public class PMMLRegressionModelExecutor implements PMMLModelExecutor {\n+\n+    private static final String INVALID_NORMALIZATION_METHOD = \"Invalid Normalization Method %s\";\n+    private static final String EXPECTED_AT_LEAST_TWO_REGRESSION_TABLES_RETRIEVED = \"Expected at least two RegressionTables, retrieved %s\";\n+    private static final String EXPECTED_TWO_REGRESSION_TABLES_RETRIEVED = \"Expected two RegressionTables, retrieved %s\";\n+    private static final String EXPECTED_A_KIE_PMMLREGRESSION_MODEL_RECEIVED = \"Expected a KiePMMLRegressionModel, received %s \";\n+    private static final String TARGET_FIELD_REQUIRED_RETRIEVED = \"TargetField required, retrieved %s\";\n+    private static final String EXPECTED_ONE_REGRESSION_TABLE_RETRIEVED = \"Expected one RegressionTable, retrieved %s\";\n+    private static final String INVALID_TARGET_TYPE = \"Invalid target type %s\";\n+\n+    @Override\n+    public PMML_MODEL getPMMLModelType() {\n+        return PMML_MODEL.REGRESSION_MODEL;\n+    }\n+\n+    @Override\n+    public PMML4Result evaluate(KiePMMLModel model, PMMLContext pmmlContext, String releaseId) {\n+        validate(model);\n+        PMML4Result toReturn = new PMML4Result();\n+        String targetField = model.getTargetField();\n+        final Map<String, Object> requestData = getUnwrappedParametersMap(pmmlContext.getRequestData().getMappedRequestParams());\n+        Object result = model.evaluate(requestData);\n+        toReturn.addResultVariable(targetField, result);\n+        toReturn.setResultObjectName(targetField);\n+        toReturn.setResultCode(OK.getName());\n+        model.getOutputFieldsMap().forEach(toReturn::addResultVariable);\n+        return toReturn;\n+\n+//        final KiePMMLRegressionModel regressionModel = (KiePMMLRegressionModel) model;\n+//        return (regressionModel).isRegression() ? evaluateRegression(regressionModel, pmmlContext) : PMMLClassificationModelEvaluator.evaluateClassification(regressionModel, pmmlContext);\n+    }\n+\n+    private void validate(KiePMMLModel toValidate) {\n+        // NO OP - backward compatibility\n+    }\n+\n+//    private void validate(KiePMMLModel toValidate) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI4ODQ1Mw==", "bodyText": "Please uncomment or remove.", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390288453", "createdAt": "2020-03-10T12:49:02Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-evaluator/src/test/java/org/kie/pmml/models/regression/evaluator/PMMLRegressionModelExecutorTest.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package org.kie.pmml.models.regression.evaluator;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.pmml.commons.model.enums.PMML_MODEL;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+public class PMMLRegressionModelExecutorTest {\n+\n+    private static final String REGRESSION_MODEL_NAME = \"LinReg\";\n+    private static final String REGRESSION_TARGET_FIELD_NAME = \"fld4\";\n+    private static final String CLASSIFICATION_MODEL_NAME = \"Sample for logistic regression\";\n+    private static final String CLASSIFICATION_TARGET_FIELD_NAME = \"jobcat\";\n+    private static final String RELEASE_ID = \"RELEASE_ID\";\n+\n+    private PMMLRegressionModelExecutor executor;\n+\n+    @Before\n+    public void setUp() {\n+        executor = new PMMLRegressionModelExecutor();\n+    }\n+\n+    @Test\n+    public void getPMMLModelType() {\n+        assertEquals(PMML_MODEL.REGRESSION_MODEL, executor.getPMMLModelType());\n+    }\n+\n+//    @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI4OTUwMA==", "bodyText": "Seems suspicious. Don't you forget to uncomment this code?", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390289500", "createdAt": "2020-03-10T12:50:54Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-model/src/main/resources/KiePMMLEvaluateMethodTemplate.tmpl", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.model;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+\n+public class KiePMMLEvaluateMethodTemplate {\n+\n+    private double evaluateNumericWithExponent(double input) {\n+        double coefficient = 5;\n+        double exponent = 2;\n+        // Considering exponent because it is != 1\n+        return Math.pow(input, exponent) * coefficient;\n+    }\n+\n+    private double evaluateNumericWithoutExponent(double input) {\n+        double coefficient = 1;\n+        // Ignoring exponent because it is 1\n+        return input * coefficient;\n+    }\n+\n+    private double evaluateCategorical(Object input) {\n+//        if (Objects.equals(\"x\", input)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI5MDAzOA==", "bodyText": "I don't understand what is going on here.", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r390290038", "createdAt": "2020-03-10T12:51:51Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-model/src/test/java/org/kie/pmml/models/regression/model/KiePMMLRegressionModelTest.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.pmml.models.regression.model;\n+\n+import org.kie.pmml.commons.model.enums.MINING_FUNCTION;\n+import org.kie.pmml.commons.model.enums.OP_TYPE;\n+import org.kie.pmml.models.regression.model.enums.MODEL_TYPE;\n+import org.kie.pmml.models.regression.model.enums.REGRESSION_NORMALIZATION_METHOD;\n+\n+public class KiePMMLRegressionModelTest {\n+\n+    private static final String MODEL_NAME = \"MODEL_NAME\";\n+    private static final String ALGORITHM_NAME = \"multinom\";\n+    private static final MINING_FUNCTION _MINING_FUNCTION = MINING_FUNCTION.REGRESSION;\n+    private static final MODEL_TYPE _MODEL_TYPE = MODEL_TYPE.LINEAR_REGRESSION;\n+    private static final REGRESSION_NORMALIZATION_METHOD _REGRESSION_NORMALIZATION_METHOD = REGRESSION_NORMALIZATION_METHOD.SIMPLEMAX;\n+    private static final boolean SCORABLE = true;\n+    private static final String TARGETFIELD_NAME = \"TARGETFIELD_NAME\";\n+    private static final OP_TYPE _OP_TYPE = OP_TYPE.CONTINUOUS;\n+//\n+//    @Test\n+//    public void buildWithAll() {\n+////        final KiePMMLRegressionModel retrieved = KiePMMLRegressionModel.builder(MODEL_NAME, Collections.emptyList(), _MINING_FUNCTION, REGRESSION_TABLES, _OP_TYPE)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7543d6c235681cdd6561a8bb4e5b520cafa64c7d"}, "originalPosition": 37}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca6078f5e5c81ba44e5765c92a8403eb9345d642", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/ca6078f5e5c81ba44e5765c92a8403eb9345d642", "committedDate": "2020-03-11T11:22:18Z", "message": "[DROOLS-3339] Fix benchmark. Fix model tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e4b1593329e337ba108e511b24b5f38c8b1cf5f", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/8e4b1593329e337ba108e511b24b5f38c8b1cf5f", "committedDate": "2020-03-11T11:22:24Z", "message": "Merge remote-tracking branch 'origin/master' into DROOLS-3339"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c4a838980a18a8428b253ee431087beb471fe8d", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/3c4a838980a18a8428b253ee431087beb471fe8d", "committedDate": "2020-03-11T15:14:20Z", "message": "[DROOLS-3339] Fix as per PR suggestion"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxMzk3MDM0", "url": "https://github.com/kiegroup/drools/pull/2808#pullrequestreview-371397034", "createdAt": "2020-03-09T17:45:47Z", "commit": {"oid": "5a68e7e68b439401a4d7a232b0f86700998e459a"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNzo1MTowNlrOFzzIiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwOTo1MjoxMFrOF19ijA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg1OTQ2Nw==", "bodyText": "Can you please add javadoc and add prefix Abstract?", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r389859467", "createdAt": "2020-03-09T17:51:06Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-new/kie-pmml-commons/src/main/java/org/kie/pmml/commons/model/abstracts/KiePMMLBase.java", "diffHunk": "@@ -15,18 +15,23 @@\n  */\n package org.kie.pmml.commons.model.abstracts;\n \n-import java.io.Serializable;\n-import java.util.Objects;\n+import java.util.Collections;\n+import java.util.List;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.function.Supplier;\n \n-public class KiePMMLIDed implements Serializable {\n+import org.kie.pmml.commons.model.KiePMMLExtension;\n \n-    private static final long serialVersionUID = -2153680489671276928L;\n+public abstract class KiePMMLBase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a68e7e68b439401a4d7a232b0f86700998e459a"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA4MTM4NQ==", "bodyText": "Please remove", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r392081385", "createdAt": "2020-03-13T08:11:09Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/main/java/org/kie/pmml/models/regression/compiler/executor/RegressionModelImplementationProvider.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.compiler.executor;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import org.dmg.pmml.DataDictionary;\n+import org.dmg.pmml.MiningFunction;\n+import org.dmg.pmml.OpType;\n+import org.dmg.pmml.regression.RegressionModel;\n+import org.kie.pmml.commons.exceptions.KiePMMLException;\n+import org.kie.pmml.commons.model.enums.OP_TYPE;\n+import org.kie.pmml.commons.model.enums.PMML_MODEL;\n+import org.kie.pmml.commons.model.tuples.KiePMMLNameOpType;\n+import org.kie.pmml.compiler.api.provider.ModelImplementationProvider;\n+import org.kie.pmml.models.regression.compiler.factories.KiePMMLRegressionModelFactory;\n+import org.kie.pmml.models.regression.model.KiePMMLRegressionModel;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.pmml.compiler.commons.utils.ModelUtils.getOpType;\n+import static org.kie.pmml.compiler.commons.utils.ModelUtils.getTargetFields;\n+//import static org.kie.pmml.models.regression.model.KiePMMLRegressionModel.PMML_MODEL_TYPE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c4a838980a18a8428b253ee431087beb471fe8d"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA5MjYwMA==", "bodyText": "Is it possible? What about an exception or at least a log?", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r392092600", "createdAt": "2020-03-13T08:40:07Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/main/java/org/kie/pmml/models/regression/compiler/factories/KiePMMLRegressionTableClassificationFactory.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.compiler.factories;\n+\n+import java.io.IOException;\n+import java.util.AbstractMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.BooleanLiteralExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.SimpleName;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import org.dmg.pmml.OpType;\n+import org.dmg.pmml.regression.RegressionModel;\n+import org.dmg.pmml.regression.RegressionTable;\n+import org.kie.pmml.commons.exceptions.KiePMMLInternalException;\n+import org.kie.pmml.commons.model.KiePMMLOutputField;\n+import org.kie.pmml.commons.model.enums.OP_TYPE;\n+import org.kie.pmml.models.regression.model.enums.REGRESSION_NORMALIZATION_METHOD;\n+import org.kie.pmml.models.regression.model.tuples.KiePMMLTableSourceCategory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.pmml.models.regression.compiler.factories.KiePMMLRegressionTableRegressionFactory.addMethod;\n+import static org.kie.pmml.models.regression.compiler.factories.KiePMMLRegressionTableRegressionFactory.populateGetTargetCategory;\n+\n+public class KiePMMLRegressionTableClassificationFactory {\n+\n+    public static final String KIE_PMML_REGRESSION_TABLE_CLASSIFICATION_TEMPLATE_JAVA = \"KiePMMLRegressionTableClassificationTemplate.tmpl\";\n+    private static final Logger logger = LoggerFactory.getLogger(KiePMMLRegressionTableClassificationFactory.class.getName());\n+    private static final String MAIN_CLASS_NOT_FOUND = \"Main class not found\";\n+    private static final String KIE_PMML_GET_PROBABILITY_MAP_METHOD_TEMPLATE_JAVA = \"KiePMMLGetProbabilityMapMethodTemplate.tmpl\";\n+    private static final String KIE_PMML_GET_PROBABILITY_MAP_METHOD_TEMPLATE = \"KiePMMLGetProbabilityMapMethodTemplate\";\n+    private static final String KIE_PMML_REGRESSION_TABLE_CLASSIFICATION_TEMPLATE = \"KiePMMLRegressionTableClassificationTemplate\";\n+    private static AtomicInteger classArity = new AtomicInteger(0);\n+    private static CompilationUnit templateEvaluate;\n+    private static CompilationUnit cloneEvaluate;\n+\n+    private KiePMMLRegressionTableClassificationFactory() {\n+        // Avoid instantiation\n+    }\n+\n+    public static Map<String, KiePMMLTableSourceCategory> getRegressionTables(final List<RegressionTable> regressionTables, final RegressionModel.NormalizationMethod normalizationMethod, final OpType opType, final List<KiePMMLOutputField> outputFields, final String targetField) throws IOException {\n+        logger.debug(\"getRegressionTables {}\", regressionTables);\n+        CompilationUnit templateCU = StaticJavaParser.parseResource(KIE_PMML_REGRESSION_TABLE_CLASSIFICATION_TEMPLATE_JAVA);\n+        Map<String, KiePMMLTableSourceCategory> toReturn = KiePMMLRegressionTableRegressionFactory.getRegressionTables(regressionTables, RegressionModel.NormalizationMethod.NONE, targetField);\n+        Map.Entry<String, String> regressionTableEntry = getRegressionTable(templateCU, toReturn, normalizationMethod, opType, outputFields, targetField);\n+        toReturn.put(regressionTableEntry.getKey(), new KiePMMLTableSourceCategory(regressionTableEntry.getValue(), \"\"));\n+        return toReturn;\n+    }\n+\n+    public static Map.Entry<String, String> getRegressionTable(final CompilationUnit templateCU, final Map<String, KiePMMLTableSourceCategory> regressionTablesMap, final RegressionModel.NormalizationMethod normalizationMethod, final OpType opType, final List<KiePMMLOutputField> outputFields, final String targetField) throws IOException {\n+        logger.debug(\"getRegressionTable {}\", regressionTablesMap);\n+        CompilationUnit cloneCU = templateCU.clone();\n+        final REGRESSION_NORMALIZATION_METHOD regressionNormalizationMethod = REGRESSION_NORMALIZATION_METHOD.byName(normalizationMethod.value());\n+        final OP_TYPE op_type = OP_TYPE.byName(opType.value());\n+        ClassOrInterfaceDeclaration tableTemplate = cloneCU.getClassByName(KIE_PMML_REGRESSION_TABLE_CLASSIFICATION_TEMPLATE)\n+                .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+        String className = \"KiePMMLRegressionTableClassification\" + classArity.addAndGet(1);\n+        tableTemplate.setName(className);\n+        populateGetProbabilityMapMethod(normalizationMethod, tableTemplate);\n+        populateOutputFieldsMap(tableTemplate, outputFields);\n+        populateIsBinaryMethod(opType, regressionTablesMap.size(), tableTemplate);\n+        tableTemplate.getDefaultConstructor().ifPresent(constructorDeclaration -> {\n+            setConstructor(constructorDeclaration, tableTemplate.getName(), targetField, regressionNormalizationMethod, op_type);\n+            addMapPopulation(constructorDeclaration.getBody(), regressionTablesMap);\n+        });\n+        populateGetTargetCategory(tableTemplate, null);\n+        return new AbstractMap.SimpleEntry<>(className, cloneCU.toString());\n+    }\n+\n+    /**\n+     * Set the <b>targetField</b> values inside the constructor\n+     * @param constructorDeclaration\n+     * @param generatedClassName\n+     * @param targetField\n+     */\n+    private static void setConstructor(final ConstructorDeclaration constructorDeclaration, final SimpleName generatedClassName, final String targetField, final REGRESSION_NORMALIZATION_METHOD regressionNormalizationMethod, final OP_TYPE opType) {\n+        constructorDeclaration.setName(generatedClassName);\n+        final BlockStmt body = constructorDeclaration.getBody();\n+        final List<AssignExpr> assignExprs = body.findAll(AssignExpr.class);\n+        assignExprs.forEach(assignExpr -> {\n+            final String propertyName = assignExpr.getTarget().asNameExpr().getNameAsString();\n+            switch (propertyName) {\n+                case \"targetField\":\n+                    assignExpr.setValue(new StringLiteralExpr(targetField));\n+                    break;\n+                case \"regressionNormalizationMethod\":\n+                    assignExpr.setValue(new NameExpr(regressionNormalizationMethod.getClass().getSimpleName() + \".\" + regressionNormalizationMethod.name()));\n+                    break;\n+                case \"opType\":\n+                    assignExpr.setValue(new NameExpr(opType.getClass().getSimpleName() + \".\" + opType.name()));\n+                    break;\n+                default:\n+                    // NOOP", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c4a838980a18a8428b253ee431087beb471fe8d"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA5MjY4OA==", "bodyText": "Same comment", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r392092688", "createdAt": "2020-03-13T08:40:19Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/main/java/org/kie/pmml/models/regression/compiler/factories/KiePMMLRegressionTableClassificationFactory.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.compiler.factories;\n+\n+import java.io.IOException;\n+import java.util.AbstractMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.BooleanLiteralExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.SimpleName;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import org.dmg.pmml.OpType;\n+import org.dmg.pmml.regression.RegressionModel;\n+import org.dmg.pmml.regression.RegressionTable;\n+import org.kie.pmml.commons.exceptions.KiePMMLInternalException;\n+import org.kie.pmml.commons.model.KiePMMLOutputField;\n+import org.kie.pmml.commons.model.enums.OP_TYPE;\n+import org.kie.pmml.models.regression.model.enums.REGRESSION_NORMALIZATION_METHOD;\n+import org.kie.pmml.models.regression.model.tuples.KiePMMLTableSourceCategory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.pmml.models.regression.compiler.factories.KiePMMLRegressionTableRegressionFactory.addMethod;\n+import static org.kie.pmml.models.regression.compiler.factories.KiePMMLRegressionTableRegressionFactory.populateGetTargetCategory;\n+\n+public class KiePMMLRegressionTableClassificationFactory {\n+\n+    public static final String KIE_PMML_REGRESSION_TABLE_CLASSIFICATION_TEMPLATE_JAVA = \"KiePMMLRegressionTableClassificationTemplate.tmpl\";\n+    private static final Logger logger = LoggerFactory.getLogger(KiePMMLRegressionTableClassificationFactory.class.getName());\n+    private static final String MAIN_CLASS_NOT_FOUND = \"Main class not found\";\n+    private static final String KIE_PMML_GET_PROBABILITY_MAP_METHOD_TEMPLATE_JAVA = \"KiePMMLGetProbabilityMapMethodTemplate.tmpl\";\n+    private static final String KIE_PMML_GET_PROBABILITY_MAP_METHOD_TEMPLATE = \"KiePMMLGetProbabilityMapMethodTemplate\";\n+    private static final String KIE_PMML_REGRESSION_TABLE_CLASSIFICATION_TEMPLATE = \"KiePMMLRegressionTableClassificationTemplate\";\n+    private static AtomicInteger classArity = new AtomicInteger(0);\n+    private static CompilationUnit templateEvaluate;\n+    private static CompilationUnit cloneEvaluate;\n+\n+    private KiePMMLRegressionTableClassificationFactory() {\n+        // Avoid instantiation\n+    }\n+\n+    public static Map<String, KiePMMLTableSourceCategory> getRegressionTables(final List<RegressionTable> regressionTables, final RegressionModel.NormalizationMethod normalizationMethod, final OpType opType, final List<KiePMMLOutputField> outputFields, final String targetField) throws IOException {\n+        logger.debug(\"getRegressionTables {}\", regressionTables);\n+        CompilationUnit templateCU = StaticJavaParser.parseResource(KIE_PMML_REGRESSION_TABLE_CLASSIFICATION_TEMPLATE_JAVA);\n+        Map<String, KiePMMLTableSourceCategory> toReturn = KiePMMLRegressionTableRegressionFactory.getRegressionTables(regressionTables, RegressionModel.NormalizationMethod.NONE, targetField);\n+        Map.Entry<String, String> regressionTableEntry = getRegressionTable(templateCU, toReturn, normalizationMethod, opType, outputFields, targetField);\n+        toReturn.put(regressionTableEntry.getKey(), new KiePMMLTableSourceCategory(regressionTableEntry.getValue(), \"\"));\n+        return toReturn;\n+    }\n+\n+    public static Map.Entry<String, String> getRegressionTable(final CompilationUnit templateCU, final Map<String, KiePMMLTableSourceCategory> regressionTablesMap, final RegressionModel.NormalizationMethod normalizationMethod, final OpType opType, final List<KiePMMLOutputField> outputFields, final String targetField) throws IOException {\n+        logger.debug(\"getRegressionTable {}\", regressionTablesMap);\n+        CompilationUnit cloneCU = templateCU.clone();\n+        final REGRESSION_NORMALIZATION_METHOD regressionNormalizationMethod = REGRESSION_NORMALIZATION_METHOD.byName(normalizationMethod.value());\n+        final OP_TYPE op_type = OP_TYPE.byName(opType.value());\n+        ClassOrInterfaceDeclaration tableTemplate = cloneCU.getClassByName(KIE_PMML_REGRESSION_TABLE_CLASSIFICATION_TEMPLATE)\n+                .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+        String className = \"KiePMMLRegressionTableClassification\" + classArity.addAndGet(1);\n+        tableTemplate.setName(className);\n+        populateGetProbabilityMapMethod(normalizationMethod, tableTemplate);\n+        populateOutputFieldsMap(tableTemplate, outputFields);\n+        populateIsBinaryMethod(opType, regressionTablesMap.size(), tableTemplate);\n+        tableTemplate.getDefaultConstructor().ifPresent(constructorDeclaration -> {\n+            setConstructor(constructorDeclaration, tableTemplate.getName(), targetField, regressionNormalizationMethod, op_type);\n+            addMapPopulation(constructorDeclaration.getBody(), regressionTablesMap);\n+        });\n+        populateGetTargetCategory(tableTemplate, null);\n+        return new AbstractMap.SimpleEntry<>(className, cloneCU.toString());\n+    }\n+\n+    /**\n+     * Set the <b>targetField</b> values inside the constructor\n+     * @param constructorDeclaration\n+     * @param generatedClassName\n+     * @param targetField\n+     */\n+    private static void setConstructor(final ConstructorDeclaration constructorDeclaration, final SimpleName generatedClassName, final String targetField, final REGRESSION_NORMALIZATION_METHOD regressionNormalizationMethod, final OP_TYPE opType) {\n+        constructorDeclaration.setName(generatedClassName);\n+        final BlockStmt body = constructorDeclaration.getBody();\n+        final List<AssignExpr> assignExprs = body.findAll(AssignExpr.class);\n+        assignExprs.forEach(assignExpr -> {\n+            final String propertyName = assignExpr.getTarget().asNameExpr().getNameAsString();\n+            switch (propertyName) {\n+                case \"targetField\":\n+                    assignExpr.setValue(new StringLiteralExpr(targetField));\n+                    break;\n+                case \"regressionNormalizationMethod\":\n+                    assignExpr.setValue(new NameExpr(regressionNormalizationMethod.getClass().getSimpleName() + \".\" + regressionNormalizationMethod.name()));\n+                    break;\n+                case \"opType\":\n+                    assignExpr.setValue(new NameExpr(opType.getClass().getSimpleName() + \".\" + opType.name()));\n+                    break;\n+                default:\n+                    // NOOP\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Add entries <b>category/KiePMMLRegressionTable</b> inside the constructor\n+     * @param body\n+     * @param regressionTablesMap\n+     */\n+    private static void addMapPopulation(final BlockStmt body, final Map<String, KiePMMLTableSourceCategory> regressionTablesMap) {\n+        regressionTablesMap.forEach((className, tableSourceCategory) -> {\n+            ObjectCreationExpr objectCreationExpr = new ObjectCreationExpr();\n+            objectCreationExpr.setType(className);\n+            NodeList<Expression> expressions = NodeList.nodeList(new StringLiteralExpr(tableSourceCategory.getCategory()), objectCreationExpr);\n+            body.addStatement(new MethodCallExpr(new NameExpr(\"categoryTableMap\"), \"put\", expressions));\n+        });\n+    }\n+\n+    /**\n+     * Add entries <b>output field/output value</b> inside <b>populateOutputFieldsMap</b> method\n+     * @param tableTemplate\n+     * @param outputFields\n+     */\n+    private static void populateOutputFieldsMap(final ClassOrInterfaceDeclaration tableTemplate, final List<KiePMMLOutputField> outputFields) {\n+        final MethodDeclaration methodDeclaration = tableTemplate.getMethodsByName(\"populateOutputFieldsMap\").get(0);\n+        methodDeclaration.getBody().ifPresent(body -> populateOutputFieldsMap(body, outputFields));\n+    }\n+\n+    /**\n+     * Add entries <b>output field/output value</b> inside <b>populateOutputFieldsMap</b> method\n+     * @param body\n+     * @param outputFields\n+     */\n+    private static void populateOutputFieldsMap(final BlockStmt body, final List<KiePMMLOutputField> outputFields) {\n+        outputFields.forEach(outputField -> {\n+            StringLiteralExpr key = new StringLiteralExpr(outputField.getName());\n+            Expression value = null;\n+            switch (outputField.getResultFeature()) {\n+                case PREDICTED_VALUE:\n+                    value = new MethodCallExpr(new NameExpr(\"predictedEntry\"), \"getKey\");\n+                    break;\n+                case PROBABILITY:\n+                    if (outputField.getValue() != null) {\n+                        NodeList<Expression> expressions = NodeList.nodeList(new StringLiteralExpr(outputField.getValue().toString()));\n+                        value = new MethodCallExpr(new NameExpr(\"probabilityMap\"), \"get\", expressions);\n+                    } else if (outputField.getTargetField().isPresent()) {\n+                        NodeList<Expression> expressions = NodeList.nodeList(new StringLiteralExpr(outputField.getTargetField().get()));\n+                        value = new MethodCallExpr(new NameExpr(\"probabilityMap\"), \"get\", expressions);\n+                    }\n+                    break;\n+                default:\n+                    // All other possibilities not analyzed, yet", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c4a838980a18a8428b253ee431087beb471fe8d"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA5NDEyNw==", "bodyText": "Same comment", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r392094127", "createdAt": "2020-03-13T08:43:24Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/main/java/org/kie/pmml/models/regression/compiler/factories/KiePMMLRegressionTableRegressionFactory.java", "diffHunk": "@@ -0,0 +1,410 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.compiler.factories;\n+\n+import java.io.IOException;\n+import java.util.AbstractMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.DoubleLiteralExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.MethodReferenceExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.expr.ThisExpr;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.IfStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import org.dmg.pmml.regression.CategoricalPredictor;\n+import org.dmg.pmml.regression.NumericPredictor;\n+import org.dmg.pmml.regression.PredictorTerm;\n+import org.dmg.pmml.regression.RegressionModel;\n+import org.dmg.pmml.regression.RegressionTable;\n+import org.kie.pmml.models.regression.model.tuples.KiePMMLTableSourceCategory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+\n+public class KiePMMLRegressionTableRegressionFactory {\n+\n+    public static final String KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE_JAVA = \"KiePMMLRegressionTableRegressionTemplate.tmpl\";\n+    private static final Logger logger = LoggerFactory.getLogger(KiePMMLRegressionTableRegressionFactory.class.getName());\n+    private static final String MAIN_CLASS_NOT_FOUND = \"Main class not found\";\n+    private static final String KIE_PMML_EVALUATE_METHOD_TEMPLATE_JAVA = \"KiePMMLEvaluateMethodTemplate.tmpl\";\n+    private static final String KIE_PMML_EVALUATE_METHOD_TEMPLATE = \"KiePMMLEvaluateMethodTemplate\";\n+    private static final String KIE_PMML_UPDATE_RESULT_METHOD_TEMPLATE_JAVA = \"KiePMMLUpdateResultMethodTemplate.tmpl\";\n+    private static final String KIE_PMML_UPDATE_RESULT_METHOD_TEMPLATE = \"KiePMMLUpdateResultMethodTemplate\";\n+    private static final String KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE = \"KiePMMLRegressionTableRegressionTemplate\";\n+    private static final String COEFFICIENT = \"coefficient\";\n+    private static final String EXPONENT = \"exponent\";\n+    private static AtomicInteger classArity = new AtomicInteger(0);\n+    private static AtomicInteger predictorsArity = new AtomicInteger(0);\n+    private static CompilationUnit templateEvaluate;\n+    private static CompilationUnit cloneEvaluate;\n+\n+    private KiePMMLRegressionTableRegressionFactory() {\n+        // Avoid instantiation\n+    }\n+\n+    public static Map<String, KiePMMLTableSourceCategory> getRegressionTables(final List<RegressionTable> regressionTables, final RegressionModel.NormalizationMethod normalizationMethod, final String targetField) throws IOException {\n+        logger.debug(\"getRegressionTables {}\", regressionTables);\n+        CompilationUnit templateCU = StaticJavaParser.parseResource(KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE_JAVA);\n+        Map<String, KiePMMLTableSourceCategory> toReturn = new HashMap<>();\n+        for (RegressionTable regressionTable : regressionTables) {\n+            final Map.Entry<String, String> regressionTableEntry = getRegressionTable(templateCU, regressionTable, normalizationMethod, targetField);\n+            String targetCategory = regressionTable.getTargetCategory() != null ? regressionTable.getTargetCategory().toString() : \"\";\n+            toReturn.put(regressionTableEntry.getKey(), new KiePMMLTableSourceCategory(regressionTableEntry.getValue(), targetCategory));\n+        }\n+        return toReturn;\n+    }\n+\n+    public static AbstractMap.Entry<String, String> getRegressionTable(final CompilationUnit templateCU, final RegressionTable regressionTable, final RegressionModel.NormalizationMethod normalizationMethod, final String targetField) {\n+        logger.debug(\"getRegressionTable {}\", regressionTable);\n+        CompilationUnit cloneCU = templateCU.clone();\n+        ClassOrInterfaceDeclaration tableTemplate = cloneCU.getClassByName(KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE)\n+                .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+        String className = \"KiePMMLRegressionTableRegression\" + classArity.addAndGet(1);\n+        tableTemplate.setName(className);\n+        setConstructor(regressionTable, tableTemplate, targetField);\n+        final Map<String, MethodDeclaration> numericPredictorsMap = addNumericPredictors(regressionTable.getNumericPredictors(), tableTemplate);\n+        final Map<String, MethodDeclaration> categoricalPredictorsMap = addCategoricalPredictors(regressionTable.getCategoricalPredictors(), tableTemplate);\n+        final Map<String, MethodDeclaration> predictorTermsMap = addPredictorTerms(regressionTable.getPredictorTerms(), tableTemplate);\n+        tableTemplate.getDefaultConstructor().ifPresent(constructorDeclaration -> {\n+            final BlockStmt body = constructorDeclaration.getBody();\n+            addMapPopulation(numericPredictorsMap, body, \"numericFunctionMap\");\n+            addMapPopulation(categoricalPredictorsMap, body, \"categoricalFunctionMap\");\n+            addMapPopulation(predictorTermsMap, body, \"predictorTermsFunctionMap\");\n+        });\n+        populateGetTargetCategory(tableTemplate, regressionTable.getTargetCategory());\n+        populateUpdateResult(tableTemplate, normalizationMethod);\n+        return new AbstractMap.SimpleEntry<>(className, cloneCU.toString());\n+    }\n+\n+    /**\n+     * Add entries <b>fieldName/function</b> inside the constructor\n+     * @param toAdd\n+     * @param body\n+     * @param mapName\n+     */\n+    private static void addMapPopulation(final Map<String, MethodDeclaration> toAdd, final BlockStmt body, final String mapName) {\n+        toAdd.forEach((s, methodDeclaration) -> {\n+            MethodReferenceExpr methodReferenceExpr = new MethodReferenceExpr();\n+            methodReferenceExpr.setScope(new ThisExpr());\n+            methodReferenceExpr.setIdentifier(methodDeclaration.getNameAsString());\n+            NodeList<Expression> expressions = NodeList.nodeList(new StringLiteralExpr(s), methodReferenceExpr);\n+            body.addStatement(new MethodCallExpr(new NameExpr(mapName), \"put\", expressions));\n+        });\n+    }\n+\n+    /**\n+     * Set the <b>intercept</b> and <b>targetField</b> values inside the constructor\n+     * @param regressionTable\n+     * @param tableTemplate\n+     * @param targetField\n+     */\n+    private static void setConstructor(final RegressionTable regressionTable, final ClassOrInterfaceDeclaration tableTemplate, final String targetField) {\n+        tableTemplate.getDefaultConstructor().ifPresent(constructorDeclaration -> {\n+            constructorDeclaration.setName(tableTemplate.getName());\n+            final BlockStmt body = constructorDeclaration.getBody();\n+            final List<AssignExpr> assignExprs = body.findAll(AssignExpr.class);\n+            assignExprs.forEach(assignExpr -> {\n+                if (assignExpr.getTarget().asNameExpr().getNameAsString().equals(\"intercept\")) {\n+                    assignExpr.setValue(new DoubleLiteralExpr(String.valueOf(regressionTable.getIntercept().doubleValue())));\n+                } else if (assignExpr.getTarget().asNameExpr().getNameAsString().equals(\"targetField\")) {\n+                    assignExpr.setValue(new StringLiteralExpr(targetField));\n+                }\n+            });\n+        });\n+    }\n+\n+    /**\n+     * Add <b>NumericPredictor</b>s <code>MethodDeclaration</code> to the class\n+     * @param numericPredictors\n+     * @param tableTemplate\n+     * @return\n+     */\n+    private static Map<String, MethodDeclaration> addNumericPredictors(final List<NumericPredictor> numericPredictors, final ClassOrInterfaceDeclaration tableTemplate) {\n+        predictorsArity.set(0);\n+        return numericPredictors.stream()\n+                .map(numericPredictor -> new AbstractMap.SimpleEntry<>(numericPredictor.getName().getValue(),\n+                                                                       addNumericPredictor(numericPredictor, tableTemplate, predictorsArity.addAndGet(1))))\n+                .filter(entry -> entry.getValue().isPresent())\n+                .collect(Collectors.toMap(AbstractMap.SimpleEntry::getKey,\n+                                          entry -> entry.getValue().get()));\n+    }\n+\n+    /**\n+     * Add a <b>NumericPredictor</b> <code>MethodDeclaration</code> to the class\n+     * @param numericPredictor\n+     * @param tableTemplate\n+     * @param predictorArity\n+     * @return\n+     */\n+    private static Optional<MethodDeclaration> addNumericPredictor(final NumericPredictor numericPredictor, final ClassOrInterfaceDeclaration tableTemplate, int predictorArity) {\n+        try {\n+            templateEvaluate = StaticJavaParser.parseResource(KIE_PMML_EVALUATE_METHOD_TEMPLATE_JAVA);\n+            cloneEvaluate = templateEvaluate.clone();\n+            ClassOrInterfaceDeclaration evaluateTemplateClass = cloneEvaluate.getClassByName(KIE_PMML_EVALUATE_METHOD_TEMPLATE)\n+                    .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+            MethodDeclaration methodTemplate;\n+            if (Objects.equals(1, numericPredictor.getExponent())) {\n+                methodTemplate = getNumericPredictorWithoutExponentTemplate(numericPredictor, evaluateTemplateClass);\n+            } else {\n+                methodTemplate = getNumericPredictorWithExponentTemplate(numericPredictor, evaluateTemplateClass);\n+            }\n+            return addMethod(methodTemplate, tableTemplate, \"evaluateNumericPredictor\" + predictorArity);\n+        } catch (Exception e) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * Add a <b>NumericPredictor</b> <code>MethodDeclaration</code> with <b>exponent != 1</b> to the class\n+     * @param numericPredictor\n+     * @param evaluateTemplateClass\n+     * @return\n+     */\n+    private static MethodDeclaration getNumericPredictorWithExponentTemplate(final NumericPredictor numericPredictor, final ClassOrInterfaceDeclaration evaluateTemplateClass) {\n+        final MethodDeclaration toReturn = evaluateTemplateClass.getMethodsByName(\"evaluateNumericWithExponent\").get(0);\n+        toReturn.getBody().ifPresent(body -> {\n+            final List<VariableDeclarator> variableDeclarators = body.findAll(VariableDeclarator.class);\n+            variableDeclarators.forEach(variableDeclarator -> {\n+                String initializer = null;\n+                if (variableDeclarator.getName().asString().equals(COEFFICIENT)) {\n+                    initializer = String.valueOf(numericPredictor.getCoefficient().doubleValue());\n+                } else if (variableDeclarator.getName().asString().equals(EXPONENT)) {\n+                    initializer = String.valueOf(numericPredictor.getExponent().doubleValue());\n+                }\n+                if (initializer != null) {\n+                    variableDeclarator.setInitializer(initializer);\n+                }\n+            });\n+        });\n+        return toReturn;\n+    }\n+\n+    /**\n+     * Add a <b>NumericPredictor</b> <code>MethodDeclaration</code> with <b>exponent == 1</b> to the class\n+     * @param numericPredictor\n+     * @param evaluateTemplateClass\n+     * @return\n+     */\n+    private static MethodDeclaration getNumericPredictorWithoutExponentTemplate(final NumericPredictor numericPredictor, final ClassOrInterfaceDeclaration evaluateTemplateClass) {\n+        final MethodDeclaration toReturn = evaluateTemplateClass.getMethodsByName(\"evaluateNumericWithoutExponent\").get(0);\n+        toReturn.getBody().ifPresent(body -> {\n+            final List<VariableDeclarator> variableDeclarators = body.findAll(VariableDeclarator.class);\n+            variableDeclarators.stream().filter(variableDeclarator -> variableDeclarator.getName().asString().equals(COEFFICIENT))\n+                    .forEach(variableDeclarator -> variableDeclarator.setInitializer(String.valueOf(numericPredictor.getCoefficient().doubleValue())));\n+        });\n+        return toReturn;\n+    }\n+\n+    /**\n+     * Add <b>CategoricalPredictor</b>s <code>MethodDeclaration</code> to the class\n+     * @param categoricalPredictors\n+     * @param tableTemplate\n+     * @return\n+     */\n+    private static Map<String, MethodDeclaration> addCategoricalPredictors(final List<CategoricalPredictor> categoricalPredictors, final ClassOrInterfaceDeclaration tableTemplate) {\n+        predictorsArity.set(0);\n+        final Map<String, List<CategoricalPredictor>> groupedCollectors = categoricalPredictors.stream()\n+                .collect(groupingBy(categoricalPredictor -> categoricalPredictor.getField().getValue()));\n+        return groupedCollectors.entrySet().stream()\n+                .map(entry -> new AbstractMap.SimpleEntry<>(entry.getKey(),\n+                                                            addGroupedCategoricalPredictor(entry.getValue(), tableTemplate, predictorsArity.addAndGet(1))))\n+                .filter(entry -> entry.getValue().isPresent())\n+                .collect(Collectors.toMap(AbstractMap.SimpleEntry::getKey,\n+                                          entry -> entry.getValue().get()));\n+    }\n+\n+    /**\n+     * Add a <b>CategoricalPredictor</b> <code>MethodDeclaration</code> to the class\n+     * @param categoricalPredictors\n+     * @param tableTemplate\n+     * @param predictorArity\n+     * @return\n+     */\n+    private static Optional<MethodDeclaration> addGroupedCategoricalPredictor(final List<CategoricalPredictor> categoricalPredictors, final ClassOrInterfaceDeclaration tableTemplate, int predictorArity) {\n+        try {\n+            templateEvaluate = StaticJavaParser.parseResource(KIE_PMML_EVALUATE_METHOD_TEMPLATE_JAVA);\n+            cloneEvaluate = templateEvaluate.clone();\n+            ClassOrInterfaceDeclaration evaluateTemplateClass = cloneEvaluate.getClassByName(KIE_PMML_EVALUATE_METHOD_TEMPLATE)\n+                    .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+            MethodDeclaration methodTemplate = evaluateTemplateClass.getMethodsByName(\"evaluateCategorical\").get(0);\n+            methodTemplate.getBody().ifPresent(body -> {\n+                IfStmt ifStmt = new IfStmt();\n+                for (int i = 0; i < categoricalPredictors.size(); i++) {\n+                    CategoricalPredictor categoricalPredictor = categoricalPredictors.get(i);\n+                    Expression lhe;\n+                    if (categoricalPredictor.getValue() instanceof String) {\n+                        lhe = new StringLiteralExpr((String) categoricalPredictor.getValue());\n+                    } else {\n+                        lhe = new NameExpr(categoricalPredictor.getValue().toString());\n+                    }\n+                    NodeList<Expression> expressions = NodeList.nodeList(lhe, new NameExpr(\"input\"));\n+                    MethodCallExpr conditionExpr = new MethodCallExpr(new NameExpr(\"Objects\"), \"equals\", expressions);\n+                    if (i == 0) {\n+                        ifStmt.setCondition(conditionExpr);\n+                        ifStmt.setThenStmt(new ReturnStmt(new DoubleLiteralExpr(String.valueOf(categoricalPredictor.getCoefficient()))));\n+                        body.addStatement(ifStmt);\n+                    } else {\n+                        IfStmt elseIf = new IfStmt();\n+                        elseIf.setCondition(conditionExpr);\n+                        elseIf.setThenStmt(new ReturnStmt(new DoubleLiteralExpr(String.valueOf(categoricalPredictor.getCoefficient()))));\n+                        ifStmt.setElseStmt(elseIf);\n+                        ifStmt = elseIf;\n+                    }\n+                }\n+                ifStmt.setElseStmt(new ReturnStmt(new DoubleLiteralExpr(\"0.0\")));\n+            });\n+            return addMethod(methodTemplate, tableTemplate, \"evaluateCategoricalPredictor\" + predictorArity);\n+        } catch (Exception e) {\n+            //\n+            return Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * Add <b>PredictorTerm</b>s <code>MethodDeclaration</code> to the class\n+     * @param predictorTerms\n+     * @param tableTemplate\n+     * @return\n+     */\n+    private static Map<String, MethodDeclaration> addPredictorTerms(final List<PredictorTerm> predictorTerms, final ClassOrInterfaceDeclaration tableTemplate) {\n+        predictorsArity.set(0);\n+        return predictorTerms.stream()\n+                .map(predictorTerm -> {\n+                    int arity = predictorsArity.addAndGet(1);\n+                    return new AbstractMap.SimpleEntry<>(predictorTerm.getName() != null ? predictorTerm.getName().getValue() : \"predictorTerm\" + arity,\n+                                                         addPredictorTerm(predictorTerm, tableTemplate, arity));\n+                })\n+                .filter(entry -> entry.getValue().isPresent())\n+                .collect(Collectors.toMap(AbstractMap.SimpleEntry::getKey,\n+                                          entry -> entry.getValue().get()));\n+    }\n+\n+    /**\n+     * Add a <b>PredictorTerm</b> <code>MethodDeclaration</code> to the class\n+     * @param predictorTerm\n+     * @param tableTemplate\n+     * @param predictorArity\n+     * @return\n+     */\n+    private static Optional<MethodDeclaration> addPredictorTerm(final PredictorTerm predictorTerm, final ClassOrInterfaceDeclaration tableTemplate, int predictorArity) {\n+        try {\n+            templateEvaluate = StaticJavaParser.parseResource(KIE_PMML_EVALUATE_METHOD_TEMPLATE_JAVA);\n+            cloneEvaluate = templateEvaluate.clone();\n+            ClassOrInterfaceDeclaration evaluateTemplateClass = cloneEvaluate.getClassByName(KIE_PMML_EVALUATE_METHOD_TEMPLATE)\n+                    .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+            MethodDeclaration methodTemplate = evaluateTemplateClass.getMethodsByName(\"evaluatePredictor\").get(0);\n+            methodTemplate.getBody().ifPresent(body -> {\n+                final List<VariableDeclarator> variableDeclarators = body.findAll(VariableDeclarator.class);\n+                variableDeclarators.forEach(variableDeclarator -> {\n+                    if (variableDeclarator.getName().asString().equals(\"fieldRefs\")) {\n+                        final List<Expression> nodeList = predictorTerm.getFieldRefs().stream()\n+                                .map(fieldRef -> new StringLiteralExpr(fieldRef.getField().getValue()))\n+                                .collect(Collectors.toList());\n+                        NodeList<Expression> expressions = NodeList.nodeList(nodeList);\n+                        MethodCallExpr methodCallExpr = new MethodCallExpr(new NameExpr(\"Arrays\"), \"asList\", expressions);\n+                        variableDeclarator.setInitializer(methodCallExpr);\n+                    } else if (variableDeclarator.getName().asString().equals(COEFFICIENT)) {\n+                        variableDeclarator.setInitializer(String.valueOf(predictorTerm.getCoefficient().doubleValue()));\n+                    }\n+                });\n+            });\n+            return addMethod(methodTemplate, tableTemplate, \"evaluatePredictorTerm\" + predictorArity);\n+        } catch (Exception e) {\n+            //", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c4a838980a18a8428b253ee431087beb471fe8d"}, "originalPosition": 345}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA5NDIxMA==", "bodyText": "Same comment", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r392094210", "createdAt": "2020-03-13T08:43:35Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/main/java/org/kie/pmml/models/regression/compiler/factories/KiePMMLRegressionTableRegressionFactory.java", "diffHunk": "@@ -0,0 +1,410 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.compiler.factories;\n+\n+import java.io.IOException;\n+import java.util.AbstractMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.DoubleLiteralExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.MethodReferenceExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.expr.ThisExpr;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.IfStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import org.dmg.pmml.regression.CategoricalPredictor;\n+import org.dmg.pmml.regression.NumericPredictor;\n+import org.dmg.pmml.regression.PredictorTerm;\n+import org.dmg.pmml.regression.RegressionModel;\n+import org.dmg.pmml.regression.RegressionTable;\n+import org.kie.pmml.models.regression.model.tuples.KiePMMLTableSourceCategory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+\n+public class KiePMMLRegressionTableRegressionFactory {\n+\n+    public static final String KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE_JAVA = \"KiePMMLRegressionTableRegressionTemplate.tmpl\";\n+    private static final Logger logger = LoggerFactory.getLogger(KiePMMLRegressionTableRegressionFactory.class.getName());\n+    private static final String MAIN_CLASS_NOT_FOUND = \"Main class not found\";\n+    private static final String KIE_PMML_EVALUATE_METHOD_TEMPLATE_JAVA = \"KiePMMLEvaluateMethodTemplate.tmpl\";\n+    private static final String KIE_PMML_EVALUATE_METHOD_TEMPLATE = \"KiePMMLEvaluateMethodTemplate\";\n+    private static final String KIE_PMML_UPDATE_RESULT_METHOD_TEMPLATE_JAVA = \"KiePMMLUpdateResultMethodTemplate.tmpl\";\n+    private static final String KIE_PMML_UPDATE_RESULT_METHOD_TEMPLATE = \"KiePMMLUpdateResultMethodTemplate\";\n+    private static final String KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE = \"KiePMMLRegressionTableRegressionTemplate\";\n+    private static final String COEFFICIENT = \"coefficient\";\n+    private static final String EXPONENT = \"exponent\";\n+    private static AtomicInteger classArity = new AtomicInteger(0);\n+    private static AtomicInteger predictorsArity = new AtomicInteger(0);\n+    private static CompilationUnit templateEvaluate;\n+    private static CompilationUnit cloneEvaluate;\n+\n+    private KiePMMLRegressionTableRegressionFactory() {\n+        // Avoid instantiation\n+    }\n+\n+    public static Map<String, KiePMMLTableSourceCategory> getRegressionTables(final List<RegressionTable> regressionTables, final RegressionModel.NormalizationMethod normalizationMethod, final String targetField) throws IOException {\n+        logger.debug(\"getRegressionTables {}\", regressionTables);\n+        CompilationUnit templateCU = StaticJavaParser.parseResource(KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE_JAVA);\n+        Map<String, KiePMMLTableSourceCategory> toReturn = new HashMap<>();\n+        for (RegressionTable regressionTable : regressionTables) {\n+            final Map.Entry<String, String> regressionTableEntry = getRegressionTable(templateCU, regressionTable, normalizationMethod, targetField);\n+            String targetCategory = regressionTable.getTargetCategory() != null ? regressionTable.getTargetCategory().toString() : \"\";\n+            toReturn.put(regressionTableEntry.getKey(), new KiePMMLTableSourceCategory(regressionTableEntry.getValue(), targetCategory));\n+        }\n+        return toReturn;\n+    }\n+\n+    public static AbstractMap.Entry<String, String> getRegressionTable(final CompilationUnit templateCU, final RegressionTable regressionTable, final RegressionModel.NormalizationMethod normalizationMethod, final String targetField) {\n+        logger.debug(\"getRegressionTable {}\", regressionTable);\n+        CompilationUnit cloneCU = templateCU.clone();\n+        ClassOrInterfaceDeclaration tableTemplate = cloneCU.getClassByName(KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE)\n+                .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+        String className = \"KiePMMLRegressionTableRegression\" + classArity.addAndGet(1);\n+        tableTemplate.setName(className);\n+        setConstructor(regressionTable, tableTemplate, targetField);\n+        final Map<String, MethodDeclaration> numericPredictorsMap = addNumericPredictors(regressionTable.getNumericPredictors(), tableTemplate);\n+        final Map<String, MethodDeclaration> categoricalPredictorsMap = addCategoricalPredictors(regressionTable.getCategoricalPredictors(), tableTemplate);\n+        final Map<String, MethodDeclaration> predictorTermsMap = addPredictorTerms(regressionTable.getPredictorTerms(), tableTemplate);\n+        tableTemplate.getDefaultConstructor().ifPresent(constructorDeclaration -> {\n+            final BlockStmt body = constructorDeclaration.getBody();\n+            addMapPopulation(numericPredictorsMap, body, \"numericFunctionMap\");\n+            addMapPopulation(categoricalPredictorsMap, body, \"categoricalFunctionMap\");\n+            addMapPopulation(predictorTermsMap, body, \"predictorTermsFunctionMap\");\n+        });\n+        populateGetTargetCategory(tableTemplate, regressionTable.getTargetCategory());\n+        populateUpdateResult(tableTemplate, normalizationMethod);\n+        return new AbstractMap.SimpleEntry<>(className, cloneCU.toString());\n+    }\n+\n+    /**\n+     * Add entries <b>fieldName/function</b> inside the constructor\n+     * @param toAdd\n+     * @param body\n+     * @param mapName\n+     */\n+    private static void addMapPopulation(final Map<String, MethodDeclaration> toAdd, final BlockStmt body, final String mapName) {\n+        toAdd.forEach((s, methodDeclaration) -> {\n+            MethodReferenceExpr methodReferenceExpr = new MethodReferenceExpr();\n+            methodReferenceExpr.setScope(new ThisExpr());\n+            methodReferenceExpr.setIdentifier(methodDeclaration.getNameAsString());\n+            NodeList<Expression> expressions = NodeList.nodeList(new StringLiteralExpr(s), methodReferenceExpr);\n+            body.addStatement(new MethodCallExpr(new NameExpr(mapName), \"put\", expressions));\n+        });\n+    }\n+\n+    /**\n+     * Set the <b>intercept</b> and <b>targetField</b> values inside the constructor\n+     * @param regressionTable\n+     * @param tableTemplate\n+     * @param targetField\n+     */\n+    private static void setConstructor(final RegressionTable regressionTable, final ClassOrInterfaceDeclaration tableTemplate, final String targetField) {\n+        tableTemplate.getDefaultConstructor().ifPresent(constructorDeclaration -> {\n+            constructorDeclaration.setName(tableTemplate.getName());\n+            final BlockStmt body = constructorDeclaration.getBody();\n+            final List<AssignExpr> assignExprs = body.findAll(AssignExpr.class);\n+            assignExprs.forEach(assignExpr -> {\n+                if (assignExpr.getTarget().asNameExpr().getNameAsString().equals(\"intercept\")) {\n+                    assignExpr.setValue(new DoubleLiteralExpr(String.valueOf(regressionTable.getIntercept().doubleValue())));\n+                } else if (assignExpr.getTarget().asNameExpr().getNameAsString().equals(\"targetField\")) {\n+                    assignExpr.setValue(new StringLiteralExpr(targetField));\n+                }\n+            });\n+        });\n+    }\n+\n+    /**\n+     * Add <b>NumericPredictor</b>s <code>MethodDeclaration</code> to the class\n+     * @param numericPredictors\n+     * @param tableTemplate\n+     * @return\n+     */\n+    private static Map<String, MethodDeclaration> addNumericPredictors(final List<NumericPredictor> numericPredictors, final ClassOrInterfaceDeclaration tableTemplate) {\n+        predictorsArity.set(0);\n+        return numericPredictors.stream()\n+                .map(numericPredictor -> new AbstractMap.SimpleEntry<>(numericPredictor.getName().getValue(),\n+                                                                       addNumericPredictor(numericPredictor, tableTemplate, predictorsArity.addAndGet(1))))\n+                .filter(entry -> entry.getValue().isPresent())\n+                .collect(Collectors.toMap(AbstractMap.SimpleEntry::getKey,\n+                                          entry -> entry.getValue().get()));\n+    }\n+\n+    /**\n+     * Add a <b>NumericPredictor</b> <code>MethodDeclaration</code> to the class\n+     * @param numericPredictor\n+     * @param tableTemplate\n+     * @param predictorArity\n+     * @return\n+     */\n+    private static Optional<MethodDeclaration> addNumericPredictor(final NumericPredictor numericPredictor, final ClassOrInterfaceDeclaration tableTemplate, int predictorArity) {\n+        try {\n+            templateEvaluate = StaticJavaParser.parseResource(KIE_PMML_EVALUATE_METHOD_TEMPLATE_JAVA);\n+            cloneEvaluate = templateEvaluate.clone();\n+            ClassOrInterfaceDeclaration evaluateTemplateClass = cloneEvaluate.getClassByName(KIE_PMML_EVALUATE_METHOD_TEMPLATE)\n+                    .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+            MethodDeclaration methodTemplate;\n+            if (Objects.equals(1, numericPredictor.getExponent())) {\n+                methodTemplate = getNumericPredictorWithoutExponentTemplate(numericPredictor, evaluateTemplateClass);\n+            } else {\n+                methodTemplate = getNumericPredictorWithExponentTemplate(numericPredictor, evaluateTemplateClass);\n+            }\n+            return addMethod(methodTemplate, tableTemplate, \"evaluateNumericPredictor\" + predictorArity);\n+        } catch (Exception e) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * Add a <b>NumericPredictor</b> <code>MethodDeclaration</code> with <b>exponent != 1</b> to the class\n+     * @param numericPredictor\n+     * @param evaluateTemplateClass\n+     * @return\n+     */\n+    private static MethodDeclaration getNumericPredictorWithExponentTemplate(final NumericPredictor numericPredictor, final ClassOrInterfaceDeclaration evaluateTemplateClass) {\n+        final MethodDeclaration toReturn = evaluateTemplateClass.getMethodsByName(\"evaluateNumericWithExponent\").get(0);\n+        toReturn.getBody().ifPresent(body -> {\n+            final List<VariableDeclarator> variableDeclarators = body.findAll(VariableDeclarator.class);\n+            variableDeclarators.forEach(variableDeclarator -> {\n+                String initializer = null;\n+                if (variableDeclarator.getName().asString().equals(COEFFICIENT)) {\n+                    initializer = String.valueOf(numericPredictor.getCoefficient().doubleValue());\n+                } else if (variableDeclarator.getName().asString().equals(EXPONENT)) {\n+                    initializer = String.valueOf(numericPredictor.getExponent().doubleValue());\n+                }\n+                if (initializer != null) {\n+                    variableDeclarator.setInitializer(initializer);\n+                }\n+            });\n+        });\n+        return toReturn;\n+    }\n+\n+    /**\n+     * Add a <b>NumericPredictor</b> <code>MethodDeclaration</code> with <b>exponent == 1</b> to the class\n+     * @param numericPredictor\n+     * @param evaluateTemplateClass\n+     * @return\n+     */\n+    private static MethodDeclaration getNumericPredictorWithoutExponentTemplate(final NumericPredictor numericPredictor, final ClassOrInterfaceDeclaration evaluateTemplateClass) {\n+        final MethodDeclaration toReturn = evaluateTemplateClass.getMethodsByName(\"evaluateNumericWithoutExponent\").get(0);\n+        toReturn.getBody().ifPresent(body -> {\n+            final List<VariableDeclarator> variableDeclarators = body.findAll(VariableDeclarator.class);\n+            variableDeclarators.stream().filter(variableDeclarator -> variableDeclarator.getName().asString().equals(COEFFICIENT))\n+                    .forEach(variableDeclarator -> variableDeclarator.setInitializer(String.valueOf(numericPredictor.getCoefficient().doubleValue())));\n+        });\n+        return toReturn;\n+    }\n+\n+    /**\n+     * Add <b>CategoricalPredictor</b>s <code>MethodDeclaration</code> to the class\n+     * @param categoricalPredictors\n+     * @param tableTemplate\n+     * @return\n+     */\n+    private static Map<String, MethodDeclaration> addCategoricalPredictors(final List<CategoricalPredictor> categoricalPredictors, final ClassOrInterfaceDeclaration tableTemplate) {\n+        predictorsArity.set(0);\n+        final Map<String, List<CategoricalPredictor>> groupedCollectors = categoricalPredictors.stream()\n+                .collect(groupingBy(categoricalPredictor -> categoricalPredictor.getField().getValue()));\n+        return groupedCollectors.entrySet().stream()\n+                .map(entry -> new AbstractMap.SimpleEntry<>(entry.getKey(),\n+                                                            addGroupedCategoricalPredictor(entry.getValue(), tableTemplate, predictorsArity.addAndGet(1))))\n+                .filter(entry -> entry.getValue().isPresent())\n+                .collect(Collectors.toMap(AbstractMap.SimpleEntry::getKey,\n+                                          entry -> entry.getValue().get()));\n+    }\n+\n+    /**\n+     * Add a <b>CategoricalPredictor</b> <code>MethodDeclaration</code> to the class\n+     * @param categoricalPredictors\n+     * @param tableTemplate\n+     * @param predictorArity\n+     * @return\n+     */\n+    private static Optional<MethodDeclaration> addGroupedCategoricalPredictor(final List<CategoricalPredictor> categoricalPredictors, final ClassOrInterfaceDeclaration tableTemplate, int predictorArity) {\n+        try {\n+            templateEvaluate = StaticJavaParser.parseResource(KIE_PMML_EVALUATE_METHOD_TEMPLATE_JAVA);\n+            cloneEvaluate = templateEvaluate.clone();\n+            ClassOrInterfaceDeclaration evaluateTemplateClass = cloneEvaluate.getClassByName(KIE_PMML_EVALUATE_METHOD_TEMPLATE)\n+                    .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+            MethodDeclaration methodTemplate = evaluateTemplateClass.getMethodsByName(\"evaluateCategorical\").get(0);\n+            methodTemplate.getBody().ifPresent(body -> {\n+                IfStmt ifStmt = new IfStmt();\n+                for (int i = 0; i < categoricalPredictors.size(); i++) {\n+                    CategoricalPredictor categoricalPredictor = categoricalPredictors.get(i);\n+                    Expression lhe;\n+                    if (categoricalPredictor.getValue() instanceof String) {\n+                        lhe = new StringLiteralExpr((String) categoricalPredictor.getValue());\n+                    } else {\n+                        lhe = new NameExpr(categoricalPredictor.getValue().toString());\n+                    }\n+                    NodeList<Expression> expressions = NodeList.nodeList(lhe, new NameExpr(\"input\"));\n+                    MethodCallExpr conditionExpr = new MethodCallExpr(new NameExpr(\"Objects\"), \"equals\", expressions);\n+                    if (i == 0) {\n+                        ifStmt.setCondition(conditionExpr);\n+                        ifStmt.setThenStmt(new ReturnStmt(new DoubleLiteralExpr(String.valueOf(categoricalPredictor.getCoefficient()))));\n+                        body.addStatement(ifStmt);\n+                    } else {\n+                        IfStmt elseIf = new IfStmt();\n+                        elseIf.setCondition(conditionExpr);\n+                        elseIf.setThenStmt(new ReturnStmt(new DoubleLiteralExpr(String.valueOf(categoricalPredictor.getCoefficient()))));\n+                        ifStmt.setElseStmt(elseIf);\n+                        ifStmt = elseIf;\n+                    }\n+                }\n+                ifStmt.setElseStmt(new ReturnStmt(new DoubleLiteralExpr(\"0.0\")));\n+            });\n+            return addMethod(methodTemplate, tableTemplate, \"evaluateCategoricalPredictor\" + predictorArity);\n+        } catch (Exception e) {\n+            //\n+            return Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * Add <b>PredictorTerm</b>s <code>MethodDeclaration</code> to the class\n+     * @param predictorTerms\n+     * @param tableTemplate\n+     * @return\n+     */\n+    private static Map<String, MethodDeclaration> addPredictorTerms(final List<PredictorTerm> predictorTerms, final ClassOrInterfaceDeclaration tableTemplate) {\n+        predictorsArity.set(0);\n+        return predictorTerms.stream()\n+                .map(predictorTerm -> {\n+                    int arity = predictorsArity.addAndGet(1);\n+                    return new AbstractMap.SimpleEntry<>(predictorTerm.getName() != null ? predictorTerm.getName().getValue() : \"predictorTerm\" + arity,\n+                                                         addPredictorTerm(predictorTerm, tableTemplate, arity));\n+                })\n+                .filter(entry -> entry.getValue().isPresent())\n+                .collect(Collectors.toMap(AbstractMap.SimpleEntry::getKey,\n+                                          entry -> entry.getValue().get()));\n+    }\n+\n+    /**\n+     * Add a <b>PredictorTerm</b> <code>MethodDeclaration</code> to the class\n+     * @param predictorTerm\n+     * @param tableTemplate\n+     * @param predictorArity\n+     * @return\n+     */\n+    private static Optional<MethodDeclaration> addPredictorTerm(final PredictorTerm predictorTerm, final ClassOrInterfaceDeclaration tableTemplate, int predictorArity) {\n+        try {\n+            templateEvaluate = StaticJavaParser.parseResource(KIE_PMML_EVALUATE_METHOD_TEMPLATE_JAVA);\n+            cloneEvaluate = templateEvaluate.clone();\n+            ClassOrInterfaceDeclaration evaluateTemplateClass = cloneEvaluate.getClassByName(KIE_PMML_EVALUATE_METHOD_TEMPLATE)\n+                    .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+            MethodDeclaration methodTemplate = evaluateTemplateClass.getMethodsByName(\"evaluatePredictor\").get(0);\n+            methodTemplate.getBody().ifPresent(body -> {\n+                final List<VariableDeclarator> variableDeclarators = body.findAll(VariableDeclarator.class);\n+                variableDeclarators.forEach(variableDeclarator -> {\n+                    if (variableDeclarator.getName().asString().equals(\"fieldRefs\")) {\n+                        final List<Expression> nodeList = predictorTerm.getFieldRefs().stream()\n+                                .map(fieldRef -> new StringLiteralExpr(fieldRef.getField().getValue()))\n+                                .collect(Collectors.toList());\n+                        NodeList<Expression> expressions = NodeList.nodeList(nodeList);\n+                        MethodCallExpr methodCallExpr = new MethodCallExpr(new NameExpr(\"Arrays\"), \"asList\", expressions);\n+                        variableDeclarator.setInitializer(methodCallExpr);\n+                    } else if (variableDeclarator.getName().asString().equals(COEFFICIENT)) {\n+                        variableDeclarator.setInitializer(String.valueOf(predictorTerm.getCoefficient().doubleValue()));\n+                    }\n+                });\n+            });\n+            return addMethod(methodTemplate, tableTemplate, \"evaluatePredictorTerm\" + predictorArity);\n+        } catch (Exception e) {\n+            //\n+            return Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * Add a <code>MethodDeclaration</code> to the class\n+     * @param methodTemplate\n+     * @param tableTemplate\n+     * @param evaluateMethodName\n+     * @return\n+     */\n+    protected static Optional<MethodDeclaration> addMethod(final MethodDeclaration methodTemplate, final ClassOrInterfaceDeclaration tableTemplate, final String evaluateMethodName) {\n+        return methodTemplate.getBody().map(body -> {\n+            final MethodDeclaration toReturn = tableTemplate.addMethod(evaluateMethodName).setBody(body);\n+            toReturn.setModifiers(methodTemplate.getModifiers());\n+            methodTemplate.getParameters().forEach(toReturn::addParameter);\n+            toReturn.setType(methodTemplate.getType());\n+            return toReturn;\n+        });\n+    }\n+\n+    /**\n+     * Populate the <b>getTargetCategory</b> method of the class\n+     * @param tableTemplate\n+     * @param targetCategory\n+     * @return\n+     */\n+    protected static void populateGetTargetCategory(final ClassOrInterfaceDeclaration tableTemplate, final Object targetCategory) {\n+        MethodDeclaration methodDeclaration = tableTemplate.getMethodsByName(\"getTargetCategory\").get(0);\n+        methodDeclaration.getBody().ifPresent(body -> {\n+            ReturnStmt returnStmt = new ReturnStmt();\n+            if (targetCategory == null) {\n+                returnStmt.setExpression(new NameExpr(\"null\"));\n+            } else if (targetCategory instanceof String) {\n+                returnStmt.setExpression(new StringLiteralExpr((String) targetCategory));\n+            } else {\n+                returnStmt.setExpression(new NameExpr(targetCategory.toString()));\n+            }\n+            body.addStatement(returnStmt);\n+        });\n+    }\n+\n+    /**\n+     * Populate the <b>getTargetCategory</b> method of the class\n+     * @param tableTemplate\n+     * @param normalizationMethod\n+     * @return\n+     */\n+    protected static void populateUpdateResult(final ClassOrInterfaceDeclaration tableTemplate, final RegressionModel.NormalizationMethod normalizationMethod) {\n+        try {\n+            templateEvaluate = StaticJavaParser.parseResource(KIE_PMML_UPDATE_RESULT_METHOD_TEMPLATE_JAVA);\n+            cloneEvaluate = templateEvaluate.clone();\n+            ClassOrInterfaceDeclaration evaluateTemplateClass = cloneEvaluate.getClassByName(KIE_PMML_UPDATE_RESULT_METHOD_TEMPLATE)\n+                    .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+            String methodName = String.format(\"update%sResult\", normalizationMethod.name());\n+            MethodDeclaration methodTemplate = evaluateTemplateClass.getMethodsByName(methodName).get(0);\n+            methodTemplate.getBody().ifPresent(body -> {\n+                MethodDeclaration targetMethod = tableTemplate.getMethodsByName(\"updateResult\").get(0);\n+                targetMethod.setBody(body);\n+            });\n+        } catch (Exception e) {\n+            //", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c4a838980a18a8428b253ee431087beb471fe8d"}, "originalPosition": 407}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA5NDM4NA==", "bodyText": "Same comment", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r392094384", "createdAt": "2020-03-13T08:43:58Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/main/java/org/kie/pmml/models/regression/compiler/factories/KiePMMLRegressionTableRegressionFactory.java", "diffHunk": "@@ -0,0 +1,410 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.compiler.factories;\n+\n+import java.io.IOException;\n+import java.util.AbstractMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.DoubleLiteralExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.MethodReferenceExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.expr.ThisExpr;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.IfStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import org.dmg.pmml.regression.CategoricalPredictor;\n+import org.dmg.pmml.regression.NumericPredictor;\n+import org.dmg.pmml.regression.PredictorTerm;\n+import org.dmg.pmml.regression.RegressionModel;\n+import org.dmg.pmml.regression.RegressionTable;\n+import org.kie.pmml.models.regression.model.tuples.KiePMMLTableSourceCategory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+\n+public class KiePMMLRegressionTableRegressionFactory {\n+\n+    public static final String KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE_JAVA = \"KiePMMLRegressionTableRegressionTemplate.tmpl\";\n+    private static final Logger logger = LoggerFactory.getLogger(KiePMMLRegressionTableRegressionFactory.class.getName());\n+    private static final String MAIN_CLASS_NOT_FOUND = \"Main class not found\";\n+    private static final String KIE_PMML_EVALUATE_METHOD_TEMPLATE_JAVA = \"KiePMMLEvaluateMethodTemplate.tmpl\";\n+    private static final String KIE_PMML_EVALUATE_METHOD_TEMPLATE = \"KiePMMLEvaluateMethodTemplate\";\n+    private static final String KIE_PMML_UPDATE_RESULT_METHOD_TEMPLATE_JAVA = \"KiePMMLUpdateResultMethodTemplate.tmpl\";\n+    private static final String KIE_PMML_UPDATE_RESULT_METHOD_TEMPLATE = \"KiePMMLUpdateResultMethodTemplate\";\n+    private static final String KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE = \"KiePMMLRegressionTableRegressionTemplate\";\n+    private static final String COEFFICIENT = \"coefficient\";\n+    private static final String EXPONENT = \"exponent\";\n+    private static AtomicInteger classArity = new AtomicInteger(0);\n+    private static AtomicInteger predictorsArity = new AtomicInteger(0);\n+    private static CompilationUnit templateEvaluate;\n+    private static CompilationUnit cloneEvaluate;\n+\n+    private KiePMMLRegressionTableRegressionFactory() {\n+        // Avoid instantiation\n+    }\n+\n+    public static Map<String, KiePMMLTableSourceCategory> getRegressionTables(final List<RegressionTable> regressionTables, final RegressionModel.NormalizationMethod normalizationMethod, final String targetField) throws IOException {\n+        logger.debug(\"getRegressionTables {}\", regressionTables);\n+        CompilationUnit templateCU = StaticJavaParser.parseResource(KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE_JAVA);\n+        Map<String, KiePMMLTableSourceCategory> toReturn = new HashMap<>();\n+        for (RegressionTable regressionTable : regressionTables) {\n+            final Map.Entry<String, String> regressionTableEntry = getRegressionTable(templateCU, regressionTable, normalizationMethod, targetField);\n+            String targetCategory = regressionTable.getTargetCategory() != null ? regressionTable.getTargetCategory().toString() : \"\";\n+            toReturn.put(regressionTableEntry.getKey(), new KiePMMLTableSourceCategory(regressionTableEntry.getValue(), targetCategory));\n+        }\n+        return toReturn;\n+    }\n+\n+    public static AbstractMap.Entry<String, String> getRegressionTable(final CompilationUnit templateCU, final RegressionTable regressionTable, final RegressionModel.NormalizationMethod normalizationMethod, final String targetField) {\n+        logger.debug(\"getRegressionTable {}\", regressionTable);\n+        CompilationUnit cloneCU = templateCU.clone();\n+        ClassOrInterfaceDeclaration tableTemplate = cloneCU.getClassByName(KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE)\n+                .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+        String className = \"KiePMMLRegressionTableRegression\" + classArity.addAndGet(1);\n+        tableTemplate.setName(className);\n+        setConstructor(regressionTable, tableTemplate, targetField);\n+        final Map<String, MethodDeclaration> numericPredictorsMap = addNumericPredictors(regressionTable.getNumericPredictors(), tableTemplate);\n+        final Map<String, MethodDeclaration> categoricalPredictorsMap = addCategoricalPredictors(regressionTable.getCategoricalPredictors(), tableTemplate);\n+        final Map<String, MethodDeclaration> predictorTermsMap = addPredictorTerms(regressionTable.getPredictorTerms(), tableTemplate);\n+        tableTemplate.getDefaultConstructor().ifPresent(constructorDeclaration -> {\n+            final BlockStmt body = constructorDeclaration.getBody();\n+            addMapPopulation(numericPredictorsMap, body, \"numericFunctionMap\");\n+            addMapPopulation(categoricalPredictorsMap, body, \"categoricalFunctionMap\");\n+            addMapPopulation(predictorTermsMap, body, \"predictorTermsFunctionMap\");\n+        });\n+        populateGetTargetCategory(tableTemplate, regressionTable.getTargetCategory());\n+        populateUpdateResult(tableTemplate, normalizationMethod);\n+        return new AbstractMap.SimpleEntry<>(className, cloneCU.toString());\n+    }\n+\n+    /**\n+     * Add entries <b>fieldName/function</b> inside the constructor\n+     * @param toAdd\n+     * @param body\n+     * @param mapName\n+     */\n+    private static void addMapPopulation(final Map<String, MethodDeclaration> toAdd, final BlockStmt body, final String mapName) {\n+        toAdd.forEach((s, methodDeclaration) -> {\n+            MethodReferenceExpr methodReferenceExpr = new MethodReferenceExpr();\n+            methodReferenceExpr.setScope(new ThisExpr());\n+            methodReferenceExpr.setIdentifier(methodDeclaration.getNameAsString());\n+            NodeList<Expression> expressions = NodeList.nodeList(new StringLiteralExpr(s), methodReferenceExpr);\n+            body.addStatement(new MethodCallExpr(new NameExpr(mapName), \"put\", expressions));\n+        });\n+    }\n+\n+    /**\n+     * Set the <b>intercept</b> and <b>targetField</b> values inside the constructor\n+     * @param regressionTable\n+     * @param tableTemplate\n+     * @param targetField\n+     */\n+    private static void setConstructor(final RegressionTable regressionTable, final ClassOrInterfaceDeclaration tableTemplate, final String targetField) {\n+        tableTemplate.getDefaultConstructor().ifPresent(constructorDeclaration -> {\n+            constructorDeclaration.setName(tableTemplate.getName());\n+            final BlockStmt body = constructorDeclaration.getBody();\n+            final List<AssignExpr> assignExprs = body.findAll(AssignExpr.class);\n+            assignExprs.forEach(assignExpr -> {\n+                if (assignExpr.getTarget().asNameExpr().getNameAsString().equals(\"intercept\")) {\n+                    assignExpr.setValue(new DoubleLiteralExpr(String.valueOf(regressionTable.getIntercept().doubleValue())));\n+                } else if (assignExpr.getTarget().asNameExpr().getNameAsString().equals(\"targetField\")) {\n+                    assignExpr.setValue(new StringLiteralExpr(targetField));\n+                }\n+            });\n+        });\n+    }\n+\n+    /**\n+     * Add <b>NumericPredictor</b>s <code>MethodDeclaration</code> to the class\n+     * @param numericPredictors\n+     * @param tableTemplate\n+     * @return\n+     */\n+    private static Map<String, MethodDeclaration> addNumericPredictors(final List<NumericPredictor> numericPredictors, final ClassOrInterfaceDeclaration tableTemplate) {\n+        predictorsArity.set(0);\n+        return numericPredictors.stream()\n+                .map(numericPredictor -> new AbstractMap.SimpleEntry<>(numericPredictor.getName().getValue(),\n+                                                                       addNumericPredictor(numericPredictor, tableTemplate, predictorsArity.addAndGet(1))))\n+                .filter(entry -> entry.getValue().isPresent())\n+                .collect(Collectors.toMap(AbstractMap.SimpleEntry::getKey,\n+                                          entry -> entry.getValue().get()));\n+    }\n+\n+    /**\n+     * Add a <b>NumericPredictor</b> <code>MethodDeclaration</code> to the class\n+     * @param numericPredictor\n+     * @param tableTemplate\n+     * @param predictorArity\n+     * @return\n+     */\n+    private static Optional<MethodDeclaration> addNumericPredictor(final NumericPredictor numericPredictor, final ClassOrInterfaceDeclaration tableTemplate, int predictorArity) {\n+        try {\n+            templateEvaluate = StaticJavaParser.parseResource(KIE_PMML_EVALUATE_METHOD_TEMPLATE_JAVA);\n+            cloneEvaluate = templateEvaluate.clone();\n+            ClassOrInterfaceDeclaration evaluateTemplateClass = cloneEvaluate.getClassByName(KIE_PMML_EVALUATE_METHOD_TEMPLATE)\n+                    .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+            MethodDeclaration methodTemplate;\n+            if (Objects.equals(1, numericPredictor.getExponent())) {\n+                methodTemplate = getNumericPredictorWithoutExponentTemplate(numericPredictor, evaluateTemplateClass);\n+            } else {\n+                methodTemplate = getNumericPredictorWithExponentTemplate(numericPredictor, evaluateTemplateClass);\n+            }\n+            return addMethod(methodTemplate, tableTemplate, \"evaluateNumericPredictor\" + predictorArity);\n+        } catch (Exception e) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * Add a <b>NumericPredictor</b> <code>MethodDeclaration</code> with <b>exponent != 1</b> to the class\n+     * @param numericPredictor\n+     * @param evaluateTemplateClass\n+     * @return\n+     */\n+    private static MethodDeclaration getNumericPredictorWithExponentTemplate(final NumericPredictor numericPredictor, final ClassOrInterfaceDeclaration evaluateTemplateClass) {\n+        final MethodDeclaration toReturn = evaluateTemplateClass.getMethodsByName(\"evaluateNumericWithExponent\").get(0);\n+        toReturn.getBody().ifPresent(body -> {\n+            final List<VariableDeclarator> variableDeclarators = body.findAll(VariableDeclarator.class);\n+            variableDeclarators.forEach(variableDeclarator -> {\n+                String initializer = null;\n+                if (variableDeclarator.getName().asString().equals(COEFFICIENT)) {\n+                    initializer = String.valueOf(numericPredictor.getCoefficient().doubleValue());\n+                } else if (variableDeclarator.getName().asString().equals(EXPONENT)) {\n+                    initializer = String.valueOf(numericPredictor.getExponent().doubleValue());\n+                }\n+                if (initializer != null) {\n+                    variableDeclarator.setInitializer(initializer);\n+                }\n+            });\n+        });\n+        return toReturn;\n+    }\n+\n+    /**\n+     * Add a <b>NumericPredictor</b> <code>MethodDeclaration</code> with <b>exponent == 1</b> to the class\n+     * @param numericPredictor\n+     * @param evaluateTemplateClass\n+     * @return\n+     */\n+    private static MethodDeclaration getNumericPredictorWithoutExponentTemplate(final NumericPredictor numericPredictor, final ClassOrInterfaceDeclaration evaluateTemplateClass) {\n+        final MethodDeclaration toReturn = evaluateTemplateClass.getMethodsByName(\"evaluateNumericWithoutExponent\").get(0);\n+        toReturn.getBody().ifPresent(body -> {\n+            final List<VariableDeclarator> variableDeclarators = body.findAll(VariableDeclarator.class);\n+            variableDeclarators.stream().filter(variableDeclarator -> variableDeclarator.getName().asString().equals(COEFFICIENT))\n+                    .forEach(variableDeclarator -> variableDeclarator.setInitializer(String.valueOf(numericPredictor.getCoefficient().doubleValue())));\n+        });\n+        return toReturn;\n+    }\n+\n+    /**\n+     * Add <b>CategoricalPredictor</b>s <code>MethodDeclaration</code> to the class\n+     * @param categoricalPredictors\n+     * @param tableTemplate\n+     * @return\n+     */\n+    private static Map<String, MethodDeclaration> addCategoricalPredictors(final List<CategoricalPredictor> categoricalPredictors, final ClassOrInterfaceDeclaration tableTemplate) {\n+        predictorsArity.set(0);\n+        final Map<String, List<CategoricalPredictor>> groupedCollectors = categoricalPredictors.stream()\n+                .collect(groupingBy(categoricalPredictor -> categoricalPredictor.getField().getValue()));\n+        return groupedCollectors.entrySet().stream()\n+                .map(entry -> new AbstractMap.SimpleEntry<>(entry.getKey(),\n+                                                            addGroupedCategoricalPredictor(entry.getValue(), tableTemplate, predictorsArity.addAndGet(1))))\n+                .filter(entry -> entry.getValue().isPresent())\n+                .collect(Collectors.toMap(AbstractMap.SimpleEntry::getKey,\n+                                          entry -> entry.getValue().get()));\n+    }\n+\n+    /**\n+     * Add a <b>CategoricalPredictor</b> <code>MethodDeclaration</code> to the class\n+     * @param categoricalPredictors\n+     * @param tableTemplate\n+     * @param predictorArity\n+     * @return\n+     */\n+    private static Optional<MethodDeclaration> addGroupedCategoricalPredictor(final List<CategoricalPredictor> categoricalPredictors, final ClassOrInterfaceDeclaration tableTemplate, int predictorArity) {\n+        try {\n+            templateEvaluate = StaticJavaParser.parseResource(KIE_PMML_EVALUATE_METHOD_TEMPLATE_JAVA);\n+            cloneEvaluate = templateEvaluate.clone();\n+            ClassOrInterfaceDeclaration evaluateTemplateClass = cloneEvaluate.getClassByName(KIE_PMML_EVALUATE_METHOD_TEMPLATE)\n+                    .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+            MethodDeclaration methodTemplate = evaluateTemplateClass.getMethodsByName(\"evaluateCategorical\").get(0);\n+            methodTemplate.getBody().ifPresent(body -> {\n+                IfStmt ifStmt = new IfStmt();\n+                for (int i = 0; i < categoricalPredictors.size(); i++) {\n+                    CategoricalPredictor categoricalPredictor = categoricalPredictors.get(i);\n+                    Expression lhe;\n+                    if (categoricalPredictor.getValue() instanceof String) {\n+                        lhe = new StringLiteralExpr((String) categoricalPredictor.getValue());\n+                    } else {\n+                        lhe = new NameExpr(categoricalPredictor.getValue().toString());\n+                    }\n+                    NodeList<Expression> expressions = NodeList.nodeList(lhe, new NameExpr(\"input\"));\n+                    MethodCallExpr conditionExpr = new MethodCallExpr(new NameExpr(\"Objects\"), \"equals\", expressions);\n+                    if (i == 0) {\n+                        ifStmt.setCondition(conditionExpr);\n+                        ifStmt.setThenStmt(new ReturnStmt(new DoubleLiteralExpr(String.valueOf(categoricalPredictor.getCoefficient()))));\n+                        body.addStatement(ifStmt);\n+                    } else {\n+                        IfStmt elseIf = new IfStmt();\n+                        elseIf.setCondition(conditionExpr);\n+                        elseIf.setThenStmt(new ReturnStmt(new DoubleLiteralExpr(String.valueOf(categoricalPredictor.getCoefficient()))));\n+                        ifStmt.setElseStmt(elseIf);\n+                        ifStmt = elseIf;\n+                    }\n+                }\n+                ifStmt.setElseStmt(new ReturnStmt(new DoubleLiteralExpr(\"0.0\")));\n+            });\n+            return addMethod(methodTemplate, tableTemplate, \"evaluateCategoricalPredictor\" + predictorArity);\n+        } catch (Exception e) {\n+            //", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c4a838980a18a8428b253ee431087beb471fe8d"}, "originalPosition": 290}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA5NDUyMA==", "bodyText": "Are you sure this could happen? We are working with a template created by us", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r392094520", "createdAt": "2020-03-13T08:44:19Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/main/java/org/kie/pmml/models/regression/compiler/factories/KiePMMLRegressionTableRegressionFactory.java", "diffHunk": "@@ -0,0 +1,410 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.compiler.factories;\n+\n+import java.io.IOException;\n+import java.util.AbstractMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.DoubleLiteralExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.MethodReferenceExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.expr.ThisExpr;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.IfStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import org.dmg.pmml.regression.CategoricalPredictor;\n+import org.dmg.pmml.regression.NumericPredictor;\n+import org.dmg.pmml.regression.PredictorTerm;\n+import org.dmg.pmml.regression.RegressionModel;\n+import org.dmg.pmml.regression.RegressionTable;\n+import org.kie.pmml.models.regression.model.tuples.KiePMMLTableSourceCategory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+\n+public class KiePMMLRegressionTableRegressionFactory {\n+\n+    public static final String KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE_JAVA = \"KiePMMLRegressionTableRegressionTemplate.tmpl\";\n+    private static final Logger logger = LoggerFactory.getLogger(KiePMMLRegressionTableRegressionFactory.class.getName());\n+    private static final String MAIN_CLASS_NOT_FOUND = \"Main class not found\";\n+    private static final String KIE_PMML_EVALUATE_METHOD_TEMPLATE_JAVA = \"KiePMMLEvaluateMethodTemplate.tmpl\";\n+    private static final String KIE_PMML_EVALUATE_METHOD_TEMPLATE = \"KiePMMLEvaluateMethodTemplate\";\n+    private static final String KIE_PMML_UPDATE_RESULT_METHOD_TEMPLATE_JAVA = \"KiePMMLUpdateResultMethodTemplate.tmpl\";\n+    private static final String KIE_PMML_UPDATE_RESULT_METHOD_TEMPLATE = \"KiePMMLUpdateResultMethodTemplate\";\n+    private static final String KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE = \"KiePMMLRegressionTableRegressionTemplate\";\n+    private static final String COEFFICIENT = \"coefficient\";\n+    private static final String EXPONENT = \"exponent\";\n+    private static AtomicInteger classArity = new AtomicInteger(0);\n+    private static AtomicInteger predictorsArity = new AtomicInteger(0);\n+    private static CompilationUnit templateEvaluate;\n+    private static CompilationUnit cloneEvaluate;\n+\n+    private KiePMMLRegressionTableRegressionFactory() {\n+        // Avoid instantiation\n+    }\n+\n+    public static Map<String, KiePMMLTableSourceCategory> getRegressionTables(final List<RegressionTable> regressionTables, final RegressionModel.NormalizationMethod normalizationMethod, final String targetField) throws IOException {\n+        logger.debug(\"getRegressionTables {}\", regressionTables);\n+        CompilationUnit templateCU = StaticJavaParser.parseResource(KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE_JAVA);\n+        Map<String, KiePMMLTableSourceCategory> toReturn = new HashMap<>();\n+        for (RegressionTable regressionTable : regressionTables) {\n+            final Map.Entry<String, String> regressionTableEntry = getRegressionTable(templateCU, regressionTable, normalizationMethod, targetField);\n+            String targetCategory = regressionTable.getTargetCategory() != null ? regressionTable.getTargetCategory().toString() : \"\";\n+            toReturn.put(regressionTableEntry.getKey(), new KiePMMLTableSourceCategory(regressionTableEntry.getValue(), targetCategory));\n+        }\n+        return toReturn;\n+    }\n+\n+    public static AbstractMap.Entry<String, String> getRegressionTable(final CompilationUnit templateCU, final RegressionTable regressionTable, final RegressionModel.NormalizationMethod normalizationMethod, final String targetField) {\n+        logger.debug(\"getRegressionTable {}\", regressionTable);\n+        CompilationUnit cloneCU = templateCU.clone();\n+        ClassOrInterfaceDeclaration tableTemplate = cloneCU.getClassByName(KIE_PMML_REGRESSION_TABLE_REGRESSION_TEMPLATE)\n+                .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+        String className = \"KiePMMLRegressionTableRegression\" + classArity.addAndGet(1);\n+        tableTemplate.setName(className);\n+        setConstructor(regressionTable, tableTemplate, targetField);\n+        final Map<String, MethodDeclaration> numericPredictorsMap = addNumericPredictors(regressionTable.getNumericPredictors(), tableTemplate);\n+        final Map<String, MethodDeclaration> categoricalPredictorsMap = addCategoricalPredictors(regressionTable.getCategoricalPredictors(), tableTemplate);\n+        final Map<String, MethodDeclaration> predictorTermsMap = addPredictorTerms(regressionTable.getPredictorTerms(), tableTemplate);\n+        tableTemplate.getDefaultConstructor().ifPresent(constructorDeclaration -> {\n+            final BlockStmt body = constructorDeclaration.getBody();\n+            addMapPopulation(numericPredictorsMap, body, \"numericFunctionMap\");\n+            addMapPopulation(categoricalPredictorsMap, body, \"categoricalFunctionMap\");\n+            addMapPopulation(predictorTermsMap, body, \"predictorTermsFunctionMap\");\n+        });\n+        populateGetTargetCategory(tableTemplate, regressionTable.getTargetCategory());\n+        populateUpdateResult(tableTemplate, normalizationMethod);\n+        return new AbstractMap.SimpleEntry<>(className, cloneCU.toString());\n+    }\n+\n+    /**\n+     * Add entries <b>fieldName/function</b> inside the constructor\n+     * @param toAdd\n+     * @param body\n+     * @param mapName\n+     */\n+    private static void addMapPopulation(final Map<String, MethodDeclaration> toAdd, final BlockStmt body, final String mapName) {\n+        toAdd.forEach((s, methodDeclaration) -> {\n+            MethodReferenceExpr methodReferenceExpr = new MethodReferenceExpr();\n+            methodReferenceExpr.setScope(new ThisExpr());\n+            methodReferenceExpr.setIdentifier(methodDeclaration.getNameAsString());\n+            NodeList<Expression> expressions = NodeList.nodeList(new StringLiteralExpr(s), methodReferenceExpr);\n+            body.addStatement(new MethodCallExpr(new NameExpr(mapName), \"put\", expressions));\n+        });\n+    }\n+\n+    /**\n+     * Set the <b>intercept</b> and <b>targetField</b> values inside the constructor\n+     * @param regressionTable\n+     * @param tableTemplate\n+     * @param targetField\n+     */\n+    private static void setConstructor(final RegressionTable regressionTable, final ClassOrInterfaceDeclaration tableTemplate, final String targetField) {\n+        tableTemplate.getDefaultConstructor().ifPresent(constructorDeclaration -> {\n+            constructorDeclaration.setName(tableTemplate.getName());\n+            final BlockStmt body = constructorDeclaration.getBody();\n+            final List<AssignExpr> assignExprs = body.findAll(AssignExpr.class);\n+            assignExprs.forEach(assignExpr -> {\n+                if (assignExpr.getTarget().asNameExpr().getNameAsString().equals(\"intercept\")) {\n+                    assignExpr.setValue(new DoubleLiteralExpr(String.valueOf(regressionTable.getIntercept().doubleValue())));\n+                } else if (assignExpr.getTarget().asNameExpr().getNameAsString().equals(\"targetField\")) {\n+                    assignExpr.setValue(new StringLiteralExpr(targetField));\n+                }\n+            });\n+        });\n+    }\n+\n+    /**\n+     * Add <b>NumericPredictor</b>s <code>MethodDeclaration</code> to the class\n+     * @param numericPredictors\n+     * @param tableTemplate\n+     * @return\n+     */\n+    private static Map<String, MethodDeclaration> addNumericPredictors(final List<NumericPredictor> numericPredictors, final ClassOrInterfaceDeclaration tableTemplate) {\n+        predictorsArity.set(0);\n+        return numericPredictors.stream()\n+                .map(numericPredictor -> new AbstractMap.SimpleEntry<>(numericPredictor.getName().getValue(),\n+                                                                       addNumericPredictor(numericPredictor, tableTemplate, predictorsArity.addAndGet(1))))\n+                .filter(entry -> entry.getValue().isPresent())\n+                .collect(Collectors.toMap(AbstractMap.SimpleEntry::getKey,\n+                                          entry -> entry.getValue().get()));\n+    }\n+\n+    /**\n+     * Add a <b>NumericPredictor</b> <code>MethodDeclaration</code> to the class\n+     * @param numericPredictor\n+     * @param tableTemplate\n+     * @param predictorArity\n+     * @return\n+     */\n+    private static Optional<MethodDeclaration> addNumericPredictor(final NumericPredictor numericPredictor, final ClassOrInterfaceDeclaration tableTemplate, int predictorArity) {\n+        try {\n+            templateEvaluate = StaticJavaParser.parseResource(KIE_PMML_EVALUATE_METHOD_TEMPLATE_JAVA);\n+            cloneEvaluate = templateEvaluate.clone();\n+            ClassOrInterfaceDeclaration evaluateTemplateClass = cloneEvaluate.getClassByName(KIE_PMML_EVALUATE_METHOD_TEMPLATE)\n+                    .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n+            MethodDeclaration methodTemplate;\n+            if (Objects.equals(1, numericPredictor.getExponent())) {\n+                methodTemplate = getNumericPredictorWithoutExponentTemplate(numericPredictor, evaluateTemplateClass);\n+            } else {\n+                methodTemplate = getNumericPredictorWithExponentTemplate(numericPredictor, evaluateTemplateClass);\n+            }\n+            return addMethod(methodTemplate, tableTemplate, \"evaluateNumericPredictor\" + predictorArity);\n+        } catch (Exception e) {\n+            return Optional.empty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c4a838980a18a8428b253ee431087beb471fe8d"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA5ODMwMw==", "bodyText": "Is this method optional?", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r392098303", "createdAt": "2020-03-13T08:52:24Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-model/src/main/java/org/kie/pmml/models/regression/model/KiePMMLRegressionTable.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.model;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+public abstract class KiePMMLRegressionTable {\n+\n+    protected Map<String, Function<Double, Double>> numericFunctionMap = new HashMap<>();\n+    protected Map<String, Function<Object, Double>> categoricalFunctionMap = new HashMap<>();\n+    protected Map<String, Function<Map<String, Object>, Double>> predictorTermsFunctionMap = new HashMap<>();\n+    protected double intercept;\n+    protected String targetField;\n+\n+    public abstract Object getTargetCategory();\n+\n+    public Object evaluateRegression(Map<String, Object> input) {\n+        final AtomicReference<Double> result = new AtomicReference<>(intercept);\n+        final Map<String, Double> resultMap = new HashMap<>();\n+        for (Map.Entry<String, Function<Double, Double>> entry : numericFunctionMap.entrySet()) {\n+            String key = entry.getKey();\n+            if (input.containsKey(key)) {\n+                resultMap.put(key, entry.getValue().apply(((Number) input.get(key)).doubleValue()));\n+            }\n+        }\n+        for (Map.Entry<String, Function<Object, Double>> entry : categoricalFunctionMap.entrySet()) {\n+            String key = entry.getKey();\n+            if (input.containsKey(key)) {\n+                resultMap.put(key, entry.getValue().apply(input.get(key)));\n+            }\n+        }\n+        for (Map.Entry<String, Function<Map<String, Object>, Double>> entry : predictorTermsFunctionMap.entrySet()) {\n+            resultMap.put(entry.getKey(), entry.getValue().apply(input));\n+        }\n+        resultMap.values().forEach(value -> result.accumulateAndGet(value, Double::sum));\n+        updateResult(result);\n+        return result.get();\n+    }\n+\n+    public Map<String, Object> getOutputFieldsMap() {\n+        return new HashMap<>();\n+    }\n+\n+    public String getTargetField() {\n+        return targetField;\n+    }\n+\n+    public Map<String, Function<Double, Double>> getNumericFunctionMap() {\n+        return numericFunctionMap;\n+    }\n+\n+    public Map<String, Function<Object, Double>> getCategoricalFunctionMap() {\n+        return categoricalFunctionMap;\n+    }\n+\n+    public Map<String, Function<Map<String, Object>, Double>> getPredictorTermsFunctionMap() {\n+        return predictorTermsFunctionMap;\n+    }\n+\n+    public double getIntercept() {\n+        return intercept;\n+    }\n+\n+    protected void updateResult(final AtomicReference<Double> toUpdate) {\n+        // NONE", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c4a838980a18a8428b253ee431087beb471fe8d"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjExMzkzNw==", "bodyText": "Is it optional?", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r392113937", "createdAt": "2020-03-13T09:25:44Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-model/src/main/java/org/kie/pmml/models/regression/model/KiePMMLRegressionClassificationTable.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.model;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.DoubleUnaryOperator;\n+\n+import org.kie.pmml.commons.exceptions.KiePMMLException;\n+import org.kie.pmml.commons.model.KiePMMLOutputField;\n+import org.kie.pmml.commons.model.enums.OP_TYPE;\n+import org.kie.pmml.models.regression.model.enums.REGRESSION_NORMALIZATION_METHOD;\n+\n+import static org.kie.pmml.commons.Constants.EXPECTED_TWO_ENTRIES_RETRIEVED;\n+\n+public abstract class KiePMMLRegressionClassificationTable extends KiePMMLRegressionTable {\n+\n+    protected REGRESSION_NORMALIZATION_METHOD regressionNormalizationMethod;\n+    protected OP_TYPE opType;\n+    protected List<KiePMMLOutputField> outputFields = new ArrayList<>();\n+    protected Map<String, Object> outputFieldsMap = new HashMap<>();\n+    protected Map<String, KiePMMLRegressionTable> categoryTableMap = new HashMap<>();\n+\n+    public Object evaluateRegression(Map<String, Object> input) {\n+        final LinkedHashMap<String, Double> resultMap = new LinkedHashMap<>();\n+        for (Map.Entry<String, KiePMMLRegressionTable> entry : categoryTableMap.entrySet()) {\n+            resultMap.put(entry.getKey(), (Double) entry.getValue().evaluateRegression(input));\n+        }\n+        final LinkedHashMap<String, Double> probabilityMap = getProbabilityMap(resultMap);\n+        final Map.Entry<String, Double> predictedEntry = Collections.max(probabilityMap.entrySet(), Map.Entry.comparingByValue());\n+        probabilityMap.put(targetField, predictedEntry.getValue());\n+        populateOutputFieldsMap(predictedEntry, probabilityMap);\n+        outputFieldsMap.put(targetField, predictedEntry.getKey());\n+        return predictedEntry.getKey();\n+    }\n+\n+    public abstract boolean isBinary();/* {\n+        return Objects.equals(OP_TYPE.CATEGORICAL, targetOpType) && (targetValues != null && targetValues.size() == 2);\n+    }*/\n+\n+    protected abstract LinkedHashMap<String, Double> getProbabilityMap(final LinkedHashMap<String, Double> resultMap);\n+\n+    protected abstract void populateOutputFieldsMap(final Map.Entry<String, Double> predictedEntry, final LinkedHashMap<String, Double> probabilityMap);\n+\n+    protected void updateResult(final AtomicReference<Double> toUpdate) {\n+        // NOOP", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c4a838980a18a8428b253ee431087beb471fe8d"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjExNDUxOQ==", "bodyText": "Can you remove the comment?", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r392114519", "createdAt": "2020-03-13T09:26:57Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-model/src/main/java/org/kie/pmml/models/regression/model/KiePMMLRegressionClassificationTable.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.model;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.DoubleUnaryOperator;\n+\n+import org.kie.pmml.commons.exceptions.KiePMMLException;\n+import org.kie.pmml.commons.model.KiePMMLOutputField;\n+import org.kie.pmml.commons.model.enums.OP_TYPE;\n+import org.kie.pmml.models.regression.model.enums.REGRESSION_NORMALIZATION_METHOD;\n+\n+import static org.kie.pmml.commons.Constants.EXPECTED_TWO_ENTRIES_RETRIEVED;\n+\n+public abstract class KiePMMLRegressionClassificationTable extends KiePMMLRegressionTable {\n+\n+    protected REGRESSION_NORMALIZATION_METHOD regressionNormalizationMethod;\n+    protected OP_TYPE opType;\n+    protected List<KiePMMLOutputField> outputFields = new ArrayList<>();\n+    protected Map<String, Object> outputFieldsMap = new HashMap<>();\n+    protected Map<String, KiePMMLRegressionTable> categoryTableMap = new HashMap<>();\n+\n+    public Object evaluateRegression(Map<String, Object> input) {\n+        final LinkedHashMap<String, Double> resultMap = new LinkedHashMap<>();\n+        for (Map.Entry<String, KiePMMLRegressionTable> entry : categoryTableMap.entrySet()) {\n+            resultMap.put(entry.getKey(), (Double) entry.getValue().evaluateRegression(input));\n+        }\n+        final LinkedHashMap<String, Double> probabilityMap = getProbabilityMap(resultMap);\n+        final Map.Entry<String, Double> predictedEntry = Collections.max(probabilityMap.entrySet(), Map.Entry.comparingByValue());\n+        probabilityMap.put(targetField, predictedEntry.getValue());\n+        populateOutputFieldsMap(predictedEntry, probabilityMap);\n+        outputFieldsMap.put(targetField, predictedEntry.getKey());\n+        return predictedEntry.getKey();\n+    }\n+\n+    public abstract boolean isBinary();/* {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c4a838980a18a8428b253ee431087beb471fe8d"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjEyNzExNg==", "bodyText": "I think it is more clear to have KiePMMLSourceCode and KiePMMLByteCode to clarify when they are used", "url": "https://github.com/kiegroup/drools/pull/2808#discussion_r392127116", "createdAt": "2020-03-13T09:52:10Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-regression/kie-pmml-models-regression-compiler/src/main/java/org/kie/pmml/models/regression/compiler/utils/KiePMMLCode.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.regression.compiler.utils;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.URI;\n+\n+import javax.tools.SimpleJavaFileObject;\n+\n+public class KiePMMLCode extends SimpleJavaFileObject {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c4a838980a18a8428b253ee431087beb471fe8d"}, "originalPosition": 25}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "835d6310752a3c5f7323f26288c519093a0131a5", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/835d6310752a3c5f7323f26288c519093a0131a5", "committedDate": "2020-03-13T10:15:47Z", "message": "Merge remote-tracking branch 'origin/master' into DROOLS-3339"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "14c3458acdaacec6300194526e8b5dca53b784dd", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/14c3458acdaacec6300194526e8b5dca53b784dd", "committedDate": "2020-03-13T11:12:35Z", "message": "[DROOLS-3339] Fix as per PR suggestion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f2afc1a728ff95ec7a817965e135f6cb56dbe37", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/4f2afc1a728ff95ec7a817965e135f6cb56dbe37", "committedDate": "2020-03-13T11:45:29Z", "message": "[DROOLS-3339] Missing bits. Completely remove use of optionals in factories"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0MjU2Njk2", "url": "https://github.com/kiegroup/drools/pull/2808#pullrequestreview-374256696", "createdAt": "2020-03-13T12:21:40Z", "commit": {"oid": "4f2afc1a728ff95ec7a817965e135f6cb56dbe37"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0MjYyOTM0", "url": "https://github.com/kiegroup/drools/pull/2808#pullrequestreview-374262934", "createdAt": "2020-03-13T12:32:52Z", "commit": {"oid": "4f2afc1a728ff95ec7a817965e135f6cb56dbe37"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3dbecf3b9d9c2d30d888f65394e910923b10079c", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/3dbecf3b9d9c2d30d888f65394e910923b10079c", "committedDate": "2020-01-14T16:45:26Z", "message": "[DROOLS-4933] Scheleton implementation."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d8d48091b32f272146d9a2957987371b22f1c659", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/d8d48091b32f272146d9a2957987371b22f1c659", "committedDate": "2020-01-14T17:01:05Z", "message": "[DROOLS-4933] Add UMLs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "925f1987f140893cb1322e539256872f2ccbeecd", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/925f1987f140893cb1322e539256872f2ccbeecd", "committedDate": "2020-01-15T12:03:01Z", "message": "Merge remote-tracking branch 'origin/master' into DROOLS-4933"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1e0adbc1c2b8b2a96f208342cb2e7c4c571f311", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/d1e0adbc1c2b8b2a96f208342cb2e7c4c571f311", "committedDate": "2020-01-16T13:02:50Z", "message": "[DROOLS-4933] Refactor module layout to include KiePMMLRuntime implementation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3433fe23e6e8c8f5c56ed87aba9b31fc7fdb8c4", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/f3433fe23e6e8c8f5c56ed87aba9b31fc7fdb8c4", "committedDate": "2020-01-16T16:27:04Z", "message": "[DROOLS-4933] Refactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2e2db3f85353573027fef94ceb58c672fbb072e", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/a2e2db3f85353573027fef94ceb58c672fbb072e", "committedDate": "2020-01-21T13:20:08Z", "message": "[DROOLS_4933] Begin Regression model runtime implementation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "406f5aa611d29288414e56990b02cc1511fa922b", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/406f5aa611d29288414e56990b02cc1511fa922b", "committedDate": "2020-01-21T13:22:02Z", "message": "Merge remote-tracking branch 'origin/master' into DROOLS-4933"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "acf3a796d5f83b2d0ba3c9301defc8b03d83d3ab", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/acf3a796d5f83b2d0ba3c9301defc8b03d83d3ab", "committedDate": "2020-01-21T15:23:19Z", "message": "[DROOLS-4933] Implemented regression model test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46a55aeea38f0cff3394726e9d2a69fd27f29de3", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/46a55aeea38f0cff3394726e9d2a69fd27f29de3", "committedDate": "2020-01-21T15:28:35Z", "message": "[DROOLS-4933] Add models"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4804ecb09fa750cd3f9d55cd4862b31dc181e102", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/4804ecb09fa750cd3f9d55cd4862b31dc181e102", "committedDate": "2020-01-21T16:17:38Z", "message": "[DROOLS-4933] Add PMML compiler test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f728a0545a1d660d4dcde290305e4c637b2302cd", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/f728a0545a1d660d4dcde290305e4c637b2302cd", "committedDate": "2020-01-22T18:28:39Z", "message": "[DROOLS-4933] Implemented compiler and assembler, with tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a6a17446ea7262bd11cde18697e67a7bc92a1213", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/a6a17446ea7262bd11cde18697e67a7bc92a1213", "committedDate": "2020-01-23T10:12:27Z", "message": "[DROOLS-4933] Switched version. Moved ResourceHelper to kie-test-util package"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c1e01ec7a306f3d0253d261eca41867e86399c5", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/7c1e01ec7a306f3d0253d261eca41867e86399c5", "committedDate": "2020-01-23T10:30:10Z", "message": "Merge remote-tracking branch 'origin/master' into DROOLS-4933"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "212bfb68a5ad7db74ad36f0c1387a967f40cff57", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/212bfb68a5ad7db74ad36f0c1387a967f40cff57", "committedDate": "2020-01-23T12:24:20Z", "message": "[DROOLS-4933] Implemented integration test module. Full roundtrip test for linear regression"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e53facd07bdeef8aeef9e181e8db381b71568ff", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/5e53facd07bdeef8aeef9e181e8db381b71568ff", "committedDate": "2020-01-23T15:16:34Z", "message": "[DROOLS-4933] Implementing full roundtrip test with full kie integration - test not working"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c052f3939c806f06ba9da81d8a458306fdf821d1", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/c052f3939c806f06ba9da81d8a458306fdf821d1", "committedDate": "2020-01-23T17:59:13Z", "message": "[DROOLS-4933] Implementing PMMLWeaverService. Fixing integration test setup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85c248d9f9bb20102002da13b80f30ae2c349280", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/85c248d9f9bb20102002da13b80f30ae2c349280", "committedDate": "2020-01-24T09:50:45Z", "message": "[DROOLS-4933] Begin implementation of drools-based Tree model"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "daec25864ebfb41a5d5b24fb767a5f34018bf57a", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/daec25864ebfb41a5d5b24fb767a5f34018bf57a", "committedDate": "2020-01-24T09:56:54Z", "message": "[DROOLS-4933] Fixing old KieBaseTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "414dfb3bf8436958e7ad9d2a6450cef56bd66267", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/414dfb3bf8436958e7ad9d2a6450cef56bd66267", "committedDate": "2020-01-24T16:00:23Z", "message": "[DROOLS-4933] Begin implementation of Tree model with tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b55f05acc849c76130d70bc796fe1a395e103f4", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/4b55f05acc849c76130d70bc796fe1a395e103f4", "committedDate": "2020-01-27T08:12:46Z", "message": "[DROOLS-4933] Keep going with implementation of Tree model and tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ea39606d4becc5dc01226cab8412f598490a1d0", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/2ea39606d4becc5dc01226cab8412f598490a1d0", "committedDate": "2020-01-27T08:13:07Z", "message": "Merge remote-tracking branch 'origin/master' into DROOLS-4933"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cbb1d77ac080712959f51271a356ebad6063b390", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/cbb1d77ac080712959f51271a356ebad6063b390", "committedDate": "2020-01-27T15:58:41Z", "message": "[DROOLS-4933] Renaming previous implementation to kie-pmml-legacy. Updating dependant modules to reflect that"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e22de0c5d1b6dd260f93be2839f5254794a87ff", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/7e22de0c5d1b6dd260f93be2839f5254794a87ff", "committedDate": "2020-01-27T15:59:49Z", "message": "[DROOLS-4933] Fixing linear regression roundtrip test. Implementing finder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a0cf0f5916cbc9c730d9d23e43fe6d313fd97f9e", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/a0cf0f5916cbc9c730d9d23e43fe6d313fd97f9e", "committedDate": "2020-01-28T09:25:11Z", "message": "[DROOLS-4933] Commenting execution logic from Tree model. Begin model test implementation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c42ce09ac28ed51ad9e6060f980685de7d06c42", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/6c42ce09ac28ed51ad9e6060f980685de7d06c42", "committedDate": "2020-01-28T09:25:18Z", "message": "Merge remote-tracking branch 'origin/master' into DROOLS-4933"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e483c8c449cac316f8310afe45b8ba7f31f503c2", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/e483c8c449cac316f8310afe45b8ba7f31f503c2", "committedDate": "2020-01-28T10:55:43Z", "message": "[DROOLS-4933] Done TreeModelImplementationProviderTest stub. Add True/False predicates."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "98bca0adc201a3fdb1ffdc38a89b31c207fe749a", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/98bca0adc201a3fdb1ffdc38a89b31c207fe749a", "committedDate": "2020-01-28T13:50:07Z", "message": "[DROOLS-4933] First TreeModel (drools) iteration done with empty rule"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d59116f44ded7f430ed3597ff3fa718271aa8a5a", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/d59116f44ded7f430ed3597ff3fa718271aa8a5a", "committedDate": "2020-01-30T12:29:19Z", "message": "[DROOLS-4933] TreeModel (drools) iteration done with golfing model example test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a193a6dba6f6207164f8dc83bdda8b40f0a0a50b", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/a193a6dba6f6207164f8dc83bdda8b40f0a0a50b", "committedDate": "2020-01-30T16:35:26Z", "message": "[DROOLS-4933] Refactored builders. Begin MiningModel implementation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "19ff28abb0f692680a866b94fe2452e9e9b8b836", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/19ff28abb0f692680a866b94fe2452e9e9b8b836", "committedDate": "2020-01-31T07:36:23Z", "message": "[DROOLS-4933] Keep working on MiningModel implementation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c85bd66afb70ce59af3ae6c55800dd1b55389b84", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/c85bd66afb70ce59af3ae6c55800dd1b55389b84", "committedDate": "2020-01-31T07:36:56Z", "message": "Merge remote-tracking branch 'origin/master' into DROOLS-4933"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8971e0cd3aac211c0b36bb00f37f229a60cbaed1", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/8971e0cd3aac211c0b36bb00f37f229a60cbaed1", "committedDate": "2020-01-31T09:03:12Z", "message": "[DROOLS-4933] Begin kie-pmml-mining model"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "921b348434bd8348345973588725c623cc2f4173", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/921b348434bd8348345973588725c623cc2f4173", "committedDate": "2020-01-31T09:47:17Z", "message": "[DROOLS-4933] Cleanup poms"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "713668504dd2fb49b9d52db00a34ea926765b21e", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/713668504dd2fb49b9d52db00a34ea926765b21e", "committedDate": "2020-01-31T14:39:19Z", "message": "[DROOLS-4933] Created pmml-models archetype"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "edeeedbc693b49984609d0a178434c641b546d54", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/edeeedbc693b49984609d0a178434c641b546d54", "committedDate": "2020-01-31T14:40:17Z", "message": "[DROOLS-4933] Created pmml-model-mining"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "459f819de6be5cf254c40942bf016eb5dfce5d4e", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/459f819de6be5cf254c40942bf016eb5dfce5d4e", "committedDate": "2020-01-31T14:52:40Z", "message": "[DROOLS-4933] Refactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c47c3f367473464803ed1d568c5067763442c8a", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/4c47c3f367473464803ed1d568c5067763442c8a", "committedDate": "2020-01-31T15:28:33Z", "message": "[DROOLS-4933] Created pmml-runtime archetype"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e3fd656e4750327cfc639ad1e3a531ac01711dc3", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/e3fd656e4750327cfc639ad1e3a531ac01711dc3", "committedDate": "2020-01-31T15:29:29Z", "message": "[DROOLS-4933] Created pmml-runtime-mining"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "50b56a83a99b42615d75c09c8fe80892f34f69f2", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/50b56a83a99b42615d75c09c8fe80892f34f69f2", "committedDate": "2020-01-31T17:12:39Z", "message": "[DROOLS-4933] Implemented library-commons module"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "98f66e40313bee5cf66397060cf0a8255eaa7216", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/98f66e40313bee5cf66397060cf0a8255eaa7216", "committedDate": "2020-02-06T09:34:57Z", "message": "[DROOLS-4933] Refactored log. Keep working on mining model."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "53c428bb16df9c3fb532619ce6d03b1375fff6c0", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/53c428bb16df9c3fb532619ce6d03b1375fff6c0", "committedDate": "2020-02-06T09:35:35Z", "message": "Merge remote-tracking branch 'origin/master' into DROOLS-4933"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03a4b4ddb940bf244976035b4e5a81aa490932e3", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/03a4b4ddb940bf244976035b4e5a81aa490932e3", "committedDate": "2020-02-06T10:03:27Z", "message": "[DROOLS-4933] Fixing archetypes' poms"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a143a6ffe27414701ded12c9c79b611c1738491", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/0a143a6ffe27414701ded12c9c79b611c1738491", "committedDate": "2020-02-06T10:51:08Z", "message": "[DROOLS-4933] Add Tree model overall implementation strategy description"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a8187bbf36f4f72c35d48af1cadd94209b4e3704", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/a8187bbf36f4f72c35d48af1cadd94209b4e3704", "committedDate": "2020-02-06T11:18:27Z", "message": "[DROOLS-4933] Refactored log. Updated implementation.md"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7dfc36e5428b6e36354e60c0898f19b36f9bb9ab", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/7dfc36e5428b6e36354e60c0898f19b36f9bb9ab", "committedDate": "2020-02-07T14:00:51Z", "message": "[DROOLS-4933] First implmentation of KiePMMLDescrFactory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0297c3edc6baa0e36efa5e52b3f0f950414c4d2e", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/0297c3edc6baa0e36efa5e52b3f0f950414c4d2e", "committedDate": "2020-02-07T14:42:45Z", "message": "[DROOLS-4933] Refactoring - reorganizing modules"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d44b449c659787092a93d8f45f4629bb03f9e16c", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/d44b449c659787092a93d8f45f4629bb03f9e16c", "committedDate": "2020-02-07T15:10:25Z", "message": "[DROOLS-4933] Fixed refactoring - Tree runtime broken"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a20e82e3baa8e74ff854ad163beeed608399d4ae", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/a20e82e3baa8e74ff854ad163beeed608399d4ae", "committedDate": "2020-02-07T15:59:02Z", "message": "[DROOLS-4933] Keep refactoring - moved models"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6cb5f0e6bd51bd89f1a86b7d927f556d4ffd6a48", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/6cb5f0e6bd51bd89f1a86b7d927f556d4ffd6a48", "committedDate": "2020-02-10T08:43:57Z", "message": "[DROOLS-4933] Adapting archetype. Not completely working"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba41cc61bff3b65558d299472952593e4c968dcb", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/ba41cc61bff3b65558d299472952593e4c968dcb", "committedDate": "2020-02-10T08:44:33Z", "message": "Merge remote-tracking branch 'origin/master' into DROOLS-4933"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "afc30bd72eca48f9b574ec70519d96bf6f5e604a", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/afc30bd72eca48f9b574ec70519d96bf6f5e604a", "committedDate": "2020-02-10T17:32:10Z", "message": "[DROOLS-4933] Renamed kie-pmml to kie-pmml-refactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "83bb9948d4d287964841584e03ee6be1ca0fe394", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/83bb9948d4d287964841584e03ee6be1ca0fe394", "committedDate": "2020-02-10T17:46:48Z", "message": "[DROOLS-4933] Restored kie-pmml-legacy to kie-pmml"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c5b637d10f0a2249ecc693380e5e8ebe688143a", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/5c5b637d10f0a2249ecc693380e5e8ebe688143a", "committedDate": "2020-02-10T18:09:27Z", "message": "[DROOLS-4933] Create PMML refactoring skeleton"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "67c28bfe7ced36b439175e9eba671aed5c9fb80f", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/67c28bfe7ced36b439175e9eba671aed5c9fb80f", "committedDate": "2020-02-10T18:15:50Z", "message": "[DROOLS-4933] Add test utility methods. Fixed pom"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6ca8e81b9d20f3aa192e74608c7325efcfc7d314", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/6ca8e81b9d20f3aa192e74608c7325efcfc7d314", "committedDate": "2020-02-10T18:33:01Z", "message": "[DROOLS-3339] Begin refactoring of regression model with new architecture"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a8ad88cb113e4a42a00938dbf8856a6c02195c7", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/1a8ad88cb113e4a42a00938dbf8856a6c02195c7", "committedDate": "2020-02-11T08:56:44Z", "message": "[DROOLS-4933] Add tests to kie-test-util"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1073fc4f1da4d51c1d54b7f003f189699fc62e6d", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/1073fc4f1da4d51c1d54b7f003f189699fc62e6d", "committedDate": "2020-02-11T09:03:08Z", "message": "[DROOLS-4933] Add assertions to tests inside kie-test-util"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "413738cfcbca688f64aa93deca9d5f96d2f4dc0b", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/413738cfcbca688f64aa93deca9d5f96d2f4dc0b", "committedDate": "2020-02-11T09:39:24Z", "message": "[DROOLS-3339] Begin Regression model implementation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97726c0778e26fb7815b3ad35fec88ec63ebabfe", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/97726c0778e26fb7815b3ad35fec88ec63ebabfe", "committedDate": "2020-02-11T10:02:36Z", "message": "[DROOLS-3339] Add tests to IsRegressionModel. Make KiePMMLRegressionModel constructor protected"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47c187638b8be2d807e6d187e7627e20432b4d1a", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/47c187638b8be2d807e6d187e7627e20432b4d1a", "committedDate": "2020-02-11T10:20:22Z", "message": "[DROOLS-3339] Add some fixes as per sonar suggestion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2959221c665ee2eda43afaa8b89baf75829f9f8f", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/2959221c665ee2eda43afaa8b89baf75829f9f8f", "committedDate": "2020-02-12T10:27:46Z", "message": "[DROOLS-4933] Format"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68213c4ef79d639bd3f4c70543a876ba9c69e6e5", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/68213c4ef79d639bd3f4c70543a876ba9c69e6e5", "committedDate": "2020-02-12T11:02:17Z", "message": "[DROOLS-4933] Moving kie-pmml-api to kie-pmml-commons"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a163b2d51d89d7e02401f198939201edc1123bd7", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/a163b2d51d89d7e02401f198939201edc1123bd7", "committedDate": "2020-02-12T11:28:09Z", "message": "[DROOLS-4933] Renamed kie-pmml-refactoring to kie-pmml-new"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6ef20f048ff6935f8b928c966440e33d4af8f127", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/6ef20f048ff6935f8b928c966440e33d4af8f127", "committedDate": "2020-02-12T11:44:16Z", "message": "[WIP] Renamed modules"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35439483900cb2905876ccf0bb1104b4950613f9", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/35439483900cb2905876ccf0bb1104b4950613f9", "committedDate": "2020-02-12T11:46:04Z", "message": "Merge branch 'DROOLS-4933' into PMML-REF-WIP\n\n# Conflicts:\n#\tkie-pmml-new/kie-pmml-commons/pom.xml\n#\tkie-pmml-new/kie-pmml-commons/src/test/java/org/kie/pmml/api/model/TestUtils.java\n#\tkie-pmml-new/kie-pmml-integration-tests/pom.xml\n#\tkie-pmml-new/kie-pmml-library/kie-pmml-library-api/pom.xml\n#\tkie-pmml-new/kie-pmml-library/kie-pmml-library-api/src/main/java/org/kie/pmml/library/api/implementations/ModelImplementationProvider.java\n#\tkie-pmml-new/kie-pmml-library/kie-pmml-library-api/src/main/java/org/kie/pmml/library/api/implementations/ModelImplementationProviderFinder.java\n#\tkie-pmml-new/kie-pmml-library/kie-pmml-library-api/src/test/java/org/kie/pmml/library/testutils/TestUtils.java\n#\tkie-pmml-new/kie-pmml-library/kie-pmml-library-commons/pom.xml\n#\tkie-pmml-new/kie-pmml-library/kie-pmml-library-commons/src/main/java/org/kie/pmml/library/commons/factories/KiePMMLExtensionFactory.java\n#\tkie-pmml-new/kie-pmml-library/kie-pmml-library-commons/src/main/java/org/kie/pmml/library/commons/factories/KiePMMLFieldRefFactory.java\n#\tkie-pmml-new/kie-pmml-library/kie-pmml-library-commons/src/main/java/org/kie/pmml/library/commons/implementations/KiePMMLModelRetriever.java\n#\tkie-pmml-new/kie-pmml-library/kie-pmml-library-commons/src/main/java/org/kie/pmml/library/commons/implementations/ModelImplementationProviderFinderImpl.java\n#\tkie-pmml-new/kie-pmml-library/kie-pmml-library-commons/src/main/java/org/kie/pmml/library/commons/utils/ModelUtils.java\n#\tkie-pmml-new/kie-pmml-library/kie-pmml-library-compiler/pom.xml\n#\tkie-pmml-new/kie-pmml-library/kie-pmml-library-compiler/src/main/java/org/kie/pmml/compiler/executor/PMMLCompiler.java\n#\tkie-pmml-new/kie-pmml-library/kie-pmml-library-compiler/src/main/java/org/kie/pmml/compiler/executor/PMMLCompilerImpl.java\n#\tkie-pmml-new/kie-pmml-library/kie-pmml-library-compiler/src/main/java/org/kie/pmml/compiler/utils/KiePMMLUtil.java\n#\tkie-pmml-new/kie-pmml-library/pom.xml\n#\tkie-pmml-new/kie-pmml-models/pom.xml\n#\tkie-pmml-new/kie-pmml-runtime/kie-pmml-runtime-api/pom.xml\n#\tkie-pmml-new/kie-pmml-runtime/kie-pmml-runtime-api/src/main/java/org/kie/pmml/runtime/api/container/PMMLPackage.java\n#\tkie-pmml-new/kie-pmml-runtime/kie-pmml-runtime-api/src/main/java/org/kie/pmml/runtime/api/exceptions/KiePMMLModelException.java\n#\tkie-pmml-new/kie-pmml-runtime/kie-pmml-runtime-api/src/main/java/org/kie/pmml/runtime/api/executor/PMMLContext.java\n#\tkie-pmml-new/kie-pmml-runtime/kie-pmml-runtime-api/src/main/java/org/kie/pmml/runtime/api/executor/PMMLRuntime.java\n#\tkie-pmml-new/kie-pmml-runtime/kie-pmml-runtime-assembler/pom.xml\n#\tkie-pmml-new/kie-pmml-runtime/kie-pmml-runtime-assembler/src/main/java/org/kie/pmml/assembler/PMMLWeaverService.java\n#\tkie-pmml-new/kie-pmml-runtime/kie-pmml-runtime-assembler/src/main/java/org/kie/pmml/assembler/container/PMMLPackageImpl.java\n#\tkie-pmml-new/kie-pmml-runtime/kie-pmml-runtime-assembler/src/main/java/org/kie/pmml/assembler/service/PMMLAssemblerService.java\n#\tkie-pmml-new/kie-pmml-runtime/kie-pmml-runtime-core/pom.xml\n#\tkie-pmml-new/kie-pmml-runtime/kie-pmml-runtime-core/src/main/java/org/kie/pmml/runtime/core/PMMLContextImpl.java\n#\tkie-pmml-new/kie-pmml-runtime/kie-pmml-runtime-core/src/main/java/org/kie/pmml/runtime/core/executor/PMMLModelExecutor.java\n#\tkie-pmml-new/kie-pmml-runtime/kie-pmml-runtime-core/src/main/java/org/kie/pmml/runtime/core/executor/PMMLModelExecutorFinderImpl.java\n#\tkie-pmml-new/kie-pmml-runtime/kie-pmml-runtime-core/src/main/java/org/kie/pmml/runtime/core/service/PMMLRuntimeImpl.java\n#\tkie-pmml-new/kie-pmml-runtime/kie-pmml-runtime-core/src/main/java/org/kie/pmml/runtime/core/utils/Converter.java\n#\tkie-pmml-new/kie-pmml-runtime/kie-pmml-runtime-core/src/main/java/org/kie/pmml/runtime/core/utils/PMMLRequestDataBuilder.java\n#\tkie-pmml-new/kie-pmml-runtime/pom.xml\n#\tkie-pmml-new/pom.xml\n#\tkie-test-util/src/main/java/org/kie/test/util/filesystem/FileUtils.java\n#\tkie-test-util/src/main/java/org/kie/test/util/filesystem/ResourceHelper.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "84ddf7046f3f597262b7cea67a3c67975ae15de2", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/84ddf7046f3f597262b7cea67a3c67975ae15de2", "committedDate": "2020-02-12T12:01:48Z", "message": "[WIP] Keep renaming/refactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d973ddb6be6da1b7adb0b29544cf1917aa324291", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/d973ddb6be6da1b7adb0b29544cf1917aa324291", "committedDate": "2020-02-12T13:07:25Z", "message": "[DROOLS-3339] Begin test implementation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "67f86b39b1294731de1a4f8afe34a1368a3f97ac", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/67f86b39b1294731de1a4f8afe34a1368a3f97ac", "committedDate": "2020-02-12T13:09:26Z", "message": "Merge remote-tracking branch 'gitgabrio/PMML-REF-WIP' into DROOLS-3339\n\n# Conflicts:\n#\tkie-pmml-new/kie-pmml-commons/pom.xml\n#\tkie-pmml-new/kie-pmml-commons/src/main/java/org/kie/pmml/commons/functionals/FunctionUtils.java\n#\tkie-pmml-new/kie-pmml-commons/src/main/java/org/kie/pmml/commons/interfaces/FunctionalWrapperFactory.java\n#\tkie-pmml-new/kie-pmml-commons/src/main/java/org/kie/pmml/commons/interfaces/ThrowingFunction.java\n#\tkie-pmml-new/kie-pmml-commons/src/main/java/org/kie/pmml/commons/model/KiePMMLModel.java\n#\tkie-pmml-new/kie-pmml-integration-tests/pom.xml\n#\tkie-pmml-new/kie-pmml-library/kie-pmml-library-commons/src/main/java/org/kie/pmml/library/commons/implementations/KiePMMLModelRetriever.java\n#\tkie-pmml-new/kie-pmml-library/kie-pmml-library-commons/src/main/java/org/kie/pmml/library/commons/utils/ModelUtils.java\n#\tkie-pmml-new/kie-pmml-library/kie-pmml-library-compiler/src/main/java/org/kie/pmml/compiler/executor/PMMLCompiler.java\n#\tkie-pmml-new/kie-pmml-models/pom.xml\n#\tkie-pmml-new/kie-pmml-runtime/kie-pmml-runtime-assembler/src/main/java/org/kie/pmml/assembler/service/PMMLAssemblerService.java\n#\tkie-pmml-new/kie-pmml-runtime/kie-pmml-runtime-core/src/main/java/org/kie/pmml/runtime/core/utils/Converter.java\n#\tkie-pmml-new/kie-pmml-runtime/kie-pmml-runtime-core/src/main/java/org/kie/pmml/runtime/core/utils/PMMLRequestDataBuilder.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7a381245ae84c30b84e445cc203293d9f79aeac", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/e7a381245ae84c30b84e445cc203293d9f79aeac", "committedDate": "2020-02-12T13:26:28Z", "message": "[DROOLS-3339] Merge refactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "49777dd997b3c78dc5da7b5cede42280c4133b5d", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/49777dd997b3c78dc5da7b5cede42280c4133b5d", "committedDate": "2020-02-12T13:44:04Z", "message": "[DROOLS-3339] Merge refactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa2e577cd9fe6312f1bac58da2ac236dcd0ed8c4", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/fa2e577cd9fe6312f1bac58da2ac236dcd0ed8c4", "committedDate": "2020-02-13T08:09:54Z", "message": "[DROOLS-3339] Begin integrationg of tests from previous implementation. Refactoring predictors."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f79b9743dbfccc1d6e2a3e61fda9c453e06ec30", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/1f79b9743dbfccc1d6e2a3e61fda9c453e06ec30", "committedDate": "2020-02-13T14:27:37Z", "message": "[DROOLS-3339] Reorganizing resources in integration test. Fixing broken pmmls"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "432b11e4facce1ff204aae5fa3c776132ff00eb1", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/432b11e4facce1ff204aae5fa3c776132ff00eb1", "committedDate": "2020-02-13T17:30:34Z", "message": "[DROOLS-3339] Fixed regression. Begin fixing classification. Add outputfields"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eefbc4f4f97343d54ef9915083817935bdd1aef4", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/eefbc4f4f97343d54ef9915083817935bdd1aef4", "committedDate": "2020-02-14T13:49:39Z", "message": "[DROOLS-3339] Fixed classification and add some whole-model test. Start increasing unittesting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a71bc70ac4c0a6d2e0b7600159ce092808d66a78", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/a71bc70ac4c0a6d2e0b7600159ce092808d66a78", "committedDate": "2020-02-17T14:57:27Z", "message": "[DROOLS-3339] Updated name refactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb8cd4540266533d6f5365851b74a0bd45aa0e64", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/bb8cd4540266533d6f5365851b74a0bd45aa0e64", "committedDate": "2020-02-18T08:13:11Z", "message": "[DROOLS-3339] Changed log level."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "66fb642deaf3288f9c1c3a20d2c38bfcc60d9227", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/66fb642deaf3288f9c1c3a20d2c38bfcc60d9227", "committedDate": "2020-02-18T11:09:55Z", "message": "[DROOLS-3339] Sync with base pr"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee3a56f43a5e1a7ecde49df5de863cd27ae4a2e9", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/ee3a56f43a5e1a7ecde49df5de863cd27ae4a2e9", "committedDate": "2020-02-18T11:11:08Z", "message": "Merge remote-tracking branch 'origin/master' into DROOLS-3339"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d5ee307ca406deddd9c11dc449fc45f93d5a33c3", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/d5ee307ca406deddd9c11dc449fc45f93d5a33c3", "committedDate": "2020-02-18T11:12:30Z", "message": "[DROOLS-3339] Update version"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c478acbf8b402e1da8db4976c8d7867e2bd5b1f", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/3c478acbf8b402e1da8db4976c8d7867e2bd5b1f", "committedDate": "2020-02-19T09:19:57Z", "message": "Merge remote-tracking branch 'origin/master' into DROOLS-3339\n\n# Conflicts:\n#\tkie-pmml-new/.gitignore\n#\tkie-pmml-new/kie-pmml-commons/pom.xml\n#\tkie-pmml-new/kie-pmml-commons/src/main/java/org/kie/pmml/commons/model/KiePMMLExtension.java\n#\tkie-pmml-new/kie-pmml-commons/src/main/java/org/kie/pmml/commons/model/abstracts/KiePMMLExtensioned.java\n#\tkie-pmml-new/kie-pmml-commons/src/main/java/org/kie/pmml/commons/model/abstracts/KiePMMLNamed.java\n#\tkie-pmml-new/kie-pmml-compiler/kie-pmml-compiler-commons/pom.xml\n#\tkie-pmml-new/kie-pmml-compiler/kie-pmml-compiler-commons/src/main/java/org/kie/pmml/compiler/commons/utils/ModelUtils.java\n#\tkie-pmml-new/kie-pmml-compiler/kie-pmml-compiler-core/src/main/java/org/kie/pmml/compiler/executor/PMMLCompiler.java\n#\tkie-pmml-new/kie-pmml-compiler/kie-pmml-compiler-core/src/main/java/org/kie/pmml/compiler/executor/PMMLCompilerImpl.java\n#\tkie-pmml-new/kie-pmml-evaluator/kie-pmml-evaluator-api/src/main/java/org/kie/pmml/evaluator/api/executor/PMMLRuntime.java\n#\tkie-pmml-new/kie-pmml-evaluator/kie-pmml-evaluator-assembler/src/main/java/org/kie/pmml/evaluator/assembler/service/PMMLAssemblerService.java\n#\tkie-pmml-new/kie-pmml-evaluator/kie-pmml-evaluator-core/src/main/java/org/kie/pmml/evaluator/core/service/PMMLRuntimeImpl.java\n#\tkie-pmml-new/kie-pmml-evaluator/kie-pmml-evaluator-core/src/main/java/org/kie/pmml/evaluator/core/utils/Converter.java\n#\tkie-pmml-new/kie-pmml-integration-tests/pom.xml\n#\tkie-pmml-new/kie-pmml-models/pom.xml\n#\tkie-pmml-new/pom.xml"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0252db264590eab9cb09d736af61422c60598d13", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/0252db264590eab9cb09d736af61422c60598d13", "committedDate": "2020-02-19T09:25:50Z", "message": "[DROOLS-3339] Merging master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be10d13c9c11387678bd9b952e3f755d8997f058", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/be10d13c9c11387678bd9b952e3f755d8997f058", "committedDate": "2020-02-19T09:30:45Z", "message": "[DROOLS-3339] Fixing merge with master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1dfcd04225406cf68c56c831f0cefdad5dc15989", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/1dfcd04225406cf68c56c831f0cefdad5dc15989", "committedDate": "2020-02-19T09:36:15Z", "message": "[DROOLS-3339] Fixing merge with master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "08ba9803a700031577e4ff7b916a6c491eb4257b", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/08ba9803a700031577e4ff7b916a6c491eb4257b", "committedDate": "2020-02-19T09:39:10Z", "message": "[DROOLS-3339] Fixing merge with master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f13d63392567162e43a735e023b96b803f055720", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/f13d63392567162e43a735e023b96b803f055720", "committedDate": "2020-02-19T09:45:59Z", "message": "[DROOLS-3339] Fix merge with master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d006f75f08f11c53dd9070c63d563d0b3e49363d", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/d006f75f08f11c53dd9070c63d563d0b3e49363d", "committedDate": "2020-02-19T09:58:13Z", "message": "[DROOLS-3339] Fix merge with master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f81dae86e4b8bbfefe4ee91f48b094f5de66054f", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/f81dae86e4b8bbfefe4ee91f48b094f5de66054f", "committedDate": "2020-02-19T10:05:10Z", "message": "[DROOLS-3339] Fixing merge with master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c7f8b89211ee5b049037e45a53485c623debcfb8", "author": {"user": {"login": "jiripetrlik", "name": "Jiri Petrlik"}}, "url": "https://github.com/kiegroup/drools/commit/c7f8b89211ee5b049037e45a53485c623debcfb8", "committedDate": "2020-02-19T15:24:19Z", "message": "Example of simple test for whole model"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb91454321ab75ec4ce011e7a255e62939bc3095", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/eb91454321ab75ec4ce011e7a255e62939bc3095", "committedDate": "2020-02-20T11:49:29Z", "message": "[DROOLS-3339] Implementing factories unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c8e359bbdf01bdaf471233bd554c4d9976a46246", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/c8e359bbdf01bdaf471233bd554c4d9976a46246", "committedDate": "2020-02-20T11:49:59Z", "message": "Merge branch 'DROOLS-3339' of github.com:gitgabrio/drools into DROOLS-3339"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9b6c4b41bfb33ce5732e644a6e77261ef136e01", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/c9b6c4b41bfb33ce5732e644a6e77261ef136e01", "committedDate": "2020-02-20T12:10:16Z", "message": "[DROOLS-3339] Changed outputfield - target field to Optional"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c7f5c4ae4d486f4839a67477dd63bdaf52691b0f", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/c7f5c4ae4d486f4839a67477dd63bdaf52691b0f", "committedDate": "2020-02-20T13:22:04Z", "message": "[DROOLS-3339] Add tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "60ac6321fca21660851f05c8ea01d652119579f9", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/60ac6321fca21660851f05c8ea01d652119579f9", "committedDate": "2020-02-20T13:54:01Z", "message": "[DROOLS-3339] Refactoring kie-pmml-models-regression-api -> kie-pmml-models-regression-model"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37d423724f3e36ff1464a3b46014c0331244bb83", "author": {"user": {"login": "jiripetrlik", "name": "Jiri Petrlik"}}, "url": "https://github.com/kiegroup/drools/commit/37d423724f3e36ff1464a3b46014c0331244bb83", "committedDate": "2020-02-20T14:19:00Z", "message": "Parameterize and polish NumericVariablesLinearRegressionTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5ff18f260a1fc55388b7db6c72fbc4cf33319eb7", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/5ff18f260a1fc55388b7db6c72fbc4cf33319eb7", "committedDate": "2020-02-21T09:37:55Z", "message": "[DROOLS-3339] Keep testing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1178cffc04dd79b8ec0db806bd75e435dc8fc138", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/1178cffc04dd79b8ec0db806bd75e435dc8fc138", "committedDate": "2020-02-21T09:38:42Z", "message": "Merge remote-tracking branch 'gitgabrio/DROOLS-3339' into DROOLS-3339"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86523713cb68d5b422553f9649e046279682a4bc", "author": {"user": {"login": "jiripetrlik", "name": "Jiri Petrlik"}}, "url": "https://github.com/kiegroup/drools/commit/86523713cb68d5b422553f9649e046279682a4bc", "committedDate": "2020-02-21T09:50:28Z", "message": "Change package name for PMML regression tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "564492a1ff343a8faf391e2bd30bba51abcaa66e", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/564492a1ff343a8faf391e2bd30bba51abcaa66e", "committedDate": "2020-02-21T13:24:48Z", "message": "[DROOLS-3339] Fixing/refactoring ClassificationModelEvaluator. Implemented tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29c29482c09c29a88360f73764d9e68d9f736d7a", "author": {"user": {"login": "jiripetrlik", "name": "Jiri Petrlik"}}, "url": "https://github.com/kiegroup/drools/commit/29c29482c09c29a88360f73764d9e68d9f736d7a", "committedDate": "2020-02-21T13:27:41Z", "message": "[DROOLS-5099] PMML tests for regression with numeric inputs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0139a0fe1897e5db8b7a91a9b027c183b1ef1ca8", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/drools/commit/0139a0fe1897e5db8b7a91a9b027c183b1ef1ca8", "committedDate": "2020-02-21T14:20:16Z", "message": "[DROOLS-3339] Done ClassificationModelEvaluator tests"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1621, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}