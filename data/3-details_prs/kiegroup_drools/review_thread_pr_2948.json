{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM0NjI4Nzgz", "number": 2948, "reviewThreads": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNzo0MjowNFrOEF0cCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxOTo1MzoyM1rOEGfs6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NTM3NDgwOnYy", "diffSide": "RIGHT", "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/AbstractPMMLInvocationEvaluator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNzo0MjowNFrOGkPFBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwODowNToyOVrOGkP67w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY0ODk2NQ==", "bodyText": "Is there any reason why you're attempting to load the class from the thread context class loader? Not saying it's wrong, just wondering if a plain Class.forName() wouldn't be enough in this case.", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r440648965", "createdAt": "2020-06-16T07:42:04Z", "author": {"login": "mariofusco"}, "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/AbstractPMMLInvocationEvaluator.java", "diffHunk": "@@ -143,9 +146,68 @@ public static AbstractPMMLInvocationEvaluator newInstance(DMNModelImpl model, Cl\n                                   funcDef.getIdentifierString());\n             return new AbstractPMMLInvocationEvaluator.DummyPMMLInvocationEvaluator(model.getNamespace(), funcDef, pmmlResource, pmmlModel);\n         }\n+    }\n \n-        private PMMLInvocationEvaluatorFactory() {\n-            // Constructing instances is not allowed for this Factory\n+    private static AbstractDMNKiePMMLInvocationEvaluator getAbstractDMNKiePMMLInvocationEvaluator(String nameSpace, DMNElement funcDef, Resource pmmlResource, String pmmlModel, PMMLInfo<?> pmmlInfo) {\n+        final boolean legacyImplementationPresent = isLegacyImplementationPresent();\n+        final boolean newImplementationPresent = isNewImplementationPresent();\n+        if (legacyImplementationPresent && newImplementationPresent) {\n+            if (isLegacyPMMLRequired()) {\n+                return getDMNKiePMMLInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+            } else {\n+                return getDMNKiePMMLNewInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+            }\n+        } else if (legacyImplementationPresent) {\n+            return getDMNKiePMMLInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+        } else if (newImplementationPresent) {\n+            return getDMNKiePMMLNewInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private static DMNKiePMMLInvocationEvaluator getDMNKiePMMLInvocationEvaluator(String nameSpace, DMNElement funcDef, Resource pmmlResource, String pmmlModel, PMMLInfo<?> pmmlInfo) {\n+        try {\n+            return new DMNKiePMMLInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+        } catch (NoClassDefFoundError e) {\n+            LOG.warn(\"Tried binding org.drools:kie-pmml, failed.\");\n+        } catch (Throwable e) {\n+            LOG.warn(\"Binding org.drools:kie-pmml succeded but initialization failed, with:\", e);\n+        }\n+        return null;\n+    }\n+\n+    private static DMNKiePMMLNewInvocationEvaluator getDMNKiePMMLNewInvocationEvaluator(String nameSpace, DMNElement funcDef, Resource pmmlResource, String pmmlModel, PMMLInfo<?> pmmlInfo) {\n+        try {\n+            return new DMNKiePMMLNewInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+        } catch (NoClassDefFoundError e) {\n+            LOG.warn(\"Tried binding org.drools:kie-pmml-new, failed.\");\n+        } catch (Throwable e) {\n+            throw new RuntimeException(\"Binding org.drools:kie-pmml-new succeded but initialization failed, with:\", e);\n+        }\n+        return null;\n+    }\n+\n+    private static boolean isLegacyPMMLRequired() {\n+        final String property = System.getProperty(KIE_PMML_IMPLEMENTATION.getName(), LEGACY.getName());\n+        return property.equals(LEGACY.getName());\n+    }\n+\n+    private static boolean isLegacyImplementationPresent() {\n+        try {\n+            Thread.currentThread().getContextClassLoader().loadClass(\"org.kie.pmml.pmml_4_2.PMML4ExecutionHelper\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "623f03f6b59d4baae90e927b207cae9f982beceb"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY2Mjc2Nw==", "bodyText": "@mariofusco\nReplaced with Class.forName. Seems to work.\nThanks for suggestion", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r440662767", "createdAt": "2020-06-16T08:05:29Z", "author": {"login": "gitgabrio"}, "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/AbstractPMMLInvocationEvaluator.java", "diffHunk": "@@ -143,9 +146,68 @@ public static AbstractPMMLInvocationEvaluator newInstance(DMNModelImpl model, Cl\n                                   funcDef.getIdentifierString());\n             return new AbstractPMMLInvocationEvaluator.DummyPMMLInvocationEvaluator(model.getNamespace(), funcDef, pmmlResource, pmmlModel);\n         }\n+    }\n \n-        private PMMLInvocationEvaluatorFactory() {\n-            // Constructing instances is not allowed for this Factory\n+    private static AbstractDMNKiePMMLInvocationEvaluator getAbstractDMNKiePMMLInvocationEvaluator(String nameSpace, DMNElement funcDef, Resource pmmlResource, String pmmlModel, PMMLInfo<?> pmmlInfo) {\n+        final boolean legacyImplementationPresent = isLegacyImplementationPresent();\n+        final boolean newImplementationPresent = isNewImplementationPresent();\n+        if (legacyImplementationPresent && newImplementationPresent) {\n+            if (isLegacyPMMLRequired()) {\n+                return getDMNKiePMMLInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+            } else {\n+                return getDMNKiePMMLNewInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+            }\n+        } else if (legacyImplementationPresent) {\n+            return getDMNKiePMMLInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+        } else if (newImplementationPresent) {\n+            return getDMNKiePMMLNewInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private static DMNKiePMMLInvocationEvaluator getDMNKiePMMLInvocationEvaluator(String nameSpace, DMNElement funcDef, Resource pmmlResource, String pmmlModel, PMMLInfo<?> pmmlInfo) {\n+        try {\n+            return new DMNKiePMMLInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+        } catch (NoClassDefFoundError e) {\n+            LOG.warn(\"Tried binding org.drools:kie-pmml, failed.\");\n+        } catch (Throwable e) {\n+            LOG.warn(\"Binding org.drools:kie-pmml succeded but initialization failed, with:\", e);\n+        }\n+        return null;\n+    }\n+\n+    private static DMNKiePMMLNewInvocationEvaluator getDMNKiePMMLNewInvocationEvaluator(String nameSpace, DMNElement funcDef, Resource pmmlResource, String pmmlModel, PMMLInfo<?> pmmlInfo) {\n+        try {\n+            return new DMNKiePMMLNewInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+        } catch (NoClassDefFoundError e) {\n+            LOG.warn(\"Tried binding org.drools:kie-pmml-new, failed.\");\n+        } catch (Throwable e) {\n+            throw new RuntimeException(\"Binding org.drools:kie-pmml-new succeded but initialization failed, with:\", e);\n+        }\n+        return null;\n+    }\n+\n+    private static boolean isLegacyPMMLRequired() {\n+        final String property = System.getProperty(KIE_PMML_IMPLEMENTATION.getName(), LEGACY.getName());\n+        return property.equals(LEGACY.getName());\n+    }\n+\n+    private static boolean isLegacyImplementationPresent() {\n+        try {\n+            Thread.currentThread().getContextClassLoader().loadClass(\"org.kie.pmml.pmml_4_2.PMML4ExecutionHelper\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY0ODk2NQ=="}, "originalCommit": {"oid": "623f03f6b59d4baae90e927b207cae9f982beceb"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0OTU5NTAxOnYy", "diffSide": "RIGHT", "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/AbstractDMNKiePMMLInvocationEvaluator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwNzowOTozOFrOGk4fGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwODoxMTo0OFrOGlkZXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyNzM4NA==", "bodyText": "Is this wrong? What is missing?", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r441327384", "createdAt": "2020-06-17T07:09:38Z", "author": {"login": "danielezonca"}, "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/AbstractDMNKiePMMLInvocationEvaluator.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.dmn.core.pmml;\n+\n+import java.lang.reflect.Method;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.kie.api.io.Resource;\n+import org.kie.api.pmml.PMML4Field;\n+import org.kie.api.pmml.PMML4Result;\n+import org.kie.dmn.api.core.DMNMessage;\n+import org.kie.dmn.api.core.DMNResult;\n+import org.kie.dmn.api.core.DMNType;\n+import org.kie.dmn.api.core.event.DMNRuntimeEventManager;\n+import org.kie.dmn.core.api.EvaluatorResult;\n+import org.kie.dmn.core.api.EvaluatorResult.ResultType;\n+import org.kie.dmn.core.ast.EvaluatorResultImpl;\n+import org.kie.dmn.core.impl.CompositeTypeImpl;\n+import org.kie.dmn.core.impl.DMNResultImpl;\n+import org.kie.dmn.core.util.Msg;\n+import org.kie.dmn.core.util.MsgUtil;\n+import org.kie.dmn.feel.util.EvalHelper;\n+import org.kie.dmn.model.api.DMNElement;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract <code>DMNKiePMMLInvocationEvaluator</code> to delegate actual <code>PMML4Result</code> retrieval to specific\n+ * kie-pmml implementation (legacy or new)\n+ */\n+public abstract class AbstractDMNKiePMMLInvocationEvaluator extends AbstractPMMLInvocationEvaluator {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AbstractDMNKiePMMLInvocationEvaluator.class);\n+    protected final PMMLInfo<?> pmmlInfo;\n+\n+    public AbstractDMNKiePMMLInvocationEvaluator(String dmnNS, DMNElement node, Resource pmmlResource, String model, PMMLInfo<?> pmmlInfo) {\n+        super(dmnNS, node, pmmlResource, model);\n+        this.pmmlInfo = pmmlInfo;\n+    }\n+\n+    @Override\n+    public EvaluatorResult evaluate(DMNRuntimeEventManager eventManager, DMNResult dmnr) {\n+        PMML4Result resultHolder = getPMML4Result(eventManager, dmnr);\n+\n+        Map<String, Object> resultVariables = resultHolder.getResultVariables();\n+        Map<String, Object> result = getOutputFieldValues(resultHolder, resultVariables, dmnr);\n+        if (result.isEmpty()) {\n+            result = getPredictedValues(resultHolder, dmnr);\n+        }\n+        if (result.isEmpty()) {\n+            // TO FIX\n+            MsgUtil.reportMessage(LOG,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b701f0bac31cc69636b09c32e1d8c320c510a37b"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjA0NjgxNA==", "bodyText": "@danielezonca\nleftover", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r442046814", "createdAt": "2020-06-18T08:11:48Z", "author": {"login": "gitgabrio"}, "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/AbstractDMNKiePMMLInvocationEvaluator.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.dmn.core.pmml;\n+\n+import java.lang.reflect.Method;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.kie.api.io.Resource;\n+import org.kie.api.pmml.PMML4Field;\n+import org.kie.api.pmml.PMML4Result;\n+import org.kie.dmn.api.core.DMNMessage;\n+import org.kie.dmn.api.core.DMNResult;\n+import org.kie.dmn.api.core.DMNType;\n+import org.kie.dmn.api.core.event.DMNRuntimeEventManager;\n+import org.kie.dmn.core.api.EvaluatorResult;\n+import org.kie.dmn.core.api.EvaluatorResult.ResultType;\n+import org.kie.dmn.core.ast.EvaluatorResultImpl;\n+import org.kie.dmn.core.impl.CompositeTypeImpl;\n+import org.kie.dmn.core.impl.DMNResultImpl;\n+import org.kie.dmn.core.util.Msg;\n+import org.kie.dmn.core.util.MsgUtil;\n+import org.kie.dmn.feel.util.EvalHelper;\n+import org.kie.dmn.model.api.DMNElement;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract <code>DMNKiePMMLInvocationEvaluator</code> to delegate actual <code>PMML4Result</code> retrieval to specific\n+ * kie-pmml implementation (legacy or new)\n+ */\n+public abstract class AbstractDMNKiePMMLInvocationEvaluator extends AbstractPMMLInvocationEvaluator {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AbstractDMNKiePMMLInvocationEvaluator.class);\n+    protected final PMMLInfo<?> pmmlInfo;\n+\n+    public AbstractDMNKiePMMLInvocationEvaluator(String dmnNS, DMNElement node, Resource pmmlResource, String model, PMMLInfo<?> pmmlInfo) {\n+        super(dmnNS, node, pmmlResource, model);\n+        this.pmmlInfo = pmmlInfo;\n+    }\n+\n+    @Override\n+    public EvaluatorResult evaluate(DMNRuntimeEventManager eventManager, DMNResult dmnr) {\n+        PMML4Result resultHolder = getPMML4Result(eventManager, dmnr);\n+\n+        Map<String, Object> resultVariables = resultHolder.getResultVariables();\n+        Map<String, Object> result = getOutputFieldValues(resultHolder, resultVariables, dmnr);\n+        if (result.isEmpty()) {\n+            result = getPredictedValues(resultHolder, dmnr);\n+        }\n+        if (result.isEmpty()) {\n+            // TO FIX\n+            MsgUtil.reportMessage(LOG,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyNzM4NA=="}, "originalCommit": {"oid": "b701f0bac31cc69636b09c32e1d8c320c510a37b"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MDYxMjY5OnYy", "diffSide": "RIGHT", "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/AbstractPMMLInvocationEvaluator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMjowMTozMlrOGlCiFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwODoxMTozMlrOGlkYug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ5MTk5MQ==", "bodyText": "What about wrap decision logic to a method like checkPMMLavailability that just returns LEGACY or NEW?\nI think it could improve readability", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r441491991", "createdAt": "2020-06-17T12:01:32Z", "author": {"login": "danielezonca"}, "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/AbstractPMMLInvocationEvaluator.java", "diffHunk": "@@ -143,9 +146,68 @@ public static AbstractPMMLInvocationEvaluator newInstance(DMNModelImpl model, Cl\n                                   funcDef.getIdentifierString());\n             return new AbstractPMMLInvocationEvaluator.DummyPMMLInvocationEvaluator(model.getNamespace(), funcDef, pmmlResource, pmmlModel);\n         }\n+    }\n \n-        private PMMLInvocationEvaluatorFactory() {\n-            // Constructing instances is not allowed for this Factory\n+    private static AbstractDMNKiePMMLInvocationEvaluator getAbstractDMNKiePMMLInvocationEvaluator(String nameSpace, DMNElement funcDef, Resource pmmlResource, String pmmlModel, PMMLInfo<?> pmmlInfo) {\n+        final boolean legacyImplementationPresent = isLegacyImplementationPresent();\n+        final boolean newImplementationPresent = isNewImplementationPresent();\n+        if (legacyImplementationPresent && newImplementationPresent) {\n+            if (isLegacyPMMLRequired()) {\n+                return getDMNKiePMMLInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+            } else {\n+                return getDMNKiePMMLNewInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+            }\n+        } else if (legacyImplementationPresent) {\n+            return getDMNKiePMMLInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+        } else if (newImplementationPresent) {\n+            return getDMNKiePMMLNewInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+        } else {\n+            return null;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b701f0bac31cc69636b09c32e1d8c320c510a37b"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjA0NjY1MA==", "bodyText": "@danielezonca\nDone", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r442046650", "createdAt": "2020-06-18T08:11:32Z", "author": {"login": "gitgabrio"}, "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/AbstractPMMLInvocationEvaluator.java", "diffHunk": "@@ -143,9 +146,68 @@ public static AbstractPMMLInvocationEvaluator newInstance(DMNModelImpl model, Cl\n                                   funcDef.getIdentifierString());\n             return new AbstractPMMLInvocationEvaluator.DummyPMMLInvocationEvaluator(model.getNamespace(), funcDef, pmmlResource, pmmlModel);\n         }\n+    }\n \n-        private PMMLInvocationEvaluatorFactory() {\n-            // Constructing instances is not allowed for this Factory\n+    private static AbstractDMNKiePMMLInvocationEvaluator getAbstractDMNKiePMMLInvocationEvaluator(String nameSpace, DMNElement funcDef, Resource pmmlResource, String pmmlModel, PMMLInfo<?> pmmlInfo) {\n+        final boolean legacyImplementationPresent = isLegacyImplementationPresent();\n+        final boolean newImplementationPresent = isNewImplementationPresent();\n+        if (legacyImplementationPresent && newImplementationPresent) {\n+            if (isLegacyPMMLRequired()) {\n+                return getDMNKiePMMLInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+            } else {\n+                return getDMNKiePMMLNewInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+            }\n+        } else if (legacyImplementationPresent) {\n+            return getDMNKiePMMLInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+        } else if (newImplementationPresent) {\n+            return getDMNKiePMMLNewInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+        } else {\n+            return null;\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ5MTk5MQ=="}, "originalCommit": {"oid": "b701f0bac31cc69636b09c32e1d8c320c510a37b"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MDc1Mzk3OnYy", "diffSide": "RIGHT", "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/util/KieHelper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMjo0MzowMFrOGlD66g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwODoxMToyOFrOGlkYjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxNDczMA==", "bodyText": "To be removed", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r441514730", "createdAt": "2020-06-17T12:43:00Z", "author": {"login": "danielezonca"}, "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/util/KieHelper.java", "diffHunk": "@@ -30,11 +30,16 @@\n \n public final class KieHelper {\n \n+    private KieHelper() {\n+        // Constructing instances is not allowed for this class\n+    }\n+\n     public static KieContainer getKieContainer(ReleaseId releaseId,\n-                                               Resource... resources ) {\n+                                               Resource... resources) {\n         KieServices ks = KieServices.Factory.get();\n-        createAndDeployJar( ks, releaseId, resources );\n-        return ks.newKieContainer( releaseId );\n+//        createAndDeployJar( ks, releaseId, resources );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b701f0bac31cc69636b09c32e1d8c320c510a37b"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjA0NjYwNA==", "bodyText": "@danielezonca\nDone", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r442046604", "createdAt": "2020-06-18T08:11:28Z", "author": {"login": "gitgabrio"}, "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/util/KieHelper.java", "diffHunk": "@@ -30,11 +30,16 @@\n \n public final class KieHelper {\n \n+    private KieHelper() {\n+        // Constructing instances is not allowed for this class\n+    }\n+\n     public static KieContainer getKieContainer(ReleaseId releaseId,\n-                                               Resource... resources ) {\n+                                               Resource... resources) {\n         KieServices ks = KieServices.Factory.get();\n-        createAndDeployJar( ks, releaseId, resources );\n-        return ks.newKieContainer( releaseId );\n+//        createAndDeployJar( ks, releaseId, resources );", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxNDczMA=="}, "originalCommit": {"oid": "b701f0bac31cc69636b09c32e1d8c320c510a37b"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTI1NTgyOnYy", "diffSide": "RIGHT", "path": "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/pmml/DMNNaiveBayesPMMLTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNDozOTo0MFrOGlI-Ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwODoxMToyM1rOGlkYaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU5NzQ0Mg==", "bodyText": "Is it possible to move this code to AbstractDMNPMMLTest? It seems to me always the same", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r441597442", "createdAt": "2020-06-17T14:39:40Z", "author": {"login": "danielezonca"}, "path": "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/pmml/DMNNaiveBayesPMMLTest.java", "diffHunk": "@@ -30,12 +31,22 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-public class DMNNaiveBayesPMMLTest {\n+import static org.kie.api.pmml.PMMLConstants.KIE_PMML_IMPLEMENTATION;\n+import static org.kie.api.pmml.PMMLConstants.LEGACY;\n+import static org.kie.dmn.core.util.DMNRuntimeUtil.resetServices;\n+\n+public class DMNNaiveBayesPMMLTest extends AbstractDMNPMMLTest {\n     private static final Logger LOG = LoggerFactory.getLogger(DMNNaiveBayesPMMLTest.class);\n \n     private DMNRuntime runtime;\n     private DMNModel dmnModel;\n \n+    @Before\n+    public void resetEnvironment() {\n+        LOG.debug(\"resetEnvironment\");\n+        resetEnvironment(LEGACY.getName());\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b701f0bac31cc69636b09c32e1d8c320c510a37b"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjA0NjU2OA==", "bodyText": "@danielezonca\nThe parameter is different - tests for new kiepmml should invoke it with \"NEW.getName()\", while the other tests should use \"LEGACY.getName()\"; (fixed inside DMNTreePMMLNewImplTest)", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r442046568", "createdAt": "2020-06-18T08:11:23Z", "author": {"login": "gitgabrio"}, "path": "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/pmml/DMNNaiveBayesPMMLTest.java", "diffHunk": "@@ -30,12 +31,22 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-public class DMNNaiveBayesPMMLTest {\n+import static org.kie.api.pmml.PMMLConstants.KIE_PMML_IMPLEMENTATION;\n+import static org.kie.api.pmml.PMMLConstants.LEGACY;\n+import static org.kie.dmn.core.util.DMNRuntimeUtil.resetServices;\n+\n+public class DMNNaiveBayesPMMLTest extends AbstractDMNPMMLTest {\n     private static final Logger LOG = LoggerFactory.getLogger(DMNNaiveBayesPMMLTest.class);\n \n     private DMNRuntime runtime;\n     private DMNModel dmnModel;\n \n+    @Before\n+    public void resetEnvironment() {\n+        LOG.debug(\"resetEnvironment\");\n+        resetEnvironment(LEGACY.getName());\n+    }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU5NzQ0Mg=="}, "originalCommit": {"oid": "b701f0bac31cc69636b09c32e1d8c320c510a37b"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTI2Nzg1OnYy", "diffSide": "RIGHT", "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/DMNKiePMMLNewInvocationEvaluator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNDo0MjoyMVrOGlJF0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwODoxMToxOVrOGlkYOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU5OTQ0MQ==", "bodyText": "Can you please add logging in both branches (debug should be fine)?", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r441599441", "createdAt": "2020-06-17T14:42:21Z", "author": {"login": "danielezonca"}, "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/DMNKiePMMLNewInvocationEvaluator.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.dmn.core.pmml;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import org.drools.core.impl.KnowledgeBaseImpl;\n+import org.kie.api.KieBase;\n+import org.kie.api.io.Resource;\n+import org.kie.api.pmml.PMML4Result;\n+import org.kie.api.runtime.KieContainer;\n+import org.kie.api.runtime.KieRuntimeFactory;\n+import org.kie.dmn.api.core.DMNMessage;\n+import org.kie.dmn.api.core.DMNResult;\n+import org.kie.dmn.api.core.event.DMNRuntimeEventManager;\n+import org.kie.dmn.core.ast.DMNFunctionDefinitionEvaluator.FormalParameter;\n+import org.kie.dmn.core.impl.DMNResultImpl;\n+import org.kie.dmn.core.impl.DMNRuntimeImpl;\n+import org.kie.dmn.core.util.Msg;\n+import org.kie.dmn.core.util.MsgUtil;\n+import org.kie.dmn.feel.util.EvalHelper;\n+import org.kie.dmn.model.api.DMNElement;\n+import org.kie.pmml.evaluator.api.executor.PMMLContext;\n+import org.kie.pmml.evaluator.api.executor.PMMLRuntime;\n+import org.kie.pmml.evaluator.core.PMMLContextImpl;\n+import org.kie.pmml.evaluator.core.utils.PMMLRequestDataBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.pmml.commons.utils.KiePMMLModelUtils.getSanitizedPackageName;\n+\n+public class DMNKiePMMLNewInvocationEvaluator extends AbstractDMNKiePMMLInvocationEvaluator {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(DMNKiePMMLNewInvocationEvaluator.class);\n+\n+    public DMNKiePMMLNewInvocationEvaluator(String dmnNS, DMNElement node, Resource pmmlResource, String model, PMMLInfo<?> pmmlInfo) {\n+        super(dmnNS, node, pmmlResource, model, pmmlInfo);\n+    }\n+\n+    @Override\n+    protected PMML4Result getPMML4Result(DMNRuntimeEventManager eventManager, DMNResult dmnr) {\n+        LOG.debug(\"getPMML4Result\");\n+        PMMLContext pmmlContext = getPMMLPMMLContext(UUID.randomUUID().toString(), model, dmnr);\n+        String sanitizedKieBase = getSanitizedPackageName(model);\n+        PMMLRuntime pmmlRuntime = getPMMLRuntime(eventManager, sanitizedKieBase);\n+        return pmmlRuntime.evaluate(model, pmmlContext);\n+    }\n+\n+    @Override\n+    protected Map<String, Object> getOutputFieldValues(PMML4Result pmml4Result, Map<String, Object> resultVariables, DMNResult dmnr) {\n+        LOG.debug(\"getOutputFieldValues\");\n+        Map<String, Object> toReturn = new HashMap<>();\n+        for (Map.Entry<String, Object> kv : resultVariables.entrySet()) {\n+            String resultName = kv.getKey();\n+            if (resultName == null || resultName.isEmpty()) {\n+                continue;\n+            }\n+            Object r = kv.getValue();\n+            populateWithObject(toReturn, kv.getKey(), r, dmnr);\n+        }\n+        return toReturn;\n+    }\n+\n+    @Override\n+    protected Map<String, Object> getPredictedValues(PMML4Result pmml4Result, DMNResult dmnr) {\n+        LOG.debug(\"pmml4Result\");\n+        Map<String, Object> toReturn = new HashMap<>();\n+        String resultName = pmml4Result.getResultObjectName();\n+        Object value = pmml4Result.getResultVariables().get(resultName);\n+        toReturn.put(resultName, EvalHelper.coerceNumber(value));\n+        return toReturn;\n+    }\n+\n+    private void populateWithObject(Map<String, Object> toPopulate, String resultName, Object r, DMNResult dmnr) {\n+        Optional<String> outputFieldNameFromInfo = getOutputFieldNameFromInfo(resultName);\n+        if (outputFieldNameFromInfo.isPresent()) {\n+            String name = outputFieldNameFromInfo.get();\n+            try {\n+                toPopulate.put(name, EvalHelper.coerceNumber(r));\n+            } catch (Throwable e) {\n+                MsgUtil.reportMessage(LOG,\n+                                      DMNMessage.Severity.WARN,\n+                                      node,\n+                                      ((DMNResultImpl) dmnr),\n+                                      e,\n+                                      null,\n+                                      Msg.INVALID_NAME,\n+                                      name,\n+                                      e.getMessage());\n+                toPopulate.put(name, null);\n+            }\n+        }\n+    }\n+\n+    private PMMLRuntime getPMMLRuntime(DMNRuntimeEventManager eventManager, String sanitizedKieBase) {\n+        KnowledgeBaseImpl knowledgeBase = ((KnowledgeBaseImpl) ((DMNRuntimeImpl) eventManager.getRuntime()).getInternalKnowledgeBase());\n+        KieContainer kieContainer = knowledgeBase.getKieContainer();\n+        KieBase kieBase;\n+        if (kieContainer.getKieBaseNames().contains(sanitizedKieBase)) {\n+            kieBase = kieContainer.getKieBase(sanitizedKieBase);\n+        } else {\n+            kieBase = kieContainer.getKieBase();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b701f0bac31cc69636b09c32e1d8c320c510a37b"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjA0NjUyMg==", "bodyText": "@danielezonca\ndone", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r442046522", "createdAt": "2020-06-18T08:11:19Z", "author": {"login": "gitgabrio"}, "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/DMNKiePMMLNewInvocationEvaluator.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.dmn.core.pmml;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import org.drools.core.impl.KnowledgeBaseImpl;\n+import org.kie.api.KieBase;\n+import org.kie.api.io.Resource;\n+import org.kie.api.pmml.PMML4Result;\n+import org.kie.api.runtime.KieContainer;\n+import org.kie.api.runtime.KieRuntimeFactory;\n+import org.kie.dmn.api.core.DMNMessage;\n+import org.kie.dmn.api.core.DMNResult;\n+import org.kie.dmn.api.core.event.DMNRuntimeEventManager;\n+import org.kie.dmn.core.ast.DMNFunctionDefinitionEvaluator.FormalParameter;\n+import org.kie.dmn.core.impl.DMNResultImpl;\n+import org.kie.dmn.core.impl.DMNRuntimeImpl;\n+import org.kie.dmn.core.util.Msg;\n+import org.kie.dmn.core.util.MsgUtil;\n+import org.kie.dmn.feel.util.EvalHelper;\n+import org.kie.dmn.model.api.DMNElement;\n+import org.kie.pmml.evaluator.api.executor.PMMLContext;\n+import org.kie.pmml.evaluator.api.executor.PMMLRuntime;\n+import org.kie.pmml.evaluator.core.PMMLContextImpl;\n+import org.kie.pmml.evaluator.core.utils.PMMLRequestDataBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.pmml.commons.utils.KiePMMLModelUtils.getSanitizedPackageName;\n+\n+public class DMNKiePMMLNewInvocationEvaluator extends AbstractDMNKiePMMLInvocationEvaluator {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(DMNKiePMMLNewInvocationEvaluator.class);\n+\n+    public DMNKiePMMLNewInvocationEvaluator(String dmnNS, DMNElement node, Resource pmmlResource, String model, PMMLInfo<?> pmmlInfo) {\n+        super(dmnNS, node, pmmlResource, model, pmmlInfo);\n+    }\n+\n+    @Override\n+    protected PMML4Result getPMML4Result(DMNRuntimeEventManager eventManager, DMNResult dmnr) {\n+        LOG.debug(\"getPMML4Result\");\n+        PMMLContext pmmlContext = getPMMLPMMLContext(UUID.randomUUID().toString(), model, dmnr);\n+        String sanitizedKieBase = getSanitizedPackageName(model);\n+        PMMLRuntime pmmlRuntime = getPMMLRuntime(eventManager, sanitizedKieBase);\n+        return pmmlRuntime.evaluate(model, pmmlContext);\n+    }\n+\n+    @Override\n+    protected Map<String, Object> getOutputFieldValues(PMML4Result pmml4Result, Map<String, Object> resultVariables, DMNResult dmnr) {\n+        LOG.debug(\"getOutputFieldValues\");\n+        Map<String, Object> toReturn = new HashMap<>();\n+        for (Map.Entry<String, Object> kv : resultVariables.entrySet()) {\n+            String resultName = kv.getKey();\n+            if (resultName == null || resultName.isEmpty()) {\n+                continue;\n+            }\n+            Object r = kv.getValue();\n+            populateWithObject(toReturn, kv.getKey(), r, dmnr);\n+        }\n+        return toReturn;\n+    }\n+\n+    @Override\n+    protected Map<String, Object> getPredictedValues(PMML4Result pmml4Result, DMNResult dmnr) {\n+        LOG.debug(\"pmml4Result\");\n+        Map<String, Object> toReturn = new HashMap<>();\n+        String resultName = pmml4Result.getResultObjectName();\n+        Object value = pmml4Result.getResultVariables().get(resultName);\n+        toReturn.put(resultName, EvalHelper.coerceNumber(value));\n+        return toReturn;\n+    }\n+\n+    private void populateWithObject(Map<String, Object> toPopulate, String resultName, Object r, DMNResult dmnr) {\n+        Optional<String> outputFieldNameFromInfo = getOutputFieldNameFromInfo(resultName);\n+        if (outputFieldNameFromInfo.isPresent()) {\n+            String name = outputFieldNameFromInfo.get();\n+            try {\n+                toPopulate.put(name, EvalHelper.coerceNumber(r));\n+            } catch (Throwable e) {\n+                MsgUtil.reportMessage(LOG,\n+                                      DMNMessage.Severity.WARN,\n+                                      node,\n+                                      ((DMNResultImpl) dmnr),\n+                                      e,\n+                                      null,\n+                                      Msg.INVALID_NAME,\n+                                      name,\n+                                      e.getMessage());\n+                toPopulate.put(name, null);\n+            }\n+        }\n+    }\n+\n+    private PMMLRuntime getPMMLRuntime(DMNRuntimeEventManager eventManager, String sanitizedKieBase) {\n+        KnowledgeBaseImpl knowledgeBase = ((KnowledgeBaseImpl) ((DMNRuntimeImpl) eventManager.getRuntime()).getInternalKnowledgeBase());\n+        KieContainer kieContainer = knowledgeBase.getKieContainer();\n+        KieBase kieBase;\n+        if (kieContainer.getKieBaseNames().contains(sanitizedKieBase)) {\n+            kieBase = kieContainer.getKieBase(sanitizedKieBase);\n+        } else {\n+            kieBase = kieContainer.getKieBase();\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU5OTQ0MQ=="}, "originalCommit": {"oid": "b701f0bac31cc69636b09c32e1d8c320c510a37b"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTI2OTg4OnYy", "diffSide": "RIGHT", "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/DMNKiePMMLNewInvocationEvaluator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNDo0Mjo0OVrOGlJHOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwODoxMToxNlrOGlkYEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU5OTgwMQ==", "bodyText": "Can you please remove them or move to trace level?", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r441599801", "createdAt": "2020-06-17T14:42:49Z", "author": {"login": "danielezonca"}, "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/DMNKiePMMLNewInvocationEvaluator.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.dmn.core.pmml;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import org.drools.core.impl.KnowledgeBaseImpl;\n+import org.kie.api.KieBase;\n+import org.kie.api.io.Resource;\n+import org.kie.api.pmml.PMML4Result;\n+import org.kie.api.runtime.KieContainer;\n+import org.kie.api.runtime.KieRuntimeFactory;\n+import org.kie.dmn.api.core.DMNMessage;\n+import org.kie.dmn.api.core.DMNResult;\n+import org.kie.dmn.api.core.event.DMNRuntimeEventManager;\n+import org.kie.dmn.core.ast.DMNFunctionDefinitionEvaluator.FormalParameter;\n+import org.kie.dmn.core.impl.DMNResultImpl;\n+import org.kie.dmn.core.impl.DMNRuntimeImpl;\n+import org.kie.dmn.core.util.Msg;\n+import org.kie.dmn.core.util.MsgUtil;\n+import org.kie.dmn.feel.util.EvalHelper;\n+import org.kie.dmn.model.api.DMNElement;\n+import org.kie.pmml.evaluator.api.executor.PMMLContext;\n+import org.kie.pmml.evaluator.api.executor.PMMLRuntime;\n+import org.kie.pmml.evaluator.core.PMMLContextImpl;\n+import org.kie.pmml.evaluator.core.utils.PMMLRequestDataBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.pmml.commons.utils.KiePMMLModelUtils.getSanitizedPackageName;\n+\n+public class DMNKiePMMLNewInvocationEvaluator extends AbstractDMNKiePMMLInvocationEvaluator {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(DMNKiePMMLNewInvocationEvaluator.class);\n+\n+    public DMNKiePMMLNewInvocationEvaluator(String dmnNS, DMNElement node, Resource pmmlResource, String model, PMMLInfo<?> pmmlInfo) {\n+        super(dmnNS, node, pmmlResource, model, pmmlInfo);\n+    }\n+\n+    @Override\n+    protected PMML4Result getPMML4Result(DMNRuntimeEventManager eventManager, DMNResult dmnr) {\n+        LOG.debug(\"getPMML4Result\");\n+        PMMLContext pmmlContext = getPMMLPMMLContext(UUID.randomUUID().toString(), model, dmnr);\n+        String sanitizedKieBase = getSanitizedPackageName(model);\n+        PMMLRuntime pmmlRuntime = getPMMLRuntime(eventManager, sanitizedKieBase);\n+        return pmmlRuntime.evaluate(model, pmmlContext);\n+    }\n+\n+    @Override\n+    protected Map<String, Object> getOutputFieldValues(PMML4Result pmml4Result, Map<String, Object> resultVariables, DMNResult dmnr) {\n+        LOG.debug(\"getOutputFieldValues\");\n+        Map<String, Object> toReturn = new HashMap<>();\n+        for (Map.Entry<String, Object> kv : resultVariables.entrySet()) {\n+            String resultName = kv.getKey();\n+            if (resultName == null || resultName.isEmpty()) {\n+                continue;\n+            }\n+            Object r = kv.getValue();\n+            populateWithObject(toReturn, kv.getKey(), r, dmnr);\n+        }\n+        return toReturn;\n+    }\n+\n+    @Override\n+    protected Map<String, Object> getPredictedValues(PMML4Result pmml4Result, DMNResult dmnr) {\n+        LOG.debug(\"pmml4Result\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b701f0bac31cc69636b09c32e1d8c320c510a37b"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjA0NjQ4MQ==", "bodyText": "@danielezonca\ndone", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r442046481", "createdAt": "2020-06-18T08:11:16Z", "author": {"login": "gitgabrio"}, "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/DMNKiePMMLNewInvocationEvaluator.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.dmn.core.pmml;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import org.drools.core.impl.KnowledgeBaseImpl;\n+import org.kie.api.KieBase;\n+import org.kie.api.io.Resource;\n+import org.kie.api.pmml.PMML4Result;\n+import org.kie.api.runtime.KieContainer;\n+import org.kie.api.runtime.KieRuntimeFactory;\n+import org.kie.dmn.api.core.DMNMessage;\n+import org.kie.dmn.api.core.DMNResult;\n+import org.kie.dmn.api.core.event.DMNRuntimeEventManager;\n+import org.kie.dmn.core.ast.DMNFunctionDefinitionEvaluator.FormalParameter;\n+import org.kie.dmn.core.impl.DMNResultImpl;\n+import org.kie.dmn.core.impl.DMNRuntimeImpl;\n+import org.kie.dmn.core.util.Msg;\n+import org.kie.dmn.core.util.MsgUtil;\n+import org.kie.dmn.feel.util.EvalHelper;\n+import org.kie.dmn.model.api.DMNElement;\n+import org.kie.pmml.evaluator.api.executor.PMMLContext;\n+import org.kie.pmml.evaluator.api.executor.PMMLRuntime;\n+import org.kie.pmml.evaluator.core.PMMLContextImpl;\n+import org.kie.pmml.evaluator.core.utils.PMMLRequestDataBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.pmml.commons.utils.KiePMMLModelUtils.getSanitizedPackageName;\n+\n+public class DMNKiePMMLNewInvocationEvaluator extends AbstractDMNKiePMMLInvocationEvaluator {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(DMNKiePMMLNewInvocationEvaluator.class);\n+\n+    public DMNKiePMMLNewInvocationEvaluator(String dmnNS, DMNElement node, Resource pmmlResource, String model, PMMLInfo<?> pmmlInfo) {\n+        super(dmnNS, node, pmmlResource, model, pmmlInfo);\n+    }\n+\n+    @Override\n+    protected PMML4Result getPMML4Result(DMNRuntimeEventManager eventManager, DMNResult dmnr) {\n+        LOG.debug(\"getPMML4Result\");\n+        PMMLContext pmmlContext = getPMMLPMMLContext(UUID.randomUUID().toString(), model, dmnr);\n+        String sanitizedKieBase = getSanitizedPackageName(model);\n+        PMMLRuntime pmmlRuntime = getPMMLRuntime(eventManager, sanitizedKieBase);\n+        return pmmlRuntime.evaluate(model, pmmlContext);\n+    }\n+\n+    @Override\n+    protected Map<String, Object> getOutputFieldValues(PMML4Result pmml4Result, Map<String, Object> resultVariables, DMNResult dmnr) {\n+        LOG.debug(\"getOutputFieldValues\");\n+        Map<String, Object> toReturn = new HashMap<>();\n+        for (Map.Entry<String, Object> kv : resultVariables.entrySet()) {\n+            String resultName = kv.getKey();\n+            if (resultName == null || resultName.isEmpty()) {\n+                continue;\n+            }\n+            Object r = kv.getValue();\n+            populateWithObject(toReturn, kv.getKey(), r, dmnr);\n+        }\n+        return toReturn;\n+    }\n+\n+    @Override\n+    protected Map<String, Object> getPredictedValues(PMML4Result pmml4Result, DMNResult dmnr) {\n+        LOG.debug(\"pmml4Result\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU5OTgwMQ=="}, "originalCommit": {"oid": "b701f0bac31cc69636b09c32e1d8c320c510a37b"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTI3MDQ0OnYy", "diffSide": "RIGHT", "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/DMNKiePMMLNewInvocationEvaluator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNDo0Mjo1NVrOGlJHjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwODoxMTowOVrOGlkX1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU5OTg4Ng==", "bodyText": "Can you please remove them or move to trace level?", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r441599886", "createdAt": "2020-06-17T14:42:55Z", "author": {"login": "danielezonca"}, "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/DMNKiePMMLNewInvocationEvaluator.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.dmn.core.pmml;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import org.drools.core.impl.KnowledgeBaseImpl;\n+import org.kie.api.KieBase;\n+import org.kie.api.io.Resource;\n+import org.kie.api.pmml.PMML4Result;\n+import org.kie.api.runtime.KieContainer;\n+import org.kie.api.runtime.KieRuntimeFactory;\n+import org.kie.dmn.api.core.DMNMessage;\n+import org.kie.dmn.api.core.DMNResult;\n+import org.kie.dmn.api.core.event.DMNRuntimeEventManager;\n+import org.kie.dmn.core.ast.DMNFunctionDefinitionEvaluator.FormalParameter;\n+import org.kie.dmn.core.impl.DMNResultImpl;\n+import org.kie.dmn.core.impl.DMNRuntimeImpl;\n+import org.kie.dmn.core.util.Msg;\n+import org.kie.dmn.core.util.MsgUtil;\n+import org.kie.dmn.feel.util.EvalHelper;\n+import org.kie.dmn.model.api.DMNElement;\n+import org.kie.pmml.evaluator.api.executor.PMMLContext;\n+import org.kie.pmml.evaluator.api.executor.PMMLRuntime;\n+import org.kie.pmml.evaluator.core.PMMLContextImpl;\n+import org.kie.pmml.evaluator.core.utils.PMMLRequestDataBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.pmml.commons.utils.KiePMMLModelUtils.getSanitizedPackageName;\n+\n+public class DMNKiePMMLNewInvocationEvaluator extends AbstractDMNKiePMMLInvocationEvaluator {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(DMNKiePMMLNewInvocationEvaluator.class);\n+\n+    public DMNKiePMMLNewInvocationEvaluator(String dmnNS, DMNElement node, Resource pmmlResource, String model, PMMLInfo<?> pmmlInfo) {\n+        super(dmnNS, node, pmmlResource, model, pmmlInfo);\n+    }\n+\n+    @Override\n+    protected PMML4Result getPMML4Result(DMNRuntimeEventManager eventManager, DMNResult dmnr) {\n+        LOG.debug(\"getPMML4Result\");\n+        PMMLContext pmmlContext = getPMMLPMMLContext(UUID.randomUUID().toString(), model, dmnr);\n+        String sanitizedKieBase = getSanitizedPackageName(model);\n+        PMMLRuntime pmmlRuntime = getPMMLRuntime(eventManager, sanitizedKieBase);\n+        return pmmlRuntime.evaluate(model, pmmlContext);\n+    }\n+\n+    @Override\n+    protected Map<String, Object> getOutputFieldValues(PMML4Result pmml4Result, Map<String, Object> resultVariables, DMNResult dmnr) {\n+        LOG.debug(\"getOutputFieldValues\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b701f0bac31cc69636b09c32e1d8c320c510a37b"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjA0NjQyMQ==", "bodyText": "@danielezonca\ndone", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r442046421", "createdAt": "2020-06-18T08:11:09Z", "author": {"login": "gitgabrio"}, "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/DMNKiePMMLNewInvocationEvaluator.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.dmn.core.pmml;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import org.drools.core.impl.KnowledgeBaseImpl;\n+import org.kie.api.KieBase;\n+import org.kie.api.io.Resource;\n+import org.kie.api.pmml.PMML4Result;\n+import org.kie.api.runtime.KieContainer;\n+import org.kie.api.runtime.KieRuntimeFactory;\n+import org.kie.dmn.api.core.DMNMessage;\n+import org.kie.dmn.api.core.DMNResult;\n+import org.kie.dmn.api.core.event.DMNRuntimeEventManager;\n+import org.kie.dmn.core.ast.DMNFunctionDefinitionEvaluator.FormalParameter;\n+import org.kie.dmn.core.impl.DMNResultImpl;\n+import org.kie.dmn.core.impl.DMNRuntimeImpl;\n+import org.kie.dmn.core.util.Msg;\n+import org.kie.dmn.core.util.MsgUtil;\n+import org.kie.dmn.feel.util.EvalHelper;\n+import org.kie.dmn.model.api.DMNElement;\n+import org.kie.pmml.evaluator.api.executor.PMMLContext;\n+import org.kie.pmml.evaluator.api.executor.PMMLRuntime;\n+import org.kie.pmml.evaluator.core.PMMLContextImpl;\n+import org.kie.pmml.evaluator.core.utils.PMMLRequestDataBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.pmml.commons.utils.KiePMMLModelUtils.getSanitizedPackageName;\n+\n+public class DMNKiePMMLNewInvocationEvaluator extends AbstractDMNKiePMMLInvocationEvaluator {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(DMNKiePMMLNewInvocationEvaluator.class);\n+\n+    public DMNKiePMMLNewInvocationEvaluator(String dmnNS, DMNElement node, Resource pmmlResource, String model, PMMLInfo<?> pmmlInfo) {\n+        super(dmnNS, node, pmmlResource, model, pmmlInfo);\n+    }\n+\n+    @Override\n+    protected PMML4Result getPMML4Result(DMNRuntimeEventManager eventManager, DMNResult dmnr) {\n+        LOG.debug(\"getPMML4Result\");\n+        PMMLContext pmmlContext = getPMMLPMMLContext(UUID.randomUUID().toString(), model, dmnr);\n+        String sanitizedKieBase = getSanitizedPackageName(model);\n+        PMMLRuntime pmmlRuntime = getPMMLRuntime(eventManager, sanitizedKieBase);\n+        return pmmlRuntime.evaluate(model, pmmlContext);\n+    }\n+\n+    @Override\n+    protected Map<String, Object> getOutputFieldValues(PMML4Result pmml4Result, Map<String, Object> resultVariables, DMNResult dmnr) {\n+        LOG.debug(\"getOutputFieldValues\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU5OTg4Ng=="}, "originalCommit": {"oid": "b701f0bac31cc69636b09c32e1d8c320c510a37b"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTI3MDg5OnYy", "diffSide": "RIGHT", "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/DMNKiePMMLNewInvocationEvaluator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNDo0MzowMlrOGlJH3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwODoxMTowNVrOGlkXnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU5OTk2NQ==", "bodyText": "Can you please remove them or move to trace level?", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r441599965", "createdAt": "2020-06-17T14:43:02Z", "author": {"login": "danielezonca"}, "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/DMNKiePMMLNewInvocationEvaluator.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.dmn.core.pmml;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import org.drools.core.impl.KnowledgeBaseImpl;\n+import org.kie.api.KieBase;\n+import org.kie.api.io.Resource;\n+import org.kie.api.pmml.PMML4Result;\n+import org.kie.api.runtime.KieContainer;\n+import org.kie.api.runtime.KieRuntimeFactory;\n+import org.kie.dmn.api.core.DMNMessage;\n+import org.kie.dmn.api.core.DMNResult;\n+import org.kie.dmn.api.core.event.DMNRuntimeEventManager;\n+import org.kie.dmn.core.ast.DMNFunctionDefinitionEvaluator.FormalParameter;\n+import org.kie.dmn.core.impl.DMNResultImpl;\n+import org.kie.dmn.core.impl.DMNRuntimeImpl;\n+import org.kie.dmn.core.util.Msg;\n+import org.kie.dmn.core.util.MsgUtil;\n+import org.kie.dmn.feel.util.EvalHelper;\n+import org.kie.dmn.model.api.DMNElement;\n+import org.kie.pmml.evaluator.api.executor.PMMLContext;\n+import org.kie.pmml.evaluator.api.executor.PMMLRuntime;\n+import org.kie.pmml.evaluator.core.PMMLContextImpl;\n+import org.kie.pmml.evaluator.core.utils.PMMLRequestDataBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.pmml.commons.utils.KiePMMLModelUtils.getSanitizedPackageName;\n+\n+public class DMNKiePMMLNewInvocationEvaluator extends AbstractDMNKiePMMLInvocationEvaluator {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(DMNKiePMMLNewInvocationEvaluator.class);\n+\n+    public DMNKiePMMLNewInvocationEvaluator(String dmnNS, DMNElement node, Resource pmmlResource, String model, PMMLInfo<?> pmmlInfo) {\n+        super(dmnNS, node, pmmlResource, model, pmmlInfo);\n+    }\n+\n+    @Override\n+    protected PMML4Result getPMML4Result(DMNRuntimeEventManager eventManager, DMNResult dmnr) {\n+        LOG.debug(\"getPMML4Result\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b701f0bac31cc69636b09c32e1d8c320c510a37b"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjA0NjM2Nw==", "bodyText": "@danielezonca\ndone", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r442046367", "createdAt": "2020-06-18T08:11:05Z", "author": {"login": "gitgabrio"}, "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/DMNKiePMMLNewInvocationEvaluator.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.dmn.core.pmml;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import org.drools.core.impl.KnowledgeBaseImpl;\n+import org.kie.api.KieBase;\n+import org.kie.api.io.Resource;\n+import org.kie.api.pmml.PMML4Result;\n+import org.kie.api.runtime.KieContainer;\n+import org.kie.api.runtime.KieRuntimeFactory;\n+import org.kie.dmn.api.core.DMNMessage;\n+import org.kie.dmn.api.core.DMNResult;\n+import org.kie.dmn.api.core.event.DMNRuntimeEventManager;\n+import org.kie.dmn.core.ast.DMNFunctionDefinitionEvaluator.FormalParameter;\n+import org.kie.dmn.core.impl.DMNResultImpl;\n+import org.kie.dmn.core.impl.DMNRuntimeImpl;\n+import org.kie.dmn.core.util.Msg;\n+import org.kie.dmn.core.util.MsgUtil;\n+import org.kie.dmn.feel.util.EvalHelper;\n+import org.kie.dmn.model.api.DMNElement;\n+import org.kie.pmml.evaluator.api.executor.PMMLContext;\n+import org.kie.pmml.evaluator.api.executor.PMMLRuntime;\n+import org.kie.pmml.evaluator.core.PMMLContextImpl;\n+import org.kie.pmml.evaluator.core.utils.PMMLRequestDataBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.pmml.commons.utils.KiePMMLModelUtils.getSanitizedPackageName;\n+\n+public class DMNKiePMMLNewInvocationEvaluator extends AbstractDMNKiePMMLInvocationEvaluator {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(DMNKiePMMLNewInvocationEvaluator.class);\n+\n+    public DMNKiePMMLNewInvocationEvaluator(String dmnNS, DMNElement node, Resource pmmlResource, String model, PMMLInfo<?> pmmlInfo) {\n+        super(dmnNS, node, pmmlResource, model, pmmlInfo);\n+    }\n+\n+    @Override\n+    protected PMML4Result getPMML4Result(DMNRuntimeEventManager eventManager, DMNResult dmnr) {\n+        LOG.debug(\"getPMML4Result\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU5OTk2NQ=="}, "originalCommit": {"oid": "b701f0bac31cc69636b09c32e1d8c320c510a37b"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTI5NDczOnYy", "diffSide": "RIGHT", "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/DMNKiePMMLInvocationEvaluator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNDo0Nzo1NlrOGlJWqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwODoxMDo1OVrOGlkXXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYwMzc1NQ==", "bodyText": "This method is a bit misleading because it is not a proper ignore case. For example using these values List(\"sAmple\") and sample will fail", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r441603755", "createdAt": "2020-06-17T14:47:56Z", "author": {"login": "danielezonca"}, "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/DMNKiePMMLInvocationEvaluator.java", "diffHunk": "@@ -76,70 +74,90 @@ public EvaluatorResult evaluate(DMNRuntimeEventManager eventManager, DMNResult d\n             Class class1 = pValue.getClass();\n             request.addParameter(p.name, pValue, class1);\n         }\n-        PMML4Result resultHolder = helper.submitRequest(request.build());\n-\n-        Map<String, Object> resultVariables = resultHolder.getResultVariables();\n+        return helper.submitRequest(request.build());\n+    }\n \n-        Map<String, Object> result = new HashMap<>();\n-        for (Entry<String, Object> kv : resultVariables.entrySet()) {\n+    @Override\n+    protected Map<String, Object> getOutputFieldValues(PMML4Result pmml4Result, Map<String, Object> resultVariables, DMNResult dmnr) {\n+        LOG.debug(\"getOutputFieldValues\");\n+        Map<String, Object> toReturn = new HashMap<>();\n+        for (Map.Entry<String, Object> kv : resultVariables.entrySet()) {\n+            String resultName = kv.getKey();\n+            if (resultName == null || resultName.isEmpty()) {\n+                continue;\n+            }\n             Object r = kv.getValue();\n             if (r instanceof PMML4Field) {\n-                final String resultName = kv.getKey();\n-                if (resultName != null && !resultName.isEmpty()) {\n-                    Optional<String> outputFieldNameFromInfo;\n-                    Optional<DMNType> opt = getCompositeOutput();\n-                    if (opt.isPresent()) {\n-                        CompositeTypeImpl type = (CompositeTypeImpl) opt.get();\n-                        outputFieldNameFromInfo = type.getFields()\n-                                                      .keySet()\n-                                                      .stream()\n-                                                      .filter(k -> k.equalsIgnoreCase(resultName))\n-                                                      .findFirst();\n-                    } else {\n-                        outputFieldNameFromInfo = pmmlInfo.getModels()\n-                                                          .stream()\n-                                                          .filter(m -> model.equals(m.getName()))\n-                                                          .flatMap(m -> m.getOutputFieldNames().stream())\n-                                                          .filter(ofn -> ofn.equalsIgnoreCase(resultName))\n-                                                          .findFirst();\n-                    }\n-                    if (outputFieldNameFromInfo.isPresent()) {\n-                        String name = outputFieldNameFromInfo.get();\n-                        try {\n-                            Method method = r.getClass().getMethod(\"getValue\");\n-                            Object value = method.invoke(r);\n-                            result.put(name, EvalHelper.coerceNumber(value));\n-                        } catch (Throwable e) {\n-                            MsgUtil.reportMessage(LOG,\n-                                                  DMNMessage.Severity.WARN,\n-                                                  node,\n-                                                  ((DMNResultImpl) result),\n-                                                  e,\n-                                                  null,\n-                                                  Msg.INVALID_NAME,\n-                                                  name,\n-                                                  e.getMessage());\n-                            result.put(name, null);\n-                        }\n-                    }\n-                }\n+                populateWithPMML4Field(toReturn, kv.getKey(), (PMML4Field) r, dmnr);\n             }\n         }\n+        return toReturn;\n+    }\n \n-        Object coercedResult = result.size() > 1 ? result : result.values().iterator().next();\n-        return new EvaluatorResultImpl(coercedResult, ResultType.SUCCESS);\n+    @Override\n+    protected Map<String, Object> getPredictedValues(PMML4Result pmml4Result, DMNResult dmnr) {\n+        LOG.debug(\"getPredictedValues\");\n+        final DMNPMMLModelInfo modelInfo = getDMNPMMLInfo();\n+        if (modelInfo == null) {\n+            return Collections.emptyMap();\n+        }\n+        return getTargetObjects(modelInfo.getTargetFieldNames(), pmml4Result, dmnr);\n     }\n \n-    private Optional<DMNType> getCompositeOutput() {\n-        Collection<? extends PMMLModelInfo> models = pmmlInfo.getModels();\n-        return models.stream()\n-                .filter(m -> model.equals(m.getName()))\n-                .filter(m -> m instanceof DMNPMMLModelInfo)\n-                .flatMap(m -> ((DMNPMMLModelInfo)m).getOutputFields().entrySet().stream())\n-                .filter(e -> e.getKey().equals(model))\n-                .filter(e -> e.getValue() instanceof CompositeTypeImpl)\n-                .map(Map.Entry::getValue)\n-                .findFirst();\n+    private Map<String, Object> getTargetObjects(Collection<String> targetFieldNames, PMML4Result pmml4Result, DMNResult dmnr) {\n+        Map<String, Object> toReturn = new HashMap<>();\n+        pmml4Result.getResultVariables().forEach((key, value) -> {\n+            if (containsIgnoreCase(targetFieldNames, key) && value instanceof PMML4OutputField) {\n+                PMML4OutputField pmml4OutputField = (PMML4OutputField) value;\n+                populateWithReflection(toReturn, key, pmml4OutputField, dmnr);\n+            }\n+        });\n+        return toReturn;\n     }\n \n+    private void populateWithPMML4Field(Map<String, Object> toPopulate, String resultName, PMML4Field pmml4Field, DMNResult dmnr) {\n+        Optional<String> outputFieldNameFromInfo = getOutputFieldNameFromInfo(resultName);\n+        if (outputFieldNameFromInfo.isPresent()) {\n+            String name = outputFieldNameFromInfo.get();\n+            populateWithReflection(toPopulate, name, pmml4Field, dmnr);\n+        }\n+    }\n+\n+    private void populateWithReflection(Map<String, Object> toPopulate, String name, PMML4Field pmml4Field, DMNResult dmnr) {\n+        try {\n+            Method method = pmml4Field.getClass().getMethod(\"getValue\");\n+            Object value = method.invoke(pmml4Field);\n+            toPopulate.put(name, EvalHelper.coerceNumber(value));\n+        } catch (Throwable e) {\n+            MsgUtil.reportMessage(LOG,\n+                                  DMNMessage.Severity.WARN,\n+                                  node,\n+                                  ((DMNResultImpl) dmnr),\n+                                  e,\n+                                  null,\n+                                  Msg.INVALID_NAME,\n+                                  name,\n+                                  e.getMessage());\n+            toPopulate.put(name, null);\n+        }\n+    }\n+\n+    /**\n+     * Returns <code>true</code> if <b>containingCollection</b> contains <b>searchedString</b> OR <b>searchedString.toLowerCase()</b>\n+     * @param containingCollection\n+     * @param searchedString\n+     * @return\n+     */\n+    private boolean containsIgnoreCase(Collection<String> containingCollection, String searchedString) {\n+        return containingCollection.contains(searchedString) || containingCollection.contains(searchedString.toLowerCase());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b701f0bac31cc69636b09c32e1d8c320c510a37b"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjA0NjMwMQ==", "bodyText": "@danielezonca\nRenamed a little bit.\nBTW - that is one of the reason of javadoc -  sometimes it is hard to explain a specific logic in one camel-cased word", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r442046301", "createdAt": "2020-06-18T08:10:59Z", "author": {"login": "gitgabrio"}, "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/DMNKiePMMLInvocationEvaluator.java", "diffHunk": "@@ -76,70 +74,90 @@ public EvaluatorResult evaluate(DMNRuntimeEventManager eventManager, DMNResult d\n             Class class1 = pValue.getClass();\n             request.addParameter(p.name, pValue, class1);\n         }\n-        PMML4Result resultHolder = helper.submitRequest(request.build());\n-\n-        Map<String, Object> resultVariables = resultHolder.getResultVariables();\n+        return helper.submitRequest(request.build());\n+    }\n \n-        Map<String, Object> result = new HashMap<>();\n-        for (Entry<String, Object> kv : resultVariables.entrySet()) {\n+    @Override\n+    protected Map<String, Object> getOutputFieldValues(PMML4Result pmml4Result, Map<String, Object> resultVariables, DMNResult dmnr) {\n+        LOG.debug(\"getOutputFieldValues\");\n+        Map<String, Object> toReturn = new HashMap<>();\n+        for (Map.Entry<String, Object> kv : resultVariables.entrySet()) {\n+            String resultName = kv.getKey();\n+            if (resultName == null || resultName.isEmpty()) {\n+                continue;\n+            }\n             Object r = kv.getValue();\n             if (r instanceof PMML4Field) {\n-                final String resultName = kv.getKey();\n-                if (resultName != null && !resultName.isEmpty()) {\n-                    Optional<String> outputFieldNameFromInfo;\n-                    Optional<DMNType> opt = getCompositeOutput();\n-                    if (opt.isPresent()) {\n-                        CompositeTypeImpl type = (CompositeTypeImpl) opt.get();\n-                        outputFieldNameFromInfo = type.getFields()\n-                                                      .keySet()\n-                                                      .stream()\n-                                                      .filter(k -> k.equalsIgnoreCase(resultName))\n-                                                      .findFirst();\n-                    } else {\n-                        outputFieldNameFromInfo = pmmlInfo.getModels()\n-                                                          .stream()\n-                                                          .filter(m -> model.equals(m.getName()))\n-                                                          .flatMap(m -> m.getOutputFieldNames().stream())\n-                                                          .filter(ofn -> ofn.equalsIgnoreCase(resultName))\n-                                                          .findFirst();\n-                    }\n-                    if (outputFieldNameFromInfo.isPresent()) {\n-                        String name = outputFieldNameFromInfo.get();\n-                        try {\n-                            Method method = r.getClass().getMethod(\"getValue\");\n-                            Object value = method.invoke(r);\n-                            result.put(name, EvalHelper.coerceNumber(value));\n-                        } catch (Throwable e) {\n-                            MsgUtil.reportMessage(LOG,\n-                                                  DMNMessage.Severity.WARN,\n-                                                  node,\n-                                                  ((DMNResultImpl) result),\n-                                                  e,\n-                                                  null,\n-                                                  Msg.INVALID_NAME,\n-                                                  name,\n-                                                  e.getMessage());\n-                            result.put(name, null);\n-                        }\n-                    }\n-                }\n+                populateWithPMML4Field(toReturn, kv.getKey(), (PMML4Field) r, dmnr);\n             }\n         }\n+        return toReturn;\n+    }\n \n-        Object coercedResult = result.size() > 1 ? result : result.values().iterator().next();\n-        return new EvaluatorResultImpl(coercedResult, ResultType.SUCCESS);\n+    @Override\n+    protected Map<String, Object> getPredictedValues(PMML4Result pmml4Result, DMNResult dmnr) {\n+        LOG.debug(\"getPredictedValues\");\n+        final DMNPMMLModelInfo modelInfo = getDMNPMMLInfo();\n+        if (modelInfo == null) {\n+            return Collections.emptyMap();\n+        }\n+        return getTargetObjects(modelInfo.getTargetFieldNames(), pmml4Result, dmnr);\n     }\n \n-    private Optional<DMNType> getCompositeOutput() {\n-        Collection<? extends PMMLModelInfo> models = pmmlInfo.getModels();\n-        return models.stream()\n-                .filter(m -> model.equals(m.getName()))\n-                .filter(m -> m instanceof DMNPMMLModelInfo)\n-                .flatMap(m -> ((DMNPMMLModelInfo)m).getOutputFields().entrySet().stream())\n-                .filter(e -> e.getKey().equals(model))\n-                .filter(e -> e.getValue() instanceof CompositeTypeImpl)\n-                .map(Map.Entry::getValue)\n-                .findFirst();\n+    private Map<String, Object> getTargetObjects(Collection<String> targetFieldNames, PMML4Result pmml4Result, DMNResult dmnr) {\n+        Map<String, Object> toReturn = new HashMap<>();\n+        pmml4Result.getResultVariables().forEach((key, value) -> {\n+            if (containsIgnoreCase(targetFieldNames, key) && value instanceof PMML4OutputField) {\n+                PMML4OutputField pmml4OutputField = (PMML4OutputField) value;\n+                populateWithReflection(toReturn, key, pmml4OutputField, dmnr);\n+            }\n+        });\n+        return toReturn;\n     }\n \n+    private void populateWithPMML4Field(Map<String, Object> toPopulate, String resultName, PMML4Field pmml4Field, DMNResult dmnr) {\n+        Optional<String> outputFieldNameFromInfo = getOutputFieldNameFromInfo(resultName);\n+        if (outputFieldNameFromInfo.isPresent()) {\n+            String name = outputFieldNameFromInfo.get();\n+            populateWithReflection(toPopulate, name, pmml4Field, dmnr);\n+        }\n+    }\n+\n+    private void populateWithReflection(Map<String, Object> toPopulate, String name, PMML4Field pmml4Field, DMNResult dmnr) {\n+        try {\n+            Method method = pmml4Field.getClass().getMethod(\"getValue\");\n+            Object value = method.invoke(pmml4Field);\n+            toPopulate.put(name, EvalHelper.coerceNumber(value));\n+        } catch (Throwable e) {\n+            MsgUtil.reportMessage(LOG,\n+                                  DMNMessage.Severity.WARN,\n+                                  node,\n+                                  ((DMNResultImpl) dmnr),\n+                                  e,\n+                                  null,\n+                                  Msg.INVALID_NAME,\n+                                  name,\n+                                  e.getMessage());\n+            toPopulate.put(name, null);\n+        }\n+    }\n+\n+    /**\n+     * Returns <code>true</code> if <b>containingCollection</b> contains <b>searchedString</b> OR <b>searchedString.toLowerCase()</b>\n+     * @param containingCollection\n+     * @param searchedString\n+     * @return\n+     */\n+    private boolean containsIgnoreCase(Collection<String> containingCollection, String searchedString) {\n+        return containingCollection.contains(searchedString) || containingCollection.contains(searchedString.toLowerCase());\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYwMzc1NQ=="}, "originalCommit": {"oid": "b701f0bac31cc69636b09c32e1d8c320c510a37b"}, "originalPosition": 197}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTMxODI4OnYy", "diffSide": "RIGHT", "path": "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/util/DMNRuntimeUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNDo1Mjo1OVrOGlJlzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwODoxMDo1NFrOGlkXIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYwNzYzMQ==", "bodyText": "To be removed", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r441607631", "createdAt": "2020-06-17T14:52:59Z", "author": {"login": "danielezonca"}, "path": "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/util/DMNRuntimeUtil.java", "diffHunk": "@@ -94,6 +103,21 @@ public static DMNRuntime createRuntime(final String resourceName, final Class te\n         return dmnMessages;\n     }\n \n+    public static void resetServices() {\n+        final ServiceDiscoveryImpl serviceDiscovery = ServiceDiscoveryImpl.getInstance();\n+        serviceDiscovery.reset();\n+        final ServiceRegistryImpl instance = (ServiceRegistryImpl)ServiceRegistry.getInstance();\n+        instance.reload();\n+//\n+//\n+//        Map<String, Object> resetServices = serviceDiscovery.getServices();\n+//        KieAssemblersImpl resetKieAssemblers = (KieAssemblersImpl)resetServices.get(\"org.kie.api.internal.assembler.KieAssemblers\");\n+//        KieAssemblersImpl kieAssemblers = (KieAssemblersImpl)instance.get(KieAssemblers.class);\n+//        Map<ResourceType, KieAssemblerService> registeredKieAssemblers = kieAssemblers.getAssemblers();\n+//        resetKieAssemblers.getAssemblers()\n+//                .forEach(registeredKieAssemblers::put);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b701f0bac31cc69636b09c32e1d8c320c510a37b"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjA0NjI0Mw==", "bodyText": "@danielezonca\ndone", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r442046243", "createdAt": "2020-06-18T08:10:54Z", "author": {"login": "gitgabrio"}, "path": "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/util/DMNRuntimeUtil.java", "diffHunk": "@@ -94,6 +103,21 @@ public static DMNRuntime createRuntime(final String resourceName, final Class te\n         return dmnMessages;\n     }\n \n+    public static void resetServices() {\n+        final ServiceDiscoveryImpl serviceDiscovery = ServiceDiscoveryImpl.getInstance();\n+        serviceDiscovery.reset();\n+        final ServiceRegistryImpl instance = (ServiceRegistryImpl)ServiceRegistry.getInstance();\n+        instance.reload();\n+//\n+//\n+//        Map<String, Object> resetServices = serviceDiscovery.getServices();\n+//        KieAssemblersImpl resetKieAssemblers = (KieAssemblersImpl)resetServices.get(\"org.kie.api.internal.assembler.KieAssemblers\");\n+//        KieAssemblersImpl kieAssemblers = (KieAssemblersImpl)instance.get(KieAssemblers.class);\n+//        Map<ResourceType, KieAssemblerService> registeredKieAssemblers = kieAssemblers.getAssemblers();\n+//        resetKieAssemblers.getAssemblers()\n+//                .forEach(registeredKieAssemblers::put);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYwNzYzMQ=="}, "originalCommit": {"oid": "b701f0bac31cc69636b09c32e1d8c320c510a37b"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTMzMTEzOnYy", "diffSide": "LEFT", "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-drools/kie-pmml-models-drools-tree/kie-pmml-models-drools-tree-compiler/src/main/java/org/kie/pmml/models/drools/tree/compiler/factories/KiePMMLTreeModelNodeASTFactory.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNDo1NTo0MlrOGlJuIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwODoxMDo0N1rOGlkW3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYwOTc2MQ==", "bodyText": "Is this always true?", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r441609761", "createdAt": "2020-06-17T14:55:42Z", "author": {"login": "danielezonca"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-drools/kie-pmml-models-drools-tree/kie-pmml-models-drools-tree-compiler/src/main/java/org/kie/pmml/models/drools/tree/compiler/factories/KiePMMLTreeModelNodeASTFactory.java", "diffHunk": "@@ -98,10 +98,8 @@ protected void declareFinalRuleFromNode(final Node node,\n             return;\n         }\n         String currentRule = String.format(PATH_PATTERN, parentPath, node.getScore());\n-        if (!(predicate instanceof True)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b701f0bac31cc69636b09c32e1d8c320c510a37b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjA0NjE3NA==", "bodyText": "@danielezonca\nThis is out of the scope of this PR - I will check in another ticket", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r442046174", "createdAt": "2020-06-18T08:10:47Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-drools/kie-pmml-models-drools-tree/kie-pmml-models-drools-tree-compiler/src/main/java/org/kie/pmml/models/drools/tree/compiler/factories/KiePMMLTreeModelNodeASTFactory.java", "diffHunk": "@@ -98,10 +98,8 @@ protected void declareFinalRuleFromNode(final Node node,\n             return;\n         }\n         String currentRule = String.format(PATH_PATTERN, parentPath, node.getScore());\n-        if (!(predicate instanceof True)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYwOTc2MQ=="}, "originalCommit": {"oid": "b701f0bac31cc69636b09c32e1d8c320c510a37b"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjM5ODYxOnYy", "diffSide": "RIGHT", "path": "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/util/DMNRuntimeUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxOTozMzo1MFrOGlUeIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwODoxMDozM1rOGlkWaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc4NTg5MA==", "bodyText": "Is there any reason to keep commented code? If yes please add description into the comment. Otherwise please remove.", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r441785890", "createdAt": "2020-06-17T19:33:50Z", "author": {"login": "jiripetrlik"}, "path": "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/util/DMNRuntimeUtil.java", "diffHunk": "@@ -94,6 +103,21 @@ public static DMNRuntime createRuntime(final String resourceName, final Class te\n         return dmnMessages;\n     }\n \n+    public static void resetServices() {\n+        final ServiceDiscoveryImpl serviceDiscovery = ServiceDiscoveryImpl.getInstance();\n+        serviceDiscovery.reset();\n+        final ServiceRegistryImpl instance = (ServiceRegistryImpl)ServiceRegistry.getInstance();\n+        instance.reload();\n+//\n+//\n+//        Map<String, Object> resetServices = serviceDiscovery.getServices();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b701f0bac31cc69636b09c32e1d8c320c510a37b"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjA0NjA1Ng==", "bodyText": "@jiripetrlik\nThe issue here is different. Here we have both kie-pmml implementations in the classpath (legacy and new one) and unfortunatley the \"utils\" used in the tests does not clear the runtime. What happens is that all the KieServices are populated (normally) only at application startup (see https://github.com/kiegroup/droolsjbpm-knowledge/blob/master/kie-internal/src/main/java/org/kie/internal/services/KieAssemblersImpl.java#L67).\n/---/\nRemoved commented code", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r442046056", "createdAt": "2020-06-18T08:10:33Z", "author": {"login": "gitgabrio"}, "path": "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/util/DMNRuntimeUtil.java", "diffHunk": "@@ -94,6 +103,21 @@ public static DMNRuntime createRuntime(final String resourceName, final Class te\n         return dmnMessages;\n     }\n \n+    public static void resetServices() {\n+        final ServiceDiscoveryImpl serviceDiscovery = ServiceDiscoveryImpl.getInstance();\n+        serviceDiscovery.reset();\n+        final ServiceRegistryImpl instance = (ServiceRegistryImpl)ServiceRegistry.getInstance();\n+        instance.reload();\n+//\n+//\n+//        Map<String, Object> resetServices = serviceDiscovery.getServices();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc4NTg5MA=="}, "originalCommit": {"oid": "b701f0bac31cc69636b09c32e1d8c320c510a37b"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjQyMTI0OnYy", "diffSide": "RIGHT", "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/AbstractPMMLInvocationEvaluator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxOTo0MDo1NlrOGlUsYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwODoxMDoyN1rOGlkWLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc4OTUzNg==", "bodyText": "Maybe it would be better to throw exception.", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r441789536", "createdAt": "2020-06-17T19:40:56Z", "author": {"login": "jiripetrlik"}, "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/AbstractPMMLInvocationEvaluator.java", "diffHunk": "@@ -143,9 +146,68 @@ public static AbstractPMMLInvocationEvaluator newInstance(DMNModelImpl model, Cl\n                                   funcDef.getIdentifierString());\n             return new AbstractPMMLInvocationEvaluator.DummyPMMLInvocationEvaluator(model.getNamespace(), funcDef, pmmlResource, pmmlModel);\n         }\n+    }\n \n-        private PMMLInvocationEvaluatorFactory() {\n-            // Constructing instances is not allowed for this Factory\n+    private static AbstractDMNKiePMMLInvocationEvaluator getAbstractDMNKiePMMLInvocationEvaluator(String nameSpace, DMNElement funcDef, Resource pmmlResource, String pmmlModel, PMMLInfo<?> pmmlInfo) {\n+        final boolean legacyImplementationPresent = isLegacyImplementationPresent();\n+        final boolean newImplementationPresent = isNewImplementationPresent();\n+        if (legacyImplementationPresent && newImplementationPresent) {\n+            if (isLegacyPMMLRequired()) {\n+                return getDMNKiePMMLInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+            } else {\n+                return getDMNKiePMMLNewInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+            }\n+        } else if (legacyImplementationPresent) {\n+            return getDMNKiePMMLInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+        } else if (newImplementationPresent) {\n+            return getDMNKiePMMLNewInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+        } else {\n+            return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b701f0bac31cc69636b09c32e1d8c320c510a37b"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjA0NTk5Nw==", "bodyText": "@jiripetrlik\nThat \"null\" is expected since - in this case - the code is written to return a \"DummyPMMLInvocationEvaluator\"", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r442045997", "createdAt": "2020-06-18T08:10:27Z", "author": {"login": "gitgabrio"}, "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/AbstractPMMLInvocationEvaluator.java", "diffHunk": "@@ -143,9 +146,68 @@ public static AbstractPMMLInvocationEvaluator newInstance(DMNModelImpl model, Cl\n                                   funcDef.getIdentifierString());\n             return new AbstractPMMLInvocationEvaluator.DummyPMMLInvocationEvaluator(model.getNamespace(), funcDef, pmmlResource, pmmlModel);\n         }\n+    }\n \n-        private PMMLInvocationEvaluatorFactory() {\n-            // Constructing instances is not allowed for this Factory\n+    private static AbstractDMNKiePMMLInvocationEvaluator getAbstractDMNKiePMMLInvocationEvaluator(String nameSpace, DMNElement funcDef, Resource pmmlResource, String pmmlModel, PMMLInfo<?> pmmlInfo) {\n+        final boolean legacyImplementationPresent = isLegacyImplementationPresent();\n+        final boolean newImplementationPresent = isNewImplementationPresent();\n+        if (legacyImplementationPresent && newImplementationPresent) {\n+            if (isLegacyPMMLRequired()) {\n+                return getDMNKiePMMLInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+            } else {\n+                return getDMNKiePMMLNewInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+            }\n+        } else if (legacyImplementationPresent) {\n+            return getDMNKiePMMLInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+        } else if (newImplementationPresent) {\n+            return getDMNKiePMMLNewInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+        } else {\n+            return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc4OTUzNg=="}, "originalCommit": {"oid": "b701f0bac31cc69636b09c32e1d8c320c510a37b"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjQ0MTIxOnYy", "diffSide": "RIGHT", "path": "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/pmml/AbstractDMNPMMLTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxOTo0NzoyM1rOGlU5DQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwODoxMDoxM1rOGlkVpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc5Mjc4MQ==", "bodyText": "I'm not sure about this. I think it would be much more clear to create two separate modules as @tarilabs suggested with different jars on classpath. We can never be sure that it DMN PMML works without logic in resetService() method.", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r441792781", "createdAt": "2020-06-17T19:47:23Z", "author": {"login": "jiripetrlik"}, "path": "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/pmml/AbstractDMNPMMLTest.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.dmn.core.pmml;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.api.pmml.PMMLConstants.KIE_PMML_IMPLEMENTATION;\n+import static org.kie.dmn.core.util.DMNRuntimeUtil.resetServices;\n+\n+public abstract class AbstractDMNPMMLTest {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AbstractDMNPMMLTest.class);\n+\n+    protected void resetEnvironment(String pmmlVersion) {\n+        LOG.debug(\"resetEnvironment {}\", pmmlVersion);\n+        System.setProperty(KIE_PMML_IMPLEMENTATION.getName(), pmmlVersion);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b701f0bac31cc69636b09c32e1d8c320c510a37b"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjA0NTg2Mg==", "bodyText": "@jiripetrlik\nThis workaround is needed because all those DMN-PMML tests are using \"utils\" (like KieHelper) that by themselves are \"by-passing\" the normal usage; as they currently are they do not test the real runtime.\nRewriting all those tests is out of the scope of this PR.", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r442045862", "createdAt": "2020-06-18T08:10:13Z", "author": {"login": "gitgabrio"}, "path": "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/pmml/AbstractDMNPMMLTest.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.dmn.core.pmml;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.api.pmml.PMMLConstants.KIE_PMML_IMPLEMENTATION;\n+import static org.kie.dmn.core.util.DMNRuntimeUtil.resetServices;\n+\n+public abstract class AbstractDMNPMMLTest {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AbstractDMNPMMLTest.class);\n+\n+    protected void resetEnvironment(String pmmlVersion) {\n+        LOG.debug(\"resetEnvironment {}\", pmmlVersion);\n+        System.setProperty(KIE_PMML_IMPLEMENTATION.getName(), pmmlVersion);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc5Mjc4MQ=="}, "originalCommit": {"oid": "b701f0bac31cc69636b09c32e1d8c320c510a37b"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjQ1MDQ3OnYy", "diffSide": "RIGHT", "path": "kie-pmml-new/kie-pmml-models-archetype/src/main/resources/archetype-resources/__rootArtifactId__-compiler/pom.xml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxOTo0OTo0MlrOGlU-bA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwODowOTowNlrOGlkTDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc5NDE1Ng==", "bodyText": "Can you please explain why do we need to exclude these libs now?", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r441794156", "createdAt": "2020-06-17T19:49:42Z", "author": {"login": "jiripetrlik"}, "path": "kie-pmml-new/kie-pmml-models-archetype/src/main/resources/archetype-resources/__rootArtifactId__-compiler/pom.xml", "diffHunk": "@@ -40,6 +40,16 @@\n       <groupId>org.kie</groupId>\n       <artifactId>kie-test-util</artifactId>\n       <scope>test</scope>\n+      <exclusions>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b701f0bac31cc69636b09c32e1d8c320c510a37b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjA0NTE5Nw==", "bodyText": "@jiripetrlik\nEnforcer rules (ban-duplicated-classes)", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r442045197", "createdAt": "2020-06-18T08:09:06Z", "author": {"login": "gitgabrio"}, "path": "kie-pmml-new/kie-pmml-models-archetype/src/main/resources/archetype-resources/__rootArtifactId__-compiler/pom.xml", "diffHunk": "@@ -40,6 +40,16 @@\n       <groupId>org.kie</groupId>\n       <artifactId>kie-test-util</artifactId>\n       <scope>test</scope>\n+      <exclusions>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc5NDE1Ng=="}, "originalCommit": {"oid": "b701f0bac31cc69636b09c32e1d8c320c510a37b"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjQ2MzEyOnYy", "diffSide": "RIGHT", "path": "kie-dmn/kie-dmn-core/src/test/resources/org/kie/dmn/core/pmml/KiePMMLNewTree.dmn", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxOTo1MzoyM1rOGlVF_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwODowOTowM1rOGlkS7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc5NjA5Mw==", "bodyText": "Is there any difference between old dmn and new dmn? Can you please explain reason for it.", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r441796093", "createdAt": "2020-06-17T19:53:23Z", "author": {"login": "jiripetrlik"}, "path": "kie-dmn/kie-dmn-core/src/test/resources/org/kie/dmn/core/pmml/KiePMMLNewTree.dmn", "diffHunk": "@@ -0,0 +1,148 @@\n+<?xml version='1.0' encoding='UTF-8'?>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b701f0bac31cc69636b09c32e1d8c320c510a37b"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjA0NTE2NA==", "bodyText": "@jiripetrlik\nRemoved", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r442045164", "createdAt": "2020-06-18T08:09:03Z", "author": {"login": "gitgabrio"}, "path": "kie-dmn/kie-dmn-core/src/test/resources/org/kie/dmn/core/pmml/KiePMMLNewTree.dmn", "diffHunk": "@@ -0,0 +1,148 @@\n+<?xml version='1.0' encoding='UTF-8'?>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc5NjA5Mw=="}, "originalCommit": {"oid": "b701f0bac31cc69636b09c32e1d8c320c510a37b"}, "originalPosition": 1}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2447, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}