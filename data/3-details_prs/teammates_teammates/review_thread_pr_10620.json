{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY5MTE2NTYw", "number": 10620, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QyMzoyODoxNVrOEZQYLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMTozNTo1M1rOEZR1MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTE4MTg4OnYy", "diffSide": "RIGHT", "path": "src/web/app/pages-session/session-submission-page/session-submission-page.component.ts", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QyMzoyODoxNVrOHB-JZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QyMzoyODoxNVrOHB-JZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgyODgzNg==", "bodyText": "I skipped this because I wasn't very sure how this is supposed to work. Will take some time to add this back, @xpdavid if you can help it will be great.", "url": "https://github.com/TEAMMATES/teammates/pull/10620#discussion_r471828836", "createdAt": "2020-08-17T23:28:15Z", "author": {"login": "wkurniawan07"}, "path": "src/web/app/pages-session/session-submission-page/session-submission-page.component.ts", "diffHunk": "@@ -547,84 +549,63 @@ export class SessionSubmissionPageComponent implements OnInit, AfterViewInit {\n     this.questionSubmissionForms.forEach((questionSubmissionFormModel: QuestionSubmissionFormModel) => {\n       let isQuestionFullyAnswered: boolean = true;\n \n+      const responseDetailsPerRecipient: Record<string, FeedbackResponseDetails> = {};\n+\n       questionSubmissionFormModel.recipientSubmissionForms\n           .forEach((recipientSubmissionFormModel: FeedbackResponseRecipientSubmissionFormModel) => {\n             const isFeedbackResponseDetailsEmpty: boolean =\n                 this.feedbackResponsesService.isFeedbackResponseDetailsEmpty(\n                     questionSubmissionFormModel.questionType, recipientSubmissionFormModel.responseDetails);\n             isQuestionFullyAnswered = isQuestionFullyAnswered && !isFeedbackResponseDetailsEmpty;\n \n-            if (recipientSubmissionFormModel.responseId !== '' && isFeedbackResponseDetailsEmpty) {\n-              // existing response but empty details -> delete response\n-              savingRequests.push(this.feedbackResponsesService.deleteFeedbackResponse({\n-                responseId: recipientSubmissionFormModel.responseId,\n-                intent: this.intent,\n-                key: this.regKey,\n-                moderatedPerson: this.moderatedPerson,\n-              }).pipe(\n-                  tap(() => {\n-                    // clear inputs\n-                    recipientSubmissionFormModel.responseId = '';\n-                    recipientSubmissionFormModel.commentByGiver = undefined;\n-                  }),\n-                  catchError((error: ErrorMessageOutput) => {\n-                    failToSaveQuestions[questionSubmissionFormModel.questionNumber] = error.error.message;\n-                    return of(error);\n-                  }),\n-              ));\n-            }\n-\n-            if (recipientSubmissionFormModel.responseId !== '' && !isFeedbackResponseDetailsEmpty) {\n-              // existing response and details is not empty -> update response\n-              savingRequests.push(\n-                  this.feedbackResponsesService.updateFeedbackResponse(recipientSubmissionFormModel.responseId, {\n-                    intent: this.intent,\n-                    key: this.regKey,\n-                    moderatedperson: this.moderatedPerson,\n-                  }, {\n-                    recipientIdentifier: recipientSubmissionFormModel.recipientIdentifier,\n-                    questionType: questionSubmissionFormModel.questionType,\n-                    responseDetails: recipientSubmissionFormModel.responseDetails,\n-                  }).pipe(\n-                      tap((resp: FeedbackResponse) => {\n-                        recipientSubmissionFormModel.responseId = resp.feedbackResponseId;\n-                        recipientSubmissionFormModel.responseDetails = resp.responseDetails;\n-                        recipientSubmissionFormModel.recipientIdentifier = resp.recipientIdentifier;\n-                      }),\n-                      switchMap(() => this.createCommentRequest(recipientSubmissionFormModel)),\n-                      catchError((error: ErrorMessageOutput) => {\n-                        failToSaveQuestions[questionSubmissionFormModel.questionNumber] = error.error.message;\n-                        return of(error);\n-                      }),\n-                  ));\n-            }\n-\n-            if (recipientSubmissionFormModel.responseId === '' && !isFeedbackResponseDetailsEmpty) {\n-              // new response and the details is not empty -> create response\n-              savingRequests.push(\n-                  this.feedbackResponsesService.createFeedbackResponse(questionSubmissionFormModel.feedbackQuestionId, {\n-                    intent: this.intent,\n-                    key: this.regKey,\n-                    moderatedperson: this.moderatedPerson,\n-                  }, {\n-                    recipientIdentifier: recipientSubmissionFormModel.recipientIdentifier,\n-                    questionType: questionSubmissionFormModel.questionType,\n-                    responseDetails: recipientSubmissionFormModel.responseDetails,\n-                  }).pipe(\n-                      tap((resp: FeedbackResponse) => {\n-                        recipientSubmissionFormModel.responseId = resp.feedbackResponseId;\n-                        recipientSubmissionFormModel.responseDetails = resp.responseDetails;\n-                        recipientSubmissionFormModel.recipientIdentifier = resp.recipientIdentifier;\n-                      }),\n-                      switchMap(() => this.createCommentRequest(recipientSubmissionFormModel)),\n-                      catchError((error: ErrorMessageOutput) => {\n-                        failToSaveQuestions[questionSubmissionFormModel.questionNumber] = error.error.message;\n-                        return of(error);\n-                      }),\n-                  ));\n+            if (!isFeedbackResponseDetailsEmpty) {\n+              responseDetailsPerRecipient[recipientSubmissionFormModel.recipientIdentifier] =\n+                  recipientSubmissionFormModel.responseDetails;\n             }\n           });\n \n+      savingRequests.push(\n+          this.feedbackResponsesService.submitFeedbackResponse(questionSubmissionFormModel.feedbackQuestionId, {\n+            intent: this.intent,\n+            key: this.regKey,\n+            moderatedperson: this.moderatedPerson,\n+          }, {\n+            responseDetailsPerRecipient,\n+            questionType: questionSubmissionFormModel.questionType,\n+          }).pipe(\n+              tap((resp: FeedbackResponses) => {\n+                const responsesMap: Record<string, FeedbackResponse> = {};\n+                resp.responses.forEach((response: FeedbackResponse) => {\n+                  responsesMap[response.recipientIdentifier] = response;\n+                });\n+\n+                questionSubmissionFormModel.recipientSubmissionForms\n+                    .forEach((recipientSubmissionFormModel: FeedbackResponseRecipientSubmissionFormModel) => {\n+                      if (responsesMap[recipientSubmissionFormModel.recipientIdentifier]) {\n+                        const correspondingResp: FeedbackResponse =\n+                            responsesMap[recipientSubmissionFormModel.recipientIdentifier];\n+                        recipientSubmissionFormModel.responseId = correspondingResp.feedbackResponseId;\n+                        recipientSubmissionFormModel.responseDetails = correspondingResp.responseDetails;\n+                        recipientSubmissionFormModel.recipientIdentifier = correspondingResp.recipientIdentifier;\n+                      } else {\n+                        recipientSubmissionFormModel.responseId = '';\n+                        recipientSubmissionFormModel.commentByGiver = undefined;\n+                      }\n+                    });\n+              }),\n+              // switchMap(() =>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eaffa4e01ea6173cc160d76c603c4bb4cd9a6cec"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTMyNjQyOnYy", "diffSide": "RIGHT", "path": "src/main/java/teammates/common/datatransfer/questions/FeedbackQuestionDetails.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMDo0NDo0OFrOHB_cmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMDo0NDo0OFrOHB_cmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1MDEzNw==", "bodyText": "Don't forget javadoc", "url": "https://github.com/TEAMMATES/teammates/pull/10620#discussion_r471850137", "createdAt": "2020-08-18T00:44:48Z", "author": {"login": "xpdavid"}, "path": "src/main/java/teammates/common/datatransfer/questions/FeedbackQuestionDetails.java", "diffHunk": "@@ -63,6 +63,8 @@ public boolean isIndividualResponsesShownToStudents() {\n      */\n     public abstract List<String> validateQuestionDetails();\n \n+    public abstract List<String> validateResponsesDetails(List<FeedbackResponseDetails> responseDetails);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1095aea151653fcfeb06ac4b6a3638754bf87cef"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTMzMTg3OnYy", "diffSide": "RIGHT", "path": "src/main/java/teammates/logic/api/Logic.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMDo0Nzo1MFrOHB_fpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMDo0Nzo1MFrOHB_fpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1MDkxNw==", "bodyText": "Can we inherit the doc for deleteFeedbackResponsesForQuestion in feedbackResponsesLogic", "url": "https://github.com/TEAMMATES/teammates/pull/10620#discussion_r471850917", "createdAt": "2020-08-18T00:47:50Z", "author": {"login": "xpdavid"}, "path": "src/main/java/teammates/logic/api/Logic.java", "diffHunk": "@@ -1487,4 +1487,9 @@ public int getNumOfGeneratedChoicesForParticipantType(String courseId, FeedbackP\n         return feedbackQuestionsLogic.getNumOfGeneratedChoicesForParticipantType(courseId, generateOptionsFor);\n     }\n \n+    public void deleteFeedbackResponsesForQuestion(String feedbackQuestionId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67d6feaf68aac713c1bf90f4a234418894e40a2e"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTM2NjIwOnYy", "diffSide": "RIGHT", "path": "src/main/java/teammates/ui/webapi/request/FeedbackResponseSubmissionRequest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMTowNjo1NVrOHB_zXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMTowNjo1NVrOHB_zXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1NTk2Nw==", "bodyText": "I don't recommend to use map as API request. It is too abstract and there is no way to tell the structure immediately even looking at the class itself.\nInstead, I think it should accept a list of FeedbackResponseRequest where there are two field recipientIdentifier  and responseDetails.", "url": "https://github.com/TEAMMATES/teammates/pull/10620#discussion_r471855967", "createdAt": "2020-08-18T01:06:55Z", "author": {"login": "xpdavid"}, "path": "src/main/java/teammates/ui/webapi/request/FeedbackResponseSubmissionRequest.java", "diffHunk": "@@ -0,0 +1,64 @@\n+package teammates.ui.webapi.request;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import teammates.common.datatransfer.questions.FeedbackQuestionType;\n+import teammates.common.datatransfer.questions.FeedbackResponseDetails;\n+import teammates.common.util.JsonUtils;\n+\n+/**\n+ * The basic request of modifying a feedback response.\n+ */\n+public class FeedbackResponseSubmissionRequest extends BasicRequest {\n+\n+    private FeedbackQuestionType questionType;\n+    private Map<String, Map<String, Object>> responseDetailsPerRecipient = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f62b8a9c292098a107ded00b1ad2a16f7757a3ae"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTM4MjUzOnYy", "diffSide": "RIGHT", "path": "src/main/java/teammates/ui/webapi/action/SubmitFeedbackResponsesAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMToxNTozNlrOHB_8oA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMToxNTozNlrOHB_8oA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1ODMzNg==", "bodyText": "The above lines can be written as\nFeedbackResponseAttributes.UpdateOptions options = XXXX (Line 148 - 154)\nFeedbackResponseAttributes updatedResponse = new FeedbackResponseAttributes(feedbackResponse);\nupdatedResponse.update(options)\nfeedbackResponsesToValidate.add(updatedResponse)", "url": "https://github.com/TEAMMATES/teammates/pull/10620#discussion_r471858336", "createdAt": "2020-08-18T01:15:36Z", "author": {"login": "xpdavid"}, "path": "src/main/java/teammates/ui/webapi/action/SubmitFeedbackResponsesAction.java", "diffHunk": "@@ -0,0 +1,221 @@\n+package teammates.ui.webapi.action;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import teammates.common.datatransfer.FeedbackParticipantType;\n+import teammates.common.datatransfer.attributes.FeedbackQuestionAttributes;\n+import teammates.common.datatransfer.attributes.FeedbackResponseAttributes;\n+import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;\n+import teammates.common.datatransfer.attributes.InstructorAttributes;\n+import teammates.common.datatransfer.attributes.StudentAttributes;\n+import teammates.common.datatransfer.questions.FeedbackResponseDetails;\n+import teammates.common.exception.EntityAlreadyExistsException;\n+import teammates.common.exception.EntityDoesNotExistException;\n+import teammates.common.exception.EntityNotFoundException;\n+import teammates.common.exception.InvalidHttpParameterException;\n+import teammates.common.exception.InvalidHttpRequestBodyException;\n+import teammates.common.exception.InvalidParametersException;\n+import teammates.common.exception.UnauthorizedAccessException;\n+import teammates.common.util.Const;\n+import teammates.ui.webapi.output.FeedbackResponsesData;\n+import teammates.ui.webapi.request.FeedbackResponseSubmissionRequest;\n+import teammates.ui.webapi.request.Intent;\n+\n+/**\n+ * Submits a list of feedback responses to a feedback question.\n+ *\n+ * <p>This action is meant to completely overwrite the feedback responses that are previously attached to the\n+ * same feedback question.\n+ */\n+public class SubmitFeedbackResponsesAction extends BasicFeedbackSubmissionAction {\n+\n+    @Override\n+    protected AuthType getMinAuthLevel() {\n+        return AuthType.PUBLIC;\n+    }\n+\n+    @Override\n+    public void checkSpecificAccessControl() {\n+        String feedbackQuestionId = getNonNullRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_ID);\n+        FeedbackQuestionAttributes feedbackQuestion = logic.getFeedbackQuestion(feedbackQuestionId);\n+        if (feedbackQuestion == null) {\n+            throw new EntityNotFoundException(new EntityDoesNotExistException(\"The feedback question does not exist.\"));\n+        }\n+        FeedbackSessionAttributes feedbackSession =\n+                logic.getFeedbackSession(feedbackQuestion.feedbackSessionName, feedbackQuestion.courseId);\n+\n+        verifyInstructorCanSeeQuestionIfInModeration(feedbackQuestion);\n+        verifySessionOpenExceptForModeration(feedbackSession);\n+        verifyNotPreview();\n+\n+        Map<String, String> recipientsOfTheQuestion;\n+        Intent intent = Intent.valueOf(getNonNullRequestParamValue(Const.ParamsNames.INTENT));\n+        switch (intent) {\n+        case STUDENT_SUBMISSION:\n+            gateKeeper.verifyAnswerableForStudent(feedbackQuestion);\n+            StudentAttributes studentAttributes = getStudentOfCourseFromRequest(feedbackQuestion.getCourseId());\n+            checkAccessControlForStudentFeedbackSubmission(studentAttributes, feedbackSession);\n+            recipientsOfTheQuestion = logic.getRecipientsOfQuestion(feedbackQuestion, null, studentAttributes);\n+            break;\n+        case INSTRUCTOR_SUBMISSION:\n+            gateKeeper.verifyAnswerableForInstructor(feedbackQuestion);\n+            InstructorAttributes instructorAttributes = getInstructorOfCourseFromRequest(feedbackQuestion.getCourseId());\n+            checkAccessControlForInstructorFeedbackSubmission(instructorAttributes, feedbackSession);\n+            recipientsOfTheQuestion = logic.getRecipientsOfQuestion(feedbackQuestion, instructorAttributes, null);\n+            break;\n+        case INSTRUCTOR_RESULT:\n+        case STUDENT_RESULT:\n+            throw new InvalidHttpParameterException(\"Invalid intent for this action\");\n+        default:\n+            throw new InvalidHttpParameterException(\"Unknown intent \" + intent);\n+        }\n+\n+        FeedbackResponseSubmissionRequest submitRequest = getAndValidateRequestBody(FeedbackResponseSubmissionRequest.class);\n+\n+        for (String recipient : submitRequest.getRecipients()) {\n+            if (!recipientsOfTheQuestion.containsKey(recipient)) {\n+                throw new UnauthorizedAccessException(\"The recipient is not a valid recipient of the question\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public ActionResult execute() {\n+        String feedbackQuestionId = getNonNullRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_ID);\n+        FeedbackQuestionAttributes feedbackQuestion = logic.getFeedbackQuestion(feedbackQuestionId);\n+        if (feedbackQuestion == null) {\n+            throw new EntityNotFoundException(new EntityDoesNotExistException(\"The feedback question does not exist.\"));\n+        }\n+\n+        FeedbackResponseSubmissionRequest submitRequest = getAndValidateRequestBody(FeedbackResponseSubmissionRequest.class);\n+\n+        if (submitRequest.getResponseDetailsPerRecipient().isEmpty()) {\n+            logic.deleteFeedbackResponsesForQuestion(feedbackQuestionId);\n+            return new JsonResult(new FeedbackResponsesData(new ArrayList<>()));\n+        }\n+\n+        List<FeedbackResponseAttributes> existingResponses;\n+\n+        String giverIdentifier;\n+        String giverSection;\n+        Intent intent = Intent.valueOf(getNonNullRequestParamValue(Const.ParamsNames.INTENT));\n+        switch (intent) {\n+        case STUDENT_SUBMISSION:\n+            StudentAttributes studentAttributes = getStudentOfCourseFromRequest(feedbackQuestion.getCourseId());\n+            giverIdentifier =\n+                    feedbackQuestion.getGiverType() == FeedbackParticipantType.TEAMS\n+                            ? studentAttributes.getTeam() : studentAttributes.getEmail();\n+            giverSection = studentAttributes.getSection();\n+            existingResponses = logic.getFeedbackResponsesFromStudentOrTeamForQuestion(feedbackQuestion, studentAttributes);\n+            logic.populateFieldsToGenerateInQuestion(feedbackQuestion,\n+                    studentAttributes.getEmail(), studentAttributes.getTeam());\n+            break;\n+        case INSTRUCTOR_SUBMISSION:\n+            InstructorAttributes instructorAttributes = getInstructorOfCourseFromRequest(feedbackQuestion.getCourseId());\n+            giverIdentifier = instructorAttributes.getEmail();\n+            giverSection = Const.DEFAULT_SECTION;\n+            existingResponses = logic.getFeedbackResponsesFromInstructorForQuestion(feedbackQuestion, instructorAttributes);\n+            logic.populateFieldsToGenerateInQuestion(feedbackQuestion,\n+                    instructorAttributes.getEmail(), null);\n+            break;\n+        default:\n+            throw new InvalidHttpParameterException(\"Unknown intent \" + intent);\n+        }\n+\n+        Map<String, FeedbackResponseAttributes> existingResponsesPerRecipient = new HashMap<>();\n+        existingResponses.forEach(response -> existingResponsesPerRecipient.put(response.getRecipient(), response));\n+        Map<String, FeedbackResponseDetails> responseDetailsPerRecipient = submitRequest.getResponseDetailsPerRecipient();\n+        List<FeedbackResponseAttributes> feedbackResponsesToValidate = new ArrayList<>();\n+        List<FeedbackResponseAttributes> feedbackResponsesToAdd = new ArrayList<>();\n+        List<FeedbackResponseAttributes.UpdateOptions> feedbackResponsesToUpdate = new ArrayList<>();\n+\n+        responseDetailsPerRecipient.forEach((recipient, responseDetails) -> {\n+            if (existingResponsesPerRecipient.containsKey(recipient)) {\n+                FeedbackResponseAttributes feedbackResponse = existingResponsesPerRecipient.get(recipient);\n+                feedbackResponse.giver = giverIdentifier;\n+                feedbackResponse.giverSection = giverSection;\n+                feedbackResponse.recipient = recipient;\n+                feedbackResponse.recipientSection =\n+                        getRecipientSection(feedbackQuestion.getCourseId(), feedbackQuestion.getGiverType(),\n+                                feedbackQuestion.getRecipientType(), recipient);\n+                feedbackResponse.responseDetails = responseDetails;\n+\n+                feedbackResponsesToValidate.add(feedbackResponse);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f62b8a9c292098a107ded00b1ad2a16f7757a3ae"}, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTM4NDc2OnYy", "diffSide": "RIGHT", "path": "src/main/java/teammates/ui/webapi/action/SubmitFeedbackResponsesAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMToxNjo1M1rOHB_92g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMToxNjo1M1rOHB_92g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1ODY1MA==", "bodyText": "Why we need set the ID manually? The ID should be updated correctly in the returned response. I believe the previous API is written before my improvement on DB layer.", "url": "https://github.com/TEAMMATES/teammates/pull/10620#discussion_r471858650", "createdAt": "2020-08-18T01:16:53Z", "author": {"login": "xpdavid"}, "path": "src/main/java/teammates/ui/webapi/action/SubmitFeedbackResponsesAction.java", "diffHunk": "@@ -0,0 +1,221 @@\n+package teammates.ui.webapi.action;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import teammates.common.datatransfer.FeedbackParticipantType;\n+import teammates.common.datatransfer.attributes.FeedbackQuestionAttributes;\n+import teammates.common.datatransfer.attributes.FeedbackResponseAttributes;\n+import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;\n+import teammates.common.datatransfer.attributes.InstructorAttributes;\n+import teammates.common.datatransfer.attributes.StudentAttributes;\n+import teammates.common.datatransfer.questions.FeedbackResponseDetails;\n+import teammates.common.exception.EntityAlreadyExistsException;\n+import teammates.common.exception.EntityDoesNotExistException;\n+import teammates.common.exception.EntityNotFoundException;\n+import teammates.common.exception.InvalidHttpParameterException;\n+import teammates.common.exception.InvalidHttpRequestBodyException;\n+import teammates.common.exception.InvalidParametersException;\n+import teammates.common.exception.UnauthorizedAccessException;\n+import teammates.common.util.Const;\n+import teammates.ui.webapi.output.FeedbackResponsesData;\n+import teammates.ui.webapi.request.FeedbackResponseSubmissionRequest;\n+import teammates.ui.webapi.request.Intent;\n+\n+/**\n+ * Submits a list of feedback responses to a feedback question.\n+ *\n+ * <p>This action is meant to completely overwrite the feedback responses that are previously attached to the\n+ * same feedback question.\n+ */\n+public class SubmitFeedbackResponsesAction extends BasicFeedbackSubmissionAction {\n+\n+    @Override\n+    protected AuthType getMinAuthLevel() {\n+        return AuthType.PUBLIC;\n+    }\n+\n+    @Override\n+    public void checkSpecificAccessControl() {\n+        String feedbackQuestionId = getNonNullRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_ID);\n+        FeedbackQuestionAttributes feedbackQuestion = logic.getFeedbackQuestion(feedbackQuestionId);\n+        if (feedbackQuestion == null) {\n+            throw new EntityNotFoundException(new EntityDoesNotExistException(\"The feedback question does not exist.\"));\n+        }\n+        FeedbackSessionAttributes feedbackSession =\n+                logic.getFeedbackSession(feedbackQuestion.feedbackSessionName, feedbackQuestion.courseId);\n+\n+        verifyInstructorCanSeeQuestionIfInModeration(feedbackQuestion);\n+        verifySessionOpenExceptForModeration(feedbackSession);\n+        verifyNotPreview();\n+\n+        Map<String, String> recipientsOfTheQuestion;\n+        Intent intent = Intent.valueOf(getNonNullRequestParamValue(Const.ParamsNames.INTENT));\n+        switch (intent) {\n+        case STUDENT_SUBMISSION:\n+            gateKeeper.verifyAnswerableForStudent(feedbackQuestion);\n+            StudentAttributes studentAttributes = getStudentOfCourseFromRequest(feedbackQuestion.getCourseId());\n+            checkAccessControlForStudentFeedbackSubmission(studentAttributes, feedbackSession);\n+            recipientsOfTheQuestion = logic.getRecipientsOfQuestion(feedbackQuestion, null, studentAttributes);\n+            break;\n+        case INSTRUCTOR_SUBMISSION:\n+            gateKeeper.verifyAnswerableForInstructor(feedbackQuestion);\n+            InstructorAttributes instructorAttributes = getInstructorOfCourseFromRequest(feedbackQuestion.getCourseId());\n+            checkAccessControlForInstructorFeedbackSubmission(instructorAttributes, feedbackSession);\n+            recipientsOfTheQuestion = logic.getRecipientsOfQuestion(feedbackQuestion, instructorAttributes, null);\n+            break;\n+        case INSTRUCTOR_RESULT:\n+        case STUDENT_RESULT:\n+            throw new InvalidHttpParameterException(\"Invalid intent for this action\");\n+        default:\n+            throw new InvalidHttpParameterException(\"Unknown intent \" + intent);\n+        }\n+\n+        FeedbackResponseSubmissionRequest submitRequest = getAndValidateRequestBody(FeedbackResponseSubmissionRequest.class);\n+\n+        for (String recipient : submitRequest.getRecipients()) {\n+            if (!recipientsOfTheQuestion.containsKey(recipient)) {\n+                throw new UnauthorizedAccessException(\"The recipient is not a valid recipient of the question\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public ActionResult execute() {\n+        String feedbackQuestionId = getNonNullRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_ID);\n+        FeedbackQuestionAttributes feedbackQuestion = logic.getFeedbackQuestion(feedbackQuestionId);\n+        if (feedbackQuestion == null) {\n+            throw new EntityNotFoundException(new EntityDoesNotExistException(\"The feedback question does not exist.\"));\n+        }\n+\n+        FeedbackResponseSubmissionRequest submitRequest = getAndValidateRequestBody(FeedbackResponseSubmissionRequest.class);\n+\n+        if (submitRequest.getResponseDetailsPerRecipient().isEmpty()) {\n+            logic.deleteFeedbackResponsesForQuestion(feedbackQuestionId);\n+            return new JsonResult(new FeedbackResponsesData(new ArrayList<>()));\n+        }\n+\n+        List<FeedbackResponseAttributes> existingResponses;\n+\n+        String giverIdentifier;\n+        String giverSection;\n+        Intent intent = Intent.valueOf(getNonNullRequestParamValue(Const.ParamsNames.INTENT));\n+        switch (intent) {\n+        case STUDENT_SUBMISSION:\n+            StudentAttributes studentAttributes = getStudentOfCourseFromRequest(feedbackQuestion.getCourseId());\n+            giverIdentifier =\n+                    feedbackQuestion.getGiverType() == FeedbackParticipantType.TEAMS\n+                            ? studentAttributes.getTeam() : studentAttributes.getEmail();\n+            giverSection = studentAttributes.getSection();\n+            existingResponses = logic.getFeedbackResponsesFromStudentOrTeamForQuestion(feedbackQuestion, studentAttributes);\n+            logic.populateFieldsToGenerateInQuestion(feedbackQuestion,\n+                    studentAttributes.getEmail(), studentAttributes.getTeam());\n+            break;\n+        case INSTRUCTOR_SUBMISSION:\n+            InstructorAttributes instructorAttributes = getInstructorOfCourseFromRequest(feedbackQuestion.getCourseId());\n+            giverIdentifier = instructorAttributes.getEmail();\n+            giverSection = Const.DEFAULT_SECTION;\n+            existingResponses = logic.getFeedbackResponsesFromInstructorForQuestion(feedbackQuestion, instructorAttributes);\n+            logic.populateFieldsToGenerateInQuestion(feedbackQuestion,\n+                    instructorAttributes.getEmail(), null);\n+            break;\n+        default:\n+            throw new InvalidHttpParameterException(\"Unknown intent \" + intent);\n+        }\n+\n+        Map<String, FeedbackResponseAttributes> existingResponsesPerRecipient = new HashMap<>();\n+        existingResponses.forEach(response -> existingResponsesPerRecipient.put(response.getRecipient(), response));\n+        Map<String, FeedbackResponseDetails> responseDetailsPerRecipient = submitRequest.getResponseDetailsPerRecipient();\n+        List<FeedbackResponseAttributes> feedbackResponsesToValidate = new ArrayList<>();\n+        List<FeedbackResponseAttributes> feedbackResponsesToAdd = new ArrayList<>();\n+        List<FeedbackResponseAttributes.UpdateOptions> feedbackResponsesToUpdate = new ArrayList<>();\n+\n+        responseDetailsPerRecipient.forEach((recipient, responseDetails) -> {\n+            if (existingResponsesPerRecipient.containsKey(recipient)) {\n+                FeedbackResponseAttributes feedbackResponse = existingResponsesPerRecipient.get(recipient);\n+                feedbackResponse.giver = giverIdentifier;\n+                feedbackResponse.giverSection = giverSection;\n+                feedbackResponse.recipient = recipient;\n+                feedbackResponse.recipientSection =\n+                        getRecipientSection(feedbackQuestion.getCourseId(), feedbackQuestion.getGiverType(),\n+                                feedbackQuestion.getRecipientType(), recipient);\n+                feedbackResponse.responseDetails = responseDetails;\n+\n+                feedbackResponsesToValidate.add(feedbackResponse);\n+                feedbackResponsesToUpdate.add(FeedbackResponseAttributes.updateOptionsBuilder(feedbackResponse.getId())\n+                        .withGiver(feedbackResponse.giver)\n+                        .withGiverSection(feedbackResponse.giverSection)\n+                        .withRecipient(feedbackResponse.recipient)\n+                        .withRecipientSection(feedbackResponse.recipientSection)\n+                        .withResponseDetails(feedbackResponse.getResponseDetails())\n+                        .build());\n+            } else {\n+                FeedbackResponseAttributes feedbackResponse = FeedbackResponseAttributes\n+                        .builder(feedbackQuestion.getId(), giverIdentifier, recipient)\n+                        .withGiverSection(giverSection)\n+                        .withRecipientSection(getRecipientSection(feedbackQuestion.getCourseId(),\n+                                feedbackQuestion.getGiverType(),\n+                                feedbackQuestion.getRecipientType(), recipient))\n+                        .withCourseId(feedbackQuestion.getCourseId())\n+                        .withFeedbackSessionName(feedbackQuestion.getFeedbackSessionName())\n+                        .withResponseDetails(responseDetails)\n+                        .build();\n+\n+                feedbackResponsesToValidate.add(feedbackResponse);\n+                feedbackResponsesToAdd.add(feedbackResponse);\n+            }\n+        });\n+\n+        validateResponsesOfQuestion(feedbackQuestion, feedbackResponsesToValidate);\n+\n+        List<FeedbackResponseAttributes> feedbackResponsesToDelete = existingResponsesPerRecipient.entrySet().stream()\n+                .filter(entry -> !responseDetailsPerRecipient.containsKey(entry.getKey()))\n+                .map(entry -> entry.getValue())\n+                .collect(Collectors.toList());\n+\n+        for (FeedbackResponseAttributes feedbackResponse : feedbackResponsesToDelete) {\n+            logic.deleteFeedbackResponseCascade(feedbackResponse.getId());\n+        }\n+\n+        List<FeedbackResponseAttributes> output = new ArrayList<>();\n+\n+        for (FeedbackResponseAttributes feedbackResponse : feedbackResponsesToAdd) {\n+            try {\n+                FeedbackResponseAttributes createdFeedbackResponse = logic.createFeedbackResponse(feedbackResponse);\n+                createdFeedbackResponse.setId(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f62b8a9c292098a107ded00b1ad2a16f7757a3ae"}, "originalPosition": 188}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTQyMDAwOnYy", "diffSide": "RIGHT", "path": "src/web/app/components/question-types/question-edit-answer-form/rubric-question-edit-answer-form.component.ts", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMTozNTo1M1rOHCARbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMTozNTo1M1rOHCARbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg2MzY2MQ==", "bodyText": "I would add comment\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  newAnswer[subQuestionIndex] = RUBRIC_ANSWER_NOT_CHOSEN;\n          \n          \n            \n                  // select the same answer, toggle as unselected\n          \n          \n            \n                  newAnswer[subQuestionIndex] = RUBRIC_ANSWER_NOT_CHOSEN;", "url": "https://github.com/TEAMMATES/teammates/pull/10620#discussion_r471863661", "createdAt": "2020-08-18T01:35:53Z", "author": {"login": "xpdavid"}, "path": "src/web/app/components/question-types/question-edit-answer-form/rubric-question-edit-answer-form.component.ts", "diffHunk": "@@ -48,7 +48,11 @@ export class RubricQuestionEditAnswerFormComponent extends QuestionEditAnswerFor\n       newAnswer = Array(this.questionDetails.numOfRubricSubQuestions).fill(RUBRIC_ANSWER_NOT_CHOSEN);\n     }\n \n-    newAnswer[subQuestionIndex] = answerIndex;\n+    if (newAnswer[subQuestionIndex] === answerIndex) {\n+      newAnswer[subQuestionIndex] = RUBRIC_ANSWER_NOT_CHOSEN;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2abcbde20255b3785f709a0ce8f6b94f5bafb65e"}, "originalPosition": 6}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3496, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}