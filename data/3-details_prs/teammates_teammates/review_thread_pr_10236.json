{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQwMTQyNTE1", "number": 10236, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxNToyNDoyMFrOEMiheQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxNToyNDoyMFrOEMiheQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxNTgzOTkzOnYy", "diffSide": "RIGHT", "path": "src/e2e/java/teammates/e2e/util/BackDoor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxNToyNDoyMFrOGutUwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxNToyNDoyMFrOGutUwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTYzMDI3NA==", "bodyText": "Minor point:\nI realise this is a common pattern within the BackDoor. I am personally not a fan of sweeping through a list to find and return an item inside. The happy path is not very clear either :P\nThis is an alternate way of doing it:\nFeedbackSessionData feedbackSession =  \n    sessionsData.getFeedbackSessions()\n                .stream()\n                .filter(fs -> fs.getFeedbackSessionName().equals(feedbackSessionName))\n                .findFirst()\n                .orElse(null);\n\nif (feedbackSession == null) {\n    return null;\n}\n\nreturn FeedbackSessionAttributes\n        .builder(feedbackSession.getCourseId(), \n                 feedbackSession.getFeedbackSessionName())\n        .build();", "url": "https://github.com/TEAMMATES/teammates/pull/10236#discussion_r451630274", "createdAt": "2020-07-08T15:24:20Z", "author": {"login": "rrtheonlyone"}, "path": "src/e2e/java/teammates/e2e/util/BackDoor.java", "diffHunk": "@@ -425,6 +440,151 @@ public static StudentAttributes getStudent(String courseId, String studentEmail)\n         return student.build();\n     }\n \n+    /**\n+     * Get feedback session data from datastore.\n+     */\n+    public static FeedbackSessionData getFeedbackSessionData(String courseId, String feedbackSessionName) {\n+        Map<String, String[]> params = new HashMap<>();\n+        params.put(Const.ParamsNames.COURSE_ID, new String[] { courseId });\n+        params.put(Const.ParamsNames.FEEDBACK_SESSION_NAME, new String[] { feedbackSessionName });\n+        params.put(Const.ParamsNames.INTENT, new String[] { Intent.FULL_DETAIL.toString() });\n+        ResponseBodyAndCode response = executeGetRequest(Const.ResourceURIs.SESSION, params);\n+        if (response.responseCode == HttpStatus.SC_NOT_FOUND) {\n+            return null;\n+        }\n+        return JsonUtils.fromJson(response.responseBody, FeedbackSessionData.class);\n+    }\n+\n+    /**\n+     * Get feedback session from datastore.\n+     */\n+    public static FeedbackSessionAttributes getFeedbackSession(String courseId, String feedbackSessionName) {\n+        FeedbackSessionData sessionData = getFeedbackSessionData(courseId, feedbackSessionName);\n+\n+        FeedbackSessionAttributes sessionAttributes = FeedbackSessionAttributes\n+                .builder(sessionData.getFeedbackSessionName(), sessionData.getCourseId())\n+                .withInstructions(sessionData.getInstructions())\n+                .withStartTime(Instant.ofEpochMilli(sessionData.getSubmissionStartTimestamp()))\n+                .withEndTime(Instant.ofEpochMilli(sessionData.getSubmissionEndTimestamp()))\n+                .withTimeZone(ZoneId.of(sessionData.getTimeZone()))\n+                .withGracePeriod(Duration.ofMinutes(sessionData.getGracePeriod()))\n+                .withIsClosingEmailEnabled(sessionData.getIsClosingEmailEnabled())\n+                .withIsPublishedEmailEnabled(sessionData.getIsPublishedEmailEnabled())\n+                .build();\n+\n+        sessionAttributes.setCreatedTime(Instant.ofEpochMilli(sessionData.getCreatedAtTimestamp()));\n+\n+        if (sessionData.getSessionVisibleSetting().equals(SessionVisibleSetting.AT_OPEN)) {\n+            sessionAttributes.setSessionVisibleFromTime(Const.TIME_REPRESENTS_FOLLOW_OPENING);\n+        } else {\n+            sessionAttributes.setSessionVisibleFromTime(Instant.ofEpochMilli(\n+                    sessionData.getCustomSessionVisibleTimestamp()));\n+        }\n+\n+        if (sessionData.getResponseVisibleSetting().equals(ResponseVisibleSetting.AT_VISIBLE)) {\n+            sessionAttributes.setResultsVisibleFromTime(Const.TIME_REPRESENTS_FOLLOW_VISIBLE);\n+        } else if (sessionData.getResponseVisibleSetting().equals(ResponseVisibleSetting.LATER)) {\n+            sessionAttributes.setResultsVisibleFromTime(Const.TIME_REPRESENTS_LATER);\n+        } else {\n+            sessionAttributes.setResultsVisibleFromTime(Instant.ofEpochMilli(\n+                    sessionData.getCustomResponseVisibleTimestamp()));\n+        }\n+\n+        return sessionAttributes;\n+    }\n+\n+    /**\n+     * Get soft deleted feedback session from datastore.\n+     */\n+    public static FeedbackSessionAttributes getSoftDeletedSession(String feedbackSessionName, String instructorId) {\n+        Map<String, String[]> params = new HashMap<>();\n+        params.put(Const.ParamsNames.ENTITY_TYPE, new String[] { Const.EntityType.INSTRUCTOR });\n+        params.put(Const.ParamsNames.IS_IN_RECYCLE_BIN, new String[] { \"true\" });\n+        params.put(Const.ParamsNames.USER_ID, new String[] { instructorId });\n+        ResponseBodyAndCode response = executeGetRequest(Const.ResourceURIs.SESSIONS, params);\n+        if (response.responseCode == HttpStatus.SC_NOT_FOUND) {\n+            return null;\n+        }\n+\n+        FeedbackSessionsData sessionsData = JsonUtils.fromJson(response.responseBody, FeedbackSessionsData.class);\n+        List<FeedbackSessionData> sessionsDataList = sessionsData.getFeedbackSessions();\n+        for (FeedbackSessionData feedbackSession : sessionsDataList) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98ab5c634cf1ada81ab26eefe35673048688fc11"}, "originalPosition": 115}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3879, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}