{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY5MTE2NTYw", "number": 10620, "title": "[#10397] Create API for receiving all responses of a feedback question", "bodyText": "This is the more important part of #10397\n\nCreated a new PUT /responses endpoint which takes in the list of responses for a particular question ID. The back-end will know which responses to update, delete, and create based on the list of responses given and the list of responses already existing in the DB.\n\nAll previous individual response APIs, namely POST /response, PUT /response, DELETE /response, are decommissioned\n\n\nAdded question-wide validation for rank recipient and const sum recipient questions\nRemoved usage of numOfConstSumOption which is problematic/redundant\n\nAlso removed the field itself in one of the commits, but this can be kept for a while longer Delayed to later, when it's safe to do so\n\n\n\nAnd some quality of life improvements:\n\nAllowed erasing of answers; this was not working/buggy in many question types before\nFixed #10588; while this issue is independent, because the validation logic has been moved, we might as well fix it here\n\nThe following things still need to be done (in future PR):\n\nWriting API tests; not done yet as I still want some feedback on the API design\nDeciding how to organize the error messages; whether to show all or partial or ...", "createdAt": "2020-08-17T23:27:03Z", "url": "https://github.com/TEAMMATES/teammates/pull/10620", "merged": true, "mergeCommit": {"oid": "7ac01ad4b14f6f84e706f606fcdf25190973d4b7"}, "closed": true, "closedAt": "2020-08-20T12:21:00Z", "author": {"login": "wkurniawan07"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc_7AgoAFqTQ2ODg5NjE2NQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdAuCzmAH2gAyNDY5MTE2NTYwOmRhNWUwNTgxYjc5N2RkNTA5YWIxOTAwNzg3YTRiZDRlZGJkYjM1NDQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4ODk2MTY1", "url": "https://github.com/TEAMMATES/teammates/pull/10620#pullrequestreview-468896165", "createdAt": "2020-08-17T23:28:15Z", "commit": {"oid": "eaffa4e01ea6173cc160d76c603c4bb4cd9a6cec"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QyMzoyODoxNVrOHB-JZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QyMzoyODoxNVrOHB-JZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgyODgzNg==", "bodyText": "I skipped this because I wasn't very sure how this is supposed to work. Will take some time to add this back, @xpdavid if you can help it will be great.", "url": "https://github.com/TEAMMATES/teammates/pull/10620#discussion_r471828836", "createdAt": "2020-08-17T23:28:15Z", "author": {"login": "wkurniawan07"}, "path": "src/web/app/pages-session/session-submission-page/session-submission-page.component.ts", "diffHunk": "@@ -547,84 +549,63 @@ export class SessionSubmissionPageComponent implements OnInit, AfterViewInit {\n     this.questionSubmissionForms.forEach((questionSubmissionFormModel: QuestionSubmissionFormModel) => {\n       let isQuestionFullyAnswered: boolean = true;\n \n+      const responseDetailsPerRecipient: Record<string, FeedbackResponseDetails> = {};\n+\n       questionSubmissionFormModel.recipientSubmissionForms\n           .forEach((recipientSubmissionFormModel: FeedbackResponseRecipientSubmissionFormModel) => {\n             const isFeedbackResponseDetailsEmpty: boolean =\n                 this.feedbackResponsesService.isFeedbackResponseDetailsEmpty(\n                     questionSubmissionFormModel.questionType, recipientSubmissionFormModel.responseDetails);\n             isQuestionFullyAnswered = isQuestionFullyAnswered && !isFeedbackResponseDetailsEmpty;\n \n-            if (recipientSubmissionFormModel.responseId !== '' && isFeedbackResponseDetailsEmpty) {\n-              // existing response but empty details -> delete response\n-              savingRequests.push(this.feedbackResponsesService.deleteFeedbackResponse({\n-                responseId: recipientSubmissionFormModel.responseId,\n-                intent: this.intent,\n-                key: this.regKey,\n-                moderatedPerson: this.moderatedPerson,\n-              }).pipe(\n-                  tap(() => {\n-                    // clear inputs\n-                    recipientSubmissionFormModel.responseId = '';\n-                    recipientSubmissionFormModel.commentByGiver = undefined;\n-                  }),\n-                  catchError((error: ErrorMessageOutput) => {\n-                    failToSaveQuestions[questionSubmissionFormModel.questionNumber] = error.error.message;\n-                    return of(error);\n-                  }),\n-              ));\n-            }\n-\n-            if (recipientSubmissionFormModel.responseId !== '' && !isFeedbackResponseDetailsEmpty) {\n-              // existing response and details is not empty -> update response\n-              savingRequests.push(\n-                  this.feedbackResponsesService.updateFeedbackResponse(recipientSubmissionFormModel.responseId, {\n-                    intent: this.intent,\n-                    key: this.regKey,\n-                    moderatedperson: this.moderatedPerson,\n-                  }, {\n-                    recipientIdentifier: recipientSubmissionFormModel.recipientIdentifier,\n-                    questionType: questionSubmissionFormModel.questionType,\n-                    responseDetails: recipientSubmissionFormModel.responseDetails,\n-                  }).pipe(\n-                      tap((resp: FeedbackResponse) => {\n-                        recipientSubmissionFormModel.responseId = resp.feedbackResponseId;\n-                        recipientSubmissionFormModel.responseDetails = resp.responseDetails;\n-                        recipientSubmissionFormModel.recipientIdentifier = resp.recipientIdentifier;\n-                      }),\n-                      switchMap(() => this.createCommentRequest(recipientSubmissionFormModel)),\n-                      catchError((error: ErrorMessageOutput) => {\n-                        failToSaveQuestions[questionSubmissionFormModel.questionNumber] = error.error.message;\n-                        return of(error);\n-                      }),\n-                  ));\n-            }\n-\n-            if (recipientSubmissionFormModel.responseId === '' && !isFeedbackResponseDetailsEmpty) {\n-              // new response and the details is not empty -> create response\n-              savingRequests.push(\n-                  this.feedbackResponsesService.createFeedbackResponse(questionSubmissionFormModel.feedbackQuestionId, {\n-                    intent: this.intent,\n-                    key: this.regKey,\n-                    moderatedperson: this.moderatedPerson,\n-                  }, {\n-                    recipientIdentifier: recipientSubmissionFormModel.recipientIdentifier,\n-                    questionType: questionSubmissionFormModel.questionType,\n-                    responseDetails: recipientSubmissionFormModel.responseDetails,\n-                  }).pipe(\n-                      tap((resp: FeedbackResponse) => {\n-                        recipientSubmissionFormModel.responseId = resp.feedbackResponseId;\n-                        recipientSubmissionFormModel.responseDetails = resp.responseDetails;\n-                        recipientSubmissionFormModel.recipientIdentifier = resp.recipientIdentifier;\n-                      }),\n-                      switchMap(() => this.createCommentRequest(recipientSubmissionFormModel)),\n-                      catchError((error: ErrorMessageOutput) => {\n-                        failToSaveQuestions[questionSubmissionFormModel.questionNumber] = error.error.message;\n-                        return of(error);\n-                      }),\n-                  ));\n+            if (!isFeedbackResponseDetailsEmpty) {\n+              responseDetailsPerRecipient[recipientSubmissionFormModel.recipientIdentifier] =\n+                  recipientSubmissionFormModel.responseDetails;\n             }\n           });\n \n+      savingRequests.push(\n+          this.feedbackResponsesService.submitFeedbackResponse(questionSubmissionFormModel.feedbackQuestionId, {\n+            intent: this.intent,\n+            key: this.regKey,\n+            moderatedperson: this.moderatedPerson,\n+          }, {\n+            responseDetailsPerRecipient,\n+            questionType: questionSubmissionFormModel.questionType,\n+          }).pipe(\n+              tap((resp: FeedbackResponses) => {\n+                const responsesMap: Record<string, FeedbackResponse> = {};\n+                resp.responses.forEach((response: FeedbackResponse) => {\n+                  responsesMap[response.recipientIdentifier] = response;\n+                });\n+\n+                questionSubmissionFormModel.recipientSubmissionForms\n+                    .forEach((recipientSubmissionFormModel: FeedbackResponseRecipientSubmissionFormModel) => {\n+                      if (responsesMap[recipientSubmissionFormModel.recipientIdentifier]) {\n+                        const correspondingResp: FeedbackResponse =\n+                            responsesMap[recipientSubmissionFormModel.recipientIdentifier];\n+                        recipientSubmissionFormModel.responseId = correspondingResp.feedbackResponseId;\n+                        recipientSubmissionFormModel.responseDetails = correspondingResp.responseDetails;\n+                        recipientSubmissionFormModel.recipientIdentifier = correspondingResp.recipientIdentifier;\n+                      } else {\n+                        recipientSubmissionFormModel.responseId = '';\n+                        recipientSubmissionFormModel.commentByGiver = undefined;\n+                      }\n+                    });\n+              }),\n+              // switchMap(() =>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eaffa4e01ea6173cc160d76c603c4bb4cd9a6cec"}, "originalPosition": 125}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTE5NzM0", "url": "https://github.com/TEAMMATES/teammates/pull/10620#pullrequestreview-468919734", "createdAt": "2020-08-18T00:44:47Z", "commit": {"oid": "1095aea151653fcfeb06ac4b6a3638754bf87cef"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMDo0NDo0OFrOHB_cmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMTozNTo1M1rOHCARbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1MDEzNw==", "bodyText": "Don't forget javadoc", "url": "https://github.com/TEAMMATES/teammates/pull/10620#discussion_r471850137", "createdAt": "2020-08-18T00:44:48Z", "author": {"login": "xpdavid"}, "path": "src/main/java/teammates/common/datatransfer/questions/FeedbackQuestionDetails.java", "diffHunk": "@@ -63,6 +63,8 @@ public boolean isIndividualResponsesShownToStudents() {\n      */\n     public abstract List<String> validateQuestionDetails();\n \n+    public abstract List<String> validateResponsesDetails(List<FeedbackResponseDetails> responseDetails);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1095aea151653fcfeb06ac4b6a3638754bf87cef"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1MDkxNw==", "bodyText": "Can we inherit the doc for deleteFeedbackResponsesForQuestion in feedbackResponsesLogic", "url": "https://github.com/TEAMMATES/teammates/pull/10620#discussion_r471850917", "createdAt": "2020-08-18T00:47:50Z", "author": {"login": "xpdavid"}, "path": "src/main/java/teammates/logic/api/Logic.java", "diffHunk": "@@ -1487,4 +1487,9 @@ public int getNumOfGeneratedChoicesForParticipantType(String courseId, FeedbackP\n         return feedbackQuestionsLogic.getNumOfGeneratedChoicesForParticipantType(courseId, generateOptionsFor);\n     }\n \n+    public void deleteFeedbackResponsesForQuestion(String feedbackQuestionId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67d6feaf68aac713c1bf90f4a234418894e40a2e"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1NTk2Nw==", "bodyText": "I don't recommend to use map as API request. It is too abstract and there is no way to tell the structure immediately even looking at the class itself.\nInstead, I think it should accept a list of FeedbackResponseRequest where there are two field recipientIdentifier  and responseDetails.", "url": "https://github.com/TEAMMATES/teammates/pull/10620#discussion_r471855967", "createdAt": "2020-08-18T01:06:55Z", "author": {"login": "xpdavid"}, "path": "src/main/java/teammates/ui/webapi/request/FeedbackResponseSubmissionRequest.java", "diffHunk": "@@ -0,0 +1,64 @@\n+package teammates.ui.webapi.request;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import teammates.common.datatransfer.questions.FeedbackQuestionType;\n+import teammates.common.datatransfer.questions.FeedbackResponseDetails;\n+import teammates.common.util.JsonUtils;\n+\n+/**\n+ * The basic request of modifying a feedback response.\n+ */\n+public class FeedbackResponseSubmissionRequest extends BasicRequest {\n+\n+    private FeedbackQuestionType questionType;\n+    private Map<String, Map<String, Object>> responseDetailsPerRecipient = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f62b8a9c292098a107ded00b1ad2a16f7757a3ae"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1ODMzNg==", "bodyText": "The above lines can be written as\nFeedbackResponseAttributes.UpdateOptions options = XXXX (Line 148 - 154)\nFeedbackResponseAttributes updatedResponse = new FeedbackResponseAttributes(feedbackResponse);\nupdatedResponse.update(options)\nfeedbackResponsesToValidate.add(updatedResponse)", "url": "https://github.com/TEAMMATES/teammates/pull/10620#discussion_r471858336", "createdAt": "2020-08-18T01:15:36Z", "author": {"login": "xpdavid"}, "path": "src/main/java/teammates/ui/webapi/action/SubmitFeedbackResponsesAction.java", "diffHunk": "@@ -0,0 +1,221 @@\n+package teammates.ui.webapi.action;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import teammates.common.datatransfer.FeedbackParticipantType;\n+import teammates.common.datatransfer.attributes.FeedbackQuestionAttributes;\n+import teammates.common.datatransfer.attributes.FeedbackResponseAttributes;\n+import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;\n+import teammates.common.datatransfer.attributes.InstructorAttributes;\n+import teammates.common.datatransfer.attributes.StudentAttributes;\n+import teammates.common.datatransfer.questions.FeedbackResponseDetails;\n+import teammates.common.exception.EntityAlreadyExistsException;\n+import teammates.common.exception.EntityDoesNotExistException;\n+import teammates.common.exception.EntityNotFoundException;\n+import teammates.common.exception.InvalidHttpParameterException;\n+import teammates.common.exception.InvalidHttpRequestBodyException;\n+import teammates.common.exception.InvalidParametersException;\n+import teammates.common.exception.UnauthorizedAccessException;\n+import teammates.common.util.Const;\n+import teammates.ui.webapi.output.FeedbackResponsesData;\n+import teammates.ui.webapi.request.FeedbackResponseSubmissionRequest;\n+import teammates.ui.webapi.request.Intent;\n+\n+/**\n+ * Submits a list of feedback responses to a feedback question.\n+ *\n+ * <p>This action is meant to completely overwrite the feedback responses that are previously attached to the\n+ * same feedback question.\n+ */\n+public class SubmitFeedbackResponsesAction extends BasicFeedbackSubmissionAction {\n+\n+    @Override\n+    protected AuthType getMinAuthLevel() {\n+        return AuthType.PUBLIC;\n+    }\n+\n+    @Override\n+    public void checkSpecificAccessControl() {\n+        String feedbackQuestionId = getNonNullRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_ID);\n+        FeedbackQuestionAttributes feedbackQuestion = logic.getFeedbackQuestion(feedbackQuestionId);\n+        if (feedbackQuestion == null) {\n+            throw new EntityNotFoundException(new EntityDoesNotExistException(\"The feedback question does not exist.\"));\n+        }\n+        FeedbackSessionAttributes feedbackSession =\n+                logic.getFeedbackSession(feedbackQuestion.feedbackSessionName, feedbackQuestion.courseId);\n+\n+        verifyInstructorCanSeeQuestionIfInModeration(feedbackQuestion);\n+        verifySessionOpenExceptForModeration(feedbackSession);\n+        verifyNotPreview();\n+\n+        Map<String, String> recipientsOfTheQuestion;\n+        Intent intent = Intent.valueOf(getNonNullRequestParamValue(Const.ParamsNames.INTENT));\n+        switch (intent) {\n+        case STUDENT_SUBMISSION:\n+            gateKeeper.verifyAnswerableForStudent(feedbackQuestion);\n+            StudentAttributes studentAttributes = getStudentOfCourseFromRequest(feedbackQuestion.getCourseId());\n+            checkAccessControlForStudentFeedbackSubmission(studentAttributes, feedbackSession);\n+            recipientsOfTheQuestion = logic.getRecipientsOfQuestion(feedbackQuestion, null, studentAttributes);\n+            break;\n+        case INSTRUCTOR_SUBMISSION:\n+            gateKeeper.verifyAnswerableForInstructor(feedbackQuestion);\n+            InstructorAttributes instructorAttributes = getInstructorOfCourseFromRequest(feedbackQuestion.getCourseId());\n+            checkAccessControlForInstructorFeedbackSubmission(instructorAttributes, feedbackSession);\n+            recipientsOfTheQuestion = logic.getRecipientsOfQuestion(feedbackQuestion, instructorAttributes, null);\n+            break;\n+        case INSTRUCTOR_RESULT:\n+        case STUDENT_RESULT:\n+            throw new InvalidHttpParameterException(\"Invalid intent for this action\");\n+        default:\n+            throw new InvalidHttpParameterException(\"Unknown intent \" + intent);\n+        }\n+\n+        FeedbackResponseSubmissionRequest submitRequest = getAndValidateRequestBody(FeedbackResponseSubmissionRequest.class);\n+\n+        for (String recipient : submitRequest.getRecipients()) {\n+            if (!recipientsOfTheQuestion.containsKey(recipient)) {\n+                throw new UnauthorizedAccessException(\"The recipient is not a valid recipient of the question\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public ActionResult execute() {\n+        String feedbackQuestionId = getNonNullRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_ID);\n+        FeedbackQuestionAttributes feedbackQuestion = logic.getFeedbackQuestion(feedbackQuestionId);\n+        if (feedbackQuestion == null) {\n+            throw new EntityNotFoundException(new EntityDoesNotExistException(\"The feedback question does not exist.\"));\n+        }\n+\n+        FeedbackResponseSubmissionRequest submitRequest = getAndValidateRequestBody(FeedbackResponseSubmissionRequest.class);\n+\n+        if (submitRequest.getResponseDetailsPerRecipient().isEmpty()) {\n+            logic.deleteFeedbackResponsesForQuestion(feedbackQuestionId);\n+            return new JsonResult(new FeedbackResponsesData(new ArrayList<>()));\n+        }\n+\n+        List<FeedbackResponseAttributes> existingResponses;\n+\n+        String giverIdentifier;\n+        String giverSection;\n+        Intent intent = Intent.valueOf(getNonNullRequestParamValue(Const.ParamsNames.INTENT));\n+        switch (intent) {\n+        case STUDENT_SUBMISSION:\n+            StudentAttributes studentAttributes = getStudentOfCourseFromRequest(feedbackQuestion.getCourseId());\n+            giverIdentifier =\n+                    feedbackQuestion.getGiverType() == FeedbackParticipantType.TEAMS\n+                            ? studentAttributes.getTeam() : studentAttributes.getEmail();\n+            giverSection = studentAttributes.getSection();\n+            existingResponses = logic.getFeedbackResponsesFromStudentOrTeamForQuestion(feedbackQuestion, studentAttributes);\n+            logic.populateFieldsToGenerateInQuestion(feedbackQuestion,\n+                    studentAttributes.getEmail(), studentAttributes.getTeam());\n+            break;\n+        case INSTRUCTOR_SUBMISSION:\n+            InstructorAttributes instructorAttributes = getInstructorOfCourseFromRequest(feedbackQuestion.getCourseId());\n+            giverIdentifier = instructorAttributes.getEmail();\n+            giverSection = Const.DEFAULT_SECTION;\n+            existingResponses = logic.getFeedbackResponsesFromInstructorForQuestion(feedbackQuestion, instructorAttributes);\n+            logic.populateFieldsToGenerateInQuestion(feedbackQuestion,\n+                    instructorAttributes.getEmail(), null);\n+            break;\n+        default:\n+            throw new InvalidHttpParameterException(\"Unknown intent \" + intent);\n+        }\n+\n+        Map<String, FeedbackResponseAttributes> existingResponsesPerRecipient = new HashMap<>();\n+        existingResponses.forEach(response -> existingResponsesPerRecipient.put(response.getRecipient(), response));\n+        Map<String, FeedbackResponseDetails> responseDetailsPerRecipient = submitRequest.getResponseDetailsPerRecipient();\n+        List<FeedbackResponseAttributes> feedbackResponsesToValidate = new ArrayList<>();\n+        List<FeedbackResponseAttributes> feedbackResponsesToAdd = new ArrayList<>();\n+        List<FeedbackResponseAttributes.UpdateOptions> feedbackResponsesToUpdate = new ArrayList<>();\n+\n+        responseDetailsPerRecipient.forEach((recipient, responseDetails) -> {\n+            if (existingResponsesPerRecipient.containsKey(recipient)) {\n+                FeedbackResponseAttributes feedbackResponse = existingResponsesPerRecipient.get(recipient);\n+                feedbackResponse.giver = giverIdentifier;\n+                feedbackResponse.giverSection = giverSection;\n+                feedbackResponse.recipient = recipient;\n+                feedbackResponse.recipientSection =\n+                        getRecipientSection(feedbackQuestion.getCourseId(), feedbackQuestion.getGiverType(),\n+                                feedbackQuestion.getRecipientType(), recipient);\n+                feedbackResponse.responseDetails = responseDetails;\n+\n+                feedbackResponsesToValidate.add(feedbackResponse);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f62b8a9c292098a107ded00b1ad2a16f7757a3ae"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1ODY1MA==", "bodyText": "Why we need set the ID manually? The ID should be updated correctly in the returned response. I believe the previous API is written before my improvement on DB layer.", "url": "https://github.com/TEAMMATES/teammates/pull/10620#discussion_r471858650", "createdAt": "2020-08-18T01:16:53Z", "author": {"login": "xpdavid"}, "path": "src/main/java/teammates/ui/webapi/action/SubmitFeedbackResponsesAction.java", "diffHunk": "@@ -0,0 +1,221 @@\n+package teammates.ui.webapi.action;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import teammates.common.datatransfer.FeedbackParticipantType;\n+import teammates.common.datatransfer.attributes.FeedbackQuestionAttributes;\n+import teammates.common.datatransfer.attributes.FeedbackResponseAttributes;\n+import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;\n+import teammates.common.datatransfer.attributes.InstructorAttributes;\n+import teammates.common.datatransfer.attributes.StudentAttributes;\n+import teammates.common.datatransfer.questions.FeedbackResponseDetails;\n+import teammates.common.exception.EntityAlreadyExistsException;\n+import teammates.common.exception.EntityDoesNotExistException;\n+import teammates.common.exception.EntityNotFoundException;\n+import teammates.common.exception.InvalidHttpParameterException;\n+import teammates.common.exception.InvalidHttpRequestBodyException;\n+import teammates.common.exception.InvalidParametersException;\n+import teammates.common.exception.UnauthorizedAccessException;\n+import teammates.common.util.Const;\n+import teammates.ui.webapi.output.FeedbackResponsesData;\n+import teammates.ui.webapi.request.FeedbackResponseSubmissionRequest;\n+import teammates.ui.webapi.request.Intent;\n+\n+/**\n+ * Submits a list of feedback responses to a feedback question.\n+ *\n+ * <p>This action is meant to completely overwrite the feedback responses that are previously attached to the\n+ * same feedback question.\n+ */\n+public class SubmitFeedbackResponsesAction extends BasicFeedbackSubmissionAction {\n+\n+    @Override\n+    protected AuthType getMinAuthLevel() {\n+        return AuthType.PUBLIC;\n+    }\n+\n+    @Override\n+    public void checkSpecificAccessControl() {\n+        String feedbackQuestionId = getNonNullRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_ID);\n+        FeedbackQuestionAttributes feedbackQuestion = logic.getFeedbackQuestion(feedbackQuestionId);\n+        if (feedbackQuestion == null) {\n+            throw new EntityNotFoundException(new EntityDoesNotExistException(\"The feedback question does not exist.\"));\n+        }\n+        FeedbackSessionAttributes feedbackSession =\n+                logic.getFeedbackSession(feedbackQuestion.feedbackSessionName, feedbackQuestion.courseId);\n+\n+        verifyInstructorCanSeeQuestionIfInModeration(feedbackQuestion);\n+        verifySessionOpenExceptForModeration(feedbackSession);\n+        verifyNotPreview();\n+\n+        Map<String, String> recipientsOfTheQuestion;\n+        Intent intent = Intent.valueOf(getNonNullRequestParamValue(Const.ParamsNames.INTENT));\n+        switch (intent) {\n+        case STUDENT_SUBMISSION:\n+            gateKeeper.verifyAnswerableForStudent(feedbackQuestion);\n+            StudentAttributes studentAttributes = getStudentOfCourseFromRequest(feedbackQuestion.getCourseId());\n+            checkAccessControlForStudentFeedbackSubmission(studentAttributes, feedbackSession);\n+            recipientsOfTheQuestion = logic.getRecipientsOfQuestion(feedbackQuestion, null, studentAttributes);\n+            break;\n+        case INSTRUCTOR_SUBMISSION:\n+            gateKeeper.verifyAnswerableForInstructor(feedbackQuestion);\n+            InstructorAttributes instructorAttributes = getInstructorOfCourseFromRequest(feedbackQuestion.getCourseId());\n+            checkAccessControlForInstructorFeedbackSubmission(instructorAttributes, feedbackSession);\n+            recipientsOfTheQuestion = logic.getRecipientsOfQuestion(feedbackQuestion, instructorAttributes, null);\n+            break;\n+        case INSTRUCTOR_RESULT:\n+        case STUDENT_RESULT:\n+            throw new InvalidHttpParameterException(\"Invalid intent for this action\");\n+        default:\n+            throw new InvalidHttpParameterException(\"Unknown intent \" + intent);\n+        }\n+\n+        FeedbackResponseSubmissionRequest submitRequest = getAndValidateRequestBody(FeedbackResponseSubmissionRequest.class);\n+\n+        for (String recipient : submitRequest.getRecipients()) {\n+            if (!recipientsOfTheQuestion.containsKey(recipient)) {\n+                throw new UnauthorizedAccessException(\"The recipient is not a valid recipient of the question\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public ActionResult execute() {\n+        String feedbackQuestionId = getNonNullRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_ID);\n+        FeedbackQuestionAttributes feedbackQuestion = logic.getFeedbackQuestion(feedbackQuestionId);\n+        if (feedbackQuestion == null) {\n+            throw new EntityNotFoundException(new EntityDoesNotExistException(\"The feedback question does not exist.\"));\n+        }\n+\n+        FeedbackResponseSubmissionRequest submitRequest = getAndValidateRequestBody(FeedbackResponseSubmissionRequest.class);\n+\n+        if (submitRequest.getResponseDetailsPerRecipient().isEmpty()) {\n+            logic.deleteFeedbackResponsesForQuestion(feedbackQuestionId);\n+            return new JsonResult(new FeedbackResponsesData(new ArrayList<>()));\n+        }\n+\n+        List<FeedbackResponseAttributes> existingResponses;\n+\n+        String giverIdentifier;\n+        String giverSection;\n+        Intent intent = Intent.valueOf(getNonNullRequestParamValue(Const.ParamsNames.INTENT));\n+        switch (intent) {\n+        case STUDENT_SUBMISSION:\n+            StudentAttributes studentAttributes = getStudentOfCourseFromRequest(feedbackQuestion.getCourseId());\n+            giverIdentifier =\n+                    feedbackQuestion.getGiverType() == FeedbackParticipantType.TEAMS\n+                            ? studentAttributes.getTeam() : studentAttributes.getEmail();\n+            giverSection = studentAttributes.getSection();\n+            existingResponses = logic.getFeedbackResponsesFromStudentOrTeamForQuestion(feedbackQuestion, studentAttributes);\n+            logic.populateFieldsToGenerateInQuestion(feedbackQuestion,\n+                    studentAttributes.getEmail(), studentAttributes.getTeam());\n+            break;\n+        case INSTRUCTOR_SUBMISSION:\n+            InstructorAttributes instructorAttributes = getInstructorOfCourseFromRequest(feedbackQuestion.getCourseId());\n+            giverIdentifier = instructorAttributes.getEmail();\n+            giverSection = Const.DEFAULT_SECTION;\n+            existingResponses = logic.getFeedbackResponsesFromInstructorForQuestion(feedbackQuestion, instructorAttributes);\n+            logic.populateFieldsToGenerateInQuestion(feedbackQuestion,\n+                    instructorAttributes.getEmail(), null);\n+            break;\n+        default:\n+            throw new InvalidHttpParameterException(\"Unknown intent \" + intent);\n+        }\n+\n+        Map<String, FeedbackResponseAttributes> existingResponsesPerRecipient = new HashMap<>();\n+        existingResponses.forEach(response -> existingResponsesPerRecipient.put(response.getRecipient(), response));\n+        Map<String, FeedbackResponseDetails> responseDetailsPerRecipient = submitRequest.getResponseDetailsPerRecipient();\n+        List<FeedbackResponseAttributes> feedbackResponsesToValidate = new ArrayList<>();\n+        List<FeedbackResponseAttributes> feedbackResponsesToAdd = new ArrayList<>();\n+        List<FeedbackResponseAttributes.UpdateOptions> feedbackResponsesToUpdate = new ArrayList<>();\n+\n+        responseDetailsPerRecipient.forEach((recipient, responseDetails) -> {\n+            if (existingResponsesPerRecipient.containsKey(recipient)) {\n+                FeedbackResponseAttributes feedbackResponse = existingResponsesPerRecipient.get(recipient);\n+                feedbackResponse.giver = giverIdentifier;\n+                feedbackResponse.giverSection = giverSection;\n+                feedbackResponse.recipient = recipient;\n+                feedbackResponse.recipientSection =\n+                        getRecipientSection(feedbackQuestion.getCourseId(), feedbackQuestion.getGiverType(),\n+                                feedbackQuestion.getRecipientType(), recipient);\n+                feedbackResponse.responseDetails = responseDetails;\n+\n+                feedbackResponsesToValidate.add(feedbackResponse);\n+                feedbackResponsesToUpdate.add(FeedbackResponseAttributes.updateOptionsBuilder(feedbackResponse.getId())\n+                        .withGiver(feedbackResponse.giver)\n+                        .withGiverSection(feedbackResponse.giverSection)\n+                        .withRecipient(feedbackResponse.recipient)\n+                        .withRecipientSection(feedbackResponse.recipientSection)\n+                        .withResponseDetails(feedbackResponse.getResponseDetails())\n+                        .build());\n+            } else {\n+                FeedbackResponseAttributes feedbackResponse = FeedbackResponseAttributes\n+                        .builder(feedbackQuestion.getId(), giverIdentifier, recipient)\n+                        .withGiverSection(giverSection)\n+                        .withRecipientSection(getRecipientSection(feedbackQuestion.getCourseId(),\n+                                feedbackQuestion.getGiverType(),\n+                                feedbackQuestion.getRecipientType(), recipient))\n+                        .withCourseId(feedbackQuestion.getCourseId())\n+                        .withFeedbackSessionName(feedbackQuestion.getFeedbackSessionName())\n+                        .withResponseDetails(responseDetails)\n+                        .build();\n+\n+                feedbackResponsesToValidate.add(feedbackResponse);\n+                feedbackResponsesToAdd.add(feedbackResponse);\n+            }\n+        });\n+\n+        validateResponsesOfQuestion(feedbackQuestion, feedbackResponsesToValidate);\n+\n+        List<FeedbackResponseAttributes> feedbackResponsesToDelete = existingResponsesPerRecipient.entrySet().stream()\n+                .filter(entry -> !responseDetailsPerRecipient.containsKey(entry.getKey()))\n+                .map(entry -> entry.getValue())\n+                .collect(Collectors.toList());\n+\n+        for (FeedbackResponseAttributes feedbackResponse : feedbackResponsesToDelete) {\n+            logic.deleteFeedbackResponseCascade(feedbackResponse.getId());\n+        }\n+\n+        List<FeedbackResponseAttributes> output = new ArrayList<>();\n+\n+        for (FeedbackResponseAttributes feedbackResponse : feedbackResponsesToAdd) {\n+            try {\n+                FeedbackResponseAttributes createdFeedbackResponse = logic.createFeedbackResponse(feedbackResponse);\n+                createdFeedbackResponse.setId(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f62b8a9c292098a107ded00b1ad2a16f7757a3ae"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg2MzY2MQ==", "bodyText": "I would add comment\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  newAnswer[subQuestionIndex] = RUBRIC_ANSWER_NOT_CHOSEN;\n          \n          \n            \n                  // select the same answer, toggle as unselected\n          \n          \n            \n                  newAnswer[subQuestionIndex] = RUBRIC_ANSWER_NOT_CHOSEN;", "url": "https://github.com/TEAMMATES/teammates/pull/10620#discussion_r471863661", "createdAt": "2020-08-18T01:35:53Z", "author": {"login": "xpdavid"}, "path": "src/web/app/components/question-types/question-edit-answer-form/rubric-question-edit-answer-form.component.ts", "diffHunk": "@@ -48,7 +48,11 @@ export class RubricQuestionEditAnswerFormComponent extends QuestionEditAnswerFor\n       newAnswer = Array(this.questionDetails.numOfRubricSubQuestions).fill(RUBRIC_ANSWER_NOT_CHOSEN);\n     }\n \n-    newAnswer[subQuestionIndex] = answerIndex;\n+    if (newAnswer[subQuestionIndex] === answerIndex) {\n+      newAnswer[subQuestionIndex] = RUBRIC_ANSWER_NOT_CHOSEN;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2abcbde20255b3785f709a0ce8f6b94f5bafb65e"}, "originalPosition": 6}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eaffa4e01ea6173cc160d76c603c4bb4cd9a6cec", "author": {"user": {"login": "wkurniawan07", "name": "Wilson Kurniawan"}}, "url": "https://github.com/TEAMMATES/teammates/commit/eaffa4e01ea6173cc160d76c603c4bb4cd9a6cec", "committedDate": "2020-08-17T22:20:24Z", "message": "Add more rounding off and change modulo operator"}, "afterCommit": {"oid": "08fe25f6e8104067b7da66c7257d11f114feecb9", "author": {"user": {"login": "wkurniawan07", "name": "Wilson Kurniawan"}}, "url": "https://github.com/TEAMMATES/teammates/commit/08fe25f6e8104067b7da66c7257d11f114feecb9", "committedDate": "2020-08-18T10:57:34Z", "message": "Add more rounding off and change modulo operator"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcwMDgwNDEx", "url": "https://github.com/TEAMMATES/teammates/pull/10620#pullrequestreview-470080411", "createdAt": "2020-08-19T02:22:33Z", "commit": {"oid": "08fe25f6e8104067b7da66c7257d11f114feecb9"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "08fe25f6e8104067b7da66c7257d11f114feecb9", "author": {"user": {"login": "wkurniawan07", "name": "Wilson Kurniawan"}}, "url": "https://github.com/TEAMMATES/teammates/commit/08fe25f6e8104067b7da66c7257d11f114feecb9", "committedDate": "2020-08-18T10:57:34Z", "message": "Add more rounding off and change modulo operator"}, "afterCommit": {"oid": "0410f21870508c1c73a88d2a56d5e17da8d35cde", "author": {"user": {"login": "wkurniawan07", "name": "Wilson Kurniawan"}}, "url": "https://github.com/TEAMMATES/teammates/commit/0410f21870508c1c73a88d2a56d5e17da8d35cde", "committedDate": "2020-08-19T02:55:47Z", "message": "Add more rounding off and change modulo operator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f55106d86128f0407170fbe3d17731138a47e9b", "author": {"user": {"login": "wkurniawan07", "name": "Wilson Kurniawan"}}, "url": "https://github.com/TEAMMATES/teammates/commit/7f55106d86128f0407170fbe3d17731138a47e9b", "committedDate": "2020-08-19T13:43:41Z", "message": "Move question type-specific response validation to QuestionDetails class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "493f03e67f79d63e95075d5326d07303c3cf2526", "author": {"user": {"login": "wkurniawan07", "name": "Wilson Kurniawan"}}, "url": "https://github.com/TEAMMATES/teammates/commit/493f03e67f79d63e95075d5326d07303c3cf2526", "committedDate": "2020-08-19T13:43:41Z", "message": "Add logic method to delete all feedback responses for a question"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3877b4f05ae8fc6ab4586a479af540c1ae57df41", "author": {"user": {"login": "wkurniawan07", "name": "Wilson Kurniawan"}}, "url": "https://github.com/TEAMMATES/teammates/commit/3877b4f05ae8fc6ab4586a479af540c1ae57df41", "committedDate": "2020-08-19T14:09:18Z", "message": "Unify API to submit session response per question"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3fe9401df6029a0633422883044b3d5ce9a9bcce", "author": {"user": {"login": "wkurniawan07", "name": "Wilson Kurniawan"}}, "url": "https://github.com/TEAMMATES/teammates/commit/3fe9401df6029a0633422883044b3d5ce9a9bcce", "committedDate": "2020-08-19T14:09:18Z", "message": "Add question-wide validation for constsum and rank recipient"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d8a85416c8d4e8b1d2675cb319b5b4534e97a099", "author": {"user": {"login": "wkurniawan07", "name": "Wilson Kurniawan"}}, "url": "https://github.com/TEAMMATES/teammates/commit/d8a85416c8d4e8b1d2675cb319b5b4534e97a099", "committedDate": "2020-08-19T14:09:18Z", "message": "Edit front-end to use new API endpoint structure"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fcf501d7fee27e61c7faf3dba6523b773020c6c3", "author": {"user": {"login": "wkurniawan07", "name": "Wilson Kurniawan"}}, "url": "https://github.com/TEAMMATES/teammates/commit/fcf501d7fee27e61c7faf3dba6523b773020c6c3", "committedDate": "2020-08-19T14:09:18Z", "message": "Remove usage of numOfConstSumOptions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47cdc195178d49a4f4e69bd1eef51fa8463572d2", "author": {"user": {"login": "wkurniawan07", "name": "Wilson Kurniawan"}}, "url": "https://github.com/TEAMMATES/teammates/commit/47cdc195178d49a4f4e69bd1eef51fa8463572d2", "committedDate": "2020-08-19T14:10:51Z", "message": "Display only points per recipient for constsum recipient additional info"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1634f374a08942a007d66325deac7a53be3bfa3", "author": {"user": {"login": "wkurniawan07", "name": "Wilson Kurniawan"}}, "url": "https://github.com/TEAMMATES/teammates/commit/a1634f374a08942a007d66325deac7a53be3bfa3", "committedDate": "2020-08-19T14:10:51Z", "message": "Allow erasing of answers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e293894d0c401854a076bdb139f169e5707e6dc5", "author": {"user": {"login": "wkurniawan07", "name": "Wilson Kurniawan"}}, "url": "https://github.com/TEAMMATES/teammates/commit/e293894d0c401854a076bdb139f169e5707e6dc5", "committedDate": "2020-08-19T14:10:51Z", "message": "Add more rounding off and change modulo operator"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0410f21870508c1c73a88d2a56d5e17da8d35cde", "author": {"user": {"login": "wkurniawan07", "name": "Wilson Kurniawan"}}, "url": "https://github.com/TEAMMATES/teammates/commit/0410f21870508c1c73a88d2a56d5e17da8d35cde", "committedDate": "2020-08-19T02:55:47Z", "message": "Add more rounding off and change modulo operator"}, "afterCommit": {"oid": "e293894d0c401854a076bdb139f169e5707e6dc5", "author": {"user": {"login": "wkurniawan07", "name": "Wilson Kurniawan"}}, "url": "https://github.com/TEAMMATES/teammates/commit/e293894d0c401854a076bdb139f169e5707e6dc5", "committedDate": "2020-08-19T14:10:51Z", "message": "Add more rounding off and change modulo operator"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxMzAzNDc0", "url": "https://github.com/TEAMMATES/teammates/pull/10620#pullrequestreview-471303474", "createdAt": "2020-08-20T07:11:37Z", "commit": {"oid": "e293894d0c401854a076bdb139f169e5707e6dc5"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da5e0581b797dd509ab1900787a4bd4edbdb3544", "author": {"user": {"login": "wkurniawan07", "name": "Wilson Kurniawan"}}, "url": "https://github.com/TEAMMATES/teammates/commit/da5e0581b797dd509ab1900787a4bd4edbdb3544", "committedDate": "2020-08-20T10:55:56Z", "message": "Merge branch 'master' into 10397-question-wide-validation"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4241, "cost": 1, "resetAt": "2021-11-02T12:20:56Z"}}}