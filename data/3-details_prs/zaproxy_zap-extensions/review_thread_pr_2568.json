{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAxMTQwMDg4", "number": 2568, "reviewThreads": {"totalCount": 27, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDoxMToxMFrOEsb8cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxNToyNDoyMFrOEw0hsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MDMwNjQyOnYy", "diffSide": "RIGHT", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDoxMToxMFrOHfrzlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDoyOTo1OFrOHiY1hA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTYyMg==", "bodyText": "Remove, no longer necessary.", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502985622", "createdAt": "2020-10-12T00:11:10Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyMDU0OA==", "bodyText": "Updated.", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505820548", "createdAt": "2020-10-15T20:29:58Z", "author": {"login": "ejayaraman"}, "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTYyMg=="}, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MDMwNjU1OnYy", "diffSide": "RIGHT", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDoxMToyNlrOHfrzqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDozMDoxNFrOHiY2Pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTY0Mw==", "bodyText": "Go for it \ud83d\ude00", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502985643", "createdAt": "2020-10-12T00:11:26Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyMDczNA==", "bodyText": "Doc comments included.", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505820734", "createdAt": "2020-10-15T20:30:14Z", "author": {"login": "ejayaraman"}, "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTY0Mw=="}, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MDMwNzI4OnYy", "diffSide": "RIGHT", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDoxMjowOVrOHfr0Bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDozMzoyMlrOHiZAKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTczNQ==", "bodyText": "The blank and comment can be removed, it's in a separate method now, it obviously related to LFI.", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502985735", "createdAt": "2020-10-12T00:12:09Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyMzI3Mg==", "bodyText": "This has been updated.", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505823272", "createdAt": "2020-10-15T20:33:22Z", "author": {"login": "ejayaraman"}, "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTczNQ=="}, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MDMwNzg1OnYy", "diffSide": "RIGHT", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDoxMjo1MlrOHfr0WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDoxMjo1MlrOHfr0WQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTgxNw==", "bodyText": "These blanks and comment are no longer necessary.", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502985817", "createdAt": "2020-10-12T00:12:52Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MDMwNzg5OnYy", "diffSide": "RIGHT", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDoxMjo1OVrOHfr0YA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDozMzo1NlrOHiZCBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTgyNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502985824", "createdAt": "2020-10-12T00:12:59Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyMzc0OA==", "bodyText": "This is the one I forgot to remove. I can push another commit for this.", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505823748", "createdAt": "2020-10-15T20:33:56Z", "author": {"login": "ejayaraman"}, "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTgyNA=="}, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MDMwODQxOnYy", "diffSide": "RIGHT", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDoxMzozM1rOHfr0nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDoxMzozM1rOHfr0nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTg4Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            // Check if the scan has been stopped\n          \n          \n            \n                            // if yes dispose resources and exit", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502985887", "createdAt": "2020-10-12T00:13:33Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 164}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MDMwODU1OnYy", "diffSide": "RIGHT", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDoxMzo0MlrOHfr0sQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDoxMzo0MlrOHfr0sQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTkwNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                // Dispose all resources", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502985905", "createdAt": "2020-10-12T00:13:42Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 166}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MDMwOTAxOnYy", "diffSide": "RIGHT", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDoxNDowMFrOHfr06g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDozNDoyNlrOHiZDmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTk2Mg==", "bodyText": "Go for it.", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502985962", "createdAt": "2020-10-12T00:14:00Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources\n+                    // Exit the rule\n+                    return;\n+                }\n             }\n+\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n+\n+    // TODO: Add Doc Comments", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyNDE1NQ==", "bodyText": "Doc comments added.", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505824155", "createdAt": "2020-10-15T20:34:26Z", "author": {"login": "ejayaraman"}, "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources\n+                    // Exit the rule\n+                    return;\n+                }\n             }\n+\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n+\n+    // TODO: Add Doc Comments", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTk2Mg=="}, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 181}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MDMwOTQ1OnYy", "diffSide": "RIGHT", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDoxNDozN1rOHfr1JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDozNDo1OFrOHiZFkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjAyMQ==", "bodyText": "Can be private. Will explain further while commenting on the other class.", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986021", "createdAt": "2020-10-12T00:14:37Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyNDY1OQ==", "bodyText": "This is private now, as the tests are using the scan() method.", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505824659", "createdAt": "2020-10-15T20:34:58Z", "author": {"login": "ejayaraman"}, "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjAyMQ=="}, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MDMxMDc3OnYy", "diffSide": "RIGHT", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDoxNToyNFrOHfr1tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDoxNToyNFrOHfr1tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjE2Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            // msg = getNewMsg();", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986166", "createdAt": "2020-10-12T00:15:24Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources\n+                    // Exit the rule\n+                    return;\n+                }\n             }\n+\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n+\n+    // TODO: Add Doc Comments\n+    protected void localFileInclusionAttack(HttpMessage msg) {\n+        String localFile;\n+        String response;\n+        Matcher matcher;\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                // msg = getNewMsg();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 192}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MDMxMDg0OnYy", "diffSide": "RIGHT", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDoxNTozNlrOHfr1xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDoxNTozNlrOHfr1xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjE4Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n                            // Send message with local file inclusion", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986183", "createdAt": "2020-10-12T00:15:36Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources\n+                    // Exit the rule\n+                    return;\n+                }\n             }\n+\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n+\n+    // TODO: Add Doc Comments\n+    protected void localFileInclusionAttack(HttpMessage msg) {\n+        String localFile;\n+        String response;\n+        Matcher matcher;\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 195}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MDMxMTExOnYy", "diffSide": "RIGHT", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDoxNTo1MFrOHfr16A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDoxNTo1MFrOHfr16A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjIxNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n                            // Parse the result", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986216", "createdAt": "2020-10-12T00:15:50Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources\n+                    // Exit the rule\n+                    return;\n+                }\n             }\n+\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n+\n+    // TODO: Add Doc Comments\n+    protected void localFileInclusionAttack(HttpMessage msg) {\n+        String localFile;\n+        String response;\n+        Matcher matcher;\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 199}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MDMxMTE4OnYy", "diffSide": "RIGHT", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDoxNTo1N1rOHfr18w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDo0MDoxNlrOHiZV3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjIyNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986227", "createdAt": "2020-10-12T00:15:57Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources\n+                    // Exit the rule\n+                    return;\n+                }\n             }\n+\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n+\n+    // TODO: Add Doc Comments\n+    protected void localFileInclusionAttack(HttpMessage msg) {\n+        String localFile;\n+        String response;\n+        Matcher matcher;\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyODgzMQ==", "bodyText": "And another one to remove.", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505828831", "createdAt": "2020-10-15T20:40:16Z", "author": {"login": "ejayaraman"}, "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources\n+                    // Exit the rule\n+                    return;\n+                }\n             }\n+\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n+\n+    // TODO: Add Doc Comments\n+    protected void localFileInclusionAttack(HttpMessage msg) {\n+        String localFile;\n+        String response;\n+        Matcher matcher;\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjIyNw=="}, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 203}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MDMxMTU3OnYy", "diffSide": "RIGHT", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDoxNjoxN1rOHfr2Jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDoxNjoxN1rOHfr2Jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjI3OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n                            // Check if the scan has been stopped\n          \n          \n            \n                            // if yes dispose resources and exit\n          \n          \n            \n                            // Check if the scan has been stopped", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986278", "createdAt": "2020-10-12T00:16:17Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources\n+                    // Exit the rule\n+                    return;\n+                }\n             }\n+\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n+\n+    // TODO: Add Doc Comments\n+    protected void localFileInclusionAttack(HttpMessage msg) {\n+        String localFile;\n+        String response;\n+        Matcher matcher;\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 213}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MDMxMTYxOnYy", "diffSide": "RIGHT", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDoxNjoyNlrOHfr2MQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDoxNjoyNlrOHfr2MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjI4OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                // Dispose all resources", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986289", "createdAt": "2020-10-12T00:16:26Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources\n+                    // Exit the rule\n+                    return;\n+                }\n             }\n+\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n+\n+    // TODO: Add Doc Comments\n+    protected void localFileInclusionAttack(HttpMessage msg) {\n+        String localFile;\n+        String response;\n+        Matcher matcher;\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 215}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MDMxMTg4OnYy", "diffSide": "RIGHT", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDoxNjo0NlrOHfr2VA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDoxNjo0NlrOHfr2VA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjMyNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986324", "createdAt": "2020-10-12T00:16:46Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources\n+                    // Exit the rule\n+                    return;\n+                }\n             }\n+\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n+\n+    // TODO: Add Doc Comments\n+    protected void localFileInclusionAttack(HttpMessage msg) {\n+        String localFile;\n+        String response;\n+        Matcher matcher;\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources\n+                    // Exit the rule\n+                    return;\n+                }\n+            }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 220}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MDMxMzAwOnYy", "diffSide": "RIGHT", "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDoxODoxNFrOHfr27g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDoxODo0MFrOHiYbog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjQ3OA==", "bodyText": "This seems to be used over and over again, It may as well be extracted to a local method, such as createNanoHandler. Then just used as this.nano.addHandler(createHandler());", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986478", "createdAt": "2020-10-12T00:18:14Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgxMzkyMg==", "bodyText": "A local method has been created: createNanoHandler", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505813922", "createdAt": "2020-10-15T20:18:40Z", "author": {"login": "ejayaraman"}, "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjQ3OA=="}, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MDMxMzQ0OnYy", "diffSide": "RIGHT", "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDoxODo1N1rOHfr3MQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDoxODo1N1rOHfr3MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjU0NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986545", "createdAt": "2020-10-12T00:18:57Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MDMxMzYwOnYy", "diffSide": "RIGHT", "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDoxOTowNlrOHfr3Qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDoxOTowNlrOHfr3Qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjU2Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986562", "createdAt": "2020-10-12T00:19:06Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MDMxMzgxOnYy", "diffSide": "RIGHT", "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDoxOToxOVrOHfr3Wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDoxOToxOVrOHfr3Wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjU4Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986586", "createdAt": "2020-10-12T00:19:19Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.scan();\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MDMxNDcyOnYy", "diffSide": "RIGHT", "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDoyMDowNlrOHfr3zA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDoxODo1OVrOHiYcVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjcwMA==", "bodyText": "The blanks leading // When and // Then throughout can be removed, the comments already delineate things.", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986700", "createdAt": "2020-10-12T00:20:06Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.scan();\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(0));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgxNDEwMQ==", "bodyText": "This has been removed now.", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505814101", "createdAt": "2020-10-15T20:18:59Z", "author": {"login": "ejayaraman"}, "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.scan();\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(0));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjcwMA=="}, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MDMxNTgzOnYy", "diffSide": "RIGHT", "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDoyMToyNVrOHfr4XQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDoxOTozNlrOHiYddA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4Njg0NQ==", "bodyText": "Is this an intentional mismatch?", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986845", "createdAt": "2020-10-12T00:21:25Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgxNDM4OA==", "bodyText": "yes, it is. I have added a comment in the test to explain this mismatch.", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505814388", "createdAt": "2020-10-15T20:19:36Z", "author": {"login": "ejayaraman"}, "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4Njg0NQ=="}, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MDMxODg2OnYy", "diffSide": "RIGHT", "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDoyNDo1MVrOHfr54w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDoyMDowNFrOHiYeXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NzIzNQ==", "bodyText": "Throughout the new tests the scan method should be used. That ensures none of the payloads are misinterpreted.\nHowever, having the two test methods broken out in the scan rule allows for earlier troubleshooting and maintenance in the future so that was a worthy change (IMHO).", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502987235", "createdAt": "2020-10-12T00:24:51Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.scan();\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(0));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgxNDYyMw==", "bodyText": "Tests have been updated to use the scan method.", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505814623", "createdAt": "2020-10-15T20:20:04Z", "author": {"login": "ejayaraman"}, "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.scan();\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(0));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NzIzNQ=="}, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MDMxOTg1OnYy", "diffSide": "RIGHT", "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDoyNTozOFrOHfr6Vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDoyMDoyNVrOHiYfCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NzM1MQ==", "bodyText": "The number of messages sent should already be being tested as part of the generalized Strength tests.\nEdit: So I believe this one can be removed.", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502987351", "createdAt": "2020-10-12T00:25:38Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.scan();\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(0));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgxNDc5NQ==", "bodyText": "This has been removed.", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505814795", "createdAt": "2020-10-15T20:20:25Z", "author": {"login": "ejayaraman"}, "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.scan();\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(0));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NzM1MQ=="}, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MDMyMjY1OnYy", "diffSide": "RIGHT", "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDoyODoyN1rOHfr72Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDoyMDo0NFrOHiYfxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NzczNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n          \n          \n            \n                    assertThat(\n          \n          \n            \n                            alertsRaised.get(0).getAttack(),\n          \n          \n            \n                            equalTo(\n          \n          \n            \n                                    MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n          \n          \n            \n                                            + XxeScanRule.ATTACK_BODY));\n          \n          \n            \n                    assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n          \n          \n            \n                    assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n          \n          \n            \n                    Alert alert = alertsRaised.get(0);\n          \n          \n            \n                    assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n          \n          \n            \n                    assertThat(\n          \n          \n            \n                            alert.getAttack(),\n          \n          \n            \n                            equalTo(\n          \n          \n            \n                                    MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n          \n          \n            \n                                            + XxeScanRule.ATTACK_BODY));\n          \n          \n            \n                    assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n          \n          \n            \n                    assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n          \n      \n    \n    \n  \n\nThis likely applies elsewhere as well.", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502987737", "createdAt": "2020-10-12T00:28:27Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.scan();\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(0));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(3));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n+            throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        parent.stop();\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(alertsRaised.size(), equalTo(1));\n+        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(\n+                alertsRaised.get(0).getAttack(),\n+                equalTo(\n+                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                                + \"<comment><text>&zapxxe;</text></comment>\"));\n+        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    @Test\n+    public void shouldStopLocalFileReflectionRuleIfScanIsStopped() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        parent.stop();\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(1));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileInclusionRule() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileInclusionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(3));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+            throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response = \"root:*:0:0:System Administrator:/var/root:/bin/sh\";\n+                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileInclusionAttack(msg);\n+\n+        // Then\n+        assertThat(alertsRaised.size(), equalTo(1));\n+        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(\n+                alertsRaised.get(0).getAttack(),\n+                equalTo(\n+                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                                + XxeScanRule.ATTACK_BODY));\n+        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgxNDk4MQ==", "bodyText": "This has been updated as well.", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505814981", "createdAt": "2020-10-15T20:20:44Z", "author": {"login": "ejayaraman"}, "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.scan();\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(0));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(3));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n+            throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        parent.stop();\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(alertsRaised.size(), equalTo(1));\n+        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(\n+                alertsRaised.get(0).getAttack(),\n+                equalTo(\n+                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                                + \"<comment><text>&zapxxe;</text></comment>\"));\n+        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    @Test\n+    public void shouldStopLocalFileReflectionRuleIfScanIsStopped() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        parent.stop();\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(1));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileInclusionRule() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileInclusionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(3));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+            throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response = \"root:*:0:0:System Administrator:/var/root:/bin/sh\";\n+                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileInclusionAttack(msg);\n+\n+        // Then\n+        assertThat(alertsRaised.size(), equalTo(1));\n+        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(\n+                alertsRaised.get(0).getAttack(),\n+                equalTo(\n+                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                                + XxeScanRule.ATTACK_BODY));\n+        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NzczNw=="}, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 218}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MDMyNjYxOnYy", "diffSide": "RIGHT", "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDozMjo1NlrOHfr97Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMjowNjozM1rOHp_SEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4ODI2OQ==", "bodyText": "This test is an interesting idea, however, I'm not sure it'll behave properly if When is rule.scan and parent.stop() was issued in Given.\n@thc202? @psiinon?", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502988269", "createdAt": "2020-10-12T00:32:56Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.scan();\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(0));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(3));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n+            throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        parent.stop();\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(alertsRaised.size(), equalTo(1));\n+        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(\n+                alertsRaised.get(0).getAttack(),\n+                equalTo(\n+                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                                + \"<comment><text>&zapxxe;</text></comment>\"));\n+        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    @Test\n+    public void shouldStopLocalFileReflectionRuleIfScanIsStopped() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        parent.stop();\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(1));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileInclusionRule() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileInclusionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(3));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+            throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response = \"root:*:0:0:System Administrator:/var/root:/bin/sh\";\n+                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileInclusionAttack(msg);\n+\n+        // Then\n+        assertThat(alertsRaised.size(), equalTo(1));\n+        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(\n+                alertsRaised.get(0).getAttack(),\n+                equalTo(\n+                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                                + XxeScanRule.ATTACK_BODY));\n+        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    @Test\n+    public void shouldStopLocalFileInclusionRuleIfScanIsStopped() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        parent.stop();\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileInclusionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(1));\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyMDIxMA==", "bodyText": "This test did started failing after using rule.scan(), but not sure if it is for the same reason you had in mind. The reason it started failing for me was: since localFileInclusionAttack and localFileReflectionAttack has been moved to its own methods, return, when parent.stop() is true, exits only that method and not the scan itself. So I have added another check within the scan() method between attacks to stop scanning when parent.stop() is invoked. This fixed the test.", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505820210", "createdAt": "2020-10-15T20:29:32Z", "author": {"login": "ejayaraman"}, "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.scan();\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(0));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(3));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n+            throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        parent.stop();\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(alertsRaised.size(), equalTo(1));\n+        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(\n+                alertsRaised.get(0).getAttack(),\n+                equalTo(\n+                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                                + \"<comment><text>&zapxxe;</text></comment>\"));\n+        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    @Test\n+    public void shouldStopLocalFileReflectionRuleIfScanIsStopped() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        parent.stop();\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(1));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileInclusionRule() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileInclusionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(3));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+            throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response = \"root:*:0:0:System Administrator:/var/root:/bin/sh\";\n+                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileInclusionAttack(msg);\n+\n+        // Then\n+        assertThat(alertsRaised.size(), equalTo(1));\n+        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(\n+                alertsRaised.get(0).getAttack(),\n+                equalTo(\n+                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                                + XxeScanRule.ATTACK_BODY));\n+        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    @Test\n+    public void shouldStopLocalFileInclusionRuleIfScanIsStopped() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        parent.stop();\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileInclusionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(1));\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4ODI2OQ=="}, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI1MDQzMw==", "bodyText": "I'm not sure we should add it as is, if the scanner is already stopped the scan rule would not have been called (it could happen immediately after but it's less likely than when actually running), better to test that the stop is respected by stopping while running (i.e. in the several loops that it might have).", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r510250433", "createdAt": "2020-10-22T15:22:33Z", "author": {"login": "thc202"}, "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.scan();\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(0));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(3));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n+            throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        parent.stop();\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(alertsRaised.size(), equalTo(1));\n+        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(\n+                alertsRaised.get(0).getAttack(),\n+                equalTo(\n+                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                                + \"<comment><text>&zapxxe;</text></comment>\"));\n+        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    @Test\n+    public void shouldStopLocalFileReflectionRuleIfScanIsStopped() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        parent.stop();\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(1));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileInclusionRule() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileInclusionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(3));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+            throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response = \"root:*:0:0:System Administrator:/var/root:/bin/sh\";\n+                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileInclusionAttack(msg);\n+\n+        // Then\n+        assertThat(alertsRaised.size(), equalTo(1));\n+        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(\n+                alertsRaised.get(0).getAttack(),\n+                equalTo(\n+                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                                + XxeScanRule.ATTACK_BODY));\n+        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    @Test\n+    public void shouldStopLocalFileInclusionRuleIfScanIsStopped() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        parent.stop();\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileInclusionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(1));\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4ODI2OQ=="}, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI1MzAxOA==", "bodyText": "This is probably something that can be added as part of the common tests.", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r510253018", "createdAt": "2020-10-22T15:25:45Z", "author": {"login": "thc202"}, "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.scan();\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(0));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(3));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n+            throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        parent.stop();\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(alertsRaised.size(), equalTo(1));\n+        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(\n+                alertsRaised.get(0).getAttack(),\n+                equalTo(\n+                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                                + \"<comment><text>&zapxxe;</text></comment>\"));\n+        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    @Test\n+    public void shouldStopLocalFileReflectionRuleIfScanIsStopped() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        parent.stop();\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(1));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileInclusionRule() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileInclusionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(3));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+            throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response = \"root:*:0:0:System Administrator:/var/root:/bin/sh\";\n+                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileInclusionAttack(msg);\n+\n+        // Then\n+        assertThat(alertsRaised.size(), equalTo(1));\n+        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(\n+                alertsRaised.get(0).getAttack(),\n+                equalTo(\n+                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                                + XxeScanRule.ATTACK_BODY));\n+        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    @Test\n+    public void shouldStopLocalFileInclusionRuleIfScanIsStopped() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        parent.stop();\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileInclusionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(1));\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4ODI2OQ=="}, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI1NTIwMg==", "bodyText": "For the time being lets just leave the stop testing out for now. It would be nice to get this done/in. Stop testing will require further unrelated changes.", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r510255202", "createdAt": "2020-10-22T15:28:38Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.scan();\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(0));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(3));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n+            throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        parent.stop();\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(alertsRaised.size(), equalTo(1));\n+        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(\n+                alertsRaised.get(0).getAttack(),\n+                equalTo(\n+                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                                + \"<comment><text>&zapxxe;</text></comment>\"));\n+        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    @Test\n+    public void shouldStopLocalFileReflectionRuleIfScanIsStopped() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        parent.stop();\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(1));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileInclusionRule() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileInclusionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(3));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+            throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response = \"root:*:0:0:System Administrator:/var/root:/bin/sh\";\n+                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileInclusionAttack(msg);\n+\n+        // Then\n+        assertThat(alertsRaised.size(), equalTo(1));\n+        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(\n+                alertsRaised.get(0).getAttack(),\n+                equalTo(\n+                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                                + XxeScanRule.ATTACK_BODY));\n+        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    @Test\n+    public void shouldStopLocalFileInclusionRuleIfScanIsStopped() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        parent.stop();\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileInclusionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(1));\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4ODI2OQ=="}, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk1NDUwMA==", "bodyText": "Sure. Will remove this test.", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r510954500", "createdAt": "2020-10-23T15:14:15Z", "author": {"login": "ejayaraman"}, "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.scan();\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(0));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(3));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n+            throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        parent.stop();\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(alertsRaised.size(), equalTo(1));\n+        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(\n+                alertsRaised.get(0).getAttack(),\n+                equalTo(\n+                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                                + \"<comment><text>&zapxxe;</text></comment>\"));\n+        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    @Test\n+    public void shouldStopLocalFileReflectionRuleIfScanIsStopped() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        parent.stop();\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(1));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileInclusionRule() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileInclusionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(3));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+            throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response = \"root:*:0:0:System Administrator:/var/root:/bin/sh\";\n+                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileInclusionAttack(msg);\n+\n+        // Then\n+        assertThat(alertsRaised.size(), equalTo(1));\n+        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(\n+                alertsRaised.get(0).getAttack(),\n+                equalTo(\n+                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                                + XxeScanRule.ATTACK_BODY));\n+        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    @Test\n+    public void shouldStopLocalFileInclusionRuleIfScanIsStopped() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        parent.stop();\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileInclusionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(1));\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4ODI2OQ=="}, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc5MDQ4MA==", "bodyText": "This test has been removed.", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r513790480", "createdAt": "2020-10-28T22:06:33Z", "author": {"login": "ejayaraman"}, "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.scan();\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(0));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(3));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n+            throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        parent.stop();\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(alertsRaised.size(), equalTo(1));\n+        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(\n+                alertsRaised.get(0).getAttack(),\n+                equalTo(\n+                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                                + \"<comment><text>&zapxxe;</text></comment>\"));\n+        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    @Test\n+    public void shouldStopLocalFileReflectionRuleIfScanIsStopped() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        parent.stop();\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(1));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileInclusionRule() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileInclusionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(3));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+            throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response = \"root:*:0:0:System Administrator:/var/root:/bin/sh\";\n+                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileInclusionAttack(msg);\n+\n+        // Then\n+        assertThat(alertsRaised.size(), equalTo(1));\n+        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(\n+                alertsRaised.get(0).getAttack(),\n+                equalTo(\n+                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                                + XxeScanRule.ATTACK_BODY));\n+        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    @Test\n+    public void shouldStopLocalFileInclusionRuleIfScanIsStopped() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        parent.stop();\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileInclusionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(1));\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4ODI2OQ=="}, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 248}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NjI3Njk5OnYy", "diffSide": "RIGHT", "path": "addOns/ascanrulesBeta/CHANGELOG.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxNToyNDoyMFrOHmnS_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMjowNjoxMlrOHp_RiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI1MTc3Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ## Unreleased\n          \n          \n            \n             - XML External Entity Attack scan rule updated to parse response body irrespective of the HTTP response status code. (Issue 6203) \n          \n          \n            \n            ## Unreleased\n          \n          \n            \n            ### Changed.\n          \n          \n            \n             - XML External Entity Attack scan rule updated to parse response body irrespective of the HTTP response status code. (Issue 6203)", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r510251772", "createdAt": "2020-10-22T15:24:20Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/CHANGELOG.md", "diffHunk": "@@ -4,6 +4,7 @@ All notable changes to this add-on will be documented in this file.\n The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/).\n \n ## Unreleased\n+ - XML External Entity Attack scan rule updated to parse response body irrespective of the HTTP response status code. (Issue 6203) ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29cf52d5bc300ca0f5729f0bb599771d725ed344"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc5MDM0NQ==", "bodyText": "This has been addressed.", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r513790345", "createdAt": "2020-10-28T22:06:12Z", "author": {"login": "ejayaraman"}, "path": "addOns/ascanrulesBeta/CHANGELOG.md", "diffHunk": "@@ -4,6 +4,7 @@ All notable changes to this add-on will be documented in this file.\n The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/).\n \n ## Unreleased\n+ - XML External Entity Attack scan rule updated to parse response body irrespective of the HTTP response status code. (Issue 6203) ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI1MTc3Mg=="}, "originalCommit": {"oid": "29cf52d5bc300ca0f5729f0bb599771d725ed344"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 679, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}