{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQyMzMwNDc2", "number": 2660, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxNTo0NzowMlrOFINHUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNFQxMToxMDoxOFrOFI6MsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MTQ3NzkyOnYy", "diffSide": "RIGHT", "path": "addOns/ascanrulesAlpha/src/main/java/org/zaproxy/zap/extension/ascanrulesAlpha/ForbiddenBypassScanRule.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxNTo0NzowMlrOIJ_tkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QxMDo1MToyNVrOIKhByQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1MTk1Mw==", "bodyText": "These should be removed.", "url": "https://github.com/zaproxy/zap-extensions/pull/2660#discussion_r547351953", "createdAt": "2020-12-22T15:47:02Z", "author": {"login": "thc202"}, "path": "addOns/ascanrulesAlpha/src/main/java/org/zaproxy/zap/extension/ascanrulesAlpha/ForbiddenBypassScanRule.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.extension.ascanrulesAlpha;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.httpclient.URI;\n+import org.apache.log4j.Logger;\n+import org.parosproxy.paros.Constant;\n+import org.parosproxy.paros.core.scanner.AbstractAppPlugin;\n+import org.parosproxy.paros.core.scanner.Alert;\n+import org.parosproxy.paros.core.scanner.Category;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.parosproxy.paros.network.HttpStatusCode;\n+\n+/**\n+ * Active scan rule which attempts various 403 bypass techniques.\n+ *\n+ * @author Aman Rawat (@theamanrawat)\n+ */\n+public class ForbiddenBypassScanRule extends AbstractAppPlugin {\n+\n+    private static final String MESSAGE_PREFIX = \"ascanalpha.forbiddenBypass.\";\n+    private static final Logger LOG = Logger.getLogger(ForbiddenBypassScanRule.class);\n+\n+    @Override\n+    public int getId() {\n+        return 40038;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return Constant.messages.getString(MESSAGE_PREFIX + \"name\");\n+    }\n+\n+    @Override\n+    public String getDescription() {\n+        return Constant.messages.getString(MESSAGE_PREFIX + \"desc\");\n+    }\n+\n+    @Override\n+    public void scan() {\n+        HttpMessage message = getNewMsg();\n+        try {\n+            sendAndReceive(message);\n+            if (message.getResponseHeader().getStatusCode() != HttpStatusCode.FORBIDDEN) {\n+                return;\n+            }\n+            URI uri = message.getRequestHeader().getURI();\n+            String host = uri.getEscapedAuthority();\n+            String path = uri.getEscapedPath();\n+            String schema = uri.getScheme();\n+            if (sendPathPayloads(path, host, schema, uri)) {\n+                return;\n+            }\n+            ;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9afe57d880176b650fb08bcb8daa2867940f5e8d"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg4MzcwNA==", "bodyText": "You mean parameters?", "url": "https://github.com/zaproxy/zap-extensions/pull/2660#discussion_r547883704", "createdAt": "2020-12-23T10:17:47Z", "author": {"login": "theamanrawat"}, "path": "addOns/ascanrulesAlpha/src/main/java/org/zaproxy/zap/extension/ascanrulesAlpha/ForbiddenBypassScanRule.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.extension.ascanrulesAlpha;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.httpclient.URI;\n+import org.apache.log4j.Logger;\n+import org.parosproxy.paros.Constant;\n+import org.parosproxy.paros.core.scanner.AbstractAppPlugin;\n+import org.parosproxy.paros.core.scanner.Alert;\n+import org.parosproxy.paros.core.scanner.Category;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.parosproxy.paros.network.HttpStatusCode;\n+\n+/**\n+ * Active scan rule which attempts various 403 bypass techniques.\n+ *\n+ * @author Aman Rawat (@theamanrawat)\n+ */\n+public class ForbiddenBypassScanRule extends AbstractAppPlugin {\n+\n+    private static final String MESSAGE_PREFIX = \"ascanalpha.forbiddenBypass.\";\n+    private static final Logger LOG = Logger.getLogger(ForbiddenBypassScanRule.class);\n+\n+    @Override\n+    public int getId() {\n+        return 40038;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return Constant.messages.getString(MESSAGE_PREFIX + \"name\");\n+    }\n+\n+    @Override\n+    public String getDescription() {\n+        return Constant.messages.getString(MESSAGE_PREFIX + \"desc\");\n+    }\n+\n+    @Override\n+    public void scan() {\n+        HttpMessage message = getNewMsg();\n+        try {\n+            sendAndReceive(message);\n+            if (message.getResponseHeader().getStatusCode() != HttpStatusCode.FORBIDDEN) {\n+                return;\n+            }\n+            URI uri = message.getRequestHeader().getURI();\n+            String host = uri.getEscapedAuthority();\n+            String path = uri.getEscapedPath();\n+            String schema = uri.getScheme();\n+            if (sendPathPayloads(path, host, schema, uri)) {\n+                return;\n+            }\n+            ;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1MTk1Mw=="}, "originalCommit": {"oid": "9afe57d880176b650fb08bcb8daa2867940f5e8d"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg4NDk2OQ==", "bodyText": "The semicolons (this and the other after the following if), it's not necessary.", "url": "https://github.com/zaproxy/zap-extensions/pull/2660#discussion_r547884969", "createdAt": "2020-12-23T10:20:38Z", "author": {"login": "thc202"}, "path": "addOns/ascanrulesAlpha/src/main/java/org/zaproxy/zap/extension/ascanrulesAlpha/ForbiddenBypassScanRule.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.extension.ascanrulesAlpha;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.httpclient.URI;\n+import org.apache.log4j.Logger;\n+import org.parosproxy.paros.Constant;\n+import org.parosproxy.paros.core.scanner.AbstractAppPlugin;\n+import org.parosproxy.paros.core.scanner.Alert;\n+import org.parosproxy.paros.core.scanner.Category;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.parosproxy.paros.network.HttpStatusCode;\n+\n+/**\n+ * Active scan rule which attempts various 403 bypass techniques.\n+ *\n+ * @author Aman Rawat (@theamanrawat)\n+ */\n+public class ForbiddenBypassScanRule extends AbstractAppPlugin {\n+\n+    private static final String MESSAGE_PREFIX = \"ascanalpha.forbiddenBypass.\";\n+    private static final Logger LOG = Logger.getLogger(ForbiddenBypassScanRule.class);\n+\n+    @Override\n+    public int getId() {\n+        return 40038;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return Constant.messages.getString(MESSAGE_PREFIX + \"name\");\n+    }\n+\n+    @Override\n+    public String getDescription() {\n+        return Constant.messages.getString(MESSAGE_PREFIX + \"desc\");\n+    }\n+\n+    @Override\n+    public void scan() {\n+        HttpMessage message = getNewMsg();\n+        try {\n+            sendAndReceive(message);\n+            if (message.getResponseHeader().getStatusCode() != HttpStatusCode.FORBIDDEN) {\n+                return;\n+            }\n+            URI uri = message.getRequestHeader().getURI();\n+            String host = uri.getEscapedAuthority();\n+            String path = uri.getEscapedPath();\n+            String schema = uri.getScheme();\n+            if (sendPathPayloads(path, host, schema, uri)) {\n+                return;\n+            }\n+            ;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1MTk1Mw=="}, "originalCommit": {"oid": "9afe57d880176b650fb08bcb8daa2867940f5e8d"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg5NzgwMQ==", "bodyText": "Done", "url": "https://github.com/zaproxy/zap-extensions/pull/2660#discussion_r547897801", "createdAt": "2020-12-23T10:51:25Z", "author": {"login": "theamanrawat"}, "path": "addOns/ascanrulesAlpha/src/main/java/org/zaproxy/zap/extension/ascanrulesAlpha/ForbiddenBypassScanRule.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.extension.ascanrulesAlpha;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.httpclient.URI;\n+import org.apache.log4j.Logger;\n+import org.parosproxy.paros.Constant;\n+import org.parosproxy.paros.core.scanner.AbstractAppPlugin;\n+import org.parosproxy.paros.core.scanner.Alert;\n+import org.parosproxy.paros.core.scanner.Category;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.parosproxy.paros.network.HttpStatusCode;\n+\n+/**\n+ * Active scan rule which attempts various 403 bypass techniques.\n+ *\n+ * @author Aman Rawat (@theamanrawat)\n+ */\n+public class ForbiddenBypassScanRule extends AbstractAppPlugin {\n+\n+    private static final String MESSAGE_PREFIX = \"ascanalpha.forbiddenBypass.\";\n+    private static final Logger LOG = Logger.getLogger(ForbiddenBypassScanRule.class);\n+\n+    @Override\n+    public int getId() {\n+        return 40038;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return Constant.messages.getString(MESSAGE_PREFIX + \"name\");\n+    }\n+\n+    @Override\n+    public String getDescription() {\n+        return Constant.messages.getString(MESSAGE_PREFIX + \"desc\");\n+    }\n+\n+    @Override\n+    public void scan() {\n+        HttpMessage message = getNewMsg();\n+        try {\n+            sendAndReceive(message);\n+            if (message.getResponseHeader().getStatusCode() != HttpStatusCode.FORBIDDEN) {\n+                return;\n+            }\n+            URI uri = message.getRequestHeader().getURI();\n+            String host = uri.getEscapedAuthority();\n+            String path = uri.getEscapedPath();\n+            String schema = uri.getScheme();\n+            if (sendPathPayloads(path, host, schema, uri)) {\n+                return;\n+            }\n+            ;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1MTk1Mw=="}, "originalCommit": {"oid": "9afe57d880176b650fb08bcb8daa2867940f5e8d"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MTQ3ODIwOnYy", "diffSide": "RIGHT", "path": "addOns/ascanrulesAlpha/src/main/java/org/zaproxy/zap/extension/ascanrulesAlpha/ForbiddenBypassScanRule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxNTo0NzowOFrOIJ_txg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QxMDo1MToxM1rOIKhBhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1MjAwNg==", "bodyText": "These cases should be covered by the tests too.", "url": "https://github.com/zaproxy/zap-extensions/pull/2660#discussion_r547352006", "createdAt": "2020-12-22T15:47:08Z", "author": {"login": "thc202"}, "path": "addOns/ascanrulesAlpha/src/main/java/org/zaproxy/zap/extension/ascanrulesAlpha/ForbiddenBypassScanRule.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.extension.ascanrulesAlpha;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.httpclient.URI;\n+import org.apache.log4j.Logger;\n+import org.parosproxy.paros.Constant;\n+import org.parosproxy.paros.core.scanner.AbstractAppPlugin;\n+import org.parosproxy.paros.core.scanner.Alert;\n+import org.parosproxy.paros.core.scanner.Category;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.parosproxy.paros.network.HttpStatusCode;\n+\n+/**\n+ * Active scan rule which attempts various 403 bypass techniques.\n+ *\n+ * @author Aman Rawat (@theamanrawat)\n+ */\n+public class ForbiddenBypassScanRule extends AbstractAppPlugin {\n+\n+    private static final String MESSAGE_PREFIX = \"ascanalpha.forbiddenBypass.\";\n+    private static final Logger LOG = Logger.getLogger(ForbiddenBypassScanRule.class);\n+\n+    @Override\n+    public int getId() {\n+        return 40038;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return Constant.messages.getString(MESSAGE_PREFIX + \"name\");\n+    }\n+\n+    @Override\n+    public String getDescription() {\n+        return Constant.messages.getString(MESSAGE_PREFIX + \"desc\");\n+    }\n+\n+    @Override\n+    public void scan() {\n+        HttpMessage message = getNewMsg();\n+        try {\n+            sendAndReceive(message);\n+            if (message.getResponseHeader().getStatusCode() != HttpStatusCode.FORBIDDEN) {\n+                return;\n+            }\n+            URI uri = message.getRequestHeader().getURI();\n+            String host = uri.getEscapedAuthority();\n+            String path = uri.getEscapedPath();\n+            String schema = uri.getScheme();\n+            if (sendPathPayloads(path, host, schema, uri)) {\n+                return;\n+            }\n+            ;\n+            if (sendHeaderPayloads(path, host, schema, uri)) {\n+                return;\n+            }\n+            ;\n+\n+        } catch (IOException e) {\n+            LOG.warn(e.getMessage(), e);\n+        }\n+    }\n+\n+    private boolean sendPathPayloads(String path, String host, String schema, URI uri)\n+            throws IOException {\n+        String[] pathPayloads = {\n+            \"/%2e\" + path,\n+            path + \"/./\",\n+            \"/.\" + path + \"/./\",\n+            path + \"%20/\",\n+            \"/%20\" + path + \"%20/\",\n+            path + \"..;/\",\n+            path + \"?\",\n+            path + \"??\",\n+            \"/\" + path + \"//\",\n+            path + \"/\",\n+            path + \"/.testus\",\n+            path + \"../app.py\"\n+        };\n+\n+        for (String pathPayload : pathPayloads) {\n+            HttpMessage reqWithPayload =\n+                    new HttpMessage(new URI(schema + \"://\" + host + \"\" + pathPayload, true));\n+            sendAndReceive(reqWithPayload);\n+            if (reqWithPayload.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n+                createAlert(uri.toString(), reqWithPayload).raise();\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean sendHeaderPayloads(String path, String host, String schema, URI uri)\n+            throws IOException {\n+        String[] headerPayloads = {\n+            \"X-Rewrite-URL: \" + path,\n+            \"X-Original-URL: \" + path,\n+            \"Referer: \" + path,\n+            \"X-Custom-IP-Authorization: 127.0.0.1\",\n+            \"X-Originating-IP: 127.0.0.1\",\n+            \"X-Forwarded-For: 127.0.0.1\",\n+            \"X-Remote-IP: 127.0.0.1\",\n+            \"X-Client-IP: 127.0.0.1\",\n+            \"X-Host: 127.0.0.1\",\n+            \"X-Forwared-Host: 127.0.0.1\"\n+        };\n+\n+        for (String header : headerPayloads) {\n+            String tmpUri = schema + \"://\" + host;\n+\n+            if (header.contains(\"X-Rewrite-URL\")) {\n+                tmpUri = tmpUri + \"/anything\";\n+            } else if (header.contains(\"X-Original-URL\")) {\n+                tmpUri = tmpUri + \"://\" + host + \"/\";\n+            } else if (header.contains(\"Referer\")) {\n+                tmpUri = tmpUri + \"://\" + host + \"/anything\";\n+            } else {\n+                tmpUri = tmpUri + path;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9afe57d880176b650fb08bcb8daa2867940f5e8d"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg5NzczMw==", "bodyText": "Done", "url": "https://github.com/zaproxy/zap-extensions/pull/2660#discussion_r547897733", "createdAt": "2020-12-23T10:51:13Z", "author": {"login": "theamanrawat"}, "path": "addOns/ascanrulesAlpha/src/main/java/org/zaproxy/zap/extension/ascanrulesAlpha/ForbiddenBypassScanRule.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.extension.ascanrulesAlpha;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.httpclient.URI;\n+import org.apache.log4j.Logger;\n+import org.parosproxy.paros.Constant;\n+import org.parosproxy.paros.core.scanner.AbstractAppPlugin;\n+import org.parosproxy.paros.core.scanner.Alert;\n+import org.parosproxy.paros.core.scanner.Category;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.parosproxy.paros.network.HttpStatusCode;\n+\n+/**\n+ * Active scan rule which attempts various 403 bypass techniques.\n+ *\n+ * @author Aman Rawat (@theamanrawat)\n+ */\n+public class ForbiddenBypassScanRule extends AbstractAppPlugin {\n+\n+    private static final String MESSAGE_PREFIX = \"ascanalpha.forbiddenBypass.\";\n+    private static final Logger LOG = Logger.getLogger(ForbiddenBypassScanRule.class);\n+\n+    @Override\n+    public int getId() {\n+        return 40038;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return Constant.messages.getString(MESSAGE_PREFIX + \"name\");\n+    }\n+\n+    @Override\n+    public String getDescription() {\n+        return Constant.messages.getString(MESSAGE_PREFIX + \"desc\");\n+    }\n+\n+    @Override\n+    public void scan() {\n+        HttpMessage message = getNewMsg();\n+        try {\n+            sendAndReceive(message);\n+            if (message.getResponseHeader().getStatusCode() != HttpStatusCode.FORBIDDEN) {\n+                return;\n+            }\n+            URI uri = message.getRequestHeader().getURI();\n+            String host = uri.getEscapedAuthority();\n+            String path = uri.getEscapedPath();\n+            String schema = uri.getScheme();\n+            if (sendPathPayloads(path, host, schema, uri)) {\n+                return;\n+            }\n+            ;\n+            if (sendHeaderPayloads(path, host, schema, uri)) {\n+                return;\n+            }\n+            ;\n+\n+        } catch (IOException e) {\n+            LOG.warn(e.getMessage(), e);\n+        }\n+    }\n+\n+    private boolean sendPathPayloads(String path, String host, String schema, URI uri)\n+            throws IOException {\n+        String[] pathPayloads = {\n+            \"/%2e\" + path,\n+            path + \"/./\",\n+            \"/.\" + path + \"/./\",\n+            path + \"%20/\",\n+            \"/%20\" + path + \"%20/\",\n+            path + \"..;/\",\n+            path + \"?\",\n+            path + \"??\",\n+            \"/\" + path + \"//\",\n+            path + \"/\",\n+            path + \"/.testus\",\n+            path + \"../app.py\"\n+        };\n+\n+        for (String pathPayload : pathPayloads) {\n+            HttpMessage reqWithPayload =\n+                    new HttpMessage(new URI(schema + \"://\" + host + \"\" + pathPayload, true));\n+            sendAndReceive(reqWithPayload);\n+            if (reqWithPayload.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n+                createAlert(uri.toString(), reqWithPayload).raise();\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean sendHeaderPayloads(String path, String host, String schema, URI uri)\n+            throws IOException {\n+        String[] headerPayloads = {\n+            \"X-Rewrite-URL: \" + path,\n+            \"X-Original-URL: \" + path,\n+            \"Referer: \" + path,\n+            \"X-Custom-IP-Authorization: 127.0.0.1\",\n+            \"X-Originating-IP: 127.0.0.1\",\n+            \"X-Forwarded-For: 127.0.0.1\",\n+            \"X-Remote-IP: 127.0.0.1\",\n+            \"X-Client-IP: 127.0.0.1\",\n+            \"X-Host: 127.0.0.1\",\n+            \"X-Forwared-Host: 127.0.0.1\"\n+        };\n+\n+        for (String header : headerPayloads) {\n+            String tmpUri = schema + \"://\" + host;\n+\n+            if (header.contains(\"X-Rewrite-URL\")) {\n+                tmpUri = tmpUri + \"/anything\";\n+            } else if (header.contains(\"X-Original-URL\")) {\n+                tmpUri = tmpUri + \"://\" + host + \"/\";\n+            } else if (header.contains(\"Referer\")) {\n+                tmpUri = tmpUri + \"://\" + host + \"/anything\";\n+            } else {\n+                tmpUri = tmpUri + path;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1MjAwNg=="}, "originalCommit": {"oid": "9afe57d880176b650fb08bcb8daa2867940f5e8d"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MTQ3ODY1OnYy", "diffSide": "RIGHT", "path": "addOns/ascanrulesAlpha/src/main/java/org/zaproxy/zap/extension/ascanrulesAlpha/ForbiddenBypassScanRule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxNTo0NzoxOVrOIJ_uGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QxMDo1MDo1OFrOIKhBGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1MjA5MQ==", "bodyText": "The attack could be set to the payload sent.", "url": "https://github.com/zaproxy/zap-extensions/pull/2660#discussion_r547352091", "createdAt": "2020-12-22T15:47:19Z", "author": {"login": "thc202"}, "path": "addOns/ascanrulesAlpha/src/main/java/org/zaproxy/zap/extension/ascanrulesAlpha/ForbiddenBypassScanRule.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.extension.ascanrulesAlpha;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.httpclient.URI;\n+import org.apache.log4j.Logger;\n+import org.parosproxy.paros.Constant;\n+import org.parosproxy.paros.core.scanner.AbstractAppPlugin;\n+import org.parosproxy.paros.core.scanner.Alert;\n+import org.parosproxy.paros.core.scanner.Category;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.parosproxy.paros.network.HttpStatusCode;\n+\n+/**\n+ * Active scan rule which attempts various 403 bypass techniques.\n+ *\n+ * @author Aman Rawat (@theamanrawat)\n+ */\n+public class ForbiddenBypassScanRule extends AbstractAppPlugin {\n+\n+    private static final String MESSAGE_PREFIX = \"ascanalpha.forbiddenBypass.\";\n+    private static final Logger LOG = Logger.getLogger(ForbiddenBypassScanRule.class);\n+\n+    @Override\n+    public int getId() {\n+        return 40038;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return Constant.messages.getString(MESSAGE_PREFIX + \"name\");\n+    }\n+\n+    @Override\n+    public String getDescription() {\n+        return Constant.messages.getString(MESSAGE_PREFIX + \"desc\");\n+    }\n+\n+    @Override\n+    public void scan() {\n+        HttpMessage message = getNewMsg();\n+        try {\n+            sendAndReceive(message);\n+            if (message.getResponseHeader().getStatusCode() != HttpStatusCode.FORBIDDEN) {\n+                return;\n+            }\n+            URI uri = message.getRequestHeader().getURI();\n+            String host = uri.getEscapedAuthority();\n+            String path = uri.getEscapedPath();\n+            String schema = uri.getScheme();\n+            if (sendPathPayloads(path, host, schema, uri)) {\n+                return;\n+            }\n+            ;\n+            if (sendHeaderPayloads(path, host, schema, uri)) {\n+                return;\n+            }\n+            ;\n+\n+        } catch (IOException e) {\n+            LOG.warn(e.getMessage(), e);\n+        }\n+    }\n+\n+    private boolean sendPathPayloads(String path, String host, String schema, URI uri)\n+            throws IOException {\n+        String[] pathPayloads = {\n+            \"/%2e\" + path,\n+            path + \"/./\",\n+            \"/.\" + path + \"/./\",\n+            path + \"%20/\",\n+            \"/%20\" + path + \"%20/\",\n+            path + \"..;/\",\n+            path + \"?\",\n+            path + \"??\",\n+            \"/\" + path + \"//\",\n+            path + \"/\",\n+            path + \"/.testus\",\n+            path + \"../app.py\"\n+        };\n+\n+        for (String pathPayload : pathPayloads) {\n+            HttpMessage reqWithPayload =\n+                    new HttpMessage(new URI(schema + \"://\" + host + \"\" + pathPayload, true));\n+            sendAndReceive(reqWithPayload);\n+            if (reqWithPayload.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n+                createAlert(uri.toString(), reqWithPayload).raise();\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean sendHeaderPayloads(String path, String host, String schema, URI uri)\n+            throws IOException {\n+        String[] headerPayloads = {\n+            \"X-Rewrite-URL: \" + path,\n+            \"X-Original-URL: \" + path,\n+            \"Referer: \" + path,\n+            \"X-Custom-IP-Authorization: 127.0.0.1\",\n+            \"X-Originating-IP: 127.0.0.1\",\n+            \"X-Forwarded-For: 127.0.0.1\",\n+            \"X-Remote-IP: 127.0.0.1\",\n+            \"X-Client-IP: 127.0.0.1\",\n+            \"X-Host: 127.0.0.1\",\n+            \"X-Forwared-Host: 127.0.0.1\"\n+        };\n+\n+        for (String header : headerPayloads) {\n+            String tmpUri = schema + \"://\" + host;\n+\n+            if (header.contains(\"X-Rewrite-URL\")) {\n+                tmpUri = tmpUri + \"/anything\";\n+            } else if (header.contains(\"X-Original-URL\")) {\n+                tmpUri = tmpUri + \"://\" + host + \"/\";\n+            } else if (header.contains(\"Referer\")) {\n+                tmpUri = tmpUri + \"://\" + host + \"/anything\";\n+            } else {\n+                tmpUri = tmpUri + path;\n+            }\n+\n+            HttpMessage reqWithPayload = new HttpMessage(new URI(tmpUri, true));\n+\n+            String[] headerPayload = header.split(\":\");\n+\n+            reqWithPayload.getRequestHeader().setHeader(headerPayload[0], headerPayload[1]);\n+            sendAndReceive(reqWithPayload);\n+\n+            if (reqWithPayload.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n+                createAlert(uri.toString(), reqWithPayload).raise();\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private AlertBuilder createAlert(String uri, HttpMessage messgae) {\n+        return newAlert().setOtherInfo(uri).setMessage(messgae);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9afe57d880176b650fb08bcb8daa2867940f5e8d"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg5NzYyNA==", "bodyText": "Done", "url": "https://github.com/zaproxy/zap-extensions/pull/2660#discussion_r547897624", "createdAt": "2020-12-23T10:50:58Z", "author": {"login": "theamanrawat"}, "path": "addOns/ascanrulesAlpha/src/main/java/org/zaproxy/zap/extension/ascanrulesAlpha/ForbiddenBypassScanRule.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.extension.ascanrulesAlpha;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.httpclient.URI;\n+import org.apache.log4j.Logger;\n+import org.parosproxy.paros.Constant;\n+import org.parosproxy.paros.core.scanner.AbstractAppPlugin;\n+import org.parosproxy.paros.core.scanner.Alert;\n+import org.parosproxy.paros.core.scanner.Category;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.parosproxy.paros.network.HttpStatusCode;\n+\n+/**\n+ * Active scan rule which attempts various 403 bypass techniques.\n+ *\n+ * @author Aman Rawat (@theamanrawat)\n+ */\n+public class ForbiddenBypassScanRule extends AbstractAppPlugin {\n+\n+    private static final String MESSAGE_PREFIX = \"ascanalpha.forbiddenBypass.\";\n+    private static final Logger LOG = Logger.getLogger(ForbiddenBypassScanRule.class);\n+\n+    @Override\n+    public int getId() {\n+        return 40038;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return Constant.messages.getString(MESSAGE_PREFIX + \"name\");\n+    }\n+\n+    @Override\n+    public String getDescription() {\n+        return Constant.messages.getString(MESSAGE_PREFIX + \"desc\");\n+    }\n+\n+    @Override\n+    public void scan() {\n+        HttpMessage message = getNewMsg();\n+        try {\n+            sendAndReceive(message);\n+            if (message.getResponseHeader().getStatusCode() != HttpStatusCode.FORBIDDEN) {\n+                return;\n+            }\n+            URI uri = message.getRequestHeader().getURI();\n+            String host = uri.getEscapedAuthority();\n+            String path = uri.getEscapedPath();\n+            String schema = uri.getScheme();\n+            if (sendPathPayloads(path, host, schema, uri)) {\n+                return;\n+            }\n+            ;\n+            if (sendHeaderPayloads(path, host, schema, uri)) {\n+                return;\n+            }\n+            ;\n+\n+        } catch (IOException e) {\n+            LOG.warn(e.getMessage(), e);\n+        }\n+    }\n+\n+    private boolean sendPathPayloads(String path, String host, String schema, URI uri)\n+            throws IOException {\n+        String[] pathPayloads = {\n+            \"/%2e\" + path,\n+            path + \"/./\",\n+            \"/.\" + path + \"/./\",\n+            path + \"%20/\",\n+            \"/%20\" + path + \"%20/\",\n+            path + \"..;/\",\n+            path + \"?\",\n+            path + \"??\",\n+            \"/\" + path + \"//\",\n+            path + \"/\",\n+            path + \"/.testus\",\n+            path + \"../app.py\"\n+        };\n+\n+        for (String pathPayload : pathPayloads) {\n+            HttpMessage reqWithPayload =\n+                    new HttpMessage(new URI(schema + \"://\" + host + \"\" + pathPayload, true));\n+            sendAndReceive(reqWithPayload);\n+            if (reqWithPayload.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n+                createAlert(uri.toString(), reqWithPayload).raise();\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean sendHeaderPayloads(String path, String host, String schema, URI uri)\n+            throws IOException {\n+        String[] headerPayloads = {\n+            \"X-Rewrite-URL: \" + path,\n+            \"X-Original-URL: \" + path,\n+            \"Referer: \" + path,\n+            \"X-Custom-IP-Authorization: 127.0.0.1\",\n+            \"X-Originating-IP: 127.0.0.1\",\n+            \"X-Forwarded-For: 127.0.0.1\",\n+            \"X-Remote-IP: 127.0.0.1\",\n+            \"X-Client-IP: 127.0.0.1\",\n+            \"X-Host: 127.0.0.1\",\n+            \"X-Forwared-Host: 127.0.0.1\"\n+        };\n+\n+        for (String header : headerPayloads) {\n+            String tmpUri = schema + \"://\" + host;\n+\n+            if (header.contains(\"X-Rewrite-URL\")) {\n+                tmpUri = tmpUri + \"/anything\";\n+            } else if (header.contains(\"X-Original-URL\")) {\n+                tmpUri = tmpUri + \"://\" + host + \"/\";\n+            } else if (header.contains(\"Referer\")) {\n+                tmpUri = tmpUri + \"://\" + host + \"/anything\";\n+            } else {\n+                tmpUri = tmpUri + path;\n+            }\n+\n+            HttpMessage reqWithPayload = new HttpMessage(new URI(tmpUri, true));\n+\n+            String[] headerPayload = header.split(\":\");\n+\n+            reqWithPayload.getRequestHeader().setHeader(headerPayload[0], headerPayload[1]);\n+            sendAndReceive(reqWithPayload);\n+\n+            if (reqWithPayload.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n+                createAlert(uri.toString(), reqWithPayload).raise();\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private AlertBuilder createAlert(String uri, HttpMessage messgae) {\n+        return newAlert().setOtherInfo(uri).setMessage(messgae);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1MjA5MQ=="}, "originalCommit": {"oid": "9afe57d880176b650fb08bcb8daa2867940f5e8d"}, "originalPosition": 158}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MTQ3OTM1OnYy", "diffSide": "RIGHT", "path": "addOns/ascanrulesAlpha/src/main/resources/org/zaproxy/zap/extension/ascanrulesAlpha/resources/Messages.properties", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxNTo0NzoyOFrOIJ_udA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QxMDo1MDo0MlrOIKhAtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1MjE4MA==", "bodyText": "To be more explicit it could be added e.g.: , the scan rule sent a payload that caused the response to be accessible (status code 200).", "url": "https://github.com/zaproxy/zap-extensions/pull/2660#discussion_r547352180", "createdAt": "2020-12-22T15:47:28Z", "author": {"login": "thc202"}, "path": "addOns/ascanrulesAlpha/src/main/resources/org/zaproxy/zap/extension/ascanrulesAlpha/resources/Messages.properties", "diffHunk": "@@ -30,3 +30,7 @@ ascanalpha.mongodb.extrainfo.alldata=In some PHP or NodeJS based back end implem\n ascanalpha.mongodb.extrainfo.sleep=Through the where or group MongoDB clauses, Javascript sleep function is probably executable.\n ascanalpha.mongodb.extrainfo.json=In some NodeJS based back end implementations, messages having the JSON format as content-type are expected. In order to obtain sensitive data it is possible to attack these applications injecting the \"{$ne:}\" string (or other similar ones) that is processed as an associative array rather than a simple text.\\nThrough this, the queries made to MongoDB will always be true.\n ascanalpha.mongodb.extrainfo.authbypass=More probably a MongoDB attack has bypassed an authentication page.\n+\n+ascanalpha.forbiddenBypass.name=Bypassing 403\n+ascanalpha.forbiddenBypass.desc=Bypassing 403 endpoints may be possible.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9afe57d880176b650fb08bcb8daa2867940f5e8d"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg5NzUyNg==", "bodyText": "Done", "url": "https://github.com/zaproxy/zap-extensions/pull/2660#discussion_r547897526", "createdAt": "2020-12-23T10:50:42Z", "author": {"login": "theamanrawat"}, "path": "addOns/ascanrulesAlpha/src/main/resources/org/zaproxy/zap/extension/ascanrulesAlpha/resources/Messages.properties", "diffHunk": "@@ -30,3 +30,7 @@ ascanalpha.mongodb.extrainfo.alldata=In some PHP or NodeJS based back end implem\n ascanalpha.mongodb.extrainfo.sleep=Through the where or group MongoDB clauses, Javascript sleep function is probably executable.\n ascanalpha.mongodb.extrainfo.json=In some NodeJS based back end implementations, messages having the JSON format as content-type are expected. In order to obtain sensitive data it is possible to attack these applications injecting the \"{$ne:}\" string (or other similar ones) that is processed as an associative array rather than a simple text.\\nThrough this, the queries made to MongoDB will always be true.\n ascanalpha.mongodb.extrainfo.authbypass=More probably a MongoDB attack has bypassed an authentication page.\n+\n+ascanalpha.forbiddenBypass.name=Bypassing 403\n+ascanalpha.forbiddenBypass.desc=Bypassing 403 endpoints may be possible.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1MjE4MA=="}, "originalCommit": {"oid": "9afe57d880176b650fb08bcb8daa2867940f5e8d"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0NTM4MDMwOnYy", "diffSide": "RIGHT", "path": "addOns/ascanrulesAlpha/src/main/java/org/zaproxy/zap/extension/ascanrulesAlpha/ForbiddenBypassScanRule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QxMzoyODowMFrOIKkubg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QxMzoyODowMFrOIKkubg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk1ODM4Mg==", "bodyText": "This is now the same case as the first if statement, better include this condition there.", "url": "https://github.com/zaproxy/zap-extensions/pull/2660#discussion_r547958382", "createdAt": "2020-12-23T13:28:00Z", "author": {"login": "thc202"}, "path": "addOns/ascanrulesAlpha/src/main/java/org/zaproxy/zap/extension/ascanrulesAlpha/ForbiddenBypassScanRule.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.extension.ascanrulesAlpha;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.httpclient.URI;\n+import org.apache.log4j.Logger;\n+import org.parosproxy.paros.Constant;\n+import org.parosproxy.paros.core.scanner.AbstractAppPlugin;\n+import org.parosproxy.paros.core.scanner.Alert;\n+import org.parosproxy.paros.core.scanner.Category;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.parosproxy.paros.network.HttpStatusCode;\n+\n+/**\n+ * Active scan rule which attempts various 403 bypass techniques.\n+ *\n+ * @author Aman Rawat (@theamanrawat)\n+ */\n+public class ForbiddenBypassScanRule extends AbstractAppPlugin {\n+\n+    private static final String MESSAGE_PREFIX = \"ascanalpha.forbiddenBypass.\";\n+    private static final Logger LOG = Logger.getLogger(ForbiddenBypassScanRule.class);\n+\n+    @Override\n+    public int getId() {\n+        return 40038;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return Constant.messages.getString(MESSAGE_PREFIX + \"name\");\n+    }\n+\n+    @Override\n+    public String getDescription() {\n+        return Constant.messages.getString(MESSAGE_PREFIX + \"desc\");\n+    }\n+\n+    @Override\n+    public void scan() {\n+        HttpMessage message = getNewMsg();\n+        try {\n+            sendAndReceive(message);\n+            if (message.getResponseHeader().getStatusCode() != HttpStatusCode.FORBIDDEN) {\n+                return;\n+            }\n+            URI uri = message.getRequestHeader().getURI();\n+            String host = uri.getEscapedAuthority();\n+            String path = uri.getEscapedPath();\n+            String schema = uri.getScheme();\n+            if (sendPathPayloads(path, host, schema, uri)) {\n+                return;\n+            }\n+            if (sendHeaderPayloads(path, host, schema, uri)) {\n+                return;\n+            }\n+\n+        } catch (IOException e) {\n+            LOG.warn(e.getMessage(), e);\n+        }\n+    }\n+\n+    private boolean sendPathPayloads(String path, String host, String schema, URI uri)\n+            throws IOException {\n+        String[] pathPayloads = {\n+            \"/%2e\" + path,\n+            path + \"/./\",\n+            \"/.\" + path + \"/./\",\n+            path + \"%20/\",\n+            \"/%20\" + path + \"%20/\",\n+            path + \"..;/\",\n+            path + \"?\",\n+            path + \"??\",\n+            \"/\" + path + \"//\",\n+            path + \"/\",\n+            path + \"/.testus\",\n+            path + \"../app.py\"\n+        };\n+\n+        for (String pathPayload : pathPayloads) {\n+            HttpMessage reqWithPayload =\n+                    new HttpMessage(new URI(schema + \"://\" + host + \"\" + pathPayload, true));\n+            sendAndReceive(reqWithPayload);\n+            if (reqWithPayload.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n+                createAlert(uri.toString(), reqWithPayload, pathPayload).raise();\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean sendHeaderPayloads(String path, String host, String schema, URI uri)\n+            throws IOException {\n+        String[] headerPayloads = {\n+            \"X-Rewrite-URL: \" + path,\n+            \"X-Original-URL: \" + path,\n+            \"Referer: \" + path,\n+            \"X-Custom-IP-Authorization: 127.0.0.1\",\n+            \"X-Originating-IP: 127.0.0.1\",\n+            \"X-Forwarded-For: 127.0.0.1\",\n+            \"X-Remote-IP: 127.0.0.1\",\n+            \"X-Client-IP: 127.0.0.1\",\n+            \"X-Host: 127.0.0.1\",\n+            \"X-Forwared-Host: 127.0.0.1\"\n+        };\n+\n+        for (String header : headerPayloads) {\n+            String tmpUri = schema + \"://\" + host;\n+\n+            if (header.contains(\"X-Rewrite-URL\")) {\n+                tmpUri = tmpUri + \"/anything\";\n+            } else if (header.contains(\"X-Original-URL\")) {\n+                tmpUri = tmpUri + \"/\";\n+            } else if (header.contains(\"Referer\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d792255c21cf6f5b8ce98b351df1b002c70ff93"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0NTM4MTI0OnYy", "diffSide": "RIGHT", "path": "addOns/ascanrulesAlpha/src/test/java/org/zaproxy/zap/extension/ascanrulesAlpha/ForbiddenBypassScanRuleUnitTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QxMzoyODoxNFrOIKku4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QxMzoyODoxNFrOIKku4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk1ODQ5OQ==", "bodyText": "Could you also assert the attack is not empty and for following tests that it's the expected one?", "url": "https://github.com/zaproxy/zap-extensions/pull/2660#discussion_r547958499", "createdAt": "2020-12-23T13:28:14Z", "author": {"login": "thc202"}, "path": "addOns/ascanrulesAlpha/src/test/java/org/zaproxy/zap/extension/ascanrulesAlpha/ForbiddenBypassScanRuleUnitTest.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.extension.ascanrulesAlpha;\n+\n+import static fi.iki.elonen.NanoHTTPD.newFixedLengthResponse;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import fi.iki.elonen.NanoHTTPD.IHTTPSession;\n+import fi.iki.elonen.NanoHTTPD.Response;\n+import org.junit.jupiter.api.Test;\n+import org.parosproxy.paros.core.scanner.Alert;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.testutils.NanoServerHandler;\n+\n+/** Unit test for {@link ForbiddenBypassScanRule}. */\n+public class ForbiddenBypassScanRuleUnitTest extends ActiveScannerTest<ForbiddenBypassScanRule> {\n+\n+    private static final String PROTECTED_PATH = \"/protected/endpoint\";\n+\n+    private static final String GENERIC_RESPONSE =\n+            \"<!DOCTYPE HTML PUBLIC \\\"-//IETF//DTD HTML 2.0//EN\\\">\\n\"\n+                    + \"<html><head></head><body></body></html>\";\n+\n+    @Override\n+    protected ForbiddenBypassScanRule createScanner() {\n+        return new ForbiddenBypassScanRule();\n+    }\n+\n+    @Test\n+    public void shouldNotAlertIfInitialRequestIsNotForbidden() throws Exception {\n+        // Given\n+        String path = \"/allowed/\";\n+        nano.addHandler(new OkResponse(path));\n+        HttpMessage msg = this.getHttpMessage(path);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(0));\n+        assertEquals(1, httpMessagesSent.size());\n+    }\n+\n+    @Test\n+    public void shouldNotAlertIfAllRequestsAreForbidden() throws Exception {\n+        // Given\n+        String path = \"/forbidden/\";\n+        nano.addHandler(new ForbiddenResponse(path));\n+        HttpMessage msg = this.getHttpMessage(path);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(0));\n+        assertEquals(23, httpMessagesSent.size());\n+    }\n+\n+    @Test\n+    public void shouldAlertIfOkObtained() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d792255c21cf6f5b8ce98b351df1b002c70ff93"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0NTM4MTQ0OnYy", "diffSide": "RIGHT", "path": "addOns/ascanrulesAlpha/src/test/java/org/zaproxy/zap/extension/ascanrulesAlpha/ForbiddenBypassScanRuleUnitTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QxMzoyODoxN1rOIKku-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QxMzoyODoxN1rOIKku-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk1ODUyMg==", "bodyText": "btw, given this is the same for all of them it could be extracted a method.", "url": "https://github.com/zaproxy/zap-extensions/pull/2660#discussion_r547958522", "createdAt": "2020-12-23T13:28:17Z", "author": {"login": "thc202"}, "path": "addOns/ascanrulesAlpha/src/test/java/org/zaproxy/zap/extension/ascanrulesAlpha/ForbiddenBypassScanRuleUnitTest.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.extension.ascanrulesAlpha;\n+\n+import static fi.iki.elonen.NanoHTTPD.newFixedLengthResponse;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import fi.iki.elonen.NanoHTTPD.IHTTPSession;\n+import fi.iki.elonen.NanoHTTPD.Response;\n+import org.junit.jupiter.api.Test;\n+import org.parosproxy.paros.core.scanner.Alert;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.testutils.NanoServerHandler;\n+\n+/** Unit test for {@link ForbiddenBypassScanRule}. */\n+public class ForbiddenBypassScanRuleUnitTest extends ActiveScannerTest<ForbiddenBypassScanRule> {\n+\n+    private static final String PROTECTED_PATH = \"/protected/endpoint\";\n+\n+    private static final String GENERIC_RESPONSE =\n+            \"<!DOCTYPE HTML PUBLIC \\\"-//IETF//DTD HTML 2.0//EN\\\">\\n\"\n+                    + \"<html><head></head><body></body></html>\";\n+\n+    @Override\n+    protected ForbiddenBypassScanRule createScanner() {\n+        return new ForbiddenBypassScanRule();\n+    }\n+\n+    @Test\n+    public void shouldNotAlertIfInitialRequestIsNotForbidden() throws Exception {\n+        // Given\n+        String path = \"/allowed/\";\n+        nano.addHandler(new OkResponse(path));\n+        HttpMessage msg = this.getHttpMessage(path);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(0));\n+        assertEquals(1, httpMessagesSent.size());\n+    }\n+\n+    @Test\n+    public void shouldNotAlertIfAllRequestsAreForbidden() throws Exception {\n+        // Given\n+        String path = \"/forbidden/\";\n+        nano.addHandler(new ForbiddenResponse(path));\n+        HttpMessage msg = this.getHttpMessage(path);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(0));\n+        assertEquals(23, httpMessagesSent.size());\n+    }\n+\n+    @Test\n+    public void shouldAlertIfOkObtained() throws Exception {\n+        // Given\n+        nano.addHandler(new ForbiddenResponse(PROTECTED_PATH));\n+        nano.addHandler(new OkResponse(\"/.\" + PROTECTED_PATH)); // Period is %2e\n+        HttpMessage msg = this.getHttpMessage(PROTECTED_PATH);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(1));\n+        Alert alert = alertsRaised.get(0);\n+        assertEquals(\"Bypassing 403\", alert.getName());\n+        assertEquals(Alert.RISK_MEDIUM, alert.getRisk());\n+        assertEquals(Alert.CONFIDENCE_MEDIUM, alert.getConfidence());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d792255c21cf6f5b8ce98b351df1b002c70ff93"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0NTM4MTc4OnYy", "diffSide": "RIGHT", "path": "addOns/ascanrulesAlpha/src/test/java/org/zaproxy/zap/extension/ascanrulesAlpha/ForbiddenBypassScanRuleUnitTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QxMzoyODoyNFrOIKkvLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QxMzoyODoyNFrOIKkvLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk1ODU3Mg==", "bodyText": "It's preferable to use specific names, e.g.shouldAlertIfOkWithRewriteUrlHeader.", "url": "https://github.com/zaproxy/zap-extensions/pull/2660#discussion_r547958572", "createdAt": "2020-12-23T13:28:24Z", "author": {"login": "thc202"}, "path": "addOns/ascanrulesAlpha/src/test/java/org/zaproxy/zap/extension/ascanrulesAlpha/ForbiddenBypassScanRuleUnitTest.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.extension.ascanrulesAlpha;\n+\n+import static fi.iki.elonen.NanoHTTPD.newFixedLengthResponse;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import fi.iki.elonen.NanoHTTPD.IHTTPSession;\n+import fi.iki.elonen.NanoHTTPD.Response;\n+import org.junit.jupiter.api.Test;\n+import org.parosproxy.paros.core.scanner.Alert;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.testutils.NanoServerHandler;\n+\n+/** Unit test for {@link ForbiddenBypassScanRule}. */\n+public class ForbiddenBypassScanRuleUnitTest extends ActiveScannerTest<ForbiddenBypassScanRule> {\n+\n+    private static final String PROTECTED_PATH = \"/protected/endpoint\";\n+\n+    private static final String GENERIC_RESPONSE =\n+            \"<!DOCTYPE HTML PUBLIC \\\"-//IETF//DTD HTML 2.0//EN\\\">\\n\"\n+                    + \"<html><head></head><body></body></html>\";\n+\n+    @Override\n+    protected ForbiddenBypassScanRule createScanner() {\n+        return new ForbiddenBypassScanRule();\n+    }\n+\n+    @Test\n+    public void shouldNotAlertIfInitialRequestIsNotForbidden() throws Exception {\n+        // Given\n+        String path = \"/allowed/\";\n+        nano.addHandler(new OkResponse(path));\n+        HttpMessage msg = this.getHttpMessage(path);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(0));\n+        assertEquals(1, httpMessagesSent.size());\n+    }\n+\n+    @Test\n+    public void shouldNotAlertIfAllRequestsAreForbidden() throws Exception {\n+        // Given\n+        String path = \"/forbidden/\";\n+        nano.addHandler(new ForbiddenResponse(path));\n+        HttpMessage msg = this.getHttpMessage(path);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(0));\n+        assertEquals(23, httpMessagesSent.size());\n+    }\n+\n+    @Test\n+    public void shouldAlertIfOkObtained() throws Exception {\n+        // Given\n+        nano.addHandler(new ForbiddenResponse(PROTECTED_PATH));\n+        nano.addHandler(new OkResponse(\"/.\" + PROTECTED_PATH)); // Period is %2e\n+        HttpMessage msg = this.getHttpMessage(PROTECTED_PATH);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(1));\n+        Alert alert = alertsRaised.get(0);\n+        assertEquals(\"Bypassing 403\", alert.getName());\n+        assertEquals(Alert.RISK_MEDIUM, alert.getRisk());\n+        assertEquals(Alert.CONFIDENCE_MEDIUM, alert.getConfidence());\n+    }\n+\n+    @Test\n+    public void shouldAlertIfOkWithHeaderPayload1() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d792255c21cf6f5b8ce98b351df1b002c70ff93"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0NTM4Mzg3OnYy", "diffSide": "RIGHT", "path": "addOns/ascanrulesAlpha/src/test/java/org/zaproxy/zap/extension/ascanrulesAlpha/ForbiddenBypassScanRuleUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QxMzoyOTowNlrOIKkwaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNFQxMToxMDo0OVrOILFjQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk1ODg5MQ==", "bodyText": "Same here regarding using specific names, although this should be changed to allow to pass the header being tested.", "url": "https://github.com/zaproxy/zap-extensions/pull/2660#discussion_r547958891", "createdAt": "2020-12-23T13:29:06Z", "author": {"login": "thc202"}, "path": "addOns/ascanrulesAlpha/src/test/java/org/zaproxy/zap/extension/ascanrulesAlpha/ForbiddenBypassScanRuleUnitTest.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.extension.ascanrulesAlpha;\n+\n+import static fi.iki.elonen.NanoHTTPD.newFixedLengthResponse;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import fi.iki.elonen.NanoHTTPD.IHTTPSession;\n+import fi.iki.elonen.NanoHTTPD.Response;\n+import org.junit.jupiter.api.Test;\n+import org.parosproxy.paros.core.scanner.Alert;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.testutils.NanoServerHandler;\n+\n+/** Unit test for {@link ForbiddenBypassScanRule}. */\n+public class ForbiddenBypassScanRuleUnitTest extends ActiveScannerTest<ForbiddenBypassScanRule> {\n+\n+    private static final String PROTECTED_PATH = \"/protected/endpoint\";\n+\n+    private static final String GENERIC_RESPONSE =\n+            \"<!DOCTYPE HTML PUBLIC \\\"-//IETF//DTD HTML 2.0//EN\\\">\\n\"\n+                    + \"<html><head></head><body></body></html>\";\n+\n+    @Override\n+    protected ForbiddenBypassScanRule createScanner() {\n+        return new ForbiddenBypassScanRule();\n+    }\n+\n+    @Test\n+    public void shouldNotAlertIfInitialRequestIsNotForbidden() throws Exception {\n+        // Given\n+        String path = \"/allowed/\";\n+        nano.addHandler(new OkResponse(path));\n+        HttpMessage msg = this.getHttpMessage(path);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(0));\n+        assertEquals(1, httpMessagesSent.size());\n+    }\n+\n+    @Test\n+    public void shouldNotAlertIfAllRequestsAreForbidden() throws Exception {\n+        // Given\n+        String path = \"/forbidden/\";\n+        nano.addHandler(new ForbiddenResponse(path));\n+        HttpMessage msg = this.getHttpMessage(path);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(0));\n+        assertEquals(23, httpMessagesSent.size());\n+    }\n+\n+    @Test\n+    public void shouldAlertIfOkObtained() throws Exception {\n+        // Given\n+        nano.addHandler(new ForbiddenResponse(PROTECTED_PATH));\n+        nano.addHandler(new OkResponse(\"/.\" + PROTECTED_PATH)); // Period is %2e\n+        HttpMessage msg = this.getHttpMessage(PROTECTED_PATH);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(1));\n+        Alert alert = alertsRaised.get(0);\n+        assertEquals(\"Bypassing 403\", alert.getName());\n+        assertEquals(Alert.RISK_MEDIUM, alert.getRisk());\n+        assertEquals(Alert.CONFIDENCE_MEDIUM, alert.getConfidence());\n+    }\n+\n+    @Test\n+    public void shouldAlertIfOkWithHeaderPayload1() throws Exception {\n+        // Given\n+        nano.addHandler(new ForbiddenResponse(PROTECTED_PATH));\n+        nano.addHandler(new HeaderResponse1(\"/anything\"));\n+        HttpMessage msg = this.getHttpMessage(PROTECTED_PATH);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(1));\n+        Alert alert = alertsRaised.get(0);\n+        assertEquals(\"Bypassing 403\", alert.getName());\n+        assertEquals(Alert.RISK_MEDIUM, alert.getRisk());\n+        assertEquals(Alert.CONFIDENCE_MEDIUM, alert.getConfidence());\n+    }\n+\n+    @Test\n+    public void shouldAlertIfOkWithHeaderPayload2() throws Exception {\n+        // Given\n+        nano.addHandler(new ForbiddenResponse(PROTECTED_PATH));\n+        nano.addHandler(new HeaderResponse1(\"/anything\"));\n+        HttpMessage msg = this.getHttpMessage(PROTECTED_PATH);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(1));\n+        Alert alert = alertsRaised.get(0);\n+        assertEquals(\"Bypassing 403\", alert.getName());\n+        assertEquals(Alert.RISK_MEDIUM, alert.getRisk());\n+        assertEquals(Alert.CONFIDENCE_MEDIUM, alert.getConfidence());\n+    }\n+\n+    @Test\n+    public void shouldAlertIfOkWithHeaderPayload3() throws Exception {\n+        // Given\n+        nano.addHandler(new ForbiddenResponse(PROTECTED_PATH));\n+        nano.addHandler(new HeaderResponse1(\"/\"));\n+        HttpMessage msg = this.getHttpMessage(PROTECTED_PATH);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(1));\n+        Alert alert = alertsRaised.get(0);\n+        assertEquals(\"Bypassing 403\", alert.getName());\n+        assertEquals(Alert.RISK_MEDIUM, alert.getRisk());\n+        assertEquals(Alert.CONFIDENCE_MEDIUM, alert.getConfidence());\n+    }\n+\n+    @Test\n+    public void shouldAlertIfOkWithHeaderPayload4() throws Exception {\n+        // Given\n+        nano.addHandler(new HeaderResponse2(PROTECTED_PATH));\n+        HttpMessage msg = this.getHttpMessage(PROTECTED_PATH);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(1));\n+        Alert alert = alertsRaised.get(0);\n+        assertEquals(\"Bypassing 403\", alert.getName());\n+        assertEquals(Alert.RISK_MEDIUM, alert.getRisk());\n+        assertEquals(Alert.CONFIDENCE_MEDIUM, alert.getConfidence());\n+    }\n+\n+    private static class OkResponse extends NanoServerHandler {\n+\n+        public OkResponse(String path) {\n+            super(path);\n+        }\n+\n+        @Override\n+        protected Response serve(IHTTPSession session) {\n+            return newFixedLengthResponse(Response.Status.OK, \"text/html\", GENERIC_RESPONSE);\n+        }\n+    }\n+\n+    private static class ForbiddenResponse extends NanoServerHandler {\n+\n+        public ForbiddenResponse(String path) {\n+            super(path);\n+        }\n+\n+        @Override\n+        protected Response serve(IHTTPSession session) {\n+            return newFixedLengthResponse(Response.Status.FORBIDDEN, \"text/html\", GENERIC_RESPONSE);\n+        }\n+    }\n+\n+    private static class HeaderResponse1 extends NanoServerHandler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d792255c21cf6f5b8ce98b351df1b002c70ff93"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ5NjE5NQ==", "bodyText": "Note the last part, it should be changed to allow to pass the header (to avoid duplicating the same code for each header).", "url": "https://github.com/zaproxy/zap-extensions/pull/2660#discussion_r548496195", "createdAt": "2020-12-24T11:10:49Z", "author": {"login": "thc202"}, "path": "addOns/ascanrulesAlpha/src/test/java/org/zaproxy/zap/extension/ascanrulesAlpha/ForbiddenBypassScanRuleUnitTest.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.extension.ascanrulesAlpha;\n+\n+import static fi.iki.elonen.NanoHTTPD.newFixedLengthResponse;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import fi.iki.elonen.NanoHTTPD.IHTTPSession;\n+import fi.iki.elonen.NanoHTTPD.Response;\n+import org.junit.jupiter.api.Test;\n+import org.parosproxy.paros.core.scanner.Alert;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.testutils.NanoServerHandler;\n+\n+/** Unit test for {@link ForbiddenBypassScanRule}. */\n+public class ForbiddenBypassScanRuleUnitTest extends ActiveScannerTest<ForbiddenBypassScanRule> {\n+\n+    private static final String PROTECTED_PATH = \"/protected/endpoint\";\n+\n+    private static final String GENERIC_RESPONSE =\n+            \"<!DOCTYPE HTML PUBLIC \\\"-//IETF//DTD HTML 2.0//EN\\\">\\n\"\n+                    + \"<html><head></head><body></body></html>\";\n+\n+    @Override\n+    protected ForbiddenBypassScanRule createScanner() {\n+        return new ForbiddenBypassScanRule();\n+    }\n+\n+    @Test\n+    public void shouldNotAlertIfInitialRequestIsNotForbidden() throws Exception {\n+        // Given\n+        String path = \"/allowed/\";\n+        nano.addHandler(new OkResponse(path));\n+        HttpMessage msg = this.getHttpMessage(path);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(0));\n+        assertEquals(1, httpMessagesSent.size());\n+    }\n+\n+    @Test\n+    public void shouldNotAlertIfAllRequestsAreForbidden() throws Exception {\n+        // Given\n+        String path = \"/forbidden/\";\n+        nano.addHandler(new ForbiddenResponse(path));\n+        HttpMessage msg = this.getHttpMessage(path);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(0));\n+        assertEquals(23, httpMessagesSent.size());\n+    }\n+\n+    @Test\n+    public void shouldAlertIfOkObtained() throws Exception {\n+        // Given\n+        nano.addHandler(new ForbiddenResponse(PROTECTED_PATH));\n+        nano.addHandler(new OkResponse(\"/.\" + PROTECTED_PATH)); // Period is %2e\n+        HttpMessage msg = this.getHttpMessage(PROTECTED_PATH);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(1));\n+        Alert alert = alertsRaised.get(0);\n+        assertEquals(\"Bypassing 403\", alert.getName());\n+        assertEquals(Alert.RISK_MEDIUM, alert.getRisk());\n+        assertEquals(Alert.CONFIDENCE_MEDIUM, alert.getConfidence());\n+    }\n+\n+    @Test\n+    public void shouldAlertIfOkWithHeaderPayload1() throws Exception {\n+        // Given\n+        nano.addHandler(new ForbiddenResponse(PROTECTED_PATH));\n+        nano.addHandler(new HeaderResponse1(\"/anything\"));\n+        HttpMessage msg = this.getHttpMessage(PROTECTED_PATH);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(1));\n+        Alert alert = alertsRaised.get(0);\n+        assertEquals(\"Bypassing 403\", alert.getName());\n+        assertEquals(Alert.RISK_MEDIUM, alert.getRisk());\n+        assertEquals(Alert.CONFIDENCE_MEDIUM, alert.getConfidence());\n+    }\n+\n+    @Test\n+    public void shouldAlertIfOkWithHeaderPayload2() throws Exception {\n+        // Given\n+        nano.addHandler(new ForbiddenResponse(PROTECTED_PATH));\n+        nano.addHandler(new HeaderResponse1(\"/anything\"));\n+        HttpMessage msg = this.getHttpMessage(PROTECTED_PATH);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(1));\n+        Alert alert = alertsRaised.get(0);\n+        assertEquals(\"Bypassing 403\", alert.getName());\n+        assertEquals(Alert.RISK_MEDIUM, alert.getRisk());\n+        assertEquals(Alert.CONFIDENCE_MEDIUM, alert.getConfidence());\n+    }\n+\n+    @Test\n+    public void shouldAlertIfOkWithHeaderPayload3() throws Exception {\n+        // Given\n+        nano.addHandler(new ForbiddenResponse(PROTECTED_PATH));\n+        nano.addHandler(new HeaderResponse1(\"/\"));\n+        HttpMessage msg = this.getHttpMessage(PROTECTED_PATH);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(1));\n+        Alert alert = alertsRaised.get(0);\n+        assertEquals(\"Bypassing 403\", alert.getName());\n+        assertEquals(Alert.RISK_MEDIUM, alert.getRisk());\n+        assertEquals(Alert.CONFIDENCE_MEDIUM, alert.getConfidence());\n+    }\n+\n+    @Test\n+    public void shouldAlertIfOkWithHeaderPayload4() throws Exception {\n+        // Given\n+        nano.addHandler(new HeaderResponse2(PROTECTED_PATH));\n+        HttpMessage msg = this.getHttpMessage(PROTECTED_PATH);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(1));\n+        Alert alert = alertsRaised.get(0);\n+        assertEquals(\"Bypassing 403\", alert.getName());\n+        assertEquals(Alert.RISK_MEDIUM, alert.getRisk());\n+        assertEquals(Alert.CONFIDENCE_MEDIUM, alert.getConfidence());\n+    }\n+\n+    private static class OkResponse extends NanoServerHandler {\n+\n+        public OkResponse(String path) {\n+            super(path);\n+        }\n+\n+        @Override\n+        protected Response serve(IHTTPSession session) {\n+            return newFixedLengthResponse(Response.Status.OK, \"text/html\", GENERIC_RESPONSE);\n+        }\n+    }\n+\n+    private static class ForbiddenResponse extends NanoServerHandler {\n+\n+        public ForbiddenResponse(String path) {\n+            super(path);\n+        }\n+\n+        @Override\n+        protected Response serve(IHTTPSession session) {\n+            return newFixedLengthResponse(Response.Status.FORBIDDEN, \"text/html\", GENERIC_RESPONSE);\n+        }\n+    }\n+\n+    private static class HeaderResponse1 extends NanoServerHandler {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk1ODg5MQ=="}, "originalCommit": {"oid": "0d792255c21cf6f5b8ce98b351df1b002c70ff93"}, "originalPosition": 184}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0ODg2MzUyOnYy", "diffSide": "RIGHT", "path": "addOns/ascanrulesAlpha/CHANGELOG.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNFQxMTowOTozN1rOILFiOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNFQxMTowOTozN1rOILFiOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ5NTkzMQ==", "bodyText": "Should be added under the Unreleased section.", "url": "https://github.com/zaproxy/zap-extensions/pull/2660#discussion_r548495931", "createdAt": "2020-12-24T11:09:37Z", "author": {"login": "thc202"}, "path": "addOns/ascanrulesAlpha/CHANGELOG.md", "diffHunk": "@@ -3,6 +3,9 @@ All notable changes to this add-on will be documented in this file.\n \n The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/).\n \n+### Added\n+- Forbidden (403) Bypass scan rule.\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66adec8173e75097745688086e575fecd6ee2286"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0ODg2NDQ4OnYy", "diffSide": "RIGHT", "path": "addOns/ascanrulesAlpha/src/test/java/org/zaproxy/zap/extension/ascanrulesAlpha/ForbiddenBypassScanRuleUnitTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNFQxMToxMDoxOFrOILFi1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNFQxMToxMDoxOFrOILFi1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ5NjA4Ng==", "bodyText": "private static\nassertAlert", "url": "https://github.com/zaproxy/zap-extensions/pull/2660#discussion_r548496086", "createdAt": "2020-12-24T11:10:18Z", "author": {"login": "thc202"}, "path": "addOns/ascanrulesAlpha/src/test/java/org/zaproxy/zap/extension/ascanrulesAlpha/ForbiddenBypassScanRuleUnitTest.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.extension.ascanrulesAlpha;\n+\n+import static fi.iki.elonen.NanoHTTPD.newFixedLengthResponse;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import fi.iki.elonen.NanoHTTPD.IHTTPSession;\n+import fi.iki.elonen.NanoHTTPD.Response;\n+import org.junit.jupiter.api.Test;\n+import org.parosproxy.paros.core.scanner.Alert;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.testutils.NanoServerHandler;\n+\n+/** Unit test for {@link ForbiddenBypassScanRule}. */\n+public class ForbiddenBypassScanRuleUnitTest extends ActiveScannerTest<ForbiddenBypassScanRule> {\n+\n+    private static final String PROTECTED_PATH = \"/protected/endpoint\";\n+\n+    private static final String GENERIC_RESPONSE =\n+            \"<!DOCTYPE HTML PUBLIC \\\"-//IETF//DTD HTML 2.0//EN\\\">\\n\"\n+                    + \"<html><head></head><body></body></html>\";\n+\n+    @Override\n+    protected ForbiddenBypassScanRule createScanner() {\n+        return new ForbiddenBypassScanRule();\n+    }\n+\n+    @Test\n+    public void shouldNotAlertIfInitialRequestIsNotForbidden() throws Exception {\n+        // Given\n+        String path = \"/allowed/\";\n+        nano.addHandler(new OkResponse(path));\n+        HttpMessage msg = this.getHttpMessage(path);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(0));\n+        assertEquals(1, httpMessagesSent.size());\n+    }\n+\n+    @Test\n+    public void shouldNotAlertIfAllRequestsAreForbidden() throws Exception {\n+        // Given\n+        String path = \"/forbidden/\";\n+        nano.addHandler(new ForbiddenResponse(path));\n+        HttpMessage msg = this.getHttpMessage(path);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(0));\n+        assertEquals(23, httpMessagesSent.size());\n+    }\n+\n+    @Test\n+    public void shouldAlertIfOkObtained() throws Exception {\n+        // Given\n+        nano.addHandler(new ForbiddenResponse(PROTECTED_PATH));\n+        nano.addHandler(new OkResponse(\"/.\" + PROTECTED_PATH)); // Period is %2e\n+        HttpMessage msg = this.getHttpMessage(PROTECTED_PATH);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(1));\n+        Alert alert = alertsRaised.get(0);\n+        assertEquals(\"/%2e\" + PROTECTED_PATH, alert.getAttack());\n+        raiseAlert(alert);\n+    }\n+\n+    @Test\n+    public void shouldAlertIfOkWithRewriteUrlHeader() throws Exception {\n+        // Given\n+        nano.addHandler(new ForbiddenResponse(PROTECTED_PATH));\n+        nano.addHandler(new RewriteUrlResponse(\"/anything\"));\n+        HttpMessage msg = this.getHttpMessage(PROTECTED_PATH);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(1));\n+        Alert alert = alertsRaised.get(0);\n+        assertEquals(\"X-Rewrite-URL: \" + PROTECTED_PATH, alert.getAttack());\n+        raiseAlert(alert);\n+    }\n+\n+    @Test\n+    public void shouldAlertIfOkWithRefererHeader() throws Exception {\n+        // Given\n+        nano.addHandler(new ForbiddenResponse(PROTECTED_PATH));\n+        nano.addHandler(new RefererResponse(\"/anything\"));\n+        HttpMessage msg = this.getHttpMessage(PROTECTED_PATH);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(1));\n+        Alert alert = alertsRaised.get(0);\n+        assertEquals(\"Referer: \" + PROTECTED_PATH, alert.getAttack());\n+        raiseAlert(alert);\n+    }\n+\n+    @Test\n+    public void shouldAlertIfOkWithOriginalUrlHeader() throws Exception {\n+        // Given\n+        nano.addHandler(new ForbiddenResponse(PROTECTED_PATH));\n+        nano.addHandler(new OriginalUrlResponse(\"/\"));\n+        HttpMessage msg = this.getHttpMessage(PROTECTED_PATH);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(1));\n+        Alert alert = alertsRaised.get(0);\n+        assertEquals(\"X-Original-URL: \" + PROTECTED_PATH, alert.getAttack());\n+        raiseAlert(alert);\n+    }\n+\n+    @Test\n+    public void shouldAlertIfOkWithCustomIpAuthorizationHeader() throws Exception {\n+        // Given\n+        nano.addHandler(new CustomIpAuthorizationResponse(PROTECTED_PATH));\n+        HttpMessage msg = this.getHttpMessage(PROTECTED_PATH);\n+        rule.init(msg, this.parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(alertsRaised, hasSize(1));\n+        Alert alert = alertsRaised.get(0);\n+        assertEquals(\"X-Custom-IP-Authorization: 127.0.0.1\", alert.getAttack());\n+        raiseAlert(alert);\n+    }\n+\n+    public void raiseAlert(Alert alert) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66adec8173e75097745688086e575fecd6ee2286"}, "originalPosition": 155}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 660, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}