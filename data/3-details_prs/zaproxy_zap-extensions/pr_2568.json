{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAxMTQwMDg4", "number": 2568, "title": "6203: Remove status code check in XXE, extract Local File Reflection and Local File Inclusion", "bodyText": "Extracted XXE Local File Reflection and Local File Inclusion to separate methods to enable unit testing.\nRemoved the check to parse response only when the status code is 200.\nResponse is now parsed for XXE reflection/inclution regardless of the status code.\nAdded unit tests.\nCloses zaproxy/zaproxy#6203", "createdAt": "2020-10-11T13:44:44Z", "url": "https://github.com/zaproxy/zap-extensions/pull/2568", "merged": true, "mergeCommit": {"oid": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5"}, "closed": true, "closedAt": "2020-11-10T13:06:12Z", "author": {"login": "ejayaraman"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdRo-tpgFqTUwNjIzMjc0OA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdbJDXqgFqTUyNzE4MTEzMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2MjMyNzQ4", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#pullrequestreview-506232748", "createdAt": "2020-10-12T00:11:10Z", "commit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDoxMToxMFrOHfrzlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwMDozMjo1NlrOHfr97Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTYyMg==", "bodyText": "Remove, no longer necessary.", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502985622", "createdAt": "2020-10-12T00:11:10Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTY0Mw==", "bodyText": "Go for it \ud83d\ude00", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502985643", "createdAt": "2020-10-12T00:11:26Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTczNQ==", "bodyText": "The blank and comment can be removed, it's in a separate method now, it obviously related to LFI.", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502985735", "createdAt": "2020-10-12T00:12:09Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTgxNw==", "bodyText": "These blanks and comment are no longer necessary.", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502985817", "createdAt": "2020-10-12T00:12:52Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTgyNA==", "bodyText": "Suggested change", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502985824", "createdAt": "2020-10-12T00:12:59Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTg4Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            // Check if the scan has been stopped\n          \n          \n            \n                            // if yes dispose resources and exit", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502985887", "createdAt": "2020-10-12T00:13:33Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTkwNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                // Dispose all resources", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502985905", "createdAt": "2020-10-12T00:13:42Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTk2Mg==", "bodyText": "Go for it.", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502985962", "createdAt": "2020-10-12T00:14:00Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources\n+                    // Exit the rule\n+                    return;\n+                }\n             }\n+\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n+\n+    // TODO: Add Doc Comments", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjAyMQ==", "bodyText": "Can be private. Will explain further while commenting on the other class.", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986021", "createdAt": "2020-10-12T00:14:37Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjE2Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            // msg = getNewMsg();", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986166", "createdAt": "2020-10-12T00:15:24Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources\n+                    // Exit the rule\n+                    return;\n+                }\n             }\n+\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n+\n+    // TODO: Add Doc Comments\n+    protected void localFileInclusionAttack(HttpMessage msg) {\n+        String localFile;\n+        String response;\n+        Matcher matcher;\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                // msg = getNewMsg();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjE4Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n                            // Send message with local file inclusion", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986183", "createdAt": "2020-10-12T00:15:36Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources\n+                    // Exit the rule\n+                    return;\n+                }\n             }\n+\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n+\n+    // TODO: Add Doc Comments\n+    protected void localFileInclusionAttack(HttpMessage msg) {\n+        String localFile;\n+        String response;\n+        Matcher matcher;\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 195}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjIxNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n                            // Parse the result", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986216", "createdAt": "2020-10-12T00:15:50Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources\n+                    // Exit the rule\n+                    return;\n+                }\n             }\n+\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n+\n+    // TODO: Add Doc Comments\n+    protected void localFileInclusionAttack(HttpMessage msg) {\n+        String localFile;\n+        String response;\n+        Matcher matcher;\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjIyNw==", "bodyText": "Suggested change", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986227", "createdAt": "2020-10-12T00:15:57Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources\n+                    // Exit the rule\n+                    return;\n+                }\n             }\n+\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n+\n+    // TODO: Add Doc Comments\n+    protected void localFileInclusionAttack(HttpMessage msg) {\n+        String localFile;\n+        String response;\n+        Matcher matcher;\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjI3OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n                            // Check if the scan has been stopped\n          \n          \n            \n                            // if yes dispose resources and exit\n          \n          \n            \n                            // Check if the scan has been stopped", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986278", "createdAt": "2020-10-12T00:16:17Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources\n+                    // Exit the rule\n+                    return;\n+                }\n             }\n+\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n+\n+    // TODO: Add Doc Comments\n+    protected void localFileInclusionAttack(HttpMessage msg) {\n+        String localFile;\n+        String response;\n+        Matcher matcher;\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjI4OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                // Dispose all resources", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986289", "createdAt": "2020-10-12T00:16:26Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources\n+                    // Exit the rule\n+                    return;\n+                }\n             }\n+\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n+\n+    // TODO: Add Doc Comments\n+    protected void localFileInclusionAttack(HttpMessage msg) {\n+        String localFile;\n+        String response;\n+        Matcher matcher;\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjMyNA==", "bodyText": "Suggested change", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986324", "createdAt": "2020-10-12T00:16:46Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources\n+                    // Exit the rule\n+                    return;\n+                }\n             }\n+\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n+\n+    // TODO: Add Doc Comments\n+    protected void localFileInclusionAttack(HttpMessage msg) {\n+        String localFile;\n+        String response;\n+        Matcher matcher;\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources\n+                    // Exit the rule\n+                    return;\n+                }\n+            }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjQ3OA==", "bodyText": "This seems to be used over and over again, It may as well be extracted to a local method, such as createNanoHandler. Then just used as this.nano.addHandler(createHandler());", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986478", "createdAt": "2020-10-12T00:18:14Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjU0NQ==", "bodyText": "Suggested change", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986545", "createdAt": "2020-10-12T00:18:57Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjU2Mg==", "bodyText": "Suggested change", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986562", "createdAt": "2020-10-12T00:19:06Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjU4Ng==", "bodyText": "Suggested change", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986586", "createdAt": "2020-10-12T00:19:19Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.scan();\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjcwMA==", "bodyText": "The blanks leading // When and // Then throughout can be removed, the comments already delineate things.", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986700", "createdAt": "2020-10-12T00:20:06Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.scan();\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(0));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4Njg0NQ==", "bodyText": "Is this an intentional mismatch?", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986845", "createdAt": "2020-10-12T00:21:25Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NzIzNQ==", "bodyText": "Throughout the new tests the scan method should be used. That ensures none of the payloads are misinterpreted.\nHowever, having the two test methods broken out in the scan rule allows for earlier troubleshooting and maintenance in the future so that was a worthy change (IMHO).", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502987235", "createdAt": "2020-10-12T00:24:51Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.scan();\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(0));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NzM1MQ==", "bodyText": "The number of messages sent should already be being tested as part of the generalized Strength tests.\nEdit: So I believe this one can be removed.", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502987351", "createdAt": "2020-10-12T00:25:38Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.scan();\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(0));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NzczNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n          \n          \n            \n                    assertThat(\n          \n          \n            \n                            alertsRaised.get(0).getAttack(),\n          \n          \n            \n                            equalTo(\n          \n          \n            \n                                    MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n          \n          \n            \n                                            + XxeScanRule.ATTACK_BODY));\n          \n          \n            \n                    assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n          \n          \n            \n                    assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n          \n          \n            \n                    Alert alert = alertsRaised.get(0);\n          \n          \n            \n                    assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n          \n          \n            \n                    assertThat(\n          \n          \n            \n                            alert.getAttack(),\n          \n          \n            \n                            equalTo(\n          \n          \n            \n                                    MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n          \n          \n            \n                                            + XxeScanRule.ATTACK_BODY));\n          \n          \n            \n                    assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n          \n          \n            \n                    assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n          \n      \n    \n    \n  \n\nThis likely applies elsewhere as well.", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502987737", "createdAt": "2020-10-12T00:28:27Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.scan();\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(0));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(3));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n+            throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        parent.stop();\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(alertsRaised.size(), equalTo(1));\n+        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(\n+                alertsRaised.get(0).getAttack(),\n+                equalTo(\n+                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                                + \"<comment><text>&zapxxe;</text></comment>\"));\n+        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    @Test\n+    public void shouldStopLocalFileReflectionRuleIfScanIsStopped() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        parent.stop();\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(1));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileInclusionRule() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileInclusionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(3));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+            throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response = \"root:*:0:0:System Administrator:/var/root:/bin/sh\";\n+                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileInclusionAttack(msg);\n+\n+        // Then\n+        assertThat(alertsRaised.size(), equalTo(1));\n+        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(\n+                alertsRaised.get(0).getAttack(),\n+                equalTo(\n+                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                                + XxeScanRule.ATTACK_BODY));\n+        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4ODI2OQ==", "bodyText": "This test is an interesting idea, however, I'm not sure it'll behave properly if When is rule.scan and parent.stop() was issued in Given.\n@thc202? @psiinon?", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502988269", "createdAt": "2020-10-12T00:32:56Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.scan();\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(0));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(3));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n+            throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        parent.stop();\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(alertsRaised.size(), equalTo(1));\n+        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(\n+                alertsRaised.get(0).getAttack(),\n+                equalTo(\n+                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                                + \"<comment><text>&zapxxe;</text></comment>\"));\n+        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    @Test\n+    public void shouldStopLocalFileReflectionRuleIfScanIsStopped() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        parent.stop();\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(1));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileInclusionRule() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileInclusionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(3));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+            throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response = \"root:*:0:0:System Administrator:/var/root:/bin/sh\";\n+                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileInclusionAttack(msg);\n+\n+        // Then\n+        assertThat(alertsRaised.size(), equalTo(1));\n+        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(\n+                alertsRaised.get(0).getAttack(),\n+                equalTo(\n+                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                                + XxeScanRule.ATTACK_BODY));\n+        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    @Test\n+    public void shouldStopLocalFileInclusionRuleIfScanIsStopped() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        parent.stop();\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileInclusionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(1));\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5"}, "originalPosition": 248}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "28af3c43d0f33b370234833a162f0cd8827601f5", "author": {"user": {"login": "ejayaraman", "name": "Eswarprasath Jayaraman"}}, "url": "https://github.com/zaproxy/zap-extensions/commit/28af3c43d0f33b370234833a162f0cd8827601f5", "committedDate": "2020-10-11T14:22:12Z", "message": "6203:  Added unit tests missed in previous commit\nFixed formatting with spotlessApply."}, "afterCommit": {"oid": "10de60d241a1143dc4c3717cb7a0e1bb870823be", "author": {"user": {"login": "ejayaraman", "name": "Eswarprasath Jayaraman"}}, "url": "https://github.com/zaproxy/zap-extensions/commit/10de60d241a1143dc4c3717cb7a0e1bb870823be", "committedDate": "2020-10-15T20:04:24Z", "message": "ISSUE-6203: XXE Scan rule updated to parse response irresspective of status code.\nWhen extension callback is not available only XXE Remote file inclusion attack is skipped.\nAdded unit tests\n\nSigned-off-by: ejayaraman <7340261+ejayaraman@users.noreply.github.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "10de60d241a1143dc4c3717cb7a0e1bb870823be", "author": {"user": {"login": "ejayaraman", "name": "Eswarprasath Jayaraman"}}, "url": "https://github.com/zaproxy/zap-extensions/commit/10de60d241a1143dc4c3717cb7a0e1bb870823be", "committedDate": "2020-10-15T20:04:24Z", "message": "ISSUE-6203: XXE Scan rule updated to parse response irresspective of status code.\nWhen extension callback is not available only XXE Remote file inclusion attack is skipped.\nAdded unit tests\n\nSigned-off-by: ejayaraman <7340261+ejayaraman@users.noreply.github.com>"}, "afterCommit": {"oid": "5a73de1287b5c925621671e7553924fc32dd656a", "author": {"user": {"login": "ejayaraman", "name": "Eswarprasath Jayaraman"}}, "url": "https://github.com/zaproxy/zap-extensions/commit/5a73de1287b5c925621671e7553924fc32dd656a", "committedDate": "2020-10-15T20:12:07Z", "message": "ISSUE-6203: XXE Scan rule updated to parse response irresspective of status code.\nWhen extension callback is not available only XXE Remote file inclusion attack is skipped.\nAdded unit tests\n\nSigned-off-by: ejayaraman <7340261+ejayaraman@users.noreply.github.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODE5MDMz", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#pullrequestreview-510819033", "createdAt": "2020-10-16T21:55:01Z", "commit": {"oid": "5a73de1287b5c925621671e7553924fc32dd656a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODIwMzM0", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#pullrequestreview-510820334", "createdAt": "2020-10-16T21:58:40Z", "commit": {"oid": "5a73de1287b5c925621671e7553924fc32dd656a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODIxMDIy", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#pullrequestreview-510821022", "createdAt": "2020-10-16T22:00:24Z", "commit": {"oid": "5a73de1287b5c925621671e7553924fc32dd656a"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5a73de1287b5c925621671e7553924fc32dd656a", "author": {"user": {"login": "ejayaraman", "name": "Eswarprasath Jayaraman"}}, "url": "https://github.com/zaproxy/zap-extensions/commit/5a73de1287b5c925621671e7553924fc32dd656a", "committedDate": "2020-10-15T20:12:07Z", "message": "ISSUE-6203: XXE Scan rule updated to parse response irresspective of status code.\nWhen extension callback is not available only XXE Remote file inclusion attack is skipped.\nAdded unit tests\n\nSigned-off-by: ejayaraman <7340261+ejayaraman@users.noreply.github.com>"}, "afterCommit": {"oid": "29cf52d5bc300ca0f5729f0bb599771d725ed344", "author": {"user": {"login": "ejayaraman", "name": "Eswarprasath Jayaraman"}}, "url": "https://github.com/zaproxy/zap-extensions/commit/29cf52d5bc300ca0f5729f0bb599771d725ed344", "committedDate": "2020-10-17T13:55:08Z", "message": "Removed blank lines.\n\nSigned-off-by: ejayaraman <7340261+ejayaraman@users.noreply.github.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0ODQ5OTg2", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#pullrequestreview-514849986", "createdAt": "2020-10-22T15:24:19Z", "commit": {"oid": "29cf52d5bc300ca0f5729f0bb599771d725ed344"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxNToyNDoyMFrOHmnS_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxNToyNDoyMFrOHmnS_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI1MTc3Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ## Unreleased\n          \n          \n            \n             - XML External Entity Attack scan rule updated to parse response body irrespective of the HTTP response status code. (Issue 6203) \n          \n          \n            \n            ## Unreleased\n          \n          \n            \n            ### Changed.\n          \n          \n            \n             - XML External Entity Attack scan rule updated to parse response body irrespective of the HTTP response status code. (Issue 6203)", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r510251772", "createdAt": "2020-10-22T15:24:20Z", "author": {"login": "kingthorin"}, "path": "addOns/ascanrulesBeta/CHANGELOG.md", "diffHunk": "@@ -4,6 +4,7 @@ All notable changes to this add-on will be documented in this file.\n The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/).\n \n ## Unreleased\n+ - XML External Entity Attack scan rule updated to parse response body irrespective of the HTTP response status code. (Issue 6203) ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29cf52d5bc300ca0f5729f0bb599771d725ed344"}, "originalPosition": 4}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "29cf52d5bc300ca0f5729f0bb599771d725ed344", "author": {"user": {"login": "ejayaraman", "name": "Eswarprasath Jayaraman"}}, "url": "https://github.com/zaproxy/zap-extensions/commit/29cf52d5bc300ca0f5729f0bb599771d725ed344", "committedDate": "2020-10-17T13:55:08Z", "message": "Removed blank lines.\n\nSigned-off-by: ejayaraman <7340261+ejayaraman@users.noreply.github.com>"}, "afterCommit": {"oid": "9229f2da87b2eac652396f84f589a4df857495e7", "author": {"user": {"login": "ejayaraman", "name": "Eswarprasath Jayaraman"}}, "url": "https://github.com/zaproxy/zap-extensions/commit/9229f2da87b2eac652396f84f589a4df857495e7", "committedDate": "2020-10-28T21:16:25Z", "message": "Refactor XXE Scan Rule to extract Local File Reflection and Local File Inclusion\n\nSigned-off-by: ejayaraman <7340261+ejayaraman@users.noreply.github.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1ODYyNzgy", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#pullrequestreview-525862782", "createdAt": "2020-11-09T00:18:11Z", "commit": {"oid": "9229f2da87b2eac652396f84f589a4df857495e7"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f1cf427f4b223e3659b6e383ad0a4b8ebe2d5ec", "author": {"user": {"login": "ejayaraman", "name": "Eswarprasath Jayaraman"}}, "url": "https://github.com/zaproxy/zap-extensions/commit/6f1cf427f4b223e3659b6e383ad0a4b8ebe2d5ec", "committedDate": "2020-11-09T17:27:45Z", "message": "XML External Entity Attack scan rule changed to skip only Remote File Inclusion Attack when Callback extension is not available\n\nSigned-off-by: ejayaraman <7340261+ejayaraman@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "380a0995ce8dd79e5596ae680e57849d85e5f447", "author": {"user": {"login": "ejayaraman", "name": "Eswarprasath Jayaraman"}}, "url": "https://github.com/zaproxy/zap-extensions/commit/380a0995ce8dd79e5596ae680e57849d85e5f447", "committedDate": "2020-11-09T17:28:10Z", "message": "XML External Entity Attack scan rule changed to parse response body irrespective of the HTTP response status code\n\nSigned-off-by: ejayaraman <7340261+ejayaraman@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f06a9bb670792320ea21f2536832a87344616516", "author": {"user": {"login": "ejayaraman", "name": "Eswarprasath Jayaraman"}}, "url": "https://github.com/zaproxy/zap-extensions/commit/f06a9bb670792320ea21f2536832a87344616516", "committedDate": "2020-11-09T17:28:10Z", "message": "Refactor XXE Scan Rule to extract Local File Reflection and Local File Inclusion\n\nSigned-off-by: ejayaraman <7340261+ejayaraman@users.noreply.github.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9229f2da87b2eac652396f84f589a4df857495e7", "author": {"user": {"login": "ejayaraman", "name": "Eswarprasath Jayaraman"}}, "url": "https://github.com/zaproxy/zap-extensions/commit/9229f2da87b2eac652396f84f589a4df857495e7", "committedDate": "2020-10-28T21:16:25Z", "message": "Refactor XXE Scan Rule to extract Local File Reflection and Local File Inclusion\n\nSigned-off-by: ejayaraman <7340261+ejayaraman@users.noreply.github.com>"}, "afterCommit": {"oid": "f06a9bb670792320ea21f2536832a87344616516", "author": {"user": {"login": "ejayaraman", "name": "Eswarprasath Jayaraman"}}, "url": "https://github.com/zaproxy/zap-extensions/commit/f06a9bb670792320ea21f2536832a87344616516", "committedDate": "2020-11-09T17:28:10Z", "message": "Refactor XXE Scan Rule to extract Local File Reflection and Local File Inclusion\n\nSigned-off-by: ejayaraman <7340261+ejayaraman@users.noreply.github.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NTAwMzc0", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#pullrequestreview-526500374", "createdAt": "2020-11-09T17:43:52Z", "commit": {"oid": "f06a9bb670792320ea21f2536832a87344616516"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3MTgxMTMy", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#pullrequestreview-527181132", "createdAt": "2020-11-10T13:06:01Z", "commit": {"oid": "f06a9bb670792320ea21f2536832a87344616516"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 312, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}