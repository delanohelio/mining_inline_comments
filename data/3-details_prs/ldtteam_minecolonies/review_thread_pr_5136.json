{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI2Mjc1NzYz", "number": 5136, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNzozOToxOFrOEBoSrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxMjozNjoyMlrOEDO8Cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMTQ0MTc1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "isResolved": false, "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNzozOToxOFrOGdlsig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMTowNToyMVrOGdstdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY3OTQ5OA==", "bodyText": "I don't think all this dump inventory code here is necessary?", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433679498", "createdAt": "2020-06-02T07:39:18Z", "author": {"login": "Raycoms"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -300,6 +311,65 @@ private IAIState findTrees()\n         return LUMBERJACK_CHOP_TREE;\n     }\n \n+    @NotNull\n+    @Override\n+    protected IAIState dumpInventory() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5ebcbcccbb5c95148b8bf58cbf903f3865d2e09"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcxMjcyOA==", "bodyText": "The problem is that the worker can get stuck when a tree grows around him while he is choking down a tree, so when he then tries to bring the items back I need to check if he is stuck.\nI can reduce it to only the first few lines and then call the super dumpInventory function", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433712728", "createdAt": "2020-06-02T08:37:30Z", "author": {"login": "Tobiti"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -300,6 +311,65 @@ private IAIState findTrees()\n         return LUMBERJACK_CHOP_TREE;\n     }\n \n+    @NotNull\n+    @Override\n+    protected IAIState dumpInventory() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY3OTQ5OA=="}, "originalCommit": {"oid": "c5ebcbcccbb5c95148b8bf58cbf903f3865d2e09"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcxNDU4Nw==", "bodyText": "did you test this? Because normally the AI should shut down completely when the head is in the leaves", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433714587", "createdAt": "2020-06-02T08:40:35Z", "author": {"login": "Raycoms"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -300,6 +311,65 @@ private IAIState findTrees()\n         return LUMBERJACK_CHOP_TREE;\n     }\n \n+    @NotNull\n+    @Override\n+    protected IAIState dumpInventory() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY3OTQ5OA=="}, "originalCommit": {"oid": "c5ebcbcccbb5c95148b8bf58cbf903f3865d2e09"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc0MTA1OQ==", "bodyText": "I tested it some minutes ago and its working fine :)", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433741059", "createdAt": "2020-06-02T09:24:51Z", "author": {"login": "Tobiti"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -300,6 +311,65 @@ private IAIState findTrees()\n         return LUMBERJACK_CHOP_TREE;\n     }\n \n+    @NotNull\n+    @Override\n+    protected IAIState dumpInventory() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY3OTQ5OA=="}, "originalCommit": {"oid": "c5ebcbcccbb5c95148b8bf58cbf903f3865d2e09"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc2NzU0Ng==", "bodyText": "shouldn't be necessary to copy all this code here though. If anything then you should put this in the walkToBlock override and not in copied functions.", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433767546", "createdAt": "2020-06-02T10:10:46Z", "author": {"login": "Raycoms"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -300,6 +311,65 @@ private IAIState findTrees()\n         return LUMBERJACK_CHOP_TREE;\n     }\n \n+    @NotNull\n+    @Override\n+    protected IAIState dumpInventory() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY3OTQ5OA=="}, "originalCommit": {"oid": "c5ebcbcccbb5c95148b8bf58cbf903f3865d2e09"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4NDU4NQ==", "bodyText": "But then I need to copy everything to the EntityCitizenWalkToProxy class", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433784585", "createdAt": "2020-06-02T10:45:11Z", "author": {"login": "Tobiti"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -300,6 +311,65 @@ private IAIState findTrees()\n         return LUMBERJACK_CHOP_TREE;\n     }\n \n+    @NotNull\n+    @Override\n+    protected IAIState dumpInventory() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY3OTQ5OA=="}, "originalCommit": {"oid": "c5ebcbcccbb5c95148b8bf58cbf903f3865d2e09"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4ODExMQ==", "bodyText": "The problem is that its final", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433788111", "createdAt": "2020-06-02T10:52:25Z", "author": {"login": "Tobiti"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -300,6 +311,65 @@ private IAIState findTrees()\n         return LUMBERJACK_CHOP_TREE;\n     }\n \n+    @NotNull\n+    @Override\n+    protected IAIState dumpInventory() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY3OTQ5OA=="}, "originalCommit": {"oid": "c5ebcbcccbb5c95148b8bf58cbf903f3865d2e09"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4ODIxNA==", "bodyText": "I will change that and override the function", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433788214", "createdAt": "2020-06-02T10:52:41Z", "author": {"login": "Tobiti"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -300,6 +311,65 @@ private IAIState findTrees()\n         return LUMBERJACK_CHOP_TREE;\n     }\n \n+    @NotNull\n+    @Override\n+    protected IAIState dumpInventory() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY3OTQ5OA=="}, "originalCommit": {"oid": "c5ebcbcccbb5c95148b8bf58cbf903f3865d2e09"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4OTg2OQ==", "bodyText": "ye", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433789869", "createdAt": "2020-06-02T10:56:02Z", "author": {"login": "Raycoms"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -300,6 +311,65 @@ private IAIState findTrees()\n         return LUMBERJACK_CHOP_TREE;\n     }\n \n+    @NotNull\n+    @Override\n+    protected IAIState dumpInventory() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY3OTQ5OA=="}, "originalCommit": {"oid": "c5ebcbcccbb5c95148b8bf58cbf903f3865d2e09"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc5MTM5NA==", "bodyText": "Still have the problem for the dumpInventory function, because its not calling the walkToBlock function of the ai\nInstead its calling this function on the worker:", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433791394", "createdAt": "2020-06-02T10:58:58Z", "author": {"login": "Tobiti"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -300,6 +311,65 @@ private IAIState findTrees()\n         return LUMBERJACK_CHOP_TREE;\n     }\n \n+    @NotNull\n+    @Override\n+    protected IAIState dumpInventory() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY3OTQ5OA=="}, "originalCommit": {"oid": "c5ebcbcccbb5c95148b8bf58cbf903f3865d2e09"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc5MjA5Mw==", "bodyText": "Am I allowed to change it in the abstract class to the walkToBlock funtion?", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433792093", "createdAt": "2020-06-02T11:00:21Z", "author": {"login": "Tobiti"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -300,6 +311,65 @@ private IAIState findTrees()\n         return LUMBERJACK_CHOP_TREE;\n     }\n \n+    @NotNull\n+    @Override\n+    protected IAIState dumpInventory() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY3OTQ5OA=="}, "originalCommit": {"oid": "c5ebcbcccbb5c95148b8bf58cbf903f3865d2e09"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc5MjUwNQ==", "bodyText": "and the walkToBlock on the AI, calls this also doesn't it? So we just redirect the dump call to this one.", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433792505", "createdAt": "2020-06-02T11:01:09Z", "author": {"login": "Raycoms"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -300,6 +311,65 @@ private IAIState findTrees()\n         return LUMBERJACK_CHOP_TREE;\n     }\n \n+    @NotNull\n+    @Override\n+    protected IAIState dumpInventory() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY3OTQ5OA=="}, "originalCommit": {"oid": "c5ebcbcccbb5c95148b8bf58cbf903f3865d2e09"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc5MzA2OA==", "bodyText": "Its nearly the same", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433793068", "createdAt": "2020-06-02T11:02:24Z", "author": {"login": "Tobiti"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -300,6 +311,65 @@ private IAIState findTrees()\n         return LUMBERJACK_CHOP_TREE;\n     }\n \n+    @NotNull\n+    @Override\n+    protected IAIState dumpInventory() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY3OTQ5OA=="}, "originalCommit": {"oid": "c5ebcbcccbb5c95148b8bf58cbf903f3865d2e09"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc5Mzc2MA==", "bodyText": "it returns the opposite though. So you have to take that into account.", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433793760", "createdAt": "2020-06-02T11:03:53Z", "author": {"login": "Raycoms"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -300,6 +311,65 @@ private IAIState findTrees()\n         return LUMBERJACK_CHOP_TREE;\n     }\n \n+    @NotNull\n+    @Override\n+    protected IAIState dumpInventory() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY3OTQ5OA=="}, "originalCommit": {"oid": "c5ebcbcccbb5c95148b8bf58cbf903f3865d2e09"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc5NDQyMw==", "bodyText": "I can just remove the ! in dumpInventory :)", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433794423", "createdAt": "2020-06-02T11:05:21Z", "author": {"login": "Tobiti"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -300,6 +311,65 @@ private IAIState findTrees()\n         return LUMBERJACK_CHOP_TREE;\n     }\n \n+    @NotNull\n+    @Override\n+    protected IAIState dumpInventory() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY3OTQ5OA=="}, "originalCommit": {"oid": "c5ebcbcccbb5c95148b8bf58cbf903f3865d2e09"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjUyOTQ0OnYy", "diffSide": "LEFT", "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMzowMTowMFrOGdweJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMzowMTowMFrOGdweJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1NjAzNw==", "bodyText": "I think all you needed to add for the unstuck to work better is here to add  BlockPos nextPosUpUp = new BlockPos(next.x, next.y + 2, next.z); as it gets stuck in cases where it needs space to change height.", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433856037", "createdAt": "2020-06-02T13:01:00Z", "author": {"login": "someaddons"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -544,31 +565,93 @@ private Boolean isPassable(final BlockState blockState)\n         return blockState.getMaterial() == Material.LEAVES;\n     }\n \n+\n     /**\n      * Check if distance to block changed and if we are not moving for too long, try to get unstuck.\n      *\n      * @return false\n      */\n-    private boolean checkIfStuckOnLeaves()\n+    private boolean checkIfStuck()\n     {\n         if (!worker.getNavigator().noPath())\n         {\n-            Path pathToTree = worker.getNavigator().getPath();\n-            if (pathToTree != null && pathToTree.getCurrentPathLength() > pathToTree.getCurrentPathIndex())\n-            {\n-                PathPoint next = pathToTree.getPathPointFromIndex(pathToTree.getCurrentPathIndex());\n-                BlockPos nextPos = new BlockPos(next.x, next.y, next.z);\n-                BlockPos nextPosUp = new BlockPos(next.x, next.y + 1, next.z);\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "feaafc886f3a41303244eac4036859599653dfaa"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjUzMDUyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMzowMToxNVrOGdwezg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNDoyMTozMlrOGd0HPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1NjIwNg==", "bodyText": "see my comment above, this shouldnt be here at all", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433856206", "createdAt": "2020-06-02T13:01:15Z", "author": {"login": "someaddons"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -227,6 +235,17 @@ protected IAIState decide()\n         return GET_RECIPE;\n     }\n \n+    @Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "feaafc886f3a41303244eac4036859599653dfaa"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkxNTcwOA==", "bodyText": "Done", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433915708", "createdAt": "2020-06-02T14:21:32Z", "author": {"login": "Tobiti"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -227,6 +235,17 @@ protected IAIState decide()\n         return GET_RECIPE;\n     }\n \n+    @Override", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1NjIwNg=="}, "originalCommit": {"oid": "feaafc886f3a41303244eac4036859599653dfaa"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjUzNjQzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMzowMjo0M1rOGdwiZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNDoxMzowOVrOGdzvCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1NzEyNw==", "bodyText": "we are already using the pathing to see which leaves need to be removed, I don't think we need this general remove all around worker", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433857127", "createdAt": "2020-06-02T13:02:43Z", "author": {"login": "someaddons"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -544,31 +565,93 @@ private Boolean isPassable(final BlockState blockState)\n         return blockState.getMaterial() == Material.LEAVES;\n     }\n \n+\n     /**\n      * Check if distance to block changed and if we are not moving for too long, try to get unstuck.\n      *\n      * @return false\n      */\n-    private boolean checkIfStuckOnLeaves()\n+    private boolean checkIfStuck()\n     {\n         if (!worker.getNavigator().noPath())\n         {\n-            Path pathToTree = worker.getNavigator().getPath();\n-            if (pathToTree != null && pathToTree.getCurrentPathLength() > pathToTree.getCurrentPathIndex())\n-            {\n-                PathPoint next = pathToTree.getPathPointFromIndex(pathToTree.getCurrentPathIndex());\n-                BlockPos nextPos = new BlockPos(next.x, next.y, next.z);\n-                BlockPos nextPosUp = new BlockPos(next.x, next.y + 1, next.z);\n-\n-                if (world.getBlockState(nextPos).getBlock().isIn(BlockTags.LEAVES))\n-                {\n-                    mineBlock(nextPos);\n+            Path path = worker.getNavigator().getPath();\n+            if(path != null) {\n+                if (path.getCurrentPathLength() > path.getCurrentPathIndex()) {\n+                    return true;\n                 }\n-                else if (world.getBlockState(nextPosUp).getBlock().isIn(BlockTags.LEAVES))\n-                {\n-                    mineBlock(nextPosUp);\n+                if(path.getCurrentPathLength() == 0){\n+                    return true;\n                 }\n             }\n+            else {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Mines leaves on path and above.\n+     */\n+    private void tryUnstuck(){\n+\n+        if (!worker.getNavigator().noPath()) {\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null) {\n+                // Unstuck with path\n+                ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+                PathPoint next = path.getPathPointFromIndex(path.getCurrentPathIndex());\n+                // Blocks in front of the worker\n+                checkPositions.add(new BlockPos(next.x, next.y, next.z));\n+                checkPositions.add(new BlockPos(next.x, next.y + 1, next.z));\n+                // Block above the worker\n+                checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 2, worker.getCurrentPosition().getZ()));\n+\n+                mineIfEqualsBlockTag(checkPositions, BlockTags.LEAVES);\n+                return;\n+            }\n+        }\n+\n+        // General unstuck\n+        ArrayList<BlockPos> checkPositions = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "feaafc886f3a41303244eac4036859599653dfaa"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkwOTUxNA==", "bodyText": "But you dont have always a path, sometimes the path is empty or null", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433909514", "createdAt": "2020-06-02T14:13:09Z", "author": {"login": "Tobiti"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -544,31 +565,93 @@ private Boolean isPassable(final BlockState blockState)\n         return blockState.getMaterial() == Material.LEAVES;\n     }\n \n+\n     /**\n      * Check if distance to block changed and if we are not moving for too long, try to get unstuck.\n      *\n      * @return false\n      */\n-    private boolean checkIfStuckOnLeaves()\n+    private boolean checkIfStuck()\n     {\n         if (!worker.getNavigator().noPath())\n         {\n-            Path pathToTree = worker.getNavigator().getPath();\n-            if (pathToTree != null && pathToTree.getCurrentPathLength() > pathToTree.getCurrentPathIndex())\n-            {\n-                PathPoint next = pathToTree.getPathPointFromIndex(pathToTree.getCurrentPathIndex());\n-                BlockPos nextPos = new BlockPos(next.x, next.y, next.z);\n-                BlockPos nextPosUp = new BlockPos(next.x, next.y + 1, next.z);\n-\n-                if (world.getBlockState(nextPos).getBlock().isIn(BlockTags.LEAVES))\n-                {\n-                    mineBlock(nextPos);\n+            Path path = worker.getNavigator().getPath();\n+            if(path != null) {\n+                if (path.getCurrentPathLength() > path.getCurrentPathIndex()) {\n+                    return true;\n                 }\n-                else if (world.getBlockState(nextPosUp).getBlock().isIn(BlockTags.LEAVES))\n-                {\n-                    mineBlock(nextPosUp);\n+                if(path.getCurrentPathLength() == 0){\n+                    return true;\n                 }\n             }\n+            else {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Mines leaves on path and above.\n+     */\n+    private void tryUnstuck(){\n+\n+        if (!worker.getNavigator().noPath()) {\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null) {\n+                // Unstuck with path\n+                ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+                PathPoint next = path.getPathPointFromIndex(path.getCurrentPathIndex());\n+                // Blocks in front of the worker\n+                checkPositions.add(new BlockPos(next.x, next.y, next.z));\n+                checkPositions.add(new BlockPos(next.x, next.y + 1, next.z));\n+                // Block above the worker\n+                checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 2, worker.getCurrentPosition().getZ()));\n+\n+                mineIfEqualsBlockTag(checkPositions, BlockTags.LEAVES);\n+                return;\n+            }\n+        }\n+\n+        // General unstuck\n+        ArrayList<BlockPos> checkPositions = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1NzEyNw=="}, "originalCommit": {"oid": "feaafc886f3a41303244eac4036859599653dfaa"}, "originalPosition": 173}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjUzOTk1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMzowMzo0M1rOGdwkrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxOTowMjo1MVrOGeAC5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1NzcxMQ==", "bodyText": "This function isnt going to work nicely like this, because our mineBlock() is made to mine one position after another as it works through repeated calls and a delay inbetween", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433857711", "createdAt": "2020-06-02T13:03:43Z", "author": {"login": "someaddons"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -544,31 +565,93 @@ private Boolean isPassable(final BlockState blockState)\n         return blockState.getMaterial() == Material.LEAVES;\n     }\n \n+\n     /**\n      * Check if distance to block changed and if we are not moving for too long, try to get unstuck.\n      *\n      * @return false\n      */\n-    private boolean checkIfStuckOnLeaves()\n+    private boolean checkIfStuck()\n     {\n         if (!worker.getNavigator().noPath())\n         {\n-            Path pathToTree = worker.getNavigator().getPath();\n-            if (pathToTree != null && pathToTree.getCurrentPathLength() > pathToTree.getCurrentPathIndex())\n-            {\n-                PathPoint next = pathToTree.getPathPointFromIndex(pathToTree.getCurrentPathIndex());\n-                BlockPos nextPos = new BlockPos(next.x, next.y, next.z);\n-                BlockPos nextPosUp = new BlockPos(next.x, next.y + 1, next.z);\n-\n-                if (world.getBlockState(nextPos).getBlock().isIn(BlockTags.LEAVES))\n-                {\n-                    mineBlock(nextPos);\n+            Path path = worker.getNavigator().getPath();\n+            if(path != null) {\n+                if (path.getCurrentPathLength() > path.getCurrentPathIndex()) {\n+                    return true;\n                 }\n-                else if (world.getBlockState(nextPosUp).getBlock().isIn(BlockTags.LEAVES))\n-                {\n-                    mineBlock(nextPosUp);\n+                if(path.getCurrentPathLength() == 0){\n+                    return true;\n                 }\n             }\n+            else {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Mines leaves on path and above.\n+     */\n+    private void tryUnstuck(){\n+\n+        if (!worker.getNavigator().noPath()) {\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null) {\n+                // Unstuck with path\n+                ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+                PathPoint next = path.getPathPointFromIndex(path.getCurrentPathIndex());\n+                // Blocks in front of the worker\n+                checkPositions.add(new BlockPos(next.x, next.y, next.z));\n+                checkPositions.add(new BlockPos(next.x, next.y + 1, next.z));\n+                // Block above the worker\n+                checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 2, worker.getCurrentPosition().getZ()));\n+\n+                mineIfEqualsBlockTag(checkPositions, BlockTags.LEAVES);\n+                return;\n+            }\n+        }\n+\n+        // General unstuck\n+        ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+        // Blocks in front of the worker\n+        checkPositions.add(new BlockPos(worker.getForward().getX(), worker.getForward().getY(), worker.getForward().getZ()));\n+        checkPositions.add(new BlockPos(worker.getForward().getX(), worker.getForward().getY() + 1, worker.getForward().getZ()));\n+\n+        // blocks in north of the player\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY(), worker.getCurrentPosition().getZ()).north());\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 1, worker.getCurrentPosition().getZ()).north());\n+\n+        // blocks in east of the player\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY(), worker.getCurrentPosition().getZ()).east());\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 1, worker.getCurrentPosition().getZ()).east());\n+\n+        // blocks in south of the player\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY(), worker.getCurrentPosition().getZ()).south());\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 1, worker.getCurrentPosition().getZ()).south());\n+\n+        // blocks in west of the player\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY(), worker.getCurrentPosition().getZ()).west());\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 1, worker.getCurrentPosition().getZ()).west());\n+\n+        mineIfEqualsBlockTag(checkPositions, BlockTags.LEAVES);\n+    }\n+\n+    /**\n+     * Checks blocks for tag and mines the first it fines if its the same\n+     * @param blockPositions block positions\n+     * @param tag tag to check\n+     */\n+    private boolean mineIfEqualsBlockTag(List<BlockPos> blockPositions, Tag<Block> tag){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "feaafc886f3a41303244eac4036859599653dfaa"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkxMjE1Mg==", "bodyText": "Why?\nIts only adding one block per call", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433912152", "createdAt": "2020-06-02T14:16:47Z", "author": {"login": "Tobiti"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -544,31 +565,93 @@ private Boolean isPassable(final BlockState blockState)\n         return blockState.getMaterial() == Material.LEAVES;\n     }\n \n+\n     /**\n      * Check if distance to block changed and if we are not moving for too long, try to get unstuck.\n      *\n      * @return false\n      */\n-    private boolean checkIfStuckOnLeaves()\n+    private boolean checkIfStuck()\n     {\n         if (!worker.getNavigator().noPath())\n         {\n-            Path pathToTree = worker.getNavigator().getPath();\n-            if (pathToTree != null && pathToTree.getCurrentPathLength() > pathToTree.getCurrentPathIndex())\n-            {\n-                PathPoint next = pathToTree.getPathPointFromIndex(pathToTree.getCurrentPathIndex());\n-                BlockPos nextPos = new BlockPos(next.x, next.y, next.z);\n-                BlockPos nextPosUp = new BlockPos(next.x, next.y + 1, next.z);\n-\n-                if (world.getBlockState(nextPos).getBlock().isIn(BlockTags.LEAVES))\n-                {\n-                    mineBlock(nextPos);\n+            Path path = worker.getNavigator().getPath();\n+            if(path != null) {\n+                if (path.getCurrentPathLength() > path.getCurrentPathIndex()) {\n+                    return true;\n                 }\n-                else if (world.getBlockState(nextPosUp).getBlock().isIn(BlockTags.LEAVES))\n-                {\n-                    mineBlock(nextPosUp);\n+                if(path.getCurrentPathLength() == 0){\n+                    return true;\n                 }\n             }\n+            else {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Mines leaves on path and above.\n+     */\n+    private void tryUnstuck(){\n+\n+        if (!worker.getNavigator().noPath()) {\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null) {\n+                // Unstuck with path\n+                ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+                PathPoint next = path.getPathPointFromIndex(path.getCurrentPathIndex());\n+                // Blocks in front of the worker\n+                checkPositions.add(new BlockPos(next.x, next.y, next.z));\n+                checkPositions.add(new BlockPos(next.x, next.y + 1, next.z));\n+                // Block above the worker\n+                checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 2, worker.getCurrentPosition().getZ()));\n+\n+                mineIfEqualsBlockTag(checkPositions, BlockTags.LEAVES);\n+                return;\n+            }\n+        }\n+\n+        // General unstuck\n+        ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+        // Blocks in front of the worker\n+        checkPositions.add(new BlockPos(worker.getForward().getX(), worker.getForward().getY(), worker.getForward().getZ()));\n+        checkPositions.add(new BlockPos(worker.getForward().getX(), worker.getForward().getY() + 1, worker.getForward().getZ()));\n+\n+        // blocks in north of the player\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY(), worker.getCurrentPosition().getZ()).north());\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 1, worker.getCurrentPosition().getZ()).north());\n+\n+        // blocks in east of the player\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY(), worker.getCurrentPosition().getZ()).east());\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 1, worker.getCurrentPosition().getZ()).east());\n+\n+        // blocks in south of the player\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY(), worker.getCurrentPosition().getZ()).south());\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 1, worker.getCurrentPosition().getZ()).south());\n+\n+        // blocks in west of the player\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY(), worker.getCurrentPosition().getZ()).west());\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 1, worker.getCurrentPosition().getZ()).west());\n+\n+        mineIfEqualsBlockTag(checkPositions, BlockTags.LEAVES);\n+    }\n+\n+    /**\n+     * Checks blocks for tag and mines the first it fines if its the same\n+     * @param blockPositions block positions\n+     * @param tag tag to check\n+     */\n+    private boolean mineIfEqualsBlockTag(List<BlockPos> blockPositions, Tag<Block> tag){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1NzcxMQ=="}, "originalCommit": {"oid": "feaafc886f3a41303244eac4036859599653dfaa"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDAzODY5Nw==", "bodyText": "ye one block per call isnt enough, you need to call the same position twice, with a time delay inbetween. It simulates the harvesting with a delay before actually breaking the block. Since the AI repeatedly executes this code. You should do if(leaf) mine(leaf) and then you do nothing but wait for the next time it runs into it again, and you check for the first leaf you find again and break that one again.", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r434038697", "createdAt": "2020-06-02T17:10:51Z", "author": {"login": "someaddons"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -544,31 +565,93 @@ private Boolean isPassable(final BlockState blockState)\n         return blockState.getMaterial() == Material.LEAVES;\n     }\n \n+\n     /**\n      * Check if distance to block changed and if we are not moving for too long, try to get unstuck.\n      *\n      * @return false\n      */\n-    private boolean checkIfStuckOnLeaves()\n+    private boolean checkIfStuck()\n     {\n         if (!worker.getNavigator().noPath())\n         {\n-            Path pathToTree = worker.getNavigator().getPath();\n-            if (pathToTree != null && pathToTree.getCurrentPathLength() > pathToTree.getCurrentPathIndex())\n-            {\n-                PathPoint next = pathToTree.getPathPointFromIndex(pathToTree.getCurrentPathIndex());\n-                BlockPos nextPos = new BlockPos(next.x, next.y, next.z);\n-                BlockPos nextPosUp = new BlockPos(next.x, next.y + 1, next.z);\n-\n-                if (world.getBlockState(nextPos).getBlock().isIn(BlockTags.LEAVES))\n-                {\n-                    mineBlock(nextPos);\n+            Path path = worker.getNavigator().getPath();\n+            if(path != null) {\n+                if (path.getCurrentPathLength() > path.getCurrentPathIndex()) {\n+                    return true;\n                 }\n-                else if (world.getBlockState(nextPosUp).getBlock().isIn(BlockTags.LEAVES))\n-                {\n-                    mineBlock(nextPosUp);\n+                if(path.getCurrentPathLength() == 0){\n+                    return true;\n                 }\n             }\n+            else {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Mines leaves on path and above.\n+     */\n+    private void tryUnstuck(){\n+\n+        if (!worker.getNavigator().noPath()) {\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null) {\n+                // Unstuck with path\n+                ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+                PathPoint next = path.getPathPointFromIndex(path.getCurrentPathIndex());\n+                // Blocks in front of the worker\n+                checkPositions.add(new BlockPos(next.x, next.y, next.z));\n+                checkPositions.add(new BlockPos(next.x, next.y + 1, next.z));\n+                // Block above the worker\n+                checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 2, worker.getCurrentPosition().getZ()));\n+\n+                mineIfEqualsBlockTag(checkPositions, BlockTags.LEAVES);\n+                return;\n+            }\n+        }\n+\n+        // General unstuck\n+        ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+        // Blocks in front of the worker\n+        checkPositions.add(new BlockPos(worker.getForward().getX(), worker.getForward().getY(), worker.getForward().getZ()));\n+        checkPositions.add(new BlockPos(worker.getForward().getX(), worker.getForward().getY() + 1, worker.getForward().getZ()));\n+\n+        // blocks in north of the player\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY(), worker.getCurrentPosition().getZ()).north());\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 1, worker.getCurrentPosition().getZ()).north());\n+\n+        // blocks in east of the player\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY(), worker.getCurrentPosition().getZ()).east());\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 1, worker.getCurrentPosition().getZ()).east());\n+\n+        // blocks in south of the player\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY(), worker.getCurrentPosition().getZ()).south());\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 1, worker.getCurrentPosition().getZ()).south());\n+\n+        // blocks in west of the player\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY(), worker.getCurrentPosition().getZ()).west());\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 1, worker.getCurrentPosition().getZ()).west());\n+\n+        mineIfEqualsBlockTag(checkPositions, BlockTags.LEAVES);\n+    }\n+\n+    /**\n+     * Checks blocks for tag and mines the first it fines if its the same\n+     * @param blockPositions block positions\n+     * @param tag tag to check\n+     */\n+    private boolean mineIfEqualsBlockTag(List<BlockPos> blockPositions, Tag<Block> tag){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1NzcxMQ=="}, "originalCommit": {"oid": "feaafc886f3a41303244eac4036859599653dfaa"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA4Njk0Ng==", "bodyText": "But that was happening before, I just moved it into a separate function to minimize the code lines", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r434086946", "createdAt": "2020-06-02T18:21:07Z", "author": {"login": "Tobiti"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -544,31 +565,93 @@ private Boolean isPassable(final BlockState blockState)\n         return blockState.getMaterial() == Material.LEAVES;\n     }\n \n+\n     /**\n      * Check if distance to block changed and if we are not moving for too long, try to get unstuck.\n      *\n      * @return false\n      */\n-    private boolean checkIfStuckOnLeaves()\n+    private boolean checkIfStuck()\n     {\n         if (!worker.getNavigator().noPath())\n         {\n-            Path pathToTree = worker.getNavigator().getPath();\n-            if (pathToTree != null && pathToTree.getCurrentPathLength() > pathToTree.getCurrentPathIndex())\n-            {\n-                PathPoint next = pathToTree.getPathPointFromIndex(pathToTree.getCurrentPathIndex());\n-                BlockPos nextPos = new BlockPos(next.x, next.y, next.z);\n-                BlockPos nextPosUp = new BlockPos(next.x, next.y + 1, next.z);\n-\n-                if (world.getBlockState(nextPos).getBlock().isIn(BlockTags.LEAVES))\n-                {\n-                    mineBlock(nextPos);\n+            Path path = worker.getNavigator().getPath();\n+            if(path != null) {\n+                if (path.getCurrentPathLength() > path.getCurrentPathIndex()) {\n+                    return true;\n                 }\n-                else if (world.getBlockState(nextPosUp).getBlock().isIn(BlockTags.LEAVES))\n-                {\n-                    mineBlock(nextPosUp);\n+                if(path.getCurrentPathLength() == 0){\n+                    return true;\n                 }\n             }\n+            else {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Mines leaves on path and above.\n+     */\n+    private void tryUnstuck(){\n+\n+        if (!worker.getNavigator().noPath()) {\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null) {\n+                // Unstuck with path\n+                ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+                PathPoint next = path.getPathPointFromIndex(path.getCurrentPathIndex());\n+                // Blocks in front of the worker\n+                checkPositions.add(new BlockPos(next.x, next.y, next.z));\n+                checkPositions.add(new BlockPos(next.x, next.y + 1, next.z));\n+                // Block above the worker\n+                checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 2, worker.getCurrentPosition().getZ()));\n+\n+                mineIfEqualsBlockTag(checkPositions, BlockTags.LEAVES);\n+                return;\n+            }\n+        }\n+\n+        // General unstuck\n+        ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+        // Blocks in front of the worker\n+        checkPositions.add(new BlockPos(worker.getForward().getX(), worker.getForward().getY(), worker.getForward().getZ()));\n+        checkPositions.add(new BlockPos(worker.getForward().getX(), worker.getForward().getY() + 1, worker.getForward().getZ()));\n+\n+        // blocks in north of the player\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY(), worker.getCurrentPosition().getZ()).north());\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 1, worker.getCurrentPosition().getZ()).north());\n+\n+        // blocks in east of the player\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY(), worker.getCurrentPosition().getZ()).east());\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 1, worker.getCurrentPosition().getZ()).east());\n+\n+        // blocks in south of the player\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY(), worker.getCurrentPosition().getZ()).south());\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 1, worker.getCurrentPosition().getZ()).south());\n+\n+        // blocks in west of the player\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY(), worker.getCurrentPosition().getZ()).west());\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 1, worker.getCurrentPosition().getZ()).west());\n+\n+        mineIfEqualsBlockTag(checkPositions, BlockTags.LEAVES);\n+    }\n+\n+    /**\n+     * Checks blocks for tag and mines the first it fines if its the same\n+     * @param blockPositions block positions\n+     * @param tag tag to check\n+     */\n+    private boolean mineIfEqualsBlockTag(List<BlockPos> blockPositions, Tag<Block> tag){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1NzcxMQ=="}, "originalCommit": {"oid": "feaafc886f3a41303244eac4036859599653dfaa"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA5NDQzNw==", "bodyText": "no before it was an if else, it did check first pos -> is leaf? -> mine block. Next AI update it does check first pos -> is leaf? -> mine block (block breaks). Then next AI update it does check first pos -> no leaf -> check second pos -> is leaf -> mine second", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r434094437", "createdAt": "2020-06-02T18:32:07Z", "author": {"login": "someaddons"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -544,31 +565,93 @@ private Boolean isPassable(final BlockState blockState)\n         return blockState.getMaterial() == Material.LEAVES;\n     }\n \n+\n     /**\n      * Check if distance to block changed and if we are not moving for too long, try to get unstuck.\n      *\n      * @return false\n      */\n-    private boolean checkIfStuckOnLeaves()\n+    private boolean checkIfStuck()\n     {\n         if (!worker.getNavigator().noPath())\n         {\n-            Path pathToTree = worker.getNavigator().getPath();\n-            if (pathToTree != null && pathToTree.getCurrentPathLength() > pathToTree.getCurrentPathIndex())\n-            {\n-                PathPoint next = pathToTree.getPathPointFromIndex(pathToTree.getCurrentPathIndex());\n-                BlockPos nextPos = new BlockPos(next.x, next.y, next.z);\n-                BlockPos nextPosUp = new BlockPos(next.x, next.y + 1, next.z);\n-\n-                if (world.getBlockState(nextPos).getBlock().isIn(BlockTags.LEAVES))\n-                {\n-                    mineBlock(nextPos);\n+            Path path = worker.getNavigator().getPath();\n+            if(path != null) {\n+                if (path.getCurrentPathLength() > path.getCurrentPathIndex()) {\n+                    return true;\n                 }\n-                else if (world.getBlockState(nextPosUp).getBlock().isIn(BlockTags.LEAVES))\n-                {\n-                    mineBlock(nextPosUp);\n+                if(path.getCurrentPathLength() == 0){\n+                    return true;\n                 }\n             }\n+            else {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Mines leaves on path and above.\n+     */\n+    private void tryUnstuck(){\n+\n+        if (!worker.getNavigator().noPath()) {\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null) {\n+                // Unstuck with path\n+                ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+                PathPoint next = path.getPathPointFromIndex(path.getCurrentPathIndex());\n+                // Blocks in front of the worker\n+                checkPositions.add(new BlockPos(next.x, next.y, next.z));\n+                checkPositions.add(new BlockPos(next.x, next.y + 1, next.z));\n+                // Block above the worker\n+                checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 2, worker.getCurrentPosition().getZ()));\n+\n+                mineIfEqualsBlockTag(checkPositions, BlockTags.LEAVES);\n+                return;\n+            }\n+        }\n+\n+        // General unstuck\n+        ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+        // Blocks in front of the worker\n+        checkPositions.add(new BlockPos(worker.getForward().getX(), worker.getForward().getY(), worker.getForward().getZ()));\n+        checkPositions.add(new BlockPos(worker.getForward().getX(), worker.getForward().getY() + 1, worker.getForward().getZ()));\n+\n+        // blocks in north of the player\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY(), worker.getCurrentPosition().getZ()).north());\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 1, worker.getCurrentPosition().getZ()).north());\n+\n+        // blocks in east of the player\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY(), worker.getCurrentPosition().getZ()).east());\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 1, worker.getCurrentPosition().getZ()).east());\n+\n+        // blocks in south of the player\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY(), worker.getCurrentPosition().getZ()).south());\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 1, worker.getCurrentPosition().getZ()).south());\n+\n+        // blocks in west of the player\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY(), worker.getCurrentPosition().getZ()).west());\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 1, worker.getCurrentPosition().getZ()).west());\n+\n+        mineIfEqualsBlockTag(checkPositions, BlockTags.LEAVES);\n+    }\n+\n+    /**\n+     * Checks blocks for tag and mines the first it fines if its the same\n+     * @param blockPositions block positions\n+     * @param tag tag to check\n+     */\n+    private boolean mineIfEqualsBlockTag(List<BlockPos> blockPositions, Tag<Block> tag){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1NzcxMQ=="}, "originalCommit": {"oid": "feaafc886f3a41303244eac4036859599653dfaa"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDExMTIwNQ==", "bodyText": "And now its the same\nI starts with the first object in the list\nif leaf -> mine and return, second run, again first is leaf -> mine(break) -> return\n3rd run first is not leaf -> check second, if leaf ...", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r434111205", "createdAt": "2020-06-02T19:02:51Z", "author": {"login": "Tobiti"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -544,31 +565,93 @@ private Boolean isPassable(final BlockState blockState)\n         return blockState.getMaterial() == Material.LEAVES;\n     }\n \n+\n     /**\n      * Check if distance to block changed and if we are not moving for too long, try to get unstuck.\n      *\n      * @return false\n      */\n-    private boolean checkIfStuckOnLeaves()\n+    private boolean checkIfStuck()\n     {\n         if (!worker.getNavigator().noPath())\n         {\n-            Path pathToTree = worker.getNavigator().getPath();\n-            if (pathToTree != null && pathToTree.getCurrentPathLength() > pathToTree.getCurrentPathIndex())\n-            {\n-                PathPoint next = pathToTree.getPathPointFromIndex(pathToTree.getCurrentPathIndex());\n-                BlockPos nextPos = new BlockPos(next.x, next.y, next.z);\n-                BlockPos nextPosUp = new BlockPos(next.x, next.y + 1, next.z);\n-\n-                if (world.getBlockState(nextPos).getBlock().isIn(BlockTags.LEAVES))\n-                {\n-                    mineBlock(nextPos);\n+            Path path = worker.getNavigator().getPath();\n+            if(path != null) {\n+                if (path.getCurrentPathLength() > path.getCurrentPathIndex()) {\n+                    return true;\n                 }\n-                else if (world.getBlockState(nextPosUp).getBlock().isIn(BlockTags.LEAVES))\n-                {\n-                    mineBlock(nextPosUp);\n+                if(path.getCurrentPathLength() == 0){\n+                    return true;\n                 }\n             }\n+            else {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Mines leaves on path and above.\n+     */\n+    private void tryUnstuck(){\n+\n+        if (!worker.getNavigator().noPath()) {\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null) {\n+                // Unstuck with path\n+                ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+                PathPoint next = path.getPathPointFromIndex(path.getCurrentPathIndex());\n+                // Blocks in front of the worker\n+                checkPositions.add(new BlockPos(next.x, next.y, next.z));\n+                checkPositions.add(new BlockPos(next.x, next.y + 1, next.z));\n+                // Block above the worker\n+                checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 2, worker.getCurrentPosition().getZ()));\n+\n+                mineIfEqualsBlockTag(checkPositions, BlockTags.LEAVES);\n+                return;\n+            }\n+        }\n+\n+        // General unstuck\n+        ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+        // Blocks in front of the worker\n+        checkPositions.add(new BlockPos(worker.getForward().getX(), worker.getForward().getY(), worker.getForward().getZ()));\n+        checkPositions.add(new BlockPos(worker.getForward().getX(), worker.getForward().getY() + 1, worker.getForward().getZ()));\n+\n+        // blocks in north of the player\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY(), worker.getCurrentPosition().getZ()).north());\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 1, worker.getCurrentPosition().getZ()).north());\n+\n+        // blocks in east of the player\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY(), worker.getCurrentPosition().getZ()).east());\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 1, worker.getCurrentPosition().getZ()).east());\n+\n+        // blocks in south of the player\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY(), worker.getCurrentPosition().getZ()).south());\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 1, worker.getCurrentPosition().getZ()).south());\n+\n+        // blocks in west of the player\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY(), worker.getCurrentPosition().getZ()).west());\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 1, worker.getCurrentPosition().getZ()).west());\n+\n+        mineIfEqualsBlockTag(checkPositions, BlockTags.LEAVES);\n+    }\n+\n+    /**\n+     * Checks blocks for tag and mines the first it fines if its the same\n+     * @param blockPositions block positions\n+     * @param tag tag to check\n+     */\n+    private boolean mineIfEqualsBlockTag(List<BlockPos> blockPositions, Tag<Block> tag){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1NzcxMQ=="}, "originalCommit": {"oid": "feaafc886f3a41303244eac4036859599653dfaa"}, "originalPosition": 202}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzYyNzUyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/minecolonies/coremod/entity/ai/basic/AbstractEntityAIBasic.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxNToyMzowMlrOGgEOzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxNToyMzowMlrOGgEOzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3Njk0Mw==", "bodyText": "Do these still all have to be protected?", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r436276943", "createdAt": "2020-06-06T15:23:02Z", "author": {"login": "Raycoms"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/basic/AbstractEntityAIBasic.java", "diffHunk": "@@ -114,7 +114,7 @@\n     /**\n      * Slot he is currently trying to dump.\n      */\n-    private int slotAt = 0;\n+    protected int slotAt = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6e58fb9bfb516cdd56f624e8fe77443605f20c6"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzYzNzQ3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxNTo0MTo1MlrOGgET5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxNTo0MTo1MlrOGgET5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3ODI0Ng==", "bodyText": "brackets", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r436278246", "createdAt": "2020-06-06T15:41:52Z", "author": {"login": "Raycoms"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -413,7 +421,9 @@ private IAIState chopTree()\n         {\n             if (!walkToTree(job.getTree().getStumpLocations().get(0)))\n             {\n-                checkIfStuckOnLeaves();\n+                if(checkIfStuck()) {\n+                    tryUnstuck();\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6e58fb9bfb516cdd56f624e8fe77443605f20c6"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzYzNzY5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxNTo0MjoxNVrOGgEUAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxNTo0MjoxNVrOGgEUAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3ODI3Mw==", "bodyText": "code format is off", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r436278273", "createdAt": "2020-06-06T15:42:15Z", "author": {"login": "Raycoms"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -544,31 +554,94 @@ private Boolean isPassable(final BlockState blockState)\n         return blockState.getMaterial() == Material.LEAVES;\n     }\n \n+\n     /**\n      * Check if distance to block changed and if we are not moving for too long, try to get unstuck.\n      *\n      * @return false\n      */\n-    private boolean checkIfStuckOnLeaves()\n+    private boolean checkIfStuck()\n     {\n         if (!worker.getNavigator().noPath())\n         {\n-            Path pathToTree = worker.getNavigator().getPath();\n-            if (pathToTree != null && pathToTree.getCurrentPathLength() > pathToTree.getCurrentPathIndex())\n-            {\n-                PathPoint next = pathToTree.getPathPointFromIndex(pathToTree.getCurrentPathIndex());\n-                BlockPos nextPos = new BlockPos(next.x, next.y, next.z);\n-                BlockPos nextPosUp = new BlockPos(next.x, next.y + 1, next.z);\n-\n-                if (world.getBlockState(nextPos).getBlock().isIn(BlockTags.LEAVES))\n-                {\n-                    mineBlock(nextPos);\n+            Path path = worker.getNavigator().getPath();\n+            if(path != null) {\n+                if (path.getCurrentPathLength() > path.getCurrentPathIndex()) {\n+                    return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6e58fb9bfb516cdd56f624e8fe77443605f20c6"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzY2ODA5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxNjozOToyMVrOGgEjyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxNzowMjozOFrOGgEqjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4MjMxNA==", "bodyText": "format", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r436282314", "createdAt": "2020-06-06T16:39:21Z", "author": {"login": "Raycoms"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -544,31 +555,102 @@ private Boolean isPassable(final BlockState blockState)\n         return blockState.getMaterial() == Material.LEAVES;\n     }\n \n+\n     /**\n      * Check if distance to block changed and if we are not moving for too long, try to get unstuck.\n      *\n      * @return false\n      */\n-    private boolean checkIfStuckOnLeaves()\n+    private boolean checkIfStuck()\n     {\n         if (!worker.getNavigator().noPath())\n         {\n-            Path pathToTree = worker.getNavigator().getPath();\n-            if (pathToTree != null && pathToTree.getCurrentPathLength() > pathToTree.getCurrentPathIndex())\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null)\n             {\n-                PathPoint next = pathToTree.getPathPointFromIndex(pathToTree.getCurrentPathIndex());\n-                BlockPos nextPos = new BlockPos(next.x, next.y, next.z);\n-                BlockPos nextPosUp = new BlockPos(next.x, next.y + 1, next.z);\n-\n-                if (world.getBlockState(nextPos).getBlock().isIn(BlockTags.LEAVES))\n+                if (path.getCurrentPathLength() > path.getCurrentPathIndex())\n                 {\n-                    mineBlock(nextPos);\n+                    return true;\n                 }\n-                else if (world.getBlockState(nextPosUp).getBlock().isIn(BlockTags.LEAVES))\n+                if (path.getCurrentPathLength() == 0)\n                 {\n-                    mineBlock(nextPosUp);\n+                    return true;\n                 }\n             }\n+            else\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Mines leaves on path and above.\n+     */\n+    private void tryUnstuck(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e0983e2c1639a4fd640d720a75eec762658050a"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4NDA0Nw==", "bodyText": "Done :)", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r436284047", "createdAt": "2020-06-06T17:02:38Z", "author": {"login": "Tobiti"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -544,31 +555,102 @@ private Boolean isPassable(final BlockState blockState)\n         return blockState.getMaterial() == Material.LEAVES;\n     }\n \n+\n     /**\n      * Check if distance to block changed and if we are not moving for too long, try to get unstuck.\n      *\n      * @return false\n      */\n-    private boolean checkIfStuckOnLeaves()\n+    private boolean checkIfStuck()\n     {\n         if (!worker.getNavigator().noPath())\n         {\n-            Path pathToTree = worker.getNavigator().getPath();\n-            if (pathToTree != null && pathToTree.getCurrentPathLength() > pathToTree.getCurrentPathIndex())\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null)\n             {\n-                PathPoint next = pathToTree.getPathPointFromIndex(pathToTree.getCurrentPathIndex());\n-                BlockPos nextPos = new BlockPos(next.x, next.y, next.z);\n-                BlockPos nextPosUp = new BlockPos(next.x, next.y + 1, next.z);\n-\n-                if (world.getBlockState(nextPos).getBlock().isIn(BlockTags.LEAVES))\n+                if (path.getCurrentPathLength() > path.getCurrentPathIndex())\n                 {\n-                    mineBlock(nextPos);\n+                    return true;\n                 }\n-                else if (world.getBlockState(nextPosUp).getBlock().isIn(BlockTags.LEAVES))\n+                if (path.getCurrentPathLength() == 0)\n                 {\n-                    mineBlock(nextPosUp);\n+                    return true;\n                 }\n             }\n+            else\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Mines leaves on path and above.\n+     */\n+    private void tryUnstuck(){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4MjMxNA=="}, "originalCommit": {"oid": "8e0983e2c1639a4fd640d720a75eec762658050a"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzY2ODQzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxNjozOTo1NVrOGgEj-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQyMDo1NDo1N1rOGgFocg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4MjM2Mw==", "bodyText": "This looks like you could make a\nfor each Direction in Horizontal directions\naddInDirection", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r436282363", "createdAt": "2020-06-06T16:39:55Z", "author": {"login": "Raycoms"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -544,31 +555,102 @@ private Boolean isPassable(final BlockState blockState)\n         return blockState.getMaterial() == Material.LEAVES;\n     }\n \n+\n     /**\n      * Check if distance to block changed and if we are not moving for too long, try to get unstuck.\n      *\n      * @return false\n      */\n-    private boolean checkIfStuckOnLeaves()\n+    private boolean checkIfStuck()\n     {\n         if (!worker.getNavigator().noPath())\n         {\n-            Path pathToTree = worker.getNavigator().getPath();\n-            if (pathToTree != null && pathToTree.getCurrentPathLength() > pathToTree.getCurrentPathIndex())\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null)\n             {\n-                PathPoint next = pathToTree.getPathPointFromIndex(pathToTree.getCurrentPathIndex());\n-                BlockPos nextPos = new BlockPos(next.x, next.y, next.z);\n-                BlockPos nextPosUp = new BlockPos(next.x, next.y + 1, next.z);\n-\n-                if (world.getBlockState(nextPos).getBlock().isIn(BlockTags.LEAVES))\n+                if (path.getCurrentPathLength() > path.getCurrentPathIndex())\n                 {\n-                    mineBlock(nextPos);\n+                    return true;\n                 }\n-                else if (world.getBlockState(nextPosUp).getBlock().isIn(BlockTags.LEAVES))\n+                if (path.getCurrentPathLength() == 0)\n                 {\n-                    mineBlock(nextPosUp);\n+                    return true;\n                 }\n             }\n+            else\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Mines leaves on path and above.\n+     */\n+    private void tryUnstuck(){\n+\n+        if (!worker.getNavigator().noPath())\n+        {\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null)\n+            {\n+                // Unstuck with path\n+                ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+                PathPoint next = path.getPathPointFromIndex(path.getCurrentPathIndex());\n+\n+                // Blocks in front of the worker\n+                checkPositions.add(new BlockPos(next.x, next.y, next.z));\n+                checkPositions.add(new BlockPos(next.x, next.y + 1, next.z));\n+                checkPositions.add(new BlockPos(next.x, next.y + 2, next.z));\n+\n+                // Block above the worker\n+                checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 2, worker.getCurrentPosition().getZ()));\n+\n+                mineIfEqualsBlockTag(checkPositions, BlockTags.LEAVES);\n+                return;\n+            }\n+        }\n+\n+        // General unstuck\n+        ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+        // Blocks in front of the worker\n+        checkPositions.add(new BlockPos(worker.getForward().getX(), worker.getForward().getY(), worker.getForward().getZ()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e0983e2c1639a4fd640d720a75eec762658050a"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4NDAxNw==", "bodyText": "Done :)", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r436284017", "createdAt": "2020-06-06T17:02:16Z", "author": {"login": "Tobiti"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -544,31 +555,102 @@ private Boolean isPassable(final BlockState blockState)\n         return blockState.getMaterial() == Material.LEAVES;\n     }\n \n+\n     /**\n      * Check if distance to block changed and if we are not moving for too long, try to get unstuck.\n      *\n      * @return false\n      */\n-    private boolean checkIfStuckOnLeaves()\n+    private boolean checkIfStuck()\n     {\n         if (!worker.getNavigator().noPath())\n         {\n-            Path pathToTree = worker.getNavigator().getPath();\n-            if (pathToTree != null && pathToTree.getCurrentPathLength() > pathToTree.getCurrentPathIndex())\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null)\n             {\n-                PathPoint next = pathToTree.getPathPointFromIndex(pathToTree.getCurrentPathIndex());\n-                BlockPos nextPos = new BlockPos(next.x, next.y, next.z);\n-                BlockPos nextPosUp = new BlockPos(next.x, next.y + 1, next.z);\n-\n-                if (world.getBlockState(nextPos).getBlock().isIn(BlockTags.LEAVES))\n+                if (path.getCurrentPathLength() > path.getCurrentPathIndex())\n                 {\n-                    mineBlock(nextPos);\n+                    return true;\n                 }\n-                else if (world.getBlockState(nextPosUp).getBlock().isIn(BlockTags.LEAVES))\n+                if (path.getCurrentPathLength() == 0)\n                 {\n-                    mineBlock(nextPosUp);\n+                    return true;\n                 }\n             }\n+            else\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Mines leaves on path and above.\n+     */\n+    private void tryUnstuck(){\n+\n+        if (!worker.getNavigator().noPath())\n+        {\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null)\n+            {\n+                // Unstuck with path\n+                ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+                PathPoint next = path.getPathPointFromIndex(path.getCurrentPathIndex());\n+\n+                // Blocks in front of the worker\n+                checkPositions.add(new BlockPos(next.x, next.y, next.z));\n+                checkPositions.add(new BlockPos(next.x, next.y + 1, next.z));\n+                checkPositions.add(new BlockPos(next.x, next.y + 2, next.z));\n+\n+                // Block above the worker\n+                checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 2, worker.getCurrentPosition().getZ()));\n+\n+                mineIfEqualsBlockTag(checkPositions, BlockTags.LEAVES);\n+                return;\n+            }\n+        }\n+\n+        // General unstuck\n+        ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+        // Blocks in front of the worker\n+        checkPositions.add(new BlockPos(worker.getForward().getX(), worker.getForward().getY(), worker.getForward().getZ()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4MjM2Mw=="}, "originalCommit": {"oid": "8e0983e2c1639a4fd640d720a75eec762658050a"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5OTg5MA==", "bodyText": "where?", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r436299890", "createdAt": "2020-06-06T20:54:57Z", "author": {"login": "Raycoms"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -544,31 +555,102 @@ private Boolean isPassable(final BlockState blockState)\n         return blockState.getMaterial() == Material.LEAVES;\n     }\n \n+\n     /**\n      * Check if distance to block changed and if we are not moving for too long, try to get unstuck.\n      *\n      * @return false\n      */\n-    private boolean checkIfStuckOnLeaves()\n+    private boolean checkIfStuck()\n     {\n         if (!worker.getNavigator().noPath())\n         {\n-            Path pathToTree = worker.getNavigator().getPath();\n-            if (pathToTree != null && pathToTree.getCurrentPathLength() > pathToTree.getCurrentPathIndex())\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null)\n             {\n-                PathPoint next = pathToTree.getPathPointFromIndex(pathToTree.getCurrentPathIndex());\n-                BlockPos nextPos = new BlockPos(next.x, next.y, next.z);\n-                BlockPos nextPosUp = new BlockPos(next.x, next.y + 1, next.z);\n-\n-                if (world.getBlockState(nextPos).getBlock().isIn(BlockTags.LEAVES))\n+                if (path.getCurrentPathLength() > path.getCurrentPathIndex())\n                 {\n-                    mineBlock(nextPos);\n+                    return true;\n                 }\n-                else if (world.getBlockState(nextPosUp).getBlock().isIn(BlockTags.LEAVES))\n+                if (path.getCurrentPathLength() == 0)\n                 {\n-                    mineBlock(nextPosUp);\n+                    return true;\n                 }\n             }\n+            else\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Mines leaves on path and above.\n+     */\n+    private void tryUnstuck(){\n+\n+        if (!worker.getNavigator().noPath())\n+        {\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null)\n+            {\n+                // Unstuck with path\n+                ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+                PathPoint next = path.getPathPointFromIndex(path.getCurrentPathIndex());\n+\n+                // Blocks in front of the worker\n+                checkPositions.add(new BlockPos(next.x, next.y, next.z));\n+                checkPositions.add(new BlockPos(next.x, next.y + 1, next.z));\n+                checkPositions.add(new BlockPos(next.x, next.y + 2, next.z));\n+\n+                // Block above the worker\n+                checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 2, worker.getCurrentPosition().getZ()));\n+\n+                mineIfEqualsBlockTag(checkPositions, BlockTags.LEAVES);\n+                return;\n+            }\n+        }\n+\n+        // General unstuck\n+        ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+        // Blocks in front of the worker\n+        checkPositions.add(new BlockPos(worker.getForward().getX(), worker.getForward().getY(), worker.getForward().getZ()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4MjM2Mw=="}, "originalCommit": {"oid": "8e0983e2c1639a4fd640d720a75eec762658050a"}, "originalPosition": 164}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzY2ODY4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxNjo0MDowNVrOGgEkFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxNzowMjoyNVrOGgEqiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4MjM5MQ==", "bodyText": "format this entire method too", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r436282391", "createdAt": "2020-06-06T16:40:05Z", "author": {"login": "Raycoms"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -544,31 +555,102 @@ private Boolean isPassable(final BlockState blockState)\n         return blockState.getMaterial() == Material.LEAVES;\n     }\n \n+\n     /**\n      * Check if distance to block changed and if we are not moving for too long, try to get unstuck.\n      *\n      * @return false\n      */\n-    private boolean checkIfStuckOnLeaves()\n+    private boolean checkIfStuck()\n     {\n         if (!worker.getNavigator().noPath())\n         {\n-            Path pathToTree = worker.getNavigator().getPath();\n-            if (pathToTree != null && pathToTree.getCurrentPathLength() > pathToTree.getCurrentPathIndex())\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null)\n             {\n-                PathPoint next = pathToTree.getPathPointFromIndex(pathToTree.getCurrentPathIndex());\n-                BlockPos nextPos = new BlockPos(next.x, next.y, next.z);\n-                BlockPos nextPosUp = new BlockPos(next.x, next.y + 1, next.z);\n-\n-                if (world.getBlockState(nextPos).getBlock().isIn(BlockTags.LEAVES))\n+                if (path.getCurrentPathLength() > path.getCurrentPathIndex())\n                 {\n-                    mineBlock(nextPos);\n+                    return true;\n                 }\n-                else if (world.getBlockState(nextPosUp).getBlock().isIn(BlockTags.LEAVES))\n+                if (path.getCurrentPathLength() == 0)\n                 {\n-                    mineBlock(nextPosUp);\n+                    return true;\n                 }\n             }\n+            else\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Mines leaves on path and above.\n+     */\n+    private void tryUnstuck(){\n+\n+        if (!worker.getNavigator().noPath())\n+        {\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null)\n+            {\n+                // Unstuck with path\n+                ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+                PathPoint next = path.getPathPointFromIndex(path.getCurrentPathIndex());\n+\n+                // Blocks in front of the worker\n+                checkPositions.add(new BlockPos(next.x, next.y, next.z));\n+                checkPositions.add(new BlockPos(next.x, next.y + 1, next.z));\n+                checkPositions.add(new BlockPos(next.x, next.y + 2, next.z));\n+\n+                // Block above the worker\n+                checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 2, worker.getCurrentPosition().getZ()));\n+\n+                mineIfEqualsBlockTag(checkPositions, BlockTags.LEAVES);\n+                return;\n+            }\n+        }\n+\n+        // General unstuck\n+        ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+        // Blocks in front of the worker\n+        checkPositions.add(new BlockPos(worker.getForward().getX(), worker.getForward().getY(), worker.getForward().getZ()));\n+        checkPositions.add(new BlockPos(worker.getForward().getX(), worker.getForward().getY() + 1, worker.getForward().getZ()));\n+\n+        // blocks in north of the player\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY(), worker.getCurrentPosition().getZ()).north());\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 1, worker.getCurrentPosition().getZ()).north());\n+\n+        // blocks in east of the player\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY(), worker.getCurrentPosition().getZ()).east());\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 1, worker.getCurrentPosition().getZ()).east());\n+\n+        // blocks in south of the player\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY(), worker.getCurrentPosition().getZ()).south());\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 1, worker.getCurrentPosition().getZ()).south());\n+\n+        // blocks in west of the player\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY(), worker.getCurrentPosition().getZ()).west());\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 1, worker.getCurrentPosition().getZ()).west());\n+\n+        mineIfEqualsBlockTag(checkPositions, BlockTags.LEAVES);\n+    }\n+\n+    /**\n+     * Checks blocks for tag and mines the first it fines if its the same\n+     * @param blockPositions block positions\n+     * @param tag tag to check\n+     */\n+    private boolean mineIfEqualsBlockTag(List<BlockPos> blockPositions, Tag<Block> tag){\n+        for (BlockPos currentPos : blockPositions) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e0983e2c1639a4fd640d720a75eec762658050a"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4NDA0MA==", "bodyText": "Is fixed :)", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r436284040", "createdAt": "2020-06-06T17:02:25Z", "author": {"login": "Tobiti"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -544,31 +555,102 @@ private Boolean isPassable(final BlockState blockState)\n         return blockState.getMaterial() == Material.LEAVES;\n     }\n \n+\n     /**\n      * Check if distance to block changed and if we are not moving for too long, try to get unstuck.\n      *\n      * @return false\n      */\n-    private boolean checkIfStuckOnLeaves()\n+    private boolean checkIfStuck()\n     {\n         if (!worker.getNavigator().noPath())\n         {\n-            Path pathToTree = worker.getNavigator().getPath();\n-            if (pathToTree != null && pathToTree.getCurrentPathLength() > pathToTree.getCurrentPathIndex())\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null)\n             {\n-                PathPoint next = pathToTree.getPathPointFromIndex(pathToTree.getCurrentPathIndex());\n-                BlockPos nextPos = new BlockPos(next.x, next.y, next.z);\n-                BlockPos nextPosUp = new BlockPos(next.x, next.y + 1, next.z);\n-\n-                if (world.getBlockState(nextPos).getBlock().isIn(BlockTags.LEAVES))\n+                if (path.getCurrentPathLength() > path.getCurrentPathIndex())\n                 {\n-                    mineBlock(nextPos);\n+                    return true;\n                 }\n-                else if (world.getBlockState(nextPosUp).getBlock().isIn(BlockTags.LEAVES))\n+                if (path.getCurrentPathLength() == 0)\n                 {\n-                    mineBlock(nextPosUp);\n+                    return true;\n                 }\n             }\n+            else\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Mines leaves on path and above.\n+     */\n+    private void tryUnstuck(){\n+\n+        if (!worker.getNavigator().noPath())\n+        {\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null)\n+            {\n+                // Unstuck with path\n+                ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+                PathPoint next = path.getPathPointFromIndex(path.getCurrentPathIndex());\n+\n+                // Blocks in front of the worker\n+                checkPositions.add(new BlockPos(next.x, next.y, next.z));\n+                checkPositions.add(new BlockPos(next.x, next.y + 1, next.z));\n+                checkPositions.add(new BlockPos(next.x, next.y + 2, next.z));\n+\n+                // Block above the worker\n+                checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 2, worker.getCurrentPosition().getZ()));\n+\n+                mineIfEqualsBlockTag(checkPositions, BlockTags.LEAVES);\n+                return;\n+            }\n+        }\n+\n+        // General unstuck\n+        ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+        // Blocks in front of the worker\n+        checkPositions.add(new BlockPos(worker.getForward().getX(), worker.getForward().getY(), worker.getForward().getZ()));\n+        checkPositions.add(new BlockPos(worker.getForward().getX(), worker.getForward().getY() + 1, worker.getForward().getZ()));\n+\n+        // blocks in north of the player\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY(), worker.getCurrentPosition().getZ()).north());\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 1, worker.getCurrentPosition().getZ()).north());\n+\n+        // blocks in east of the player\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY(), worker.getCurrentPosition().getZ()).east());\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 1, worker.getCurrentPosition().getZ()).east());\n+\n+        // blocks in south of the player\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY(), worker.getCurrentPosition().getZ()).south());\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 1, worker.getCurrentPosition().getZ()).south());\n+\n+        // blocks in west of the player\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY(), worker.getCurrentPosition().getZ()).west());\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 1, worker.getCurrentPosition().getZ()).west());\n+\n+        mineIfEqualsBlockTag(checkPositions, BlockTags.LEAVES);\n+    }\n+\n+    /**\n+     * Checks blocks for tag and mines the first it fines if its the same\n+     * @param blockPositions block positions\n+     * @param tag tag to check\n+     */\n+    private boolean mineIfEqualsBlockTag(List<BlockPos> blockPositions, Tag<Block> tag){\n+        for (BlockPos currentPos : blockPositions) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4MjM5MQ=="}, "originalCommit": {"oid": "8e0983e2c1639a4fd640d720a75eec762658050a"}, "originalPosition": 192}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzY4MzM4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxNzowNTo0N1rOGgErig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQyMDowMzo1NlrOGgFcJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4NDI5OA==", "bodyText": "cough", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r436284298", "createdAt": "2020-06-06T17:05:47Z", "author": {"login": "Raycoms"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -544,30 +555,105 @@ private Boolean isPassable(final BlockState blockState)\n         return blockState.getMaterial() == Material.LEAVES;\n     }\n \n+\n     /**\n      * Check if distance to block changed and if we are not moving for too long, try to get unstuck.\n      *\n      * @return false\n      */\n-    private boolean checkIfStuckOnLeaves()\n+    private boolean checkIfStuck()\n     {\n         if (!worker.getNavigator().noPath())\n         {\n-            Path pathToTree = worker.getNavigator().getPath();\n-            if (pathToTree != null && pathToTree.getCurrentPathLength() > pathToTree.getCurrentPathIndex())\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null)\n             {\n-                PathPoint next = pathToTree.getPathPointFromIndex(pathToTree.getCurrentPathIndex());\n-                BlockPos nextPos = new BlockPos(next.x, next.y, next.z);\n-                BlockPos nextPosUp = new BlockPos(next.x, next.y + 1, next.z);\n-\n-                if (world.getBlockState(nextPos).getBlock().isIn(BlockTags.LEAVES))\n+                if (path.getCurrentPathLength() > path.getCurrentPathIndex())\n                 {\n-                    mineBlock(nextPos);\n+                    return true;\n                 }\n-                else if (world.getBlockState(nextPosUp).getBlock().isIn(BlockTags.LEAVES))\n+                if (path.getCurrentPathLength() == 0)\n                 {\n-                    mineBlock(nextPosUp);\n+                    return true;\n+                }\n+            }\n+            else\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Mines leaves on path and above.\n+     */\n+    private void tryUnstuck()\n+    {\n+        if (!worker.getNavigator().noPath())\n+        {\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null)\n+            {\n+                // Unstuck with path\n+                ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+                PathPoint next = path.getPathPointFromIndex(path.getCurrentPathIndex());\n+\n+                // Blocks in front of the worker\n+                for(int i = 0; i <= 2; i++){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f49c329a542eb4a3944c285a4ac2d0ecdeefe8c"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5MDExNQ==", "bodyText": "Done\ni need to change the code style in intellj", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r436290115", "createdAt": "2020-06-06T18:30:09Z", "author": {"login": "Tobiti"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -544,30 +555,105 @@ private Boolean isPassable(final BlockState blockState)\n         return blockState.getMaterial() == Material.LEAVES;\n     }\n \n+\n     /**\n      * Check if distance to block changed and if we are not moving for too long, try to get unstuck.\n      *\n      * @return false\n      */\n-    private boolean checkIfStuckOnLeaves()\n+    private boolean checkIfStuck()\n     {\n         if (!worker.getNavigator().noPath())\n         {\n-            Path pathToTree = worker.getNavigator().getPath();\n-            if (pathToTree != null && pathToTree.getCurrentPathLength() > pathToTree.getCurrentPathIndex())\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null)\n             {\n-                PathPoint next = pathToTree.getPathPointFromIndex(pathToTree.getCurrentPathIndex());\n-                BlockPos nextPos = new BlockPos(next.x, next.y, next.z);\n-                BlockPos nextPosUp = new BlockPos(next.x, next.y + 1, next.z);\n-\n-                if (world.getBlockState(nextPos).getBlock().isIn(BlockTags.LEAVES))\n+                if (path.getCurrentPathLength() > path.getCurrentPathIndex())\n                 {\n-                    mineBlock(nextPos);\n+                    return true;\n                 }\n-                else if (world.getBlockState(nextPosUp).getBlock().isIn(BlockTags.LEAVES))\n+                if (path.getCurrentPathLength() == 0)\n                 {\n-                    mineBlock(nextPosUp);\n+                    return true;\n+                }\n+            }\n+            else\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Mines leaves on path and above.\n+     */\n+    private void tryUnstuck()\n+    {\n+        if (!worker.getNavigator().noPath())\n+        {\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null)\n+            {\n+                // Unstuck with path\n+                ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+                PathPoint next = path.getPathPointFromIndex(path.getCurrentPathIndex());\n+\n+                // Blocks in front of the worker\n+                for(int i = 0; i <= 2; i++){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4NDI5OA=="}, "originalCommit": {"oid": "0f49c329a542eb4a3944c285a4ac2d0ecdeefe8c"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5Njc0MA==", "bodyText": "you can import the codestyle from the documentation folder", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r436296740", "createdAt": "2020-06-06T20:03:56Z", "author": {"login": "someaddons"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -544,30 +555,105 @@ private Boolean isPassable(final BlockState blockState)\n         return blockState.getMaterial() == Material.LEAVES;\n     }\n \n+\n     /**\n      * Check if distance to block changed and if we are not moving for too long, try to get unstuck.\n      *\n      * @return false\n      */\n-    private boolean checkIfStuckOnLeaves()\n+    private boolean checkIfStuck()\n     {\n         if (!worker.getNavigator().noPath())\n         {\n-            Path pathToTree = worker.getNavigator().getPath();\n-            if (pathToTree != null && pathToTree.getCurrentPathLength() > pathToTree.getCurrentPathIndex())\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null)\n             {\n-                PathPoint next = pathToTree.getPathPointFromIndex(pathToTree.getCurrentPathIndex());\n-                BlockPos nextPos = new BlockPos(next.x, next.y, next.z);\n-                BlockPos nextPosUp = new BlockPos(next.x, next.y + 1, next.z);\n-\n-                if (world.getBlockState(nextPos).getBlock().isIn(BlockTags.LEAVES))\n+                if (path.getCurrentPathLength() > path.getCurrentPathIndex())\n                 {\n-                    mineBlock(nextPos);\n+                    return true;\n                 }\n-                else if (world.getBlockState(nextPosUp).getBlock().isIn(BlockTags.LEAVES))\n+                if (path.getCurrentPathLength() == 0)\n                 {\n-                    mineBlock(nextPosUp);\n+                    return true;\n+                }\n+            }\n+            else\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Mines leaves on path and above.\n+     */\n+    private void tryUnstuck()\n+    {\n+        if (!worker.getNavigator().noPath())\n+        {\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null)\n+            {\n+                // Unstuck with path\n+                ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+                PathPoint next = path.getPathPointFromIndex(path.getCurrentPathIndex());\n+\n+                // Blocks in front of the worker\n+                for(int i = 0; i <= 2; i++){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4NDI5OA=="}, "originalCommit": {"oid": "0f49c329a542eb4a3944c285a4ac2d0ecdeefe8c"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxODI1OTMwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxMjozNjoyMlrOGgJO6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxMzo1NDoxOVrOGgJpNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM1ODg5MA==", "bodyText": "There is a minecraft class for all horizontal directions =D", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r436358890", "createdAt": "2020-06-07T12:36:22Z", "author": {"login": "Raycoms"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -544,30 +556,98 @@ private Boolean isPassable(final BlockState blockState)\n         return blockState.getMaterial() == Material.LEAVES;\n     }\n \n+\n     /**\n      * Check if distance to block changed and if we are not moving for too long, try to get unstuck.\n      *\n      * @return false\n      */\n-    private boolean checkIfStuckOnLeaves()\n+    private boolean checkIfStuck()\n     {\n         if (!worker.getNavigator().noPath())\n         {\n-            Path pathToTree = worker.getNavigator().getPath();\n-            if (pathToTree != null && pathToTree.getCurrentPathLength() > pathToTree.getCurrentPathIndex())\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null)\n             {\n-                PathPoint next = pathToTree.getPathPointFromIndex(pathToTree.getCurrentPathIndex());\n-                BlockPos nextPos = new BlockPos(next.x, next.y, next.z);\n-                BlockPos nextPosUp = new BlockPos(next.x, next.y + 1, next.z);\n-\n-                if (world.getBlockState(nextPos).getBlock().isIn(BlockTags.LEAVES))\n+                if (path.getCurrentPathLength() > path.getCurrentPathIndex())\n+                {\n+                    return true;\n+                }\n+                if (path.getCurrentPathLength() == 0)\n                 {\n-                    mineBlock(nextPos);\n+                    return true;\n                 }\n-                else if (world.getBlockState(nextPosUp).getBlock().isIn(BlockTags.LEAVES))\n+            }\n+            else\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Mines leaves on path and above.\n+     */\n+    private void tryUnstuck()\n+    {\n+        if (!worker.getNavigator().noPath())\n+        {\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null)\n+            {\n+                // Unstuck with path\n+                ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+                PathPoint next = path.getPathPointFromIndex(path.getCurrentPathIndex());\n+\n+                // Blocks in front of the worker\n+                for(int i = 0; i <= 2; i++)\n                 {\n-                    mineBlock(nextPosUp);\n+                    checkPositions.add(new BlockPos(next.x, next.y + i, next.z));\n                 }\n+\n+                // Block above the worker\n+                checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 2, worker.getCurrentPosition().getZ()));\n+\n+                mineIfEqualsBlockTag(checkPositions, BlockTags.LEAVES);\n+                return;\n+            }\n+        }\n+\n+        // General unstuck\n+        ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+        List<Direction> directions = new ArrayList<>();\n+        directions.add(Direction.NORTH);\n+        directions.add(Direction.EAST);\n+        directions.add(Direction.WEST);\n+        directions.add(Direction.SOUTH);\n+\n+        for (Direction direction: directions)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84405805207686a571c33b3f4d8c34a14a6c39a7"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM2Mzg0MA==", "bodyText": "Couldn't find it :(", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r436363840", "createdAt": "2020-06-07T13:33:02Z", "author": {"login": "Tobiti"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -544,30 +556,98 @@ private Boolean isPassable(final BlockState blockState)\n         return blockState.getMaterial() == Material.LEAVES;\n     }\n \n+\n     /**\n      * Check if distance to block changed and if we are not moving for too long, try to get unstuck.\n      *\n      * @return false\n      */\n-    private boolean checkIfStuckOnLeaves()\n+    private boolean checkIfStuck()\n     {\n         if (!worker.getNavigator().noPath())\n         {\n-            Path pathToTree = worker.getNavigator().getPath();\n-            if (pathToTree != null && pathToTree.getCurrentPathLength() > pathToTree.getCurrentPathIndex())\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null)\n             {\n-                PathPoint next = pathToTree.getPathPointFromIndex(pathToTree.getCurrentPathIndex());\n-                BlockPos nextPos = new BlockPos(next.x, next.y, next.z);\n-                BlockPos nextPosUp = new BlockPos(next.x, next.y + 1, next.z);\n-\n-                if (world.getBlockState(nextPos).getBlock().isIn(BlockTags.LEAVES))\n+                if (path.getCurrentPathLength() > path.getCurrentPathIndex())\n+                {\n+                    return true;\n+                }\n+                if (path.getCurrentPathLength() == 0)\n                 {\n-                    mineBlock(nextPos);\n+                    return true;\n                 }\n-                else if (world.getBlockState(nextPosUp).getBlock().isIn(BlockTags.LEAVES))\n+            }\n+            else\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Mines leaves on path and above.\n+     */\n+    private void tryUnstuck()\n+    {\n+        if (!worker.getNavigator().noPath())\n+        {\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null)\n+            {\n+                // Unstuck with path\n+                ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+                PathPoint next = path.getPathPointFromIndex(path.getCurrentPathIndex());\n+\n+                // Blocks in front of the worker\n+                for(int i = 0; i <= 2; i++)\n                 {\n-                    mineBlock(nextPosUp);\n+                    checkPositions.add(new BlockPos(next.x, next.y + i, next.z));\n                 }\n+\n+                // Block above the worker\n+                checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 2, worker.getCurrentPosition().getZ()));\n+\n+                mineIfEqualsBlockTag(checkPositions, BlockTags.LEAVES);\n+                return;\n+            }\n+        }\n+\n+        // General unstuck\n+        ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+        List<Direction> directions = new ArrayList<>();\n+        directions.add(Direction.NORTH);\n+        directions.add(Direction.EAST);\n+        directions.add(Direction.WEST);\n+        directions.add(Direction.SOUTH);\n+\n+        for (Direction direction: directions)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM1ODg5MA=="}, "originalCommit": {"oid": "84405805207686a571c33b3f4d8c34a14a6c39a7"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM2NDIwOQ==", "bodyText": "Plane.HORIZONTAL.values()", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r436364209", "createdAt": "2020-06-07T13:37:30Z", "author": {"login": "Raycoms"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -544,30 +556,98 @@ private Boolean isPassable(final BlockState blockState)\n         return blockState.getMaterial() == Material.LEAVES;\n     }\n \n+\n     /**\n      * Check if distance to block changed and if we are not moving for too long, try to get unstuck.\n      *\n      * @return false\n      */\n-    private boolean checkIfStuckOnLeaves()\n+    private boolean checkIfStuck()\n     {\n         if (!worker.getNavigator().noPath())\n         {\n-            Path pathToTree = worker.getNavigator().getPath();\n-            if (pathToTree != null && pathToTree.getCurrentPathLength() > pathToTree.getCurrentPathIndex())\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null)\n             {\n-                PathPoint next = pathToTree.getPathPointFromIndex(pathToTree.getCurrentPathIndex());\n-                BlockPos nextPos = new BlockPos(next.x, next.y, next.z);\n-                BlockPos nextPosUp = new BlockPos(next.x, next.y + 1, next.z);\n-\n-                if (world.getBlockState(nextPos).getBlock().isIn(BlockTags.LEAVES))\n+                if (path.getCurrentPathLength() > path.getCurrentPathIndex())\n+                {\n+                    return true;\n+                }\n+                if (path.getCurrentPathLength() == 0)\n                 {\n-                    mineBlock(nextPos);\n+                    return true;\n                 }\n-                else if (world.getBlockState(nextPosUp).getBlock().isIn(BlockTags.LEAVES))\n+            }\n+            else\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Mines leaves on path and above.\n+     */\n+    private void tryUnstuck()\n+    {\n+        if (!worker.getNavigator().noPath())\n+        {\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null)\n+            {\n+                // Unstuck with path\n+                ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+                PathPoint next = path.getPathPointFromIndex(path.getCurrentPathIndex());\n+\n+                // Blocks in front of the worker\n+                for(int i = 0; i <= 2; i++)\n                 {\n-                    mineBlock(nextPosUp);\n+                    checkPositions.add(new BlockPos(next.x, next.y + i, next.z));\n                 }\n+\n+                // Block above the worker\n+                checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 2, worker.getCurrentPosition().getZ()));\n+\n+                mineIfEqualsBlockTag(checkPositions, BlockTags.LEAVES);\n+                return;\n+            }\n+        }\n+\n+        // General unstuck\n+        ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+        List<Direction> directions = new ArrayList<>();\n+        directions.add(Direction.NORTH);\n+        directions.add(Direction.EAST);\n+        directions.add(Direction.WEST);\n+        directions.add(Direction.SOUTH);\n+\n+        for (Direction direction: directions)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM1ODg5MA=="}, "originalCommit": {"oid": "84405805207686a571c33b3f4d8c34a14a6c39a7"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM2NTYyMQ==", "bodyText": "Is done :)", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r436365621", "createdAt": "2020-06-07T13:54:19Z", "author": {"login": "Tobiti"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -544,30 +556,98 @@ private Boolean isPassable(final BlockState blockState)\n         return blockState.getMaterial() == Material.LEAVES;\n     }\n \n+\n     /**\n      * Check if distance to block changed and if we are not moving for too long, try to get unstuck.\n      *\n      * @return false\n      */\n-    private boolean checkIfStuckOnLeaves()\n+    private boolean checkIfStuck()\n     {\n         if (!worker.getNavigator().noPath())\n         {\n-            Path pathToTree = worker.getNavigator().getPath();\n-            if (pathToTree != null && pathToTree.getCurrentPathLength() > pathToTree.getCurrentPathIndex())\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null)\n             {\n-                PathPoint next = pathToTree.getPathPointFromIndex(pathToTree.getCurrentPathIndex());\n-                BlockPos nextPos = new BlockPos(next.x, next.y, next.z);\n-                BlockPos nextPosUp = new BlockPos(next.x, next.y + 1, next.z);\n-\n-                if (world.getBlockState(nextPos).getBlock().isIn(BlockTags.LEAVES))\n+                if (path.getCurrentPathLength() > path.getCurrentPathIndex())\n+                {\n+                    return true;\n+                }\n+                if (path.getCurrentPathLength() == 0)\n                 {\n-                    mineBlock(nextPos);\n+                    return true;\n                 }\n-                else if (world.getBlockState(nextPosUp).getBlock().isIn(BlockTags.LEAVES))\n+            }\n+            else\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Mines leaves on path and above.\n+     */\n+    private void tryUnstuck()\n+    {\n+        if (!worker.getNavigator().noPath())\n+        {\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null)\n+            {\n+                // Unstuck with path\n+                ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+                PathPoint next = path.getPathPointFromIndex(path.getCurrentPathIndex());\n+\n+                // Blocks in front of the worker\n+                for(int i = 0; i <= 2; i++)\n                 {\n-                    mineBlock(nextPosUp);\n+                    checkPositions.add(new BlockPos(next.x, next.y + i, next.z));\n                 }\n+\n+                // Block above the worker\n+                checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 2, worker.getCurrentPosition().getZ()));\n+\n+                mineIfEqualsBlockTag(checkPositions, BlockTags.LEAVES);\n+                return;\n+            }\n+        }\n+\n+        // General unstuck\n+        ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+        List<Direction> directions = new ArrayList<>();\n+        directions.add(Direction.NORTH);\n+        directions.add(Direction.EAST);\n+        directions.add(Direction.WEST);\n+        directions.add(Direction.SOUTH);\n+\n+        for (Direction direction: directions)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM1ODg5MA=="}, "originalCommit": {"oid": "84405805207686a571c33b3f4d8c34a14a6c39a7"}, "originalPosition": 171}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3089, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}