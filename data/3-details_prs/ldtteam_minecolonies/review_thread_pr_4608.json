{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxNDIwNjA0", "number": 4608, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMzozNToxNlrODwaFxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMzo1ODozN1rODwas6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMDg1NzAzOnYy", "diffSide": "RIGHT", "path": "src/api/java/com/minecolonies/api/entity/MinecoloniesMinecart.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMzozNToxNlrOGDY-2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMzozODozNlrOGDZH6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIwODIxOQ==", "bodyText": "Why do we need that? Can't it extend Minecart entity instead? (looks way much copy code to me)", "url": "https://github.com/ldtteam/minecolonies/pull/4608#discussion_r406208219", "createdAt": "2020-04-09T13:35:16Z", "author": {"login": "Nightenom"}, "path": "src/api/java/com/minecolonies/api/entity/MinecoloniesMinecart.java", "diffHunk": "@@ -0,0 +1,291 @@\n+package com.minecolonies.api.entity;\n+\n+import com.google.common.collect.Maps;\n+import com.mojang.datafixers.util.Pair;\n+import net.minecraft.block.AbstractRailBlock;\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.PoweredRailBlock;\n+import net.minecraft.entity.Entity;\n+import net.minecraft.entity.EntityType;\n+import net.minecraft.entity.item.minecart.AbstractMinecartEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.network.IPacket;\n+import net.minecraft.state.properties.RailShape;\n+import net.minecraft.util.Direction;\n+import net.minecraft.util.Hand;\n+import net.minecraft.util.Util;\n+import net.minecraft.util.math.*;\n+import net.minecraft.world.World;\n+import net.minecraftforge.fml.network.NetworkHooks;\n+import org.jetbrains.annotations.NotNull;\n+\n+import javax.annotation.Nullable;\n+import java.util.Map;\n+\n+/**\n+ * Special minecolonies minecart that doesn't collide.\n+ */\n+public class MinecoloniesMinecart extends AbstractMinecartEntity", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe62e64c17bdb3117dfa93aad21a82f1f15b9c5c"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIxMDUzNg==", "bodyText": "No, we need to alter a bunch of code in-between unfortunately to make it work nicely for our usecase. So we already usecase as much as we could.", "url": "https://github.com/ldtteam/minecolonies/pull/4608#discussion_r406210536", "createdAt": "2020-04-09T13:38:36Z", "author": {"login": "Raycoms"}, "path": "src/api/java/com/minecolonies/api/entity/MinecoloniesMinecart.java", "diffHunk": "@@ -0,0 +1,291 @@\n+package com.minecolonies.api.entity;\n+\n+import com.google.common.collect.Maps;\n+import com.mojang.datafixers.util.Pair;\n+import net.minecraft.block.AbstractRailBlock;\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.PoweredRailBlock;\n+import net.minecraft.entity.Entity;\n+import net.minecraft.entity.EntityType;\n+import net.minecraft.entity.item.minecart.AbstractMinecartEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.network.IPacket;\n+import net.minecraft.state.properties.RailShape;\n+import net.minecraft.util.Direction;\n+import net.minecraft.util.Hand;\n+import net.minecraft.util.Util;\n+import net.minecraft.util.math.*;\n+import net.minecraft.world.World;\n+import net.minecraftforge.fml.network.NetworkHooks;\n+import org.jetbrains.annotations.NotNull;\n+\n+import javax.annotation.Nullable;\n+import java.util.Map;\n+\n+/**\n+ * Special minecolonies minecart that doesn't collide.\n+ */\n+public class MinecoloniesMinecart extends AbstractMinecartEntity", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIwODIxOQ=="}, "originalCommit": {"oid": "fe62e64c17bdb3117dfa93aad21a82f1f15b9c5c"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMDg1NzM3OnYy", "diffSide": "RIGHT", "path": "src/api/java/com/minecolonies/api/entity/MinecoloniesMinecart.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMzozNToxOVrOGDY_Cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNDowNTowMVrOGDaO5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIwODI2Ng==", "bodyText": "Do we want this to ignore powered rails and such? should overwrite\n/**\n* Return false if this cart should not call onMinecartPass() and should ignore Powered Rails.\n* @return True if this cart should call onMinecartPass().\n*/\ndefault boolean shouldDoRailFunctions() {\nreturn true;\n}\nthen", "url": "https://github.com/ldtteam/minecolonies/pull/4608#discussion_r406208266", "createdAt": "2020-04-09T13:35:19Z", "author": {"login": "someaddons"}, "path": "src/api/java/com/minecolonies/api/entity/MinecoloniesMinecart.java", "diffHunk": "@@ -0,0 +1,291 @@\n+package com.minecolonies.api.entity;\n+\n+import com.google.common.collect.Maps;\n+import com.mojang.datafixers.util.Pair;\n+import net.minecraft.block.AbstractRailBlock;\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.PoweredRailBlock;\n+import net.minecraft.entity.Entity;\n+import net.minecraft.entity.EntityType;\n+import net.minecraft.entity.item.minecart.AbstractMinecartEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.network.IPacket;\n+import net.minecraft.state.properties.RailShape;\n+import net.minecraft.util.Direction;\n+import net.minecraft.util.Hand;\n+import net.minecraft.util.Util;\n+import net.minecraft.util.math.*;\n+import net.minecraft.world.World;\n+import net.minecraftforge.fml.network.NetworkHooks;\n+import org.jetbrains.annotations.NotNull;\n+\n+import javax.annotation.Nullable;\n+import java.util.Map;\n+\n+/**\n+ * Special minecolonies minecart that doesn't collide.\n+ */\n+public class MinecoloniesMinecart extends AbstractMinecartEntity\n+{\n+    /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe62e64c17bdb3117dfa93aad21a82f1f15b9c5c"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIyODcwOA==", "bodyText": "Wanted to keep it as is for now. If we notice problems with them we can still turn them off.", "url": "https://github.com/ldtteam/minecolonies/pull/4608#discussion_r406228708", "createdAt": "2020-04-09T14:05:01Z", "author": {"login": "Raycoms"}, "path": "src/api/java/com/minecolonies/api/entity/MinecoloniesMinecart.java", "diffHunk": "@@ -0,0 +1,291 @@\n+package com.minecolonies.api.entity;\n+\n+import com.google.common.collect.Maps;\n+import com.mojang.datafixers.util.Pair;\n+import net.minecraft.block.AbstractRailBlock;\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.PoweredRailBlock;\n+import net.minecraft.entity.Entity;\n+import net.minecraft.entity.EntityType;\n+import net.minecraft.entity.item.minecart.AbstractMinecartEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.network.IPacket;\n+import net.minecraft.state.properties.RailShape;\n+import net.minecraft.util.Direction;\n+import net.minecraft.util.Hand;\n+import net.minecraft.util.Util;\n+import net.minecraft.util.math.*;\n+import net.minecraft.world.World;\n+import net.minecraftforge.fml.network.NetworkHooks;\n+import org.jetbrains.annotations.NotNull;\n+\n+import javax.annotation.Nullable;\n+import java.util.Map;\n+\n+/**\n+ * Special minecolonies minecart that doesn't collide.\n+ */\n+public class MinecoloniesMinecart extends AbstractMinecartEntity\n+{\n+    /**", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIwODI2Ng=="}, "originalCommit": {"oid": "fe62e64c17bdb3117dfa93aad21a82f1f15b9c5c"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMDkyNzc3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/minecolonies/coremod/entity/pathfinding/MinecoloniesAdvancedPathNavigate.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMzo1MjowMVrOGDZrfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMzo1MjowMVrOGDZrfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIxOTY0NA==", "bodyText": "javadoc", "url": "https://github.com/ldtteam/minecolonies/pull/4608#discussion_r406219644", "createdAt": "2020-04-09T13:52:01Z", "author": {"login": "someaddons"}, "path": "src/main/java/com/minecolonies/coremod/entity/pathfinding/MinecoloniesAdvancedPathNavigate.java", "diffHunk": "@@ -410,6 +450,105 @@ else if (ourEntity.isInWater())\n         return false;\n     }\n \n+    /**\n+     * Handle rails navigation.\n+     *\n+     * @return true if block.\n+     */\n+    private boolean handleRails()\n+    {\n+        if (!this.noPath())\n+        {\n+            @NotNull final PathPointExtended pEx = (PathPointExtended) this.getPath().getPathPointFromIndex(this.getPath().getCurrentPathIndex());\n+            final PathPointExtended pExNext = getPath().getCurrentPathLength() > this.getPath().getCurrentPathIndex() + 1\n+                                                ? (PathPointExtended) this.getPath()\n+                                                                        .getPathPointFromIndex(this.getPath()\n+                                                                                                 .getCurrentPathIndex() + 1)\n+                                                : null;\n+\n+            if (pEx.isOnRails() || pEx.isRailsExit())\n+            {\n+                return handlePathOnRails(pEx, pExNext);\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean handlePathOnRails(final PathPointExtended pEx, final PathPointExtended pExNext)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe62e64c17bdb3117dfa93aad21a82f1f15b9c5c"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMDk0NDgyOnYy", "diffSide": "LEFT", "path": "src/main/java/com/minecolonies/coremod/entity/pathfinding/MinecoloniesAdvancedPathNavigate.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMzo1NTozNlrOGDZ1zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNDowNjozOFrOGDaTfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIyMjI4Ng==", "bodyText": "think clearpath could use some dismount when it somehow gets stuck within the minecart(make them timed lifetime aswell?)", "url": "https://github.com/ldtteam/minecolonies/pull/4608#discussion_r406222286", "createdAt": "2020-04-09T13:55:36Z", "author": {"login": "someaddons"}, "path": "src/main/java/com/minecolonies/coremod/entity/pathfinding/MinecoloniesAdvancedPathNavigate.java", "diffHunk": "@@ -532,18 +671,50 @@ protected void pathFollow()\n \n     /**\n      * Don't let vanilla rapidly discard paths, set a timeout before its allowed to use stuck.\n-     *\n-     * @param positionVec3\n      */\n     @Override\n-    protected void checkForStuck(Vec3d positionVec3)\n+    protected void checkForStuck(@NotNull final Vec3d positionVec3)\n     {\n         if (world.getGameTime() - pathStartTime < MIN_KEEP_TIME)\n         {\n             return;\n         }\n \n-        super.checkForStuck(positionVec3);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe62e64c17bdb3117dfa93aad21a82f1f15b9c5c"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIyOTg4Nw==", "bodyText": "they will automatically dismount when they try a new path that doesn't take the rail.", "url": "https://github.com/ldtteam/minecolonies/pull/4608#discussion_r406229887", "createdAt": "2020-04-09T14:06:38Z", "author": {"login": "Raycoms"}, "path": "src/main/java/com/minecolonies/coremod/entity/pathfinding/MinecoloniesAdvancedPathNavigate.java", "diffHunk": "@@ -532,18 +671,50 @@ protected void pathFollow()\n \n     /**\n      * Don't let vanilla rapidly discard paths, set a timeout before its allowed to use stuck.\n-     *\n-     * @param positionVec3\n      */\n     @Override\n-    protected void checkForStuck(Vec3d positionVec3)\n+    protected void checkForStuck(@NotNull final Vec3d positionVec3)\n     {\n         if (world.getGameTime() - pathStartTime < MIN_KEEP_TIME)\n         {\n             return;\n         }\n \n-        super.checkForStuck(positionVec3);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIyMjI4Ng=="}, "originalCommit": {"oid": "fe62e64c17bdb3117dfa93aad21a82f1f15b9c5c"}, "originalPosition": 216}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMDk1NzIwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/minecolonies/coremod/entity/pathfinding/MinecoloniesAdvancedPathNavigate.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMzo1ODozN1rOGDZ98Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNDowNjo0OVrOGDaUCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIyNDM2OQ==", "bodyText": "old todo?", "url": "https://github.com/ldtteam/minecolonies/pull/4608#discussion_r406224369", "createdAt": "2020-04-09T13:58:37Z", "author": {"login": "someaddons"}, "path": "src/main/java/com/minecolonies/coremod/entity/pathfinding/MinecoloniesAdvancedPathNavigate.java", "diffHunk": "@@ -410,6 +450,105 @@ else if (ourEntity.isInWater())\n         return false;\n     }\n \n+    /**\n+     * Handle rails navigation.\n+     *\n+     * @return true if block.\n+     */\n+    private boolean handleRails()\n+    {\n+        if (!this.noPath())\n+        {\n+            @NotNull final PathPointExtended pEx = (PathPointExtended) this.getPath().getPathPointFromIndex(this.getPath().getCurrentPathIndex());\n+            final PathPointExtended pExNext = getPath().getCurrentPathLength() > this.getPath().getCurrentPathIndex() + 1\n+                                                ? (PathPointExtended) this.getPath()\n+                                                                        .getPathPointFromIndex(this.getPath()\n+                                                                                                 .getCurrentPathIndex() + 1)\n+                                                : null;\n+\n+            if (pEx.isOnRails() || pEx.isRailsExit())\n+            {\n+                return handlePathOnRails(pEx, pExNext);\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean handlePathOnRails(final PathPointExtended pEx, final PathPointExtended pExNext)\n+    {\n+        if (pEx.isRailsEntry())\n+        {\n+            final BlockPos blockPos = new BlockPos(pEx.x, pEx.y, pEx.z);\n+            if (!spawnedPos.equals(blockPos))\n+            {\n+                final BlockState blockstate = world.getBlockState(blockPos);\n+                RailShape railshape = blockstate.getBlock() instanceof AbstractRailBlock\n+                                        ? ((AbstractRailBlock) blockstate.getBlock()).getRailDirection(blockstate, world, blockPos, null)\n+                                        : RailShape.NORTH_SOUTH;\n+                double yOffset = 0.0D;\n+                if (railshape.isAscending())\n+                {\n+                    yOffset = 0.5D;\n+                }\n+\n+                if (entity.ridingEntity instanceof MinecoloniesMinecart)\n+                {\n+                    ((MinecoloniesMinecart) entity.ridingEntity).setRollingDirection(1);\n+                }\n+                else\n+                {\n+                    MinecoloniesMinecart minecart = (MinecoloniesMinecart) ModEntities.MINECART.create(world);\n+                    final double x = pEx.x + 0.5D;\n+                    final double y = pEx.y + 0.625D + yOffset;\n+                    final double z = pEx.z + 0.5D;\n+                    minecart.setPosition(x, y, z);\n+                    minecart.setMotion(Vec3d.ZERO);\n+                    minecart.prevPosX = x;\n+                    minecart.prevPosY = y;\n+                    minecart.prevPosZ = z;\n+\n+\n+                    world.addEntity(minecart);\n+                    minecart.setRollingDirection(1);\n+                    entity.startRiding(minecart, true);\n+                }\n+                spawnedPos = blockPos;\n+            }\n+        }\n+        else\n+        {\n+            spawnedPos = BlockPos.ZERO;\n+        }\n+\n+        if (entity.ridingEntity instanceof MinecoloniesMinecart && pExNext != null)\n+        {\n+            final BlockPos blockPos = new BlockPos(pEx.x, pEx.y, pEx.z);\n+            final BlockPos blockPosNext = new BlockPos(pExNext.x, pExNext.y, pExNext.z);\n+            final Vec3d motion = entity.ridingEntity.getMotion();\n+            double forward;\n+            switch (BlockPosUtil.getXZFacing(blockPos, blockPosNext).getOpposite())\n+            {\n+                case EAST:\n+                    forward = Math.min(Math.max(motion.getX() - 1 * 0.01D, -1), 0);\n+                    entity.ridingEntity.setMotion(motion.add(forward == -1 ? -1 : -1 * 0.01D, 0.0D, 0.0D));\n+                    break;\n+                case WEST:\n+                    forward = Math.max(Math.min(motion.getX() + 0.01D, 1), 0);\n+                    entity.ridingEntity.setMotion(motion.add(forward == 1 ? 1 : 0.01D, 0.0D, 0.0D));\n+                    break;\n+                case NORTH:\n+                    forward = Math.max(Math.min(motion.getZ() + 0.01D, 1), 0);\n+                    entity.ridingEntity.setMotion(motion.add(0.0D, 0.0D, forward == 1 ? 1 : 0.01D));\n+                    break;\n+                case SOUTH:\n+                    forward = Math.min(Math.max(motion.getZ() - 1 * 0.01D, -1), 0);\n+                    entity.ridingEntity.setMotion(motion.add(0.0D, 0.0D, forward == -1 ? -1 : -1 * 0.01D));\n+            }\n+            //todo add research branch civilian where we add using railcarts as an option to guard this.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe62e64c17bdb3117dfa93aad21a82f1f15b9c5c"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIzMDAyNw==", "bodyText": "yes", "url": "https://github.com/ldtteam/minecolonies/pull/4608#discussion_r406230027", "createdAt": "2020-04-09T14:06:49Z", "author": {"login": "Raycoms"}, "path": "src/main/java/com/minecolonies/coremod/entity/pathfinding/MinecoloniesAdvancedPathNavigate.java", "diffHunk": "@@ -410,6 +450,105 @@ else if (ourEntity.isInWater())\n         return false;\n     }\n \n+    /**\n+     * Handle rails navigation.\n+     *\n+     * @return true if block.\n+     */\n+    private boolean handleRails()\n+    {\n+        if (!this.noPath())\n+        {\n+            @NotNull final PathPointExtended pEx = (PathPointExtended) this.getPath().getPathPointFromIndex(this.getPath().getCurrentPathIndex());\n+            final PathPointExtended pExNext = getPath().getCurrentPathLength() > this.getPath().getCurrentPathIndex() + 1\n+                                                ? (PathPointExtended) this.getPath()\n+                                                                        .getPathPointFromIndex(this.getPath()\n+                                                                                                 .getCurrentPathIndex() + 1)\n+                                                : null;\n+\n+            if (pEx.isOnRails() || pEx.isRailsExit())\n+            {\n+                return handlePathOnRails(pEx, pExNext);\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean handlePathOnRails(final PathPointExtended pEx, final PathPointExtended pExNext)\n+    {\n+        if (pEx.isRailsEntry())\n+        {\n+            final BlockPos blockPos = new BlockPos(pEx.x, pEx.y, pEx.z);\n+            if (!spawnedPos.equals(blockPos))\n+            {\n+                final BlockState blockstate = world.getBlockState(blockPos);\n+                RailShape railshape = blockstate.getBlock() instanceof AbstractRailBlock\n+                                        ? ((AbstractRailBlock) blockstate.getBlock()).getRailDirection(blockstate, world, blockPos, null)\n+                                        : RailShape.NORTH_SOUTH;\n+                double yOffset = 0.0D;\n+                if (railshape.isAscending())\n+                {\n+                    yOffset = 0.5D;\n+                }\n+\n+                if (entity.ridingEntity instanceof MinecoloniesMinecart)\n+                {\n+                    ((MinecoloniesMinecart) entity.ridingEntity).setRollingDirection(1);\n+                }\n+                else\n+                {\n+                    MinecoloniesMinecart minecart = (MinecoloniesMinecart) ModEntities.MINECART.create(world);\n+                    final double x = pEx.x + 0.5D;\n+                    final double y = pEx.y + 0.625D + yOffset;\n+                    final double z = pEx.z + 0.5D;\n+                    minecart.setPosition(x, y, z);\n+                    minecart.setMotion(Vec3d.ZERO);\n+                    minecart.prevPosX = x;\n+                    minecart.prevPosY = y;\n+                    minecart.prevPosZ = z;\n+\n+\n+                    world.addEntity(minecart);\n+                    minecart.setRollingDirection(1);\n+                    entity.startRiding(minecart, true);\n+                }\n+                spawnedPos = blockPos;\n+            }\n+        }\n+        else\n+        {\n+            spawnedPos = BlockPos.ZERO;\n+        }\n+\n+        if (entity.ridingEntity instanceof MinecoloniesMinecart && pExNext != null)\n+        {\n+            final BlockPos blockPos = new BlockPos(pEx.x, pEx.y, pEx.z);\n+            final BlockPos blockPosNext = new BlockPos(pExNext.x, pExNext.y, pExNext.z);\n+            final Vec3d motion = entity.ridingEntity.getMotion();\n+            double forward;\n+            switch (BlockPosUtil.getXZFacing(blockPos, blockPosNext).getOpposite())\n+            {\n+                case EAST:\n+                    forward = Math.min(Math.max(motion.getX() - 1 * 0.01D, -1), 0);\n+                    entity.ridingEntity.setMotion(motion.add(forward == -1 ? -1 : -1 * 0.01D, 0.0D, 0.0D));\n+                    break;\n+                case WEST:\n+                    forward = Math.max(Math.min(motion.getX() + 0.01D, 1), 0);\n+                    entity.ridingEntity.setMotion(motion.add(forward == 1 ? 1 : 0.01D, 0.0D, 0.0D));\n+                    break;\n+                case NORTH:\n+                    forward = Math.max(Math.min(motion.getZ() + 0.01D, 1), 0);\n+                    entity.ridingEntity.setMotion(motion.add(0.0D, 0.0D, forward == 1 ? 1 : 0.01D));\n+                    break;\n+                case SOUTH:\n+                    forward = Math.min(Math.max(motion.getZ() - 1 * 0.01D, -1), 0);\n+                    entity.ridingEntity.setMotion(motion.add(0.0D, 0.0D, forward == -1 ? -1 : -1 * 0.01D));\n+            }\n+            //todo add research branch civilian where we add using railcarts as an option to guard this.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIyNDM2OQ=="}, "originalCommit": {"oid": "fe62e64c17bdb3117dfa93aad21a82f1f15b9c5c"}, "originalPosition": 183}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3124, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}