{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA0MDM5NTMx", "number": 4645, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxMTo0MDoyNVrODydnUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxOTo0NDozNlrOD0Z8xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MjQwNTk1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingWareHouse.java", "isResolved": false, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxMTo0MDoyNVrOGGhPrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQxMTo0ODowNFrOGHqY4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ4OTMyNQ==", "bodyText": "our buildings already have a list of containers, called containerList. So you don't need to add all this stuff", "url": "https://github.com/ldtteam/minecolonies/pull/4645#discussion_r409489325", "createdAt": "2020-04-16T11:40:25Z", "author": {"login": "someaddons"}, "path": "src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingWareHouse.java", "diffHunk": "@@ -525,6 +537,8 @@ else if (request != null)\n          */\n         private boolean reachedLimit = false;\n \n+        private List<BlockPos> storageracks = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e570e69500186e03ca671be786c93e668cf62028"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTUwNzQyNQ==", "bodyText": "This is in the deserialize which is accessed by the View. i can not access the containerList there.. i tried a lot to access the container list but failed.", "url": "https://github.com/ldtteam/minecolonies/pull/4645#discussion_r409507425", "createdAt": "2020-04-16T12:14:23Z", "author": {"login": "lexustec"}, "path": "src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingWareHouse.java", "diffHunk": "@@ -525,6 +537,8 @@ else if (request != null)\n          */\n         private boolean reachedLimit = false;\n \n+        private List<BlockPos> storageracks = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ4OTMyNQ=="}, "originalCommit": {"oid": "e570e69500186e03ca671be786c93e668cf62028"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTUwODMwNA==", "bodyText": "oh its in the view, then you probably don't need it at all. The warehouse tileentity has a combined inventory of all rakcs", "url": "https://github.com/ldtteam/minecolonies/pull/4645#discussion_r409508304", "createdAt": "2020-04-16T12:15:50Z", "author": {"login": "someaddons"}, "path": "src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingWareHouse.java", "diffHunk": "@@ -525,6 +537,8 @@ else if (request != null)\n          */\n         private boolean reachedLimit = false;\n \n+        private List<BlockPos> storageracks = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ4OTMyNQ=="}, "originalCommit": {"oid": "e570e69500186e03ca671be786c93e668cf62028"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTUxMTgxMw==", "bodyText": "oO okay ? this i built separately in the View. it iterates through all racks and adds up.", "url": "https://github.com/ldtteam/minecolonies/pull/4645#discussion_r409511813", "createdAt": "2020-04-16T12:21:43Z", "author": {"login": "lexustec"}, "path": "src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingWareHouse.java", "diffHunk": "@@ -525,6 +537,8 @@ else if (request != null)\n          */\n         private boolean reachedLimit = false;\n \n+        private List<BlockPos> storageracks = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ4OTMyNQ=="}, "originalCommit": {"oid": "e570e69500186e03ca671be786c93e668cf62028"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTUxMjI3MQ==", "bodyText": "ye you made more effort than you need to xD", "url": "https://github.com/ldtteam/minecolonies/pull/4645#discussion_r409512271", "createdAt": "2020-04-16T12:22:29Z", "author": {"login": "someaddons"}, "path": "src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingWareHouse.java", "diffHunk": "@@ -525,6 +537,8 @@ else if (request != null)\n          */\n         private boolean reachedLimit = false;\n \n+        private List<BlockPos> storageracks = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ4OTMyNQ=="}, "originalCommit": {"oid": "e570e69500186e03ca671be786c93e668cf62028"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTUxMzYwNA==", "bodyText": "sth like tileentity.getCapability(CapabilityItemHandler.ITEM_HANDLER_CAPABILITY,null) and you get an already combined IItemhandler", "url": "https://github.com/ldtteam/minecolonies/pull/4645#discussion_r409513604", "createdAt": "2020-04-16T12:24:45Z", "author": {"login": "someaddons"}, "path": "src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingWareHouse.java", "diffHunk": "@@ -525,6 +537,8 @@ else if (request != null)\n          */\n         private boolean reachedLimit = false;\n \n+        private List<BlockPos> storageracks = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ4OTMyNQ=="}, "originalCommit": {"oid": "e570e69500186e03ca671be786c93e668cf62028"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY4NzE4OA==", "bodyText": "Yep this will need to be removed for simplicities sake.", "url": "https://github.com/ldtteam/minecolonies/pull/4645#discussion_r410687188", "createdAt": "2020-04-18T11:40:53Z", "author": {"login": "OrionDevelopment"}, "path": "src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingWareHouse.java", "diffHunk": "@@ -525,6 +537,8 @@ else if (request != null)\n          */\n         private boolean reachedLimit = false;\n \n+        private List<BlockPos> storageracks = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ4OTMyNQ=="}, "originalCommit": {"oid": "e570e69500186e03ca671be786c93e668cf62028"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY4NzcxNQ==", "bodyText": "I think how it is right now it is more efficient since he gets the cached content list @OrionDevelopment", "url": "https://github.com/ldtteam/minecolonies/pull/4645#discussion_r410687715", "createdAt": "2020-04-18T11:48:04Z", "author": {"login": "Raycoms"}, "path": "src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingWareHouse.java", "diffHunk": "@@ -525,6 +537,8 @@ else if (request != null)\n          */\n         private boolean reachedLimit = false;\n \n+        private List<BlockPos> storageracks = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ4OTMyNQ=="}, "originalCommit": {"oid": "e570e69500186e03ca671be786c93e668cf62028"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MjQxODYyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/minecolonies/coremod/entity/ai/basic/AbstractEntityAIBasic.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxMTo0NDoxNlrOGGhXfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxMjowODo0M1rOGGiKUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ5MTMyNg==", "bodyText": "make it two parameters isntead of the tuple", "url": "https://github.com/ldtteam/minecolonies/pull/4645#discussion_r409491326", "createdAt": "2020-04-16T11:44:16Z", "author": {"login": "someaddons"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/basic/AbstractEntityAIBasic.java", "diffHunk": "@@ -1463,19 +1435,58 @@ public boolean checkIfRequestForItemExistOrCreateAsynch(@NotNull final ItemStack\n      * @param predicate the predicate to evaluate.\n      * @return true if succesful.\n      */\n-    private boolean tryTransferFromPosToWorker(final BlockPos pos, @NotNull final Predicate<ItemStack> predicate)\n+\n+    private boolean tryTransferFromPosToWorker(final BlockPos pos, @NotNull final Tuple<Predicate<ItemStack>, Integer> predicate)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e570e69500186e03ca671be786c93e668cf62028"}, "originalPosition": 405}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTUwNDMzNg==", "bodyText": "The Itemlist created at  is a Tuple<Predicate, Integer> because the needsCurrently var as the transfer var is feeded in the workers. and the Predicate doesnt transfer the count.", "url": "https://github.com/ldtteam/minecolonies/pull/4645#discussion_r409504336", "createdAt": "2020-04-16T12:08:43Z", "author": {"login": "lexustec"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/basic/AbstractEntityAIBasic.java", "diffHunk": "@@ -1463,19 +1435,58 @@ public boolean checkIfRequestForItemExistOrCreateAsynch(@NotNull final ItemStack\n      * @param predicate the predicate to evaluate.\n      * @return true if succesful.\n      */\n-    private boolean tryTransferFromPosToWorker(final BlockPos pos, @NotNull final Predicate<ItemStack> predicate)\n+\n+    private boolean tryTransferFromPosToWorker(final BlockPos pos, @NotNull final Tuple<Predicate<ItemStack>, Integer> predicate)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ5MTMyNg=="}, "originalCommit": {"oid": "e570e69500186e03ca671be786c93e668cf62028"}, "originalPosition": 405}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MjQyMTQwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/minecolonies/coremod/entity/ai/basic/AbstractEntityAIBasic.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxMTo0NTowOFrOGGhZNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxMjoxNzowNFrOGGicxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ5MTc2Ng==", "bodyText": "sure this is right? tryTransferFromPosToWorker doesnt seem like a function which checks the own inventory for contains", "url": "https://github.com/ldtteam/minecolonies/pull/4645#discussion_r409491766", "createdAt": "2020-04-16T11:45:08Z", "author": {"login": "someaddons"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/basic/AbstractEntityAIBasic.java", "diffHunk": "@@ -1463,19 +1435,58 @@ public boolean checkIfRequestForItemExistOrCreateAsynch(@NotNull final ItemStack\n      * @param predicate the predicate to evaluate.\n      * @return true if succesful.\n      */\n-    private boolean tryTransferFromPosToWorker(final BlockPos pos, @NotNull final Predicate<ItemStack> predicate)\n+\n+    private boolean tryTransferFromPosToWorker(final BlockPos pos, @NotNull final Tuple<Predicate<ItemStack>, Integer> predicate)\n     {\n         final TileEntity entity = world.getTileEntity(pos);\n         if (entity == null)\n         {\n             return false;\n         }\n \n-        return InventoryUtils.transferXOfFirstSlotInProviderWithIntoNextFreeSlotInItemHandler(\n-          entity,\n-          predicate,\n-          Constants.STACKSIZE,\n-          worker.getInventoryCitizen());\n+        final int existingAmount = InventoryUtils.getItemCountInItemHandler(worker.getInventoryCitizen(), predicate.getA());\n+        int amount = 0;\n+        if (predicate.getB() > existingAmount)\n+        {\n+            amount = predicate.getB() - existingAmount;\n+        }\n+        else\n+        {\n+            return true; // has already needed transfers...", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e570e69500186e03ca671be786c93e668cf62028"}, "originalPosition": 426}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ5NjUwNA==", "bodyText": "this is why i added getItemCountInItemHandler. which assists in picking the correct amount. like if i need 2 stacks he will pick 2 stacks ( the Do while loop ). prevents that a Builder walks multiple times for the same stuff.", "url": "https://github.com/ldtteam/minecolonies/pull/4645#discussion_r409496504", "createdAt": "2020-04-16T11:54:13Z", "author": {"login": "lexustec"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/basic/AbstractEntityAIBasic.java", "diffHunk": "@@ -1463,19 +1435,58 @@ public boolean checkIfRequestForItemExistOrCreateAsynch(@NotNull final ItemStack\n      * @param predicate the predicate to evaluate.\n      * @return true if succesful.\n      */\n-    private boolean tryTransferFromPosToWorker(final BlockPos pos, @NotNull final Predicate<ItemStack> predicate)\n+\n+    private boolean tryTransferFromPosToWorker(final BlockPos pos, @NotNull final Tuple<Predicate<ItemStack>, Integer> predicate)\n     {\n         final TileEntity entity = world.getTileEntity(pos);\n         if (entity == null)\n         {\n             return false;\n         }\n \n-        return InventoryUtils.transferXOfFirstSlotInProviderWithIntoNextFreeSlotInItemHandler(\n-          entity,\n-          predicate,\n-          Constants.STACKSIZE,\n-          worker.getInventoryCitizen());\n+        final int existingAmount = InventoryUtils.getItemCountInItemHandler(worker.getInventoryCitizen(), predicate.getA());\n+        int amount = 0;\n+        if (predicate.getB() > existingAmount)\n+        {\n+            amount = predicate.getB() - existingAmount;\n+        }\n+        else\n+        {\n+            return true; // has already needed transfers...", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ5MTc2Ng=="}, "originalCommit": {"oid": "e570e69500186e03ca671be786c93e668cf62028"}, "originalPosition": 426}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTUwNjM0Mw==", "bodyText": "ye then rename the function to sth like transferItemsIfNeeded or so", "url": "https://github.com/ldtteam/minecolonies/pull/4645#discussion_r409506343", "createdAt": "2020-04-16T12:12:29Z", "author": {"login": "someaddons"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/basic/AbstractEntityAIBasic.java", "diffHunk": "@@ -1463,19 +1435,58 @@ public boolean checkIfRequestForItemExistOrCreateAsynch(@NotNull final ItemStack\n      * @param predicate the predicate to evaluate.\n      * @return true if succesful.\n      */\n-    private boolean tryTransferFromPosToWorker(final BlockPos pos, @NotNull final Predicate<ItemStack> predicate)\n+\n+    private boolean tryTransferFromPosToWorker(final BlockPos pos, @NotNull final Tuple<Predicate<ItemStack>, Integer> predicate)\n     {\n         final TileEntity entity = world.getTileEntity(pos);\n         if (entity == null)\n         {\n             return false;\n         }\n \n-        return InventoryUtils.transferXOfFirstSlotInProviderWithIntoNextFreeSlotInItemHandler(\n-          entity,\n-          predicate,\n-          Constants.STACKSIZE,\n-          worker.getInventoryCitizen());\n+        final int existingAmount = InventoryUtils.getItemCountInItemHandler(worker.getInventoryCitizen(), predicate.getA());\n+        int amount = 0;\n+        if (predicate.getB() > existingAmount)\n+        {\n+            amount = predicate.getB() - existingAmount;\n+        }\n+        else\n+        {\n+            return true; // has already needed transfers...", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ5MTc2Ng=="}, "originalCommit": {"oid": "e570e69500186e03ca671be786c93e668cf62028"}, "originalPosition": 426}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTUwOTA2Mg==", "bodyText": "i can. is only used by pickupMaterials() anyway.", "url": "https://github.com/ldtteam/minecolonies/pull/4645#discussion_r409509062", "createdAt": "2020-04-16T12:17:04Z", "author": {"login": "lexustec"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/basic/AbstractEntityAIBasic.java", "diffHunk": "@@ -1463,19 +1435,58 @@ public boolean checkIfRequestForItemExistOrCreateAsynch(@NotNull final ItemStack\n      * @param predicate the predicate to evaluate.\n      * @return true if succesful.\n      */\n-    private boolean tryTransferFromPosToWorker(final BlockPos pos, @NotNull final Predicate<ItemStack> predicate)\n+\n+    private boolean tryTransferFromPosToWorker(final BlockPos pos, @NotNull final Tuple<Predicate<ItemStack>, Integer> predicate)\n     {\n         final TileEntity entity = world.getTileEntity(pos);\n         if (entity == null)\n         {\n             return false;\n         }\n \n-        return InventoryUtils.transferXOfFirstSlotInProviderWithIntoNextFreeSlotInItemHandler(\n-          entity,\n-          predicate,\n-          Constants.STACKSIZE,\n-          worker.getInventoryCitizen());\n+        final int existingAmount = InventoryUtils.getItemCountInItemHandler(worker.getInventoryCitizen(), predicate.getA());\n+        int amount = 0;\n+        if (predicate.getB() > existingAmount)\n+        {\n+            amount = predicate.getB() - existingAmount;\n+        }\n+        else\n+        {\n+            return true; // has already needed transfers...", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ5MTc2Ng=="}, "originalCommit": {"oid": "e570e69500186e03ca671be786c93e668cf62028"}, "originalPosition": 426}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MjQyNzEzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/minecolonies/coremod/entity/ai/basic/AbstractEntityAICrafting.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxMTo0NzowMVrOGGhc5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxMTo1MDoxNVrOGGhjqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ5MjcwOQ==", "bodyText": "why Constants.STACKSIZE instead of inputStorage.amount?", "url": "https://github.com/ldtteam/minecolonies/pull/4645#discussion_r409492709", "createdAt": "2020-04-16T11:47:01Z", "author": {"login": "someaddons"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/basic/AbstractEntityAICrafting.java", "diffHunk": "@@ -164,19 +169,20 @@ private IAIState queryItems()\n \n     /**\n      * Check for all items of the required recipe.\n+     *\n      * @return the next state to go to.\n      */\n     protected IAIState checkForItems(@NotNull final IRecipeStorage storage)\n     {\n         final List<ItemStorage> input = storage.getCleanedInput();\n-        for(final ItemStorage inputStorage : input)\n+        for (final ItemStorage inputStorage : input)\n         {\n             final Predicate<ItemStack> predicate = stack -> !ItemStackUtils.isEmpty(stack) && new Stack(stack).matches(inputStorage.getItemStack());\n             if (InventoryUtils.getItemCountInItemHandler(worker.getInventoryCitizen(), predicate) < inputStorage.getAmount())\n             {\n                 if (InventoryUtils.hasItemInProvider(getOwnBuilding(), predicate))\n                 {\n-                    needsCurrently = predicate;\n+                    needsCurrently = new Tuple<>(predicate, Constants.STACKSIZE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e570e69500186e03ca671be786c93e668cf62028"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ5NDQ0MA==", "bodyText": "because i experienced that ItemStack sometimes has more than STACKSIZE ( see in pickupMaterial() when it creates the list.)", "url": "https://github.com/ldtteam/minecolonies/pull/4645#discussion_r409494440", "createdAt": "2020-04-16T11:50:15Z", "author": {"login": "lexustec"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/basic/AbstractEntityAICrafting.java", "diffHunk": "@@ -164,19 +169,20 @@ private IAIState queryItems()\n \n     /**\n      * Check for all items of the required recipe.\n+     *\n      * @return the next state to go to.\n      */\n     protected IAIState checkForItems(@NotNull final IRecipeStorage storage)\n     {\n         final List<ItemStorage> input = storage.getCleanedInput();\n-        for(final ItemStorage inputStorage : input)\n+        for (final ItemStorage inputStorage : input)\n         {\n             final Predicate<ItemStack> predicate = stack -> !ItemStackUtils.isEmpty(stack) && new Stack(stack).matches(inputStorage.getItemStack());\n             if (InventoryUtils.getItemCountInItemHandler(worker.getInventoryCitizen(), predicate) < inputStorage.getAmount())\n             {\n                 if (InventoryUtils.hasItemInProvider(getOwnBuilding(), predicate))\n                 {\n-                    needsCurrently = predicate;\n+                    needsCurrently = new Tuple<>(predicate, Constants.STACKSIZE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ5MjcwOQ=="}, "originalCommit": {"oid": "e570e69500186e03ca671be786c93e668cf62028"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODQxMjE3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/minecolonies/coremod/client/gui/WindowHutWareHouse.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDoyNjo1OVrOGHcFvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMTowODoxMlrOGHdJJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1MzQzNg==", "bodyText": "private + javadoc please", "url": "https://github.com/ldtteam/minecolonies/pull/4645#discussion_r410453436", "createdAt": "2020-04-17T20:26:59Z", "author": {"login": "Raycoms"}, "path": "src/main/java/com/minecolonies/coremod/client/gui/WindowHutWareHouse.java", "diffHunk": "@@ -107,6 +146,37 @@ private void addStock()\n         }\n     }\n \n+    void setSortFlag()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a1029b5bd31af85d7627964bce6878808a56b78"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ3MDY5NA==", "bodyText": "done", "url": "https://github.com/ldtteam/minecolonies/pull/4645#discussion_r410470694", "createdAt": "2020-04-17T21:08:12Z", "author": {"login": "lexustec"}, "path": "src/main/java/com/minecolonies/coremod/client/gui/WindowHutWareHouse.java", "diffHunk": "@@ -107,6 +146,37 @@ private void addStock()\n         }\n     }\n \n+    void setSortFlag()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1MzQzNg=="}, "originalCommit": {"oid": "8a1029b5bd31af85d7627964bce6878808a56b78"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODQxMzkzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/minecolonies/coremod/client/gui/WindowHutWareHouse.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDoyNzozOVrOGHcG4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDoyNzozOVrOGHcG4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1MzczMQ==", "bodyText": "javadoc for the remaining options please", "url": "https://github.com/ldtteam/minecolonies/pull/4645#discussion_r410453731", "createdAt": "2020-04-17T20:27:39Z", "author": {"login": "Raycoms"}, "path": "src/main/java/com/minecolonies/coremod/client/gui/WindowHutWareHouse.java", "diffHunk": "@@ -36,10 +46,36 @@\n  */\n public class WindowHutWareHouse extends AbstractWindowBuilding<BuildingWareHouse.View>\n {\n+    /**\n+     * List of all item stacks in the warehouse.\n+     */\n+    List<ItemStorage> allItems = new ArrayList<>();\n+\n+    /**\n+     * Resource scrolling list.\n+     */\n+    private final       ScrollingList stackList;\n+    /**\n+     * The filter for the resource list.\n+     */\n+    private             String        filter          = \"\";\n+    /**\n+     * The sortDescriptor so how we want to sort\n+     */\n+    public static final int           NO_SORT         = 0;\n+    public static final int           ASC_SORT        = 1;\n+    public static final int           DESC_SORT       = 2;\n+    public static final int           COUNT_ASC_SORT  = 3;\n+    public static final int           COUNT_DESC_SORT = 4;\n+    int sortDescriptor = 0;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a1029b5bd31af85d7627964bce6878808a56b78"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODQxNjYxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/minecolonies/coremod/client/gui/WindowHutWareHouse.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDoyODozOVrOGHcIlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMToxNzo0MVrOGHdX8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1NDE2NA==", "bodyText": "Btw, there is already a way to get ItemStorage from the rack without having to go through all slots", "url": "https://github.com/ldtteam/minecolonies/pull/4645#discussion_r410454164", "createdAt": "2020-04-17T20:28:39Z", "author": {"login": "Raycoms"}, "path": "src/main/java/com/minecolonies/coremod/client/gui/WindowHutWareHouse.java", "diffHunk": "@@ -247,6 +315,151 @@ public void updateElement(final int index, @NotNull final Pane rowPane)\n         });\n     }\n \n+    /**\n+     * Update the item list.\n+     */\n+    private void updateResources()\n+    {\n+        List<ItemStorage> filterItems = new ArrayList<>();\n+        final List<BlockPos> containerList = building.getContainerList();\n+        List<ItemStack> items = new ArrayList<>();\n+        int count = containerList.size();\n+        World world = building.getColony().getWorld();\n+\n+        for (int s = 0; s < count; s++)\n+        {\n+            final TileEntity rack = world.getTileEntity(containerList.get(s));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a1029b5bd31af85d7627964bce6878808a56b78"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ3NDQ4MQ==", "bodyText": "I need to go through all slots of all Racks because i am summing all up. because Multiple Stacks of the same type can be in multiple Racks. This function creates basically a single ItemStack List with all combined.\nThe getContainerlist returns only the block position from the building. i couldnt access it directly because i am in the View part. so i need to serialize and deserialize it. i serialized the containerList from the building side and deserialized it in the view part. from there i get the inventory of each rack. and then i need to sum up all together. then adding the filter and set it to the allItems List and call the updateResourceList", "url": "https://github.com/ldtteam/minecolonies/pull/4645#discussion_r410474481", "createdAt": "2020-04-17T21:17:41Z", "author": {"login": "lexustec"}, "path": "src/main/java/com/minecolonies/coremod/client/gui/WindowHutWareHouse.java", "diffHunk": "@@ -247,6 +315,151 @@ public void updateElement(final int index, @NotNull final Pane rowPane)\n         });\n     }\n \n+    /**\n+     * Update the item list.\n+     */\n+    private void updateResources()\n+    {\n+        List<ItemStorage> filterItems = new ArrayList<>();\n+        final List<BlockPos> containerList = building.getContainerList();\n+        List<ItemStack> items = new ArrayList<>();\n+        int count = containerList.size();\n+        World world = building.getColony().getWorld();\n+\n+        for (int s = 0; s < count; s++)\n+        {\n+            final TileEntity rack = world.getTileEntity(containerList.get(s));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1NDE2NA=="}, "originalCommit": {"oid": "8a1029b5bd31af85d7627964bce6878808a56b78"}, "originalPosition": 189}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NjAwNDI2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/minecolonies/coremod/client/gui/WindowHutAllInventory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozNDo0MFrOGIXofQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozNDo0MFrOGIXofQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyODk4OQ==", "bodyText": "if not instanceof TileEntityRack but rack.getCapability(IItemHandlerCap) then  get itemhandler and iterate over slots.", "url": "https://github.com/ldtteam/minecolonies/pull/4645#discussion_r411428989", "createdAt": "2020-04-20T14:34:40Z", "author": {"login": "Raycoms"}, "path": "src/main/java/com/minecolonies/coremod/client/gui/WindowHutAllInventory.java", "diffHunk": "@@ -0,0 +1,251 @@\n+package com.minecolonies.coremod.client.gui;\n+\n+import com.ldtteam.blockout.Pane;\n+import com.ldtteam.blockout.controls.*;\n+import com.ldtteam.blockout.views.ScrollingList;\n+import com.minecolonies.api.colony.buildings.views.IBuildingView;\n+import com.minecolonies.api.crafting.ItemStorage;\n+import com.minecolonies.api.tileentities.TileEntityRack;\n+import com.minecolonies.api.util.Log;\n+import com.minecolonies.api.util.constant.Constants;\n+\n+import com.minecolonies.coremod.colony.buildings.AbstractBuilding;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.tileentity.TileEntity;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.world.World;\n+import org.jetbrains.annotations.NotNull;\n+\n+import java.util.*;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import static com.minecolonies.api.util.constant.WindowConstants.*;\n+import com.minecolonies.api.util.constant.WindowConstants;\n+/**\n+ * Window for a hut name entry.\n+ */\n+public class WindowHutAllInventory extends AbstractWindowSkeleton\n+{\n+\n+    /**\n+     * List of all item stacks in the warehouse.\n+     */\n+    List<ItemStorage> allItems = new ArrayList<>();\n+\n+    /**\n+     * Resource scrolling list.\n+     */\n+    private final ScrollingList stackList;\n+    /**\n+     * The filter for the resource list.\n+     */\n+    private       String        filter         = \"\";\n+    /**\n+     * The sortDescriptor so how we want to sort\n+     */\n+    private       int           sortDescriptor = 0;\n+\n+    /**\n+     * The building associated to the GUI.\n+     */\n+    private final IBuildingView building;\n+\n+    /**\n+     * Constructor for a hut rename entry window.\n+     *\n+     * @param b {@link AbstractBuilding}\n+     */\n+    public WindowHutAllInventory(final IBuildingView b)\n+    {\n+        super(Constants.MOD_ID + HUT_ALL_INVENTORY_SUFFIX);\n+        this.building = b;\n+        registerButton(BUTTON_SORT, this::setSortFlag);\n+        this.stackList = findPaneOfTypeByID(LIST_ALLINVENTORY, ScrollingList.class);\n+        updateResources();\n+    }\n+\n+    @Override\n+    public void onOpened()\n+    {\n+\n+    }\n+\n+    /**\n+     * Increments the sortDescriptor and sets the GUI Button accordingly Valid Stages 0 - 4 NO_SORT         0   No Sorting, like wysiwyg ASC_SORT        1   Name Ascending\n+     * DESC_SORT       2   Name Descending COUNT_ASC_SORT  3   Itemcount Ascending COUNT_DESC_SORT 4   Itemcount Descending\n+     **/\n+    private void setSortFlag()\n+    {\n+        sortDescriptor++;\n+        if (sortDescriptor > 4)\n+        {\n+            sortDescriptor = NO_SORT;\n+        }\n+        switch (sortDescriptor)\n+        {\n+            case NO_SORT:\n+                findPaneOfTypeByID(BUTTON_SORT, ButtonImage.class).setLabel(\"v^\");\n+                break;\n+            case ASC_SORT:\n+                findPaneOfTypeByID(BUTTON_SORT, ButtonImage.class).setLabel(\"A^\");\n+                break;\n+            case DESC_SORT:\n+                findPaneOfTypeByID(BUTTON_SORT, ButtonImage.class).setLabel(\"Av\");\n+                break;\n+            case COUNT_ASC_SORT:\n+                findPaneOfTypeByID(BUTTON_SORT, ButtonImage.class).setLabel(\"1^\");\n+                break;\n+            case COUNT_DESC_SORT:\n+                findPaneOfTypeByID(BUTTON_SORT, ButtonImage.class).setLabel(\"1v\");\n+                break;\n+            default:\n+                break;\n+        }\n+\n+        updateResources();\n+    }\n+\n+    /**\n+     * Update the item list.\n+     */\n+    private void updateResources()\n+    {\n+        List<ItemStorage> filterItems = new ArrayList<>();\n+        final List<BlockPos> containerList = building.getContainerList();\n+        List<ItemStack> items = new ArrayList<>();\n+        int count = containerList.size();\n+        World world = building.getColony().getWorld();\n+        for (int s = 0; s < count; s++)\n+        {\n+            final TileEntity rack = world.getTileEntity(containerList.get(s));\n+            if (rack instanceof TileEntityRack)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60c12b93f403fddd125c6849bada49fe8953d89b"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2Mjc3NzAzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/minecolonies/coremod/client/gui/WindowHutAllInventory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxOTo0NDozNlrOGJVd7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxOTo0NDozNlrOGJVd7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ0MjA5NQ==", "bodyText": "if result == true (since else means the event was not caught by this gui)", "url": "https://github.com/ldtteam/minecolonies/pull/4645#discussion_r412442095", "createdAt": "2020-04-21T19:44:36Z", "author": {"login": "Nightenom"}, "path": "src/main/java/com/minecolonies/coremod/client/gui/WindowHutAllInventory.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.minecolonies.coremod.client.gui;\n+\n+import com.ldtteam.blockout.Pane;\n+import com.ldtteam.blockout.controls.*;\n+import com.ldtteam.blockout.views.ScrollingList;\n+import com.minecolonies.api.colony.buildings.views.IBuildingView;\n+import com.minecolonies.api.crafting.ItemStorage;\n+import com.minecolonies.api.tileentities.TileEntityRack;\n+import com.minecolonies.api.util.ItemStackUtils;\n+import com.minecolonies.api.util.Log;\n+import com.minecolonies.api.util.constant.Constants;\n+\n+import com.minecolonies.coremod.colony.buildings.AbstractBuilding;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.tileentity.ChestTileEntity;\n+import net.minecraft.tileentity.TileEntity;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.world.World;\n+import org.jetbrains.annotations.NotNull;\n+\n+import java.util.*;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import static com.minecolonies.api.util.constant.WindowConstants.*;\n+\n+import com.minecolonies.api.util.constant.WindowConstants;\n+\n+/**\n+ * Window for a hut name entry.\n+ */\n+public class WindowHutAllInventory extends AbstractWindowSkeleton\n+{\n+\n+    /**\n+     * List of all item stacks in the warehouse.\n+     */\n+    List<ItemStorage> allItems = new ArrayList<>();\n+\n+    /**\n+     * Resource scrolling list.\n+     */\n+    private final ScrollingList stackList;\n+    /**\n+     * The filter for the resource list.\n+     */\n+    private       String        filter         = \"\";\n+    /**\n+     * The sortDescriptor so how we want to sort\n+     */\n+    private       int           sortDescriptor = 0;\n+\n+    /**\n+     * The building associated to the GUI.\n+     */\n+    private final IBuildingView building;\n+\n+    /**\n+     * Constructor for a hut rename entry window.\n+     *\n+     * @param b {@link AbstractBuilding}\n+     */\n+    public WindowHutAllInventory(final IBuildingView b)\n+    {\n+        super(Constants.MOD_ID + HUT_ALL_INVENTORY_SUFFIX);\n+        this.building = b;\n+        registerButton(BUTTON_SORT, this::setSortFlag);\n+        this.stackList = findPaneOfTypeByID(LIST_ALLINVENTORY, ScrollingList.class);\n+        updateResources();\n+    }\n+\n+    @Override\n+    public void onOpened()\n+    {\n+\n+    }\n+\n+    /**\n+     * Increments the sortDescriptor and sets the GUI Button accordingly Valid Stages 0 - 4 NO_SORT         0   No Sorting, like wysiwyg ASC_SORT        1   Name Ascending\n+     * DESC_SORT       2   Name Descending COUNT_ASC_SORT  3   Itemcount Ascending COUNT_DESC_SORT 4   Itemcount Descending\n+     **/\n+    private void setSortFlag()\n+    {\n+        sortDescriptor++;\n+        if (sortDescriptor > 4)\n+        {\n+            sortDescriptor = NO_SORT;\n+        }\n+        switch (sortDescriptor)\n+        {\n+            case NO_SORT:\n+                findPaneOfTypeByID(BUTTON_SORT, ButtonImage.class).setLabel(\"v^\");\n+                break;\n+            case ASC_SORT:\n+                findPaneOfTypeByID(BUTTON_SORT, ButtonImage.class).setLabel(\"A^\");\n+                break;\n+            case DESC_SORT:\n+                findPaneOfTypeByID(BUTTON_SORT, ButtonImage.class).setLabel(\"Av\");\n+                break;\n+            case COUNT_ASC_SORT:\n+                findPaneOfTypeByID(BUTTON_SORT, ButtonImage.class).setLabel(\"1^\");\n+                break;\n+            case COUNT_DESC_SORT:\n+                findPaneOfTypeByID(BUTTON_SORT, ButtonImage.class).setLabel(\"1v\");\n+                break;\n+            default:\n+                break;\n+        }\n+\n+        updateResources();\n+    }\n+\n+    /**\n+     * Update the item list.\n+     */\n+    private void updateResources()\n+    {\n+        List<ItemStorage> filterItems = new ArrayList<>();\n+        final List<BlockPos> containerList = building.getContainerList();\n+\n+        List<ItemStack> items = new ArrayList<>();\n+        int count = containerList.size();\n+        World world = building.getColony().getWorld();\n+        for (int s = 0; s < count; s++)\n+        {\n+            final TileEntity rack = world.getTileEntity(containerList.get(s));\n+            if (rack instanceof TileEntityRack)\n+            {\n+\n+                Map<ItemStorage, Integer> storage = ((TileEntityRack) rack).getAllContent();\n+\n+                for (final Map.Entry<ItemStorage, Integer> entry : storage.entrySet())\n+                {\n+                    items.add(new ItemStorage(entry.getKey().getItemStack(), entry.getValue(), false).getItemStack());\n+                }\n+            }\n+            else if (rack instanceof ChestTileEntity)\n+            {\n+                final int size = ((ChestTileEntity) rack).getSizeInventory();\n+                for (int slot = 0; slot < size; slot++)\n+                {\n+                    final ItemStack stack = ((ChestTileEntity) rack).getStackInSlot(slot);\n+                    if (!ItemStackUtils.isEmpty(stack))\n+                    {\n+                        items.add(stack.copy());\n+                    }\n+                }\n+            }\n+        }\n+\n+        Map<ItemStorage, ItemStorage> storedItems = new HashMap<>();\n+        storedItems.clear();\n+\n+        for (final ItemStack currentItem : items)\n+        {\n+            final ItemStorage currentStorage = new ItemStorage(currentItem, currentItem.getCount(), false);\n+\n+            if (storedItems.containsKey(currentStorage))\n+            {\n+                final ItemStorage existing = storedItems.get(currentStorage);\n+                existing.setAmount(existing.getAmount() + currentStorage.getAmount());\n+            }\n+            else\n+            {\n+                storedItems.put(currentStorage, currentStorage);\n+            }\n+        }\n+\n+        filterItems.clear();\n+        for (ItemStorage entry : storedItems.keySet())\n+        {\n+            filterItems.add(entry);\n+        }\n+\n+        final Predicate<ItemStorage> filterPredicate = stack -> filter.isEmpty()\n+                                                                  || stack.getItemStack().getTranslationKey().toLowerCase(Locale.US).contains(filter.toLowerCase(Locale.US))\n+                                                                  || stack.getItemStack()\n+                                                                       .getDisplayName()\n+                                                                       .getFormattedText()\n+                                                                       .toLowerCase(Locale.US)\n+                                                                       .contains(filter.toLowerCase(Locale.US));\n+\n+        allItems.clear();\n+        if (filter.isEmpty())\n+        {\n+            allItems.addAll(filterItems);\n+        }\n+        else\n+        {\n+            allItems.addAll(filterItems.stream().filter(filterPredicate).collect(Collectors.toList()));\n+        }\n+\n+        Comparator<ItemStorage> compareByName =\n+          (ItemStorage o1, ItemStorage o2) -> o1.getItemStack().getDisplayName().getFormattedText().compareTo(o2.getItemStack().getDisplayName().getFormattedText());\n+        Comparator<ItemStorage> compareByCount = (ItemStorage o1, ItemStorage o2) -> o1.getAmount() - o2.getAmount();\n+        switch (sortDescriptor)\n+        {\n+            case NO_SORT:\n+                break;\n+            case ASC_SORT:\n+                Collections.sort(allItems, compareByName);\n+                break;\n+            case DESC_SORT:\n+                Collections.sort(allItems, compareByName.reversed());\n+                break;\n+            case COUNT_ASC_SORT:\n+                Collections.sort(allItems, compareByCount);\n+                break;\n+            case COUNT_DESC_SORT:\n+                Collections.sort(allItems, compareByCount.reversed());\n+                break;\n+            default:\n+                break;\n+        }\n+\n+        updateResourceList();\n+    }\n+\n+    /**\n+     * Updates the resource list in the GUI with the info we need.\n+     */\n+    private void updateResourceList()\n+    {\n+        stackList.enable();\n+\n+        //Creates a dataProvider for the unemployed stackList.\n+        stackList.setDataProvider(new ScrollingList.DataProvider()\n+        {\n+            /**\n+             * The number of rows of the list.\n+             * @return the number.\n+             */\n+            @Override\n+            public int getElementCount()\n+            {\n+                return allItems.size();\n+            }\n+\n+            /**\n+             * Inserts the elements into each row.\n+             * @param index the index of the row/list element.\n+             * @param rowPane the parent Pane for the row, containing the elements to update.\n+             */\n+            @Override\n+            public void updateElement(final int index, @NotNull final Pane rowPane)\n+            {\n+                ItemStorage resource = allItems.get(index);\n+                final Label resourceLabel = rowPane.findPaneOfTypeByID(\"ressourceStackName\", Label.class);\n+                resourceLabel.setLabelText(resource.getItemStack().getDisplayName().getFormattedText());\n+                final Label qtys = rowPane.findPaneOfTypeByID(\"quantities\", Label.class);\n+                qtys.setLabelText(Integer.toString(resource.getAmount()));\n+                Item imagesrc = resource.getItemStack().getItem();\n+                ItemStack image = new ItemStack(imagesrc, 1);\n+                rowPane.findPaneOfTypeByID(RESOURCE_ICON, ItemIcon.class).setItem(image);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public boolean onKeyTyped(final char ch, final int key)\n+    {\n+        final boolean result = super.onKeyTyped(ch, key);\n+        filter = findPaneOfTypeByID(\"names\", TextField.class).getText();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "352474a6b06954aa709398a11f4930975fba1c0a"}, "originalPosition": 264}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3135, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}