{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQwNDQ3NjA5", "number": 5298, "title": "Improve construction tape", "bodyText": "Implements #4479\nChanges proposed in this pull request:\n\nConstruction tape now behaves like a four way block, connecting to tape in all four directions, with the following exceptions:\n\nTape will remember it is a corner even when isolated (unchanged from previous)\nTape will not become a T-junction if it means it will face another T-Junction stem-to-stem. This produces a neat result when building schematics adjacent to one another (makes more sense in the picture)\n\n\nTape is now water-loggable, meaning tape can be (and is) placed in water\n\nAs a side-effect the tape now sometimes blocks adjacent water sources from flowing in its direction\n\n\nTape placed by the helper (when placing buildings) now replaces flowers\nTape placed by the helper (when placing buildings) now ignores leaves, replacing them if necessary.\n\nA picture exemplar of all these changes:\n\nReview please", "createdAt": "2020-06-26T08:16:32Z", "url": "https://github.com/ldtteam/minecolonies/pull/5298", "merged": true, "mergeCommit": {"oid": "e0085d4f8525d0703499fb09812c26a5c6cb6d3c"}, "closed": true, "closedAt": "2020-06-30T09:13:48Z", "author": {"login": "ShadowProtocol"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcuDKByAH2gAyNDQwNDQ3NjA5OjQwNzY1NWM5NTFjOTFiNTIyZmYxZmU2M2Y3ZWNkZDBlM2MyOWUyZTM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcvUdq_AH2gAyNDQwNDQ3NjA5OmZhMWFmOWQ0N2IxZDc4ZWE2M2M2OWVkN2E4MmU4NDkyOGM5OTMxNmQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "407655c951c91b522ff1fe63f7ecdd0e3c29e2e3", "author": {"user": {"login": "ShadowProtocol", "name": null}}, "url": "https://github.com/ldtteam/minecolonies/commit/407655c951c91b522ff1fe63f7ecdd0e3c29e2e3", "committedDate": "2020-06-23T10:47:16Z", "message": "Change tape model to act like a FourWayBlock"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c4562550f6ed155f2a4513100e57573f51a85bf", "author": {"user": {"login": "ShadowProtocol", "name": null}}, "url": "https://github.com/ldtteam/minecolonies/commit/5c4562550f6ed155f2a4513100e57573f51a85bf", "committedDate": "2020-06-24T02:05:05Z", "message": "Add multi-direction logic and default axis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d8337c427c3f9b077b48c902febe5086e0644538", "author": {"user": {"login": "ShadowProtocol", "name": null}}, "url": "https://github.com/ldtteam/minecolonies/commit/d8337c427c3f9b077b48c902febe5086e0644538", "committedDate": "2020-06-24T10:25:46Z", "message": "Add dynamic hit box creation and waterlogging\n\nUse the same methods as a FourWayBlock to build the composite hit boxes\nAdd the ability for tape to be waterlogged\nRename the super class to ...FallingFourWay"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f71d33b87f4b96ed8853c680ddee514531edc8cf", "author": {"user": {"login": "ShadowProtocol", "name": null}}, "url": "https://github.com/ldtteam/minecolonies/commit/f71d33b87f4b96ed8853c680ddee514531edc8cf", "committedDate": "2020-06-24T13:35:59Z", "message": "Improve tape four way logic\n\nAdd condition to remove the stem if there is a T junction opposite another T junction"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b2aaeebff06e3bf8200453775d2b442c5bf73281", "author": {"user": {"login": "ShadowProtocol", "name": null}}, "url": "https://github.com/ldtteam/minecolonies/commit/b2aaeebff06e3bf8200453775d2b442c5bf73281", "committedDate": "2020-06-25T07:07:31Z", "message": "Rework the Helper\n\nImprove code cleanliness and efficiency in ConstructionTapeHandler\nLink to new placement state getters"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bbfedef4546938197f00d500234e4e180443e115", "author": {"user": {"login": "ShadowProtocol", "name": null}}, "url": "https://github.com/ldtteam/minecolonies/commit/bbfedef4546938197f00d500234e4e180443e115", "committedDate": "2020-06-25T08:24:42Z", "message": "Add tape corner logic\n\nEnsure tape marked as a corner keeps the correct sides when isolated."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7aafb7e84f12a79995a96564f514b83d3689dc02", "author": {"user": {"login": "ShadowProtocol", "name": null}}, "url": "https://github.com/ldtteam/minecolonies/commit/7aafb7e84f12a79995a96564f514b83d3689dc02", "committedDate": "2020-06-26T05:45:30Z", "message": "Clean up and fix formatting\n\nMove Four Way shape logic to Abstract tape class\nRevert name of abstract falling block class to AbstractBlockMinecoloniesFalling\nGeneral formatting and doc fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cd5857b66427278ec2c670f51ef41eb0dc71842c", "author": {"user": {"login": "ShadowProtocol", "name": null}}, "url": "https://github.com/ldtteam/minecolonies/commit/cd5857b66427278ec2c670f51ef41eb0dc71842c", "committedDate": "2020-06-26T07:11:44Z", "message": "Fix the tape held item model\n\nAdd a new model specifically for the inventory like fences have\nAdjust the standard model's post top face to not be on a dark patch of wood"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00e0d0a5cbbf363dfa41178b1d4c6fc0525f477e", "author": {"user": {"login": "ShadowProtocol", "name": null}}, "url": "https://github.com/ldtteam/minecolonies/commit/00e0d0a5cbbf363dfa41178b1d4c6fc0525f477e", "committedDate": "2020-06-26T07:41:32Z", "message": "Add compatibility\n\nEnsure that tape placed in older versions at least appears, and with the right orientation."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4MTExMTI1", "url": "https://github.com/ldtteam/minecolonies/pull/5298#pullrequestreview-438111125", "createdAt": "2020-06-26T08:31:33Z", "commit": {"oid": "00e0d0a5cbbf363dfa41178b1d4c6fc0525f477e"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwODozMTozM1rOGpYbFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwODozMzo0MlrOGpYfhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA0NDk1MA==", "bodyText": "use lower case full name, sizeX or similar", "url": "https://github.com/ldtteam/minecolonies/pull/5298#discussion_r446044950", "createdAt": "2020-06-26T08:31:33Z", "author": {"login": "Nightenom"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/builder/ConstructionTapeHelper.java", "diffHunk": "@@ -61,106 +56,77 @@ public static void placeConstructionTape(@NotNull final WorkOrderBuildDecoration\n      */\n     public static void placeConstructionTape(final BlockPos pos, final Tuple<Tuple<Integer, Integer>, Tuple<Integer, Integer>> corners, @NotNull final World world)\n     {\n-        if (MineColonies.getConfig().getCommon().builderPlaceConstructionTape.get())\n-        {\n-            final BlockState constructionTape = ModBlocks.blockConstructionTape.getDefaultState();\n+        if (!MineColonies.getConfig().getCommon().builderPlaceConstructionTape.get()) return;\n \n-            final int x1 = corners.getA().getA();\n-            final int x3 = corners.getA().getB();\n-            final int z1 = corners.getB().getA();\n-            final int z3 = corners.getB().getB();\n-            final int y = pos.getY();\n-            int newY;\n+        final BlockState constructionTape = ModBlocks.blockConstructionTape.getDefaultState();\n \n-            if (x1 < x3)\n-            {\n-                for (int i = x1 + 1; i < x3; i++)\n-                {\n-                    newY = checkIfPlaceable(i, y, z1, world);\n-                    final BlockPos row1 = new BlockPos(i, newY, z1);\n-                    world.setBlockState(row1, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.SOUTH), world, row1));\n-                    newY = checkIfPlaceable(i, y, z3, world);\n-                    final BlockPos row2 = new BlockPos(i, newY, z3);\n-                    world.setBlockState(row2, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.NORTH), world, row2));\n-                }\n-            }\n-            else\n-            {\n-                for (int i = x3 + 1; i < x1; i++)\n-                {\n-                    newY = checkIfPlaceable(i, y, z1, world);\n-                    final BlockPos row1 = new BlockPos(i, newY, z1);\n-                    world.setBlockState(row1, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.SOUTH), world, row1));\n-                    newY = checkIfPlaceable(i, y, z3, world);\n-                    final BlockPos row2 = new BlockPos(i, newY, z3);\n-                    world.setBlockState(row2, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.NORTH), world, row2));\n-                }\n-            }\n-            if (z1 < z3)\n+        final int X = Math.min(corners.getA().getA(), corners.getA().getB());\n+        final int Y = pos.getY();\n+        final int Z = Math.min(corners.getB().getA(), corners.getB().getB());\n+        int W = Math.abs(corners.getA().getB() - corners.getA().getA());\n+        int H = Math.abs(corners.getB().getB() - corners.getB().getA());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00e0d0a5cbbf363dfa41178b1d4c6fc0525f477e"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA0NjA4NQ==", "bodyText": "leaves block only when not persistent, or I would say no to all", "url": "https://github.com/ldtteam/minecolonies/pull/5298#discussion_r446046085", "createdAt": "2020-06-26T08:33:42Z", "author": {"login": "Nightenom"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/builder/ConstructionTapeHelper.java", "diffHunk": "@@ -61,106 +56,77 @@ public static void placeConstructionTape(@NotNull final WorkOrderBuildDecoration\n      */\n     public static void placeConstructionTape(final BlockPos pos, final Tuple<Tuple<Integer, Integer>, Tuple<Integer, Integer>> corners, @NotNull final World world)\n     {\n-        if (MineColonies.getConfig().getCommon().builderPlaceConstructionTape.get())\n-        {\n-            final BlockState constructionTape = ModBlocks.blockConstructionTape.getDefaultState();\n+        if (!MineColonies.getConfig().getCommon().builderPlaceConstructionTape.get()) return;\n \n-            final int x1 = corners.getA().getA();\n-            final int x3 = corners.getA().getB();\n-            final int z1 = corners.getB().getA();\n-            final int z3 = corners.getB().getB();\n-            final int y = pos.getY();\n-            int newY;\n+        final BlockState constructionTape = ModBlocks.blockConstructionTape.getDefaultState();\n \n-            if (x1 < x3)\n-            {\n-                for (int i = x1 + 1; i < x3; i++)\n-                {\n-                    newY = checkIfPlaceable(i, y, z1, world);\n-                    final BlockPos row1 = new BlockPos(i, newY, z1);\n-                    world.setBlockState(row1, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.SOUTH), world, row1));\n-                    newY = checkIfPlaceable(i, y, z3, world);\n-                    final BlockPos row2 = new BlockPos(i, newY, z3);\n-                    world.setBlockState(row2, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.NORTH), world, row2));\n-                }\n-            }\n-            else\n-            {\n-                for (int i = x3 + 1; i < x1; i++)\n-                {\n-                    newY = checkIfPlaceable(i, y, z1, world);\n-                    final BlockPos row1 = new BlockPos(i, newY, z1);\n-                    world.setBlockState(row1, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.SOUTH), world, row1));\n-                    newY = checkIfPlaceable(i, y, z3, world);\n-                    final BlockPos row2 = new BlockPos(i, newY, z3);\n-                    world.setBlockState(row2, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.NORTH), world, row2));\n-                }\n-            }\n-            if (z1 < z3)\n+        final int X = Math.min(corners.getA().getA(), corners.getA().getB());\n+        final int Y = pos.getY();\n+        final int Z = Math.min(corners.getB().getA(), corners.getB().getB());\n+        int W = Math.abs(corners.getA().getB() - corners.getA().getA());\n+        int H = Math.abs(corners.getB().getB() - corners.getB().getA());\n+        BlockPos working;\n+\n+        for (BlockPos place = new BlockPos(X,Y,Z); place.getX() < X+W || place.getZ() < Z+H;) {\n+            if (place.getX() < X+W)\n             {\n-                for (int i = z1 + 1; i < z3; i++)\n-                {\n-                    newY = checkIfPlaceable(x1, y, i, world);\n-                    final BlockPos row3 = new BlockPos(x1, newY, i);\n-                    world.setBlockState(row3, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.EAST), world, row3));\n-                    newY = checkIfPlaceable(x3, y, i, world);\n-                    final BlockPos row4 = new BlockPos(x3, newY, i);\n-                    world.setBlockState(row4, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.WEST), world, row4));\n-                }\n+                working = firstValidPosition(new BlockPos(place.getX(), Y, Z), world);\n+                world.setBlockState(working,\n+                        BlockConstructionTape.getPlacementState(constructionTape.with(CORNER, place.getX() == X), world, working, Direction.SOUTH)\n+                );\n+\n+                working = firstValidPosition(new BlockPos(place.getX(), Y, Z+H), world);\n+                world.setBlockState(working,\n+                        BlockConstructionTape.getPlacementState(constructionTape.with(CORNER, place.getX() == X), world, working, Direction.NORTH)\n+                );\n             }\n-            else\n+\n+            if (place.getZ() < Z+H)\n             {\n-                for (int i = z3 + 1; i < z1; i++)\n-                {\n-                    newY = checkIfPlaceable(x1, y, i, world);\n-                    final BlockPos row3 = new BlockPos(x1, newY, i);\n-                    world.setBlockState(row3, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.EAST), world, row3));\n-                    newY = checkIfPlaceable(x3, y, i, world);\n-                    final BlockPos row4 = new BlockPos(x3, newY, i);\n-                    world.setBlockState(row4, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.WEST), world, row4));\n-                }\n+                working = firstValidPosition(new BlockPos(X, Y, place.getZ()), world);\n+                world.setBlockState(working,\n+                        BlockConstructionTape.getPlacementState(constructionTape.with(CORNER, place.getZ() == Z), world, working, Direction.EAST)\n+                );\n+\n+                working = firstValidPosition(new BlockPos(X+W, Y, place.getZ()), world);\n+                world.setBlockState(working,\n+                        BlockConstructionTape.getPlacementState(constructionTape.with(CORNER, place.getZ() == Z), world, working, place.getZ() == Z? Direction.SOUTH : Direction.WEST)\n+                );\n             }\n-            newY = checkIfPlaceable(x1, y, z1, world);\n-            final BlockPos corner1 = new BlockPos(x1, newY, z1);\n-            newY = checkIfPlaceable(x1, y, z3, world);\n-            final BlockPos corner2 = new BlockPos(x1, newY, z3);\n-            newY = checkIfPlaceable(x3, y, z1, world);\n-            final BlockPos corner3 = new BlockPos(x3, newY, z1);\n-            newY = checkIfPlaceable(x3, y, z3, world);\n-            final BlockPos corner4 = new BlockPos(x3, newY, z3);\n-            world.setBlockState(corner1, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.SOUTH), world, corner1));\n-            world.setBlockState(corner2, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.EAST), world, corner2));\n-            world.setBlockState(corner3, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.WEST), world, corner3));\n-            world.setBlockState(corner4, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.NORTH), world, corner4));\n+\n+            place = place.south().east();\n         }\n+\n+        working = firstValidPosition(new BlockPos(X+W, Y, Z+H), world);\n+        world.setBlockState(working,\n+                BlockConstructionTape.getPlacementState(constructionTape.with(CORNER, true), world, working, Direction.WEST)\n+        );\n     }\n \n     /**\n-     * Check if a block is placeable and return new Y position.\n+     * Find and return the highest position that is directly above a non-replaceable block.\n      *\n-     * @param x     Block X position.\n-     * @param y     Block Y position.\n-     * @param z     Block Z position.\n+     * @param target the target position for the block\n      * @param world the world.\n-     * @return The new Y position.\n+     * @return The new block position.\n      */\n-\n-    public static int checkIfPlaceable(@NotNull final int x, @NotNull final int y, @NotNull final int z, @NotNull final World world)\n+    public static BlockPos firstValidPosition(@NotNull BlockPos target, @NotNull World world)\n     {\n-        BlockPos target = new BlockPos(x,y,z);\n         final Chunk chunk = world.getChunkAt(target);\n \n-        target = new BlockPos(x, chunk.getTopFilledSegment() + 16, z);\n-        while(world.getBlockState(target).getMaterial().isReplaceable())\n+        target = new BlockPos(target.getX(), chunk.getTopFilledSegment() + 16, target.getZ());\n+                \n+        while (target.getY() > 0)\n         {\n             target = target.down();\n-            if (target.getY() == 0)\n-            {\n+            \n+            if (!world.getBlockState(target).getMaterial().isReplaceable() \n+             && !(world.getBlockState(target).getBlock() instanceof LeavesBlock)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00e0d0a5cbbf363dfa41178b1d4c6fc0525f477e"}, "originalPosition": 181}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "798bcd6fd2560686d977f2630229e9b3b75c5240", "author": {"user": {"login": "ShadowProtocol", "name": null}}, "url": "https://github.com/ldtteam/minecolonies/commit/798bcd6fd2560686d977f2630229e9b3b75c5240", "committedDate": "2020-06-26T09:48:53Z", "message": "Avoid replacement of leaves\n\nUse a forward scan to check if there is something replaceable below leaves instead\nFix some capitalization"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4MTY0NTU0", "url": "https://github.com/ldtteam/minecolonies/pull/5298#pullrequestreview-438164554", "createdAt": "2020-06-26T09:51:34Z", "commit": {"oid": "798bcd6fd2560686d977f2630229e9b3b75c5240"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwOTo1MTozNFrOGpa5Iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwOTo1MTozNFrOGpa5Iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA4NTQxMQ==", "bodyText": "just the formatting is off here yet.", "url": "https://github.com/ldtteam/minecolonies/pull/5298#discussion_r446085411", "createdAt": "2020-06-26T09:51:34Z", "author": {"login": "Raycoms"}, "path": "src/api/java/com/minecolonies/api/blocks/decorative/AbstractBlockMinecoloniesConstructionTape.java", "diffHunk": "@@ -1,107 +1,125 @@\n package com.minecolonies.api.blocks.decorative;\n \n import com.minecolonies.api.blocks.AbstractBlockMinecoloniesFalling;\n-import net.minecraft.block.HorizontalBlock;\n-import net.minecraft.block.material.MaterialColor;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n+import net.minecraft.block.*;\n+import net.minecraft.fluid.Fluids;\n+import net.minecraft.fluid.IFluidState;\n+import net.minecraft.state.BooleanProperty;\n import net.minecraft.state.DirectionProperty;\n-import net.minecraft.state.EnumProperty;\n-import net.minecraft.util.IStringSerializable;\n+import net.minecraft.state.properties.BlockStateProperties;\n+import net.minecraft.util.Direction;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.shapes.ISelectionContext;\n+import net.minecraft.util.math.shapes.VoxelShape;\n+import net.minecraft.util.math.shapes.VoxelShapes;\n+import net.minecraft.world.IBlockReader;\n import org.jetbrains.annotations.NotNull;\n \n-public abstract class AbstractBlockMinecoloniesConstructionTape<B extends AbstractBlockMinecoloniesConstructionTape<B>> extends AbstractBlockMinecoloniesFalling<B>\n+public abstract class AbstractBlockMinecoloniesConstructionTape<B extends AbstractBlockMinecoloniesConstructionTape<B>> extends AbstractBlockMinecoloniesFalling<B> implements IWaterLoggable\n {\n+    public static final BooleanProperty NORTH = SixWayBlock.NORTH;\n+    public static final BooleanProperty EAST = SixWayBlock.EAST;\n+    public static final BooleanProperty SOUTH = SixWayBlock.SOUTH;\n+    public static final BooleanProperty WEST = SixWayBlock.WEST;\n+    public static final BooleanProperty WATERLOGGED = BlockStateProperties.WATERLOGGED;\n+\n+    protected VoxelShape[] shapes = new VoxelShape[]{};\n+\n+    private final Object2IntMap<BlockState> stateShapeMap = new Object2IntOpenHashMap<>();\n+\n     /**\n-     * The variants of the shingle slab.\n+     * The default face for when there are no connections.\n      */\n-    public static final EnumProperty<ConstructionTapeType> VARIANT = EnumProperty.create(\"variant\", ConstructionTapeType.class);\n+    public static final DirectionProperty FACING = HorizontalBlock.HORIZONTAL_FACING;\n \n     /**\n-     * The position it faces.\n+     * Implies that the tape should revert to a corner if there are no connections. Must be set explicitly. For use by the builder handler.\n      */\n-    public static final DirectionProperty FACING = HorizontalBlock.HORIZONTAL_FACING;\n+    public static final BooleanProperty CORNER = BooleanProperty.create(\"corner\");\n \n     public AbstractBlockMinecoloniesConstructionTape(final Properties properties)\n     {\n         super(properties);\n     }\n \n-    /**\n-     * Types that the {@link AbstractBlockMinecoloniesConstructionTape} supports\n-     */\n-    public enum ConstructionTapeType implements IStringSerializable\n+    @NotNull\n+    @Override\n+    public VoxelShape getShape(BlockState state, IBlockReader worldIn, BlockPos pos, ISelectionContext context)\n     {\n-        STRAIGHT(0, \"straight\", MaterialColor.WOOD),\n-        CORNER(1, \"corner\", MaterialColor.OBSIDIAN);\n-\n-        private static final ConstructionTapeType[] META_LOOKUP = new ConstructionTapeType[values().length];\n-        static\n-        {\n-            for (final ConstructionTapeType enumtype : values())\n-            {\n-                META_LOOKUP[enumtype.getMetadata()] = enumtype;\n+        return this.shapes[this.getIndex(state)];\n+    }\n+\n+    private static int getMask(Direction facing) {\n+        return 1 << facing.getHorizontalIndex();\n+    }\n+\n+    protected int getIndex(BlockState state)\n+    {\n+        return this.stateShapeMap.computeIntIfAbsent(state, (p_223007_0_) -> {\n+            int i = 0;\n+            if (p_223007_0_.get(NORTH)) {\n+                i |= getMask(Direction.NORTH);\n             }\n-        }\n-        private final int           meta;\n-        private final String        name;\n-        private final String        unlocalizedName;\n-        /**\n-         * The color that represents this entry on a map.\n-         */\n-        private final MaterialColor mapColor;\n-\n-        ConstructionTapeType(final int metaIn, final String nameIn, final MaterialColor mapColorIn)\n-        {\n-            this(metaIn, nameIn, nameIn, mapColorIn);\n-        }\n \n-        ConstructionTapeType(final int metaIn, final String nameIn, final String unlocalizedNameIn, final MaterialColor mapColorIn)\n-        {\n-            this.meta = metaIn;\n-            this.name = nameIn;\n-            this.unlocalizedName = unlocalizedNameIn;\n-            this.mapColor = mapColorIn;\n-        }\n+            if (p_223007_0_.get(EAST)) {\n+                i |= getMask(Direction.EAST);\n+            }\n \n-        public static ConstructionTapeType byMetadata(final int meta)\n-        {\n-            int tempMeta = meta;\n-            if (tempMeta < 0 || tempMeta >= META_LOOKUP.length)\n-            {\n-                tempMeta = 0;\n+            if (p_223007_0_.get(SOUTH)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "798bcd6fd2560686d977f2630229e9b3b75c5240"}, "originalPosition": 118}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4MTY0NjQ3", "url": "https://github.com/ldtteam/minecolonies/pull/5298#pullrequestreview-438164647", "createdAt": "2020-06-26T09:51:43Z", "commit": {"oid": "798bcd6fd2560686d977f2630229e9b3b75c5240"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwOTo1MTo0M1rOGpa5Ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwOTo1MTo0M1rOGpa5Ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA4NTQ2Nw==", "bodyText": "here too", "url": "https://github.com/ldtteam/minecolonies/pull/5298#discussion_r446085467", "createdAt": "2020-06-26T09:51:43Z", "author": {"login": "Raycoms"}, "path": "src/api/java/com/minecolonies/api/blocks/decorative/AbstractBlockMinecoloniesConstructionTape.java", "diffHunk": "@@ -1,107 +1,125 @@\n package com.minecolonies.api.blocks.decorative;\n \n import com.minecolonies.api.blocks.AbstractBlockMinecoloniesFalling;\n-import net.minecraft.block.HorizontalBlock;\n-import net.minecraft.block.material.MaterialColor;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n+import net.minecraft.block.*;\n+import net.minecraft.fluid.Fluids;\n+import net.minecraft.fluid.IFluidState;\n+import net.minecraft.state.BooleanProperty;\n import net.minecraft.state.DirectionProperty;\n-import net.minecraft.state.EnumProperty;\n-import net.minecraft.util.IStringSerializable;\n+import net.minecraft.state.properties.BlockStateProperties;\n+import net.minecraft.util.Direction;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.shapes.ISelectionContext;\n+import net.minecraft.util.math.shapes.VoxelShape;\n+import net.minecraft.util.math.shapes.VoxelShapes;\n+import net.minecraft.world.IBlockReader;\n import org.jetbrains.annotations.NotNull;\n \n-public abstract class AbstractBlockMinecoloniesConstructionTape<B extends AbstractBlockMinecoloniesConstructionTape<B>> extends AbstractBlockMinecoloniesFalling<B>\n+public abstract class AbstractBlockMinecoloniesConstructionTape<B extends AbstractBlockMinecoloniesConstructionTape<B>> extends AbstractBlockMinecoloniesFalling<B> implements IWaterLoggable\n {\n+    public static final BooleanProperty NORTH = SixWayBlock.NORTH;\n+    public static final BooleanProperty EAST = SixWayBlock.EAST;\n+    public static final BooleanProperty SOUTH = SixWayBlock.SOUTH;\n+    public static final BooleanProperty WEST = SixWayBlock.WEST;\n+    public static final BooleanProperty WATERLOGGED = BlockStateProperties.WATERLOGGED;\n+\n+    protected VoxelShape[] shapes = new VoxelShape[]{};\n+\n+    private final Object2IntMap<BlockState> stateShapeMap = new Object2IntOpenHashMap<>();\n+\n     /**\n-     * The variants of the shingle slab.\n+     * The default face for when there are no connections.\n      */\n-    public static final EnumProperty<ConstructionTapeType> VARIANT = EnumProperty.create(\"variant\", ConstructionTapeType.class);\n+    public static final DirectionProperty FACING = HorizontalBlock.HORIZONTAL_FACING;\n \n     /**\n-     * The position it faces.\n+     * Implies that the tape should revert to a corner if there are no connections. Must be set explicitly. For use by the builder handler.\n      */\n-    public static final DirectionProperty FACING = HorizontalBlock.HORIZONTAL_FACING;\n+    public static final BooleanProperty CORNER = BooleanProperty.create(\"corner\");\n \n     public AbstractBlockMinecoloniesConstructionTape(final Properties properties)\n     {\n         super(properties);\n     }\n \n-    /**\n-     * Types that the {@link AbstractBlockMinecoloniesConstructionTape} supports\n-     */\n-    public enum ConstructionTapeType implements IStringSerializable\n+    @NotNull\n+    @Override\n+    public VoxelShape getShape(BlockState state, IBlockReader worldIn, BlockPos pos, ISelectionContext context)\n     {\n-        STRAIGHT(0, \"straight\", MaterialColor.WOOD),\n-        CORNER(1, \"corner\", MaterialColor.OBSIDIAN);\n-\n-        private static final ConstructionTapeType[] META_LOOKUP = new ConstructionTapeType[values().length];\n-        static\n-        {\n-            for (final ConstructionTapeType enumtype : values())\n-            {\n-                META_LOOKUP[enumtype.getMetadata()] = enumtype;\n+        return this.shapes[this.getIndex(state)];\n+    }\n+\n+    private static int getMask(Direction facing) {\n+        return 1 << facing.getHorizontalIndex();\n+    }\n+\n+    protected int getIndex(BlockState state)\n+    {\n+        return this.stateShapeMap.computeIntIfAbsent(state, (p_223007_0_) -> {\n+            int i = 0;\n+            if (p_223007_0_.get(NORTH)) {\n+                i |= getMask(Direction.NORTH);\n             }\n-        }\n-        private final int           meta;\n-        private final String        name;\n-        private final String        unlocalizedName;\n-        /**\n-         * The color that represents this entry on a map.\n-         */\n-        private final MaterialColor mapColor;\n-\n-        ConstructionTapeType(final int metaIn, final String nameIn, final MaterialColor mapColorIn)\n-        {\n-            this(metaIn, nameIn, nameIn, mapColorIn);\n-        }\n \n-        ConstructionTapeType(final int metaIn, final String nameIn, final String unlocalizedNameIn, final MaterialColor mapColorIn)\n-        {\n-            this.meta = metaIn;\n-            this.name = nameIn;\n-            this.unlocalizedName = unlocalizedNameIn;\n-            this.mapColor = mapColorIn;\n-        }\n+            if (p_223007_0_.get(EAST)) {\n+                i |= getMask(Direction.EAST);\n+            }\n \n-        public static ConstructionTapeType byMetadata(final int meta)\n-        {\n-            int tempMeta = meta;\n-            if (tempMeta < 0 || tempMeta >= META_LOOKUP.length)\n-            {\n-                tempMeta = 0;\n+            if (p_223007_0_.get(SOUTH)) {\n+                i |= getMask(Direction.SOUTH);\n             }\n \n-            return META_LOOKUP[tempMeta];\n-        }\n+            if (p_223007_0_.get(WEST)) {\n+                i |= getMask(Direction.WEST);\n+            }\n \n-        public int getMetadata()\n-        {\n-            return this.meta;\n-        }\n+            return i;\n+        });\n+    }\n \n-        /**\n-         * The color which represents this entry on a map.\n-         * @return the material color.\n-         */\n-        public MaterialColor getMaterialColor()\n-        {\n-            return this.mapColor;\n-        }\n+    @NotNull\n+    @Override\n+    public IFluidState getFluidState(BlockState state)\n+    {\n+        return state.get(WATERLOGGED) ? Fluids.WATER.getStillFluidState(false) : super.getFluidState(state);\n+    }\n \n-        @Override\n-        public String toString()\n-        {\n-            return this.name;\n-        }\n+    protected VoxelShape[] makeShapes(float nodeWidth, float limbWidth, float nodeHeight, float limbBase, float limbTop)\n+    {\n+        float nodeStart = 8.0F - nodeWidth;\n+        float nodeEnd = 8.0F + nodeWidth;\n+        float limbStart = 8.0F - limbWidth;\n+        float limbEnd = 8.0F + limbWidth;\n \n-        @NotNull\n-        public String getName()\n-        {\n-            return this.name;\n-        }\n+        VoxelShape node  = Block.makeCuboidShape(nodeStart, 0.0F,     nodeStart, nodeEnd, nodeHeight, nodeEnd);\n+        VoxelShape north = Block.makeCuboidShape(limbStart, limbBase, 0.0F,      limbEnd, limbTop, limbEnd);\n+        VoxelShape south = Block.makeCuboidShape(limbStart, limbBase, limbStart, limbEnd, limbTop, 16.0D);\n+        VoxelShape west  = Block.makeCuboidShape(0.0F,      limbBase, limbStart, limbEnd, limbTop, limbEnd);\n+        VoxelShape east  = Block.makeCuboidShape(limbStart, limbBase, limbStart, 16.0D,   limbTop, limbEnd);\n+        VoxelShape cornernw = VoxelShapes.or(north, east);\n+        VoxelShape cornerse = VoxelShapes.or(south, west);\n+\n+        // All 16 possible block combinations, in a specific index to be retrieved by getIndex\n+        VoxelShape[] avoxelshape = new VoxelShape[]{\n+                VoxelShapes.empty(),    south,   west, cornerse, north,\n+                VoxelShapes.or(south,   north),\n+                VoxelShapes.or(west,    north),\n+                VoxelShapes.or(cornerse,north),  east,\n+                VoxelShapes.or(south,   east),\n+                VoxelShapes.or(west,    east),\n+                VoxelShapes.or(cornerse,east),   cornernw,\n+                VoxelShapes.or(south,   cornernw),\n+                VoxelShapes.or(west,    cornernw),\n+                VoxelShapes.or(cornerse,cornernw)\n+        };\n \n-        public String getTranslationKey()\n-        {\n-            return this.unlocalizedName;\n+        // Combine the arm voxel shapes with the main node for all combinations\n+        for(int i = 0; i < 16; ++i) {\n+            avoxelshape[i] = VoxelShapes.or(node, avoxelshape[i]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "798bcd6fd2560686d977f2630229e9b3b75c5240"}, "originalPosition": 195}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b1cec33b8da6111ec6b4786fbb9c3f9cc9cc9000", "author": {"user": {"login": "ShadowProtocol", "name": null}}, "url": "https://github.com/ldtteam/minecolonies/commit/b1cec33b8da6111ec6b4786fbb9c3f9cc9cc9000", "committedDate": "2020-06-26T09:58:39Z", "message": "Fix formatting and naming"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4Njg0Mjc0", "url": "https://github.com/ldtteam/minecolonies/pull/5298#pullrequestreview-438684274", "createdAt": "2020-06-27T08:59:06Z", "commit": {"oid": "b1cec33b8da6111ec6b4786fbb9c3f9cc9cc9000"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwODo1OTowNlrOGp0afg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwODo1OTowNlrOGp0afg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjUwMzU1MA==", "bodyText": "format", "url": "https://github.com/ldtteam/minecolonies/pull/5298#discussion_r446503550", "createdAt": "2020-06-27T08:59:06Z", "author": {"login": "Raycoms"}, "path": "src/api/java/com/minecolonies/api/blocks/decorative/AbstractBlockMinecoloniesConstructionTape.java", "diffHunk": "@@ -1,107 +1,121 @@\n package com.minecolonies.api.blocks.decorative;\n \n import com.minecolonies.api.blocks.AbstractBlockMinecoloniesFalling;\n-import net.minecraft.block.HorizontalBlock;\n-import net.minecraft.block.material.MaterialColor;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n+import net.minecraft.block.*;\n+import net.minecraft.fluid.Fluids;\n+import net.minecraft.fluid.IFluidState;\n+import net.minecraft.state.BooleanProperty;\n import net.minecraft.state.DirectionProperty;\n-import net.minecraft.state.EnumProperty;\n-import net.minecraft.util.IStringSerializable;\n+import net.minecraft.state.properties.BlockStateProperties;\n+import net.minecraft.util.Direction;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.shapes.ISelectionContext;\n+import net.minecraft.util.math.shapes.VoxelShape;\n+import net.minecraft.util.math.shapes.VoxelShapes;\n+import net.minecraft.world.IBlockReader;\n import org.jetbrains.annotations.NotNull;\n \n-public abstract class AbstractBlockMinecoloniesConstructionTape<B extends AbstractBlockMinecoloniesConstructionTape<B>> extends AbstractBlockMinecoloniesFalling<B>\n+public abstract class AbstractBlockMinecoloniesConstructionTape<B extends AbstractBlockMinecoloniesConstructionTape<B>> extends AbstractBlockMinecoloniesFalling<B> implements IWaterLoggable\n {\n+    public static final BooleanProperty NORTH = SixWayBlock.NORTH;\n+    public static final BooleanProperty EAST = SixWayBlock.EAST;\n+    public static final BooleanProperty SOUTH = SixWayBlock.SOUTH;\n+    public static final BooleanProperty WEST = SixWayBlock.WEST;\n+    public static final BooleanProperty WATERLOGGED = BlockStateProperties.WATERLOGGED;\n+\n+    protected VoxelShape[] shapes = new VoxelShape[]{};\n+\n+    private final Object2IntMap<BlockState> stateShapeMap = new Object2IntOpenHashMap<>();\n+\n     /**\n-     * The variants of the shingle slab.\n+     * The default face for when there are no connections.\n      */\n-    public static final EnumProperty<ConstructionTapeType> VARIANT = EnumProperty.create(\"variant\", ConstructionTapeType.class);\n+    public static final DirectionProperty FACING = HorizontalBlock.HORIZONTAL_FACING;\n \n     /**\n-     * The position it faces.\n+     * Implies that the tape should revert to a corner if there are no connections. Must be set explicitly. For use by the builder handler.\n      */\n-    public static final DirectionProperty FACING = HorizontalBlock.HORIZONTAL_FACING;\n+    public static final BooleanProperty CORNER = BooleanProperty.create(\"corner\");\n \n     public AbstractBlockMinecoloniesConstructionTape(final Properties properties)\n     {\n         super(properties);\n     }\n \n-    /**\n-     * Types that the {@link AbstractBlockMinecoloniesConstructionTape} supports\n-     */\n-    public enum ConstructionTapeType implements IStringSerializable\n+    @NotNull\n+    @Override\n+    public VoxelShape getShape(BlockState state, IBlockReader worldIn, BlockPos pos, ISelectionContext context)\n     {\n-        STRAIGHT(0, \"straight\", MaterialColor.WOOD),\n-        CORNER(1, \"corner\", MaterialColor.OBSIDIAN);\n+        return this.shapes[this.getIndex(state)];\n+    }\n \n-        private static final ConstructionTapeType[] META_LOOKUP = new ConstructionTapeType[values().length];\n-        static\n-        {\n-            for (final ConstructionTapeType enumtype : values())\n-            {\n-                META_LOOKUP[enumtype.getMetadata()] = enumtype;\n-            }\n-        }\n-        private final int           meta;\n-        private final String        name;\n-        private final String        unlocalizedName;\n-        /**\n-         * The color that represents this entry on a map.\n-         */\n-        private final MaterialColor mapColor;\n-\n-        ConstructionTapeType(final int metaIn, final String nameIn, final MaterialColor mapColorIn)\n-        {\n-            this(metaIn, nameIn, nameIn, mapColorIn);\n-        }\n+    private static int getMask(Direction facing) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1cec33b8da6111ec6b4786fbb9c3f9cc9cc9000"}, "originalPosition": 89}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa1af9d47b1d78ea63c69ed7a82e84928c99316d", "author": {"user": {"login": "ShadowProtocol", "name": null}}, "url": "https://github.com/ldtteam/minecolonies/commit/fa1af9d47b1d78ea63c69ed7a82e84928c99316d", "committedDate": "2020-06-27T09:31:02Z", "message": "Fix formatting"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2081, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}