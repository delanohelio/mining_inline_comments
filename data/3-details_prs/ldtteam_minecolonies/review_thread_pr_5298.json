{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQwNDQ3NjA5", "number": 5298, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwODozMTozM1rOEJDMLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwODo1OTowNlrOEJVLAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3OTI0OTA4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/builder/ConstructionTapeHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwODozMTozM1rOGpYbFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwODozMTozM1rOGpYbFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA0NDk1MA==", "bodyText": "use lower case full name, sizeX or similar", "url": "https://github.com/ldtteam/minecolonies/pull/5298#discussion_r446044950", "createdAt": "2020-06-26T08:31:33Z", "author": {"login": "Nightenom"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/builder/ConstructionTapeHelper.java", "diffHunk": "@@ -61,106 +56,77 @@ public static void placeConstructionTape(@NotNull final WorkOrderBuildDecoration\n      */\n     public static void placeConstructionTape(final BlockPos pos, final Tuple<Tuple<Integer, Integer>, Tuple<Integer, Integer>> corners, @NotNull final World world)\n     {\n-        if (MineColonies.getConfig().getCommon().builderPlaceConstructionTape.get())\n-        {\n-            final BlockState constructionTape = ModBlocks.blockConstructionTape.getDefaultState();\n+        if (!MineColonies.getConfig().getCommon().builderPlaceConstructionTape.get()) return;\n \n-            final int x1 = corners.getA().getA();\n-            final int x3 = corners.getA().getB();\n-            final int z1 = corners.getB().getA();\n-            final int z3 = corners.getB().getB();\n-            final int y = pos.getY();\n-            int newY;\n+        final BlockState constructionTape = ModBlocks.blockConstructionTape.getDefaultState();\n \n-            if (x1 < x3)\n-            {\n-                for (int i = x1 + 1; i < x3; i++)\n-                {\n-                    newY = checkIfPlaceable(i, y, z1, world);\n-                    final BlockPos row1 = new BlockPos(i, newY, z1);\n-                    world.setBlockState(row1, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.SOUTH), world, row1));\n-                    newY = checkIfPlaceable(i, y, z3, world);\n-                    final BlockPos row2 = new BlockPos(i, newY, z3);\n-                    world.setBlockState(row2, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.NORTH), world, row2));\n-                }\n-            }\n-            else\n-            {\n-                for (int i = x3 + 1; i < x1; i++)\n-                {\n-                    newY = checkIfPlaceable(i, y, z1, world);\n-                    final BlockPos row1 = new BlockPos(i, newY, z1);\n-                    world.setBlockState(row1, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.SOUTH), world, row1));\n-                    newY = checkIfPlaceable(i, y, z3, world);\n-                    final BlockPos row2 = new BlockPos(i, newY, z3);\n-                    world.setBlockState(row2, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.NORTH), world, row2));\n-                }\n-            }\n-            if (z1 < z3)\n+        final int X = Math.min(corners.getA().getA(), corners.getA().getB());\n+        final int Y = pos.getY();\n+        final int Z = Math.min(corners.getB().getA(), corners.getB().getB());\n+        int W = Math.abs(corners.getA().getB() - corners.getA().getA());\n+        int H = Math.abs(corners.getB().getB() - corners.getB().getA());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00e0d0a5cbbf363dfa41178b1d4c6fc0525f477e"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3OTI1NTc1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/builder/ConstructionTapeHelper.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwODozMzo0MlrOGpYfhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwOTo1MToyOFrOGpa48A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA0NjA4NQ==", "bodyText": "leaves block only when not persistent, or I would say no to all", "url": "https://github.com/ldtteam/minecolonies/pull/5298#discussion_r446046085", "createdAt": "2020-06-26T08:33:42Z", "author": {"login": "Nightenom"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/builder/ConstructionTapeHelper.java", "diffHunk": "@@ -61,106 +56,77 @@ public static void placeConstructionTape(@NotNull final WorkOrderBuildDecoration\n      */\n     public static void placeConstructionTape(final BlockPos pos, final Tuple<Tuple<Integer, Integer>, Tuple<Integer, Integer>> corners, @NotNull final World world)\n     {\n-        if (MineColonies.getConfig().getCommon().builderPlaceConstructionTape.get())\n-        {\n-            final BlockState constructionTape = ModBlocks.blockConstructionTape.getDefaultState();\n+        if (!MineColonies.getConfig().getCommon().builderPlaceConstructionTape.get()) return;\n \n-            final int x1 = corners.getA().getA();\n-            final int x3 = corners.getA().getB();\n-            final int z1 = corners.getB().getA();\n-            final int z3 = corners.getB().getB();\n-            final int y = pos.getY();\n-            int newY;\n+        final BlockState constructionTape = ModBlocks.blockConstructionTape.getDefaultState();\n \n-            if (x1 < x3)\n-            {\n-                for (int i = x1 + 1; i < x3; i++)\n-                {\n-                    newY = checkIfPlaceable(i, y, z1, world);\n-                    final BlockPos row1 = new BlockPos(i, newY, z1);\n-                    world.setBlockState(row1, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.SOUTH), world, row1));\n-                    newY = checkIfPlaceable(i, y, z3, world);\n-                    final BlockPos row2 = new BlockPos(i, newY, z3);\n-                    world.setBlockState(row2, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.NORTH), world, row2));\n-                }\n-            }\n-            else\n-            {\n-                for (int i = x3 + 1; i < x1; i++)\n-                {\n-                    newY = checkIfPlaceable(i, y, z1, world);\n-                    final BlockPos row1 = new BlockPos(i, newY, z1);\n-                    world.setBlockState(row1, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.SOUTH), world, row1));\n-                    newY = checkIfPlaceable(i, y, z3, world);\n-                    final BlockPos row2 = new BlockPos(i, newY, z3);\n-                    world.setBlockState(row2, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.NORTH), world, row2));\n-                }\n-            }\n-            if (z1 < z3)\n+        final int X = Math.min(corners.getA().getA(), corners.getA().getB());\n+        final int Y = pos.getY();\n+        final int Z = Math.min(corners.getB().getA(), corners.getB().getB());\n+        int W = Math.abs(corners.getA().getB() - corners.getA().getA());\n+        int H = Math.abs(corners.getB().getB() - corners.getB().getA());\n+        BlockPos working;\n+\n+        for (BlockPos place = new BlockPos(X,Y,Z); place.getX() < X+W || place.getZ() < Z+H;) {\n+            if (place.getX() < X+W)\n             {\n-                for (int i = z1 + 1; i < z3; i++)\n-                {\n-                    newY = checkIfPlaceable(x1, y, i, world);\n-                    final BlockPos row3 = new BlockPos(x1, newY, i);\n-                    world.setBlockState(row3, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.EAST), world, row3));\n-                    newY = checkIfPlaceable(x3, y, i, world);\n-                    final BlockPos row4 = new BlockPos(x3, newY, i);\n-                    world.setBlockState(row4, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.WEST), world, row4));\n-                }\n+                working = firstValidPosition(new BlockPos(place.getX(), Y, Z), world);\n+                world.setBlockState(working,\n+                        BlockConstructionTape.getPlacementState(constructionTape.with(CORNER, place.getX() == X), world, working, Direction.SOUTH)\n+                );\n+\n+                working = firstValidPosition(new BlockPos(place.getX(), Y, Z+H), world);\n+                world.setBlockState(working,\n+                        BlockConstructionTape.getPlacementState(constructionTape.with(CORNER, place.getX() == X), world, working, Direction.NORTH)\n+                );\n             }\n-            else\n+\n+            if (place.getZ() < Z+H)\n             {\n-                for (int i = z3 + 1; i < z1; i++)\n-                {\n-                    newY = checkIfPlaceable(x1, y, i, world);\n-                    final BlockPos row3 = new BlockPos(x1, newY, i);\n-                    world.setBlockState(row3, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.EAST), world, row3));\n-                    newY = checkIfPlaceable(x3, y, i, world);\n-                    final BlockPos row4 = new BlockPos(x3, newY, i);\n-                    world.setBlockState(row4, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.WEST), world, row4));\n-                }\n+                working = firstValidPosition(new BlockPos(X, Y, place.getZ()), world);\n+                world.setBlockState(working,\n+                        BlockConstructionTape.getPlacementState(constructionTape.with(CORNER, place.getZ() == Z), world, working, Direction.EAST)\n+                );\n+\n+                working = firstValidPosition(new BlockPos(X+W, Y, place.getZ()), world);\n+                world.setBlockState(working,\n+                        BlockConstructionTape.getPlacementState(constructionTape.with(CORNER, place.getZ() == Z), world, working, place.getZ() == Z? Direction.SOUTH : Direction.WEST)\n+                );\n             }\n-            newY = checkIfPlaceable(x1, y, z1, world);\n-            final BlockPos corner1 = new BlockPos(x1, newY, z1);\n-            newY = checkIfPlaceable(x1, y, z3, world);\n-            final BlockPos corner2 = new BlockPos(x1, newY, z3);\n-            newY = checkIfPlaceable(x3, y, z1, world);\n-            final BlockPos corner3 = new BlockPos(x3, newY, z1);\n-            newY = checkIfPlaceable(x3, y, z3, world);\n-            final BlockPos corner4 = new BlockPos(x3, newY, z3);\n-            world.setBlockState(corner1, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.SOUTH), world, corner1));\n-            world.setBlockState(corner2, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.EAST), world, corner2));\n-            world.setBlockState(corner3, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.WEST), world, corner3));\n-            world.setBlockState(corner4, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.NORTH), world, corner4));\n+\n+            place = place.south().east();\n         }\n+\n+        working = firstValidPosition(new BlockPos(X+W, Y, Z+H), world);\n+        world.setBlockState(working,\n+                BlockConstructionTape.getPlacementState(constructionTape.with(CORNER, true), world, working, Direction.WEST)\n+        );\n     }\n \n     /**\n-     * Check if a block is placeable and return new Y position.\n+     * Find and return the highest position that is directly above a non-replaceable block.\n      *\n-     * @param x     Block X position.\n-     * @param y     Block Y position.\n-     * @param z     Block Z position.\n+     * @param target the target position for the block\n      * @param world the world.\n-     * @return The new Y position.\n+     * @return The new block position.\n      */\n-\n-    public static int checkIfPlaceable(@NotNull final int x, @NotNull final int y, @NotNull final int z, @NotNull final World world)\n+    public static BlockPos firstValidPosition(@NotNull BlockPos target, @NotNull World world)\n     {\n-        BlockPos target = new BlockPos(x,y,z);\n         final Chunk chunk = world.getChunkAt(target);\n \n-        target = new BlockPos(x, chunk.getTopFilledSegment() + 16, z);\n-        while(world.getBlockState(target).getMaterial().isReplaceable())\n+        target = new BlockPos(target.getX(), chunk.getTopFilledSegment() + 16, target.getZ());\n+                \n+        while (target.getY() > 0)\n         {\n             target = target.down();\n-            if (target.getY() == 0)\n-            {\n+            \n+            if (!world.getBlockState(target).getMaterial().isReplaceable() \n+             && !(world.getBlockState(target).getBlock() instanceof LeavesBlock)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00e0d0a5cbbf363dfa41178b1d4c6fc0525f477e"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1MjU0Nw==", "bodyText": "Not quite sure what you are getting at. The point of that line is so that overhanging trees are ignored. What do you mean?", "url": "https://github.com/ldtteam/minecolonies/pull/5298#discussion_r446052547", "createdAt": "2020-06-26T08:46:39Z", "author": {"login": "ShadowProtocol"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/builder/ConstructionTapeHelper.java", "diffHunk": "@@ -61,106 +56,77 @@ public static void placeConstructionTape(@NotNull final WorkOrderBuildDecoration\n      */\n     public static void placeConstructionTape(final BlockPos pos, final Tuple<Tuple<Integer, Integer>, Tuple<Integer, Integer>> corners, @NotNull final World world)\n     {\n-        if (MineColonies.getConfig().getCommon().builderPlaceConstructionTape.get())\n-        {\n-            final BlockState constructionTape = ModBlocks.blockConstructionTape.getDefaultState();\n+        if (!MineColonies.getConfig().getCommon().builderPlaceConstructionTape.get()) return;\n \n-            final int x1 = corners.getA().getA();\n-            final int x3 = corners.getA().getB();\n-            final int z1 = corners.getB().getA();\n-            final int z3 = corners.getB().getB();\n-            final int y = pos.getY();\n-            int newY;\n+        final BlockState constructionTape = ModBlocks.blockConstructionTape.getDefaultState();\n \n-            if (x1 < x3)\n-            {\n-                for (int i = x1 + 1; i < x3; i++)\n-                {\n-                    newY = checkIfPlaceable(i, y, z1, world);\n-                    final BlockPos row1 = new BlockPos(i, newY, z1);\n-                    world.setBlockState(row1, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.SOUTH), world, row1));\n-                    newY = checkIfPlaceable(i, y, z3, world);\n-                    final BlockPos row2 = new BlockPos(i, newY, z3);\n-                    world.setBlockState(row2, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.NORTH), world, row2));\n-                }\n-            }\n-            else\n-            {\n-                for (int i = x3 + 1; i < x1; i++)\n-                {\n-                    newY = checkIfPlaceable(i, y, z1, world);\n-                    final BlockPos row1 = new BlockPos(i, newY, z1);\n-                    world.setBlockState(row1, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.SOUTH), world, row1));\n-                    newY = checkIfPlaceable(i, y, z3, world);\n-                    final BlockPos row2 = new BlockPos(i, newY, z3);\n-                    world.setBlockState(row2, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.NORTH), world, row2));\n-                }\n-            }\n-            if (z1 < z3)\n+        final int X = Math.min(corners.getA().getA(), corners.getA().getB());\n+        final int Y = pos.getY();\n+        final int Z = Math.min(corners.getB().getA(), corners.getB().getB());\n+        int W = Math.abs(corners.getA().getB() - corners.getA().getA());\n+        int H = Math.abs(corners.getB().getB() - corners.getB().getA());\n+        BlockPos working;\n+\n+        for (BlockPos place = new BlockPos(X,Y,Z); place.getX() < X+W || place.getZ() < Z+H;) {\n+            if (place.getX() < X+W)\n             {\n-                for (int i = z1 + 1; i < z3; i++)\n-                {\n-                    newY = checkIfPlaceable(x1, y, i, world);\n-                    final BlockPos row3 = new BlockPos(x1, newY, i);\n-                    world.setBlockState(row3, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.EAST), world, row3));\n-                    newY = checkIfPlaceable(x3, y, i, world);\n-                    final BlockPos row4 = new BlockPos(x3, newY, i);\n-                    world.setBlockState(row4, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.WEST), world, row4));\n-                }\n+                working = firstValidPosition(new BlockPos(place.getX(), Y, Z), world);\n+                world.setBlockState(working,\n+                        BlockConstructionTape.getPlacementState(constructionTape.with(CORNER, place.getX() == X), world, working, Direction.SOUTH)\n+                );\n+\n+                working = firstValidPosition(new BlockPos(place.getX(), Y, Z+H), world);\n+                world.setBlockState(working,\n+                        BlockConstructionTape.getPlacementState(constructionTape.with(CORNER, place.getX() == X), world, working, Direction.NORTH)\n+                );\n             }\n-            else\n+\n+            if (place.getZ() < Z+H)\n             {\n-                for (int i = z3 + 1; i < z1; i++)\n-                {\n-                    newY = checkIfPlaceable(x1, y, i, world);\n-                    final BlockPos row3 = new BlockPos(x1, newY, i);\n-                    world.setBlockState(row3, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.EAST), world, row3));\n-                    newY = checkIfPlaceable(x3, y, i, world);\n-                    final BlockPos row4 = new BlockPos(x3, newY, i);\n-                    world.setBlockState(row4, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.WEST), world, row4));\n-                }\n+                working = firstValidPosition(new BlockPos(X, Y, place.getZ()), world);\n+                world.setBlockState(working,\n+                        BlockConstructionTape.getPlacementState(constructionTape.with(CORNER, place.getZ() == Z), world, working, Direction.EAST)\n+                );\n+\n+                working = firstValidPosition(new BlockPos(X+W, Y, place.getZ()), world);\n+                world.setBlockState(working,\n+                        BlockConstructionTape.getPlacementState(constructionTape.with(CORNER, place.getZ() == Z), world, working, place.getZ() == Z? Direction.SOUTH : Direction.WEST)\n+                );\n             }\n-            newY = checkIfPlaceable(x1, y, z1, world);\n-            final BlockPos corner1 = new BlockPos(x1, newY, z1);\n-            newY = checkIfPlaceable(x1, y, z3, world);\n-            final BlockPos corner2 = new BlockPos(x1, newY, z3);\n-            newY = checkIfPlaceable(x3, y, z1, world);\n-            final BlockPos corner3 = new BlockPos(x3, newY, z1);\n-            newY = checkIfPlaceable(x3, y, z3, world);\n-            final BlockPos corner4 = new BlockPos(x3, newY, z3);\n-            world.setBlockState(corner1, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.SOUTH), world, corner1));\n-            world.setBlockState(corner2, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.EAST), world, corner2));\n-            world.setBlockState(corner3, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.WEST), world, corner3));\n-            world.setBlockState(corner4, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.NORTH), world, corner4));\n+\n+            place = place.south().east();\n         }\n+\n+        working = firstValidPosition(new BlockPos(X+W, Y, Z+H), world);\n+        world.setBlockState(working,\n+                BlockConstructionTape.getPlacementState(constructionTape.with(CORNER, true), world, working, Direction.WEST)\n+        );\n     }\n \n     /**\n-     * Check if a block is placeable and return new Y position.\n+     * Find and return the highest position that is directly above a non-replaceable block.\n      *\n-     * @param x     Block X position.\n-     * @param y     Block Y position.\n-     * @param z     Block Z position.\n+     * @param target the target position for the block\n      * @param world the world.\n-     * @return The new Y position.\n+     * @return The new block position.\n      */\n-\n-    public static int checkIfPlaceable(@NotNull final int x, @NotNull final int y, @NotNull final int z, @NotNull final World world)\n+    public static BlockPos firstValidPosition(@NotNull BlockPos target, @NotNull World world)\n     {\n-        BlockPos target = new BlockPos(x,y,z);\n         final Chunk chunk = world.getChunkAt(target);\n \n-        target = new BlockPos(x, chunk.getTopFilledSegment() + 16, z);\n-        while(world.getBlockState(target).getMaterial().isReplaceable())\n+        target = new BlockPos(target.getX(), chunk.getTopFilledSegment() + 16, target.getZ());\n+                \n+        while (target.getY() > 0)\n         {\n             target = target.down();\n-            if (target.getY() == 0)\n-            {\n+            \n+            if (!world.getBlockState(target).getMaterial().isReplaceable() \n+             && !(world.getBlockState(target).getBlock() instanceof LeavesBlock)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA0NjA4NQ=="}, "originalCommit": {"oid": "00e0d0a5cbbf363dfa41178b1d4c6fc0525f477e"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1NDEzMg==", "bodyText": "There is a property on leaves if they are placed manually by the player or builder. Those should not be replaced.", "url": "https://github.com/ldtteam/minecolonies/pull/5298#discussion_r446054132", "createdAt": "2020-06-26T08:49:43Z", "author": {"login": "Raycoms"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/builder/ConstructionTapeHelper.java", "diffHunk": "@@ -61,106 +56,77 @@ public static void placeConstructionTape(@NotNull final WorkOrderBuildDecoration\n      */\n     public static void placeConstructionTape(final BlockPos pos, final Tuple<Tuple<Integer, Integer>, Tuple<Integer, Integer>> corners, @NotNull final World world)\n     {\n-        if (MineColonies.getConfig().getCommon().builderPlaceConstructionTape.get())\n-        {\n-            final BlockState constructionTape = ModBlocks.blockConstructionTape.getDefaultState();\n+        if (!MineColonies.getConfig().getCommon().builderPlaceConstructionTape.get()) return;\n \n-            final int x1 = corners.getA().getA();\n-            final int x3 = corners.getA().getB();\n-            final int z1 = corners.getB().getA();\n-            final int z3 = corners.getB().getB();\n-            final int y = pos.getY();\n-            int newY;\n+        final BlockState constructionTape = ModBlocks.blockConstructionTape.getDefaultState();\n \n-            if (x1 < x3)\n-            {\n-                for (int i = x1 + 1; i < x3; i++)\n-                {\n-                    newY = checkIfPlaceable(i, y, z1, world);\n-                    final BlockPos row1 = new BlockPos(i, newY, z1);\n-                    world.setBlockState(row1, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.SOUTH), world, row1));\n-                    newY = checkIfPlaceable(i, y, z3, world);\n-                    final BlockPos row2 = new BlockPos(i, newY, z3);\n-                    world.setBlockState(row2, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.NORTH), world, row2));\n-                }\n-            }\n-            else\n-            {\n-                for (int i = x3 + 1; i < x1; i++)\n-                {\n-                    newY = checkIfPlaceable(i, y, z1, world);\n-                    final BlockPos row1 = new BlockPos(i, newY, z1);\n-                    world.setBlockState(row1, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.SOUTH), world, row1));\n-                    newY = checkIfPlaceable(i, y, z3, world);\n-                    final BlockPos row2 = new BlockPos(i, newY, z3);\n-                    world.setBlockState(row2, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.NORTH), world, row2));\n-                }\n-            }\n-            if (z1 < z3)\n+        final int X = Math.min(corners.getA().getA(), corners.getA().getB());\n+        final int Y = pos.getY();\n+        final int Z = Math.min(corners.getB().getA(), corners.getB().getB());\n+        int W = Math.abs(corners.getA().getB() - corners.getA().getA());\n+        int H = Math.abs(corners.getB().getB() - corners.getB().getA());\n+        BlockPos working;\n+\n+        for (BlockPos place = new BlockPos(X,Y,Z); place.getX() < X+W || place.getZ() < Z+H;) {\n+            if (place.getX() < X+W)\n             {\n-                for (int i = z1 + 1; i < z3; i++)\n-                {\n-                    newY = checkIfPlaceable(x1, y, i, world);\n-                    final BlockPos row3 = new BlockPos(x1, newY, i);\n-                    world.setBlockState(row3, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.EAST), world, row3));\n-                    newY = checkIfPlaceable(x3, y, i, world);\n-                    final BlockPos row4 = new BlockPos(x3, newY, i);\n-                    world.setBlockState(row4, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.WEST), world, row4));\n-                }\n+                working = firstValidPosition(new BlockPos(place.getX(), Y, Z), world);\n+                world.setBlockState(working,\n+                        BlockConstructionTape.getPlacementState(constructionTape.with(CORNER, place.getX() == X), world, working, Direction.SOUTH)\n+                );\n+\n+                working = firstValidPosition(new BlockPos(place.getX(), Y, Z+H), world);\n+                world.setBlockState(working,\n+                        BlockConstructionTape.getPlacementState(constructionTape.with(CORNER, place.getX() == X), world, working, Direction.NORTH)\n+                );\n             }\n-            else\n+\n+            if (place.getZ() < Z+H)\n             {\n-                for (int i = z3 + 1; i < z1; i++)\n-                {\n-                    newY = checkIfPlaceable(x1, y, i, world);\n-                    final BlockPos row3 = new BlockPos(x1, newY, i);\n-                    world.setBlockState(row3, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.EAST), world, row3));\n-                    newY = checkIfPlaceable(x3, y, i, world);\n-                    final BlockPos row4 = new BlockPos(x3, newY, i);\n-                    world.setBlockState(row4, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.WEST), world, row4));\n-                }\n+                working = firstValidPosition(new BlockPos(X, Y, place.getZ()), world);\n+                world.setBlockState(working,\n+                        BlockConstructionTape.getPlacementState(constructionTape.with(CORNER, place.getZ() == Z), world, working, Direction.EAST)\n+                );\n+\n+                working = firstValidPosition(new BlockPos(X+W, Y, place.getZ()), world);\n+                world.setBlockState(working,\n+                        BlockConstructionTape.getPlacementState(constructionTape.with(CORNER, place.getZ() == Z), world, working, place.getZ() == Z? Direction.SOUTH : Direction.WEST)\n+                );\n             }\n-            newY = checkIfPlaceable(x1, y, z1, world);\n-            final BlockPos corner1 = new BlockPos(x1, newY, z1);\n-            newY = checkIfPlaceable(x1, y, z3, world);\n-            final BlockPos corner2 = new BlockPos(x1, newY, z3);\n-            newY = checkIfPlaceable(x3, y, z1, world);\n-            final BlockPos corner3 = new BlockPos(x3, newY, z1);\n-            newY = checkIfPlaceable(x3, y, z3, world);\n-            final BlockPos corner4 = new BlockPos(x3, newY, z3);\n-            world.setBlockState(corner1, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.SOUTH), world, corner1));\n-            world.setBlockState(corner2, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.EAST), world, corner2));\n-            world.setBlockState(corner3, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.WEST), world, corner3));\n-            world.setBlockState(corner4, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.NORTH), world, corner4));\n+\n+            place = place.south().east();\n         }\n+\n+        working = firstValidPosition(new BlockPos(X+W, Y, Z+H), world);\n+        world.setBlockState(working,\n+                BlockConstructionTape.getPlacementState(constructionTape.with(CORNER, true), world, working, Direction.WEST)\n+        );\n     }\n \n     /**\n-     * Check if a block is placeable and return new Y position.\n+     * Find and return the highest position that is directly above a non-replaceable block.\n      *\n-     * @param x     Block X position.\n-     * @param y     Block Y position.\n-     * @param z     Block Z position.\n+     * @param target the target position for the block\n      * @param world the world.\n-     * @return The new Y position.\n+     * @return The new block position.\n      */\n-\n-    public static int checkIfPlaceable(@NotNull final int x, @NotNull final int y, @NotNull final int z, @NotNull final World world)\n+    public static BlockPos firstValidPosition(@NotNull BlockPos target, @NotNull World world)\n     {\n-        BlockPos target = new BlockPos(x,y,z);\n         final Chunk chunk = world.getChunkAt(target);\n \n-        target = new BlockPos(x, chunk.getTopFilledSegment() + 16, z);\n-        while(world.getBlockState(target).getMaterial().isReplaceable())\n+        target = new BlockPos(target.getX(), chunk.getTopFilledSegment() + 16, target.getZ());\n+                \n+        while (target.getY() > 0)\n         {\n             target = target.down();\n-            if (target.getY() == 0)\n-            {\n+            \n+            if (!world.getBlockState(target).getMaterial().isReplaceable() \n+             && !(world.getBlockState(target).getBlock() instanceof LeavesBlock)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA0NjA4NQ=="}, "originalCommit": {"oid": "00e0d0a5cbbf363dfa41178b1d4c6fc0525f477e"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1NDk0Mg==", "bodyText": "I would say no to all, unless you can find air block under a row of leaves only", "url": "https://github.com/ldtteam/minecolonies/pull/5298#discussion_r446054942", "createdAt": "2020-06-26T08:51:14Z", "author": {"login": "Nightenom"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/builder/ConstructionTapeHelper.java", "diffHunk": "@@ -61,106 +56,77 @@ public static void placeConstructionTape(@NotNull final WorkOrderBuildDecoration\n      */\n     public static void placeConstructionTape(final BlockPos pos, final Tuple<Tuple<Integer, Integer>, Tuple<Integer, Integer>> corners, @NotNull final World world)\n     {\n-        if (MineColonies.getConfig().getCommon().builderPlaceConstructionTape.get())\n-        {\n-            final BlockState constructionTape = ModBlocks.blockConstructionTape.getDefaultState();\n+        if (!MineColonies.getConfig().getCommon().builderPlaceConstructionTape.get()) return;\n \n-            final int x1 = corners.getA().getA();\n-            final int x3 = corners.getA().getB();\n-            final int z1 = corners.getB().getA();\n-            final int z3 = corners.getB().getB();\n-            final int y = pos.getY();\n-            int newY;\n+        final BlockState constructionTape = ModBlocks.blockConstructionTape.getDefaultState();\n \n-            if (x1 < x3)\n-            {\n-                for (int i = x1 + 1; i < x3; i++)\n-                {\n-                    newY = checkIfPlaceable(i, y, z1, world);\n-                    final BlockPos row1 = new BlockPos(i, newY, z1);\n-                    world.setBlockState(row1, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.SOUTH), world, row1));\n-                    newY = checkIfPlaceable(i, y, z3, world);\n-                    final BlockPos row2 = new BlockPos(i, newY, z3);\n-                    world.setBlockState(row2, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.NORTH), world, row2));\n-                }\n-            }\n-            else\n-            {\n-                for (int i = x3 + 1; i < x1; i++)\n-                {\n-                    newY = checkIfPlaceable(i, y, z1, world);\n-                    final BlockPos row1 = new BlockPos(i, newY, z1);\n-                    world.setBlockState(row1, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.SOUTH), world, row1));\n-                    newY = checkIfPlaceable(i, y, z3, world);\n-                    final BlockPos row2 = new BlockPos(i, newY, z3);\n-                    world.setBlockState(row2, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.NORTH), world, row2));\n-                }\n-            }\n-            if (z1 < z3)\n+        final int X = Math.min(corners.getA().getA(), corners.getA().getB());\n+        final int Y = pos.getY();\n+        final int Z = Math.min(corners.getB().getA(), corners.getB().getB());\n+        int W = Math.abs(corners.getA().getB() - corners.getA().getA());\n+        int H = Math.abs(corners.getB().getB() - corners.getB().getA());\n+        BlockPos working;\n+\n+        for (BlockPos place = new BlockPos(X,Y,Z); place.getX() < X+W || place.getZ() < Z+H;) {\n+            if (place.getX() < X+W)\n             {\n-                for (int i = z1 + 1; i < z3; i++)\n-                {\n-                    newY = checkIfPlaceable(x1, y, i, world);\n-                    final BlockPos row3 = new BlockPos(x1, newY, i);\n-                    world.setBlockState(row3, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.EAST), world, row3));\n-                    newY = checkIfPlaceable(x3, y, i, world);\n-                    final BlockPos row4 = new BlockPos(x3, newY, i);\n-                    world.setBlockState(row4, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.WEST), world, row4));\n-                }\n+                working = firstValidPosition(new BlockPos(place.getX(), Y, Z), world);\n+                world.setBlockState(working,\n+                        BlockConstructionTape.getPlacementState(constructionTape.with(CORNER, place.getX() == X), world, working, Direction.SOUTH)\n+                );\n+\n+                working = firstValidPosition(new BlockPos(place.getX(), Y, Z+H), world);\n+                world.setBlockState(working,\n+                        BlockConstructionTape.getPlacementState(constructionTape.with(CORNER, place.getX() == X), world, working, Direction.NORTH)\n+                );\n             }\n-            else\n+\n+            if (place.getZ() < Z+H)\n             {\n-                for (int i = z3 + 1; i < z1; i++)\n-                {\n-                    newY = checkIfPlaceable(x1, y, i, world);\n-                    final BlockPos row3 = new BlockPos(x1, newY, i);\n-                    world.setBlockState(row3, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.EAST), world, row3));\n-                    newY = checkIfPlaceable(x3, y, i, world);\n-                    final BlockPos row4 = new BlockPos(x3, newY, i);\n-                    world.setBlockState(row4, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.WEST), world, row4));\n-                }\n+                working = firstValidPosition(new BlockPos(X, Y, place.getZ()), world);\n+                world.setBlockState(working,\n+                        BlockConstructionTape.getPlacementState(constructionTape.with(CORNER, place.getZ() == Z), world, working, Direction.EAST)\n+                );\n+\n+                working = firstValidPosition(new BlockPos(X+W, Y, place.getZ()), world);\n+                world.setBlockState(working,\n+                        BlockConstructionTape.getPlacementState(constructionTape.with(CORNER, place.getZ() == Z), world, working, place.getZ() == Z? Direction.SOUTH : Direction.WEST)\n+                );\n             }\n-            newY = checkIfPlaceable(x1, y, z1, world);\n-            final BlockPos corner1 = new BlockPos(x1, newY, z1);\n-            newY = checkIfPlaceable(x1, y, z3, world);\n-            final BlockPos corner2 = new BlockPos(x1, newY, z3);\n-            newY = checkIfPlaceable(x3, y, z1, world);\n-            final BlockPos corner3 = new BlockPos(x3, newY, z1);\n-            newY = checkIfPlaceable(x3, y, z3, world);\n-            final BlockPos corner4 = new BlockPos(x3, newY, z3);\n-            world.setBlockState(corner1, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.SOUTH), world, corner1));\n-            world.setBlockState(corner2, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.EAST), world, corner2));\n-            world.setBlockState(corner3, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.WEST), world, corner3));\n-            world.setBlockState(corner4, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.NORTH), world, corner4));\n+\n+            place = place.south().east();\n         }\n+\n+        working = firstValidPosition(new BlockPos(X+W, Y, Z+H), world);\n+        world.setBlockState(working,\n+                BlockConstructionTape.getPlacementState(constructionTape.with(CORNER, true), world, working, Direction.WEST)\n+        );\n     }\n \n     /**\n-     * Check if a block is placeable and return new Y position.\n+     * Find and return the highest position that is directly above a non-replaceable block.\n      *\n-     * @param x     Block X position.\n-     * @param y     Block Y position.\n-     * @param z     Block Z position.\n+     * @param target the target position for the block\n      * @param world the world.\n-     * @return The new Y position.\n+     * @return The new block position.\n      */\n-\n-    public static int checkIfPlaceable(@NotNull final int x, @NotNull final int y, @NotNull final int z, @NotNull final World world)\n+    public static BlockPos firstValidPosition(@NotNull BlockPos target, @NotNull World world)\n     {\n-        BlockPos target = new BlockPos(x,y,z);\n         final Chunk chunk = world.getChunkAt(target);\n \n-        target = new BlockPos(x, chunk.getTopFilledSegment() + 16, z);\n-        while(world.getBlockState(target).getMaterial().isReplaceable())\n+        target = new BlockPos(target.getX(), chunk.getTopFilledSegment() + 16, target.getZ());\n+                \n+        while (target.getY() > 0)\n         {\n             target = target.down();\n-            if (target.getY() == 0)\n-            {\n+            \n+            if (!world.getBlockState(target).getMaterial().isReplaceable() \n+             && !(world.getBlockState(target).getBlock() instanceof LeavesBlock)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA0NjA4NQ=="}, "originalCommit": {"oid": "00e0d0a5cbbf363dfa41178b1d4c6fc0525f477e"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA4NTM2MA==", "bodyText": "Now does a scan for air (or something properly replaceable) below.", "url": "https://github.com/ldtteam/minecolonies/pull/5298#discussion_r446085360", "createdAt": "2020-06-26T09:51:28Z", "author": {"login": "ShadowProtocol"}, "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/builder/ConstructionTapeHelper.java", "diffHunk": "@@ -61,106 +56,77 @@ public static void placeConstructionTape(@NotNull final WorkOrderBuildDecoration\n      */\n     public static void placeConstructionTape(final BlockPos pos, final Tuple<Tuple<Integer, Integer>, Tuple<Integer, Integer>> corners, @NotNull final World world)\n     {\n-        if (MineColonies.getConfig().getCommon().builderPlaceConstructionTape.get())\n-        {\n-            final BlockState constructionTape = ModBlocks.blockConstructionTape.getDefaultState();\n+        if (!MineColonies.getConfig().getCommon().builderPlaceConstructionTape.get()) return;\n \n-            final int x1 = corners.getA().getA();\n-            final int x3 = corners.getA().getB();\n-            final int z1 = corners.getB().getA();\n-            final int z3 = corners.getB().getB();\n-            final int y = pos.getY();\n-            int newY;\n+        final BlockState constructionTape = ModBlocks.blockConstructionTape.getDefaultState();\n \n-            if (x1 < x3)\n-            {\n-                for (int i = x1 + 1; i < x3; i++)\n-                {\n-                    newY = checkIfPlaceable(i, y, z1, world);\n-                    final BlockPos row1 = new BlockPos(i, newY, z1);\n-                    world.setBlockState(row1, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.SOUTH), world, row1));\n-                    newY = checkIfPlaceable(i, y, z3, world);\n-                    final BlockPos row2 = new BlockPos(i, newY, z3);\n-                    world.setBlockState(row2, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.NORTH), world, row2));\n-                }\n-            }\n-            else\n-            {\n-                for (int i = x3 + 1; i < x1; i++)\n-                {\n-                    newY = checkIfPlaceable(i, y, z1, world);\n-                    final BlockPos row1 = new BlockPos(i, newY, z1);\n-                    world.setBlockState(row1, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.SOUTH), world, row1));\n-                    newY = checkIfPlaceable(i, y, z3, world);\n-                    final BlockPos row2 = new BlockPos(i, newY, z3);\n-                    world.setBlockState(row2, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.NORTH), world, row2));\n-                }\n-            }\n-            if (z1 < z3)\n+        final int X = Math.min(corners.getA().getA(), corners.getA().getB());\n+        final int Y = pos.getY();\n+        final int Z = Math.min(corners.getB().getA(), corners.getB().getB());\n+        int W = Math.abs(corners.getA().getB() - corners.getA().getA());\n+        int H = Math.abs(corners.getB().getB() - corners.getB().getA());\n+        BlockPos working;\n+\n+        for (BlockPos place = new BlockPos(X,Y,Z); place.getX() < X+W || place.getZ() < Z+H;) {\n+            if (place.getX() < X+W)\n             {\n-                for (int i = z1 + 1; i < z3; i++)\n-                {\n-                    newY = checkIfPlaceable(x1, y, i, world);\n-                    final BlockPos row3 = new BlockPos(x1, newY, i);\n-                    world.setBlockState(row3, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.EAST), world, row3));\n-                    newY = checkIfPlaceable(x3, y, i, world);\n-                    final BlockPos row4 = new BlockPos(x3, newY, i);\n-                    world.setBlockState(row4, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.WEST), world, row4));\n-                }\n+                working = firstValidPosition(new BlockPos(place.getX(), Y, Z), world);\n+                world.setBlockState(working,\n+                        BlockConstructionTape.getPlacementState(constructionTape.with(CORNER, place.getX() == X), world, working, Direction.SOUTH)\n+                );\n+\n+                working = firstValidPosition(new BlockPos(place.getX(), Y, Z+H), world);\n+                world.setBlockState(working,\n+                        BlockConstructionTape.getPlacementState(constructionTape.with(CORNER, place.getX() == X), world, working, Direction.NORTH)\n+                );\n             }\n-            else\n+\n+            if (place.getZ() < Z+H)\n             {\n-                for (int i = z3 + 1; i < z1; i++)\n-                {\n-                    newY = checkIfPlaceable(x1, y, i, world);\n-                    final BlockPos row3 = new BlockPos(x1, newY, i);\n-                    world.setBlockState(row3, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.EAST), world, row3));\n-                    newY = checkIfPlaceable(x3, y, i, world);\n-                    final BlockPos row4 = new BlockPos(x3, newY, i);\n-                    world.setBlockState(row4, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.WEST), world, row4));\n-                }\n+                working = firstValidPosition(new BlockPos(X, Y, place.getZ()), world);\n+                world.setBlockState(working,\n+                        BlockConstructionTape.getPlacementState(constructionTape.with(CORNER, place.getZ() == Z), world, working, Direction.EAST)\n+                );\n+\n+                working = firstValidPosition(new BlockPos(X+W, Y, place.getZ()), world);\n+                world.setBlockState(working,\n+                        BlockConstructionTape.getPlacementState(constructionTape.with(CORNER, place.getZ() == Z), world, working, place.getZ() == Z? Direction.SOUTH : Direction.WEST)\n+                );\n             }\n-            newY = checkIfPlaceable(x1, y, z1, world);\n-            final BlockPos corner1 = new BlockPos(x1, newY, z1);\n-            newY = checkIfPlaceable(x1, y, z3, world);\n-            final BlockPos corner2 = new BlockPos(x1, newY, z3);\n-            newY = checkIfPlaceable(x3, y, z1, world);\n-            final BlockPos corner3 = new BlockPos(x3, newY, z1);\n-            newY = checkIfPlaceable(x3, y, z3, world);\n-            final BlockPos corner4 = new BlockPos(x3, newY, z3);\n-            world.setBlockState(corner1, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.SOUTH), world, corner1));\n-            world.setBlockState(corner2, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.EAST), world, corner2));\n-            world.setBlockState(corner3, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.WEST), world, corner3));\n-            world.setBlockState(corner4, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.NORTH), world, corner4));\n+\n+            place = place.south().east();\n         }\n+\n+        working = firstValidPosition(new BlockPos(X+W, Y, Z+H), world);\n+        world.setBlockState(working,\n+                BlockConstructionTape.getPlacementState(constructionTape.with(CORNER, true), world, working, Direction.WEST)\n+        );\n     }\n \n     /**\n-     * Check if a block is placeable and return new Y position.\n+     * Find and return the highest position that is directly above a non-replaceable block.\n      *\n-     * @param x     Block X position.\n-     * @param y     Block Y position.\n-     * @param z     Block Z position.\n+     * @param target the target position for the block\n      * @param world the world.\n-     * @return The new Y position.\n+     * @return The new block position.\n      */\n-\n-    public static int checkIfPlaceable(@NotNull final int x, @NotNull final int y, @NotNull final int z, @NotNull final World world)\n+    public static BlockPos firstValidPosition(@NotNull BlockPos target, @NotNull World world)\n     {\n-        BlockPos target = new BlockPos(x,y,z);\n         final Chunk chunk = world.getChunkAt(target);\n \n-        target = new BlockPos(x, chunk.getTopFilledSegment() + 16, z);\n-        while(world.getBlockState(target).getMaterial().isReplaceable())\n+        target = new BlockPos(target.getX(), chunk.getTopFilledSegment() + 16, target.getZ());\n+                \n+        while (target.getY() > 0)\n         {\n             target = target.down();\n-            if (target.getY() == 0)\n-            {\n+            \n+            if (!world.getBlockState(target).getMaterial().isReplaceable() \n+             && !(world.getBlockState(target).getBlock() instanceof LeavesBlock)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA0NjA4NQ=="}, "originalCommit": {"oid": "00e0d0a5cbbf363dfa41178b1d4c6fc0525f477e"}, "originalPosition": 181}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3OTUwMjM2OnYy", "diffSide": "RIGHT", "path": "src/api/java/com/minecolonies/api/blocks/decorative/AbstractBlockMinecoloniesConstructionTape.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwOTo1MTozNFrOGpa5Iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwOTo1MTozNFrOGpa5Iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA4NTQxMQ==", "bodyText": "just the formatting is off here yet.", "url": "https://github.com/ldtteam/minecolonies/pull/5298#discussion_r446085411", "createdAt": "2020-06-26T09:51:34Z", "author": {"login": "Raycoms"}, "path": "src/api/java/com/minecolonies/api/blocks/decorative/AbstractBlockMinecoloniesConstructionTape.java", "diffHunk": "@@ -1,107 +1,125 @@\n package com.minecolonies.api.blocks.decorative;\n \n import com.minecolonies.api.blocks.AbstractBlockMinecoloniesFalling;\n-import net.minecraft.block.HorizontalBlock;\n-import net.minecraft.block.material.MaterialColor;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n+import net.minecraft.block.*;\n+import net.minecraft.fluid.Fluids;\n+import net.minecraft.fluid.IFluidState;\n+import net.minecraft.state.BooleanProperty;\n import net.minecraft.state.DirectionProperty;\n-import net.minecraft.state.EnumProperty;\n-import net.minecraft.util.IStringSerializable;\n+import net.minecraft.state.properties.BlockStateProperties;\n+import net.minecraft.util.Direction;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.shapes.ISelectionContext;\n+import net.minecraft.util.math.shapes.VoxelShape;\n+import net.minecraft.util.math.shapes.VoxelShapes;\n+import net.minecraft.world.IBlockReader;\n import org.jetbrains.annotations.NotNull;\n \n-public abstract class AbstractBlockMinecoloniesConstructionTape<B extends AbstractBlockMinecoloniesConstructionTape<B>> extends AbstractBlockMinecoloniesFalling<B>\n+public abstract class AbstractBlockMinecoloniesConstructionTape<B extends AbstractBlockMinecoloniesConstructionTape<B>> extends AbstractBlockMinecoloniesFalling<B> implements IWaterLoggable\n {\n+    public static final BooleanProperty NORTH = SixWayBlock.NORTH;\n+    public static final BooleanProperty EAST = SixWayBlock.EAST;\n+    public static final BooleanProperty SOUTH = SixWayBlock.SOUTH;\n+    public static final BooleanProperty WEST = SixWayBlock.WEST;\n+    public static final BooleanProperty WATERLOGGED = BlockStateProperties.WATERLOGGED;\n+\n+    protected VoxelShape[] shapes = new VoxelShape[]{};\n+\n+    private final Object2IntMap<BlockState> stateShapeMap = new Object2IntOpenHashMap<>();\n+\n     /**\n-     * The variants of the shingle slab.\n+     * The default face for when there are no connections.\n      */\n-    public static final EnumProperty<ConstructionTapeType> VARIANT = EnumProperty.create(\"variant\", ConstructionTapeType.class);\n+    public static final DirectionProperty FACING = HorizontalBlock.HORIZONTAL_FACING;\n \n     /**\n-     * The position it faces.\n+     * Implies that the tape should revert to a corner if there are no connections. Must be set explicitly. For use by the builder handler.\n      */\n-    public static final DirectionProperty FACING = HorizontalBlock.HORIZONTAL_FACING;\n+    public static final BooleanProperty CORNER = BooleanProperty.create(\"corner\");\n \n     public AbstractBlockMinecoloniesConstructionTape(final Properties properties)\n     {\n         super(properties);\n     }\n \n-    /**\n-     * Types that the {@link AbstractBlockMinecoloniesConstructionTape} supports\n-     */\n-    public enum ConstructionTapeType implements IStringSerializable\n+    @NotNull\n+    @Override\n+    public VoxelShape getShape(BlockState state, IBlockReader worldIn, BlockPos pos, ISelectionContext context)\n     {\n-        STRAIGHT(0, \"straight\", MaterialColor.WOOD),\n-        CORNER(1, \"corner\", MaterialColor.OBSIDIAN);\n-\n-        private static final ConstructionTapeType[] META_LOOKUP = new ConstructionTapeType[values().length];\n-        static\n-        {\n-            for (final ConstructionTapeType enumtype : values())\n-            {\n-                META_LOOKUP[enumtype.getMetadata()] = enumtype;\n+        return this.shapes[this.getIndex(state)];\n+    }\n+\n+    private static int getMask(Direction facing) {\n+        return 1 << facing.getHorizontalIndex();\n+    }\n+\n+    protected int getIndex(BlockState state)\n+    {\n+        return this.stateShapeMap.computeIntIfAbsent(state, (p_223007_0_) -> {\n+            int i = 0;\n+            if (p_223007_0_.get(NORTH)) {\n+                i |= getMask(Direction.NORTH);\n             }\n-        }\n-        private final int           meta;\n-        private final String        name;\n-        private final String        unlocalizedName;\n-        /**\n-         * The color that represents this entry on a map.\n-         */\n-        private final MaterialColor mapColor;\n-\n-        ConstructionTapeType(final int metaIn, final String nameIn, final MaterialColor mapColorIn)\n-        {\n-            this(metaIn, nameIn, nameIn, mapColorIn);\n-        }\n \n-        ConstructionTapeType(final int metaIn, final String nameIn, final String unlocalizedNameIn, final MaterialColor mapColorIn)\n-        {\n-            this.meta = metaIn;\n-            this.name = nameIn;\n-            this.unlocalizedName = unlocalizedNameIn;\n-            this.mapColor = mapColorIn;\n-        }\n+            if (p_223007_0_.get(EAST)) {\n+                i |= getMask(Direction.EAST);\n+            }\n \n-        public static ConstructionTapeType byMetadata(final int meta)\n-        {\n-            int tempMeta = meta;\n-            if (tempMeta < 0 || tempMeta >= META_LOOKUP.length)\n-            {\n-                tempMeta = 0;\n+            if (p_223007_0_.get(SOUTH)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "798bcd6fd2560686d977f2630229e9b3b75c5240"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3OTUwMjc1OnYy", "diffSide": "RIGHT", "path": "src/api/java/com/minecolonies/api/blocks/decorative/AbstractBlockMinecoloniesConstructionTape.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwOTo1MTo0M1rOGpa5Ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwOTo1MTo0M1rOGpa5Ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA4NTQ2Nw==", "bodyText": "here too", "url": "https://github.com/ldtteam/minecolonies/pull/5298#discussion_r446085467", "createdAt": "2020-06-26T09:51:43Z", "author": {"login": "Raycoms"}, "path": "src/api/java/com/minecolonies/api/blocks/decorative/AbstractBlockMinecoloniesConstructionTape.java", "diffHunk": "@@ -1,107 +1,125 @@\n package com.minecolonies.api.blocks.decorative;\n \n import com.minecolonies.api.blocks.AbstractBlockMinecoloniesFalling;\n-import net.minecraft.block.HorizontalBlock;\n-import net.minecraft.block.material.MaterialColor;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n+import net.minecraft.block.*;\n+import net.minecraft.fluid.Fluids;\n+import net.minecraft.fluid.IFluidState;\n+import net.minecraft.state.BooleanProperty;\n import net.minecraft.state.DirectionProperty;\n-import net.minecraft.state.EnumProperty;\n-import net.minecraft.util.IStringSerializable;\n+import net.minecraft.state.properties.BlockStateProperties;\n+import net.minecraft.util.Direction;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.shapes.ISelectionContext;\n+import net.minecraft.util.math.shapes.VoxelShape;\n+import net.minecraft.util.math.shapes.VoxelShapes;\n+import net.minecraft.world.IBlockReader;\n import org.jetbrains.annotations.NotNull;\n \n-public abstract class AbstractBlockMinecoloniesConstructionTape<B extends AbstractBlockMinecoloniesConstructionTape<B>> extends AbstractBlockMinecoloniesFalling<B>\n+public abstract class AbstractBlockMinecoloniesConstructionTape<B extends AbstractBlockMinecoloniesConstructionTape<B>> extends AbstractBlockMinecoloniesFalling<B> implements IWaterLoggable\n {\n+    public static final BooleanProperty NORTH = SixWayBlock.NORTH;\n+    public static final BooleanProperty EAST = SixWayBlock.EAST;\n+    public static final BooleanProperty SOUTH = SixWayBlock.SOUTH;\n+    public static final BooleanProperty WEST = SixWayBlock.WEST;\n+    public static final BooleanProperty WATERLOGGED = BlockStateProperties.WATERLOGGED;\n+\n+    protected VoxelShape[] shapes = new VoxelShape[]{};\n+\n+    private final Object2IntMap<BlockState> stateShapeMap = new Object2IntOpenHashMap<>();\n+\n     /**\n-     * The variants of the shingle slab.\n+     * The default face for when there are no connections.\n      */\n-    public static final EnumProperty<ConstructionTapeType> VARIANT = EnumProperty.create(\"variant\", ConstructionTapeType.class);\n+    public static final DirectionProperty FACING = HorizontalBlock.HORIZONTAL_FACING;\n \n     /**\n-     * The position it faces.\n+     * Implies that the tape should revert to a corner if there are no connections. Must be set explicitly. For use by the builder handler.\n      */\n-    public static final DirectionProperty FACING = HorizontalBlock.HORIZONTAL_FACING;\n+    public static final BooleanProperty CORNER = BooleanProperty.create(\"corner\");\n \n     public AbstractBlockMinecoloniesConstructionTape(final Properties properties)\n     {\n         super(properties);\n     }\n \n-    /**\n-     * Types that the {@link AbstractBlockMinecoloniesConstructionTape} supports\n-     */\n-    public enum ConstructionTapeType implements IStringSerializable\n+    @NotNull\n+    @Override\n+    public VoxelShape getShape(BlockState state, IBlockReader worldIn, BlockPos pos, ISelectionContext context)\n     {\n-        STRAIGHT(0, \"straight\", MaterialColor.WOOD),\n-        CORNER(1, \"corner\", MaterialColor.OBSIDIAN);\n-\n-        private static final ConstructionTapeType[] META_LOOKUP = new ConstructionTapeType[values().length];\n-        static\n-        {\n-            for (final ConstructionTapeType enumtype : values())\n-            {\n-                META_LOOKUP[enumtype.getMetadata()] = enumtype;\n+        return this.shapes[this.getIndex(state)];\n+    }\n+\n+    private static int getMask(Direction facing) {\n+        return 1 << facing.getHorizontalIndex();\n+    }\n+\n+    protected int getIndex(BlockState state)\n+    {\n+        return this.stateShapeMap.computeIntIfAbsent(state, (p_223007_0_) -> {\n+            int i = 0;\n+            if (p_223007_0_.get(NORTH)) {\n+                i |= getMask(Direction.NORTH);\n             }\n-        }\n-        private final int           meta;\n-        private final String        name;\n-        private final String        unlocalizedName;\n-        /**\n-         * The color that represents this entry on a map.\n-         */\n-        private final MaterialColor mapColor;\n-\n-        ConstructionTapeType(final int metaIn, final String nameIn, final MaterialColor mapColorIn)\n-        {\n-            this(metaIn, nameIn, nameIn, mapColorIn);\n-        }\n \n-        ConstructionTapeType(final int metaIn, final String nameIn, final String unlocalizedNameIn, final MaterialColor mapColorIn)\n-        {\n-            this.meta = metaIn;\n-            this.name = nameIn;\n-            this.unlocalizedName = unlocalizedNameIn;\n-            this.mapColor = mapColorIn;\n-        }\n+            if (p_223007_0_.get(EAST)) {\n+                i |= getMask(Direction.EAST);\n+            }\n \n-        public static ConstructionTapeType byMetadata(final int meta)\n-        {\n-            int tempMeta = meta;\n-            if (tempMeta < 0 || tempMeta >= META_LOOKUP.length)\n-            {\n-                tempMeta = 0;\n+            if (p_223007_0_.get(SOUTH)) {\n+                i |= getMask(Direction.SOUTH);\n             }\n \n-            return META_LOOKUP[tempMeta];\n-        }\n+            if (p_223007_0_.get(WEST)) {\n+                i |= getMask(Direction.WEST);\n+            }\n \n-        public int getMetadata()\n-        {\n-            return this.meta;\n-        }\n+            return i;\n+        });\n+    }\n \n-        /**\n-         * The color which represents this entry on a map.\n-         * @return the material color.\n-         */\n-        public MaterialColor getMaterialColor()\n-        {\n-            return this.mapColor;\n-        }\n+    @NotNull\n+    @Override\n+    public IFluidState getFluidState(BlockState state)\n+    {\n+        return state.get(WATERLOGGED) ? Fluids.WATER.getStillFluidState(false) : super.getFluidState(state);\n+    }\n \n-        @Override\n-        public String toString()\n-        {\n-            return this.name;\n-        }\n+    protected VoxelShape[] makeShapes(float nodeWidth, float limbWidth, float nodeHeight, float limbBase, float limbTop)\n+    {\n+        float nodeStart = 8.0F - nodeWidth;\n+        float nodeEnd = 8.0F + nodeWidth;\n+        float limbStart = 8.0F - limbWidth;\n+        float limbEnd = 8.0F + limbWidth;\n \n-        @NotNull\n-        public String getName()\n-        {\n-            return this.name;\n-        }\n+        VoxelShape node  = Block.makeCuboidShape(nodeStart, 0.0F,     nodeStart, nodeEnd, nodeHeight, nodeEnd);\n+        VoxelShape north = Block.makeCuboidShape(limbStart, limbBase, 0.0F,      limbEnd, limbTop, limbEnd);\n+        VoxelShape south = Block.makeCuboidShape(limbStart, limbBase, limbStart, limbEnd, limbTop, 16.0D);\n+        VoxelShape west  = Block.makeCuboidShape(0.0F,      limbBase, limbStart, limbEnd, limbTop, limbEnd);\n+        VoxelShape east  = Block.makeCuboidShape(limbStart, limbBase, limbStart, 16.0D,   limbTop, limbEnd);\n+        VoxelShape cornernw = VoxelShapes.or(north, east);\n+        VoxelShape cornerse = VoxelShapes.or(south, west);\n+\n+        // All 16 possible block combinations, in a specific index to be retrieved by getIndex\n+        VoxelShape[] avoxelshape = new VoxelShape[]{\n+                VoxelShapes.empty(),    south,   west, cornerse, north,\n+                VoxelShapes.or(south,   north),\n+                VoxelShapes.or(west,    north),\n+                VoxelShapes.or(cornerse,north),  east,\n+                VoxelShapes.or(south,   east),\n+                VoxelShapes.or(west,    east),\n+                VoxelShapes.or(cornerse,east),   cornernw,\n+                VoxelShapes.or(south,   cornernw),\n+                VoxelShapes.or(west,    cornernw),\n+                VoxelShapes.or(cornerse,cornernw)\n+        };\n \n-        public String getTranslationKey()\n-        {\n-            return this.unlocalizedName;\n+        // Combine the arm voxel shapes with the main node for all combinations\n+        for(int i = 0; i < 16; ++i) {\n+            avoxelshape[i] = VoxelShapes.or(node, avoxelshape[i]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "798bcd6fd2560686d977f2630229e9b3b75c5240"}, "originalPosition": 195}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MjE5NTIyOnYy", "diffSide": "RIGHT", "path": "src/api/java/com/minecolonies/api/blocks/decorative/AbstractBlockMinecoloniesConstructionTape.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwODo1OTowNlrOGp0afg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwOTozNTowMFrOGp0lRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjUwMzU1MA==", "bodyText": "format", "url": "https://github.com/ldtteam/minecolonies/pull/5298#discussion_r446503550", "createdAt": "2020-06-27T08:59:06Z", "author": {"login": "Raycoms"}, "path": "src/api/java/com/minecolonies/api/blocks/decorative/AbstractBlockMinecoloniesConstructionTape.java", "diffHunk": "@@ -1,107 +1,121 @@\n package com.minecolonies.api.blocks.decorative;\n \n import com.minecolonies.api.blocks.AbstractBlockMinecoloniesFalling;\n-import net.minecraft.block.HorizontalBlock;\n-import net.minecraft.block.material.MaterialColor;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n+import net.minecraft.block.*;\n+import net.minecraft.fluid.Fluids;\n+import net.minecraft.fluid.IFluidState;\n+import net.minecraft.state.BooleanProperty;\n import net.minecraft.state.DirectionProperty;\n-import net.minecraft.state.EnumProperty;\n-import net.minecraft.util.IStringSerializable;\n+import net.minecraft.state.properties.BlockStateProperties;\n+import net.minecraft.util.Direction;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.shapes.ISelectionContext;\n+import net.minecraft.util.math.shapes.VoxelShape;\n+import net.minecraft.util.math.shapes.VoxelShapes;\n+import net.minecraft.world.IBlockReader;\n import org.jetbrains.annotations.NotNull;\n \n-public abstract class AbstractBlockMinecoloniesConstructionTape<B extends AbstractBlockMinecoloniesConstructionTape<B>> extends AbstractBlockMinecoloniesFalling<B>\n+public abstract class AbstractBlockMinecoloniesConstructionTape<B extends AbstractBlockMinecoloniesConstructionTape<B>> extends AbstractBlockMinecoloniesFalling<B> implements IWaterLoggable\n {\n+    public static final BooleanProperty NORTH = SixWayBlock.NORTH;\n+    public static final BooleanProperty EAST = SixWayBlock.EAST;\n+    public static final BooleanProperty SOUTH = SixWayBlock.SOUTH;\n+    public static final BooleanProperty WEST = SixWayBlock.WEST;\n+    public static final BooleanProperty WATERLOGGED = BlockStateProperties.WATERLOGGED;\n+\n+    protected VoxelShape[] shapes = new VoxelShape[]{};\n+\n+    private final Object2IntMap<BlockState> stateShapeMap = new Object2IntOpenHashMap<>();\n+\n     /**\n-     * The variants of the shingle slab.\n+     * The default face for when there are no connections.\n      */\n-    public static final EnumProperty<ConstructionTapeType> VARIANT = EnumProperty.create(\"variant\", ConstructionTapeType.class);\n+    public static final DirectionProperty FACING = HorizontalBlock.HORIZONTAL_FACING;\n \n     /**\n-     * The position it faces.\n+     * Implies that the tape should revert to a corner if there are no connections. Must be set explicitly. For use by the builder handler.\n      */\n-    public static final DirectionProperty FACING = HorizontalBlock.HORIZONTAL_FACING;\n+    public static final BooleanProperty CORNER = BooleanProperty.create(\"corner\");\n \n     public AbstractBlockMinecoloniesConstructionTape(final Properties properties)\n     {\n         super(properties);\n     }\n \n-    /**\n-     * Types that the {@link AbstractBlockMinecoloniesConstructionTape} supports\n-     */\n-    public enum ConstructionTapeType implements IStringSerializable\n+    @NotNull\n+    @Override\n+    public VoxelShape getShape(BlockState state, IBlockReader worldIn, BlockPos pos, ISelectionContext context)\n     {\n-        STRAIGHT(0, \"straight\", MaterialColor.WOOD),\n-        CORNER(1, \"corner\", MaterialColor.OBSIDIAN);\n+        return this.shapes[this.getIndex(state)];\n+    }\n \n-        private static final ConstructionTapeType[] META_LOOKUP = new ConstructionTapeType[values().length];\n-        static\n-        {\n-            for (final ConstructionTapeType enumtype : values())\n-            {\n-                META_LOOKUP[enumtype.getMetadata()] = enumtype;\n-            }\n-        }\n-        private final int           meta;\n-        private final String        name;\n-        private final String        unlocalizedName;\n-        /**\n-         * The color that represents this entry on a map.\n-         */\n-        private final MaterialColor mapColor;\n-\n-        ConstructionTapeType(final int metaIn, final String nameIn, final MaterialColor mapColorIn)\n-        {\n-            this(metaIn, nameIn, nameIn, mapColorIn);\n-        }\n+    private static int getMask(Direction facing) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1cec33b8da6111ec6b4786fbb9c3f9cc9cc9000"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjUwNjMwOA==", "bodyText": "I'll activate the IDE file formatter with the right settings now... although I don't know how I missed that many. I did try.", "url": "https://github.com/ldtteam/minecolonies/pull/5298#discussion_r446506308", "createdAt": "2020-06-27T09:35:00Z", "author": {"login": "ShadowProtocol"}, "path": "src/api/java/com/minecolonies/api/blocks/decorative/AbstractBlockMinecoloniesConstructionTape.java", "diffHunk": "@@ -1,107 +1,121 @@\n package com.minecolonies.api.blocks.decorative;\n \n import com.minecolonies.api.blocks.AbstractBlockMinecoloniesFalling;\n-import net.minecraft.block.HorizontalBlock;\n-import net.minecraft.block.material.MaterialColor;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n+import net.minecraft.block.*;\n+import net.minecraft.fluid.Fluids;\n+import net.minecraft.fluid.IFluidState;\n+import net.minecraft.state.BooleanProperty;\n import net.minecraft.state.DirectionProperty;\n-import net.minecraft.state.EnumProperty;\n-import net.minecraft.util.IStringSerializable;\n+import net.minecraft.state.properties.BlockStateProperties;\n+import net.minecraft.util.Direction;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.shapes.ISelectionContext;\n+import net.minecraft.util.math.shapes.VoxelShape;\n+import net.minecraft.util.math.shapes.VoxelShapes;\n+import net.minecraft.world.IBlockReader;\n import org.jetbrains.annotations.NotNull;\n \n-public abstract class AbstractBlockMinecoloniesConstructionTape<B extends AbstractBlockMinecoloniesConstructionTape<B>> extends AbstractBlockMinecoloniesFalling<B>\n+public abstract class AbstractBlockMinecoloniesConstructionTape<B extends AbstractBlockMinecoloniesConstructionTape<B>> extends AbstractBlockMinecoloniesFalling<B> implements IWaterLoggable\n {\n+    public static final BooleanProperty NORTH = SixWayBlock.NORTH;\n+    public static final BooleanProperty EAST = SixWayBlock.EAST;\n+    public static final BooleanProperty SOUTH = SixWayBlock.SOUTH;\n+    public static final BooleanProperty WEST = SixWayBlock.WEST;\n+    public static final BooleanProperty WATERLOGGED = BlockStateProperties.WATERLOGGED;\n+\n+    protected VoxelShape[] shapes = new VoxelShape[]{};\n+\n+    private final Object2IntMap<BlockState> stateShapeMap = new Object2IntOpenHashMap<>();\n+\n     /**\n-     * The variants of the shingle slab.\n+     * The default face for when there are no connections.\n      */\n-    public static final EnumProperty<ConstructionTapeType> VARIANT = EnumProperty.create(\"variant\", ConstructionTapeType.class);\n+    public static final DirectionProperty FACING = HorizontalBlock.HORIZONTAL_FACING;\n \n     /**\n-     * The position it faces.\n+     * Implies that the tape should revert to a corner if there are no connections. Must be set explicitly. For use by the builder handler.\n      */\n-    public static final DirectionProperty FACING = HorizontalBlock.HORIZONTAL_FACING;\n+    public static final BooleanProperty CORNER = BooleanProperty.create(\"corner\");\n \n     public AbstractBlockMinecoloniesConstructionTape(final Properties properties)\n     {\n         super(properties);\n     }\n \n-    /**\n-     * Types that the {@link AbstractBlockMinecoloniesConstructionTape} supports\n-     */\n-    public enum ConstructionTapeType implements IStringSerializable\n+    @NotNull\n+    @Override\n+    public VoxelShape getShape(BlockState state, IBlockReader worldIn, BlockPos pos, ISelectionContext context)\n     {\n-        STRAIGHT(0, \"straight\", MaterialColor.WOOD),\n-        CORNER(1, \"corner\", MaterialColor.OBSIDIAN);\n+        return this.shapes[this.getIndex(state)];\n+    }\n \n-        private static final ConstructionTapeType[] META_LOOKUP = new ConstructionTapeType[values().length];\n-        static\n-        {\n-            for (final ConstructionTapeType enumtype : values())\n-            {\n-                META_LOOKUP[enumtype.getMetadata()] = enumtype;\n-            }\n-        }\n-        private final int           meta;\n-        private final String        name;\n-        private final String        unlocalizedName;\n-        /**\n-         * The color that represents this entry on a map.\n-         */\n-        private final MaterialColor mapColor;\n-\n-        ConstructionTapeType(final int metaIn, final String nameIn, final MaterialColor mapColorIn)\n-        {\n-            this(metaIn, nameIn, nameIn, mapColorIn);\n-        }\n+    private static int getMask(Direction facing) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjUwMzU1MA=="}, "originalCommit": {"oid": "b1cec33b8da6111ec6b4786fbb9c3f9cc9cc9000"}, "originalPosition": 89}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3632, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}