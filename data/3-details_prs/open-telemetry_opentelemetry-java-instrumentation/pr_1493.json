{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEwNTMzNjQ0", "number": 1493, "title": "Replace ContextStore for context bridge with a custom context storage\u2026", "bodyText": "\u2026 provider. And handles \"span always operates on agent context\" logic in the storage layer.\nFixes #976", "createdAt": "2020-10-27T07:14:38Z", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1493", "merged": true, "mergeCommit": {"oid": "fd03a4b1e17acb6c5ad2778855d37af86e6a744a"}, "closed": true, "closedAt": "2020-10-29T06:42:51Z", "author": {"login": "anuraaga"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdWjj_7AH2gAyNTEwNTMzNjQ0OjcwNWFiYTYwNzc3OGY3N2RhODljYTBiNmZjOWQwNzk2ODQzYWNhNDI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdXMJn-AH2gAyNTEwNTMzNjQ0OmE2MmYzZWI4NjZkMThiOGJmYWM2NzFiZGI5MjRlNmI3Y2RjMTdjZTA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "705aba607778f77da89ca0b6fc9d0796843aca42", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/705aba607778f77da89ca0b6fc9d0796843aca42", "committedDate": "2020-10-27T07:09:34Z", "message": "Replace ContextStore for context bridge with a custom context storage provider."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b461995ae06e6965f83b6a511bf4c1d1e7f6840", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/1b461995ae06e6965f83b6a511bf4c1d1e7f6840", "committedDate": "2020-10-27T08:21:23Z", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-auto-instr-java into contextstorage-override"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e90fbd5f3739717f4f4b7a279a8b0da2de9d9483", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/e90fbd5f3739717f4f4b7a279a8b0da2de9d9483", "committedDate": "2020-10-28T02:41:40Z", "message": "Handle context mapping at storage layer."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2070bdf0044ae4f844f8c9f0eaf0f1ee1eb4a3cb", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/2070bdf0044ae4f844f8c9f0eaf0f1ee1eb4a3cb", "committedDate": "2020-10-28T02:41:46Z", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-auto-instr-java into contextstorage-override"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "60644edbe70da71eaea0ac32bd1c46711a2b1ea7", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/60644edbe70da71eaea0ac32bd1c46711a2b1ea7", "committedDate": "2020-10-28T04:22:05Z", "message": "Cleanup"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4MzE0NzI1", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1493#pullrequestreview-518314725", "createdAt": "2020-10-28T04:24:50Z", "commit": {"oid": "60644edbe70da71eaea0ac32bd1c46711a2b1ea7"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwNDoyNDo1MFrOHpZkgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwNDoyNToxMVrOHpZk5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE3MjYxMQ==", "bodyText": "We used to instrument all the methods of the package-private class TracingContextUtils, now we do still end up with one instrumentation of DefaultContext along with the reflective access to the context key.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1493#discussion_r513172611", "createdAt": "2020-10-28T04:24:50Z", "author": {"login": "anuraaga"}, "path": "instrumentation/opentelemetry-api-beta/src/main/java/io/opentelemetry/javaagent/instrumentation/opentelemetryapi/ContextInstrumentation.java", "diffHunk": "@@ -6,65 +6,48 @@\n package io.opentelemetry.javaagent.instrumentation.opentelemetryapi;\n \n import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n-import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n import static net.bytebuddy.matcher.ElementMatchers.isStatic;\n import static net.bytebuddy.matcher.ElementMatchers.named;\n-import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n \n import application.io.opentelemetry.context.Context;\n-import application.io.opentelemetry.context.Scope;\n+import application.io.opentelemetry.context.ContextStorage;\n import com.google.auto.service.AutoService;\n-import io.opentelemetry.javaagent.instrumentation.api.ContextStore;\n-import io.opentelemetry.javaagent.instrumentation.api.InstrumentationContext;\n+import io.opentelemetry.javaagent.instrumentation.opentelemetryapi.context.AgentContextStorage;\n import io.opentelemetry.javaagent.tooling.Instrumenter;\n-import java.util.HashMap;\n+import java.util.Collections;\n import java.util.Map;\n import net.bytebuddy.asm.Advice;\n import net.bytebuddy.description.method.MethodDescription;\n import net.bytebuddy.description.type.TypeDescription;\n import net.bytebuddy.matcher.ElementMatcher;\n \n+/**\n+ * Returns {@link AgentContextStorage} as the implementation of {@link ContextStorage} in the\n+ * application classpath. We do this instead of using the normal service loader mechanism to make\n+ * sure there is no dependency on a system property or possibility of a user overriding this since\n+ * it's required for instrumentation in the agent to work properly.\n+ */\n @AutoService(Instrumenter.class)\n public class ContextInstrumentation extends AbstractInstrumentation {\n \n   @Override\n   public ElementMatcher<? super TypeDescription> typeMatcher() {\n-    return named(\"application.io.opentelemetry.context.Context\");\n+    return named(\"application.io.opentelemetry.context.DefaultContext\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60644edbe70da71eaea0ac32bd1c46711a2b1ea7"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE3MjcxMQ==", "bodyText": "Since an agent can take over apps, I'm assuming this is allowed? Not sure", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1493#discussion_r513172711", "createdAt": "2020-10-28T04:25:11Z", "author": {"login": "anuraaga"}, "path": "instrumentation/opentelemetry-api-beta/src/main/java/io/opentelemetry/javaagent/instrumentation/opentelemetryapi/context/AgentContextStorage.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.opentelemetryapi.context;\n+\n+import application.io.opentelemetry.context.Context;\n+import application.io.opentelemetry.context.ContextKey;\n+import application.io.opentelemetry.context.ContextStorage;\n+import application.io.opentelemetry.context.Scope;\n+import application.io.opentelemetry.trace.Span;\n+import io.opentelemetry.javaagent.instrumentation.opentelemetryapi.trace.Bridging;\n+import java.lang.reflect.Field;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link ContextStorage} which stores the {@link Context} in the user's application inside the\n+ * {@link Context} in the agent. This allows for context interaction to be maintained between the\n+ * app and agent.\n+ *\n+ * <p>This storage allows for implicit parenting of context to exist between the agent and\n+ * application by storing the concrete application context in the agent context and returning a\n+ * wrapper which accesses into this stored concrete context.\n+ *\n+ * <p>This storage also makes sure that OpenTelemetry objects are shared within the context. To do\n+ * this, it recognizes the keys for OpenTelemetry objects (e.g, {@link Span}, Baggage (WIP)) and\n+ * always stores and retrieves them from the agent context, even when accessed from the application.\n+ * All other accesses are to the concrete application context.\n+ */\n+public class AgentContextStorage implements ContextStorage {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(AgentContextStorage.class);\n+\n+  public static final AgentContextStorage INSTANCE = new AgentContextStorage();\n+\n+  public static io.opentelemetry.context.Context getAgentContext(Context applicationContext) {\n+    if (applicationContext instanceof AgentContextWrapper) {\n+      return ((AgentContextWrapper) applicationContext).toAgentContext();\n+    }\n+    if (logger.isDebugEnabled()) {\n+      logger.debug(\n+          \"unexpected context: {}\", applicationContext, new Exception(\"unexpected context\"));\n+    }\n+    return io.opentelemetry.context.Context.root();\n+  }\n+\n+  static final io.opentelemetry.context.ContextKey<Context> APPLICATION_CONTEXT =\n+      io.opentelemetry.context.ContextKey.named(\"otel-context\");\n+\n+  static final io.opentelemetry.context.ContextKey<io.opentelemetry.trace.Span>\n+      AGENT_SPAN_CONTEXT_KEY;\n+  static final ContextKey<Span> APPLICATION_SPAN_CONTEXT_KEY;\n+\n+  static {\n+    io.opentelemetry.context.ContextKey<io.opentelemetry.trace.Span> agentSpanContextKey;\n+    try {\n+      Class<?> tracingContextUtils = Class.forName(\"io.opentelemetry.trace.TracingContextUtils\");\n+      Field contextSpanKeyField = tracingContextUtils.getDeclaredField(\"CONTEXT_SPAN_KEY\");\n+      contextSpanKeyField.setAccessible(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60644edbe70da71eaea0ac32bd1c46711a2b1ea7"}, "originalPosition": 61}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2e63f4ae73cd03ddba5de2459f020f7471d7fd6", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/a2e63f4ae73cd03ddba5de2459f020f7471d7fd6", "committedDate": "2020-10-29T03:37:20Z", "message": "Add interop test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee5c35eef7c745c79e98bc28e475f8ecdaef0355", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/ee5c35eef7c745c79e98bc28e475f8ecdaef0355", "committedDate": "2020-10-29T03:39:42Z", "message": "Small comment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5MzMyNjAy", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1493#pullrequestreview-519332602", "createdAt": "2020-10-29T04:56:53Z", "commit": {"oid": "ee5c35eef7c745c79e98bc28e475f8ecdaef0355"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQwNDo1Njo1M1rOHqKNrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQwNToxNTo1NFrOHqKwjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzk2OTU4Mg==", "bodyText": "let's figure this out later \ud83d\ude04 created #1520 and referenced this comment to track", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1493#discussion_r513969582", "createdAt": "2020-10-29T04:56:53Z", "author": {"login": "trask"}, "path": "instrumentation/opentelemetry-api-beta/src/main/java/io/opentelemetry/javaagent/instrumentation/opentelemetryapi/context/AgentContextStorage.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.opentelemetryapi.context;\n+\n+import application.io.opentelemetry.context.Context;\n+import application.io.opentelemetry.context.ContextKey;\n+import application.io.opentelemetry.context.ContextStorage;\n+import application.io.opentelemetry.context.Scope;\n+import application.io.opentelemetry.trace.Span;\n+import io.opentelemetry.javaagent.instrumentation.opentelemetryapi.trace.Bridging;\n+import java.lang.reflect.Field;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link ContextStorage} which stores the {@link Context} in the user's application inside the\n+ * {@link Context} in the agent. This allows for context interaction to be maintained between the\n+ * app and agent.\n+ *\n+ * <p>This storage allows for implicit parenting of context to exist between the agent and\n+ * application by storing the concrete application context in the agent context and returning a\n+ * wrapper which accesses into this stored concrete context.\n+ *\n+ * <p>This storage also makes sure that OpenTelemetry objects are shared within the context. To do\n+ * this, it recognizes the keys for OpenTelemetry objects (e.g, {@link Span}, Baggage (WIP)) and\n+ * always stores and retrieves them from the agent context, even when accessed from the application.\n+ * All other accesses are to the concrete application context.\n+ */\n+public class AgentContextStorage implements ContextStorage {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(AgentContextStorage.class);\n+\n+  public static final AgentContextStorage INSTANCE = new AgentContextStorage();\n+\n+  public static io.opentelemetry.context.Context getAgentContext(Context applicationContext) {\n+    if (applicationContext instanceof AgentContextWrapper) {\n+      return ((AgentContextWrapper) applicationContext).toAgentContext();\n+    }\n+    if (logger.isDebugEnabled()) {\n+      logger.debug(\n+          \"unexpected context: {}\", applicationContext, new Exception(\"unexpected context\"));\n+    }\n+    return io.opentelemetry.context.Context.root();\n+  }\n+\n+  static final io.opentelemetry.context.ContextKey<Context> APPLICATION_CONTEXT =\n+      io.opentelemetry.context.ContextKey.named(\"otel-context\");\n+\n+  static final io.opentelemetry.context.ContextKey<io.opentelemetry.trace.Span>\n+      AGENT_SPAN_CONTEXT_KEY;\n+  static final ContextKey<Span> APPLICATION_SPAN_CONTEXT_KEY;\n+\n+  static {\n+    io.opentelemetry.context.ContextKey<io.opentelemetry.trace.Span> agentSpanContextKey;\n+    try {\n+      Class<?> tracingContextUtils = Class.forName(\"io.opentelemetry.trace.TracingContextUtils\");\n+      Field contextSpanKeyField = tracingContextUtils.getDeclaredField(\"CONTEXT_SPAN_KEY\");\n+      contextSpanKeyField.setAccessible(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE3MjcxMQ=="}, "originalCommit": {"oid": "60644edbe70da71eaea0ac32bd1c46711a2b1ea7"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzk3NDQ2Mg==", "bodyText": "does this test show interop, or just side-by-side, since everything is in the same thread?\nwould it be better to Context.root().makeCurrent().withCloseable {} (for both agent and non-agent) around each existing makeCurrent().withCloseable {} (except for the first) below?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1493#discussion_r513974462", "createdAt": "2020-10-29T05:07:32Z", "author": {"login": "trask"}, "path": "instrumentation/opentelemetry-api-beta/src/test/groovy/ContextBridgeTest.groovy", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import application.io.opentelemetry.OpenTelemetry\n+import application.io.opentelemetry.context.Context\n+import application.io.opentelemetry.context.ContextKey\n+import application.io.opentelemetry.trace.Span\n+import io.opentelemetry.instrumentation.test.AgentTestRunner\n+import java.util.concurrent.ExecutorService\n+import java.util.concurrent.Executors\n+import java.util.concurrent.atomic.AtomicReference\n+import spock.lang.Shared\n+\n+class ContextBridgeTest extends AgentTestRunner {\n+\n+  private static final ContextKey<String> ANIMAL = ContextKey.named(\"animal\")\n+\n+  private static final io.opentelemetry.context.ContextKey<String> FOOD =\n+    io.opentelemetry.context.ContextKey.named(\"food\")\n+  private static final io.opentelemetry.context.ContextKey<String> COUNTRY =\n+    io.opentelemetry.context.ContextKey.named(\"country\")\n+\n+  @Shared\n+  ExecutorService otherThread\n+\n+  def setupSpec() {\n+    otherThread = Executors.newSingleThreadExecutor()\n+  }\n+\n+  def cleanupSpec() {\n+    otherThread.shutdown()\n+  }\n+\n+  def \"agent and application mix\"() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee5c35eef7c745c79e98bc28e475f8ecdaef0355"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzk3ODUxMQ==", "bodyText": "these tests run with our java-concurrent, so I think that will auto-propagate agentContext(?) which makes it hard to reason about this test\nmaybe cleaner to do the Context.root().makeCurrent().withScoped {} on both, then call context.wrap(runnable).run() inside of that, and not mess with threads?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1493#discussion_r513978511", "createdAt": "2020-10-29T05:15:54Z", "author": {"login": "trask"}, "path": "instrumentation/opentelemetry-api-beta/src/test/groovy/ContextBridgeTest.groovy", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import application.io.opentelemetry.OpenTelemetry\n+import application.io.opentelemetry.context.Context\n+import application.io.opentelemetry.context.ContextKey\n+import application.io.opentelemetry.trace.Span\n+import io.opentelemetry.instrumentation.test.AgentTestRunner\n+import java.util.concurrent.ExecutorService\n+import java.util.concurrent.Executors\n+import java.util.concurrent.atomic.AtomicReference\n+import spock.lang.Shared\n+\n+class ContextBridgeTest extends AgentTestRunner {\n+\n+  private static final ContextKey<String> ANIMAL = ContextKey.named(\"animal\")\n+\n+  private static final io.opentelemetry.context.ContextKey<String> FOOD =\n+    io.opentelemetry.context.ContextKey.named(\"food\")\n+  private static final io.opentelemetry.context.ContextKey<String> COUNTRY =\n+    io.opentelemetry.context.ContextKey.named(\"country\")\n+\n+  @Shared\n+  ExecutorService otherThread\n+\n+  def setupSpec() {\n+    otherThread = Executors.newSingleThreadExecutor()\n+  }\n+\n+  def cleanupSpec() {\n+    otherThread.shutdown()\n+  }\n+\n+  def \"agent and application mix\"() {\n+    expect:\n+    def agentContext = io.opentelemetry.context.Context.current().with(COUNTRY, \"japan\")\n+    io.opentelemetry.context.Context.current().get(COUNTRY) == null\n+    agentContext.makeCurrent().withCloseable {\n+      io.opentelemetry.context.Context.current().get(COUNTRY) == \"japan\"\n+      Context.current().with(ANIMAL, \"cat\").makeCurrent().withCloseable {\n+        Context.current().get(ANIMAL) == \"cat\"\n+        io.opentelemetry.context.Context.current().get(COUNTRY) == \"japan\"\n+\n+        def agentContext2 = io.opentelemetry.context.Context.current().with(FOOD, \"cheese\")\n+        io.opentelemetry.context.Context.current().get(FOOD) == null\n+        agentContext2.makeCurrent().withCloseable {\n+          io.opentelemetry.context.Context.current().get(FOOD) == \"cheese\"\n+          io.opentelemetry.context.Context.current().get(COUNTRY) == \"japan\"\n+          Context.current().get(ANIMAL) == \"cat\"\n+        }\n+      }\n+    }\n+  }\n+\n+  // The difference between \"standard\" context interop and our bridge is that with normal interop,\n+  // keys are still isolated completely. We have special logic to share the same data for our known\n+  // types like span.\n+  def \"agent and application share span\"() {\n+    when:\n+    def applicationTracer = OpenTelemetry.getGlobalTracer(\"test\")\n+    def agentTracer = io.opentelemetry.OpenTelemetry.getGlobalTracer(\"test\")\n+\n+    then:\n+    !Span.current().spanContext.isValid()\n+    !io.opentelemetry.trace.Span.current().spanContext.isValid()\n+\n+    def applicationSpan = applicationTracer.spanBuilder(\"test1\").startSpan()\n+    applicationSpan.spanContext.isValid()\n+    applicationSpan.makeCurrent().withCloseable {\n+      Span.current().spanContext.spanIdAsHexString == applicationSpan.spanContext.spanIdAsHexString\n+      io.opentelemetry.trace.Span.current().spanContext.spanIdAsHexString == applicationSpan.spanContext.spanIdAsHexString\n+\n+      def agentSpan = agentTracer.spanBuilder(\"test2\").startSpan()\n+      agentSpan.makeCurrent().withCloseable {\n+        Span.current().spanContext.spanIdAsHexString == agentSpan.spanContext.spanIdAsHexString\n+        Span.current().spanContext.traceIdAsHexString == agentSpan.spanContext.spanIdAsHexString\n+        Span.current().spanContext.traceIdAsHexString == applicationSpan.spanContext.spanIdAsHexString\n+        io.opentelemetry.trace.Span.current().spanContext.spanIdAsHexString == agentSpan.spanContext.spanIdAsHexString\n+        io.opentelemetry.trace.Span.current().spanContext.traceIdAsHexString == agentSpan.spanContext.traceIdAsHexString\n+        io.opentelemetry.trace.Span.current().spanContext.traceIdAsHexString == applicationSpan.spanContext.traceIdAsHexString\n+\n+        def applicationSpan2 = applicationTracer.spanBuilder(\"test3\").startSpan()\n+        applicationSpan2.makeCurrent().withCloseable {\n+          Span.current().spanContext.spanIdAsHexString == applicationSpan2.spanContext.spanIdAsHexString\n+          Span.current().spanContext.traceIdAsHexString == applicationSpan2.spanContext.spanIdAsHexString\n+          Span.current().spanContext.traceIdAsHexString == applicationSpan.spanContext.spanIdAsHexString\n+          io.opentelemetry.trace.Span.current().spanContext.spanIdAsHexString == applicationSpan2.spanContext.spanIdAsHexString\n+          io.opentelemetry.trace.Span.current().spanContext.traceIdAsHexString == applicationSpan2.spanContext.traceIdAsHexString\n+          io.opentelemetry.trace.Span.current().spanContext.traceIdAsHexString == applicationSpan.spanContext.traceIdAsHexString\n+        }\n+      }\n+    }\n+  }\n+\n+  def \"agent wraps\"() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee5c35eef7c745c79e98bc28e475f8ecdaef0355"}, "originalPosition": 97}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5MzUyNzc2", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1493#pullrequestreview-519352776", "createdAt": "2020-10-29T06:01:34Z", "commit": {"oid": "ee5c35eef7c745c79e98bc28e475f8ecdaef0355"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "11b115bee094dcccc172505f6c871a2a1de5ab60", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/11b115bee094dcccc172505f6c871a2a1de5ab60", "committedDate": "2020-10-29T06:19:29Z", "message": "No threads"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a62f3eb866d18b8bfac671bdb924e6b7cdc17ce0", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/a62f3eb866d18b8bfac671bdb924e6b7cdc17ce0", "committedDate": "2020-10-29T06:26:52Z", "message": "Groovy"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2409, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}