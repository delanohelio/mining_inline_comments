{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzczODAzODM4", "number": 155, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoxMDozMlrODe6F4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoxMDozMlrODe6F4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzM1NjQ4OnYy", "diffSide": "RIGHT", "path": "instrumentation/reactor-core-3.1/src/main/java8/io/opentelemetry/auto/instrumentation/reactor/core/FluxAndMonoSubscribeAdvice.java", "isResolved": false, "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoxMDozMlrOFoTjqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMDo1ODoyOVrOFoY1mQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgwNzc4Ng==", "bodyText": "when do you end up with null here? Should we have a no-op version of the class for those cases?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/155#discussion_r377807786", "createdAt": "2020-02-11T18:10:32Z", "author": {"login": "jkwatson"}, "path": "instrumentation/reactor-core-3.1/src/main/java8/io/opentelemetry/auto/instrumentation/reactor/core/FluxAndMonoSubscribeAdvice.java", "diffHunk": "@@ -33,11 +33,12 @@ public static SpanWithScope methodEnter(\n   @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n   public static void methodExit(\n       @Advice.Enter final SpanWithScope spanWithScope, @Advice.Thrown final Throwable throwable) {\n+    if (spanWithScope == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8113e0f7bd835fd75eb398250cc400726c3608a6"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgwOTE5Nw==", "bodyText": "when the Advice.OnMethodEnter method above returns null", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/155#discussion_r377809197", "createdAt": "2020-02-11T18:13:24Z", "author": {"login": "trask"}, "path": "instrumentation/reactor-core-3.1/src/main/java8/io/opentelemetry/auto/instrumentation/reactor/core/FluxAndMonoSubscribeAdvice.java", "diffHunk": "@@ -33,11 +33,12 @@ public static SpanWithScope methodEnter(\n   @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n   public static void methodExit(\n       @Advice.Enter final SpanWithScope spanWithScope, @Advice.Thrown final Throwable throwable) {\n+    if (spanWithScope == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgwNzc4Ng=="}, "originalCommit": {"oid": "8113e0f7bd835fd75eb398250cc400726c3608a6"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxMTE1NQ==", "bodyText": "maybe that should return a no-op version, rather than null?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/155#discussion_r377811155", "createdAt": "2020-02-11T18:17:15Z", "author": {"login": "jkwatson"}, "path": "instrumentation/reactor-core-3.1/src/main/java8/io/opentelemetry/auto/instrumentation/reactor/core/FluxAndMonoSubscribeAdvice.java", "diffHunk": "@@ -33,11 +33,12 @@ public static SpanWithScope methodEnter(\n   @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n   public static void methodExit(\n       @Advice.Enter final SpanWithScope spanWithScope, @Advice.Thrown final Throwable throwable) {\n+    if (spanWithScope == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgwNzc4Ng=="}, "originalCommit": {"oid": "8113e0f7bd835fd75eb398250cc400726c3608a6"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxMzA0OA==", "bodyText": "this is the pattern used throughout the code, so that's a bigger discussion, also less efficient because then we end up calling setAttribute a bunch of times on no-op Spans unnecessarily", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/155#discussion_r377813048", "createdAt": "2020-02-11T18:20:49Z", "author": {"login": "trask"}, "path": "instrumentation/reactor-core-3.1/src/main/java8/io/opentelemetry/auto/instrumentation/reactor/core/FluxAndMonoSubscribeAdvice.java", "diffHunk": "@@ -33,11 +33,12 @@ public static SpanWithScope methodEnter(\n   @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n   public static void methodExit(\n       @Advice.Enter final SpanWithScope spanWithScope, @Advice.Thrown final Throwable throwable) {\n+    if (spanWithScope == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgwNzc4Ng=="}, "originalCommit": {"oid": "8113e0f7bd835fd75eb398250cc400726c3608a6"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxMzU3OA==", "bodyText": "maybe this discussion can be part of auto/lib instrumentation convergence", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/155#discussion_r377813578", "createdAt": "2020-02-11T18:21:53Z", "author": {"login": "trask"}, "path": "instrumentation/reactor-core-3.1/src/main/java8/io/opentelemetry/auto/instrumentation/reactor/core/FluxAndMonoSubscribeAdvice.java", "diffHunk": "@@ -33,11 +33,12 @@ public static SpanWithScope methodEnter(\n   @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n   public static void methodExit(\n       @Advice.Enter final SpanWithScope spanWithScope, @Advice.Thrown final Throwable throwable) {\n+    if (spanWithScope == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgwNzc4Ng=="}, "originalCommit": {"oid": "8113e0f7bd835fd75eb398250cc400726c3608a6"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxOTg2Mg==", "bodyText": "oh, i forgot, even in auto/lib convergence, this pattern of passing across SpanWithScope will only exist in auto instrumentation, so this discussion doesn't apply to auto/lib instrumentation convergence, and this will stay internal API only (so i think ok to continue using null?)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/155#discussion_r377819862", "createdAt": "2020-02-11T18:33:27Z", "author": {"login": "trask"}, "path": "instrumentation/reactor-core-3.1/src/main/java8/io/opentelemetry/auto/instrumentation/reactor/core/FluxAndMonoSubscribeAdvice.java", "diffHunk": "@@ -33,11 +33,12 @@ public static SpanWithScope methodEnter(\n   @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n   public static void methodExit(\n       @Advice.Enter final SpanWithScope spanWithScope, @Advice.Thrown final Throwable throwable) {\n+    if (spanWithScope == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgwNzc4Ng=="}, "originalCommit": {"oid": "8113e0f7bd835fd75eb398250cc400726c3608a6"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgyMzEyMw==", "bodyText": "Just my opinion, which you are free to ignore, but using null as the contract between these methods seems like a dangerous anti-pattern, because (as you see in this very PR), it's easy to forget to check for nulls. I'm not often a fan of the null object pattern, but this sure seems like a good case for it. no-op methods are very fast and will get inlined quickly by the JIT if they get called much.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/155#discussion_r377823123", "createdAt": "2020-02-11T18:39:32Z", "author": {"login": "jkwatson"}, "path": "instrumentation/reactor-core-3.1/src/main/java8/io/opentelemetry/auto/instrumentation/reactor/core/FluxAndMonoSubscribeAdvice.java", "diffHunk": "@@ -33,11 +33,12 @@ public static SpanWithScope methodEnter(\n   @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n   public static void methodExit(\n       @Advice.Enter final SpanWithScope spanWithScope, @Advice.Thrown final Throwable throwable) {\n+    if (spanWithScope == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgwNzc4Ng=="}, "originalCommit": {"oid": "8113e0f7bd835fd75eb398250cc400726c3608a6"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgyNTMyNw==", "bodyText": "the calling of no-op methods will get inlined, but not the calculations of the attribute values, which can be expensive (e.g. calling Throwable.printStackTrace())", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/155#discussion_r377825327", "createdAt": "2020-02-11T18:43:38Z", "author": {"login": "trask"}, "path": "instrumentation/reactor-core-3.1/src/main/java8/io/opentelemetry/auto/instrumentation/reactor/core/FluxAndMonoSubscribeAdvice.java", "diffHunk": "@@ -33,11 +33,12 @@ public static SpanWithScope methodEnter(\n   @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n   public static void methodExit(\n       @Advice.Enter final SpanWithScope spanWithScope, @Advice.Thrown final Throwable throwable) {\n+    if (spanWithScope == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgwNzc4Ng=="}, "originalCommit": {"oid": "8113e0f7bd835fd75eb398250cc400726c3608a6"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgyNjM3MA==", "bodyText": "If finishSpanIfPresent checked for span.isInvalid() then that call could also be avoided.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/155#discussion_r377826370", "createdAt": "2020-02-11T18:45:26Z", "author": {"login": "jkwatson"}, "path": "instrumentation/reactor-core-3.1/src/main/java8/io/opentelemetry/auto/instrumentation/reactor/core/FluxAndMonoSubscribeAdvice.java", "diffHunk": "@@ -33,11 +33,12 @@ public static SpanWithScope methodEnter(\n   @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n   public static void methodExit(\n       @Advice.Enter final SpanWithScope spanWithScope, @Advice.Thrown final Throwable throwable) {\n+    if (spanWithScope == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgwNzc4Ng=="}, "originalCommit": {"oid": "8113e0f7bd835fd75eb398250cc400726c3608a6"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg5NDI5Nw==", "bodyText": "this pattern (passing null from OnMethodEnter to OnMethodExit) is used throughout the existing codebase, so i think better for this PR to stay consistent, and if we want to change the pattern then that belongs to a different PR where we can look at the change in the context of the full codebase", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/155#discussion_r377894297", "createdAt": "2020-02-11T20:58:29Z", "author": {"login": "trask"}, "path": "instrumentation/reactor-core-3.1/src/main/java8/io/opentelemetry/auto/instrumentation/reactor/core/FluxAndMonoSubscribeAdvice.java", "diffHunk": "@@ -33,11 +33,12 @@ public static SpanWithScope methodEnter(\n   @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n   public static void methodExit(\n       @Advice.Enter final SpanWithScope spanWithScope, @Advice.Thrown final Throwable throwable) {\n+    if (spanWithScope == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgwNzc4Ng=="}, "originalCommit": {"oid": "8113e0f7bd835fd75eb398250cc400726c3608a6"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 565, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}