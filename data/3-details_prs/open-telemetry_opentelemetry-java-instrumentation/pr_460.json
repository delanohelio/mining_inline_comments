{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI1NTY2OTQx", "number": 460, "title": "Move client span creation to decorator and automatically suppress creation of neste\u2026", "bodyText": "\u2026d client spans.\nThis is a PoC for #440. It is common for a client request, such as an RPC, to be composed of multiple parts that are all instrumented, such as the AWS SDK using Apache HTTP client. Currently, we mark the RPC span as internal and the transport span as client, but that breaks features like service graphs which are built around the concept of server/client spans being services, not transport.\nHere, I keep track of client spans and make sure another one is not created as the child of a client span. This check would have been trivial if Span presented an accessor for its kind, if this idea seems sane maybe we can ask about that. In the meantime, a weak map works.\nCurrently I'm suppressing the span but I also considered returning a wrapping Span which delegates everything except for end. This would allow transports to add information to the client span, for example events for sending / receiving data from the wire. It could happen in the future though since it's just enriching the data, not changing the modeling. It seems even more important if applying this similarly to server-side as it will be common for the \"nested span\" to have the RPC and similar important information.\nNote, as the tests show, we lose the feature of modeling retries as spans for the AWS SDK. This seems OK to me, the current code actually doesn't even propagate these spans, the only span that is propagated is the SDK span (found this out while writing this code, propagating an INTERNAL span seems like it goes against the rules of tracing!). I have filed an issue a while ago about the SDK allowing header mutation per retry and it's probably better to wait for that and mark retries as events in the meantime (not implemented yet will do so if this approach is ok to proceed with).\nLet me know if this approach seems reasonable at all!", "createdAt": "2020-05-31T06:06:44Z", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460", "merged": true, "mergeCommit": {"oid": "f13a9c49321539d49583b4c952145d1f65719a0f"}, "closed": true, "closedAt": "2020-06-08T19:01:44Z", "author": {"login": "anuraaga"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcmlSiCAH2gAyNDI1NTY2OTQxOjlkYjk5MjdiZDI3NjRkMTI3YzhhMmFlM2E4YjQyYmE1NmQyMTZhZWI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcpUvTogH2gAyNDI1NTY2OTQxOjBlMThlMDg3MzExYmQyMDM0NjQzYmJjZjIyNTI4ODU0YTVlNjY5NDQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "9db9927bd2764d127c8a2ae3a8b42ba56d216aeb", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/9db9927bd2764d127c8a2ae3a8b42ba56d216aeb", "committedDate": "2020-05-31T06:01:56Z", "message": "Move client span creation to decorator and suppress creation of nested client spans."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c2ee0436f8185534bdb6b17b7b611f540c99d19c", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/c2ee0436f8185534bdb6b17b7b611f540c99d19c", "committedDate": "2020-05-31T06:09:08Z", "message": "Retry TODO"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/d57444707cad6ea1aa1d0370d03e5654784b7ced", "committedDate": "2020-06-02T08:10:20Z", "message": "Store subtree client span in context."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNDQxMDgx", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#pullrequestreview-422441081", "createdAt": "2020-06-02T08:11:43Z", "commit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNDQyMTE1", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#pullrequestreview-422442115", "createdAt": "2020-06-02T08:13:08Z", "commit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwODoxMzowOFrOGdm2Ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwODoxMzowOFrOGdm2Ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY5ODMyMw==", "bodyText": "Ah noticed this is fixed in master of the SDK :)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r433698323", "createdAt": "2020-06-02T08:13:08Z", "author": {"login": "anuraaga"}, "path": "instrumentation/apache-httpclient/apache-httpclient-4.0/src/main/java/io/opentelemetry/auto/instrumentation/apachehttpclient/v4_0/ApacheHttpClientInstrumentation.java", "diffHunk": "@@ -172,16 +171,14 @@ public ApacheHttpClientInstrumentation() {\n \n   public static class HelperMethods {\n     public static SpanWithScope doMethodEnter(final HttpUriRequest request) {\n-      final Span span =\n-          TRACER.spanBuilder(DECORATE.spanNameForRequest(request)).setSpanKind(CLIENT).startSpan();\n+      final Span span = DECORATE.getOrCreateSpan(request, TRACER);\n \n       DECORATE.afterStart(span);\n       DECORATE.onRequest(span, request);\n \n-      final Context context = withSpan(span, Context.current());\n-      final boolean awsClientCall = request.getHeaders(\"amz-sdk-invocation-id\").length > 0;\n-      // AWS calls are often signed, so we can't add headers without breaking the signature.\n-      if (!awsClientCall) {\n+      final Context context = ClientDecorator.withSpan(span, Context.current());\n+      // TODO(anuraaga): Seems like a bug that invalid context still gets injected by the injector.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced"}, "originalPosition": 33}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNTgwMTU4", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#pullrequestreview-422580158", "createdAt": "2020-06-02T11:21:37Z", "commit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMToyMTozN1rOGdtMYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMTozMjoyMFrOGdthFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwMjMzOA==", "bodyText": "Setting parent is not required here. It will come automatically from current context", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r433802338", "createdAt": "2020-06-02T11:21:37Z", "author": {"login": "iNikem"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "diffHunk": "@@ -15,10 +15,51 @@\n  */\n package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n \n+import io.grpc.Context;\n+import io.opentelemetry.context.ContextUtils;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.DefaultSpan;\n import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n \n public abstract class ClientDecorator extends BaseDecorator {\n \n+  // Keeps track of the client span in a subtree corresponding to a client request.\n+  private static final Context.Key<Span> CONTEXT_CLIENT_SPAN_KEY =\n+      Context.key(\"opentelemetry-trace-auto-client-span-key\");\n+\n+  public static Scope currentContextWith(final Span clientSpan) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.currentContextWith(clientSpan);\n+    }\n+    return ContextUtils.withScopedContext(\n+        TracingContextUtils.withSpan(\n+            clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan)));\n+  }\n+\n+  public static Context withSpan(final Span clientSpan, final Context context) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.withSpan(clientSpan, context);\n+    }\n+    return TracingContextUtils.withSpan(\n+        clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan));\n+  }\n+\n+  public Span getOrCreateSpan(String name, Tracer tracer) {\n+    final Context context = Context.current();\n+    final Span clientSpan = CONTEXT_CLIENT_SPAN_KEY.get(context);\n+\n+    if (clientSpan != null) {\n+      // We don't want to create two client spans for a given client call, suppress inner spans.\n+      return DefaultSpan.getInvalid();\n+    }\n+\n+    final Span current = TracingContextUtils.getSpan(context);\n+    return tracer.spanBuilder(name).setSpanKind(Kind.CLIENT).setParent(current).startSpan();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwNjgyOA==", "bodyText": "This method certainly can delegate to withSpan below", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r433806828", "createdAt": "2020-06-02T11:30:37Z", "author": {"login": "iNikem"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "diffHunk": "@@ -15,10 +15,51 @@\n  */\n package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n \n+import io.grpc.Context;\n+import io.opentelemetry.context.ContextUtils;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.DefaultSpan;\n import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n \n public abstract class ClientDecorator extends BaseDecorator {\n \n+  // Keeps track of the client span in a subtree corresponding to a client request.\n+  private static final Context.Key<Span> CONTEXT_CLIENT_SPAN_KEY =\n+      Context.key(\"opentelemetry-trace-auto-client-span-key\");\n+\n+  public static Scope currentContextWith(final Span clientSpan) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwNzE2Mg==", "bodyText": "Here we are sure that we are currently creating first client span. I think this should be the right place to put that span into current context under CONTEXT_CLIENT_SPAN_KEY key.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r433807162", "createdAt": "2020-06-02T11:31:12Z", "author": {"login": "iNikem"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "diffHunk": "@@ -15,10 +15,51 @@\n  */\n package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n \n+import io.grpc.Context;\n+import io.opentelemetry.context.ContextUtils;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.DefaultSpan;\n import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n \n public abstract class ClientDecorator extends BaseDecorator {\n \n+  // Keeps track of the client span in a subtree corresponding to a client request.\n+  private static final Context.Key<Span> CONTEXT_CLIENT_SPAN_KEY =\n+      Context.key(\"opentelemetry-trace-auto-client-span-key\");\n+\n+  public static Scope currentContextWith(final Span clientSpan) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.currentContextWith(clientSpan);\n+    }\n+    return ContextUtils.withScopedContext(\n+        TracingContextUtils.withSpan(\n+            clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan)));\n+  }\n+\n+  public static Context withSpan(final Span clientSpan, final Context context) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.withSpan(clientSpan, context);\n+    }\n+    return TracingContextUtils.withSpan(\n+        clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan));\n+  }\n+\n+  public Span getOrCreateSpan(String name, Tracer tracer) {\n+    final Context context = Context.current();\n+    final Span clientSpan = CONTEXT_CLIENT_SPAN_KEY.get(context);\n+\n+    if (clientSpan != null) {\n+      // We don't want to create two client spans for a given client call, suppress inner spans.\n+      return DefaultSpan.getInvalid();\n+    }\n+\n+    final Span current = TracingContextUtils.getSpan(context);\n+    return tracer.spanBuilder(name).setSpanKind(Kind.CLIENT).setParent(current).startSpan();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwNzYzOQ==", "bodyText": "Do we still need this ScopeHolder? Why getting span from current context is not enough?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r433807639", "createdAt": "2020-06-02T11:32:20Z", "author": {"login": "iNikem"}, "path": "instrumentation/aws-sdk/aws-sdk-2.2/src/main/java8/io/opentelemetry/auto/instrumentation/awssdk/v2_2/TracingExecutionInterceptor.java", "diffHunk": "@@ -135,7 +132,7 @@ public void beforeTransmission(\n     if (span != null) {\n       // This scope will be closed by AwsHttpClientInstrumentation since ExecutionInterceptor API\n       // doesn't provide a way to run code in the same thread after transmission has been scheduled.\n-      ScopeHolder.CURRENT.set(currentContextWith(span));\n+      ScopeHolder.CURRENT.set(ClientDecorator.currentContextWith(span));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMDAwMTg0", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#pullrequestreview-423000184", "createdAt": "2020-06-02T19:39:02Z", "commit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxOTozOTowMlrOGeBSKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQyMToyNTozMVrOGeEhXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEzMTQ5OQ==", "bodyText": "Setting the parent here does save a thread-local lookup since we already have the current context from above", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r434131499", "createdAt": "2020-06-02T19:39:02Z", "author": {"login": "trask"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "diffHunk": "@@ -15,10 +15,51 @@\n  */\n package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n \n+import io.grpc.Context;\n+import io.opentelemetry.context.ContextUtils;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.DefaultSpan;\n import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n \n public abstract class ClientDecorator extends BaseDecorator {\n \n+  // Keeps track of the client span in a subtree corresponding to a client request.\n+  private static final Context.Key<Span> CONTEXT_CLIENT_SPAN_KEY =\n+      Context.key(\"opentelemetry-trace-auto-client-span-key\");\n+\n+  public static Scope currentContextWith(final Span clientSpan) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.currentContextWith(clientSpan);\n+    }\n+    return ContextUtils.withScopedContext(\n+        TracingContextUtils.withSpan(\n+            clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan)));\n+  }\n+\n+  public static Context withSpan(final Span clientSpan, final Context context) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.withSpan(clientSpan, context);\n+    }\n+    return TracingContextUtils.withSpan(\n+        clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan));\n+  }\n+\n+  public Span getOrCreateSpan(String name, Tracer tracer) {\n+    final Context context = Context.current();\n+    final Span clientSpan = CONTEXT_CLIENT_SPAN_KEY.get(context);\n+\n+    if (clientSpan != null) {\n+      // We don't want to create two client spans for a given client call, suppress inner spans.\n+      return DefaultSpan.getInvalid();\n+    }\n+\n+    final Span current = TracingContextUtils.getSpan(context);\n+    return tracer.spanBuilder(name).setSpanKind(Kind.CLIENT).setParent(current).startSpan();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwMjMzOA=="}, "originalCommit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEzNjIwMA==", "bodyText": "i think?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan));\n          \n          \n            \n                    clientSpan, context.withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan));", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r434136200", "createdAt": "2020-06-02T19:48:14Z", "author": {"login": "trask"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "diffHunk": "@@ -15,10 +15,51 @@\n  */\n package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n \n+import io.grpc.Context;\n+import io.opentelemetry.context.ContextUtils;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.DefaultSpan;\n import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n \n public abstract class ClientDecorator extends BaseDecorator {\n \n+  // Keeps track of the client span in a subtree corresponding to a client request.\n+  private static final Context.Key<Span> CONTEXT_CLIENT_SPAN_KEY =\n+      Context.key(\"opentelemetry-trace-auto-client-span-key\");\n+\n+  public static Scope currentContextWith(final Span clientSpan) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.currentContextWith(clientSpan);\n+    }\n+    return ContextUtils.withScopedContext(\n+        TracingContextUtils.withSpan(\n+            clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan)));\n+  }\n+\n+  public static Context withSpan(final Span clientSpan, final Context context) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.withSpan(clientSpan, context);\n+    }\n+    return TracingContextUtils.withSpan(\n+        clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NDIxNg==", "bodyText": "I'm guessing you know something that we don't about this not being needed anymore? \ud83d\ude04", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r434164216", "createdAt": "2020-06-02T20:43:43Z", "author": {"login": "trask"}, "path": "instrumentation/apache-httpclient/apache-httpclient-4.0/src/main/java/io/opentelemetry/auto/instrumentation/apachehttpclient/v4_0/ApacheHttpClientInstrumentation.java", "diffHunk": "@@ -172,16 +171,14 @@ public ApacheHttpClientInstrumentation() {\n \n   public static class HelperMethods {\n     public static SpanWithScope doMethodEnter(final HttpUriRequest request) {\n-      final Span span =\n-          TRACER.spanBuilder(DECORATE.spanNameForRequest(request)).setSpanKind(CLIENT).startSpan();\n+      final Span span = DECORATE.getOrCreateSpan(request, TRACER);\n \n       DECORATE.afterStart(span);\n       DECORATE.onRequest(span, request);\n \n-      final Context context = withSpan(span, Context.current());\n-      final boolean awsClientCall = request.getHeaders(\"amz-sdk-invocation-id\").length > 0;\n-      // AWS calls are often signed, so we can't add headers without breaking the signature.\n-      if (!awsClientCall) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE4NDU0MA==", "bodyText": "It looks like this is only called with Context.current(), so maybe this method isn't needed?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r434184540", "createdAt": "2020-06-02T21:25:31Z", "author": {"login": "trask"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "diffHunk": "@@ -15,10 +15,51 @@\n  */\n package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n \n+import io.grpc.Context;\n+import io.opentelemetry.context.ContextUtils;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.DefaultSpan;\n import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n \n public abstract class ClientDecorator extends BaseDecorator {\n \n+  // Keeps track of the client span in a subtree corresponding to a client request.\n+  private static final Context.Key<Span> CONTEXT_CLIENT_SPAN_KEY =\n+      Context.key(\"opentelemetry-trace-auto-client-span-key\");\n+\n+  public static Scope currentContextWith(final Span clientSpan) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.currentContextWith(clientSpan);\n+    }\n+    return ContextUtils.withScopedContext(\n+        TracingContextUtils.withSpan(\n+            clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan)));\n+  }\n+\n+  public static Context withSpan(final Span clientSpan, final Context context) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced"}, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMTU0MDI3", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#pullrequestreview-423154027", "createdAt": "2020-06-03T01:07:23Z", "commit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMTowNzoyNFrOGeI07A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMToxNjo1NVrOGeI-bQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1NTA4NA==", "bodyText": "Yup the optimization is the only reason I did so", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r434255084", "createdAt": "2020-06-03T01:07:24Z", "author": {"login": "anuraaga"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "diffHunk": "@@ -15,10 +15,51 @@\n  */\n package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n \n+import io.grpc.Context;\n+import io.opentelemetry.context.ContextUtils;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.DefaultSpan;\n import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n \n public abstract class ClientDecorator extends BaseDecorator {\n \n+  // Keeps track of the client span in a subtree corresponding to a client request.\n+  private static final Context.Key<Span> CONTEXT_CLIENT_SPAN_KEY =\n+      Context.key(\"opentelemetry-trace-auto-client-span-key\");\n+\n+  public static Scope currentContextWith(final Span clientSpan) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.currentContextWith(clientSpan);\n+    }\n+    return ContextUtils.withScopedContext(\n+        TracingContextUtils.withSpan(\n+            clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan)));\n+  }\n+\n+  public static Context withSpan(final Span clientSpan, final Context context) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.withSpan(clientSpan, context);\n+    }\n+    return TracingContextUtils.withSpan(\n+        clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan));\n+  }\n+\n+  public Span getOrCreateSpan(String name, Tracer tracer) {\n+    final Context context = Context.current();\n+    final Span clientSpan = CONTEXT_CLIENT_SPAN_KEY.get(context);\n+\n+    if (clientSpan != null) {\n+      // We don't want to create two client spans for a given client call, suppress inner spans.\n+      return DefaultSpan.getInvalid();\n+    }\n+\n+    final Span current = TracingContextUtils.getSpan(context);\n+    return tracer.spanBuilder(name).setSpanKind(Kind.CLIENT).setParent(current).startSpan();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwMjMzOA=="}, "originalCommit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1NjMyNA==", "bodyText": "I really wish I could - but context is immutable so AFAIK, we can really only \"add to context\" when mounting it, in these withSpan type of methods. I have left some comments in the context discussion doc before coincidentally, and it is running into these sort of cases where I really don't enjoy immutable context ;)\nIf there is an entrypoint that is guaranteed to be called with a new context, than it would be possible to put mutable state in at that point and then here we'd just update it. But I couldn't find one, if this span is the root of a trace (some non-server app running AWS SDK call for example), this span will be created before a new context is and we wouldn't have anywhere to store it until a call to with*.\nLet me know if I'm missing anything, I'd be happy to be since this API is otherwise somewhat ackward for duplicating the APIs in TracingContextUtils.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r434256324", "createdAt": "2020-06-03T01:12:00Z", "author": {"login": "anuraaga"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "diffHunk": "@@ -15,10 +15,51 @@\n  */\n package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n \n+import io.grpc.Context;\n+import io.opentelemetry.context.ContextUtils;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.DefaultSpan;\n import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n \n public abstract class ClientDecorator extends BaseDecorator {\n \n+  // Keeps track of the client span in a subtree corresponding to a client request.\n+  private static final Context.Key<Span> CONTEXT_CLIENT_SPAN_KEY =\n+      Context.key(\"opentelemetry-trace-auto-client-span-key\");\n+\n+  public static Scope currentContextWith(final Span clientSpan) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.currentContextWith(clientSpan);\n+    }\n+    return ContextUtils.withScopedContext(\n+        TracingContextUtils.withSpan(\n+            clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan)));\n+  }\n+\n+  public static Context withSpan(final Span clientSpan, final Context context) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.withSpan(clientSpan, context);\n+    }\n+    return TracingContextUtils.withSpan(\n+        clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan));\n+  }\n+\n+  public Span getOrCreateSpan(String name, Tracer tracer) {\n+    final Context context = Context.current();\n+    final Span clientSpan = CONTEXT_CLIENT_SPAN_KEY.get(context);\n+\n+    if (clientSpan != null) {\n+      // We don't want to create two client spans for a given client call, suppress inner spans.\n+      return DefaultSpan.getInvalid();\n+    }\n+\n+    final Span current = TracingContextUtils.getSpan(context);\n+    return tracer.spanBuilder(name).setSpanKind(Kind.CLIENT).setParent(current).startSpan();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwNzE2Mg=="}, "originalCommit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1NzAxMg==", "bodyText": "Now that there's only the SDK span and no Apache span, there's nothing to propagate here. That being said, it does seem safer to keep the check just in case something changes, at the same time, it seems pretty hacky to have the AWS-specific code here so it feels nice to remove it.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r434257012", "createdAt": "2020-06-03T01:14:52Z", "author": {"login": "anuraaga"}, "path": "instrumentation/apache-httpclient/apache-httpclient-4.0/src/main/java/io/opentelemetry/auto/instrumentation/apachehttpclient/v4_0/ApacheHttpClientInstrumentation.java", "diffHunk": "@@ -172,16 +171,14 @@ public ApacheHttpClientInstrumentation() {\n \n   public static class HelperMethods {\n     public static SpanWithScope doMethodEnter(final HttpUriRequest request) {\n-      final Span span =\n-          TRACER.spanBuilder(DECORATE.spanNameForRequest(request)).setSpanKind(CLIENT).startSpan();\n+      final Span span = DECORATE.getOrCreateSpan(request, TRACER);\n \n       DECORATE.afterStart(span);\n       DECORATE.onRequest(span, request);\n \n-      final Context context = withSpan(span, Context.current());\n-      final boolean awsClientCall = request.getHeaders(\"amz-sdk-invocation-id\").length > 0;\n-      // AWS calls are often signed, so we can't add headers without breaking the signature.\n-      if (!awsClientCall) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NDIxNg=="}, "originalCommit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1NzUxNw==", "bodyText": "We get the span from current context here, but afterTransmission may be called on a different thread, e.g., from netty, so the current context won't be accessible there. This ScopeHolder is only to allow closing in that method where we don't have context.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r434257517", "createdAt": "2020-06-03T01:16:55Z", "author": {"login": "anuraaga"}, "path": "instrumentation/aws-sdk/aws-sdk-2.2/src/main/java8/io/opentelemetry/auto/instrumentation/awssdk/v2_2/TracingExecutionInterceptor.java", "diffHunk": "@@ -135,7 +132,7 @@ public void beforeTransmission(\n     if (span != null) {\n       // This scope will be closed by AwsHttpClientInstrumentation since ExecutionInterceptor API\n       // doesn't provide a way to run code in the same thread after transmission has been scheduled.\n-      ScopeHolder.CURRENT.set(currentContextWith(span));\n+      ScopeHolder.CURRENT.set(ClientDecorator.currentContextWith(span));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwNzYzOQ=="}, "originalCommit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced"}, "originalPosition": 29}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "84ac8099c26700e520ec619526136db76d474b9c", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/84ac8099c26700e520ec619526136db76d474b9c", "committedDate": "2020-06-05T07:34:51Z", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-auto-instr-java into suppress-nested-client-spans"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76b32219cdbca9385344d4d07a2d1e7566b423af", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/76b32219cdbca9385344d4d07a2d1e7566b423af", "committedDate": "2020-06-05T08:41:23Z", "message": "Apply new pattern to AWS V1 SDK instrumentation too, cleanup, and javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "95d8115c353b7ffdd8fb4d4746de96d48e29fc37", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/95d8115c353b7ffdd8fb4d4746de96d48e29fc37", "committedDate": "2020-06-08T04:19:08Z", "message": "Update test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1OTEwNDU3", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#pullrequestreview-425910457", "createdAt": "2020-06-08T04:36:37Z", "commit": {"oid": "76b32219cdbca9385344d4d07a2d1e7566b423af"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNDozNjozN1rOGgO-VQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNDozNjozN1rOGgO-VQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ1Mjk0OQ==", "bodyText": "I noticed the same lack of symmetry in TracingContextUtils and followed the pattern. Let me know if it's worth diverging.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r436452949", "createdAt": "2020-06-08T04:36:37Z", "author": {"login": "anuraaga"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "diffHunk": "@@ -15,10 +15,51 @@\n  */\n package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n \n+import io.grpc.Context;\n+import io.opentelemetry.context.ContextUtils;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.DefaultSpan;\n import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n \n public abstract class ClientDecorator extends BaseDecorator {\n \n+  // Keeps track of the client span in a subtree corresponding to a client request.\n+  private static final Context.Key<Span> CONTEXT_CLIENT_SPAN_KEY =\n+      Context.key(\"opentelemetry-trace-auto-client-span-key\");\n+\n+  public static Scope currentContextWith(final Span clientSpan) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.currentContextWith(clientSpan);\n+    }\n+    return ContextUtils.withScopedContext(\n+        TracingContextUtils.withSpan(\n+            clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan)));\n+  }\n+\n+  public static Context withSpan(final Span clientSpan, final Context context) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE4NDU0MA=="}, "originalCommit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced"}, "originalPosition": 28}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9051e500537a0ff117ae71141c2e62057c8ff6c0", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/9051e500537a0ff117ae71141c2e62057c8ff6c0", "committedDate": "2020-06-08T05:05:18Z", "message": "Unit tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c42a37ed22fbc19656c541c91f455a083a9f9c57", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/c42a37ed22fbc19656c541c91f455a083a9f9c57", "committedDate": "2020-06-08T04:38:04Z", "message": "Merge branch 'master' into suppress-nested-client-spans"}, "afterCommit": {"oid": "9051e500537a0ff117ae71141c2e62057c8ff6c0", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/9051e500537a0ff117ae71141c2e62057c8ff6c0", "committedDate": "2020-06-08T05:05:18Z", "message": "Unit tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1OTUwMTIw", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#pullrequestreview-425950120", "createdAt": "2020-06-08T06:43:51Z", "commit": {"oid": "9051e500537a0ff117ae71141c2e62057c8ff6c0"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNjo0Mzo1MVrOGgQ8jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNjo1MDozMFrOGgRGhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NTI2Mw==", "bodyText": "io.opentelemetry.trace.TracingContextUtils#withSpan can potentially be called with contexts other than current during context extraction via io.opentelemetry.trace.propagation.HttpTraceContext#extract method. This client decorator is not general purpose util, but more specific one. Thus I think we indeed can merge these two methods together.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r436485263", "createdAt": "2020-06-08T06:43:51Z", "author": {"login": "iNikem"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "diffHunk": "@@ -15,10 +15,51 @@\n  */\n package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n \n+import io.grpc.Context;\n+import io.opentelemetry.context.ContextUtils;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.DefaultSpan;\n import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n \n public abstract class ClientDecorator extends BaseDecorator {\n \n+  // Keeps track of the client span in a subtree corresponding to a client request.\n+  private static final Context.Key<Span> CONTEXT_CLIENT_SPAN_KEY =\n+      Context.key(\"opentelemetry-trace-auto-client-span-key\");\n+\n+  public static Scope currentContextWith(final Span clientSpan) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.currentContextWith(clientSpan);\n+    }\n+    return ContextUtils.withScopedContext(\n+        TracingContextUtils.withSpan(\n+            clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan)));\n+  }\n+\n+  public static Context withSpan(final Span clientSpan, final Context context) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE4NDU0MA=="}, "originalCommit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NTYxNA==", "bodyText": "I would extract common call to TracingContextUtils.withSpan from the if above.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r436485614", "createdAt": "2020-06-08T06:44:53Z", "author": {"login": "iNikem"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "diffHunk": "@@ -15,10 +15,59 @@\n  */\n package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n \n+import io.grpc.Context;\n+import io.opentelemetry.context.ContextUtils;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.DefaultSpan;\n import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n \n public abstract class ClientDecorator extends BaseDecorator {\n \n+  // Keeps track of the client span in a subtree corresponding to a client request.\n+  // Visible for testing\n+  static final Context.Key<Span> CONTEXT_CLIENT_SPAN_KEY =\n+      Context.key(\"opentelemetry-trace-auto-client-span-key\");\n+\n+  /**\n+   * Creates a {@link Context} with the provided {@link Span} and sets it as the current {@link\n+   * Context}\n+   *\n+   * @return a {@link Scope} that will restore the previous context. All callers of this method must\n+   *     also call {@link Scope#close()} when this next context is no longer needed.\n+   */\n+  public static Scope currentContextWith(final Span clientSpan) {\n+    return ContextUtils.withScopedContext(withSpan(clientSpan, Context.current()));\n+  }\n+\n+  /** Returns a new {@link Context} forked from {@code context} with the {@link Span} set. */\n+  public static Context withSpan(final Span clientSpan, final Context context) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.withSpan(clientSpan, context);\n+    }\n+    return TracingContextUtils.withSpan(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9051e500537a0ff117ae71141c2e62057c8ff6c0"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NzQ4OQ==", "bodyText": "Here is the interesting question: should we return clientSpan from here? This way lower level instrumentations can fill in e.g. net.* attributes", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r436487489", "createdAt": "2020-06-08T06:49:46Z", "author": {"login": "iNikem"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "diffHunk": "@@ -15,10 +15,59 @@\n  */\n package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n \n+import io.grpc.Context;\n+import io.opentelemetry.context.ContextUtils;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.DefaultSpan;\n import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n \n public abstract class ClientDecorator extends BaseDecorator {\n \n+  // Keeps track of the client span in a subtree corresponding to a client request.\n+  // Visible for testing\n+  static final Context.Key<Span> CONTEXT_CLIENT_SPAN_KEY =\n+      Context.key(\"opentelemetry-trace-auto-client-span-key\");\n+\n+  /**\n+   * Creates a {@link Context} with the provided {@link Span} and sets it as the current {@link\n+   * Context}\n+   *\n+   * @return a {@link Scope} that will restore the previous context. All callers of this method must\n+   *     also call {@link Scope#close()} when this next context is no longer needed.\n+   */\n+  public static Scope currentContextWith(final Span clientSpan) {\n+    return ContextUtils.withScopedContext(withSpan(clientSpan, Context.current()));\n+  }\n+\n+  /** Returns a new {@link Context} forked from {@code context} with the {@link Span} set. */\n+  public static Context withSpan(final Span clientSpan, final Context context) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.withSpan(clientSpan, context);\n+    }\n+    return TracingContextUtils.withSpan(\n+        clientSpan, context.withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan));\n+  }\n+\n+  /**\n+   * Returns a new client {@link Span} if there is no client {@link Span} in the current {@link\n+   * Context}, or an invalid {@link Span} otherwise.\n+   */\n+  public static Span getOrCreateSpan(String name, Tracer tracer) {\n+    final Context context = Context.current();\n+    final Span clientSpan = CONTEXT_CLIENT_SPAN_KEY.get(context);\n+\n+    if (clientSpan != null) {\n+      // We don't want to create two client spans for a given client call, suppress inner spans.\n+      return DefaultSpan.getInvalid();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9051e500537a0ff117ae71141c2e62057c8ff6c0"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NzgxNA==", "bodyText": "Can this be made private/protected now?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r436487814", "createdAt": "2020-06-08T06:50:30Z", "author": {"login": "iNikem"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/HttpClientDecorator.java", "diffHunk": "@@ -35,6 +36,10 @@\n \n   protected abstract Integer status(RESPONSE response);\n \n+  public Span getOrCreateSpan(REQUEST request, Tracer tracer) {\n+    return getOrCreateSpan(spanNameForRequest(request), tracer);\n+  }\n+\n   public String spanNameForRequest(final REQUEST request) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9051e500537a0ff117ae71141c2e62057c8ff6c0"}, "originalPosition": 16}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f07eb92a7e53492f697b3be574c6b4d6f7267cc", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/6f07eb92a7e53492f697b3be574c6b4d6f7267cc", "committedDate": "2020-06-08T08:07:51Z", "message": "Cleanups"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2MDAxOTYz", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#pullrequestreview-426001963", "createdAt": "2020-06-08T08:12:04Z", "commit": {"oid": "6f07eb92a7e53492f697b3be574c6b4d6f7267cc"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e18e087311bd2034643bbcf22528854a5e66944", "author": {"user": {"login": "trask", "name": "Trask Stalnaker"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/0e18e087311bd2034643bbcf22528854a5e66944", "committedDate": "2020-06-08T18:26:45Z", "message": "Merge branch 'master' into suppress-nested-client-spans"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3187, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}