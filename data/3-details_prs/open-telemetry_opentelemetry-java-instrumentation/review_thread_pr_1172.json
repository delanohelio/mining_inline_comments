{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc5NTcyNTI3", "number": 1172, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwMzozNjoyOVrOEh75IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwNToxOToxOFrOEjbNCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MDE5NzQ1OnYy", "diffSide": "RIGHT", "path": "instrumentation/java-classloader/src/main/java/io/opentelemetry/instrumentation/auto/javaclassloader/ResourceInjectionInstrumentation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwMzozNjoyOVrOHPhtdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwMzozNjoyOVrOHPhtdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA0Mjk5OQ==", "bodyText": "BytesUtil class and its toByteArray method both need to be public b/c the advice is inlined, so it's really in a different package", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1172#discussion_r486042999", "createdAt": "2020-09-10T03:36:29Z", "author": {"login": "trask"}, "path": "instrumentation/java-classloader/src/main/java/io/opentelemetry/instrumentation/auto/javaclassloader/ResourceInjectionInstrumentation.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.javaclassloader;\n+\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.javaagent.bootstrap.HelperResources;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+/**\n+ * Instruments {@link ClassLoader} to have calls to get resources intercepted and check our map of\n+ * helper resources that is filled by instrumentation when they need helpers.\n+ */\n+@AutoService(Instrumenter.class)\n+public class ResourceInjectionInstrumentation extends Instrumenter.Default {\n+\n+  public ResourceInjectionInstrumentation() {\n+    super(\"class-loader\");\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      \"io.opentelemetry.instrumentation.auto.javaclassloader.BytesUtil\",\n+    };\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return extendsClass(named(\"java.lang.ClassLoader\"));\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        isMethod().and(named(\"getResource\")).and(takesArguments(String.class)),\n+        ResourceInjectionInstrumentation.class.getName() + \"$GetResourceAdvice\");\n+\n+    transformers.put(\n+        isMethod().and(named(\"getResources\")).and(takesArguments(String.class)),\n+        ResourceInjectionInstrumentation.class.getName() + \"$GetResourcesAdvice\");\n+    return transformers;\n+  }\n+\n+  public static class GetResourceAdvice {\n+    @Advice.OnMethodExit(onThrowable = Throwable.class)\n+    public static void onExit(\n+        @Advice.This ClassLoader classLoader,\n+        @Advice.Argument(0) String name,\n+        @Advice.Return(readOnly = false) URL resourceUrl) {\n+      if (resourceUrl != null) {\n+        // Give their classloader precedence.\n+        return;\n+      }\n+\n+      resourceUrl = HelperResources.load(classLoader, name);\n+    }\n+  }\n+\n+  public static class GetResourcesAdvice {\n+    @Advice.OnMethodExit(onThrowable = Throwable.class)\n+    public static void onExit(\n+        @Advice.This ClassLoader classLoader,\n+        @Advice.Argument(0) String name,\n+        @Advice.Return(readOnly = false) Enumeration<URL> resources) {\n+      URL helper = HelperResources.load(classLoader, name);\n+      if (helper == null) {\n+        return;\n+      }\n+\n+      if (!resources.hasMoreElements()) {\n+        resources = Collections.enumeration(Collections.singleton(helper));\n+        return;\n+      }\n+\n+      // TODO(anuraaga): Don't inline BytesUtil.toByteArray after understanding AccessError when\n+      // trying to use the class from bootstrap classloader.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eed7bfa17d5525b68292f6e61f30224b9d8cca6"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MDkzMDE4OnYy", "diffSide": "RIGHT", "path": "instrumentation/aws-sdk/aws-sdk-2.2/auto/src/main/java/io/opentelemetry/instrumentation/auto/awssdk/v2_2/AwsClientInstrumentation.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQwNDozNjo1NVrOHRDmfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwNTowNzowMlrOHRw2qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzY0Njg0NA==", "bodyText": "Without a smoke test, I'm actually a little worried this won't get shaded", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1172#discussion_r487646844", "createdAt": "2020-09-14T04:36:55Z", "author": {"login": "anuraaga"}, "path": "instrumentation/aws-sdk/aws-sdk-2.2/auto/src/main/java/io/opentelemetry/instrumentation/auto/awssdk/v2_2/AwsClientInstrumentation.java", "diffHunk": "@@ -17,72 +17,46 @@\n package io.opentelemetry.instrumentation.auto.awssdk.v2_2;\n \n import static io.opentelemetry.javaagent.tooling.ClassLoaderMatcher.hasClassesNamed;\n-import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.implementsInterface;\n-import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n-import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n-import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n import static net.bytebuddy.matcher.ElementMatchers.named;\n \n import com.google.auto.service.AutoService;\n import io.opentelemetry.javaagent.tooling.Instrumenter;\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.Map;\n-import net.bytebuddy.asm.Advice;\n import net.bytebuddy.description.method.MethodDescription;\n import net.bytebuddy.description.type.TypeDescription;\n import net.bytebuddy.matcher.ElementMatcher;\n-import software.amazon.awssdk.core.client.builder.SdkClientBuilder;\n \n-/** AWS SDK v2 instrumentation */\n+/**\n+ * Injects resource file with reference to our {@link TracingExecutionInterceptor} to allow SDK's\n+ * service loading mechanism to pick it up.\n+ */\n @AutoService(Instrumenter.class)\n-public final class AwsClientInstrumentation extends AbstractAwsClientInstrumentation {\n+public class AwsClientInstrumentation extends AbstractAwsClientInstrumentation {\n+  @Override\n+  public String[] helperResourceNames() {\n+    return new String[] {\n+      \"software/amazon/awssdk/global/handlers/execution.interceptors\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ec48cbc4394ca2cfd402084c8c8f98540db104b"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM4NTM5Mw==", "bodyText": "I'm not following, what do you want shaded here?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1172#discussion_r488385393", "createdAt": "2020-09-15T04:56:43Z", "author": {"login": "trask"}, "path": "instrumentation/aws-sdk/aws-sdk-2.2/auto/src/main/java/io/opentelemetry/instrumentation/auto/awssdk/v2_2/AwsClientInstrumentation.java", "diffHunk": "@@ -17,72 +17,46 @@\n package io.opentelemetry.instrumentation.auto.awssdk.v2_2;\n \n import static io.opentelemetry.javaagent.tooling.ClassLoaderMatcher.hasClassesNamed;\n-import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.implementsInterface;\n-import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n-import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n-import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n import static net.bytebuddy.matcher.ElementMatchers.named;\n \n import com.google.auto.service.AutoService;\n import io.opentelemetry.javaagent.tooling.Instrumenter;\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.Map;\n-import net.bytebuddy.asm.Advice;\n import net.bytebuddy.description.method.MethodDescription;\n import net.bytebuddy.description.type.TypeDescription;\n import net.bytebuddy.matcher.ElementMatcher;\n-import software.amazon.awssdk.core.client.builder.SdkClientBuilder;\n \n-/** AWS SDK v2 instrumentation */\n+/**\n+ * Injects resource file with reference to our {@link TracingExecutionInterceptor} to allow SDK's\n+ * service loading mechanism to pick it up.\n+ */\n @AutoService(Instrumenter.class)\n-public final class AwsClientInstrumentation extends AbstractAwsClientInstrumentation {\n+public class AwsClientInstrumentation extends AbstractAwsClientInstrumentation {\n+  @Override\n+  public String[] helperResourceNames() {\n+    return new String[] {\n+      \"software/amazon/awssdk/global/handlers/execution.interceptors\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzY0Njg0NA=="}, "originalCommit": {"oid": "3ec48cbc4394ca2cfd402084c8c8f98540db104b"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM4NzI2OA==", "bodyText": "Sorry nevermind :)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1172#discussion_r488387268", "createdAt": "2020-09-15T05:03:25Z", "author": {"login": "anuraaga"}, "path": "instrumentation/aws-sdk/aws-sdk-2.2/auto/src/main/java/io/opentelemetry/instrumentation/auto/awssdk/v2_2/AwsClientInstrumentation.java", "diffHunk": "@@ -17,72 +17,46 @@\n package io.opentelemetry.instrumentation.auto.awssdk.v2_2;\n \n import static io.opentelemetry.javaagent.tooling.ClassLoaderMatcher.hasClassesNamed;\n-import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.implementsInterface;\n-import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n-import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n-import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n import static net.bytebuddy.matcher.ElementMatchers.named;\n \n import com.google.auto.service.AutoService;\n import io.opentelemetry.javaagent.tooling.Instrumenter;\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.Map;\n-import net.bytebuddy.asm.Advice;\n import net.bytebuddy.description.method.MethodDescription;\n import net.bytebuddy.description.type.TypeDescription;\n import net.bytebuddy.matcher.ElementMatcher;\n-import software.amazon.awssdk.core.client.builder.SdkClientBuilder;\n \n-/** AWS SDK v2 instrumentation */\n+/**\n+ * Injects resource file with reference to our {@link TracingExecutionInterceptor} to allow SDK's\n+ * service loading mechanism to pick it up.\n+ */\n @AutoService(Instrumenter.class)\n-public final class AwsClientInstrumentation extends AbstractAwsClientInstrumentation {\n+public class AwsClientInstrumentation extends AbstractAwsClientInstrumentation {\n+  @Override\n+  public String[] helperResourceNames() {\n+    return new String[] {\n+      \"software/amazon/awssdk/global/handlers/execution.interceptors\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzY0Njg0NA=="}, "originalCommit": {"oid": "3ec48cbc4394ca2cfd402084c8c8f98540db104b"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM4ODI2Nw==", "bodyText": "\ud83d\ude05", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1172#discussion_r488388267", "createdAt": "2020-09-15T05:07:02Z", "author": {"login": "trask"}, "path": "instrumentation/aws-sdk/aws-sdk-2.2/auto/src/main/java/io/opentelemetry/instrumentation/auto/awssdk/v2_2/AwsClientInstrumentation.java", "diffHunk": "@@ -17,72 +17,46 @@\n package io.opentelemetry.instrumentation.auto.awssdk.v2_2;\n \n import static io.opentelemetry.javaagent.tooling.ClassLoaderMatcher.hasClassesNamed;\n-import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.implementsInterface;\n-import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n-import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n-import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n import static net.bytebuddy.matcher.ElementMatchers.named;\n \n import com.google.auto.service.AutoService;\n import io.opentelemetry.javaagent.tooling.Instrumenter;\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.Map;\n-import net.bytebuddy.asm.Advice;\n import net.bytebuddy.description.method.MethodDescription;\n import net.bytebuddy.description.type.TypeDescription;\n import net.bytebuddy.matcher.ElementMatcher;\n-import software.amazon.awssdk.core.client.builder.SdkClientBuilder;\n \n-/** AWS SDK v2 instrumentation */\n+/**\n+ * Injects resource file with reference to our {@link TracingExecutionInterceptor} to allow SDK's\n+ * service loading mechanism to pick it up.\n+ */\n @AutoService(Instrumenter.class)\n-public final class AwsClientInstrumentation extends AbstractAwsClientInstrumentation {\n+public class AwsClientInstrumentation extends AbstractAwsClientInstrumentation {\n+  @Override\n+  public String[] helperResourceNames() {\n+    return new String[] {\n+      \"software/amazon/awssdk/global/handlers/execution.interceptors\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzY0Njg0NA=="}, "originalCommit": {"oid": "3ec48cbc4394ca2cfd402084c8c8f98540db104b"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1NTgwNjMwOnYy", "diffSide": "RIGHT", "path": "javaagent-bootstrap/src/main/java/io/opentelemetry/javaagent/bootstrap/HelperResources.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwNToxNToxM1rOHRw_sQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwNToxNToxM1rOHRw_sQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5MDU3Nw==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1172#discussion_r488390577", "createdAt": "2020-09-15T05:15:13Z", "author": {"login": "trask"}, "path": "javaagent-bootstrap/src/main/java/io/opentelemetry/javaagent/bootstrap/HelperResources.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.javaagent.bootstrap;\n+\n+import static io.opentelemetry.instrumentation.auto.api.WeakMap.Provider.newWeakMap;\n+\n+import io.opentelemetry.instrumentation.auto.api.WeakMap;\n+import java.net.URL;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * A holder of resources needed by instrumentation. We store them in the bootstrap classloader so\n+ * instrumentation can store from the agent classloader and apps can retrieve from the app\n+ * classloader.\n+ */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ec48cbc4394ca2cfd402084c8c8f98540db104b"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1NTgxMzIwOnYy", "diffSide": "RIGHT", "path": "instrumentation/java-classloader/src/main/java/io/opentelemetry/instrumentation/auto/javaclassloader/ResourceInjectionInstrumentation.java", "isResolved": true, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwNToxOToxOFrOHRxD3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwNjo0NzozOVrOHRzGcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5MTY0Nw==", "bodyText": "do we have a use case for this? this doesn't seem very auto-instrumentation-y to me (backing off if app already has a particular resource present)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1172#discussion_r488391647", "createdAt": "2020-09-15T05:19:18Z", "author": {"login": "trask"}, "path": "instrumentation/java-classloader/src/main/java/io/opentelemetry/instrumentation/auto/javaclassloader/ResourceInjectionInstrumentation.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.javaclassloader;\n+\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.javaagent.bootstrap.HelperResources;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+/**\n+ * Instruments {@link ClassLoader} to have calls to get resources intercepted and check our map of\n+ * helper resources that is filled by instrumentation when they need helpers.\n+ */\n+@AutoService(Instrumenter.class)\n+public class ResourceInjectionInstrumentation extends Instrumenter.Default {\n+\n+  public ResourceInjectionInstrumentation() {\n+    super(\"class-loader\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return extendsClass(named(\"java.lang.ClassLoader\"));\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        isMethod().and(named(\"getResource\")).and(takesArguments(String.class)),\n+        ResourceInjectionInstrumentation.class.getName() + \"$GetResourceAdvice\");\n+\n+    transformers.put(\n+        isMethod().and(named(\"getResources\")).and(takesArguments(String.class)),\n+        ResourceInjectionInstrumentation.class.getName() + \"$GetResourcesAdvice\");\n+    return transformers;\n+  }\n+\n+  public static class GetResourceAdvice {\n+    @Advice.OnMethodExit(suppress = Throwable.class)\n+    public static void onExit(\n+        @Advice.This ClassLoader classLoader,\n+        @Advice.Argument(0) String name,\n+        @Advice.Return(readOnly = false) URL resourceUrl) {\n+      if (resourceUrl != null) {\n+        // Give their classloader precedence.\n+        return;\n+      }\n+\n+      resourceUrl = HelperResources.load(classLoader, name);\n+    }\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ec48cbc4394ca2cfd402084c8c8f98540db104b"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5NDEyOA==", "bodyText": "Hmm - don't think we have a use case. getResource won't help much in practice anyways since we're doing this mostly to interact with service loading mechanisms. It's here mostly for symmetry - on the flip side, lacking a use case, I lean towards being less intrusive into the app but what do you think?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1172#discussion_r488394128", "createdAt": "2020-09-15T05:27:48Z", "author": {"login": "anuraaga"}, "path": "instrumentation/java-classloader/src/main/java/io/opentelemetry/instrumentation/auto/javaclassloader/ResourceInjectionInstrumentation.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.javaclassloader;\n+\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.javaagent.bootstrap.HelperResources;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+/**\n+ * Instruments {@link ClassLoader} to have calls to get resources intercepted and check our map of\n+ * helper resources that is filled by instrumentation when they need helpers.\n+ */\n+@AutoService(Instrumenter.class)\n+public class ResourceInjectionInstrumentation extends Instrumenter.Default {\n+\n+  public ResourceInjectionInstrumentation() {\n+    super(\"class-loader\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return extendsClass(named(\"java.lang.ClassLoader\"));\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        isMethod().and(named(\"getResource\")).and(takesArguments(String.class)),\n+        ResourceInjectionInstrumentation.class.getName() + \"$GetResourceAdvice\");\n+\n+    transformers.put(\n+        isMethod().and(named(\"getResources\")).and(takesArguments(String.class)),\n+        ResourceInjectionInstrumentation.class.getName() + \"$GetResourcesAdvice\");\n+    return transformers;\n+  }\n+\n+  public static class GetResourceAdvice {\n+    @Advice.OnMethodExit(suppress = Throwable.class)\n+    public static void onExit(\n+        @Advice.This ClassLoader classLoader,\n+        @Advice.Argument(0) String name,\n+        @Advice.Return(readOnly = false) URL resourceUrl) {\n+      if (resourceUrl != null) {\n+        // Give their classloader precedence.\n+        return;\n+      }\n+\n+      resourceUrl = HelperResources.load(classLoader, name);\n+    }\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5MTY0Nw=="}, "originalCommit": {"oid": "3ec48cbc4394ca2cfd402084c8c8f98540db104b"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5ODQ4Mw==", "bodyText": "Without a use case, I would suggest removing instrumentation of getResource", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1172#discussion_r488398483", "createdAt": "2020-09-15T05:41:28Z", "author": {"login": "trask"}, "path": "instrumentation/java-classloader/src/main/java/io/opentelemetry/instrumentation/auto/javaclassloader/ResourceInjectionInstrumentation.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.javaclassloader;\n+\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.javaagent.bootstrap.HelperResources;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+/**\n+ * Instruments {@link ClassLoader} to have calls to get resources intercepted and check our map of\n+ * helper resources that is filled by instrumentation when they need helpers.\n+ */\n+@AutoService(Instrumenter.class)\n+public class ResourceInjectionInstrumentation extends Instrumenter.Default {\n+\n+  public ResourceInjectionInstrumentation() {\n+    super(\"class-loader\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return extendsClass(named(\"java.lang.ClassLoader\"));\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        isMethod().and(named(\"getResource\")).and(takesArguments(String.class)),\n+        ResourceInjectionInstrumentation.class.getName() + \"$GetResourceAdvice\");\n+\n+    transformers.put(\n+        isMethod().and(named(\"getResources\")).and(takesArguments(String.class)),\n+        ResourceInjectionInstrumentation.class.getName() + \"$GetResourcesAdvice\");\n+    return transformers;\n+  }\n+\n+  public static class GetResourceAdvice {\n+    @Advice.OnMethodExit(suppress = Throwable.class)\n+    public static void onExit(\n+        @Advice.This ClassLoader classLoader,\n+        @Advice.Argument(0) String name,\n+        @Advice.Return(readOnly = false) URL resourceUrl) {\n+      if (resourceUrl != null) {\n+        // Give their classloader precedence.\n+        return;\n+      }\n+\n+      resourceUrl = HelperResources.load(classLoader, name);\n+    }\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5MTY0Nw=="}, "originalCommit": {"oid": "3ec48cbc4394ca2cfd402084c8c8f98540db104b"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODQwNTI0MQ==", "bodyText": "Now I am confused: how this resource injection works without this instrumentation?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1172#discussion_r488405241", "createdAt": "2020-09-15T06:00:06Z", "author": {"login": "iNikem"}, "path": "instrumentation/java-classloader/src/main/java/io/opentelemetry/instrumentation/auto/javaclassloader/ResourceInjectionInstrumentation.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.javaclassloader;\n+\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.javaagent.bootstrap.HelperResources;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+/**\n+ * Instruments {@link ClassLoader} to have calls to get resources intercepted and check our map of\n+ * helper resources that is filled by instrumentation when they need helpers.\n+ */\n+@AutoService(Instrumenter.class)\n+public class ResourceInjectionInstrumentation extends Instrumenter.Default {\n+\n+  public ResourceInjectionInstrumentation() {\n+    super(\"class-loader\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return extendsClass(named(\"java.lang.ClassLoader\"));\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        isMethod().and(named(\"getResource\")).and(takesArguments(String.class)),\n+        ResourceInjectionInstrumentation.class.getName() + \"$GetResourceAdvice\");\n+\n+    transformers.put(\n+        isMethod().and(named(\"getResources\")).and(takesArguments(String.class)),\n+        ResourceInjectionInstrumentation.class.getName() + \"$GetResourcesAdvice\");\n+    return transformers;\n+  }\n+\n+  public static class GetResourceAdvice {\n+    @Advice.OnMethodExit(suppress = Throwable.class)\n+    public static void onExit(\n+        @Advice.This ClassLoader classLoader,\n+        @Advice.Argument(0) String name,\n+        @Advice.Return(readOnly = false) URL resourceUrl) {\n+      if (resourceUrl != null) {\n+        // Give their classloader precedence.\n+        return;\n+      }\n+\n+      resourceUrl = HelperResources.load(classLoader, name);\n+    }\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5MTY0Nw=="}, "originalCommit": {"oid": "3ec48cbc4394ca2cfd402084c8c8f98540db104b"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODQwNjQ3OA==", "bodyText": "Service loading mechanisms call getResources, not getResource, since they need to find all the classes of an interface usually. So getResource isn't really used in practice. But @trask does this potential confusion make the case that we should stick to symmetry here?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1172#discussion_r488406478", "createdAt": "2020-09-15T06:03:26Z", "author": {"login": "anuraaga"}, "path": "instrumentation/java-classloader/src/main/java/io/opentelemetry/instrumentation/auto/javaclassloader/ResourceInjectionInstrumentation.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.javaclassloader;\n+\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.javaagent.bootstrap.HelperResources;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+/**\n+ * Instruments {@link ClassLoader} to have calls to get resources intercepted and check our map of\n+ * helper resources that is filled by instrumentation when they need helpers.\n+ */\n+@AutoService(Instrumenter.class)\n+public class ResourceInjectionInstrumentation extends Instrumenter.Default {\n+\n+  public ResourceInjectionInstrumentation() {\n+    super(\"class-loader\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return extendsClass(named(\"java.lang.ClassLoader\"));\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        isMethod().and(named(\"getResource\")).and(takesArguments(String.class)),\n+        ResourceInjectionInstrumentation.class.getName() + \"$GetResourceAdvice\");\n+\n+    transformers.put(\n+        isMethod().and(named(\"getResources\")).and(takesArguments(String.class)),\n+        ResourceInjectionInstrumentation.class.getName() + \"$GetResourcesAdvice\");\n+    return transformers;\n+  }\n+\n+  public static class GetResourceAdvice {\n+    @Advice.OnMethodExit(suppress = Throwable.class)\n+    public static void onExit(\n+        @Advice.This ClassLoader classLoader,\n+        @Advice.Argument(0) String name,\n+        @Advice.Return(readOnly = false) URL resourceUrl) {\n+      if (resourceUrl != null) {\n+        // Give their classloader precedence.\n+        return;\n+      }\n+\n+      resourceUrl = HelperResources.load(classLoader, name);\n+    }\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5MTY0Nw=="}, "originalCommit": {"oid": "3ec48cbc4394ca2cfd402084c8c8f98540db104b"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODQwODEyMg==", "bodyText": "That should definitely be documented :)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1172#discussion_r488408122", "createdAt": "2020-09-15T06:07:26Z", "author": {"login": "iNikem"}, "path": "instrumentation/java-classloader/src/main/java/io/opentelemetry/instrumentation/auto/javaclassloader/ResourceInjectionInstrumentation.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.javaclassloader;\n+\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.javaagent.bootstrap.HelperResources;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+/**\n+ * Instruments {@link ClassLoader} to have calls to get resources intercepted and check our map of\n+ * helper resources that is filled by instrumentation when they need helpers.\n+ */\n+@AutoService(Instrumenter.class)\n+public class ResourceInjectionInstrumentation extends Instrumenter.Default {\n+\n+  public ResourceInjectionInstrumentation() {\n+    super(\"class-loader\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return extendsClass(named(\"java.lang.ClassLoader\"));\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        isMethod().and(named(\"getResource\")).and(takesArguments(String.class)),\n+        ResourceInjectionInstrumentation.class.getName() + \"$GetResourceAdvice\");\n+\n+    transformers.put(\n+        isMethod().and(named(\"getResources\")).and(takesArguments(String.class)),\n+        ResourceInjectionInstrumentation.class.getName() + \"$GetResourcesAdvice\");\n+    return transformers;\n+  }\n+\n+  public static class GetResourceAdvice {\n+    @Advice.OnMethodExit(suppress = Throwable.class)\n+    public static void onExit(\n+        @Advice.This ClassLoader classLoader,\n+        @Advice.Argument(0) String name,\n+        @Advice.Return(readOnly = false) URL resourceUrl) {\n+      if (resourceUrl != null) {\n+        // Give their classloader precedence.\n+        return;\n+      }\n+\n+      resourceUrl = HelperResources.load(classLoader, name);\n+    }\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5MTY0Nw=="}, "originalCommit": {"oid": "3ec48cbc4394ca2cfd402084c8c8f98540db104b"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODQxNDk5OA==", "bodyText": "I'm not sure if that's the right implementation for getResource (singular) instrumentation, e.g. we may want to merge contents in some way, but it's hard to know without a use case, so would suggest we remove it until we need it", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1172#discussion_r488414998", "createdAt": "2020-09-15T06:24:13Z", "author": {"login": "trask"}, "path": "instrumentation/java-classloader/src/main/java/io/opentelemetry/instrumentation/auto/javaclassloader/ResourceInjectionInstrumentation.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.javaclassloader;\n+\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.javaagent.bootstrap.HelperResources;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+/**\n+ * Instruments {@link ClassLoader} to have calls to get resources intercepted and check our map of\n+ * helper resources that is filled by instrumentation when they need helpers.\n+ */\n+@AutoService(Instrumenter.class)\n+public class ResourceInjectionInstrumentation extends Instrumenter.Default {\n+\n+  public ResourceInjectionInstrumentation() {\n+    super(\"class-loader\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return extendsClass(named(\"java.lang.ClassLoader\"));\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        isMethod().and(named(\"getResource\")).and(takesArguments(String.class)),\n+        ResourceInjectionInstrumentation.class.getName() + \"$GetResourceAdvice\");\n+\n+    transformers.put(\n+        isMethod().and(named(\"getResources\")).and(takesArguments(String.class)),\n+        ResourceInjectionInstrumentation.class.getName() + \"$GetResourcesAdvice\");\n+    return transformers;\n+  }\n+\n+  public static class GetResourceAdvice {\n+    @Advice.OnMethodExit(suppress = Throwable.class)\n+    public static void onExit(\n+        @Advice.This ClassLoader classLoader,\n+        @Advice.Argument(0) String name,\n+        @Advice.Return(readOnly = false) URL resourceUrl) {\n+      if (resourceUrl != null) {\n+        // Give their classloader precedence.\n+        return;\n+      }\n+\n+      resourceUrl = HelperResources.load(classLoader, name);\n+    }\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5MTY0Nw=="}, "originalCommit": {"oid": "3ec48cbc4394ca2cfd402084c8c8f98540db104b"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODQyNTA3Mg==", "bodyText": "Makes sense - deleted", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1172#discussion_r488425072", "createdAt": "2020-09-15T06:47:39Z", "author": {"login": "anuraaga"}, "path": "instrumentation/java-classloader/src/main/java/io/opentelemetry/instrumentation/auto/javaclassloader/ResourceInjectionInstrumentation.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.javaclassloader;\n+\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.javaagent.bootstrap.HelperResources;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+/**\n+ * Instruments {@link ClassLoader} to have calls to get resources intercepted and check our map of\n+ * helper resources that is filled by instrumentation when they need helpers.\n+ */\n+@AutoService(Instrumenter.class)\n+public class ResourceInjectionInstrumentation extends Instrumenter.Default {\n+\n+  public ResourceInjectionInstrumentation() {\n+    super(\"class-loader\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return extendsClass(named(\"java.lang.ClassLoader\"));\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        isMethod().and(named(\"getResource\")).and(takesArguments(String.class)),\n+        ResourceInjectionInstrumentation.class.getName() + \"$GetResourceAdvice\");\n+\n+    transformers.put(\n+        isMethod().and(named(\"getResources\")).and(takesArguments(String.class)),\n+        ResourceInjectionInstrumentation.class.getName() + \"$GetResourcesAdvice\");\n+    return transformers;\n+  }\n+\n+  public static class GetResourceAdvice {\n+    @Advice.OnMethodExit(suppress = Throwable.class)\n+    public static void onExit(\n+        @Advice.This ClassLoader classLoader,\n+        @Advice.Argument(0) String name,\n+        @Advice.Return(readOnly = false) URL resourceUrl) {\n+      if (resourceUrl != null) {\n+        // Give their classloader precedence.\n+        return;\n+      }\n+\n+      resourceUrl = HelperResources.load(classLoader, name);\n+    }\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5MTY0Nw=="}, "originalCommit": {"oid": "3ec48cbc4394ca2cfd402084c8c8f98540db104b"}, "originalPosition": 80}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4881, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}