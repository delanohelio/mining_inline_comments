{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM5OTEwOTgx", "number": 1908, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwNjo1NTo1MVrOFFbVVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwNjo1NTo1MVrOFFbVVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMjM1MDI5OnYy", "diffSide": "RIGHT", "path": "instrumentation/http-url-connection/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/httpurlconnection/HttpUrlConnectionInstrumentationModule.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwNjo1NTo1MVrOIF7rXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQyMzoxNDoxOVrOIGkPFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA5MTU1MA==", "bodyText": "We don't have similar condition in other instrumentations, right? Why do we need it here?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1908#discussion_r543091550", "createdAt": "2020-12-15T06:55:51Z", "author": {"login": "iNikem"}, "path": "instrumentation/http-url-connection/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/httpurlconnection/HttpUrlConnectionInstrumentationModule.java", "diffHunk": "@@ -79,75 +81,65 @@ public HttpUrlConnectionInstrumentationModule() {\n   public static class HttpUrlConnectionAdvice {\n \n     @Advice.OnMethodEnter(suppress = Throwable.class)\n-    public static HttpUrlState methodEnter(\n+    public static void methodEnter(\n         @Advice.This HttpURLConnection connection,\n         @Advice.FieldValue(\"connected\") boolean connected,\n-        @Advice.Local(\"otelScope\") Scope scope) {\n-\n-      int callDepth = CallDepthThreadLocalMap.incrementCallDepth(HttpURLConnection.class);\n-      if (callDepth > 0) {\n-        return null;\n+        @Advice.Local(\"otelContext\") Context context,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") CallDepth callDepth) {\n+\n+      callDepth = CallDepthThreadLocalMap.getCallDepth(HttpURLConnection.class);\n+      if (callDepth.getAndIncrement() > 0) {\n+        // only want the rest of the instrumentation rules (which are complex enough) to apply to\n+        // top-level HttpURLConnection calls\n+        return;\n+      }\n+      Context parentContext = currentContext();\n+      if (!tracer().shouldStartSpan(parentContext)) {\n+        return;\n       }\n \n-      ContextStore<HttpURLConnection, HttpUrlState> contextStore =\n-          InstrumentationContext.get(HttpURLConnection.class, HttpUrlState.class);\n-      HttpUrlState state = contextStore.putIfAbsent(connection, HttpUrlState::new);\n-\n-      synchronized (state) {\n-        if (!state.initialized) {\n-          Context parentContext = currentContext();\n-          if (tracer().shouldStartSpan(parentContext)) {\n-            state.context = tracer().startSpan(parentContext, connection, connection);\n-            if (!connected) {\n-              scope = state.context.makeCurrent();\n-            }\n-          }\n-          state.initialized = true;\n-        }\n+      // putting into storage for a couple of reasons:\n+      // - to start an operation in connect() and end it in getInputStream()\n+      // - to avoid creating new operation on multiple subsequent calls to getInputStream()\n+      ContextStore<HttpURLConnection, Context> storage =\n+          InstrumentationContext.get(HttpURLConnection.class, Context.class);\n+      context = storage.get(connection);\n+\n+      if (context == null) {\n+        context = tracer().startSpan(parentContext, connection);\n+        storage.put(connection, context);\n       }\n-      return state;\n+\n+      scope = context.makeCurrent();\n     }\n \n     @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n     public static void methodExit(\n-        @Advice.Enter HttpUrlState state,\n         @Advice.This HttpURLConnection connection,\n         @Advice.FieldValue(\"responseCode\") int responseCode,\n         @Advice.Thrown Throwable throwable,\n         @Advice.Origin(\"#m\") String methodName,\n-        @Advice.Local(\"otelScope\") Scope scope) {\n-\n-      if (scope != null) {\n-        scope.close();\n+        @Advice.Local(\"otelContext\") Context context,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") CallDepth callDepth) {\n+      if (callDepth.decrementAndGet() > 0) {\n+        return;\n       }\n-      if (state == null) {\n+      if (scope == null) {\n         return;\n       }\n-      CallDepthThreadLocalMap.reset(HttpURLConnection.class);\n-\n-      synchronized (state) {\n-        if (state.context != null && !state.finished) {\n-          if (throwable != null) {\n-            tracer().endExceptionally(state.context, throwable);\n-            state.finished = true;\n-          } else if (\"getInputStream\".equals(methodName)) {\n-            // responseCode field is sometimes not populated.\n-            // We can't call getResponseCode() due to some unwanted side-effects\n-            // (e.g. breaks getOutputStream).\n-            if (responseCode > 0) {\n-              tracer().end(state.context, new HttpUrlResponse(connection, responseCode));\n-              state.finished = true;\n-            }\n-          }\n+      scope.close();\n+      if (Span.fromContext(context).isRecording()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9bff43281b156650b3e06df48baf8c16c52fcb2"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzMzNTk1NA==", "bodyText": "isRecording() is the same as previous !state.finished. No idea why it was used here though", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1908#discussion_r543335954", "createdAt": "2020-12-15T13:22:21Z", "author": {"login": "mateuszrzeszutek"}, "path": "instrumentation/http-url-connection/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/httpurlconnection/HttpUrlConnectionInstrumentationModule.java", "diffHunk": "@@ -79,75 +81,65 @@ public HttpUrlConnectionInstrumentationModule() {\n   public static class HttpUrlConnectionAdvice {\n \n     @Advice.OnMethodEnter(suppress = Throwable.class)\n-    public static HttpUrlState methodEnter(\n+    public static void methodEnter(\n         @Advice.This HttpURLConnection connection,\n         @Advice.FieldValue(\"connected\") boolean connected,\n-        @Advice.Local(\"otelScope\") Scope scope) {\n-\n-      int callDepth = CallDepthThreadLocalMap.incrementCallDepth(HttpURLConnection.class);\n-      if (callDepth > 0) {\n-        return null;\n+        @Advice.Local(\"otelContext\") Context context,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") CallDepth callDepth) {\n+\n+      callDepth = CallDepthThreadLocalMap.getCallDepth(HttpURLConnection.class);\n+      if (callDepth.getAndIncrement() > 0) {\n+        // only want the rest of the instrumentation rules (which are complex enough) to apply to\n+        // top-level HttpURLConnection calls\n+        return;\n+      }\n+      Context parentContext = currentContext();\n+      if (!tracer().shouldStartSpan(parentContext)) {\n+        return;\n       }\n \n-      ContextStore<HttpURLConnection, HttpUrlState> contextStore =\n-          InstrumentationContext.get(HttpURLConnection.class, HttpUrlState.class);\n-      HttpUrlState state = contextStore.putIfAbsent(connection, HttpUrlState::new);\n-\n-      synchronized (state) {\n-        if (!state.initialized) {\n-          Context parentContext = currentContext();\n-          if (tracer().shouldStartSpan(parentContext)) {\n-            state.context = tracer().startSpan(parentContext, connection, connection);\n-            if (!connected) {\n-              scope = state.context.makeCurrent();\n-            }\n-          }\n-          state.initialized = true;\n-        }\n+      // putting into storage for a couple of reasons:\n+      // - to start an operation in connect() and end it in getInputStream()\n+      // - to avoid creating new operation on multiple subsequent calls to getInputStream()\n+      ContextStore<HttpURLConnection, Context> storage =\n+          InstrumentationContext.get(HttpURLConnection.class, Context.class);\n+      context = storage.get(connection);\n+\n+      if (context == null) {\n+        context = tracer().startSpan(parentContext, connection);\n+        storage.put(connection, context);\n       }\n-      return state;\n+\n+      scope = context.makeCurrent();\n     }\n \n     @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n     public static void methodExit(\n-        @Advice.Enter HttpUrlState state,\n         @Advice.This HttpURLConnection connection,\n         @Advice.FieldValue(\"responseCode\") int responseCode,\n         @Advice.Thrown Throwable throwable,\n         @Advice.Origin(\"#m\") String methodName,\n-        @Advice.Local(\"otelScope\") Scope scope) {\n-\n-      if (scope != null) {\n-        scope.close();\n+        @Advice.Local(\"otelContext\") Context context,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") CallDepth callDepth) {\n+      if (callDepth.decrementAndGet() > 0) {\n+        return;\n       }\n-      if (state == null) {\n+      if (scope == null) {\n         return;\n       }\n-      CallDepthThreadLocalMap.reset(HttpURLConnection.class);\n-\n-      synchronized (state) {\n-        if (state.context != null && !state.finished) {\n-          if (throwable != null) {\n-            tracer().endExceptionally(state.context, throwable);\n-            state.finished = true;\n-          } else if (\"getInputStream\".equals(methodName)) {\n-            // responseCode field is sometimes not populated.\n-            // We can't call getResponseCode() due to some unwanted side-effects\n-            // (e.g. breaks getOutputStream).\n-            if (responseCode > 0) {\n-              tracer().end(state.context, new HttpUrlResponse(connection, responseCode));\n-              state.finished = true;\n-            }\n-          }\n+      scope.close();\n+      if (Span.fromContext(context).isRecording()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA5MTU1MA=="}, "originalCommit": {"oid": "f9bff43281b156650b3e06df48baf8c16c52fcb2"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc1NjA1Mg==", "bodyText": "It's needed here because HttpURLConnection is a messy API and so instrumenting it is messy.\nBut I do think of checking isRecording as more of an optimization for avoiding costly things when Sampling is enabled, so think the usage here is a bit confusing, so brought back HttpUrlState.finished to track this (and added more comments).", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1908#discussion_r543756052", "createdAt": "2020-12-15T23:14:19Z", "author": {"login": "trask"}, "path": "instrumentation/http-url-connection/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/httpurlconnection/HttpUrlConnectionInstrumentationModule.java", "diffHunk": "@@ -79,75 +81,65 @@ public HttpUrlConnectionInstrumentationModule() {\n   public static class HttpUrlConnectionAdvice {\n \n     @Advice.OnMethodEnter(suppress = Throwable.class)\n-    public static HttpUrlState methodEnter(\n+    public static void methodEnter(\n         @Advice.This HttpURLConnection connection,\n         @Advice.FieldValue(\"connected\") boolean connected,\n-        @Advice.Local(\"otelScope\") Scope scope) {\n-\n-      int callDepth = CallDepthThreadLocalMap.incrementCallDepth(HttpURLConnection.class);\n-      if (callDepth > 0) {\n-        return null;\n+        @Advice.Local(\"otelContext\") Context context,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") CallDepth callDepth) {\n+\n+      callDepth = CallDepthThreadLocalMap.getCallDepth(HttpURLConnection.class);\n+      if (callDepth.getAndIncrement() > 0) {\n+        // only want the rest of the instrumentation rules (which are complex enough) to apply to\n+        // top-level HttpURLConnection calls\n+        return;\n+      }\n+      Context parentContext = currentContext();\n+      if (!tracer().shouldStartSpan(parentContext)) {\n+        return;\n       }\n \n-      ContextStore<HttpURLConnection, HttpUrlState> contextStore =\n-          InstrumentationContext.get(HttpURLConnection.class, HttpUrlState.class);\n-      HttpUrlState state = contextStore.putIfAbsent(connection, HttpUrlState::new);\n-\n-      synchronized (state) {\n-        if (!state.initialized) {\n-          Context parentContext = currentContext();\n-          if (tracer().shouldStartSpan(parentContext)) {\n-            state.context = tracer().startSpan(parentContext, connection, connection);\n-            if (!connected) {\n-              scope = state.context.makeCurrent();\n-            }\n-          }\n-          state.initialized = true;\n-        }\n+      // putting into storage for a couple of reasons:\n+      // - to start an operation in connect() and end it in getInputStream()\n+      // - to avoid creating new operation on multiple subsequent calls to getInputStream()\n+      ContextStore<HttpURLConnection, Context> storage =\n+          InstrumentationContext.get(HttpURLConnection.class, Context.class);\n+      context = storage.get(connection);\n+\n+      if (context == null) {\n+        context = tracer().startSpan(parentContext, connection);\n+        storage.put(connection, context);\n       }\n-      return state;\n+\n+      scope = context.makeCurrent();\n     }\n \n     @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n     public static void methodExit(\n-        @Advice.Enter HttpUrlState state,\n         @Advice.This HttpURLConnection connection,\n         @Advice.FieldValue(\"responseCode\") int responseCode,\n         @Advice.Thrown Throwable throwable,\n         @Advice.Origin(\"#m\") String methodName,\n-        @Advice.Local(\"otelScope\") Scope scope) {\n-\n-      if (scope != null) {\n-        scope.close();\n+        @Advice.Local(\"otelContext\") Context context,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") CallDepth callDepth) {\n+      if (callDepth.decrementAndGet() > 0) {\n+        return;\n       }\n-      if (state == null) {\n+      if (scope == null) {\n         return;\n       }\n-      CallDepthThreadLocalMap.reset(HttpURLConnection.class);\n-\n-      synchronized (state) {\n-        if (state.context != null && !state.finished) {\n-          if (throwable != null) {\n-            tracer().endExceptionally(state.context, throwable);\n-            state.finished = true;\n-          } else if (\"getInputStream\".equals(methodName)) {\n-            // responseCode field is sometimes not populated.\n-            // We can't call getResponseCode() due to some unwanted side-effects\n-            // (e.g. breaks getOutputStream).\n-            if (responseCode > 0) {\n-              tracer().end(state.context, new HttpUrlResponse(connection, responseCode));\n-              state.finished = true;\n-            }\n-          }\n+      scope.close();\n+      if (Span.fromContext(context).isRecording()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA5MTU1MA=="}, "originalCommit": {"oid": "f9bff43281b156650b3e06df48baf8c16c52fcb2"}, "originalPosition": 126}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4372, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}