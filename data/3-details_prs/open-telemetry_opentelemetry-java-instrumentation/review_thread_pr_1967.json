{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQ2MTUxNjYy", "number": 1967, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMjoyNzowN1rOFLdx3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwMDo1MjozNVrOFLgJlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NTY2NTU5OnYy", "diffSide": "RIGHT", "path": "smoke-tests/src/test/groovy/io/opentelemetry/smoketest/AppServerTest.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMjoyNzowN1rOIOp13Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwMDo0NzozOVrOIOtScg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIzNjUwOQ==", "bodyText": "overriding the method in JettySmokeTest doesn't work?\nwhat about assumeTrue(this.getClass() != JettySmokeTest)? (then wouldn't need to keep track of currentTestClass)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1967#discussion_r552236509", "createdAt": "2021-01-05T22:27:07Z", "author": {"login": "trask"}, "path": "smoke-tests/src/test/groovy/io/opentelemetry/smoketest/AppServerTest.groovy", "diffHunk": "@@ -9,17 +9,33 @@ import io.opentelemetry.proto.trace.v1.Span\n import java.util.jar.Attributes\n import java.util.jar.JarFile\n import okhttp3.Request\n+import org.junit.runner.RunWith\n+import spock.lang.IgnoreIf\n+import spock.lang.Shared\n import spock.lang.Unroll\n \n+@RunWith(AppServerTestRunner)\n abstract class AppServerTest extends SmokeTest {\n+  @Shared\n+  String jdk\n+  @Shared\n+  String serverVersion\n+\n+  def setupSpec() {\n+    AppServer a = AppServerTestRunner.currentAppServer(this.getClass())\n+    serverVersion = a.version()\n+    jdk = a.jdk()\n+    startTarget(jdk, serverVersion)\n+  }\n+\n+  def cleanupSpec() {\n+    stopTarget()\n+  }\n \n   //TODO add assert that server spans were created by servers, not by servlets\n   @Unroll\n+  @IgnoreIf({ AppServerTestRunner.currentTestClass() == JettySmokeTest })\n   def \"#appServer smoke test on JDK #jdk\"(String appServer, String jdk) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78eb8b7e47c4fba404a0480318187f6c266ff5e2"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI5Mjk3OA==", "bodyText": "Overriding didn't work when I tried it. Changed tests to use assumeTrue which I like much more than IgnoreIf.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1967#discussion_r552292978", "createdAt": "2021-01-06T00:47:39Z", "author": {"login": "laurit"}, "path": "smoke-tests/src/test/groovy/io/opentelemetry/smoketest/AppServerTest.groovy", "diffHunk": "@@ -9,17 +9,33 @@ import io.opentelemetry.proto.trace.v1.Span\n import java.util.jar.Attributes\n import java.util.jar.JarFile\n import okhttp3.Request\n+import org.junit.runner.RunWith\n+import spock.lang.IgnoreIf\n+import spock.lang.Shared\n import spock.lang.Unroll\n \n+@RunWith(AppServerTestRunner)\n abstract class AppServerTest extends SmokeTest {\n+  @Shared\n+  String jdk\n+  @Shared\n+  String serverVersion\n+\n+  def setupSpec() {\n+    AppServer a = AppServerTestRunner.currentAppServer(this.getClass())\n+    serverVersion = a.version()\n+    jdk = a.jdk()\n+    startTarget(jdk, serverVersion)\n+  }\n+\n+  def cleanupSpec() {\n+    stopTarget()\n+  }\n \n   //TODO add assert that server spans were created by servers, not by servlets\n   @Unroll\n+  @IgnoreIf({ AppServerTestRunner.currentTestClass() == JettySmokeTest })\n   def \"#appServer smoke test on JDK #jdk\"(String appServer, String jdk) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIzNjUwOQ=="}, "originalCommit": {"oid": "78eb8b7e47c4fba404a0480318187f6c266ff5e2"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NTc2MDA5OnYy", "diffSide": "RIGHT", "path": "smoke-tests/src/test/java/io/opentelemetry/smoketest/AppServerTestRunner.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMzowMzo1MlrOIOquYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwMDowOToyMlrOIOsJtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI1MDk3OA==", "bodyText": "can this be ThreadLocal<AppServer> currentAppServer?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1967#discussion_r552250978", "createdAt": "2021-01-05T23:03:52Z", "author": {"login": "trask"}, "path": "smoke-tests/src/test/java/io/opentelemetry/smoketest/AppServerTestRunner.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.smoketest;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.junit.runner.Description;\n+import org.junit.runner.notification.RunNotifier;\n+import org.junit.runners.model.InitializationError;\n+import org.spockframework.runtime.Sputnik;\n+\n+/**\n+ * Customized spock test runner that runs tests on multiple app server versions based on {@link\n+ * AppServer} annotations. This runner selects first server based on {@link AppServer} annotation\n+ * calls setupSpec, all test method and cleanupSpec, selects next {@link AppServer} and calls the\n+ * same methods. This process is repeated until tests have run for all {@link AppServer}\n+ * annotations. Tests should start server in setupSpec and stop it in cleanupSpec.\n+ */\n+public class AppServerTestRunner extends Sputnik {\n+  private static final Map<Class<?>, AppServer> runningAppServer =\n+      Collections.synchronizedMap(new HashMap<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78eb8b7e47c4fba404a0480318187f6c266ff5e2"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI3NDM1Nw==", "bodyText": "I didn't use ThreadLocal because of spockframework/spock#67 Apparently there is a way to run tests in parallel (which I believe we don't use). Using a Map seemed like a safer choice.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1967#discussion_r552274357", "createdAt": "2021-01-06T00:09:22Z", "author": {"login": "laurit"}, "path": "smoke-tests/src/test/java/io/opentelemetry/smoketest/AppServerTestRunner.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.smoketest;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.junit.runner.Description;\n+import org.junit.runner.notification.RunNotifier;\n+import org.junit.runners.model.InitializationError;\n+import org.spockframework.runtime.Sputnik;\n+\n+/**\n+ * Customized spock test runner that runs tests on multiple app server versions based on {@link\n+ * AppServer} annotations. This runner selects first server based on {@link AppServer} annotation\n+ * calls setupSpec, all test method and cleanupSpec, selects next {@link AppServer} and calls the\n+ * same methods. This process is repeated until tests have run for all {@link AppServer}\n+ * annotations. Tests should start server in setupSpec and stop it in cleanupSpec.\n+ */\n+public class AppServerTestRunner extends Sputnik {\n+  private static final Map<Class<?>, AppServer> runningAppServer =\n+      Collections.synchronizedMap(new HashMap<>());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI1MDk3OA=="}, "originalCommit": {"oid": "78eb8b7e47c4fba404a0480318187f6c266ff5e2"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NTc2MjQzOnYy", "diffSide": "RIGHT", "path": "smoke-tests/src/test/java/io/opentelemetry/smoketest/AppServerTestRunner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMzowNTowM1rOIOqv8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMzowNTowM1rOIOqv8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI1MTM3OQ==", "bodyText": "we use \"standard\" Java verbosity level \ud83d\ude04\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  for (AppServer a : appServers) {\n          \n          \n            \n                  for (AppServer appServer : appServers) {", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1967#discussion_r552251379", "createdAt": "2021-01-05T23:05:03Z", "author": {"login": "trask"}, "path": "smoke-tests/src/test/java/io/opentelemetry/smoketest/AppServerTestRunner.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.smoketest;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.junit.runner.Description;\n+import org.junit.runner.notification.RunNotifier;\n+import org.junit.runners.model.InitializationError;\n+import org.spockframework.runtime.Sputnik;\n+\n+/**\n+ * Customized spock test runner that runs tests on multiple app server versions based on {@link\n+ * AppServer} annotations. This runner selects first server based on {@link AppServer} annotation\n+ * calls setupSpec, all test method and cleanupSpec, selects next {@link AppServer} and calls the\n+ * same methods. This process is repeated until tests have run for all {@link AppServer}\n+ * annotations. Tests should start server in setupSpec and stop it in cleanupSpec.\n+ */\n+public class AppServerTestRunner extends Sputnik {\n+  private static final Map<Class<?>, AppServer> runningAppServer =\n+      Collections.synchronizedMap(new HashMap<>());\n+  private static final ThreadLocal<Class<?>> currentTestClass = new ThreadLocal<>();\n+  private final Class<?> testClass;\n+  private final AppServer[] appServers;\n+\n+  public AppServerTestRunner(Class<?> clazz) throws InitializationError {\n+    super(clazz);\n+    testClass = clazz;\n+    appServers = clazz.getAnnotationsByType(AppServer.class);\n+    if (appServers.length == 0) {\n+      throw new IllegalStateException(\"Add AppServer or AppServers annotation to test class\");\n+    }\n+  }\n+\n+  @Override\n+  public void run(RunNotifier notifier) {\n+    // run tests for all app servers\n+    try {\n+      for (AppServer a : appServers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78eb8b7e47c4fba404a0480318187f6c266ff5e2"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NTc2NDA2OnYy", "diffSide": "RIGHT", "path": "smoke-tests/src/test/java/io/opentelemetry/smoketest/AppServerTestRunner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMzowNTo0NVrOIOqw4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMzowNTo0NVrOIOqw4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI1MTYxNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                AppServer a = runningAppServer.get(testClass);\n          \n          \n            \n                AppServer appServer = runningAppServer.get(testClass);", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1967#discussion_r552251616", "createdAt": "2021-01-05T23:05:45Z", "author": {"login": "trask"}, "path": "smoke-tests/src/test/java/io/opentelemetry/smoketest/AppServerTestRunner.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.smoketest;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.junit.runner.Description;\n+import org.junit.runner.notification.RunNotifier;\n+import org.junit.runners.model.InitializationError;\n+import org.spockframework.runtime.Sputnik;\n+\n+/**\n+ * Customized spock test runner that runs tests on multiple app server versions based on {@link\n+ * AppServer} annotations. This runner selects first server based on {@link AppServer} annotation\n+ * calls setupSpec, all test method and cleanupSpec, selects next {@link AppServer} and calls the\n+ * same methods. This process is repeated until tests have run for all {@link AppServer}\n+ * annotations. Tests should start server in setupSpec and stop it in cleanupSpec.\n+ */\n+public class AppServerTestRunner extends Sputnik {\n+  private static final Map<Class<?>, AppServer> runningAppServer =\n+      Collections.synchronizedMap(new HashMap<>());\n+  private static final ThreadLocal<Class<?>> currentTestClass = new ThreadLocal<>();\n+  private final Class<?> testClass;\n+  private final AppServer[] appServers;\n+\n+  public AppServerTestRunner(Class<?> clazz) throws InitializationError {\n+    super(clazz);\n+    testClass = clazz;\n+    appServers = clazz.getAnnotationsByType(AppServer.class);\n+    if (appServers.length == 0) {\n+      throw new IllegalStateException(\"Add AppServer or AppServers annotation to test class\");\n+    }\n+  }\n+\n+  @Override\n+  public void run(RunNotifier notifier) {\n+    // run tests for all app servers\n+    try {\n+      for (AppServer a : appServers) {\n+        runningAppServer.put(testClass, a);\n+        super.run(notifier);\n+      }\n+    } finally {\n+      runningAppServer.remove(testClass);\n+    }\n+  }\n+\n+  @Override\n+  public Description getDescription() {\n+    //\n+    currentTestClass.set(testClass);\n+    try {\n+      return super.getDescription();\n+    } finally {\n+      currentTestClass.remove();\n+    }\n+  }\n+\n+  // expose currently running app server\n+  // used to get current server and jvm version inside the test class\n+  public static AppServer currentAppServer(Class<?> testClass) {\n+    AppServer a = runningAppServer.get(testClass);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78eb8b7e47c4fba404a0480318187f6c266ff5e2"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NTc4NjA1OnYy", "diffSide": "RIGHT", "path": "smoke-tests/src/test/java/io/opentelemetry/smoketest/AppServerTestRunner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMzoxNToxMVrOIOq98A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMzoxNToxMVrOIOq98A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI1NDk2MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Class<?> c = currentTestClass.get();\n          \n          \n            \n                Class<?> testClass = currentTestClass.get();", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1967#discussion_r552254960", "createdAt": "2021-01-05T23:15:11Z", "author": {"login": "trask"}, "path": "smoke-tests/src/test/java/io/opentelemetry/smoketest/AppServerTestRunner.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.smoketest;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.junit.runner.Description;\n+import org.junit.runner.notification.RunNotifier;\n+import org.junit.runners.model.InitializationError;\n+import org.spockframework.runtime.Sputnik;\n+\n+/**\n+ * Customized spock test runner that runs tests on multiple app server versions based on {@link\n+ * AppServer} annotations. This runner selects first server based on {@link AppServer} annotation\n+ * calls setupSpec, all test method and cleanupSpec, selects next {@link AppServer} and calls the\n+ * same methods. This process is repeated until tests have run for all {@link AppServer}\n+ * annotations. Tests should start server in setupSpec and stop it in cleanupSpec.\n+ */\n+public class AppServerTestRunner extends Sputnik {\n+  private static final Map<Class<?>, AppServer> runningAppServer =\n+      Collections.synchronizedMap(new HashMap<>());\n+  private static final ThreadLocal<Class<?>> currentTestClass = new ThreadLocal<>();\n+  private final Class<?> testClass;\n+  private final AppServer[] appServers;\n+\n+  public AppServerTestRunner(Class<?> clazz) throws InitializationError {\n+    super(clazz);\n+    testClass = clazz;\n+    appServers = clazz.getAnnotationsByType(AppServer.class);\n+    if (appServers.length == 0) {\n+      throw new IllegalStateException(\"Add AppServer or AppServers annotation to test class\");\n+    }\n+  }\n+\n+  @Override\n+  public void run(RunNotifier notifier) {\n+    // run tests for all app servers\n+    try {\n+      for (AppServer a : appServers) {\n+        runningAppServer.put(testClass, a);\n+        super.run(notifier);\n+      }\n+    } finally {\n+      runningAppServer.remove(testClass);\n+    }\n+  }\n+\n+  @Override\n+  public Description getDescription() {\n+    //\n+    currentTestClass.set(testClass);\n+    try {\n+      return super.getDescription();\n+    } finally {\n+      currentTestClass.remove();\n+    }\n+  }\n+\n+  // expose currently running app server\n+  // used to get current server and jvm version inside the test class\n+  public static AppServer currentAppServer(Class<?> testClass) {\n+    AppServer a = runningAppServer.get(testClass);\n+    if (a == null) {\n+      throw new IllegalStateException(\"Test not running for \" + testClass);\n+    }\n+    return a;\n+  }\n+\n+  // expose current test class\n+  // used for ignoring tests defined in base class that are expected to fail\n+  // on currently running server\n+  public static Class<?> currentTestClass() {\n+    Class<?> c = currentTestClass.get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78eb8b7e47c4fba404a0480318187f6c266ff5e2"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NjA1Mzk5OnYy", "diffSide": "RIGHT", "path": "smoke-tests/src/test/groovy/io/opentelemetry/smoketest/AppServerTest.groovy", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwMDo1MjozNVrOIOtg3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwMTowOTo0OVrOIOuMPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI5NjY3MQ==", "bodyText": "a -> appServer", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1967#discussion_r552296671", "createdAt": "2021-01-06T00:52:35Z", "author": {"login": "trask"}, "path": "smoke-tests/src/test/groovy/io/opentelemetry/smoketest/AppServerTest.groovy", "diffHunk": "@@ -5,21 +5,55 @@\n \n package io.opentelemetry.smoketest\n \n+import static org.junit.Assume.assumeTrue\n+\n import io.opentelemetry.proto.trace.v1.Span\n import java.util.jar.Attributes\n import java.util.jar.JarFile\n import okhttp3.Request\n+import org.junit.runner.RunWith\n+import spock.lang.Shared\n import spock.lang.Unroll\n \n+@RunWith(AppServerTestRunner)\n abstract class AppServerTest extends SmokeTest {\n+  @Shared\n+  String jdk\n+  @Shared\n+  String serverVersion\n+\n+  def setupSpec() {\n+    AppServer a = AppServerTestRunner.currentAppServer(this.getClass())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9dcc19fbd8c8e734afb32fe1b091c7dd85d9a3a0"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjMwNzc3Mw==", "bodyText": "fixed", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1967#discussion_r552307773", "createdAt": "2021-01-06T01:09:49Z", "author": {"login": "laurit"}, "path": "smoke-tests/src/test/groovy/io/opentelemetry/smoketest/AppServerTest.groovy", "diffHunk": "@@ -5,21 +5,55 @@\n \n package io.opentelemetry.smoketest\n \n+import static org.junit.Assume.assumeTrue\n+\n import io.opentelemetry.proto.trace.v1.Span\n import java.util.jar.Attributes\n import java.util.jar.JarFile\n import okhttp3.Request\n+import org.junit.runner.RunWith\n+import spock.lang.Shared\n import spock.lang.Unroll\n \n+@RunWith(AppServerTestRunner)\n abstract class AppServerTest extends SmokeTest {\n+  @Shared\n+  String jdk\n+  @Shared\n+  String serverVersion\n+\n+  def setupSpec() {\n+    AppServer a = AppServerTestRunner.currentAppServer(this.getClass())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI5NjY3MQ=="}, "originalCommit": {"oid": "9dcc19fbd8c8e734afb32fe1b091c7dd85d9a3a0"}, "originalPosition": 22}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4411, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}