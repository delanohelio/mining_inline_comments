{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU1NTExNzk4", "number": 768, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwNjo1MjowM1rOERUyfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQxMDo1MjowMVrOESCptg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NjAxODUzOnYy", "diffSide": "RIGHT", "path": "benchmark/benchmark.gradle", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwNjo1MjowM1rOG1-MJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxODo1NTo0M1rOG26WmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI0NjYzMQ==", "bodyText": "Is it worth having a separate Gradle project?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/768#discussion_r459246631", "createdAt": "2020-07-23T06:52:03Z", "author": {"login": "anuraaga"}, "path": "benchmark/benchmark.gradle", "diffHunk": "@@ -22,10 +25,16 @@ jmh {\n   fork = 1 // How many times to forks a single benchmark. Use 0 to disable forking altogether\n //  jvmArgs += [\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+DebugNonSafepoints\", \"-XX:StartFlightRecording=delay=5s,dumponexit=true,name=jmh-benchmark,filename=$rootDir/benchmark/build/reports/jmh/jmh-benchmark.jfr\"]\n //  jvmArgs += [\"-agentpath:$rootDir/benchmark/src/jmh/resources/libasyncProfiler.so=start,collapsed,file=$rootDir/benchmark/build/reports/jmh/profiler.txt\"]\n-  failOnError = true // Should JMH fail immediately if any benchmark had experienced the unrecoverable error?\n+\n+  // uncomment to use for TypeMatchingBenchmark", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aca347f112a2cb713d5822f197b8a210715a1c46"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI5NzY1MA==", "bodyText": "Or separate Gradle task", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/768#discussion_r459297650", "createdAt": "2020-07-23T08:40:18Z", "author": {"login": "iNikem"}, "path": "benchmark/benchmark.gradle", "diffHunk": "@@ -22,10 +25,16 @@ jmh {\n   fork = 1 // How many times to forks a single benchmark. Use 0 to disable forking altogether\n //  jvmArgs += [\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+DebugNonSafepoints\", \"-XX:StartFlightRecording=delay=5s,dumponexit=true,name=jmh-benchmark,filename=$rootDir/benchmark/build/reports/jmh/jmh-benchmark.jfr\"]\n //  jvmArgs += [\"-agentpath:$rootDir/benchmark/src/jmh/resources/libasyncProfiler.so=start,collapsed,file=$rootDir/benchmark/build/reports/jmh/profiler.txt\"]\n-  failOnError = true // Should JMH fail immediately if any benchmark had experienced the unrecoverable error?\n+\n+  // uncomment to use for TypeMatchingBenchmark", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI0NjYzMQ=="}, "originalCommit": {"oid": "aca347f112a2cb713d5822f197b8a210715a1c46"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIyOTU0OA==", "bodyText": "I just tried this, but the jmh task seems different from normal gradle tasks(?): https://github.com/melix/jmh-gradle-plugin/blob/master/src/main/groovy/me/champeau/gradle/JMHTask.java#L32\nand so I run into this problem:\nmelix/jmh-gradle-plugin#161 (comment)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/768#discussion_r460229548", "createdAt": "2020-07-24T18:49:32Z", "author": {"login": "trask"}, "path": "benchmark/benchmark.gradle", "diffHunk": "@@ -22,10 +25,16 @@ jmh {\n   fork = 1 // How many times to forks a single benchmark. Use 0 to disable forking altogether\n //  jvmArgs += [\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+DebugNonSafepoints\", \"-XX:StartFlightRecording=delay=5s,dumponexit=true,name=jmh-benchmark,filename=$rootDir/benchmark/build/reports/jmh/jmh-benchmark.jfr\"]\n //  jvmArgs += [\"-agentpath:$rootDir/benchmark/src/jmh/resources/libasyncProfiler.so=start,collapsed,file=$rootDir/benchmark/build/reports/jmh/profiler.txt\"]\n-  failOnError = true // Should JMH fail immediately if any benchmark had experienced the unrecoverable error?\n+\n+  // uncomment to use for TypeMatchingBenchmark", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI0NjYzMQ=="}, "originalCommit": {"oid": "aca347f112a2cb713d5822f197b8a210715a1c46"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIzMjM0NQ==", "bodyText": "for now, I modeled it similar to existing benchmarks, and I added #782", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/768#discussion_r460232345", "createdAt": "2020-07-24T18:55:43Z", "author": {"login": "trask"}, "path": "benchmark/benchmark.gradle", "diffHunk": "@@ -22,10 +25,16 @@ jmh {\n   fork = 1 // How many times to forks a single benchmark. Use 0 to disable forking altogether\n //  jvmArgs += [\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+DebugNonSafepoints\", \"-XX:StartFlightRecording=delay=5s,dumponexit=true,name=jmh-benchmark,filename=$rootDir/benchmark/build/reports/jmh/jmh-benchmark.jfr\"]\n //  jvmArgs += [\"-agentpath:$rootDir/benchmark/src/jmh/resources/libasyncProfiler.so=start,collapsed,file=$rootDir/benchmark/build/reports/jmh/profiler.txt\"]\n-  failOnError = true // Should JMH fail immediately if any benchmark had experienced the unrecoverable error?\n+\n+  // uncomment to use for TypeMatchingBenchmark", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI0NjYzMQ=="}, "originalCommit": {"oid": "aca347f112a2cb713d5822f197b8a210715a1c46"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NjM2MDg2OnYy", "diffSide": "RIGHT", "path": "benchmark/src/jmh/java/io/opentelemetry/benchmark/TypeMatchingBenchmark.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwODo0MjoxMlrOG2BX4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwODo0MjoxMlrOG2BX4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI5ODc4Ng==", "bodyText": "I would create a list of classes to load in @Setup method and benchmark itself will just load classes. And as a baseline, add a benchmark which just iterates over list of classes", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/768#discussion_r459298786", "createdAt": "2020-07-23T08:42:12Z", "author": {"login": "iNikem"}, "path": "benchmark/src/jmh/java/io/opentelemetry/benchmark/TypeMatchingBenchmark.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.benchmark;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+import java.io.File;\n+import java.util.Enumeration;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@BenchmarkMode(Mode.SingleShotTime)\n+@Fork(5)\n+@Warmup(iterations = 0)\n+@Measurement(iterations = 1)\n+@OutputTimeUnit(MILLISECONDS)\n+@State(Scope.Thread)\n+public class TypeMatchingBenchmark {\n+\n+  @Benchmark\n+  public void loadLotsOfClasses() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aca347f112a2cb713d5822f197b8a210715a1c46"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MzEzOTkxOnYy", "diffSide": "RIGHT", "path": "benchmark/src/jmh/java/io/opentelemetry/benchmark/TypeMatchingBenchmark.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQwMToxNjo0OVrOG3BTCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQwMToxNjo0OVrOG3BTCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM0NjEyMA==", "bodyText": "Delete? Seems like it'd affect the benchmark result / be spammy", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/768#discussion_r460346120", "createdAt": "2020-07-25T01:16:49Z", "author": {"login": "anuraaga"}, "path": "benchmark/src/jmh/java/io/opentelemetry/benchmark/TypeMatchingBenchmark.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.benchmark;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@BenchmarkMode(Mode.SingleShotTime)\n+@Fork(5)\n+@Warmup(iterations = 0)\n+@Measurement(iterations = 1)\n+@OutputTimeUnit(MILLISECONDS)\n+@State(Scope.Thread)\n+public class TypeMatchingBenchmark {\n+\n+  private Set<String> classNames;\n+\n+  @Setup\n+  public void setup() throws IOException {\n+    classNames = new HashSet<>();\n+    String classPath = System.getProperty(\"java.class.path\");\n+    for (String path : classPath.split(File.pathSeparator)) {\n+      if (!path.endsWith(\".jar\")) {\n+        continue;\n+      }\n+      JarFile jarFile = new JarFile(path);\n+      try {\n+        Enumeration<JarEntry> e = jarFile.entries();\n+        while (e.hasMoreElements()) {\n+          JarEntry jarEntry = e.nextElement();\n+          String name = jarEntry.getName();\n+          if (name.endsWith(\".class\")) {\n+            name = name.replace('/', '.');\n+            name = name.substring(0, name.length() - \".class\".length());\n+            classNames.add(name);\n+          }\n+        }\n+      } finally {\n+        jarFile.close();\n+      }\n+    }\n+  }\n+\n+  @Benchmark\n+  public void loadLotsOfClasses() {\n+    int successCount = 0;\n+    int errorCount = 0;\n+    for (String className : classNames) {\n+      try {\n+        Class.forName(className, false, TypeMatchingBenchmark.class.getClassLoader());\n+        successCount++;\n+      } catch (Throwable t) {\n+        errorCount++;\n+      }\n+    }\n+    System.out.println(\"[loaded: \" + successCount + \", failed to load: \" + errorCount + \"]\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b28d8656ec15095c44a4de2784fc9854ed55c1d"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MzE0MDUwOnYy", "diffSide": "RIGHT", "path": "benchmark/src/jmh/java/io/opentelemetry/benchmark/TypeMatchingBenchmark.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQwMToxNzozM1rOG3BTTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQwMToxNzozM1rOG3BTTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM0NjE5MA==", "bodyText": "Ah just noticed maybe can stick with a static final. Find it makes benchmarks simpler not to worry aboutState unless really having to.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/768#discussion_r460346190", "createdAt": "2020-07-25T01:17:33Z", "author": {"login": "anuraaga"}, "path": "benchmark/src/jmh/java/io/opentelemetry/benchmark/TypeMatchingBenchmark.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.benchmark;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@BenchmarkMode(Mode.SingleShotTime)\n+@Fork(5)\n+@Warmup(iterations = 0)\n+@Measurement(iterations = 1)\n+@OutputTimeUnit(MILLISECONDS)\n+@State(Scope.Thread)\n+public class TypeMatchingBenchmark {\n+\n+  private Set<String> classNames;\n+\n+  @Setup\n+  public void setup() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b28d8656ec15095c44a4de2784fc9854ed55c1d"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MzUzMjI4OnYy", "diffSide": "RIGHT", "path": "benchmark/src/jmh/java/io/opentelemetry/benchmark/TypeMatchingBenchmark.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQxMDo1MToyMFrOG3EJpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQxNzo1MDoxNVrOG3GTJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM5Mjg2OQ==", "bodyText": "What is agent master?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/768#discussion_r460392869", "createdAt": "2020-07-25T10:51:20Z", "author": {"login": "iNikem"}, "path": "benchmark/src/jmh/java/io/opentelemetry/benchmark/TypeMatchingBenchmark.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.benchmark;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@BenchmarkMode(Mode.SingleShotTime)\n+@Fork(5)\n+@Warmup(iterations = 0)\n+@Measurement(iterations = 1)\n+@OutputTimeUnit(MILLISECONDS)\n+public class TypeMatchingBenchmark {\n+\n+  private static final Set<String> classNames;\n+\n+  static {\n+    classNames = new HashSet<>();\n+    String classPath = System.getProperty(\"java.class.path\");\n+    for (String path : classPath.split(File.pathSeparator)) {\n+      if (!path.endsWith(\".jar\")) {\n+        continue;\n+      }\n+      try (JarFile jarFile = new JarFile(path)) {\n+        Enumeration<JarEntry> e = jarFile.entries();\n+        while (e.hasMoreElements()) {\n+          JarEntry jarEntry = e.nextElement();\n+          String name = jarEntry.getName();\n+          if (name.endsWith(\".class\")) {\n+            name = name.replace('/', '.');\n+            name = name.substring(0, name.length() - \".class\".length());\n+            classNames.add(name);\n+          }\n+        }\n+      } catch (IOException e) {\n+        throw new RuntimeException(e);\n+      }\n+    }\n+  }\n+\n+  @Benchmark\n+  public void loadLotsOfClasses() throws ClassNotFoundException {\n+    for (String className : classNames) {\n+      try {\n+        Class.forName(className, false, TypeMatchingBenchmark.class.getClassLoader());\n+      } catch (NoClassDefFoundError e) {\n+        // many classes in the jar files have optional dependencies which are not present\n+      }\n+    }\n+  }\n+\n+  @Fork(jvmArgsAppend = \"-javaagent:/path/to/opentelemetry-javaagent-master.jar\")\n+  public static class WithAgentMaster extends TypeMatchingBenchmark {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afc1a5555c297d4b6b96263f81edf3251f69b00f"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQyODA3MQ==", "bodyText": "i copied from another benchmark, i think the idea was to test against multiple versions of the agent, but i don't think needed so removed in both places", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/768#discussion_r460428071", "createdAt": "2020-07-25T17:50:15Z", "author": {"login": "trask"}, "path": "benchmark/src/jmh/java/io/opentelemetry/benchmark/TypeMatchingBenchmark.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.benchmark;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@BenchmarkMode(Mode.SingleShotTime)\n+@Fork(5)\n+@Warmup(iterations = 0)\n+@Measurement(iterations = 1)\n+@OutputTimeUnit(MILLISECONDS)\n+public class TypeMatchingBenchmark {\n+\n+  private static final Set<String> classNames;\n+\n+  static {\n+    classNames = new HashSet<>();\n+    String classPath = System.getProperty(\"java.class.path\");\n+    for (String path : classPath.split(File.pathSeparator)) {\n+      if (!path.endsWith(\".jar\")) {\n+        continue;\n+      }\n+      try (JarFile jarFile = new JarFile(path)) {\n+        Enumeration<JarEntry> e = jarFile.entries();\n+        while (e.hasMoreElements()) {\n+          JarEntry jarEntry = e.nextElement();\n+          String name = jarEntry.getName();\n+          if (name.endsWith(\".class\")) {\n+            name = name.replace('/', '.');\n+            name = name.substring(0, name.length() - \".class\".length());\n+            classNames.add(name);\n+          }\n+        }\n+      } catch (IOException e) {\n+        throw new RuntimeException(e);\n+      }\n+    }\n+  }\n+\n+  @Benchmark\n+  public void loadLotsOfClasses() throws ClassNotFoundException {\n+    for (String className : classNames) {\n+      try {\n+        Class.forName(className, false, TypeMatchingBenchmark.class.getClassLoader());\n+      } catch (NoClassDefFoundError e) {\n+        // many classes in the jar files have optional dependencies which are not present\n+      }\n+    }\n+  }\n+\n+  @Fork(jvmArgsAppend = \"-javaagent:/path/to/opentelemetry-javaagent-master.jar\")\n+  public static class WithAgentMaster extends TypeMatchingBenchmark {}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM5Mjg2OQ=="}, "originalCommit": {"oid": "afc1a5555c297d4b6b96263f81edf3251f69b00f"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MzUzMjcwOnYy", "diffSide": "RIGHT", "path": "benchmark/src/jmh/java/io/opentelemetry/benchmark/TypeMatchingBenchmark.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQxMDo1MjowMVrOG3EJ2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQxMDo1MjowMVrOG3EJ2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM5MjkyMA==", "bodyText": "java-agent->opentelemetry-agent", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/768#discussion_r460392920", "createdAt": "2020-07-25T10:52:01Z", "author": {"login": "iNikem"}, "path": "benchmark/src/jmh/java/io/opentelemetry/benchmark/TypeMatchingBenchmark.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.benchmark;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@BenchmarkMode(Mode.SingleShotTime)\n+@Fork(5)\n+@Warmup(iterations = 0)\n+@Measurement(iterations = 1)\n+@OutputTimeUnit(MILLISECONDS)\n+public class TypeMatchingBenchmark {\n+\n+  private static final Set<String> classNames;\n+\n+  static {\n+    classNames = new HashSet<>();\n+    String classPath = System.getProperty(\"java.class.path\");\n+    for (String path : classPath.split(File.pathSeparator)) {\n+      if (!path.endsWith(\".jar\")) {\n+        continue;\n+      }\n+      try (JarFile jarFile = new JarFile(path)) {\n+        Enumeration<JarEntry> e = jarFile.entries();\n+        while (e.hasMoreElements()) {\n+          JarEntry jarEntry = e.nextElement();\n+          String name = jarEntry.getName();\n+          if (name.endsWith(\".class\")) {\n+            name = name.replace('/', '.');\n+            name = name.substring(0, name.length() - \".class\".length());\n+            classNames.add(name);\n+          }\n+        }\n+      } catch (IOException e) {\n+        throw new RuntimeException(e);\n+      }\n+    }\n+  }\n+\n+  @Benchmark\n+  public void loadLotsOfClasses() throws ClassNotFoundException {\n+    for (String className : classNames) {\n+      try {\n+        Class.forName(className, false, TypeMatchingBenchmark.class.getClassLoader());\n+      } catch (NoClassDefFoundError e) {\n+        // many classes in the jar files have optional dependencies which are not present\n+      }\n+    }\n+  }\n+\n+  @Fork(jvmArgsAppend = \"-javaagent:/path/to/opentelemetry-javaagent-master.jar\")\n+  public static class WithAgentMaster extends TypeMatchingBenchmark {}\n+\n+  @Fork(\n+      jvmArgsAppend =\n+          \"-javaagent:/path/to/opentelemetry-java-instrumentation/java-agent/build/libs/opentelemetry-javaagent.jar\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afc1a5555c297d4b6b96263f81edf3251f69b00f"}, "originalPosition": 85}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 133, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}