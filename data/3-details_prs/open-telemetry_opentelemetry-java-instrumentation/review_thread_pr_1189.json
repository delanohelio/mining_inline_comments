{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgzODUxMjI1", "number": 1189, "reviewThreads": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNzozMzowMVrOEiapTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxNjowODowNVrOEkIFjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NTIzNTk3OnYy", "diffSide": "RIGHT", "path": "instrumentation-core/reactor-3.1/src/main/java/io/opentelemetry/instrumentation/reactor/TracingOperator.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNzozMzowMVrOHQRqtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMjoyMDowNFrOHQcjOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgyODcyNw==", "bodyText": "I think this needs to return the same reference for reset to work", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1189#discussion_r486828727", "createdAt": "2020-09-11T07:33:01Z", "author": {"login": "anuraaga"}, "path": "instrumentation-core/reactor-3.1/src/main/java/io/opentelemetry/instrumentation/reactor/TracingOperator.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.reactor;\n+\n+import io.grpc.Context;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import org.reactivestreams.Publisher;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.Fuseable;\n+import reactor.core.Scannable;\n+import reactor.core.publisher.Hooks;\n+import reactor.core.publisher.Operators;\n+\n+/** @author Based on Spring Sleuth's Reactor instrumentation. */\n+public class TracingOperator {\n+\n+  /**\n+   * Registers a hook that applies to every operator, propagating {@link Context} to downstream\n+   * callbacks to ensure spans in the {@link Context} are available throughout the lifetime of a\n+   * reactive stream. This should generally be called in a static initializer block in your\n+   * application.\n+   */\n+  public static void registerOnEachOperator() {\n+    Hooks.onEachOperator(tracingLift());\n+  }\n+\n+  /** Unregisters the hook registered by {@link #registerOnEachOperator()}. */\n+  public static void resetOnEachOperator() {\n+    Hooks.onEachOperator(tracingLift());\n+  }\n+\n+  private static <T> Function<? super Publisher<T>, ? extends Publisher<T>> tracingLift() {\n+    return Operators.lift(new Lifter<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1867995a1f4fb3d19325fa76bae6f265b290b089"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg2MjE4OQ==", "bodyText": "I don't quite understand. You mean cache the result of lift? This is copy-pasted from OpenTracing: https://github.com/opentracing-contrib/java-reactor/blob/master/src/main/java/io/opentracing/contrib/reactor/TracedSubscriber.java", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1189#discussion_r486862189", "createdAt": "2020-09-11T08:36:47Z", "author": {"login": "iNikem"}, "path": "instrumentation-core/reactor-3.1/src/main/java/io/opentelemetry/instrumentation/reactor/TracingOperator.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.reactor;\n+\n+import io.grpc.Context;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import org.reactivestreams.Publisher;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.Fuseable;\n+import reactor.core.Scannable;\n+import reactor.core.publisher.Hooks;\n+import reactor.core.publisher.Operators;\n+\n+/** @author Based on Spring Sleuth's Reactor instrumentation. */\n+public class TracingOperator {\n+\n+  /**\n+   * Registers a hook that applies to every operator, propagating {@link Context} to downstream\n+   * callbacks to ensure spans in the {@link Context} are available throughout the lifetime of a\n+   * reactive stream. This should generally be called in a static initializer block in your\n+   * application.\n+   */\n+  public static void registerOnEachOperator() {\n+    Hooks.onEachOperator(tracingLift());\n+  }\n+\n+  /** Unregisters the hook registered by {@link #registerOnEachOperator()}. */\n+  public static void resetOnEachOperator() {\n+    Hooks.onEachOperator(tracingLift());\n+  }\n+\n+  private static <T> Function<? super Publisher<T>, ? extends Publisher<T>> tracingLift() {\n+    return Operators.lift(new Lifter<>());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgyODcyNw=="}, "originalCommit": {"oid": "1867995a1f4fb3d19325fa76bae6f265b290b089"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjkyMTczOQ==", "bodyText": "Yeah like private static final Function<? super Publisher<T>, ? extends Publisher<T>>  TRACING_LIFTER = Operators.lift(new Lifter<>()); and return TRACING_LIFTER;. I didn't look at the implementation of reset in detail but I can't conceive it's possible without it being the same reference.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1189#discussion_r486921739", "createdAt": "2020-09-11T09:43:14Z", "author": {"login": "anuraaga"}, "path": "instrumentation-core/reactor-3.1/src/main/java/io/opentelemetry/instrumentation/reactor/TracingOperator.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.reactor;\n+\n+import io.grpc.Context;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import org.reactivestreams.Publisher;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.Fuseable;\n+import reactor.core.Scannable;\n+import reactor.core.publisher.Hooks;\n+import reactor.core.publisher.Operators;\n+\n+/** @author Based on Spring Sleuth's Reactor instrumentation. */\n+public class TracingOperator {\n+\n+  /**\n+   * Registers a hook that applies to every operator, propagating {@link Context} to downstream\n+   * callbacks to ensure spans in the {@link Context} are available throughout the lifetime of a\n+   * reactive stream. This should generally be called in a static initializer block in your\n+   * application.\n+   */\n+  public static void registerOnEachOperator() {\n+    Hooks.onEachOperator(tracingLift());\n+  }\n+\n+  /** Unregisters the hook registered by {@link #registerOnEachOperator()}. */\n+  public static void resetOnEachOperator() {\n+    Hooks.onEachOperator(tracingLift());\n+  }\n+\n+  private static <T> Function<? super Publisher<T>, ? extends Publisher<T>> tracingLift() {\n+    return Operators.lift(new Lifter<>());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgyODcyNw=="}, "originalCommit": {"oid": "1867995a1f4fb3d19325fa76bae6f265b290b089"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAwNzAzMw==", "bodyText": "That was actual bug, thank you :) Solved now", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1189#discussion_r487007033", "createdAt": "2020-09-11T12:20:04Z", "author": {"login": "iNikem"}, "path": "instrumentation-core/reactor-3.1/src/main/java/io/opentelemetry/instrumentation/reactor/TracingOperator.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.reactor;\n+\n+import io.grpc.Context;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import org.reactivestreams.Publisher;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.Fuseable;\n+import reactor.core.Scannable;\n+import reactor.core.publisher.Hooks;\n+import reactor.core.publisher.Operators;\n+\n+/** @author Based on Spring Sleuth's Reactor instrumentation. */\n+public class TracingOperator {\n+\n+  /**\n+   * Registers a hook that applies to every operator, propagating {@link Context} to downstream\n+   * callbacks to ensure spans in the {@link Context} are available throughout the lifetime of a\n+   * reactive stream. This should generally be called in a static initializer block in your\n+   * application.\n+   */\n+  public static void registerOnEachOperator() {\n+    Hooks.onEachOperator(tracingLift());\n+  }\n+\n+  /** Unregisters the hook registered by {@link #registerOnEachOperator()}. */\n+  public static void resetOnEachOperator() {\n+    Hooks.onEachOperator(tracingLift());\n+  }\n+\n+  private static <T> Function<? super Publisher<T>, ? extends Publisher<T>> tracingLift() {\n+    return Operators.lift(new Lifter<>());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgyODcyNw=="}, "originalCommit": {"oid": "1867995a1f4fb3d19325fa76bae6f265b290b089"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NTIzNzQ1OnYy", "diffSide": "RIGHT", "path": "instrumentation-core/reactor-3.1/src/main/java/io/opentelemetry/instrumentation/reactor/TracingOperator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNzozMzozOVrOHQRrxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwOTowNDo0NVrOHQVAAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgyODk5OA==", "bodyText": "/cc @minwoox do you mind providing any thoughts on this instrumentation? I guess you've already experienced all the corner cases since LINE uses reactor a lot. It will affect Armeria users too if they start using OpenTelemetry :)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1189#discussion_r486828998", "createdAt": "2020-09-11T07:33:39Z", "author": {"login": "anuraaga"}, "path": "instrumentation-core/reactor-3.1/src/main/java/io/opentelemetry/instrumentation/reactor/TracingOperator.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.reactor;\n+\n+import io.grpc.Context;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import org.reactivestreams.Publisher;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.Fuseable;\n+import reactor.core.Scannable;\n+import reactor.core.publisher.Hooks;\n+import reactor.core.publisher.Operators;\n+\n+/** @author Based on Spring Sleuth's Reactor instrumentation. */\n+public class TracingOperator {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1867995a1f4fb3d19325fa76bae6f265b290b089"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg4MzMzMQ==", "bodyText": "Well, LINE uses RxJava a lot. \ud83e\udd23\nRecently we got a few customers who use Reactor with Armeria, so I guess I didn't experience all the corner cases yet.\nThis implementation looks good and if I found something I will leave comments though. \ud83d\ude04", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1189#discussion_r486883331", "createdAt": "2020-09-11T09:04:45Z", "author": {"login": "minwoox"}, "path": "instrumentation-core/reactor-3.1/src/main/java/io/opentelemetry/instrumentation/reactor/TracingOperator.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.reactor;\n+\n+import io.grpc.Context;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import org.reactivestreams.Publisher;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.Fuseable;\n+import reactor.core.Scannable;\n+import reactor.core.publisher.Hooks;\n+import reactor.core.publisher.Operators;\n+\n+/** @author Based on Spring Sleuth's Reactor instrumentation. */\n+public class TracingOperator {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgyODk5OA=="}, "originalCommit": {"oid": "1867995a1f4fb3d19325fa76bae6f265b290b089"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NTI0MzAxOnYy", "diffSide": "RIGHT", "path": "instrumentation-core/reactor-3.1/src/main/java/io/opentelemetry/instrumentation/reactor/TracingSubscriber.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNzozNToxOVrOHQRvBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNzozNToxOVrOHQRvBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgyOTgyOQ==", "bodyText": "Since we don't have @author anywhere else I would recommend not including it here too even for copied files.\nIdeally we fix spotless to allow us to have two copyright headers on a file. In the meantime, I took a NOTICE approach to referencing copied code which I think is the bare minimum legally (@author doesn't help at all legally)\nhttps://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/master/instrumentation/logback/logback-1.0.0/library/NOTICE.txt", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1189#discussion_r486829829", "createdAt": "2020-09-11T07:35:19Z", "author": {"login": "anuraaga"}, "path": "instrumentation-core/reactor-3.1/src/main/java/io/opentelemetry/instrumentation/reactor/TracingSubscriber.java", "diffHunk": "@@ -18,132 +18,65 @@\n \n import io.opentelemetry.context.ContextUtils;\n import io.opentelemetry.context.Scope;\n+import org.reactivestreams.Subscriber;\n import org.reactivestreams.Subscription;\n import reactor.core.CoreSubscriber;\n-import reactor.core.Fuseable;\n-import reactor.core.Scannable;\n import reactor.util.context.Context;\n \n-public class TracingSubscriber<T>\n-    implements Subscription, CoreSubscriber<T>, Fuseable.QueueSubscription<T>, Scannable {\n-\n-  private final io.grpc.Context upstreamContext;\n-  private final CoreSubscriber<T> delegate;\n+/**\n+ * Based on Spring Sleuth's Reactor instrumentation. A trace representation of the {@link\n+ * Subscriber}\n+ *\n+ * @author Jose Montoya", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1867995a1f4fb3d19325fa76bae6f265b290b089"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NTI0ODg3OnYy", "diffSide": "RIGHT", "path": "instrumentation/netty/netty-4.1/src/test/resources/logback.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNzozNzowN1rOHQRylQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNzozNzowN1rOHQRylQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgzMDc0MQ==", "bodyText": "I think with the AgentTestRunner fix we shouldn't need to copy logback.xml around", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1189#discussion_r486830741", "createdAt": "2020-09-11T07:37:07Z", "author": {"login": "anuraaga"}, "path": "instrumentation/netty/netty-4.1/src/test/resources/logback.xml", "diffHunk": "@@ -0,0 +1,18 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1867995a1f4fb3d19325fa76bae6f265b290b089"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NTI0OTgyOnYy", "diffSide": "RIGHT", "path": "instrumentation/netty/netty-4.1/src/test/resources/logback.xml", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNzozNzoyMFrOHQRzFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwMDoyNzowOVrOHQxCBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgzMDg2OQ==", "bodyText": "And this logback.xml like many of ours is wrong :-D /cc @trask", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1189#discussion_r486830869", "createdAt": "2020-09-11T07:37:20Z", "author": {"login": "anuraaga"}, "path": "instrumentation/netty/netty-4.1/src/test/resources/logback.xml", "diffHunk": "@@ -0,0 +1,18 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<configuration>\n+\n+  <appender name=\"console\" class=\"ch.qos.logback.core.ConsoleAppender\">\n+    <layout class=\"ch.qos.logback.classic.PatternLayout\">\n+      <Pattern>\n+        %d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n\n+      </Pattern>\n+    </layout>\n+  </appender>\n+\n+  <root level=\"WARN\">\n+    <appender-ref ref=\"console\"/>\n+  </root>\n+\n+  <logger name=\"io.opentelemetry.auto\" level=\"debug\"/>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1867995a1f4fb3d19325fa76bae6f265b290b089"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEyMjM0MA==", "bodyText": "Btw, it was not wrong! InMemoryExporter still lives in io.opentelemetry.auto.test package!", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1189#discussion_r487122340", "createdAt": "2020-09-11T15:29:14Z", "author": {"login": "iNikem"}, "path": "instrumentation/netty/netty-4.1/src/test/resources/logback.xml", "diffHunk": "@@ -0,0 +1,18 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<configuration>\n+\n+  <appender name=\"console\" class=\"ch.qos.logback.core.ConsoleAppender\">\n+    <layout class=\"ch.qos.logback.classic.PatternLayout\">\n+      <Pattern>\n+        %d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n\n+      </Pattern>\n+    </layout>\n+  </appender>\n+\n+  <root level=\"WARN\">\n+    <appender-ref ref=\"console\"/>\n+  </root>\n+\n+  <logger name=\"io.opentelemetry.auto\" level=\"debug\"/>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgzMDg2OQ=="}, "originalCommit": {"oid": "1867995a1f4fb3d19325fa76bae6f265b290b089"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0MjU5OQ==", "bodyText": "well, it's not totally wrong then \ud83d\ude02\nfixed in #1194", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1189#discussion_r487342599", "createdAt": "2020-09-12T00:27:09Z", "author": {"login": "trask"}, "path": "instrumentation/netty/netty-4.1/src/test/resources/logback.xml", "diffHunk": "@@ -0,0 +1,18 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<configuration>\n+\n+  <appender name=\"console\" class=\"ch.qos.logback.core.ConsoleAppender\">\n+    <layout class=\"ch.qos.logback.classic.PatternLayout\">\n+      <Pattern>\n+        %d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n\n+      </Pattern>\n+    </layout>\n+  </appender>\n+\n+  <root level=\"WARN\">\n+    <appender-ref ref=\"console\"/>\n+  </root>\n+\n+  <logger name=\"io.opentelemetry.auto\" level=\"debug\"/>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgzMDg2OQ=="}, "originalCommit": {"oid": "1867995a1f4fb3d19325fa76bae6f265b290b089"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NTI1MzIyOnYy", "diffSide": "RIGHT", "path": "instrumentation/spring/spring-webflux-5.0/auto/src/test/groovy/SpringWebfluxTest.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNzozODoyNVrOHQR1Bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNzozODoyNVrOHQR1Bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgzMTM2Ng==", "bodyText": "Believe IntelliJ isn't set up correctly - https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/master/docs/contributing/intellij-setup.md", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1189#discussion_r486831366", "createdAt": "2020-09-11T07:38:25Z", "author": {"login": "anuraaga"}, "path": "instrumentation/spring/spring-webflux-5.0/auto/src/test/groovy/SpringWebfluxTest.groovy", "diffHunk": "@@ -34,6 +31,9 @@ import server.FooModel\n import server.SpringWebFluxTestApplication\n import server.TestController\n \n+import static io.opentelemetry.trace.Span.Kind.INTERNAL", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1867995a1f4fb3d19325fa76bae6f265b290b089"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NTI3MDM3OnYy", "diffSide": "RIGHT", "path": "instrumentation-core/reactor-3.1/src/main/java/io/opentelemetry/instrumentation/reactor/TracingSubscriber.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNzo0Mzo0MFrOHQR_UQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNzo0Mzo0MFrOHQR_UQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgzNDAwMQ==", "bodyText": "Can you add permalinks to original of all copied classes?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1189#discussion_r486834001", "createdAt": "2020-09-11T07:43:40Z", "author": {"login": "anuraaga"}, "path": "instrumentation-core/reactor-3.1/src/main/java/io/opentelemetry/instrumentation/reactor/TracingSubscriber.java", "diffHunk": "@@ -18,132 +18,65 @@\n \n import io.opentelemetry.context.ContextUtils;\n import io.opentelemetry.context.Scope;\n+import org.reactivestreams.Subscriber;\n import org.reactivestreams.Subscription;\n import reactor.core.CoreSubscriber;\n-import reactor.core.Fuseable;\n-import reactor.core.Scannable;\n import reactor.util.context.Context;\n \n-public class TracingSubscriber<T>\n-    implements Subscription, CoreSubscriber<T>, Fuseable.QueueSubscription<T>, Scannable {\n-\n-  private final io.grpc.Context upstreamContext;\n-  private final CoreSubscriber<T> delegate;\n+/**\n+ * Based on Spring Sleuth's Reactor instrumentation. A trace representation of the {@link", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1867995a1f4fb3d19325fa76bae6f265b290b089"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NTc5NTI3OnYy", "diffSide": "RIGHT", "path": "instrumentation-core/reactor-3.1/src/main/java/io/opentelemetry/instrumentation/reactor/TracingOperator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwOTo0MzozMFrOHQXW_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwOTo0MzozMFrOHQXW_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjkyMTk4Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Hooks.onEachOperator(tracingLift());\n          \n          \n            \n                Hooks.resetOnEachOperator(tracingLift());\n          \n      \n    \n    \n  \n\nCan you add a test for reset?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1189#discussion_r486921983", "createdAt": "2020-09-11T09:43:30Z", "author": {"login": "anuraaga"}, "path": "instrumentation-core/reactor-3.1/src/main/java/io/opentelemetry/instrumentation/reactor/TracingOperator.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.reactor;\n+\n+import io.grpc.Context;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import org.reactivestreams.Publisher;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.Fuseable;\n+import reactor.core.Scannable;\n+import reactor.core.publisher.Hooks;\n+import reactor.core.publisher.Operators;\n+\n+/** @author Based on Spring Sleuth's Reactor instrumentation. */\n+public class TracingOperator {\n+\n+  /**\n+   * Registers a hook that applies to every operator, propagating {@link Context} to downstream\n+   * callbacks to ensure spans in the {@link Context} are available throughout the lifetime of a\n+   * reactive stream. This should generally be called in a static initializer block in your\n+   * application.\n+   */\n+  public static void registerOnEachOperator() {\n+    Hooks.onEachOperator(tracingLift());\n+  }\n+\n+  /** Unregisters the hook registered by {@link #registerOnEachOperator()}. */\n+  public static void resetOnEachOperator() {\n+    Hooks.onEachOperator(tracingLift());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df7b781fcb5403a4973d75ee48052ec56d23ee1f"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODQ4Nzk2OnYy", "diffSide": "RIGHT", "path": "instrumentation/reactor-3.1/src/test/resources/logback.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwMDozNTowMVrOHQxG8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwMDozNTowMVrOHQxG8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0Mzg1Ng==", "bodyText": "I don't think you need this file after #1194", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1189#discussion_r487343856", "createdAt": "2020-09-12T00:35:01Z", "author": {"login": "trask"}, "path": "instrumentation/reactor-3.1/src/test/resources/logback.xml", "diffHunk": "@@ -0,0 +1,18 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<configuration>\n+\n+  <appender name=\"console\" class=\"ch.qos.logback.core.ConsoleAppender\">\n+    <layout class=\"ch.qos.logback.classic.PatternLayout\">\n+      <Pattern>\n+        %d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n\n+      </Pattern>\n+    </layout>\n+  </appender>\n+\n+  <root level=\"WARN\">\n+    <appender-ref ref=\"console\"/>\n+  </root>\n+\n+  <logger name=\"io.opentelemetry.auto\" level=\"debug\"/>\n+\n+</configuration>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e6feedb1acef99360c99ae13befe6b49032df8b"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODQ4OTQzOnYy", "diffSide": "RIGHT", "path": "testing-common/src/main/groovy/io/opentelemetry/auto/test/AgentTestRunner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwMDozNjozM1rOHQxH0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwMDozNjozM1rOHQxH0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NDA4Mg==", "bodyText": "can you revert this change, in favor of #1194?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1189#discussion_r487344082", "createdAt": "2020-09-12T00:36:33Z", "author": {"login": "trask"}, "path": "testing-common/src/main/groovy/io/opentelemetry/auto/test/AgentTestRunner.java", "diffHunk": "@@ -104,7 +104,7 @@\n     INSTRUMENTATION = ByteBuddyAgent.getInstrumentation();\n \n     ((Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME)).setLevel(Level.WARN);\n-    ((Logger) LoggerFactory.getLogger(\"io.opentelemetry.auto\")).setLevel(Level.DEBUG);\n+    ((Logger) LoggerFactory.getLogger(\"io.opentelemetry.javaagent\")).setLevel(Level.DEBUG);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e6feedb1acef99360c99ae13befe6b49032df8b"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODQ5NjY4OnYy", "diffSide": "RIGHT", "path": "instrumentation/spring/spring-webflux-5.0/library/src/main/java/io/opentelemetry/instrumentation/spring/webflux/client/WebClientTracingFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwMDo0Mzo0MVrOHQxLpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwMDo0Mzo0MVrOHQxLpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NTA2MA==", "bodyText": "we don't use the @author tag anywhere else (in favor of git history/blame). maybe permalink(s) to the source file(s) in order to effectively cite the author via that repo's git history/blame?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @author Based on Spring Sleuth's Reactor instrumentation.\n          \n          \n            \n             * @author Marcin Grzejszczak\n          \n          \n            \n             * Based on Spring Sleuth's Reactor instrumentation.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1189#discussion_r487345060", "createdAt": "2020-09-12T00:43:41Z", "author": {"login": "trask"}, "path": "instrumentation/spring/spring-webflux-5.0/library/src/main/java/io/opentelemetry/instrumentation/spring/webflux/client/WebClientTracingFilter.java", "diffHunk": "@@ -20,51 +20,53 @@\n \n import io.opentelemetry.context.Scope;\n import io.opentelemetry.trace.Span;\n-import io.opentelemetry.trace.Tracer;\n import java.util.List;\n import org.springframework.web.reactive.function.client.ClientRequest;\n import org.springframework.web.reactive.function.client.ClientResponse;\n import org.springframework.web.reactive.function.client.ExchangeFilterFunction;\n import org.springframework.web.reactive.function.client.ExchangeFunction;\n+import reactor.core.CoreSubscriber;\n import reactor.core.publisher.Mono;\n \n+/**\n+ * @author Based on Spring Sleuth's Reactor instrumentation.\n+ * @author Marcin Grzejszczak", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e6feedb1acef99360c99ae13befe6b49032df8b"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODQ5NjkxOnYy", "diffSide": "RIGHT", "path": "instrumentation-core/reactor-3.1/src/main/java/io/opentelemetry/instrumentation/reactor/TracingOperator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwMDo0Mzo1OFrOHQxLwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwMDo0Mzo1OFrOHQxLwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NTA4OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            /** @author Based on Spring Sleuth's Reactor instrumentation. */\n          \n          \n            \n            /** Based on Spring Sleuth's Reactor instrumentation. */", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1189#discussion_r487345088", "createdAt": "2020-09-12T00:43:58Z", "author": {"login": "trask"}, "path": "instrumentation-core/reactor-3.1/src/main/java/io/opentelemetry/instrumentation/reactor/TracingOperator.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.reactor;\n+\n+import io.grpc.Context;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import org.reactivestreams.Publisher;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.Fuseable;\n+import reactor.core.Scannable;\n+import reactor.core.publisher.Hooks;\n+import reactor.core.publisher.Operators;\n+\n+/** @author Based on Spring Sleuth's Reactor instrumentation. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e6feedb1acef99360c99ae13befe6b49032df8b"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODUzNTk4OnYy", "diffSide": "RIGHT", "path": "instrumentation/cassandra/cassandra-3.0/src/test/groovy/CassandraClientTest.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwMToyNzowOFrOHQxfzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwMToyNzowOFrOHQxfzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM1MDIyMw==", "bodyText": "i'm getting this same failure in #1194 \ud83d\ude2d\nit's somehow due to fixing the logger name in AgentTestRunner, so if you revert that change you should be able to bring back this test, and i'll investigate as part of #1194", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1189#discussion_r487350223", "createdAt": "2020-09-12T01:27:08Z", "author": {"login": "trask"}, "path": "instrumentation/cassandra/cassandra-3.0/src/test/groovy/CassandraClientTest.groovy", "diffHunk": "@@ -128,10 +122,42 @@ class CassandraClientTest extends AgentTestRunner {\n     \"SELECT * FROM users where name = 'alice' ALLOW FILTERING\"                                         | \"async_test\"\n   }\n \n+  //TODO fix this test\n+  @Ignore(\"\"\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e6feedb1acef99360c99ae13befe6b49032df8b"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MjQyNTA0OnYy", "diffSide": "RIGHT", "path": "instrumentation/reactor-3.1/src/test/groovy/ReactorCoreTest.groovy", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMzoyOToyNVrOHSw50g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMzoyOToyNVrOHSw50g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQzNzY1MA==", "bodyText": "This comment doesn't match the assertions below. Not sure that is intended or not", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1189#discussion_r489437650", "createdAt": "2020-09-16T13:29:25Z", "author": {"login": "devinsba"}, "path": "instrumentation/reactor-3.1/src/test/groovy/ReactorCoreTest.groovy", "diffHunk": "@@ -242,117 +241,59 @@ class ReactorCoreTest extends AgentTestRunner {\n     }\n   }\n \n-  def \"Publisher chain spans have the correct parents from assembly time '#name'\"() {\n+  def \"Publisher chain spans have the correct parents from subscription time\"() {\n     when:\n-    runUnderTrace {\n-      // The \"add one\" operations in the publisher created here should be children of the publisher-parent\n-      Publisher<Integer> publisher = publisherSupplier()\n-\n-      def tracer = OpenTelemetry.getTracer(\"test\")\n-      def intermediate = tracer.spanBuilder(\"intermediate\").startSpan()\n-      // After this activation, the \"add two\" operations below should be children of this span\n-      def scope = tracer.withSpan(intermediate)\n-      try {\n-        if (publisher instanceof Mono) {\n-          return ((Mono) publisher).map(addTwo)\n-        } else if (publisher instanceof Flux) {\n-          return ((Flux) publisher).map(addTwo)\n-        }\n-        throw new IllegalStateException(\"Unknown publisher type\")\n-      } finally {\n-        intermediate.end()\n-        scope.close()\n-      }\n+    def mono = Mono.just(42)\n+      .map(addOne)\n+      .map(addTwo)\n+    TraceUtils.runUnderTrace(\"trace-parent\") {\n+      mono.block()\n     }\n \n     then:\n     assertTraces(1) {\n-      trace(0, (workItems * 2) + 3) {\n-        span(0) {\n-          operationName \"trace-parent\"\n-          parent()\n-          attributes {\n-          }\n-        }\n-\n-        basicSpan(it, 1, \"publisher-parent\", span(0))\n-        basicSpan(it, 2, \"intermediate\", span(1))\n-\n-        for (int i = 0; i < workItems; i++) {\n-          span(3 + i) {\n-            operationName \"add two\"\n-            childOf span(2)\n-            attributes {\n-            }\n-          }\n-        }\n-        for (int i = 0; i < workItems; i++) {\n-          span(3 + workItems + i) {\n-            operationName \"add one\"\n-            childOf span(1)\n-            attributes {\n-            }\n-          }\n-        }\n+      trace(0, 3) {\n+        basicSpan(it, 0, \"trace-parent\")\n+        basicSpan(it, 1, \"add one\", span(0))\n+        basicSpan(it, 2, \"add two\", span(0))\n       }\n     }\n \n-    where:\n-    name         | workItems | publisherSupplier\n-    \"basic mono\" | 1         | { -> Mono.just(1).map(addOne) }\n-    \"basic flux\" | 2         | { -> Flux.fromIterable([1, 2]).map(addOne) }\n   }\n \n-  def \"Publisher chain spans can have the parent removed at assembly time '#name'\"() {\n+  def \"Publisher chain spans have the correct parents from subscription time '#name'\"() {\n     when:\n     runUnderTrace {\n-      // The operations in the publisher created here all end up children of the publisher-parent\n+      // The \"add one\" operations in the publisher created here should be children of the publisher-parent\n       Publisher<Integer> publisher = publisherSupplier()\n \n-      // After this activation, all additions to the assembly will create new traces\n       def tracer = OpenTelemetry.getTracer(\"test\")\n-      def scope = tracer.withSpan(DefaultSpan.getInvalid())\n+      def intermediate = tracer.spanBuilder(\"intermediate\").startSpan()\n+      // After this activation, the \"add two\" operations below should be children of this span", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20396f810738bcc3fdf926f38fb7a47a1e2e28ba"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MzE2Njg3OnYy", "diffSide": "RIGHT", "path": "instrumentation/spring/spring-webflux-5.0/auto/src/test/groovy/SpringWebfluxTest.groovy", "isResolved": false, "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxNjowODowNVrOHS4Ivw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQwNDo1Mzo1MFrOIQFq_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU1NjE1OQ==", "bodyText": "I think this change was wrong. Now the modeling isn't correct:\nBEFORE:\nnetty handler\n-> spring controller\n---> traced method\n\nAFTER\nnetty handler\n-> spring controller\n-> traced method\n\nThe traced method ends up a child of the netty span instead of the spring controller span. This was the reason that I had captured the context at assembly time", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1189#discussion_r489556159", "createdAt": "2020-09-16T16:08:05Z", "author": {"login": "devinsba"}, "path": "instrumentation/spring/spring-webflux-5.0/auto/src/test/groovy/SpringWebfluxTest.groovy", "diffHunk": "@@ -173,7 +172,7 @@ class SpringWebfluxTest extends AgentTestRunner {\n         }\n         span(2) {\n           operationName \"tracedMethod\"\n-          childOf span(1)\n+          childOf span(0)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20396f810738bcc3fdf926f38fb7a47a1e2e28ba"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYyNjIzMg==", "bodyText": "This is not so obvious for me. If we run such application under profiler, then I expect that there will NOT be a single callstack with \"netty -> spring controler -> traced method\". Because traced method was actually executed AFTER returning from spring controller.\nIn addition I definitely expect that [start:end] of traced method IS NOT contained in [start:end] of spring controller. Currently it IS and I think this is a bug. Again, due to profiler/callstack argument above.\nFor these reasons I think that capturing context during assembly is wrong.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1189#discussion_r489626232", "createdAt": "2020-09-16T18:08:08Z", "author": {"login": "iNikem"}, "path": "instrumentation/spring/spring-webflux-5.0/auto/src/test/groovy/SpringWebfluxTest.groovy", "diffHunk": "@@ -173,7 +172,7 @@ class SpringWebfluxTest extends AgentTestRunner {\n         }\n         span(2) {\n           operationName \"tracedMethod\"\n-          childOf span(1)\n+          childOf span(0)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU1NjE1OQ=="}, "originalCommit": {"oid": "20396f810738bcc3fdf926f38fb7a47a1e2e28ba"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTY0ODcwNw==", "bodyText": "I follow what you are saying but from a user point of view, I would consider that traced method to be a part of my controller call. I understand that it runs after the controller returns but my intent as the user would be that the traced method is part of the controller", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1189#discussion_r489648707", "createdAt": "2020-09-16T18:36:25Z", "author": {"login": "devinsba"}, "path": "instrumentation/spring/spring-webflux-5.0/auto/src/test/groovy/SpringWebfluxTest.groovy", "diffHunk": "@@ -173,7 +172,7 @@ class SpringWebfluxTest extends AgentTestRunner {\n         }\n         span(2) {\n           operationName \"tracedMethod\"\n-          childOf span(1)\n+          childOf span(0)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU1NjE1OQ=="}, "originalCommit": {"oid": "20396f810738bcc3fdf926f38fb7a47a1e2e28ba"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTY1MTI3NA==", "bodyText": "@GetMapping(\"/foo-mono-from-callable/{id}\")\n  Mono<FooModel> getMonoFromCallable(@PathVariable(\"id\") long id) {\n    return Mono.fromCallable { return tracedMethod(id) }\n  }\n\n  @Trace()\n  private FooModel tracedMethod(long id) {\n    return new FooModel(id, \"tracedMethod\")\n  }\n\nI think this is an async modeling question but from a user point of view the model makes most sense to me to have tracedMethod as a child of getMonoFromCallable", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1189#discussion_r489651274", "createdAt": "2020-09-16T18:38:38Z", "author": {"login": "devinsba"}, "path": "instrumentation/spring/spring-webflux-5.0/auto/src/test/groovy/SpringWebfluxTest.groovy", "diffHunk": "@@ -173,7 +172,7 @@ class SpringWebfluxTest extends AgentTestRunner {\n         }\n         span(2) {\n           operationName \"tracedMethod\"\n-          childOf span(1)\n+          childOf span(0)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU1NjE1OQ=="}, "originalCommit": {"oid": "20396f810738bcc3fdf926f38fb7a47a1e2e28ba"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTY4MDQ4Mw==", "bodyText": "Yeah, that is kinda true. But there are examples of wrong traces in both cases: capture on assembly and capture on subscribe. I think the whole reactive story is currently very weak.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1189#discussion_r489680483", "createdAt": "2020-09-16T19:04:52Z", "author": {"login": "iNikem"}, "path": "instrumentation/spring/spring-webflux-5.0/auto/src/test/groovy/SpringWebfluxTest.groovy", "diffHunk": "@@ -173,7 +172,7 @@ class SpringWebfluxTest extends AgentTestRunner {\n         }\n         span(2) {\n           operationName \"tracedMethod\"\n-          childOf span(1)\n+          childOf span(0)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU1NjE1OQ=="}, "originalCommit": {"oid": "20396f810738bcc3fdf926f38fb7a47a1e2e28ba"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc1NjUxMw==", "bodyText": "This is an interesting example, and similar to:\n  @GetMapping(\"/foo-callable/{id}\")\n  Callable<FooModel> getCallable(@PathVariable(\"id\") long id) {\n    return () -> { return tracedMethod(id) }\n  }\n\n  @Trace()\n  private FooModel tracedMethod(long id) {\n    return new FooModel(id, \"tracedMethod\")\n  }\n\n(https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async-callable)\nWe wouldn't capture traced method under controller in this example either (since we capture context when passing the callable to the executor, and not when constructing the callable).", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1189#discussion_r489756513", "createdAt": "2020-09-16T21:11:07Z", "author": {"login": "trask"}, "path": "instrumentation/spring/spring-webflux-5.0/auto/src/test/groovy/SpringWebfluxTest.groovy", "diffHunk": "@@ -173,7 +172,7 @@ class SpringWebfluxTest extends AgentTestRunner {\n         }\n         span(2) {\n           operationName \"tracedMethod\"\n-          childOf span(1)\n+          childOf span(0)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU1NjE1OQ=="}, "originalCommit": {"oid": "20396f810738bcc3fdf926f38fb7a47a1e2e28ba"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc4NzA5MA==", "bodyText": "What do you think of propagating the context from the controller to the return value when the return value represents an asynchronously executed operation? This seems similar to how we propagate the context across other async boundaries.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1189#discussion_r489787090", "createdAt": "2020-09-16T22:23:34Z", "author": {"login": "trask"}, "path": "instrumentation/spring/spring-webflux-5.0/auto/src/test/groovy/SpringWebfluxTest.groovy", "diffHunk": "@@ -173,7 +172,7 @@ class SpringWebfluxTest extends AgentTestRunner {\n         }\n         span(2) {\n           operationName \"tracedMethod\"\n-          childOf span(1)\n+          childOf span(0)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU1NjE1OQ=="}, "originalCommit": {"oid": "20396f810738bcc3fdf926f38fb7a47a1e2e28ba"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkwNDE3NA==", "bodyText": "I don't grok reactor very well but @trask's example is pretty easy to understand. By the way, do we handle the span correctly? If the span ends when getCallable returns, it seems broken even outside of just context propagation. This seems like a very special case.\nMy understanding here is that spring seems to offer a very specific execution model - the user \"registers a task\", but the actual execution happens by the framework. Because this task corresponds to a request, we want it to also correspond to a Span. This seems like it requires very specific handling - I think it's what you're saying Trask and I agree with it.\nMy feeling is this is a spring (or any framework that provides a similar task registration execution model) specific aspect, I don't think it should leak into Reactor. It does seem true that we can't really guarantee when subscription happens, maybe it happens in the wrong context. But the \"reactive model\" I think is - register many callbacks and then execute by calling subscribe, as opposed to completablefuture where you register callbacks while executing. But in user code I would expect the vast majority of usages to expect that subscription to be the parent - it is similar to our concept of an \"invocation context\" which we often remount, and it should apply to reactor as well, the subscriber is the invoker. If that doesn't fit with a separate abstraction, like webflux, we could handle that separately.\nUnrelated to our instrumentation, but my understanding is that the challenge we have with reactive is they don't seem to define the concept of a scope but probably should - is the scope assembly, subscription, or something else, it's something that affects how we propagate and needs to be known. I personally use Dagger producers and never have context issues since it has a concept of a ProductionComponent which acts like a scope (similar to DI scopes). So all callbacks defined in that component run with the same context, the context of that scope. Works great, and no code required by the user as long as they follow the one requirement that the Dagger entrypoint needs to be executed in the request handler\n@Production defines the executor used when invoking a component - so just set it to the request executor and problem solved in the framework itself, ServerModule is depended on by all users to initialize the server and is the main entrypoint to the framework, similar to SpringApplication.run in a sense :)\nhttps://github.com/curioswitch/curiostack/blob/master/common/server/framework/src/main/java/org/curioswitch/common/server/framework/ServerModule.java#L250\nInvocation looks like this. Yes if that invocation happened after being delegated to a threadpool it wouldn't work, but my framework just doesn't allow that (would throw guaranteed runtime exception), knowing how important context is.\nhttps://github.com/curioswitch/curiostack/blob/master/cafe-map/server/src/main/java/org/curioswitch/cafemap/server/CafeMapService.java#L63\nUnlike my framework, reactor does not have such a requirement - but I think we can still expect common usage by users to be that the stream is \"scoped\" to the subscription point.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1189#discussion_r489904174", "createdAt": "2020-09-17T02:46:37Z", "author": {"login": "anuraaga"}, "path": "instrumentation/spring/spring-webflux-5.0/auto/src/test/groovy/SpringWebfluxTest.groovy", "diffHunk": "@@ -173,7 +172,7 @@ class SpringWebfluxTest extends AgentTestRunner {\n         }\n         span(2) {\n           operationName \"tracedMethod\"\n-          childOf span(1)\n+          childOf span(0)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU1NjE1OQ=="}, "originalCommit": {"oid": "20396f810738bcc3fdf926f38fb7a47a1e2e28ba"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc0MTA1NQ==", "bodyText": "@iNikem @trask Just random update on this point, @kojilin came up with an interesting example which further seems to make context at subscription time, not assembly time, make sense\nline/armeria#3051 (comment)\nIf contexting at assembly time, cache will generally cause disasters.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1189#discussion_r553741055", "createdAt": "2021-01-08T04:53:50Z", "author": {"login": "anuraaga"}, "path": "instrumentation/spring/spring-webflux-5.0/auto/src/test/groovy/SpringWebfluxTest.groovy", "diffHunk": "@@ -173,7 +172,7 @@ class SpringWebfluxTest extends AgentTestRunner {\n         }\n         span(2) {\n           operationName \"tracedMethod\"\n-          childOf span(1)\n+          childOf span(0)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU1NjE1OQ=="}, "originalCommit": {"oid": "20396f810738bcc3fdf926f38fb7a47a1e2e28ba"}, "originalPosition": 13}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4891, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}