{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMwMDYzMzc4", "number": 1811, "title": "Use Context more in HttpClientTracer", "bodyText": "return Context from HttpClientTracer.startSpan()\n\nadd CONTEXT_CLIENT_SPAN_KEY at this time\ninject context propagation headers at this time\n(the above are both especially nice for async http clients, which otherwise had no need to call startScope())\n\n\nno more need for HttpClientTracer.startScope()\ncan no long decide to suppress span during startSpan() (before it returned Span.getInvalid()) because the caller won't know whether to call end() or not on the Span in the returned Context\n\nso now introduces HttpClientTracer.shouldStartSpan() and calls that before calling startSpan()\n\n\n\nEDIT: Closes #1806\nCloses #946\nCHANGELOG:\n\nImprovements to the implementation and usage of HttpClientTracer classes", "createdAt": "2020-12-01T07:23:21Z", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811", "merged": true, "mergeCommit": {"oid": "65f54e450b36bbe2a136fcbf450edd08df1e6c24"}, "closed": true, "closedAt": "2020-12-03T19:47:09Z", "author": {"login": "trask"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdh0s-8AH2gAyNTMwMDYzMzc4Ojc1MmE2MzViOTk0YmVjYjgxYTVhYjJkZDY5ZmY3NWY1OWE2NTc5ZDM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdif2w2AFqTU0Mzc2NTgzNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "752a635b994becb81a5ab2dd69ff75f59a6579d3", "author": {"user": {"login": "trask", "name": "Trask Stalnaker"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/752a635b994becb81a5ab2dd69ff75f59a6579d3", "committedDate": "2020-12-01T07:20:56Z", "message": "Use Context more in HttpClientTracer"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxOTQwNzI4", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#pullrequestreview-541940728", "createdAt": "2020-12-01T14:21:56Z", "commit": {"oid": "752a635b994becb81a5ab2dd69ff75f59a6579d3"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNDoyMTo1NlrOH8uzOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNDo1NTo0N1rOH8wvVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ0MzM4NQ==", "bodyText": "Nit: consider renaming context to parentContext", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r533443385", "createdAt": "2020-12-01T14:21:56Z", "author": {"login": "mateuszrzeszutek"}, "path": "instrumentation-api/src/main/java/io/opentelemetry/instrumentation/api/tracer/HttpClientTracer.java", "diffHunk": "@@ -60,60 +59,67 @@ protected HttpClientTracer(Tracer tracer) {\n     super(tracer);\n   }\n \n-  public Span startSpan(REQUEST request) {\n-    return startSpan(request, -1);\n+  public boolean shouldStartSpan(Context context) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "752a635b994becb81a5ab2dd69ff75f59a6579d3"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ2MDE2OQ==", "bodyText": "Scope is closed in the helper onMethodExit() method below", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r533460169", "createdAt": "2020-12-01T14:42:04Z", "author": {"login": "mateuszrzeszutek"}, "path": "instrumentation/apache-httpclient/apache-httpclient-4.0/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/apachehttpclient/v4_0/ApacheHttpClientInstrumentationModule.java", "diffHunk": "@@ -147,127 +149,175 @@ public ApacheHttpClientInstrumentationModule() {\n \n   public static class UriRequestAdvice {\n     @Advice.OnMethodEnter(suppress = Throwable.class)\n-    public static SpanWithScope methodEnter(@Advice.Argument(0) HttpUriRequest request) {\n-      int callDepth = CallDepthThreadLocalMap.incrementCallDepth(HttpClient.class);\n-      if (callDepth > 0) {\n-        return null;\n+    public static void methodEnter(\n+        @Advice.Argument(0) HttpUriRequest request,\n+        @Advice.Local(\"otelContext\") Context context,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") CallDepth callDepth) {\n+      callDepth = tracer().getCallDepth();\n+      if (callDepth.getAndIncrement() != 0) {\n+        return;\n+      }\n+      Context parentContext = currentContext();\n+      if (!tracer().shouldStartSpan(parentContext)) {\n+        return;\n       }\n \n-      return ApacheHttpClientHelper.doMethodEnter(request);\n+      context = tracer().startSpan(parentContext, request, request);\n+      scope = context.makeCurrent();\n     }\n \n     @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n     public static void methodExit(\n-        @Advice.Enter SpanWithScope spanWithScope,\n         @Advice.Return Object result,\n-        @Advice.Thrown Throwable throwable) {\n-      ApacheHttpClientHelper.doMethodExitAndResetCallDepthThread(spanWithScope, result, throwable);\n+        @Advice.Thrown Throwable throwable,\n+        @Advice.Local(\"otelContext\") Context context,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") CallDepth callDepth) {\n+      if (callDepth.decrementAndGet() == 0 && scope != null) {\n+        scope.close();\n+        ApacheHttpClientHelper.doMethodExit(context, scope, result, throwable);\n+      }\n     }\n   }\n \n   public static class UriRequestWithHandlerAdvice {\n \n     @Advice.OnMethodEnter(suppress = Throwable.class)\n-    public static SpanWithScope methodEnter(\n+    public static void methodEnter(\n         @Advice.Argument(0) HttpUriRequest request,\n         @Advice.Argument(\n                 value = 1,\n                 optional = true,\n                 typing = Assigner.Typing.DYNAMIC,\n                 readOnly = false)\n-            Object handler) {\n-      int callDepth = CallDepthThreadLocalMap.incrementCallDepth(HttpClient.class);\n-      if (callDepth > 0) {\n-        return null;\n+            Object handler,\n+        @Advice.Local(\"otelContext\") Context context,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") CallDepth callDepth) {\n+      callDepth = tracer().getCallDepth();\n+      if (callDepth.getAndIncrement() != 0) {\n+        return;\n+      }\n+      Context parentContext = currentContext();\n+      if (!tracer().shouldStartSpan(parentContext)) {\n+        return;\n       }\n \n-      SpanWithScope spanWithScope = ApacheHttpClientHelper.doMethodEnter(request);\n+      context = tracer().startSpan(parentContext, request, request);\n+      scope = context.makeCurrent();\n \n       // Wrap the handler so we capture the status code\n       if (handler instanceof ResponseHandler) {\n-        handler =\n-            new WrappingStatusSettingResponseHandler(\n-                spanWithScope.getSpan(), (ResponseHandler) handler);\n+        handler = new WrappingStatusSettingResponseHandler(context, (ResponseHandler) handler);\n       }\n-      return spanWithScope;\n     }\n \n     @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n     public static void methodExit(\n-        @Advice.Enter SpanWithScope spanWithScope,\n         @Advice.Return Object result,\n-        @Advice.Thrown Throwable throwable) {\n-      ApacheHttpClientHelper.doMethodExitAndResetCallDepthThread(spanWithScope, result, throwable);\n+        @Advice.Thrown Throwable throwable,\n+        @Advice.Local(\"otelContext\") Context context,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") CallDepth callDepth) {\n+      if (callDepth.decrementAndGet() == 0 && scope != null) {\n+        scope.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "752a635b994becb81a5ab2dd69ff75f59a6579d3"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ3MjAwMQ==", "bodyText": "We lose some span attributes in several instrumentations with this change - can you create an issue for restoring them?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r533472001", "createdAt": "2020-12-01T14:51:46Z", "author": {"login": "mateuszrzeszutek"}, "path": "instrumentation/elasticsearch/elasticsearch-rest-5.0/javaagent/src/test/groovy/Elasticsearch5RestClientTest.groovy", "diffHunk": "@@ -98,18 +98,6 @@ class Elasticsearch5RestClientTest extends AgentTestRunner {\n             \"${SemanticAttributes.DB_OPERATION.key()}\" \"GET _cluster/health\"\n           }\n         }\n-        span(1) {\n-          name expectedOperationName(\"GET\")\n-          kind CLIENT\n-          childOf span(0)\n-          attributes {\n-            \"${SemanticAttributes.NET_TRANSPORT.key()}\" \"IP.TCP\"\n-            \"${SemanticAttributes.HTTP_URL.key()}\" \"_cluster/health\"\n-            \"${SemanticAttributes.HTTP_METHOD.key()}\" \"GET\"\n-            \"${SemanticAttributes.HTTP_STATUS_CODE.key()}\" 200\n-            \"${SemanticAttributes.HTTP_FLAVOR.key()}\" \"1.1\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "752a635b994becb81a5ab2dd69ff75f59a6579d3"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ3NTE1OQ==", "bodyText": "Does this comment still apply? There's no type casting here", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r533475159", "createdAt": "2020-12-01T14:55:47Z", "author": {"login": "mateuszrzeszutek"}, "path": "instrumentation/http-url-connection/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/httpurlconnection/HttpUrlConnectionInstrumentationModule.java", "diffHunk": "@@ -120,62 +125,30 @@ public static void methodExit(\n       CallDepthThreadLocalMap.reset(HttpURLConnection.class);\n \n       synchronized (state) {\n-        if (state.hasSpan() && !state.isFinished()) {\n+        if (state.context != null && !state.finished) {\n           if (throwable != null) {\n-            state.finishSpan(throwable);\n+            tracer().endExceptionally(state.context, throwable);\n+            state.finished = true;\n           } else if (\"getInputStream\".equals(methodName)) {\n-            state.finishSpan(responseCode);\n+            // responseCode field is sometimes not populated.\n+            // We can't call getResponseCode() due to some unwanted side-effects\n+            // (e.g. breaks getOutputStream).\n+            if (responseCode > 0) {\n+              // Need to explicitly cast to boxed type to make sure correct method is called.\n+              // https://github.com/open-telemetry/opentelemetry-java-instrumentation/issues/946\n+              tracer().end(state.context, responseCode);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "752a635b994becb81a5ab2dd69ff75f59a6579d3"}, "originalPosition": 72}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9462ee431a484af3d1110b60c2b367ccc5736fcd", "author": {"user": {"login": "trask", "name": "Trask Stalnaker"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/9462ee431a484af3d1110b60c2b367ccc5736fcd", "committedDate": "2020-12-01T21:35:22Z", "message": "Better http-url-connection response object"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "968a8e0f36b5deb44a5341708c27fac1a0569080", "author": {"user": {"login": "trask", "name": "Trask Stalnaker"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/968a8e0f36b5deb44a5341708c27fac1a0569080", "committedDate": "2020-12-01T21:35:46Z", "message": "Better param name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3eb93899f1695c2f2acbf5ce3ba98a242230f7b7", "author": {"user": {"login": "trask", "name": "Trask Stalnaker"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/3eb93899f1695c2f2acbf5ce3ba98a242230f7b7", "committedDate": "2020-12-01T21:38:24Z", "message": "Fix double scope close"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec2d4849c08bd824aac5eda34ac6c168a010f690", "author": {"user": {"login": "trask", "name": "Trask Stalnaker"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/ec2d4849c08bd824aac5eda34ac6c168a010f690", "committedDate": "2020-12-01T21:54:05Z", "message": "Follow database semantic conv for elasticsearch-rest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ca8ab322b154937368a81528a218fc685582712", "author": {"user": {"login": "trask", "name": "Trask Stalnaker"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/7ca8ab322b154937368a81528a218fc685582712", "committedDate": "2020-12-01T22:13:33Z", "message": "fixup! Follow database semantic conv for elasticsearch-rest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5041e3276adfb7574d3417044d1fe340475287ab", "author": {"user": {"login": "trask", "name": "Trask Stalnaker"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/5041e3276adfb7574d3417044d1fe340475287ab", "committedDate": "2020-12-02T01:50:37Z", "message": "Merge remote-tracking branch 'upstream/master' into http-client-tracer"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyNDg2OTI0", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#pullrequestreview-542486924", "createdAt": "2020-12-02T04:16:52Z", "commit": {"oid": "5041e3276adfb7574d3417044d1fe340475287ab"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwNDoxNjo1MlrOH9JzoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwNDoxODoyNFrOH9J1XQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg4NTg1Nw==", "bodyText": "This seems like a very boring method, do we need it?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r533885857", "createdAt": "2020-12-02T04:16:52Z", "author": {"login": "anuraaga"}, "path": "instrumentation/apache-httpasyncclient-4.0/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/apachehttpasyncclient/ApacheHttpAsyncClientTracer.java", "diffHunk": "@@ -30,6 +32,17 @@ public static ApacheHttpAsyncClientTracer tracer() {\n     return TRACER;\n   }\n \n+  public Context startSpan(Context parentContext) {\n+    Span span = super.startSpan(DEFAULT_SPAN_NAME, Span.Kind.CLIENT);\n+    return parentContext.with(span);\n+  }\n+\n+  public void inject(Context context, HttpRequest request) {\n+    OpenTelemetry.getGlobalPropagators()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5041e3276adfb7574d3417044d1fe340475287ab"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg4NjMwMQ==", "bodyText": "I might be missing a detail, but instead of shouldStartSpan everywhere, can't startSpan just return parentContext if it shouldn't start a new span?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r533886301", "createdAt": "2020-12-02T04:18:24Z", "author": {"login": "anuraaga"}, "path": "instrumentation/apache-httpclient/apache-httpclient-4.0/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/apachehttpclient/v4_0/ApacheHttpClientInstrumentationModule.java", "diffHunk": "@@ -147,127 +149,175 @@ public ApacheHttpClientInstrumentationModule() {\n \n   public static class UriRequestAdvice {\n     @Advice.OnMethodEnter(suppress = Throwable.class)\n-    public static SpanWithScope methodEnter(@Advice.Argument(0) HttpUriRequest request) {\n-      int callDepth = CallDepthThreadLocalMap.incrementCallDepth(HttpClient.class);\n-      if (callDepth > 0) {\n-        return null;\n+    public static void methodEnter(\n+        @Advice.Argument(0) HttpUriRequest request,\n+        @Advice.Local(\"otelContext\") Context context,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") CallDepth callDepth) {\n+      callDepth = tracer().getCallDepth();\n+      if (callDepth.getAndIncrement() != 0) {\n+        return;\n+      }\n+      Context parentContext = currentContext();\n+      if (!tracer().shouldStartSpan(parentContext)) {\n+        return;\n       }\n \n-      return ApacheHttpClientHelper.doMethodEnter(request);\n+      context = tracer().startSpan(parentContext, request, request);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5041e3276adfb7574d3417044d1fe340475287ab"}, "originalPosition": 52}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f7b5c0b571a07486c127d5154e482cc751c05146", "author": {"user": {"login": "trask", "name": "Trask Stalnaker"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/f7b5c0b571a07486c127d5154e482cc751c05146", "committedDate": "2020-12-02T04:24:48Z", "message": "Remove boring method"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyNTU1OTQ4", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#pullrequestreview-542555948", "createdAt": "2020-12-02T07:24:09Z", "commit": {"oid": "f7b5c0b571a07486c127d5154e482cc751c05146"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwNzoyNDowOVrOH9NgGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwNzo1ODowN1rOH9OeHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk0NjM5Mw==", "bodyText": "This is outdated", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r533946393", "createdAt": "2020-12-02T07:24:09Z", "author": {"login": "iNikem"}, "path": "instrumentation-api/src/main/java/io/opentelemetry/instrumentation/api/tracer/HttpClientTracer.java", "diffHunk": "@@ -60,60 +59,67 @@ protected HttpClientTracer(Tracer tracer) {\n     super(tracer);\n   }\n \n-  public Span startSpan(REQUEST request) {\n-    return startSpan(request, -1);\n+  public boolean shouldStartSpan(Context parentContext) {\n+    return parentContext.get(CONTEXT_CLIENT_SPAN_KEY) == null;\n   }\n \n-  public Span startSpan(REQUEST request, long startTimeNanos) {\n-    return internalStartSpan(request, spanNameForRequest(request), startTimeNanos);\n+  public Context startSpan(Context parentContext, REQUEST request, CARRIER carrier) {\n+    return startSpan(parentContext, request, carrier, -1);\n   }\n \n-  public Scope startScope(Span span, CARRIER carrier) {\n-    Context context = Context.current().with(span);\n-\n+  public Context startSpan(\n+      Context parentContext, REQUEST request, CARRIER carrier, long startTimeNanos) {\n+    Span span =\n+        internalStartSpan(parentContext, request, spanNameForRequest(request), startTimeNanos);\n     Setter<CARRIER> setter = getSetter();\n     if (setter == null) {\n       throw new IllegalStateException(\n           \"getSetter() not defined but calling startScope(), either getSetter must be implemented or the scope should be setup manually\");\n     }\n+    Context context = parentContext.with(span).with(CONTEXT_CLIENT_SPAN_KEY, span);\n     OpenTelemetry.getGlobalPropagators().getTextMapPropagator().inject(context, carrier, setter);\n-    context = context.with(CONTEXT_CLIENT_SPAN_KEY, span);\n-    return context.makeCurrent();\n+    return context;\n   }\n \n-  public void end(Span span, RESPONSE response) {\n-    end(span, response, -1);\n+  public void end(Context context, RESPONSE response) {\n+    end(context, response, -1);\n   }\n \n-  public void end(Span span, RESPONSE response, long endTimeNanos) {\n+  public void end(Context context, RESPONSE response, long endTimeNanos) {\n+    Span span = Span.fromContext(context);\n     onResponse(span, response);\n     super.end(span, endTimeNanos);\n   }\n \n-  public void endExceptionally(Span span, RESPONSE response, Throwable throwable) {\n-    endExceptionally(span, response, throwable, -1);\n+  public void end(Context context) {\n+    Span span = Span.fromContext(context);\n+    super.end(span);\n+  }\n+\n+  public void endExceptionally(Context context, RESPONSE response, Throwable throwable) {\n+    endExceptionally(context, response, throwable, -1);\n   }\n \n   public void endExceptionally(\n-      Span span, RESPONSE response, Throwable throwable, long endTimeNanos) {\n+      Context context, RESPONSE response, Throwable throwable, long endTimeNanos) {\n+    Span span = Span.fromContext(context);\n     onResponse(span, response);\n     super.endExceptionally(span, throwable, endTimeNanos);\n   }\n \n+  public void endExceptionally(Context context, Throwable throwable) {\n+    Span span = Span.fromContext(context);\n+    super.endExceptionally(span, throwable, -1);\n+  }\n+\n   /**\n    * Returns a new client {@link Span} if there is no client {@link Span} in the current {@link\n    * Context}, or an invalid {@link Span} otherwise.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7b5c0b571a07486c127d5154e482cc751c05146"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk0ODIyMg==", "bodyText": "Should this update client span in context as well?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r533948222", "createdAt": "2020-12-02T07:28:20Z", "author": {"login": "iNikem"}, "path": "instrumentation/apache-httpasyncclient-4.0/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/apachehttpasyncclient/ApacheHttpAsyncClientTracer.java", "diffHunk": "@@ -30,6 +31,11 @@ public static ApacheHttpAsyncClientTracer tracer() {\n     return TRACER;\n   }\n \n+  public Context startSpan(Context parentContext) {\n+    Span span = super.startSpan(DEFAULT_SPAN_NAME, Span.Kind.CLIENT);\n+    return parentContext.with(span);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7b5c0b571a07486c127d5154e482cc751c05146"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk0OTgxOA==", "bodyText": "inline?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r533949818", "createdAt": "2020-12-02T07:31:57Z", "author": {"login": "iNikem"}, "path": "instrumentation/armeria-1.0/library/src/main/java/io/opentelemetry/instrumentation/armeria/v1_0/client/OpenTelemetryClient.java", "diffHunk": "@@ -52,8 +53,10 @@ public HttpResponse execute(ClientRequestContext ctx, HttpRequest req) throws Ex\n     long requestStartTimeMicros =\n         ctx.log().ensureAvailable(RequestLogProperty.REQUEST_START_TIME).requestStartTimeMicros();\n     long requestStartTimeNanos = TimeUnit.MICROSECONDS.toNanos(requestStartTimeMicros);\n-    Span span = clientTracer.startSpan(ctx, requestStartTimeNanos);\n+    Context parentContext = Context.current();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7b5c0b571a07486c127d5154e482cc751c05146"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk1MTE2OQ==", "bodyText": "Can contextWithParent be null or not? These two ifs clearly disagrees on this.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r533951169", "createdAt": "2020-12-02T07:34:43Z", "author": {"login": "iNikem"}, "path": "instrumentation/async-http-client-1.9/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/asynchttpclient/ResponseAdvice.java", "diffHunk": "@@ -26,14 +25,14 @@ public static Scope onEnter(\n     // After response was handled by user provided handler.\n     ContextStore<AsyncHandler, Pair> contextStore =\n         InstrumentationContext.get(AsyncHandler.class, Pair.class);\n-    Pair<Context, Span> spanWithParent = contextStore.get(handler);\n-    if (null != spanWithParent) {\n+    Pair<Context, Context> contextWithParent = contextStore.get(handler);\n+    if (contextWithParent != null) {\n       contextStore.put(handler, null);\n     }\n-    if (spanWithParent.hasRight()) {\n-      AsyncHttpClientTracer.tracer().end(spanWithParent.getRight(), response);\n+    if (contextWithParent.hasRight()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7b5c0b571a07486c127d5154e482cc751c05146"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk1MjEyNQ==", "bodyText": "I think this is very suspicious. Why we make the context, which were active before http call on some other thread, active on response thread? Probably a separate issue from this PR but still", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r533952125", "createdAt": "2020-12-02T07:36:43Z", "author": {"login": "iNikem"}, "path": "instrumentation/async-http-client-1.9/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/asynchttpclient/ResponseAdvice.java", "diffHunk": "@@ -26,14 +25,14 @@ public static Scope onEnter(\n     // After response was handled by user provided handler.\n     ContextStore<AsyncHandler, Pair> contextStore =\n         InstrumentationContext.get(AsyncHandler.class, Pair.class);\n-    Pair<Context, Span> spanWithParent = contextStore.get(handler);\n-    if (null != spanWithParent) {\n+    Pair<Context, Context> contextWithParent = contextStore.get(handler);\n+    if (contextWithParent != null) {\n       contextStore.put(handler, null);\n     }\n-    if (spanWithParent.hasRight()) {\n-      AsyncHttpClientTracer.tracer().end(spanWithParent.getRight(), response);\n+    if (contextWithParent.hasRight()) {\n+      AsyncHttpClientTracer.tracer().end(contextWithParent.getRight(), response);\n     }\n-    return spanWithParent.hasLeft() ? spanWithParent.getLeft().makeCurrent() : null;\n+    return contextWithParent.hasLeft() ? contextWithParent.getLeft().makeCurrent() : null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7b5c0b571a07486c127d5154e482cc751c05146"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk1MzUxNw==", "bodyText": "Not sure about that. Seems like unrelated change and may be undesired", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r533953517", "createdAt": "2020-12-02T07:39:50Z", "author": {"login": "iNikem"}, "path": "instrumentation/elasticsearch/elasticsearch-rest-5.0/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/elasticsearch/rest/v5_0/Elasticsearch5RestClientInstrumentationModule.java", "diffHunk": "@@ -71,7 +71,6 @@ public static void onEnter(\n       span = tracer().startSpan(null, method + \" \" + endpoint);\n       scope = tracer().startScope(span);\n \n-      tracer().onRequest(span, method, endpoint);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7b5c0b571a07486c127d5154e482cc751c05146"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk1NDAyOA==", "bodyText": "I agree with Mateusz: this seems like undesired collateral damage", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r533954028", "createdAt": "2020-12-02T07:40:56Z", "author": {"login": "iNikem"}, "path": "instrumentation/elasticsearch/elasticsearch-rest-5.0/javaagent/src/test/groovy/Elasticsearch5RestClientTest.groovy", "diffHunk": "@@ -98,18 +98,6 @@ class Elasticsearch5RestClientTest extends AgentTestRunner {\n             \"${SemanticAttributes.DB_OPERATION.key()}\" \"GET _cluster/health\"\n           }\n         }\n-        span(1) {\n-          name expectedOperationName(\"GET\")\n-          kind CLIENT\n-          childOf span(0)\n-          attributes {\n-            \"${SemanticAttributes.NET_TRANSPORT.key()}\" \"IP.TCP\"\n-            \"${SemanticAttributes.HTTP_URL.key()}\" \"_cluster/health\"\n-            \"${SemanticAttributes.HTTP_METHOD.key()}\" \"GET\"\n-            \"${SemanticAttributes.HTTP_STATUS_CODE.key()}\" 200\n-            \"${SemanticAttributes.HTTP_FLAVOR.key()}\" \"1.1\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ3MjAwMQ=="}, "originalCommit": {"oid": "752a635b994becb81a5ab2dd69ff75f59a6579d3"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk1NjkzNA==", "bodyText": "I think this was used to allow for context injection into outgoing headers. Are you sure this still works?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r533956934", "createdAt": "2020-12-02T07:47:14Z", "author": {"login": "iNikem"}, "path": "instrumentation/khttp-0.1/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/khttp/KHttpAdvice.java", "diffHunk": "@@ -22,33 +23,36 @@ public static void methodEnter(\n       @Advice.Argument(value = 0) String method,\n       @Advice.Argument(value = 1) String uri,\n       @Advice.Argument(value = 2, readOnly = false) Map<String, String> headers,\n-      @Advice.Local(\"otelSpan\") Span span,\n+      @Advice.Local(\"otelContext\") Context context,\n       @Advice.Local(\"otelScope\") Scope scope,\n-      @Advice.Local(\"otelCallDepth\") Depth callDepth) {\n-\n+      @Advice.Local(\"otelCallDepth\") CallDepth callDepth) {\n     callDepth = tracer().getCallDepth();\n-    if (callDepth.getAndIncrement() == 0) {\n-      span = tracer().startSpan(new RequestWrapper(method, uri, headers));\n-      if (span.getSpanContext().isValid()) {\n-        headers = asWritable(headers);\n-        scope = tracer().startScope(span, headers);\n-      }\n+    if (callDepth.getAndIncrement() != 0) {\n+      return;\n     }\n+    Context parentContext = currentContext();\n+    if (!tracer().shouldStartSpan(parentContext)) {\n+      return;\n+    }\n+\n+    context = tracer().startSpan(parentContext, new RequestWrapper(method, uri, headers), headers);\n+    headers = asWritable(headers);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7b5c0b571a07486c127d5154e482cc751c05146"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk2MjI2OA==", "bodyText": "Is it a good idea to inject new context into outgoing request during startSpan? Technically, creating a new span does not make it \"active\" yet. It may never become one and then propagating its context is wrong. In this sense old startScope method was much better suited for context propagation.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r533962268", "createdAt": "2020-12-02T07:58:07Z", "author": {"login": "iNikem"}, "path": "instrumentation-api/src/main/java/io/opentelemetry/instrumentation/api/tracer/HttpClientTracer.java", "diffHunk": "@@ -60,60 +59,67 @@ protected HttpClientTracer(Tracer tracer) {\n     super(tracer);\n   }\n \n-  public Span startSpan(REQUEST request) {\n-    return startSpan(request, -1);\n+  public boolean shouldStartSpan(Context parentContext) {\n+    return parentContext.get(CONTEXT_CLIENT_SPAN_KEY) == null;\n   }\n \n-  public Span startSpan(REQUEST request, long startTimeNanos) {\n-    return internalStartSpan(request, spanNameForRequest(request), startTimeNanos);\n+  public Context startSpan(Context parentContext, REQUEST request, CARRIER carrier) {\n+    return startSpan(parentContext, request, carrier, -1);\n   }\n \n-  public Scope startScope(Span span, CARRIER carrier) {\n-    Context context = Context.current().with(span);\n-\n+  public Context startSpan(\n+      Context parentContext, REQUEST request, CARRIER carrier, long startTimeNanos) {\n+    Span span =\n+        internalStartSpan(parentContext, request, spanNameForRequest(request), startTimeNanos);\n     Setter<CARRIER> setter = getSetter();\n     if (setter == null) {\n       throw new IllegalStateException(\n           \"getSetter() not defined but calling startScope(), either getSetter must be implemented or the scope should be setup manually\");\n     }\n+    Context context = parentContext.with(span).with(CONTEXT_CLIENT_SPAN_KEY, span);\n     OpenTelemetry.getGlobalPropagators().getTextMapPropagator().inject(context, carrier, setter);\n-    context = context.with(CONTEXT_CLIENT_SPAN_KEY, span);\n-    return context.makeCurrent();\n+    return context;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7b5c0b571a07486c127d5154e482cc751c05146"}, "originalPosition": 40}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "65a31911a4eda6fd4bfe4bbd206adc4811107902", "author": {"user": {"login": "trask", "name": "Trask Stalnaker"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/65a31911a4eda6fd4bfe4bbd206adc4811107902", "committedDate": "2020-12-02T21:51:09Z", "message": "Feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "815cf1da3d0bc5f954cbc04c59b7d45f0e0fde7e", "author": {"user": {"login": "trask", "name": "Trask Stalnaker"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/815cf1da3d0bc5f954cbc04c59b7d45f0e0fde7e", "committedDate": "2020-12-03T03:57:48Z", "message": "Fix khttp advice"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9428a58d8e93b68a4f29854d96cbe35da967da66", "author": {"user": {"login": "trask", "name": "Trask Stalnaker"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/9428a58d8e93b68a4f29854d96cbe35da967da66", "committedDate": "2020-12-03T04:58:17Z", "message": "Remove unnecessary CallDepth tracking"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzNzY1ODM1", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#pullrequestreview-543765835", "createdAt": "2020-12-03T09:37:32Z", "commit": {"oid": "9428a58d8e93b68a4f29854d96cbe35da967da66"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2111, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}