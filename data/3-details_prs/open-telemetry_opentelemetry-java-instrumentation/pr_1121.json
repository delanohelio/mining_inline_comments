{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc1Mjc3MDA2", "number": 1121, "title": "JDK 11 HttpClient instrumentation", "bodyText": "", "createdAt": "2020-08-28T08:53:04Z", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121", "merged": true, "mergeCommit": {"oid": "f0eaa5f0faa04a0313f72208934085065e42651b"}, "closed": true, "closedAt": "2020-09-10T07:04:53Z", "author": {"login": "malafeev"}, "timelineItems": {"totalCount": 27, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdDRDtpgH2gAyNDc1Mjc3MDA2OjZhNWIxYjIzYzE2M2RhNmZiNzBhN2Q1NGE2N2ExYzQ3NWIwYjAzZTI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdHbV18AFqTQ4NTYzNzk3OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "6a5b1b23c163da6fb70a7d54a67a1c475b0b03e2", "author": {"user": {"login": "malafeev", "name": "Sergei Malafeev"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/6a5b1b23c163da6fb70a7d54a67a1c475b0b03e2", "committedDate": "2020-08-28T08:51:27Z", "message": "JDK 11 HttpClient instrumentation\n\nSigned-off-by: Sergei Malafeev <sergei@malafeev.org>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2ea534d3fcffa6cb63676c1b660bce5ce9618ac", "author": {"user": {"login": "malafeev", "name": "Sergei Malafeev"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/e2ea534d3fcffa6cb63676c1b660bce5ce9618ac", "committedDate": "2020-08-28T09:03:08Z", "message": "get rid of semicolon\n\nSigned-off-by: Sergei Malafeev <sergei@malafeev.org>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54a4f5902b91995874ef6ff69705023bfae76178", "author": {"user": {"login": "malafeev", "name": "Sergei Malafeev"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/54a4f5902b91995874ef6ff69705023bfae76178", "committedDate": "2020-08-31T12:18:30Z", "message": "Merge branch 'master' into jdk-11-httpclient"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "65133ca15795cee859a49c575e5bf4eaf544f35d", "author": {"user": {"login": "malafeev", "name": "Sergei Malafeev"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/65133ca15795cee859a49c575e5bf4eaf544f35d", "committedDate": "2020-09-01T15:49:38Z", "message": "trace sync request\n\nSigned-off-by: Sergei Malafeev <sergei@malafeev.org>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a87f33fd4e4e389ce771073b09edbb5919bd9983", "author": {"user": {"login": "malafeev", "name": "Sergei Malafeev"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/a87f33fd4e4e389ce771073b09edbb5919bd9983", "committedDate": "2020-09-02T01:26:19Z", "message": "get rid of unnecessary gradle options\n\nSigned-off-by: Sergei Malafeev <sergei@malafeev.org>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1a63765316568f0b34fe057f9ed898a9044869e", "author": {"user": {"login": "malafeev", "name": "Sergei Malafeev"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/e1a63765316568f0b34fe057f9ed898a9044869e", "committedDate": "2020-09-02T01:27:14Z", "message": "Merge branch 'master' into jdk-11-httpclient"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36ae437db8598ba66e79390567e937704201768d", "author": {"user": {"login": "malafeev", "name": "Sergei Malafeev"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/36ae437db8598ba66e79390567e937704201768d", "committedDate": "2020-09-02T14:37:11Z", "message": "wip\n\nSigned-off-by: Sergei Malafeev <sergei@malafeev.org>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxNDcyMzg0", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#pullrequestreview-481472384", "createdAt": "2020-09-03T03:49:18Z", "commit": {"oid": "36ae437db8598ba66e79390567e937704201768d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwMzo0OToxOFrOHMU2Dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwMzo0OToxOFrOHMU2Dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY4NjQ3OQ==", "bodyText": "@malafeev Have you tried running with debug logs? I'm guessing this instrumentation is \"getting muzzled\". Lambdas create additional anonymous classes, so I believe you need to add something like `packageName + HttpClientInstrumentation$1\" to the helper classes list.\nBecause this is a bit magical I tend to avoid lambdas in instrumentation, and instead define a class that implements the interface (effectively same bytecode). Though I've found that even that doesn't always work...\nhttps://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1153/files#r481762196", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r482686479", "createdAt": "2020-09-03T03:49:18Z", "author": {"login": "anuraaga"}, "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpClientInstrumentation.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import static io.opentelemetry.instrumentation.auto.httpclient.JdkHttpClientTracer.TRACER;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.instrumentation.auto.api.CallDepthThreadLocalMap.Depth;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import io.opentelemetry.trace.Span;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandler;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.implementation.bytecode.assign.Assigner.Typing;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+@AutoService(Instrumenter.class)\n+public class HttpClientInstrumentation extends Instrumenter.Default {\n+\n+  public HttpClientInstrumentation() {\n+    super(\"httpclient\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"java.net.http.HttpRequest\", Context.class.getName());\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return nameStartsWith(\"java.net.\")\n+        .or(ElementMatchers.<TypeDescription>nameStartsWith(\"jdk.internal.\"))\n+        .and(not(named(\"jdk.internal.net.http.HttpClientFacade\")))\n+        .and(extendsClass(named(\"java.net.http.HttpClient\")));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".HttpHeadersInjectAdapter\",\n+      packageName + \".JdkHttpClientTracer\",\n+      packageName + \".TracingBodyHandler\"\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+\n+    transformers.put(\n+        isMethod()\n+            .and(named(\"send\"))\n+            .and(isPublic())\n+            .and(takesArguments(2))\n+            .and(takesArgument(0, named(\"java.net.http.HttpRequest\"))),\n+        HttpClientInstrumentation.class.getName() + \"$SendAdvice\");\n+\n+    transformers.put(\n+        isMethod()\n+            .and(named(\"sendAsync\"))\n+            .and(isPublic())\n+            .and(takesArgument(0, named(\"java.net.http.HttpRequest\")))\n+            .and(takesArgument(1, named(\"java.net.http.HttpResponse$BodyHandler\"))),\n+        HttpClientInstrumentation.class.getName() + \"$SendAsyncAdvice\");\n+\n+    return transformers;\n+  }\n+\n+  public static class SendAdvice {\n+\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void methodEnter(\n+        @Advice.Argument(value = 0) HttpRequest httpRequest,\n+        @Advice.Local(\"otelSpan\") Span span,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") Depth callDepth) {\n+\n+      callDepth = TRACER.getCallDepth();\n+      if (callDepth.getAndIncrement() == 0) {\n+        span = TRACER.startSpan(httpRequest);\n+        if (span.getContext().isValid()) {\n+          scope = TRACER.startScope(span, httpRequest);\n+        }\n+      }\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void methodExit(\n+        @Advice.Return HttpResponse result,\n+        @Advice.Thrown Throwable throwable,\n+        @Advice.Local(\"otelSpan\") Span span,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") Depth callDepth) {\n+\n+      if (callDepth.decrementAndGet() == 0 && scope != null) {\n+        scope.close();\n+        if (throwable == null) {\n+          TRACER.end(span, result);\n+        } else {\n+          TRACER.endExceptionally(span, result, throwable);\n+        }\n+      }\n+    }\n+  }\n+\n+  public static class SendAsyncAdvice {\n+\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void methodEnter(\n+        @Advice.Argument(value = 0) HttpRequest httpRequest,\n+        @Advice.Argument(value = 1, readOnly = false) BodyHandler<?> bodyHandler,\n+        @Advice.Local(\"otelSpan\") Span span,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") Depth callDepth) {\n+\n+      callDepth = TRACER.getCallDepth();\n+      if (callDepth.getAndIncrement() == 0) {\n+        span = TRACER.startSpan(httpRequest);\n+        bodyHandler = new TracingBodyHandler<>(bodyHandler, span);\n+        if (span.getContext().isValid()) {\n+          scope = TRACER.startScope(span, httpRequest);\n+        }\n+      }\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void methodExit(\n+        @Advice.Return(readOnly = false, typing = Typing.DYNAMIC) CompletableFuture<?> future,\n+        @Advice.Thrown Throwable throwable,\n+        @Advice.Local(\"otelSpan\") Span span,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") Depth callDepth) {\n+\n+      if (callDepth.decrementAndGet() == 0 && scope != null) {\n+        scope.close();\n+        if (throwable != null) {\n+          TRACER.endExceptionally(span, null, throwable);\n+        } else {\n+          // FIXME: next lines breaks interception\n+          future =\n+              future.whenComplete(\n+                  (o, t) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36ae437db8598ba66e79390567e937704201768d"}, "originalPosition": 174}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb2d2529e145ac595736733fbb7e6ae48e06d5cf", "author": {"user": {"login": "malafeev", "name": "Sergei Malafeev"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/fb2d2529e145ac595736733fbb7e6ae48e06d5cf", "committedDate": "2020-09-03T12:28:00Z", "message": "end span when future completed\n\nSigned-off-by: Sergei Malafeev <sergei@malafeev.org>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "39da54b66542af837c0a5cf4198407ad1d3269c3", "author": {"user": {"login": "malafeev", "name": "Sergei Malafeev"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/39da54b66542af837c0a5cf4198407ad1d3269c3", "committedDate": "2020-09-03T12:33:03Z", "message": "remove unneeded check\n\nSigned-off-by: Sergei Malafeev <sergei@malafeev.org>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c04109d1b61bd4c62abfba4b9958d8fe5811f0a3", "author": {"user": {"login": "malafeev", "name": "Sergei Malafeev"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/c04109d1b61bd4c62abfba4b9958d8fe5811f0a3", "committedDate": "2020-09-03T13:35:36Z", "message": "get rid of repeated test code\n\nSigned-off-by: Sergei Malafeev <sergei@malafeev.org>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec54179be024c07fd00cdabd5b8e86f23af9dd98", "author": {"user": {"login": "malafeev", "name": "Sergei Malafeev"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/ec54179be024c07fd00cdabd5b8e86f23af9dd98", "committedDate": "2020-09-03T13:36:54Z", "message": "get rid of unneeded code\n\nSigned-off-by: Sergei Malafeev <sergei@malafeev.org>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c34ca7dd15fe37592edb1f4d0813fea7cc38697b", "author": {"user": {"login": "malafeev", "name": "Sergei Malafeev"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/c34ca7dd15fe37592edb1f4d0813fea7cc38697b", "committedDate": "2020-09-03T13:42:05Z", "message": "remove semicolon\n\nSigned-off-by: Sergei Malafeev <sergei@malafeev.org>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NzEyMTg4", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#pullrequestreview-484712188", "createdAt": "2020-09-09T06:58:23Z", "commit": {"oid": "c34ca7dd15fe37592edb1f4d0813fea7cc38697b"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNjo1ODoyM1rOHO5Ubw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNzowNDoyOFrOHO5few==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MTIzMQ==", "bodyText": "Can you add classloader matcher as well? It usually gives a significant performance boost.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485381231", "createdAt": "2020-09-09T06:58:23Z", "author": {"login": "iNikem"}, "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpClientInstrumentation.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import static io.opentelemetry.instrumentation.auto.httpclient.JdkHttpClientTracer.TRACER;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.instrumentation.auto.api.CallDepthThreadLocalMap.Depth;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import io.opentelemetry.trace.Span;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.implementation.bytecode.assign.Assigner.Typing;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+@AutoService(Instrumenter.class)\n+public class HttpClientInstrumentation extends Instrumenter.Default {\n+\n+  public HttpClientInstrumentation() {\n+    super(\"httpclient\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"java.net.http.HttpRequest\", Context.class.getName());\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c34ca7dd15fe37592edb1f4d0813fea7cc38697b"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MTM3OA==", "bodyText": "Why two nameStartsWith are used differently?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485381378", "createdAt": "2020-09-09T06:58:43Z", "author": {"login": "iNikem"}, "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpClientInstrumentation.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import static io.opentelemetry.instrumentation.auto.httpclient.JdkHttpClientTracer.TRACER;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.instrumentation.auto.api.CallDepthThreadLocalMap.Depth;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import io.opentelemetry.trace.Span;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.implementation.bytecode.assign.Assigner.Typing;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+@AutoService(Instrumenter.class)\n+public class HttpClientInstrumentation extends Instrumenter.Default {\n+\n+  public HttpClientInstrumentation() {\n+    super(\"httpclient\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"java.net.http.HttpRequest\", Context.class.getName());\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return nameStartsWith(\"java.net.\")\n+        .or(ElementMatchers.<TypeDescription>nameStartsWith(\"jdk.internal.\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c34ca7dd15fe37592edb1f4d0813fea7cc38697b"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MjEwMg==", "bodyText": "So we don't support context propagation via this http client?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485382102", "createdAt": "2020-09-09T07:00:11Z", "author": {"login": "iNikem"}, "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpHeadersInjectAdapter.java", "diffHunk": "@@ -0,0 +1,29 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import io.opentelemetry.context.propagation.TextMapPropagator;\n+import java.net.http.HttpRequest;\n+\n+public class HttpHeadersInjectAdapter implements TextMapPropagator.Setter<HttpRequest> {\n+  public static final HttpHeadersInjectAdapter SETTER = new HttpHeadersInjectAdapter();\n+\n+  @Override\n+  public void set(HttpRequest carrier, String key, String value) {\n+    // Don't do anything because headers are immutable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c34ca7dd15fe37592edb1f4d0813fea7cc38697b"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MjI2NA==", "bodyText": "Remove commented code?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485382264", "createdAt": "2020-09-09T07:00:32Z", "author": {"login": "iNikem"}, "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpHeadersInstrumentation.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import static io.opentelemetry.instrumentation.auto.httpclient.JdkHttpClientTracer.TRACER;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.instrumentation.auto.api.concurrent.State;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpHeaders;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+@AutoService(Instrumenter.class)\n+public class HttpHeadersInstrumentation extends Instrumenter.Default {\n+\n+  public HttpHeadersInstrumentation() {\n+    super(\"httpclient\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(HttpClient.class.getName(), State.class.getName());\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return nameStartsWith(\"java.net.\")\n+        .or(ElementMatchers.<TypeDescription>nameStartsWith(\"jdk.internal.\"))\n+        // .and(not(named(\"jdk.internal.net.http.ImmutableHttpRequest\")))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c34ca7dd15fe37592edb1f4d0813fea7cc38697b"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MzM2MA==", "bodyText": "Why taking cause? Also I recommend overriding io.opentelemetry.instrumentation.api.tracer.BaseTracer#unwrapThrowable in JdkHttpClientTracer", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485383360", "createdAt": "2020-09-09T07:02:49Z", "author": {"login": "iNikem"}, "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/ResponseConsumer.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import static io.opentelemetry.instrumentation.auto.httpclient.JdkHttpClientTracer.TRACER;\n+\n+import io.opentelemetry.trace.Span;\n+import java.net.http.HttpResponse;\n+import java.util.Objects;\n+import java.util.function.BiConsumer;\n+\n+public class ResponseConsumer implements BiConsumer<HttpResponse<?>, Throwable> {\n+  private final Span span;\n+\n+  public ResponseConsumer(Span span) {\n+    this.span = span;\n+  }\n+\n+  @Override\n+  public void accept(HttpResponse<?> httpResponse, Throwable throwable) {\n+    if (throwable == null) {\n+      TRACER.end(span, httpResponse);\n+    } else {\n+      final Throwable cause = throwable.getCause();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c34ca7dd15fe37592edb1f4d0813fea7cc38697b"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4NDA1OQ==", "bodyText": "Move this near the check for java please.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485384059", "createdAt": "2020-09-09T07:04:28Z", "author": {"login": "iNikem"}, "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/matcher/GlobalIgnoresMatcher.java", "diffHunk": "@@ -64,6 +64,10 @@ private GlobalIgnoresMatcher(boolean skipAdditionalLibraryMatcher) {\n   public boolean matches(T target) {\n     String name = target.getActualName();\n \n+    if (name.startsWith(\"jdk.internal.net.http.\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c34ca7dd15fe37592edb1f4d0813fea7cc38697b"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0ODAxMzgy", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#pullrequestreview-484801382", "createdAt": "2020-09-09T08:57:32Z", "commit": {"oid": "c34ca7dd15fe37592edb1f4d0813fea7cc38697b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwODo1NzozM1rOHO9nQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwODo1NzozM1rOHO9nQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ1MTU4Ng==", "bodyText": "@malafeev Go ahead and restore this after merging master :)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485451586", "createdAt": "2020-09-09T08:57:33Z", "author": {"login": "anuraaga"}, "path": "instrumentation/httpclient/httpclient.gradle", "diffHunk": "@@ -0,0 +1,12 @@\n+ext {\n+  minJavaVersionForTests = JavaVersion.VERSION_11\n+}\n+\n+apply from: \"$rootDir/gradle/instrumentation.gradle\"\n+\n+// FIXME: how to pass muzzle (only for jdk 11+)\n+//muzzle {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c34ca7dd15fe37592edb1f4d0813fea7cc38697b"}, "originalPosition": 8}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cef48862cabab38c722c74e7fd12ab800031b5fe", "author": {"user": {"login": "malafeev", "name": "Sergei Malafeev"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/cef48862cabab38c722c74e7fd12ab800031b5fe", "committedDate": "2020-09-09T12:27:10Z", "message": "Merge branch 'master' into jdk-11-httpclient"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "106aa5d6ace77810e69b2349b9824a8ae23deb25", "author": {"user": {"login": "malafeev", "name": "Sergei Malafeev"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/106aa5d6ace77810e69b2349b9824a8ae23deb25", "committedDate": "2020-09-09T13:00:20Z", "message": "implement review comments\n\nSigned-off-by: Sergei Malafeev <sergei@malafeev.org>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1MDkzNjkz", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#pullrequestreview-485093693", "createdAt": "2020-09-09T14:51:58Z", "commit": {"oid": "106aa5d6ace77810e69b2349b9824a8ae23deb25"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1MzkwMDE0", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#pullrequestreview-485390014", "createdAt": "2020-09-09T20:44:54Z", "commit": {"oid": "106aa5d6ace77810e69b2349b9824a8ae23deb25"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQyMDo0NDo1NVrOHPZqXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQyMToxMjoxMlrOHPaflg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkxMTEzNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    @Advice.Return(readOnly = false, typing = Typing.DYNAMIC)\n          \n          \n            \n                        CompletableFuture<HttpResponse<?>> future,\n          \n          \n            \n                    @Advice.Return(readOnly = false) CompletableFuture<HttpResponse<?>> future,", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485911134", "createdAt": "2020-09-09T20:44:55Z", "author": {"login": "trask"}, "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpClientInstrumentation.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import static io.opentelemetry.instrumentation.auto.httpclient.JdkHttpClientTracer.TRACER;\n+import static io.opentelemetry.javaagent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.instrumentation.auto.api.CallDepthThreadLocalMap.Depth;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import io.opentelemetry.trace.Span;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.implementation.bytecode.assign.Assigner.Typing;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class HttpClientInstrumentation extends Instrumenter.Default {\n+\n+  public HttpClientInstrumentation() {\n+    super(\"httpclient\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\"java.net.http.HttpClient\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"java.net.http.HttpRequest\", Context.class.getName());\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return nameStartsWith(\"java.net.\")\n+        .or(nameStartsWith(\"jdk.internal.\"))\n+        .and(not(named(\"jdk.internal.net.http.HttpClientFacade\")))\n+        .and(extendsClass(named(\"java.net.http.HttpClient\")));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".HttpHeadersInjectAdapter\",\n+      packageName + \".JdkHttpClientTracer\",\n+      packageName + \".ResponseConsumer\"\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+\n+    transformers.put(\n+        isMethod()\n+            .and(named(\"send\"))\n+            .and(isPublic())\n+            .and(takesArguments(2))\n+            .and(takesArgument(0, named(\"java.net.http.HttpRequest\"))),\n+        HttpClientInstrumentation.class.getName() + \"$SendAdvice\");\n+\n+    transformers.put(\n+        isMethod()\n+            .and(named(\"sendAsync\"))\n+            .and(isPublic())\n+            .and(takesArgument(0, named(\"java.net.http.HttpRequest\"))),\n+        HttpClientInstrumentation.class.getName() + \"$SendAsyncAdvice\");\n+\n+    return transformers;\n+  }\n+\n+  public static class SendAdvice {\n+\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void methodEnter(\n+        @Advice.Argument(value = 0) HttpRequest httpRequest,\n+        @Advice.Local(\"otelSpan\") Span span,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") Depth callDepth) {\n+\n+      callDepth = TRACER.getCallDepth();\n+      if (callDepth.getAndIncrement() == 0) {\n+        span = TRACER.startSpan(httpRequest);\n+        if (span.getContext().isValid()) {\n+          scope = TRACER.startScope(span, httpRequest);\n+        }\n+      }\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void methodExit(\n+        @Advice.Return HttpResponse result,\n+        @Advice.Thrown Throwable throwable,\n+        @Advice.Local(\"otelSpan\") Span span,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") Depth callDepth) {\n+\n+      if (callDepth.decrementAndGet() == 0 && scope != null) {\n+        scope.close();\n+        if (throwable == null) {\n+          TRACER.end(span, result);\n+        } else {\n+          TRACER.endExceptionally(span, result, throwable);\n+        }\n+      }\n+    }\n+  }\n+\n+  public static class SendAsyncAdvice {\n+\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void methodEnter(\n+        @Advice.Argument(value = 0) HttpRequest httpRequest,\n+        @Advice.Local(\"otelSpan\") Span span,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") Depth callDepth) {\n+\n+      callDepth = TRACER.getCallDepth();\n+      if (callDepth.getAndIncrement() == 0) {\n+        span = TRACER.startSpan(httpRequest);\n+        if (span.getContext().isValid()) {\n+          scope = TRACER.startScope(span, httpRequest);\n+        }\n+      }\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void methodExit(\n+        @Advice.Return(readOnly = false, typing = Typing.DYNAMIC)\n+            CompletableFuture<HttpResponse<?>> future,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "106aa5d6ace77810e69b2349b9824a8ae23deb25"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkxMzA3OQ==", "bodyText": "this looks unused\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n              @Override\n          \n          \n            \n              public Map<String, String> contextStore() {\n          \n          \n            \n                return singletonMap(HttpClient.class.getName(), State.class.getName());\n          \n          \n            \n              }", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485913079", "createdAt": "2020-09-09T20:48:39Z", "author": {"login": "trask"}, "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpHeadersInstrumentation.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import static io.opentelemetry.instrumentation.auto.httpclient.JdkHttpClientTracer.TRACER;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.instrumentation.auto.api.concurrent.State;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpHeaders;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class HttpHeadersInstrumentation extends Instrumenter.Default {\n+\n+  public HttpHeadersInstrumentation() {\n+    super(\"httpclient\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(HttpClient.class.getName(), State.class.getName());\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "106aa5d6ace77810e69b2349b9824a8ae23deb25"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkxMzE3MQ==", "bodyText": "this looks unused\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n              @Override\n          \n          \n            \n              public Map<String, String> contextStore() {\n          \n          \n            \n                return singletonMap(\"java.net.http.HttpRequest\", Context.class.getName());\n          \n          \n            \n              }", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485913171", "createdAt": "2020-09-09T20:48:50Z", "author": {"login": "trask"}, "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpClientInstrumentation.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import static io.opentelemetry.instrumentation.auto.httpclient.JdkHttpClientTracer.TRACER;\n+import static io.opentelemetry.javaagent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.instrumentation.auto.api.CallDepthThreadLocalMap.Depth;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import io.opentelemetry.trace.Span;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.implementation.bytecode.assign.Assigner.Typing;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class HttpClientInstrumentation extends Instrumenter.Default {\n+\n+  public HttpClientInstrumentation() {\n+    super(\"httpclient\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\"java.net.http.HttpClient\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"java.net.http.HttpRequest\", Context.class.getName());\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "106aa5d6ace77810e69b2349b9824a8ae23deb25"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkxMzgzNg==", "bodyText": "good to add same classLoaderMatcher() here also from HttpClientInstrumentation", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485913836", "createdAt": "2020-09-09T20:50:08Z", "author": {"login": "trask"}, "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpHeadersInstrumentation.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import static io.opentelemetry.instrumentation.auto.httpclient.JdkHttpClientTracer.TRACER;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.instrumentation.auto.api.concurrent.State;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpHeaders;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class HttpHeadersInstrumentation extends Instrumenter.Default {\n+\n+  public HttpHeadersInstrumentation() {\n+    super(\"httpclient\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(HttpClient.class.getName(), State.class.getName());\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "106aa5d6ace77810e69b2349b9824a8ae23deb25"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkxNTU2Ng==", "bodyText": "this seems maybe too generic, same for the module name, maybe \"java-httpclient\"?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485915566", "createdAt": "2020-09-09T20:53:30Z", "author": {"login": "trask"}, "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/JdkHttpClientTracer.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.context.propagation.TextMapPropagator.Setter;\n+import io.opentelemetry.instrumentation.api.tracer.HttpClientTracer;\n+import io.opentelemetry.instrumentation.auto.api.CallDepthThreadLocalMap;\n+import io.opentelemetry.instrumentation.auto.api.CallDepthThreadLocalMap.Depth;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpHeaders;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletionException;\n+\n+public class JdkHttpClientTracer extends HttpClientTracer<HttpRequest, HttpRequest, HttpResponse> {\n+  public static final JdkHttpClientTracer TRACER = new JdkHttpClientTracer();\n+\n+  public Depth getCallDepth() {\n+    return CallDepthThreadLocalMap.getCallDepth(HttpClient.class);\n+  }\n+\n+  @Override\n+  protected String getInstrumentationName() {\n+    return \"io.opentelemetry.auto.httpclient\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "106aa5d6ace77810e69b2349b9824a8ae23deb25"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkyMTg5Nw==", "bodyText": "and add followRedirects(HttpClient.Redirect.NORMAL) to http client configuration above\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              boolean testRedirects() {\n          \n          \n            \n                // Generates 4 spans\n          \n          \n            \n              boolean testCircularRedirects() {", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485921897", "createdAt": "2020-09-09T21:06:07Z", "author": {"login": "trask"}, "path": "instrumentation/httpclient/src/test/groovy/JdkHttpClientTest.groovy", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import io.opentelemetry.auto.test.base.HttpClientTest\n+import spock.lang.Shared\n+import spock.lang.Timeout\n+\n+import java.net.http.HttpClient\n+import java.net.http.HttpRequest\n+import java.net.http.HttpResponse\n+import java.time.Duration\n+import java.time.temporal.ChronoUnit\n+\n+@Timeout(5)\n+abstract class JdkHttpClientTest extends HttpClientTest {\n+\n+  @Shared\n+  def client = HttpClient.newBuilder().connectTimeout(Duration.of(CONNECT_TIMEOUT_MS,\n+    ChronoUnit.MILLIS)).build()\n+\n+  @Override\n+  int doRequest(String method, URI uri, Map<String, String> headers, Closure callback) {\n+\n+    def builder = HttpRequest.newBuilder().uri(uri).method(method, HttpRequest.BodyPublishers.noBody())\n+\n+    headers.entrySet().each {\n+      builder.header(it.key, it.value)\n+    }\n+    def request = builder.build()\n+\n+    def resp = send(request)\n+    callback?.call()\n+    return resp.statusCode()\n+  }\n+\n+  abstract HttpResponse send(HttpRequest request)\n+\n+  @Override\n+  boolean testRedirects() {\n+    // Generates 4 spans", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "106aa5d6ace77810e69b2349b9824a8ae23deb25"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkyNDc1OA==", "bodyText": "i think this name is too generic, since there are many httpclient instrumentations, i think my suggestion would be java-httpclient", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485924758", "createdAt": "2020-09-09T21:12:12Z", "author": {"login": "trask"}, "path": "settings.gradle", "diffHunk": "@@ -91,6 +91,7 @@ include ':instrumentation:hibernate:hibernate-4.0'\n include ':instrumentation:hibernate:hibernate-4.3'\n include ':instrumentation:hibernate:hibernate-common'\n include ':instrumentation:http-url-connection'\n+include ':instrumentation:httpclient'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "106aa5d6ace77810e69b2349b9824a8ae23deb25"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e3d8aaf39d5ddbd0793e163142782373ec3c392", "author": {"user": {"login": "malafeev", "name": "Sergei Malafeev"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/0e3d8aaf39d5ddbd0793e163142782373ec3c392", "committedDate": "2020-09-10T06:01:30Z", "message": "Update instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpClientInstrumentation.java\n\nCo-authored-by: Trask Stalnaker <trask.stalnaker@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5215b8a7ebcc9cc56b41486bd8c3ce19b3b6b67", "author": {"user": {"login": "malafeev", "name": "Sergei Malafeev"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/e5215b8a7ebcc9cc56b41486bd8c3ce19b3b6b67", "committedDate": "2020-09-10T06:01:44Z", "message": "Update instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpClientInstrumentation.java\n\nCo-authored-by: Trask Stalnaker <trask.stalnaker@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8446e1a92d4d99330674b44b90b2484ae8f4e2bb", "author": {"user": {"login": "malafeev", "name": "Sergei Malafeev"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/8446e1a92d4d99330674b44b90b2484ae8f4e2bb", "committedDate": "2020-09-10T06:02:07Z", "message": "Update instrumentation/httpclient/src/test/groovy/JdkHttpClientTest.groovy\n\nCo-authored-by: Trask Stalnaker <trask.stalnaker@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d051bb30aca4f9e3d014a1e28938f3d2f7441733", "author": {"user": {"login": "malafeev", "name": "Sergei Malafeev"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/d051bb30aca4f9e3d014a1e28938f3d2f7441733", "committedDate": "2020-09-10T06:15:23Z", "message": "rename to java-httpclient\n\nSigned-off-by: Sergei Malafeev <sergei@malafeev.org>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21eb8e8693958866434bc2bcbce51838542e90e9", "author": {"user": {"login": "malafeev", "name": "Sergei Malafeev"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/21eb8e8693958866434bc2bcbce51838542e90e9", "committedDate": "2020-09-10T06:17:48Z", "message": "remove unused\n\nSigned-off-by: Sergei Malafeev <sergei@malafeev.org>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "94011b5d4d10987f7ad6053fd59de7beb0368cb0", "author": {"user": {"login": "malafeev", "name": "Sergei Malafeev"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/94011b5d4d10987f7ad6053fd59de7beb0368cb0", "committedDate": "2020-09-10T06:23:06Z", "message": "follow redirects\n\nSigned-off-by: Sergei Malafeev <sergei@malafeev.org>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ebc660a18959abb97df6ef4e55727084e436ee32", "author": {"user": {"login": "malafeev", "name": "Sergei Malafeev"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/ebc660a18959abb97df6ef4e55727084e436ee32", "committedDate": "2020-09-10T06:28:19Z", "message": "remove semicolon\n\nSigned-off-by: Sergei Malafeev <sergei@malafeev.org>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1NjM3OTc4", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#pullrequestreview-485637978", "createdAt": "2020-09-10T07:06:00Z", "commit": {"oid": "ebc660a18959abb97df6ef4e55727084e436ee32"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2520, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}