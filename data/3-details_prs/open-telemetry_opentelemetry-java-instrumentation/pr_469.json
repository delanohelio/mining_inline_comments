{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI2NjU0Mjkz", "number": 469, "title": "Deduplicate servlets", "bodyText": "Fixes #423 by extracting all common functionality of servlet instrumentation into one common place. So far Servlet 2, Servlet 3 and Grizzly were de-duplicated.\nExtracted from #466", "createdAt": "2020-06-02T15:18:53Z", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469", "merged": true, "mergeCommit": {"oid": "357fb6e98986dd40edce057f0c1892d372a0e18f"}, "closed": true, "closedAt": "2020-06-08T07:49:59Z", "author": {"login": "iNikem"}, "timelineItems": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABclBShcgH2gAyNDI2NjU0MjkzOjhmZWY2MjRmZDAxYmIzOWE5YjhiNmU2ZTNhYWY4YWM4Nzk2YmI2ZGY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcpK1zsAH2gAyNDI2NjU0MjkzOjBkNGZmMDI5YTkxYTdlOGYwYmE5YmY0ZDI0ZDJmZmVlZmIxNDFlZmY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8fef624fd01bb39a9b8b6e6e3aaf8ac8796bb6df", "author": {"user": {"login": "iNikem", "name": "Nikita Salnikov-Tarnovski"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/8fef624fd01bb39a9b8b6e6e3aaf8ac8796bb6df", "committedDate": "2020-05-26T09:31:25Z", "message": "Servlet instrumentations unified"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f0c6e7e146cd3d014ffe4b713b405110a983835", "author": {"user": {"login": "iNikem", "name": "Nikita Salnikov-Tarnovski"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/6f0c6e7e146cd3d014ffe4b713b405110a983835", "committedDate": "2020-05-26T18:59:58Z", "message": "Grizzly migrated"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e02f97cc309fce03b11685d1b1b0f4e12c77815", "author": {"user": {"login": "iNikem", "name": "Nikita Salnikov-Tarnovski"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/5e02f97cc309fce03b11685d1b1b0f4e12c77815", "committedDate": "2020-05-27T10:12:50Z", "message": "Merge remote-tracking branch 'upstream/master' into http-spans"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "83624f935b76b4972a831473689f5936dd66e9a1", "author": {"user": {"login": "iNikem", "name": "Nikita Salnikov-Tarnovski"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/83624f935b76b4972a831473689f5936dd66e9a1", "committedDate": "2020-05-27T11:10:49Z", "message": "Fix tests after merge"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e594f536a065b9613cbadad7923550bac439ff82", "author": {"user": {"login": "iNikem", "name": "Nikita Salnikov-Tarnovski"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/e594f536a065b9613cbadad7923550bac439ff82", "committedDate": "2020-06-02T12:01:51Z", "message": "Merge remote-tracking branch 'upstream/master' into deduplicate-servlets"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d69e63c5147d526c6b32ed7776d28b90f4fc3126", "author": {"user": {"login": "iNikem", "name": "Nikita Salnikov-Tarnovski"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/d69e63c5147d526c6b32ed7776d28b90f4fc3126", "committedDate": "2020-06-02T15:15:48Z", "message": "Polish and fix tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyOTgwNDE2", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#pullrequestreview-422980416", "createdAt": "2020-06-02T19:10:58Z", "commit": {"oid": "d69e63c5147d526c6b32ed7776d28b90f4fc3126"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxOToxMDo1OFrOGeAVaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxOTozMToyN1rOGeBCug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDExNTk0NQ==", "bodyText": "I think I'd keep SpanWithScope out of this this new API, and have HttpServerTracer return and work only on spans.\nSpanWithScope is primarily an auto-instrumentation detail to make it easier to pass them both between @OnMethodEnter and @OnMethodExit (in the future we could potentially get rid of it altogether using an extra @Local bytebuddy parameter, reducing memory allocations).", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r434115945", "createdAt": "2020-06-02T19:10:58Z", "author": {"login": "trask"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/HttpServerTracer.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n+\n+import static io.opentelemetry.OpenTelemetry.getPropagators;\n+import static io.opentelemetry.trace.Span.Kind.SERVER;\n+import static io.opentelemetry.trace.TracingContextUtils.currentContextWith;\n+import static io.opentelemetry.trace.TracingContextUtils.getSpan;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.auto.config.Config;\n+import io.opentelemetry.auto.instrumentation.api.MoreTags;\n+import io.opentelemetry.auto.instrumentation.api.SpanWithScope;\n+import io.opentelemetry.auto.instrumentation.api.Tags;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.reflect.Method;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import lombok.extern.slf4j.Slf4j;\n+\n+// TODO In search for a better home package\n+@Slf4j\n+public abstract class HttpServerTracer<REQUEST> {\n+  public static final String SPAN_ATTRIBUTE = \"io.opentelemetry.auto.span\";\n+\n+  protected final Tracer tracer;\n+\n+  public HttpServerTracer() {\n+    tracer = OpenTelemetry.getTracerProvider().get(getInstrumentationName(), getVersion());\n+  }\n+\n+  public SpanWithScope startSpan(REQUEST request, Method origin, String originType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d69e63c5147d526c6b32ed7776d28b90f4fc3126"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDExOTQ5Ng==", "bodyText": "I think this code is correct, short of checking response.isCommitted().\nFrom the servlet spec:\n\nIf the exception isn't caught and handled, and the response hasn\u2019t been committed, the status code MUST be set to 500", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r434119496", "createdAt": "2020-06-02T19:16:42Z", "author": {"login": "trask"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/HttpServerTracer.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n+\n+import static io.opentelemetry.OpenTelemetry.getPropagators;\n+import static io.opentelemetry.trace.Span.Kind.SERVER;\n+import static io.opentelemetry.trace.TracingContextUtils.currentContextWith;\n+import static io.opentelemetry.trace.TracingContextUtils.getSpan;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.auto.config.Config;\n+import io.opentelemetry.auto.instrumentation.api.MoreTags;\n+import io.opentelemetry.auto.instrumentation.api.SpanWithScope;\n+import io.opentelemetry.auto.instrumentation.api.Tags;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.reflect.Method;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import lombok.extern.slf4j.Slf4j;\n+\n+// TODO In search for a better home package\n+@Slf4j\n+public abstract class HttpServerTracer<REQUEST> {\n+  public static final String SPAN_ATTRIBUTE = \"io.opentelemetry.auto.span\";\n+\n+  protected final Tracer tracer;\n+\n+  public HttpServerTracer() {\n+    tracer = OpenTelemetry.getTracerProvider().get(getInstrumentationName(), getVersion());\n+  }\n+\n+  public SpanWithScope startSpan(REQUEST request, Method origin, String originType) {\n+    final Span existingSpan = getAttachedSpan(request);\n+    if (existingSpan != null) {\n+      /*\n+      Given request already has a span associated with it.\n+      As there should not be nested spans of kind SERVER, we should NOT create a new span here.\n+\n+      But it may happen that there is no span in current Context or it is from a different trace.\n+      E.g. in case of async servlet request processing we create span for incoming request in one thread,\n+      but actual request continues processing happens in another thread.\n+      Depending on servlet container implementation, this processing may again arrive into this method.\n+      E.g. Jetty handles async requests in a way that calls HttpServlet.service method twice.\n+\n+      In this case we have to put the span from the request into current context before continuing.\n+      */\n+      final boolean spanContextWasLost = !sameTrace(tracer.getCurrentSpan(), existingSpan);\n+      if (spanContextWasLost) {\n+        // Put span from request attribute into current context.\n+        // We did not create a new span here, so return null instead\n+        return new SpanWithScope(null, currentContextWith(existingSpan));\n+      } else {\n+        // We are inside nested servlet/filter, don't create new span\n+        return null;\n+      }\n+    }\n+\n+    final Span.Builder builder =\n+        tracer\n+            .spanBuilder(spanNameForMethod(origin))\n+            .setSpanKind(SERVER)\n+            .setParent(extract(request, getGetter()))\n+            // TODO Where span.origin.type is defined?\n+            .setAttribute(\"span.origin.type\", originType);\n+\n+    Span span = builder.startSpan();\n+    onConnection(span, request);\n+    onRequest(span, request);\n+\n+    return new SpanWithScope(span, currentContextWith(span));\n+  }\n+\n+  protected abstract String getVersion();\n+\n+  protected abstract String getInstrumentationName();\n+\n+  protected void onConnection(Span span, REQUEST request) {\n+    SemanticAttributes.NET_PEER_IP.set(span, peerHostIP(request));\n+    final Integer port = peerPort(request);\n+    // Negative or Zero ports might represent an unset/null value for an int type.  Skip setting.\n+    if (port != null && port > 0) {\n+      SemanticAttributes.NET_PEER_PORT.set(span, port);\n+    }\n+  }\n+\n+  private boolean sameTrace(Span oneSpan, Span otherSpan) {\n+    return oneSpan.getContext().getTraceId().equals(otherSpan.getContext().getTraceId());\n+  }\n+\n+  // TODO use semantic attributes\n+\n+  protected void onRequest(final Span span, final REQUEST request) {\n+    attachedSpanToRequest(span, request);\n+    SemanticAttributes.HTTP_METHOD.set(span, method(request));\n+\n+    // Copy of HttpClientDecorator url handling\n+    try {\n+      final URI url = url(request);\n+      if (url != null) {\n+        final StringBuilder urlBuilder = new StringBuilder();\n+        if (url.getScheme() != null) {\n+          urlBuilder.append(url.getScheme());\n+          urlBuilder.append(\"://\");\n+        }\n+        if (url.getHost() != null) {\n+          urlBuilder.append(url.getHost());\n+          if (url.getPort() > 0 && url.getPort() != 80 && url.getPort() != 443) {\n+            urlBuilder.append(\":\");\n+            urlBuilder.append(url.getPort());\n+          }\n+        }\n+        final String path = url.getPath();\n+        if (path.isEmpty()) {\n+          urlBuilder.append(\"/\");\n+        } else {\n+          urlBuilder.append(path);\n+        }\n+        final String query = url.getQuery();\n+        if (query != null) {\n+          urlBuilder.append(\"?\").append(query);\n+        }\n+        final String fragment = url.getFragment();\n+        if (fragment != null) {\n+          urlBuilder.append(\"#\").append(fragment);\n+        }\n+\n+        span.setAttribute(Tags.HTTP_URL, urlBuilder.toString());\n+\n+        if (Config.get().isHttpServerTagQueryString()) {\n+          span.setAttribute(MoreTags.HTTP_QUERY, url.getQuery());\n+          span.setAttribute(MoreTags.HTTP_FRAGMENT, url.getFragment());\n+        }\n+      }\n+    } catch (final Exception e) {\n+      log.debug(\"Error tagging url\", e);\n+    }\n+    // TODO set resource name from URL.\n+  }\n+  /**\n+   * This method is used to generate an acceptable span (operation) name based on a given method\n+   * reference. Anonymous classes are named based on their parent.\n+   */\n+  protected String spanNameForMethod(final Method method) {\n+    return spanNameForClass(method.getDeclaringClass()) + \".\" + method.getName();\n+  }\n+\n+  /**\n+   * This method is used to generate an acceptable span (operation) name based on a given class\n+   * reference. Anonymous classes are named based on their parent.\n+   */\n+  public String spanNameForClass(final Class clazz) {\n+    if (!clazz.isAnonymousClass()) {\n+      return clazz.getSimpleName();\n+    }\n+    String className = clazz.getName();\n+    if (clazz.getPackage() != null) {\n+      final String pkgName = clazz.getPackage().getName();\n+      if (!pkgName.isEmpty()) {\n+        className = clazz.getName().replace(pkgName, \"\").substring(1);\n+      }\n+    }\n+    return className;\n+  }\n+\n+  protected void onError(final Span span, final Throwable throwable) {\n+    addThrowable(span, unwrapThrowable(throwable));\n+  }\n+\n+  // TODO semantic attributes\n+  public static void addThrowable(final Span span, final Throwable throwable) {\n+    span.setAttribute(MoreTags.ERROR_MSG, throwable.getMessage());\n+    span.setAttribute(MoreTags.ERROR_TYPE, throwable.getClass().getName());\n+\n+    final StringWriter errorString = new StringWriter();\n+    throwable.printStackTrace(new PrintWriter(errorString));\n+    span.setAttribute(MoreTags.ERROR_STACK, errorString.toString());\n+  }\n+\n+  public Span getCurrentSpan() {\n+    return tracer.getCurrentSpan();\n+  }\n+\n+  // TODO should end methods remove SPAN attribute from request as well?\n+\n+  public void end(SpanWithScope spanWithScope, int responseCode) {\n+    if (spanWithScope == null) {\n+      return;\n+    }\n+\n+    final Span span = spanWithScope.getSpan();\n+    if (span != null) {\n+      end(span, responseCode);\n+    }\n+\n+    spanWithScope.closeScope();\n+  }\n+\n+  public void end(Span span, int responseStatus) {\n+    setStatus(span, responseStatus);\n+    span.end();\n+  }\n+\n+  public void endExceptionally(\n+      SpanWithScope spanWithScope, Throwable throwable, int responseStatus) {\n+    if (spanWithScope == null) {\n+      return;\n+    }\n+\n+    final Span span = spanWithScope.getSpan();\n+    if (span != null) {\n+      endExceptionally(span, throwable, responseStatus);\n+    }\n+\n+    spanWithScope.closeScope();\n+  }\n+\n+  public void endExceptionally(Span span, Throwable throwable, int responseStatus) {\n+    if (responseStatus == 200) {\n+      // TODO I think this is wrong.\n+      // We must report that response status that was actually sent to end user\n+      // We may change span status, but not http_status attribute", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d69e63c5147d526c6b32ed7776d28b90f4fc3126"}, "originalPosition": 243}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDExOTc4Mw==", "bodyText": "undo this change?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r434119783", "createdAt": "2020-06-02T19:17:08Z", "author": {"login": "trask"}, "path": "gradle/instrumentation.gradle", "diffHunk": "@@ -13,9 +13,9 @@ byteBuddy {\n \n apply from: \"${rootDir}/gradle/java.gradle\"\n \n-tasks.withType(Test) {\n-  forkEvery = 1\n-}\n+//tasks.withType(Test) {\n+//  forkEvery = 1\n+//}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d69e63c5147d526c6b32ed7776d28b90f4fc3126"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEyMjIwNg==", "bodyText": "This is for adding traceId and spanId to access logs, so you can correlate access logs with traces (e.g. https://tomcat.apache.org/tomcat-8.0-doc/config/valve.html#Access_Log_Valve/Attributes).", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r434122206", "createdAt": "2020-06-02T19:21:32Z", "author": {"login": "trask"}, "path": "instrumentation/servlet/servlet-common/src/main/java/io/opentelemetry/auto/instrumentation/servlet/ServletHttpServerTracer.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.auto.instrumentation.servlet;\n+\n+import io.opentelemetry.auto.bootstrap.instrumentation.decorator.HttpServerTracer;\n+import io.opentelemetry.auto.instrumentation.api.MoreTags;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.context.propagation.HttpTextFormat.Getter;\n+import io.opentelemetry.trace.Span;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.security.Principal;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public abstract class ServletHttpServerTracer extends HttpServerTracer<HttpServletRequest> {\n+\n+  protected String getVersion() {\n+    return null;\n+  }\n+\n+  @Override\n+  // TODO this violates convention\n+  protected URI url(HttpServletRequest httpServletRequest) throws URISyntaxException {\n+    return new URI(\n+        httpServletRequest.getScheme(),\n+        null,\n+        httpServletRequest.getServerName(),\n+        httpServletRequest.getServerPort(),\n+        httpServletRequest.getRequestURI(),\n+        httpServletRequest.getQueryString(),\n+        null);\n+  }\n+\n+  @Override\n+  protected Span getAttachedSpan(HttpServletRequest request) {\n+    Object span = request.getAttribute(SPAN_ATTRIBUTE);\n+    return span instanceof Span ? (Span) span : null;\n+  }\n+\n+  @Override\n+  protected void attachedSpanToRequest(Span span, HttpServletRequest request) {\n+    request.setAttribute(SPAN_ATTRIBUTE, span);\n+  }\n+\n+  @Override\n+  protected Integer peerPort(HttpServletRequest request) {\n+    // HttpServletResponse doesn't have accessor for remote port prior to Servlet spec 3.0\n+    return null;\n+  }\n+\n+  @Override\n+  protected String peerHostIP(HttpServletRequest request) {\n+    return request.getRemoteAddr();\n+  }\n+\n+  @Override\n+  protected String method(HttpServletRequest request) {\n+    return request.getMethod();\n+  }\n+\n+  public void onRequest(Span span, HttpServletRequest request) {\n+    // TODO why?\n+    request.setAttribute(\"traceId\", span.getContext().getTraceId().toLowerBase16());\n+    request.setAttribute(\"spanId\", span.getContext().getSpanId().toLowerBase16());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d69e63c5147d526c6b32ed7776d28b90f4fc3126"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEyNjIyNA==", "bodyText": "I think it's incorrect that we are not setting \"user.principal\" on the current span here, but it's not related to this PR (which just preserves existing behavior), so I opened a separate issue to track #470", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r434126224", "createdAt": "2020-06-02T19:28:54Z", "author": {"login": "trask"}, "path": "instrumentation/servlet/request-2.3/src/main/java/io/opentelemetry/auto/instrumentation/servlet/v2_3/Servlet2Advice.java", "diffHunk": "@@ -90,40 +55,17 @@ public static void stopSpan(\n       @Advice.Argument(1) final ServletResponse response,\n       @Advice.Enter final SpanWithScope spanWithScope,\n       @Advice.Thrown final Throwable throwable) {\n-    // Set user.principal regardless of who created this span.\n-    final Object spanAttr = request.getAttribute(SPAN_ATTRIBUTE);\n-    if (spanAttr instanceof Span && request instanceof HttpServletRequest) {\n-      final Principal principal = ((HttpServletRequest) request).getUserPrincipal();\n-      if (principal != null) {\n-        ((Span) spanAttr).setAttribute(MoreTags.USER_NAME, principal.getName());\n-      }\n-    }\n+    if (request instanceof HttpServletRequest && response instanceof HttpServletResponse) {\n+      TRACER.setPrincipal((HttpServletRequest) request);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d69e63c5147d526c6b32ed7776d28b90f4fc3126"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEyNzU0Ng==", "bodyText": "to save on memory:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private final Servlet3HttpServerTracer servletHttpServerTracer;\n          \n          \n            \n              private static final Servlet3HttpServerTracer servletHttpServerTracer = new Servlet3HttpServerTracer();", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r434127546", "createdAt": "2020-06-02T19:31:27Z", "author": {"login": "trask"}, "path": "instrumentation/servlet/request-3.0/src/main/java/io/opentelemetry/auto/instrumentation/servlet/v3_0/TagSettingAsyncListener.java", "diffHunk": "@@ -15,57 +15,48 @@\n  */\n package io.opentelemetry.auto.instrumentation.servlet.v3_0;\n \n-import static io.opentelemetry.auto.instrumentation.servlet.v3_0.Servlet3Decorator.DECORATE;\n-\n-import io.opentelemetry.auto.instrumentation.api.Tags;\n import io.opentelemetry.trace.Span;\n-import io.opentelemetry.trace.Status;\n import java.util.concurrent.atomic.AtomicBoolean;\n import javax.servlet.AsyncEvent;\n import javax.servlet.AsyncListener;\n import javax.servlet.http.HttpServletResponse;\n \n public class TagSettingAsyncListener implements AsyncListener {\n-  private final AtomicBoolean activated;\n+  private final AtomicBoolean responseHandled;\n   private final Span span;\n+  private final Servlet3HttpServerTracer servletHttpServerTracer;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d69e63c5147d526c6b32ed7776d28b90f4fc3126"}, "originalPosition": 18}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac60f9d27cf05a13a5cb4cebc4b0a4adf56f12fc", "author": {"user": {"login": "iNikem", "name": "Nikita Salnikov-Tarnovski"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/ac60f9d27cf05a13a5cb4cebc4b0a4adf56f12fc", "committedDate": "2020-06-03T11:32:06Z", "message": "Polish and fix tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b33f4f25ff44297941196f2ba55de1222c998e1f", "author": {"user": {"login": "iNikem", "name": "Nikita Salnikov-Tarnovski"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/b33f4f25ff44297941196f2ba55de1222c998e1f", "committedDate": "2020-06-03T12:30:51Z", "message": "Muzzle fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f1a937f1741260192cf19c2300854936b0a58785", "author": {"user": {"login": "iNikem", "name": "Nikita Salnikov-Tarnovski"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/f1a937f1741260192cf19c2300854936b0a58785", "committedDate": "2020-06-03T13:50:06Z", "message": "Muzzle fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b8cb1f9f262b908a61edad825424ecda879b91f5", "author": {"user": {"login": "iNikem", "name": "Nikita Salnikov-Tarnovski"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/b8cb1f9f262b908a61edad825424ecda879b91f5", "committedDate": "2020-06-03T15:52:14Z", "message": "Muzzle fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b771c88a806af04e719e52fc34bc6f99d9e2b9c", "author": {"user": {"login": "iNikem", "name": "Nikita Salnikov-Tarnovski"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/0b771c88a806af04e719e52fc34bc6f99d9e2b9c", "committedDate": "2020-06-03T17:06:18Z", "message": "Test fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f72676cd15cfe623406f69fe05d6b64280bd830", "author": {"user": {"login": "iNikem", "name": "Nikita Salnikov-Tarnovski"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/8f72676cd15cfe623406f69fe05d6b64280bd830", "committedDate": "2020-06-03T17:28:31Z", "message": "One more check fixed"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzODMzMjg4", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#pullrequestreview-423833288", "createdAt": "2020-06-03T18:45:58Z", "commit": {"oid": "8f72676cd15cfe623406f69fe05d6b64280bd830"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxODo0NTo1OFrOGeo3hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxODo0NTo1OFrOGeo3hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MDAzOQ==", "bodyText": "something like this is what i was trying to say\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    TRACER.endExceptionally(spanWithScope, throwable, responseStatus);\n          \n          \n            \n                    if (!response.isCommitted()) {\n          \n          \n            \n                      responseStatus = 500;\n          \n          \n            \n                    }\n          \n          \n            \n                    TRACER.endExceptionally(spanWithScope, throwable, responseStatus);", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r434780039", "createdAt": "2020-06-03T18:45:58Z", "author": {"login": "trask"}, "path": "instrumentation/servlet/request-2.3/src/main/java/io/opentelemetry/auto/instrumentation/servlet/v2_3/Servlet2Advice.java", "diffHunk": "@@ -90,40 +55,17 @@ public static void stopSpan(\n       @Advice.Argument(1) final ServletResponse response,\n       @Advice.Enter final SpanWithScope spanWithScope,\n       @Advice.Thrown final Throwable throwable) {\n-    // Set user.principal regardless of who created this span.\n-    final Object spanAttr = request.getAttribute(SPAN_ATTRIBUTE);\n-    if (spanAttr instanceof Span && request instanceof HttpServletRequest) {\n-      final Principal principal = ((HttpServletRequest) request).getUserPrincipal();\n-      if (principal != null) {\n-        ((Span) spanAttr).setAttribute(MoreTags.USER_NAME, principal.getName());\n-      }\n-    }\n+    if (request instanceof HttpServletRequest && response instanceof HttpServletResponse) {\n+      TRACER.setPrincipal((HttpServletRequest) request);\n \n-    if (spanWithScope == null) {\n-      return;\n-    }\n-\n-    final Span span = spanWithScope.getSpan();\n-\n-    if (response instanceof HttpServletResponse) {\n-      DECORATE.onResponse(\n-          span, InstrumentationContext.get(ServletResponse.class, Integer.class).get(response));\n-    } else {\n-      DECORATE.onResponse(span, null);\n-    }\n+      Integer responseStatus =\n+          InstrumentationContext.get(ServletResponse.class, Integer.class).get(response);\n \n-    if (throwable != null) {\n-      if (response instanceof HttpServletResponse\n-          && InstrumentationContext.get(ServletResponse.class, Integer.class).get(response)\n-              == HttpServletResponse.SC_OK) {\n-        // exception was thrown but status code wasn't set\n-        span.setAttribute(Tags.HTTP_STATUS, 500);\n-        span.setStatus(Status.UNKNOWN);\n+      if (throwable == null) {\n+        TRACER.end(spanWithScope, responseStatus);\n+      } else {\n+        TRACER.endExceptionally(spanWithScope, throwable, responseStatus);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f72676cd15cfe623406f69fe05d6b64280bd830"}, "originalPosition": 123}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "04b6f63b6c90d25a0bf432d204b62358cc1bd261", "author": {"user": {"login": "iNikem", "name": "Nikita Salnikov-Tarnovski"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/04b6f63b6c90d25a0bf432d204b62358cc1bd261", "committedDate": "2020-06-05T07:21:58Z", "message": "Stop using SpanWithScope"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "62d95d77bb2d7bc8076c520dd4e0ec1369355d08", "author": {"user": {"login": "iNikem", "name": "Nikita Salnikov-Tarnovski"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/62d95d77bb2d7bc8076c520dd4e0ec1369355d08", "committedDate": "2020-06-05T10:19:05Z", "message": "Test fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae3a610b93af44b435d4e77bcc25f27b6a26ffd7", "author": {"user": {"login": "iNikem", "name": "Nikita Salnikov-Tarnovski"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/ae3a610b93af44b435d4e77bcc25f27b6a26ffd7", "committedDate": "2020-06-05T18:22:35Z", "message": "Merge branch 'master' into deduplicate-servlets"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c9a8066c178138e6b0ff1c3ed5759750db5e3d7", "author": {"user": {"login": "iNikem", "name": "Nikita Salnikov-Tarnovski"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/3c9a8066c178138e6b0ff1c3ed5759750db5e3d7", "committedDate": "2020-06-05T18:37:31Z", "message": "Compilation fix"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NTI2MDMw", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#pullrequestreview-425526030", "createdAt": "2020-06-05T18:18:56Z", "commit": {"oid": "62d95d77bb2d7bc8076c520dd4e0ec1369355d08"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxODoxODo1N1rOGf4zmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxOToxNDo1MFrOGf6ZGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA4OTc1NQ==", "bodyText": "is this comment still applicable after latest changes?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              // TODO should end methods remove SPAN attribute from request as well?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r436089755", "createdAt": "2020-06-05T18:18:57Z", "author": {"login": "trask"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/HttpServerTracer.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n+\n+import static io.opentelemetry.OpenTelemetry.getPropagators;\n+import static io.opentelemetry.trace.Span.Kind.SERVER;\n+import static io.opentelemetry.trace.TracingContextUtils.getSpan;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.auto.config.Config;\n+import io.opentelemetry.auto.instrumentation.api.MoreTags;\n+import io.opentelemetry.auto.instrumentation.api.Tags;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.reflect.Method;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import lombok.extern.slf4j.Slf4j;\n+\n+// TODO In search for a better home package\n+@Slf4j\n+public abstract class HttpServerTracer<REQUEST> {\n+  public static final String SPAN_ATTRIBUTE = \"io.opentelemetry.auto.span\";\n+\n+  protected final Tracer tracer;\n+\n+  public HttpServerTracer() {\n+    tracer = OpenTelemetry.getTracerProvider().get(getInstrumentationName(), getVersion());\n+  }\n+\n+  public Span startSpan(REQUEST request, Method origin, String originType) {\n+    if (getAttachedSpan(request) != null) {\n+      return null;\n+    }\n+\n+    final Span.Builder builder =\n+        tracer\n+            .spanBuilder(spanNameForMethod(origin))\n+            .setSpanKind(SERVER)\n+            .setParent(extract(request, getGetter()))\n+            // TODO Where span.origin.type is defined?\n+            .setAttribute(\"span.origin.type\", originType);\n+\n+    Span span = builder.startSpan();\n+    onConnection(span, request);\n+    onRequest(span, request);\n+\n+    return span;\n+  }\n+\n+  protected abstract String getVersion();\n+\n+  protected abstract String getInstrumentationName();\n+\n+  protected void onConnection(Span span, REQUEST request) {\n+    SemanticAttributes.NET_PEER_IP.set(span, peerHostIP(request));\n+    final Integer port = peerPort(request);\n+    // Negative or Zero ports might represent an unset/null value for an int type.  Skip setting.\n+    if (port != null && port > 0) {\n+      SemanticAttributes.NET_PEER_PORT.set(span, port);\n+    }\n+  }\n+\n+  // TODO use semantic attributes\n+  protected void onRequest(final Span span, final REQUEST request) {\n+    attachSpanToRequest(span, request);\n+    SemanticAttributes.HTTP_METHOD.set(span, method(request));\n+\n+    // Copy of HttpClientDecorator url handling\n+    try {\n+      final URI url = url(request);\n+      if (url != null) {\n+        final StringBuilder urlBuilder = new StringBuilder();\n+        if (url.getScheme() != null) {\n+          urlBuilder.append(url.getScheme());\n+          urlBuilder.append(\"://\");\n+        }\n+        if (url.getHost() != null) {\n+          urlBuilder.append(url.getHost());\n+          if (url.getPort() > 0 && url.getPort() != 80 && url.getPort() != 443) {\n+            urlBuilder.append(\":\");\n+            urlBuilder.append(url.getPort());\n+          }\n+        }\n+        final String path = url.getPath();\n+        if (path.isEmpty()) {\n+          urlBuilder.append(\"/\");\n+        } else {\n+          urlBuilder.append(path);\n+        }\n+        final String query = url.getQuery();\n+        if (query != null) {\n+          urlBuilder.append(\"?\").append(query);\n+        }\n+        final String fragment = url.getFragment();\n+        if (fragment != null) {\n+          urlBuilder.append(\"#\").append(fragment);\n+        }\n+\n+        span.setAttribute(Tags.HTTP_URL, urlBuilder.toString());\n+\n+        if (Config.get().isHttpServerTagQueryString()) {\n+          span.setAttribute(MoreTags.HTTP_QUERY, url.getQuery());\n+          span.setAttribute(MoreTags.HTTP_FRAGMENT, url.getFragment());\n+        }\n+      }\n+    } catch (final Exception e) {\n+      log.debug(\"Error tagging url\", e);\n+    }\n+    // TODO set resource name from URL.\n+  }\n+\n+  public boolean sameTrace(Span oneSpan, Span otherSpan) {\n+    return oneSpan.getContext().getTraceId().equals(otherSpan.getContext().getTraceId());\n+  }\n+\n+  /**\n+   * This method is used to generate an acceptable span (operation) name based on a given method\n+   * reference. Anonymous classes are named based on their parent.\n+   */\n+  protected String spanNameForMethod(final Method method) {\n+    return spanNameForClass(method.getDeclaringClass()) + \".\" + method.getName();\n+  }\n+\n+  /**\n+   * This method is used to generate an acceptable span (operation) name based on a given class\n+   * reference. Anonymous classes are named based on their parent.\n+   */\n+  public String spanNameForClass(final Class clazz) {\n+    if (!clazz.isAnonymousClass()) {\n+      return clazz.getSimpleName();\n+    }\n+    String className = clazz.getName();\n+    if (clazz.getPackage() != null) {\n+      final String pkgName = clazz.getPackage().getName();\n+      if (!pkgName.isEmpty()) {\n+        className = clazz.getName().replace(pkgName, \"\").substring(1);\n+      }\n+    }\n+    return className;\n+  }\n+\n+  protected void onError(final Span span, final Throwable throwable) {\n+    addThrowable(span, unwrapThrowable(throwable));\n+  }\n+\n+  // TODO semantic attributes\n+  public static void addThrowable(final Span span, final Throwable throwable) {\n+    span.setAttribute(MoreTags.ERROR_MSG, throwable.getMessage());\n+    span.setAttribute(MoreTags.ERROR_TYPE, throwable.getClass().getName());\n+\n+    final StringWriter errorString = new StringWriter();\n+    throwable.printStackTrace(new PrintWriter(errorString));\n+    span.setAttribute(MoreTags.ERROR_STACK, errorString.toString());\n+  }\n+\n+  public Span getCurrentSpan() {\n+    return tracer.getCurrentSpan();\n+  }\n+\n+  public Scope newScope(Span span) {\n+    return tracer.withSpan(span);\n+  }\n+\n+  // TODO should end methods remove SPAN attribute from request as well?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62d95d77bb2d7bc8076c520dd4e0ec1369355d08"}, "originalPosition": 187}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA5OTUzOA==", "bodyText": "looks unused now\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public boolean sameTrace(Span oneSpan, Span otherSpan) {\n          \n          \n            \n                return oneSpan.getContext().getTraceId().equals(otherSpan.getContext().getTraceId());\n          \n          \n            \n              }", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r436099538", "createdAt": "2020-06-05T18:39:12Z", "author": {"login": "trask"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/HttpServerTracer.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n+\n+import static io.opentelemetry.OpenTelemetry.getPropagators;\n+import static io.opentelemetry.trace.Span.Kind.SERVER;\n+import static io.opentelemetry.trace.TracingContextUtils.getSpan;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.auto.config.Config;\n+import io.opentelemetry.auto.instrumentation.api.MoreTags;\n+import io.opentelemetry.auto.instrumentation.api.Tags;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.reflect.Method;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import lombok.extern.slf4j.Slf4j;\n+\n+// TODO In search for a better home package\n+@Slf4j\n+public abstract class HttpServerTracer<REQUEST> {\n+  public static final String SPAN_ATTRIBUTE = \"io.opentelemetry.auto.span\";\n+\n+  protected final Tracer tracer;\n+\n+  public HttpServerTracer() {\n+    tracer = OpenTelemetry.getTracerProvider().get(getInstrumentationName(), getVersion());\n+  }\n+\n+  public Span startSpan(REQUEST request, Method origin, String originType) {\n+    if (getAttachedSpan(request) != null) {\n+      return null;\n+    }\n+\n+    final Span.Builder builder =\n+        tracer\n+            .spanBuilder(spanNameForMethod(origin))\n+            .setSpanKind(SERVER)\n+            .setParent(extract(request, getGetter()))\n+            // TODO Where span.origin.type is defined?\n+            .setAttribute(\"span.origin.type\", originType);\n+\n+    Span span = builder.startSpan();\n+    onConnection(span, request);\n+    onRequest(span, request);\n+\n+    return span;\n+  }\n+\n+  protected abstract String getVersion();\n+\n+  protected abstract String getInstrumentationName();\n+\n+  protected void onConnection(Span span, REQUEST request) {\n+    SemanticAttributes.NET_PEER_IP.set(span, peerHostIP(request));\n+    final Integer port = peerPort(request);\n+    // Negative or Zero ports might represent an unset/null value for an int type.  Skip setting.\n+    if (port != null && port > 0) {\n+      SemanticAttributes.NET_PEER_PORT.set(span, port);\n+    }\n+  }\n+\n+  // TODO use semantic attributes\n+  protected void onRequest(final Span span, final REQUEST request) {\n+    attachSpanToRequest(span, request);\n+    SemanticAttributes.HTTP_METHOD.set(span, method(request));\n+\n+    // Copy of HttpClientDecorator url handling\n+    try {\n+      final URI url = url(request);\n+      if (url != null) {\n+        final StringBuilder urlBuilder = new StringBuilder();\n+        if (url.getScheme() != null) {\n+          urlBuilder.append(url.getScheme());\n+          urlBuilder.append(\"://\");\n+        }\n+        if (url.getHost() != null) {\n+          urlBuilder.append(url.getHost());\n+          if (url.getPort() > 0 && url.getPort() != 80 && url.getPort() != 443) {\n+            urlBuilder.append(\":\");\n+            urlBuilder.append(url.getPort());\n+          }\n+        }\n+        final String path = url.getPath();\n+        if (path.isEmpty()) {\n+          urlBuilder.append(\"/\");\n+        } else {\n+          urlBuilder.append(path);\n+        }\n+        final String query = url.getQuery();\n+        if (query != null) {\n+          urlBuilder.append(\"?\").append(query);\n+        }\n+        final String fragment = url.getFragment();\n+        if (fragment != null) {\n+          urlBuilder.append(\"#\").append(fragment);\n+        }\n+\n+        span.setAttribute(Tags.HTTP_URL, urlBuilder.toString());\n+\n+        if (Config.get().isHttpServerTagQueryString()) {\n+          span.setAttribute(MoreTags.HTTP_QUERY, url.getQuery());\n+          span.setAttribute(MoreTags.HTTP_FRAGMENT, url.getFragment());\n+        }\n+      }\n+    } catch (final Exception e) {\n+      log.debug(\"Error tagging url\", e);\n+    }\n+    // TODO set resource name from URL.\n+  }\n+\n+  public boolean sameTrace(Span oneSpan, Span otherSpan) {\n+    return oneSpan.getContext().getTraceId().equals(otherSpan.getContext().getTraceId());\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c9a8066c178138e6b0ff1c3ed5759750db5e3d7"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwMDA3Mg==", "bodyText": "seems good to be consistent with Tracer name?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public Scope newScope(Span span) {\n          \n          \n            \n              public Scope withSpan(Span span) {", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r436100072", "createdAt": "2020-06-05T18:40:15Z", "author": {"login": "trask"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/HttpServerTracer.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n+\n+import static io.opentelemetry.OpenTelemetry.getPropagators;\n+import static io.opentelemetry.trace.Span.Kind.SERVER;\n+import static io.opentelemetry.trace.TracingContextUtils.getSpan;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.auto.config.Config;\n+import io.opentelemetry.auto.instrumentation.api.MoreTags;\n+import io.opentelemetry.auto.instrumentation.api.Tags;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.reflect.Method;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import lombok.extern.slf4j.Slf4j;\n+\n+// TODO In search for a better home package\n+@Slf4j\n+public abstract class HttpServerTracer<REQUEST> {\n+  public static final String SPAN_ATTRIBUTE = \"io.opentelemetry.auto.span\";\n+\n+  protected final Tracer tracer;\n+\n+  public HttpServerTracer() {\n+    tracer = OpenTelemetry.getTracerProvider().get(getInstrumentationName(), getVersion());\n+  }\n+\n+  public Span startSpan(REQUEST request, Method origin, String originType) {\n+    if (getAttachedSpan(request) != null) {\n+      return null;\n+    }\n+\n+    final Span.Builder builder =\n+        tracer\n+            .spanBuilder(spanNameForMethod(origin))\n+            .setSpanKind(SERVER)\n+            .setParent(extract(request, getGetter()))\n+            // TODO Where span.origin.type is defined?\n+            .setAttribute(\"span.origin.type\", originType);\n+\n+    Span span = builder.startSpan();\n+    onConnection(span, request);\n+    onRequest(span, request);\n+\n+    return span;\n+  }\n+\n+  protected abstract String getVersion();\n+\n+  protected abstract String getInstrumentationName();\n+\n+  protected void onConnection(Span span, REQUEST request) {\n+    SemanticAttributes.NET_PEER_IP.set(span, peerHostIP(request));\n+    final Integer port = peerPort(request);\n+    // Negative or Zero ports might represent an unset/null value for an int type.  Skip setting.\n+    if (port != null && port > 0) {\n+      SemanticAttributes.NET_PEER_PORT.set(span, port);\n+    }\n+  }\n+\n+  // TODO use semantic attributes\n+  protected void onRequest(final Span span, final REQUEST request) {\n+    attachSpanToRequest(span, request);\n+    SemanticAttributes.HTTP_METHOD.set(span, method(request));\n+\n+    // Copy of HttpClientDecorator url handling\n+    try {\n+      final URI url = url(request);\n+      if (url != null) {\n+        final StringBuilder urlBuilder = new StringBuilder();\n+        if (url.getScheme() != null) {\n+          urlBuilder.append(url.getScheme());\n+          urlBuilder.append(\"://\");\n+        }\n+        if (url.getHost() != null) {\n+          urlBuilder.append(url.getHost());\n+          if (url.getPort() > 0 && url.getPort() != 80 && url.getPort() != 443) {\n+            urlBuilder.append(\":\");\n+            urlBuilder.append(url.getPort());\n+          }\n+        }\n+        final String path = url.getPath();\n+        if (path.isEmpty()) {\n+          urlBuilder.append(\"/\");\n+        } else {\n+          urlBuilder.append(path);\n+        }\n+        final String query = url.getQuery();\n+        if (query != null) {\n+          urlBuilder.append(\"?\").append(query);\n+        }\n+        final String fragment = url.getFragment();\n+        if (fragment != null) {\n+          urlBuilder.append(\"#\").append(fragment);\n+        }\n+\n+        span.setAttribute(Tags.HTTP_URL, urlBuilder.toString());\n+\n+        if (Config.get().isHttpServerTagQueryString()) {\n+          span.setAttribute(MoreTags.HTTP_QUERY, url.getQuery());\n+          span.setAttribute(MoreTags.HTTP_FRAGMENT, url.getFragment());\n+        }\n+      }\n+    } catch (final Exception e) {\n+      log.debug(\"Error tagging url\", e);\n+    }\n+    // TODO set resource name from URL.\n+  }\n+\n+  public boolean sameTrace(Span oneSpan, Span otherSpan) {\n+    return oneSpan.getContext().getTraceId().equals(otherSpan.getContext().getTraceId());\n+  }\n+\n+  /**\n+   * This method is used to generate an acceptable span (operation) name based on a given method\n+   * reference. Anonymous classes are named based on their parent.\n+   */\n+  protected String spanNameForMethod(final Method method) {\n+    return spanNameForClass(method.getDeclaringClass()) + \".\" + method.getName();\n+  }\n+\n+  /**\n+   * This method is used to generate an acceptable span (operation) name based on a given class\n+   * reference. Anonymous classes are named based on their parent.\n+   */\n+  public String spanNameForClass(final Class clazz) {\n+    if (!clazz.isAnonymousClass()) {\n+      return clazz.getSimpleName();\n+    }\n+    String className = clazz.getName();\n+    if (clazz.getPackage() != null) {\n+      final String pkgName = clazz.getPackage().getName();\n+      if (!pkgName.isEmpty()) {\n+        className = clazz.getName().replace(pkgName, \"\").substring(1);\n+      }\n+    }\n+    return className;\n+  }\n+\n+  protected void onError(final Span span, final Throwable throwable) {\n+    addThrowable(span, unwrapThrowable(throwable));\n+  }\n+\n+  // TODO semantic attributes\n+  public static void addThrowable(final Span span, final Throwable throwable) {\n+    span.setAttribute(MoreTags.ERROR_MSG, throwable.getMessage());\n+    span.setAttribute(MoreTags.ERROR_TYPE, throwable.getClass().getName());\n+\n+    final StringWriter errorString = new StringWriter();\n+    throwable.printStackTrace(new PrintWriter(errorString));\n+    span.setAttribute(MoreTags.ERROR_STACK, errorString.toString());\n+  }\n+\n+  public Span getCurrentSpan() {\n+    return tracer.getCurrentSpan();\n+  }\n+\n+  public Scope newScope(Span span) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c9a8066c178138e6b0ff1c3ed5759750db5e3d7"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExMTkzNw==", "bodyText": "similar comment as above\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void endExceptionally(Span span, Scope scope, Throwable throwable, int responseStatus) {\n          \n          \n            \n                if (scope == null) {\n          \n          \n            \n                  return;\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                if (span != null) {\n          \n          \n            \n                  endExceptionally(span, throwable, responseStatus);\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                scope.close();\n          \n          \n            \n              }", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r436111937", "createdAt": "2020-06-05T19:05:53Z", "author": {"login": "trask"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/HttpServerTracer.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n+\n+import static io.opentelemetry.OpenTelemetry.getPropagators;\n+import static io.opentelemetry.trace.Span.Kind.SERVER;\n+import static io.opentelemetry.trace.TracingContextUtils.getSpan;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.auto.config.Config;\n+import io.opentelemetry.auto.instrumentation.api.MoreTags;\n+import io.opentelemetry.auto.instrumentation.api.Tags;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.reflect.Method;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import lombok.extern.slf4j.Slf4j;\n+\n+// TODO In search for a better home package\n+@Slf4j\n+public abstract class HttpServerTracer<REQUEST> {\n+  public static final String SPAN_ATTRIBUTE = \"io.opentelemetry.auto.span\";\n+\n+  protected final Tracer tracer;\n+\n+  public HttpServerTracer() {\n+    tracer = OpenTelemetry.getTracerProvider().get(getInstrumentationName(), getVersion());\n+  }\n+\n+  public Span startSpan(REQUEST request, Method origin, String originType) {\n+    if (getAttachedSpan(request) != null) {\n+      return null;\n+    }\n+\n+    final Span.Builder builder =\n+        tracer\n+            .spanBuilder(spanNameForMethod(origin))\n+            .setSpanKind(SERVER)\n+            .setParent(extract(request, getGetter()))\n+            // TODO Where span.origin.type is defined?\n+            .setAttribute(\"span.origin.type\", originType);\n+\n+    Span span = builder.startSpan();\n+    onConnection(span, request);\n+    onRequest(span, request);\n+\n+    return span;\n+  }\n+\n+  protected abstract String getVersion();\n+\n+  protected abstract String getInstrumentationName();\n+\n+  protected void onConnection(Span span, REQUEST request) {\n+    SemanticAttributes.NET_PEER_IP.set(span, peerHostIP(request));\n+    final Integer port = peerPort(request);\n+    // Negative or Zero ports might represent an unset/null value for an int type.  Skip setting.\n+    if (port != null && port > 0) {\n+      SemanticAttributes.NET_PEER_PORT.set(span, port);\n+    }\n+  }\n+\n+  // TODO use semantic attributes\n+  protected void onRequest(final Span span, final REQUEST request) {\n+    attachSpanToRequest(span, request);\n+    SemanticAttributes.HTTP_METHOD.set(span, method(request));\n+\n+    // Copy of HttpClientDecorator url handling\n+    try {\n+      final URI url = url(request);\n+      if (url != null) {\n+        final StringBuilder urlBuilder = new StringBuilder();\n+        if (url.getScheme() != null) {\n+          urlBuilder.append(url.getScheme());\n+          urlBuilder.append(\"://\");\n+        }\n+        if (url.getHost() != null) {\n+          urlBuilder.append(url.getHost());\n+          if (url.getPort() > 0 && url.getPort() != 80 && url.getPort() != 443) {\n+            urlBuilder.append(\":\");\n+            urlBuilder.append(url.getPort());\n+          }\n+        }\n+        final String path = url.getPath();\n+        if (path.isEmpty()) {\n+          urlBuilder.append(\"/\");\n+        } else {\n+          urlBuilder.append(path);\n+        }\n+        final String query = url.getQuery();\n+        if (query != null) {\n+          urlBuilder.append(\"?\").append(query);\n+        }\n+        final String fragment = url.getFragment();\n+        if (fragment != null) {\n+          urlBuilder.append(\"#\").append(fragment);\n+        }\n+\n+        span.setAttribute(Tags.HTTP_URL, urlBuilder.toString());\n+\n+        if (Config.get().isHttpServerTagQueryString()) {\n+          span.setAttribute(MoreTags.HTTP_QUERY, url.getQuery());\n+          span.setAttribute(MoreTags.HTTP_FRAGMENT, url.getFragment());\n+        }\n+      }\n+    } catch (final Exception e) {\n+      log.debug(\"Error tagging url\", e);\n+    }\n+    // TODO set resource name from URL.\n+  }\n+\n+  public boolean sameTrace(Span oneSpan, Span otherSpan) {\n+    return oneSpan.getContext().getTraceId().equals(otherSpan.getContext().getTraceId());\n+  }\n+\n+  /**\n+   * This method is used to generate an acceptable span (operation) name based on a given method\n+   * reference. Anonymous classes are named based on their parent.\n+   */\n+  protected String spanNameForMethod(final Method method) {\n+    return spanNameForClass(method.getDeclaringClass()) + \".\" + method.getName();\n+  }\n+\n+  /**\n+   * This method is used to generate an acceptable span (operation) name based on a given class\n+   * reference. Anonymous classes are named based on their parent.\n+   */\n+  public String spanNameForClass(final Class clazz) {\n+    if (!clazz.isAnonymousClass()) {\n+      return clazz.getSimpleName();\n+    }\n+    String className = clazz.getName();\n+    if (clazz.getPackage() != null) {\n+      final String pkgName = clazz.getPackage().getName();\n+      if (!pkgName.isEmpty()) {\n+        className = clazz.getName().replace(pkgName, \"\").substring(1);\n+      }\n+    }\n+    return className;\n+  }\n+\n+  protected void onError(final Span span, final Throwable throwable) {\n+    addThrowable(span, unwrapThrowable(throwable));\n+  }\n+\n+  // TODO semantic attributes\n+  public static void addThrowable(final Span span, final Throwable throwable) {\n+    span.setAttribute(MoreTags.ERROR_MSG, throwable.getMessage());\n+    span.setAttribute(MoreTags.ERROR_TYPE, throwable.getClass().getName());\n+\n+    final StringWriter errorString = new StringWriter();\n+    throwable.printStackTrace(new PrintWriter(errorString));\n+    span.setAttribute(MoreTags.ERROR_STACK, errorString.toString());\n+  }\n+\n+  public Span getCurrentSpan() {\n+    return tracer.getCurrentSpan();\n+  }\n+\n+  public Scope newScope(Span span) {\n+    return tracer.withSpan(span);\n+  }\n+\n+  // TODO should end methods remove SPAN attribute from request as well?\n+  public void end(Span span, Scope scope, int responseCode) {\n+    if (scope == null) {\n+      return;\n+    }\n+\n+    if (span != null) {\n+      end(span, responseCode);\n+    }\n+\n+    scope.close();\n+  }\n+\n+  public void end(Span span, int responseStatus) {\n+    setStatus(span, responseStatus);\n+    span.end();\n+  }\n+\n+  public void endExceptionally(Span span, Scope scope, Throwable throwable, int responseStatus) {\n+    if (scope == null) {\n+      return;\n+    }\n+\n+    if (span != null) {\n+      endExceptionally(span, throwable, responseStatus);\n+    }\n+\n+    scope.close();\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c9a8066c178138e6b0ff1c3ed5759750db5e3d7"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExMjE4MQ==", "bodyText": "it doesn't looks like this is ever called with null span or null scope\nalso, i think i like calling end(span, responseStatus) directly, and keeping scope.close() an explicit separate action\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void end(Span span, Scope scope, int responseCode) {\n          \n          \n            \n                if (scope == null) {\n          \n          \n            \n                  return;\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                if (span != null) {\n          \n          \n            \n                  end(span, responseCode);\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                scope.close();\n          \n          \n            \n              }", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r436112181", "createdAt": "2020-06-05T19:06:27Z", "author": {"login": "trask"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/HttpServerTracer.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n+\n+import static io.opentelemetry.OpenTelemetry.getPropagators;\n+import static io.opentelemetry.trace.Span.Kind.SERVER;\n+import static io.opentelemetry.trace.TracingContextUtils.getSpan;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.auto.config.Config;\n+import io.opentelemetry.auto.instrumentation.api.MoreTags;\n+import io.opentelemetry.auto.instrumentation.api.Tags;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.reflect.Method;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import lombok.extern.slf4j.Slf4j;\n+\n+// TODO In search for a better home package\n+@Slf4j\n+public abstract class HttpServerTracer<REQUEST> {\n+  public static final String SPAN_ATTRIBUTE = \"io.opentelemetry.auto.span\";\n+\n+  protected final Tracer tracer;\n+\n+  public HttpServerTracer() {\n+    tracer = OpenTelemetry.getTracerProvider().get(getInstrumentationName(), getVersion());\n+  }\n+\n+  public Span startSpan(REQUEST request, Method origin, String originType) {\n+    if (getAttachedSpan(request) != null) {\n+      return null;\n+    }\n+\n+    final Span.Builder builder =\n+        tracer\n+            .spanBuilder(spanNameForMethod(origin))\n+            .setSpanKind(SERVER)\n+            .setParent(extract(request, getGetter()))\n+            // TODO Where span.origin.type is defined?\n+            .setAttribute(\"span.origin.type\", originType);\n+\n+    Span span = builder.startSpan();\n+    onConnection(span, request);\n+    onRequest(span, request);\n+\n+    return span;\n+  }\n+\n+  protected abstract String getVersion();\n+\n+  protected abstract String getInstrumentationName();\n+\n+  protected void onConnection(Span span, REQUEST request) {\n+    SemanticAttributes.NET_PEER_IP.set(span, peerHostIP(request));\n+    final Integer port = peerPort(request);\n+    // Negative or Zero ports might represent an unset/null value for an int type.  Skip setting.\n+    if (port != null && port > 0) {\n+      SemanticAttributes.NET_PEER_PORT.set(span, port);\n+    }\n+  }\n+\n+  // TODO use semantic attributes\n+  protected void onRequest(final Span span, final REQUEST request) {\n+    attachSpanToRequest(span, request);\n+    SemanticAttributes.HTTP_METHOD.set(span, method(request));\n+\n+    // Copy of HttpClientDecorator url handling\n+    try {\n+      final URI url = url(request);\n+      if (url != null) {\n+        final StringBuilder urlBuilder = new StringBuilder();\n+        if (url.getScheme() != null) {\n+          urlBuilder.append(url.getScheme());\n+          urlBuilder.append(\"://\");\n+        }\n+        if (url.getHost() != null) {\n+          urlBuilder.append(url.getHost());\n+          if (url.getPort() > 0 && url.getPort() != 80 && url.getPort() != 443) {\n+            urlBuilder.append(\":\");\n+            urlBuilder.append(url.getPort());\n+          }\n+        }\n+        final String path = url.getPath();\n+        if (path.isEmpty()) {\n+          urlBuilder.append(\"/\");\n+        } else {\n+          urlBuilder.append(path);\n+        }\n+        final String query = url.getQuery();\n+        if (query != null) {\n+          urlBuilder.append(\"?\").append(query);\n+        }\n+        final String fragment = url.getFragment();\n+        if (fragment != null) {\n+          urlBuilder.append(\"#\").append(fragment);\n+        }\n+\n+        span.setAttribute(Tags.HTTP_URL, urlBuilder.toString());\n+\n+        if (Config.get().isHttpServerTagQueryString()) {\n+          span.setAttribute(MoreTags.HTTP_QUERY, url.getQuery());\n+          span.setAttribute(MoreTags.HTTP_FRAGMENT, url.getFragment());\n+        }\n+      }\n+    } catch (final Exception e) {\n+      log.debug(\"Error tagging url\", e);\n+    }\n+    // TODO set resource name from URL.\n+  }\n+\n+  public boolean sameTrace(Span oneSpan, Span otherSpan) {\n+    return oneSpan.getContext().getTraceId().equals(otherSpan.getContext().getTraceId());\n+  }\n+\n+  /**\n+   * This method is used to generate an acceptable span (operation) name based on a given method\n+   * reference. Anonymous classes are named based on their parent.\n+   */\n+  protected String spanNameForMethod(final Method method) {\n+    return spanNameForClass(method.getDeclaringClass()) + \".\" + method.getName();\n+  }\n+\n+  /**\n+   * This method is used to generate an acceptable span (operation) name based on a given class\n+   * reference. Anonymous classes are named based on their parent.\n+   */\n+  public String spanNameForClass(final Class clazz) {\n+    if (!clazz.isAnonymousClass()) {\n+      return clazz.getSimpleName();\n+    }\n+    String className = clazz.getName();\n+    if (clazz.getPackage() != null) {\n+      final String pkgName = clazz.getPackage().getName();\n+      if (!pkgName.isEmpty()) {\n+        className = clazz.getName().replace(pkgName, \"\").substring(1);\n+      }\n+    }\n+    return className;\n+  }\n+\n+  protected void onError(final Span span, final Throwable throwable) {\n+    addThrowable(span, unwrapThrowable(throwable));\n+  }\n+\n+  // TODO semantic attributes\n+  public static void addThrowable(final Span span, final Throwable throwable) {\n+    span.setAttribute(MoreTags.ERROR_MSG, throwable.getMessage());\n+    span.setAttribute(MoreTags.ERROR_TYPE, throwable.getClass().getName());\n+\n+    final StringWriter errorString = new StringWriter();\n+    throwable.printStackTrace(new PrintWriter(errorString));\n+    span.setAttribute(MoreTags.ERROR_STACK, errorString.toString());\n+  }\n+\n+  public Span getCurrentSpan() {\n+    return tracer.getCurrentSpan();\n+  }\n+\n+  public Scope newScope(Span span) {\n+    return tracer.withSpan(span);\n+  }\n+\n+  // TODO should end methods remove SPAN attribute from request as well?\n+  public void end(Span span, Scope scope, int responseCode) {\n+    if (scope == null) {\n+      return;\n+    }\n+\n+    if (span != null) {\n+      end(span, responseCode);\n+    }\n+\n+    scope.close();\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c9a8066c178138e6b0ff1c3ed5759750db5e3d7"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExNTU4Mw==", "bodyText": "i think we only need this for servlet-ish instrumentations, so maybe provide default so it's more clear subclasses don't need to implement this\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              protected abstract void attachSpanToRequest(Span span, REQUEST request);\n          \n          \n            \n              protected void attachSpanToRequest(Span span, REQUEST request) {\n          \n          \n            \n              }", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r436115583", "createdAt": "2020-06-05T19:14:30Z", "author": {"login": "trask"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/HttpServerTracer.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n+\n+import static io.opentelemetry.OpenTelemetry.getPropagators;\n+import static io.opentelemetry.trace.Span.Kind.SERVER;\n+import static io.opentelemetry.trace.TracingContextUtils.getSpan;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.auto.config.Config;\n+import io.opentelemetry.auto.instrumentation.api.MoreTags;\n+import io.opentelemetry.auto.instrumentation.api.Tags;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.reflect.Method;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import lombok.extern.slf4j.Slf4j;\n+\n+// TODO In search for a better home package\n+@Slf4j\n+public abstract class HttpServerTracer<REQUEST> {\n+  public static final String SPAN_ATTRIBUTE = \"io.opentelemetry.auto.span\";\n+\n+  protected final Tracer tracer;\n+\n+  public HttpServerTracer() {\n+    tracer = OpenTelemetry.getTracerProvider().get(getInstrumentationName(), getVersion());\n+  }\n+\n+  public Span startSpan(REQUEST request, Method origin, String originType) {\n+    if (getAttachedSpan(request) != null) {\n+      return null;\n+    }\n+\n+    final Span.Builder builder =\n+        tracer\n+            .spanBuilder(spanNameForMethod(origin))\n+            .setSpanKind(SERVER)\n+            .setParent(extract(request, getGetter()))\n+            // TODO Where span.origin.type is defined?\n+            .setAttribute(\"span.origin.type\", originType);\n+\n+    Span span = builder.startSpan();\n+    onConnection(span, request);\n+    onRequest(span, request);\n+\n+    return span;\n+  }\n+\n+  protected abstract String getVersion();\n+\n+  protected abstract String getInstrumentationName();\n+\n+  protected void onConnection(Span span, REQUEST request) {\n+    SemanticAttributes.NET_PEER_IP.set(span, peerHostIP(request));\n+    final Integer port = peerPort(request);\n+    // Negative or Zero ports might represent an unset/null value for an int type.  Skip setting.\n+    if (port != null && port > 0) {\n+      SemanticAttributes.NET_PEER_PORT.set(span, port);\n+    }\n+  }\n+\n+  // TODO use semantic attributes\n+  protected void onRequest(final Span span, final REQUEST request) {\n+    attachSpanToRequest(span, request);\n+    SemanticAttributes.HTTP_METHOD.set(span, method(request));\n+\n+    // Copy of HttpClientDecorator url handling\n+    try {\n+      final URI url = url(request);\n+      if (url != null) {\n+        final StringBuilder urlBuilder = new StringBuilder();\n+        if (url.getScheme() != null) {\n+          urlBuilder.append(url.getScheme());\n+          urlBuilder.append(\"://\");\n+        }\n+        if (url.getHost() != null) {\n+          urlBuilder.append(url.getHost());\n+          if (url.getPort() > 0 && url.getPort() != 80 && url.getPort() != 443) {\n+            urlBuilder.append(\":\");\n+            urlBuilder.append(url.getPort());\n+          }\n+        }\n+        final String path = url.getPath();\n+        if (path.isEmpty()) {\n+          urlBuilder.append(\"/\");\n+        } else {\n+          urlBuilder.append(path);\n+        }\n+        final String query = url.getQuery();\n+        if (query != null) {\n+          urlBuilder.append(\"?\").append(query);\n+        }\n+        final String fragment = url.getFragment();\n+        if (fragment != null) {\n+          urlBuilder.append(\"#\").append(fragment);\n+        }\n+\n+        span.setAttribute(Tags.HTTP_URL, urlBuilder.toString());\n+\n+        if (Config.get().isHttpServerTagQueryString()) {\n+          span.setAttribute(MoreTags.HTTP_QUERY, url.getQuery());\n+          span.setAttribute(MoreTags.HTTP_FRAGMENT, url.getFragment());\n+        }\n+      }\n+    } catch (final Exception e) {\n+      log.debug(\"Error tagging url\", e);\n+    }\n+    // TODO set resource name from URL.\n+  }\n+\n+  public boolean sameTrace(Span oneSpan, Span otherSpan) {\n+    return oneSpan.getContext().getTraceId().equals(otherSpan.getContext().getTraceId());\n+  }\n+\n+  /**\n+   * This method is used to generate an acceptable span (operation) name based on a given method\n+   * reference. Anonymous classes are named based on their parent.\n+   */\n+  protected String spanNameForMethod(final Method method) {\n+    return spanNameForClass(method.getDeclaringClass()) + \".\" + method.getName();\n+  }\n+\n+  /**\n+   * This method is used to generate an acceptable span (operation) name based on a given class\n+   * reference. Anonymous classes are named based on their parent.\n+   */\n+  public String spanNameForClass(final Class clazz) {\n+    if (!clazz.isAnonymousClass()) {\n+      return clazz.getSimpleName();\n+    }\n+    String className = clazz.getName();\n+    if (clazz.getPackage() != null) {\n+      final String pkgName = clazz.getPackage().getName();\n+      if (!pkgName.isEmpty()) {\n+        className = clazz.getName().replace(pkgName, \"\").substring(1);\n+      }\n+    }\n+    return className;\n+  }\n+\n+  protected void onError(final Span span, final Throwable throwable) {\n+    addThrowable(span, unwrapThrowable(throwable));\n+  }\n+\n+  // TODO semantic attributes\n+  public static void addThrowable(final Span span, final Throwable throwable) {\n+    span.setAttribute(MoreTags.ERROR_MSG, throwable.getMessage());\n+    span.setAttribute(MoreTags.ERROR_TYPE, throwable.getClass().getName());\n+\n+    final StringWriter errorString = new StringWriter();\n+    throwable.printStackTrace(new PrintWriter(errorString));\n+    span.setAttribute(MoreTags.ERROR_STACK, errorString.toString());\n+  }\n+\n+  public Span getCurrentSpan() {\n+    return tracer.getCurrentSpan();\n+  }\n+\n+  public Scope newScope(Span span) {\n+    return tracer.withSpan(span);\n+  }\n+\n+  // TODO should end methods remove SPAN attribute from request as well?\n+  public void end(Span span, Scope scope, int responseCode) {\n+    if (scope == null) {\n+      return;\n+    }\n+\n+    if (span != null) {\n+      end(span, responseCode);\n+    }\n+\n+    scope.close();\n+  }\n+\n+  public void end(Span span, int responseStatus) {\n+    setStatus(span, responseStatus);\n+    span.end();\n+  }\n+\n+  public void endExceptionally(Span span, Scope scope, Throwable throwable, int responseStatus) {\n+    if (scope == null) {\n+      return;\n+    }\n+\n+    if (span != null) {\n+      endExceptionally(span, throwable, responseStatus);\n+    }\n+\n+    scope.close();\n+  }\n+\n+  public void endExceptionally(Span span, Throwable throwable, int responseStatus) {\n+    if (responseStatus == 200) {\n+      // TODO I think this is wrong.\n+      // We must report that response status that was actually sent to end user\n+      // We may change span status, but not http_status attribute\n+      responseStatus = 500;\n+    }\n+    setStatus(span, responseStatus);\n+    onError(span, unwrapThrowable(throwable));\n+    span.end();\n+  }\n+\n+  protected Throwable unwrapThrowable(Throwable throwable) {\n+    return throwable instanceof ExecutionException ? throwable.getCause() : throwable;\n+  }\n+\n+  private <C> SpanContext extract(final C carrier, final HttpTextFormat.Getter<C> getter) {\n+    final Context context =\n+        getPropagators().getHttpTextFormat().extract(Context.current(), carrier, getter);\n+    final Span span = getSpan(context);\n+    return span.getContext();\n+  }\n+\n+  private void setStatus(Span span, int status) {\n+    SemanticAttributes.HTTP_STATUS_CODE.set(span, status);\n+    // TODO status_message\n+    if (Config.get().getHttpServerErrorStatuses().get(status)) {\n+      span.setStatus(Status.UNKNOWN);\n+    }\n+  }\n+\n+  protected abstract Integer peerPort(REQUEST request);\n+\n+  protected abstract String peerHostIP(REQUEST request);\n+\n+  protected abstract HttpTextFormat.Getter<REQUEST> getGetter();\n+\n+  protected abstract URI url(REQUEST request) throws URISyntaxException;\n+\n+  protected abstract String method(REQUEST request);\n+\n+  protected abstract void attachSpanToRequest(Span span, REQUEST request);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c9a8066c178138e6b0ff1c3ed5759750db5e3d7"}, "originalPosition": 258}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExNTczNw==", "bodyText": "same comment as above\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              protected abstract Span getAttachedSpan(REQUEST request);\n          \n          \n            \n              protected Span getAttachedSpan(REQUEST request) {\n          \n          \n            \n                return null;\n          \n          \n            \n              }", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r436115737", "createdAt": "2020-06-05T19:14:50Z", "author": {"login": "trask"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/HttpServerTracer.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n+\n+import static io.opentelemetry.OpenTelemetry.getPropagators;\n+import static io.opentelemetry.trace.Span.Kind.SERVER;\n+import static io.opentelemetry.trace.TracingContextUtils.getSpan;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.auto.config.Config;\n+import io.opentelemetry.auto.instrumentation.api.MoreTags;\n+import io.opentelemetry.auto.instrumentation.api.Tags;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.reflect.Method;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import lombok.extern.slf4j.Slf4j;\n+\n+// TODO In search for a better home package\n+@Slf4j\n+public abstract class HttpServerTracer<REQUEST> {\n+  public static final String SPAN_ATTRIBUTE = \"io.opentelemetry.auto.span\";\n+\n+  protected final Tracer tracer;\n+\n+  public HttpServerTracer() {\n+    tracer = OpenTelemetry.getTracerProvider().get(getInstrumentationName(), getVersion());\n+  }\n+\n+  public Span startSpan(REQUEST request, Method origin, String originType) {\n+    if (getAttachedSpan(request) != null) {\n+      return null;\n+    }\n+\n+    final Span.Builder builder =\n+        tracer\n+            .spanBuilder(spanNameForMethod(origin))\n+            .setSpanKind(SERVER)\n+            .setParent(extract(request, getGetter()))\n+            // TODO Where span.origin.type is defined?\n+            .setAttribute(\"span.origin.type\", originType);\n+\n+    Span span = builder.startSpan();\n+    onConnection(span, request);\n+    onRequest(span, request);\n+\n+    return span;\n+  }\n+\n+  protected abstract String getVersion();\n+\n+  protected abstract String getInstrumentationName();\n+\n+  protected void onConnection(Span span, REQUEST request) {\n+    SemanticAttributes.NET_PEER_IP.set(span, peerHostIP(request));\n+    final Integer port = peerPort(request);\n+    // Negative or Zero ports might represent an unset/null value for an int type.  Skip setting.\n+    if (port != null && port > 0) {\n+      SemanticAttributes.NET_PEER_PORT.set(span, port);\n+    }\n+  }\n+\n+  // TODO use semantic attributes\n+  protected void onRequest(final Span span, final REQUEST request) {\n+    attachSpanToRequest(span, request);\n+    SemanticAttributes.HTTP_METHOD.set(span, method(request));\n+\n+    // Copy of HttpClientDecorator url handling\n+    try {\n+      final URI url = url(request);\n+      if (url != null) {\n+        final StringBuilder urlBuilder = new StringBuilder();\n+        if (url.getScheme() != null) {\n+          urlBuilder.append(url.getScheme());\n+          urlBuilder.append(\"://\");\n+        }\n+        if (url.getHost() != null) {\n+          urlBuilder.append(url.getHost());\n+          if (url.getPort() > 0 && url.getPort() != 80 && url.getPort() != 443) {\n+            urlBuilder.append(\":\");\n+            urlBuilder.append(url.getPort());\n+          }\n+        }\n+        final String path = url.getPath();\n+        if (path.isEmpty()) {\n+          urlBuilder.append(\"/\");\n+        } else {\n+          urlBuilder.append(path);\n+        }\n+        final String query = url.getQuery();\n+        if (query != null) {\n+          urlBuilder.append(\"?\").append(query);\n+        }\n+        final String fragment = url.getFragment();\n+        if (fragment != null) {\n+          urlBuilder.append(\"#\").append(fragment);\n+        }\n+\n+        span.setAttribute(Tags.HTTP_URL, urlBuilder.toString());\n+\n+        if (Config.get().isHttpServerTagQueryString()) {\n+          span.setAttribute(MoreTags.HTTP_QUERY, url.getQuery());\n+          span.setAttribute(MoreTags.HTTP_FRAGMENT, url.getFragment());\n+        }\n+      }\n+    } catch (final Exception e) {\n+      log.debug(\"Error tagging url\", e);\n+    }\n+    // TODO set resource name from URL.\n+  }\n+\n+  public boolean sameTrace(Span oneSpan, Span otherSpan) {\n+    return oneSpan.getContext().getTraceId().equals(otherSpan.getContext().getTraceId());\n+  }\n+\n+  /**\n+   * This method is used to generate an acceptable span (operation) name based on a given method\n+   * reference. Anonymous classes are named based on their parent.\n+   */\n+  protected String spanNameForMethod(final Method method) {\n+    return spanNameForClass(method.getDeclaringClass()) + \".\" + method.getName();\n+  }\n+\n+  /**\n+   * This method is used to generate an acceptable span (operation) name based on a given class\n+   * reference. Anonymous classes are named based on their parent.\n+   */\n+  public String spanNameForClass(final Class clazz) {\n+    if (!clazz.isAnonymousClass()) {\n+      return clazz.getSimpleName();\n+    }\n+    String className = clazz.getName();\n+    if (clazz.getPackage() != null) {\n+      final String pkgName = clazz.getPackage().getName();\n+      if (!pkgName.isEmpty()) {\n+        className = clazz.getName().replace(pkgName, \"\").substring(1);\n+      }\n+    }\n+    return className;\n+  }\n+\n+  protected void onError(final Span span, final Throwable throwable) {\n+    addThrowable(span, unwrapThrowable(throwable));\n+  }\n+\n+  // TODO semantic attributes\n+  public static void addThrowable(final Span span, final Throwable throwable) {\n+    span.setAttribute(MoreTags.ERROR_MSG, throwable.getMessage());\n+    span.setAttribute(MoreTags.ERROR_TYPE, throwable.getClass().getName());\n+\n+    final StringWriter errorString = new StringWriter();\n+    throwable.printStackTrace(new PrintWriter(errorString));\n+    span.setAttribute(MoreTags.ERROR_STACK, errorString.toString());\n+  }\n+\n+  public Span getCurrentSpan() {\n+    return tracer.getCurrentSpan();\n+  }\n+\n+  public Scope newScope(Span span) {\n+    return tracer.withSpan(span);\n+  }\n+\n+  // TODO should end methods remove SPAN attribute from request as well?\n+  public void end(Span span, Scope scope, int responseCode) {\n+    if (scope == null) {\n+      return;\n+    }\n+\n+    if (span != null) {\n+      end(span, responseCode);\n+    }\n+\n+    scope.close();\n+  }\n+\n+  public void end(Span span, int responseStatus) {\n+    setStatus(span, responseStatus);\n+    span.end();\n+  }\n+\n+  public void endExceptionally(Span span, Scope scope, Throwable throwable, int responseStatus) {\n+    if (scope == null) {\n+      return;\n+    }\n+\n+    if (span != null) {\n+      endExceptionally(span, throwable, responseStatus);\n+    }\n+\n+    scope.close();\n+  }\n+\n+  public void endExceptionally(Span span, Throwable throwable, int responseStatus) {\n+    if (responseStatus == 200) {\n+      // TODO I think this is wrong.\n+      // We must report that response status that was actually sent to end user\n+      // We may change span status, but not http_status attribute\n+      responseStatus = 500;\n+    }\n+    setStatus(span, responseStatus);\n+    onError(span, unwrapThrowable(throwable));\n+    span.end();\n+  }\n+\n+  protected Throwable unwrapThrowable(Throwable throwable) {\n+    return throwable instanceof ExecutionException ? throwable.getCause() : throwable;\n+  }\n+\n+  private <C> SpanContext extract(final C carrier, final HttpTextFormat.Getter<C> getter) {\n+    final Context context =\n+        getPropagators().getHttpTextFormat().extract(Context.current(), carrier, getter);\n+    final Span span = getSpan(context);\n+    return span.getContext();\n+  }\n+\n+  private void setStatus(Span span, int status) {\n+    SemanticAttributes.HTTP_STATUS_CODE.set(span, status);\n+    // TODO status_message\n+    if (Config.get().getHttpServerErrorStatuses().get(status)) {\n+      span.setStatus(Status.UNKNOWN);\n+    }\n+  }\n+\n+  protected abstract Integer peerPort(REQUEST request);\n+\n+  protected abstract String peerHostIP(REQUEST request);\n+\n+  protected abstract HttpTextFormat.Getter<REQUEST> getGetter();\n+\n+  protected abstract URI url(REQUEST request) throws URISyntaxException;\n+\n+  protected abstract String method(REQUEST request);\n+\n+  protected abstract void attachSpanToRequest(Span span, REQUEST request);\n+\n+  protected abstract Span getAttachedSpan(REQUEST request);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c9a8066c178138e6b0ff1c3ed5759750db5e3d7"}, "originalPosition": 260}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5de279642b809346eec8923f22fa2988f74adfc", "author": {"user": {"login": "iNikem", "name": "Nikita Salnikov-Tarnovski"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/f5de279642b809346eec8923f22fa2988f74adfc", "committedDate": "2020-06-05T19:38:37Z", "message": "Apply suggestions from code review\n\nCo-authored-by: Trask Stalnaker <trask.stalnaker@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b81bf1a1371148fd51a602116f27cb345ba96b25", "author": {"user": {"login": "iNikem", "name": "Nikita Salnikov-Tarnovski"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/b81bf1a1371148fd51a602116f27cb345ba96b25", "committedDate": "2020-06-05T19:38:50Z", "message": "Update agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/HttpServerTracer.java\n\nCo-authored-by: Trask Stalnaker <trask.stalnaker@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7bf6d0bcd86265a6df85400d83d8f7b902561c41", "author": {"user": {"login": "iNikem", "name": "Nikita Salnikov-Tarnovski"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/7bf6d0bcd86265a6df85400d83d8f7b902561c41", "committedDate": "2020-06-05T19:48:09Z", "message": "Polish"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "611d980f60e3ffc254321ce488ea951788435810", "author": {"user": {"login": "iNikem", "name": "Nikita Salnikov-Tarnovski"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/611d980f60e3ffc254321ce488ea951788435810", "committedDate": "2020-06-05T19:46:41Z", "message": "Polish"}, "afterCommit": {"oid": "7bf6d0bcd86265a6df85400d83d8f7b902561c41", "author": {"user": {"login": "iNikem", "name": "Nikita Salnikov-Tarnovski"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/7bf6d0bcd86265a6df85400d83d8f7b902561c41", "committedDate": "2020-06-05T19:48:09Z", "message": "Polish"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "075177c82d0518d53db237a54669e5a2b64990b0", "author": {"user": {"login": "iNikem", "name": "Nikita Salnikov-Tarnovski"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/075177c82d0518d53db237a54669e5a2b64990b0", "committedDate": "2020-06-06T10:19:13Z", "message": "Tracer does not manage scope anymore"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1ODU0ODgw", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#pullrequestreview-425854880", "createdAt": "2020-06-07T21:29:35Z", "commit": {"oid": "075177c82d0518d53db237a54669e5a2b64990b0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d4ff029a91a7e8f0ba9bf4d24d2ffeefb141eff", "author": {"user": {"login": "iNikem", "name": "Nikita Salnikov-Tarnovski"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/0d4ff029a91a7e8f0ba9bf4d24d2ffeefb141eff", "committedDate": "2020-06-08T06:54:48Z", "message": "Merge branch 'master' into deduplicate-servlets"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3201, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}