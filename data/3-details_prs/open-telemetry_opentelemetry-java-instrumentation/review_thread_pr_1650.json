{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIxODQwOTI5", "number": 1650, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwOTowNjoyNVrOE56tJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNjowNTowOFrOE7mnUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MTY2MTE3OnYy", "diffSide": "RIGHT", "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/ApiGatewayProxyRequest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwOTowNjoyNVrOH0q6vQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwOTo0OTowOVrOH0sreQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk5MTE2NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return (values != null && !values.isEmpty() ? values.get(0) : null);\n          \n          \n            \n                    return (values != null && !values.isEmpty()) ? values.get(0) : null;\n          \n      \n    \n    \n  \n\nI think", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1650#discussion_r524991165", "createdAt": "2020-11-17T09:06:25Z", "author": {"login": "anuraaga"}, "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/ApiGatewayProxyRequest.java", "diffHunk": "@@ -42,9 +45,16 @@ static ApiGatewayProxyRequest forStream(final InputStream source) throws IOExcep\n     return new CopiedApiGatewayProxyRequest(source);\n   }\n \n+  private static final Function<Map.Entry<String, List<String>>, String> EXTRACTOR =\n+      (entry -> {\n+        List<String> values = entry.getValue();\n+        return (values != null && !values.isEmpty() ? values.get(0) : null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9625ad33396952c0509544f07d3fc3e01919e6d"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAyMDAyNQ==", "bodyText": "+1 :)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1650#discussion_r525020025", "createdAt": "2020-11-17T09:49:09Z", "author": {"login": "kubawach"}, "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/ApiGatewayProxyRequest.java", "diffHunk": "@@ -42,9 +45,16 @@ static ApiGatewayProxyRequest forStream(final InputStream source) throws IOExcep\n     return new CopiedApiGatewayProxyRequest(source);\n   }\n \n+  private static final Function<Map.Entry<String, List<String>>, String> EXTRACTOR =\n+      (entry -> {\n+        List<String> values = entry.getValue();\n+        return (values != null && !values.isEmpty() ? values.get(0) : null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk5MTE2NQ=="}, "originalCommit": {"oid": "e9625ad33396952c0509544f07d3fc3e01919e6d"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MTY2NDAwOnYy", "diffSide": "RIGHT", "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/ApiGatewayProxyRequest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwOTowNzoxMVrOH0q8mA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwOTo0OToyNVrOH0ssQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk5MTY0MA==", "bodyText": "Consider defining a method and using a method reference", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1650#discussion_r524991640", "createdAt": "2020-11-17T09:07:11Z", "author": {"login": "anuraaga"}, "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/ApiGatewayProxyRequest.java", "diffHunk": "@@ -42,9 +45,16 @@ static ApiGatewayProxyRequest forStream(final InputStream source) throws IOExcep\n     return new CopiedApiGatewayProxyRequest(source);\n   }\n \n+  private static final Function<Map.Entry<String, List<String>>, String> EXTRACTOR =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9625ad33396952c0509544f07d3fc3e01919e6d"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAyMDIyNA==", "bodyText": "Good idea!", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1650#discussion_r525020224", "createdAt": "2020-11-17T09:49:25Z", "author": {"login": "kubawach"}, "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/ApiGatewayProxyRequest.java", "diffHunk": "@@ -42,9 +45,16 @@ static ApiGatewayProxyRequest forStream(final InputStream source) throws IOExcep\n     return new CopiedApiGatewayProxyRequest(source);\n   }\n \n+  private static final Function<Map.Entry<String, List<String>>, String> EXTRACTOR =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk5MTY0MA=="}, "originalCommit": {"oid": "e9625ad33396952c0509544f07d3fc3e01919e6d"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MTY2NzU1OnYy", "diffSide": "RIGHT", "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/ParentContextExtractor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwOTowODowNVrOH0q-0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwOTo1MDoxN1rOH0su2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk5MjIwOA==", "bodyText": "e -> e.getKey() == null ? null\n:O:O:O\nWow", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1650#discussion_r524992208", "createdAt": "2020-11-17T09:08:05Z", "author": {"login": "anuraaga"}, "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/ParentContextExtractor.java", "diffHunk": "@@ -5,35 +5,28 @@\n \n package io.opentelemetry.instrumentation.awslambda.v1_0;\n \n-import com.amazonaws.serverless.proxy.model.Headers;\n import io.opentelemetry.api.OpenTelemetry;\n import io.opentelemetry.context.Context;\n import io.opentelemetry.context.propagation.TextMapPropagator;\n import java.util.Collections;\n import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n \n public class ParentContextExtractor {\n \n-  static Context fromHttpHeaders(Headers headers) {\n-\n+  static Context fromHttpHeaders(Map<String, String> headers) {\n     return OpenTelemetry.getGlobalPropagators()\n         .getTextMapPropagator()\n-        .extract(io.opentelemetry.context.Context.current(), headers, HeadersGetter.INSTANCE);\n+        .extract(\n+            io.opentelemetry.context.Context.current(), lowercaseMap(headers), MapGetter.INSTANCE);\n   }\n \n-  private static class HeadersGetter implements TextMapPropagator.Getter<Headers> {\n-\n-    private static final HeadersGetter INSTANCE = new HeadersGetter();\n-\n-    @Override\n-    public Iterable<String> keys(Headers map) {\n-      return map.keySet();\n-    }\n-\n-    @Override\n-    public String get(Headers headers, String s) {\n-      return headers.getFirst(s);\n-    }\n+  private static Map<String, String> lowercaseMap(Map<String, String> source) {\n+    return source.entrySet().stream()\n+        .collect(\n+            Collectors.toMap(\n+                e -> e.getKey() == null ? null : e.getKey().toLowerCase(), Entry::getValue));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9625ad33396952c0509544f07d3fc3e01919e6d"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk5MjUzMg==", "bodyText": "What do you think about .filter(e -> e.getKey() != null)?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1650#discussion_r524992532", "createdAt": "2020-11-17T09:08:35Z", "author": {"login": "anuraaga"}, "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/ParentContextExtractor.java", "diffHunk": "@@ -5,35 +5,28 @@\n \n package io.opentelemetry.instrumentation.awslambda.v1_0;\n \n-import com.amazonaws.serverless.proxy.model.Headers;\n import io.opentelemetry.api.OpenTelemetry;\n import io.opentelemetry.context.Context;\n import io.opentelemetry.context.propagation.TextMapPropagator;\n import java.util.Collections;\n import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n \n public class ParentContextExtractor {\n \n-  static Context fromHttpHeaders(Headers headers) {\n-\n+  static Context fromHttpHeaders(Map<String, String> headers) {\n     return OpenTelemetry.getGlobalPropagators()\n         .getTextMapPropagator()\n-        .extract(io.opentelemetry.context.Context.current(), headers, HeadersGetter.INSTANCE);\n+        .extract(\n+            io.opentelemetry.context.Context.current(), lowercaseMap(headers), MapGetter.INSTANCE);\n   }\n \n-  private static class HeadersGetter implements TextMapPropagator.Getter<Headers> {\n-\n-    private static final HeadersGetter INSTANCE = new HeadersGetter();\n-\n-    @Override\n-    public Iterable<String> keys(Headers map) {\n-      return map.keySet();\n-    }\n-\n-    @Override\n-    public String get(Headers headers, String s) {\n-      return headers.getFirst(s);\n-    }\n+  private static Map<String, String> lowercaseMap(Map<String, String> source) {\n+    return source.entrySet().stream()\n+        .collect(\n+            Collectors.toMap(\n+                e -> e.getKey() == null ? null : e.getKey().toLowerCase(), Entry::getValue));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk5MjIwOA=="}, "originalCommit": {"oid": "e9625ad33396952c0509544f07d3fc3e01919e6d"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAyMDg4OQ==", "bodyText": "The idea here was a typical one - some map implementations allow NULLed keys. But since it's about HTTP headers, filtering out makes sense. Thanks :)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1650#discussion_r525020889", "createdAt": "2020-11-17T09:50:17Z", "author": {"login": "kubawach"}, "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/ParentContextExtractor.java", "diffHunk": "@@ -5,35 +5,28 @@\n \n package io.opentelemetry.instrumentation.awslambda.v1_0;\n \n-import com.amazonaws.serverless.proxy.model.Headers;\n import io.opentelemetry.api.OpenTelemetry;\n import io.opentelemetry.context.Context;\n import io.opentelemetry.context.propagation.TextMapPropagator;\n import java.util.Collections;\n import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n \n public class ParentContextExtractor {\n \n-  static Context fromHttpHeaders(Headers headers) {\n-\n+  static Context fromHttpHeaders(Map<String, String> headers) {\n     return OpenTelemetry.getGlobalPropagators()\n         .getTextMapPropagator()\n-        .extract(io.opentelemetry.context.Context.current(), headers, HeadersGetter.INSTANCE);\n+        .extract(\n+            io.opentelemetry.context.Context.current(), lowercaseMap(headers), MapGetter.INSTANCE);\n   }\n \n-  private static class HeadersGetter implements TextMapPropagator.Getter<Headers> {\n-\n-    private static final HeadersGetter INSTANCE = new HeadersGetter();\n-\n-    @Override\n-    public Iterable<String> keys(Headers map) {\n-      return map.keySet();\n-    }\n-\n-    @Override\n-    public String get(Headers headers, String s) {\n-      return headers.getFirst(s);\n-    }\n+  private static Map<String, String> lowercaseMap(Map<String, String> source) {\n+    return source.entrySet().stream()\n+        .collect(\n+            Collectors.toMap(\n+                e -> e.getKey() == null ? null : e.getKey().toLowerCase(), Entry::getValue));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk5MjIwOA=="}, "originalCommit": {"oid": "e9625ad33396952c0509544f07d3fc3e01919e6d"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MTY3MTkwOnYy", "diffSide": "RIGHT", "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/ParentContextExtractor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwOTowOToxMlrOH0rBhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwOTo1ODowNFrOH0tEaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk5MjkwMg==", "bodyText": "It would be nice to store the lowercased as a constant", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1650#discussion_r524992902", "createdAt": "2020-11-17T09:09:12Z", "author": {"login": "anuraaga"}, "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/ParentContextExtractor.java", "diffHunk": "@@ -43,7 +36,7 @@ static Context fromXRayHeader(String parentHeader) {\n         .getTextMapPropagator()\n         .extract(\n             Context.current(),\n-            Collections.singletonMap(AWS_TRACE_HEADER_PROPAGATOR_KEY, parentHeader),\n+            Collections.singletonMap(AWS_TRACE_HEADER_PROPAGATOR_KEY.toLowerCase(), parentHeader),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9625ad33396952c0509544f07d3fc3e01919e6d"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAyNjQwOQ==", "bodyText": "+1", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1650#discussion_r525026409", "createdAt": "2020-11-17T09:58:04Z", "author": {"login": "kubawach"}, "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/ParentContextExtractor.java", "diffHunk": "@@ -43,7 +36,7 @@ static Context fromXRayHeader(String parentHeader) {\n         .getTextMapPropagator()\n         .extract(\n             Context.current(),\n-            Collections.singletonMap(AWS_TRACE_HEADER_PROPAGATOR_KEY, parentHeader),\n+            Collections.singletonMap(AWS_TRACE_HEADER_PROPAGATOR_KEY.toLowerCase(), parentHeader),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk5MjkwMg=="}, "originalCommit": {"oid": "e9625ad33396952c0509544f07d3fc3e01919e6d"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MTY3NjE1OnYy", "diffSide": "RIGHT", "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/WrappedLambda.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwOToxMDowNlrOH0rD6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwOTo1OTozMFrOH0tH8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk5MzUxNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                              // one of the methods has last param context ?\n          \n          \n            \n                              // only one of the methods has last param context ?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1650#discussion_r524993514", "createdAt": "2020-11-17T09:10:06Z", "author": {"login": "anuraaga"}, "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/WrappedLambda.java", "diffHunk": "@@ -106,12 +107,19 @@ Method getRequestTargetMethod() {\n                   if (a.getParameterCount() != b.getParameterCount()) {\n                     return b.getParameterCount() - a.getParameterCount();\n                   }\n-                  if (isLastParameterContext(a.getParameters())) {\n-                    return -1;\n-                  } else if (isLastParameterContext(b.getParameters())) {\n-                    return 1;\n+                  boolean firstCtx = isLastParameterContext(a.getParameters());\n+                  boolean secondCtx = isLastParameterContext(b.getParameters());\n+                  // one of the methods has last param context ?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9625ad33396952c0509544f07d3fc3e01919e6d"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAyNzMxNQ==", "bodyText": "+1", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1650#discussion_r525027315", "createdAt": "2020-11-17T09:59:30Z", "author": {"login": "kubawach"}, "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/WrappedLambda.java", "diffHunk": "@@ -106,12 +107,19 @@ Method getRequestTargetMethod() {\n                   if (a.getParameterCount() != b.getParameterCount()) {\n                     return b.getParameterCount() - a.getParameterCount();\n                   }\n-                  if (isLastParameterContext(a.getParameters())) {\n-                    return -1;\n-                  } else if (isLastParameterContext(b.getParameters())) {\n-                    return 1;\n+                  boolean firstCtx = isLastParameterContext(a.getParameters());\n+                  boolean secondCtx = isLastParameterContext(b.getParameters());\n+                  // one of the methods has last param context ?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk5MzUxNA=="}, "originalCommit": {"oid": "e9625ad33396952c0509544f07d3fc3e01919e6d"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MTY4MDU2OnYy", "diffSide": "RIGHT", "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/WrappedLambda.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwOToxMToxMFrOH0rGjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMDoyMzoyNVrOH0uEcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk5NDE4OA==", "bodyText": "This logic has gotten pretty mysterious - would it be possible to add some example method signatures to the javadoc to explain it?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1650#discussion_r524994188", "createdAt": "2020-11-17T09:11:10Z", "author": {"login": "anuraaga"}, "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/WrappedLambda.java", "diffHunk": "@@ -106,12 +107,19 @@ Method getRequestTargetMethod() {\n                   if (a.getParameterCount() != b.getParameterCount()) {\n                     return b.getParameterCount() - a.getParameterCount();\n                   }\n-                  if (isLastParameterContext(a.getParameters())) {\n-                    return -1;\n-                  } else if (isLastParameterContext(b.getParameters())) {\n-                    return 1;\n+                  boolean firstCtx = isLastParameterContext(a.getParameters());\n+                  boolean secondCtx = isLastParameterContext(b.getParameters());\n+                  // one of the methods has last param context ?\n+                  if (firstCtx ^ secondCtx) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9625ad33396952c0509544f07d3fc3e01919e6d"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA0MjgwMA==", "bodyText": "Added :)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1650#discussion_r525042800", "createdAt": "2020-11-17T10:23:25Z", "author": {"login": "kubawach"}, "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/WrappedLambda.java", "diffHunk": "@@ -106,12 +107,19 @@ Method getRequestTargetMethod() {\n                   if (a.getParameterCount() != b.getParameterCount()) {\n                     return b.getParameterCount() - a.getParameterCount();\n                   }\n-                  if (isLastParameterContext(a.getParameters())) {\n-                    return -1;\n-                  } else if (isLastParameterContext(b.getParameters())) {\n-                    return 1;\n+                  boolean firstCtx = isLastParameterContext(a.getParameters());\n+                  boolean secondCtx = isLastParameterContext(b.getParameters());\n+                  // one of the methods has last param context ?\n+                  if (firstCtx ^ secondCtx) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk5NDE4OA=="}, "originalCommit": {"oid": "e9625ad33396952c0509544f07d3fc3e01919e6d"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MjI0ODE1OnYy", "diffSide": "RIGHT", "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/ApiGatewayProxyRequest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMToyODozNVrOH0wg6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMjowMTo1NVrOH0xq7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA4Mjg1Ng==", "bodyText": "How about\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                List<String> values = entry.getValue();\n          \n          \n            \n                return (nullOrEmpty(values) ? null : values.get(0));\n          \n          \n            \n                return entry.getValue().stream()\n          \n          \n            \n                    .findFirst()\n          \n          \n            \n                    .orElse(null);\n          \n      \n    \n    \n  \n\ninstead?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1650#discussion_r525082856", "createdAt": "2020-11-17T11:28:35Z", "author": {"login": "mateuszrzeszutek"}, "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/ApiGatewayProxyRequest.java", "diffHunk": "@@ -42,9 +44,20 @@ static ApiGatewayProxyRequest forStream(final InputStream source) throws IOExcep\n     return new CopiedApiGatewayProxyRequest(source);\n   }\n \n+  private static boolean nullOrEmpty(List<String> values) {\n+    return ((values == null) || values.isEmpty());\n+  }\n+\n+  private static String extractFirstValue(Map.Entry<String, List<String>> entry) {\n+    List<String> values = entry.getValue();\n+    return (nullOrEmpty(values) ? null : values.get(0));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8130bccc32b481c8b60eba343840fe5e7bf15ba6"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTEwMTgwNg==", "bodyText": "More readable, less performant I guess (streaming the list vs checking for empty()). Also, null values list is not handled properly.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1650#discussion_r525101806", "createdAt": "2020-11-17T12:01:55Z", "author": {"login": "kubawach"}, "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/ApiGatewayProxyRequest.java", "diffHunk": "@@ -42,9 +44,20 @@ static ApiGatewayProxyRequest forStream(final InputStream source) throws IOExcep\n     return new CopiedApiGatewayProxyRequest(source);\n   }\n \n+  private static boolean nullOrEmpty(List<String> values) {\n+    return ((values == null) || values.isEmpty());\n+  }\n+\n+  private static String extractFirstValue(Map.Entry<String, List<String>> entry) {\n+    List<String> values = entry.getValue();\n+    return (nullOrEmpty(values) ? null : values.get(0));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA4Mjg1Ng=="}, "originalCommit": {"oid": "8130bccc32b481c8b60eba343840fe5e7bf15ba6"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwOTMzMjQ3OnYy", "diffSide": "RIGHT", "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/TracingRequestWrapperBase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNjowMzowM1rOH3V0vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNzowMjowMVrOH4W-lA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzc5MTI5NA==", "bodyText": "I'm definitely not a fan of using an O as a type parameter. It looks way too much like a 0.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1650#discussion_r527791294", "createdAt": "2020-11-20T16:03:03Z", "author": {"login": "jkwatson"}, "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/TracingRequestWrapperBase.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.awslambda.v1_0;\n+\n+import com.amazonaws.services.lambda.runtime.Context;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+/**\n+ * Base abstract wrapper for {@link TracingRequestHandler}. Provides: - delegation to a lambda via\n+ * env property OTEL_LAMBDA_HANDLER in package.ClassName::methodName format\n+ */\n+abstract class TracingRequestWrapperBase<I, O> extends TracingRequestHandler<I, O> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ecb2c67232a4112ea4d3e14c77675d6c22f17e23"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg1ODc3Mg==", "bodyText": "It's a copy from the root handler I (input), O (ouput). Would leave that to maintain consistency :)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1650#discussion_r528858772", "createdAt": "2020-11-23T17:02:01Z", "author": {"login": "kubawach"}, "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/TracingRequestWrapperBase.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.awslambda.v1_0;\n+\n+import com.amazonaws.services.lambda.runtime.Context;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+/**\n+ * Base abstract wrapper for {@link TracingRequestHandler}. Provides: - delegation to a lambda via\n+ * env property OTEL_LAMBDA_HANDLER in package.ClassName::methodName format\n+ */\n+abstract class TracingRequestWrapperBase<I, O> extends TracingRequestHandler<I, O> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzc5MTI5NA=="}, "originalCommit": {"oid": "ecb2c67232a4112ea4d3e14c77675d6c22f17e23"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwOTM0MDk3OnYy", "diffSide": "RIGHT", "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/WrappedLambda.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNjowNTowOFrOH3V56w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNzowMjo1N1rOH4XA5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzc5MjYxOQ==", "bodyText": "personally I'd avoid using rarely used boolean operators like this. I had to look up that this was an xor. It makes the code harder to read.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1650#discussion_r527792619", "createdAt": "2020-11-20T16:05:08Z", "author": {"login": "jkwatson"}, "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/WrappedLambda.java", "diffHunk": "@@ -92,24 +92,38 @@ Method getRequestTargetMethod() {\n        - Context can be omitted\n        - Select the method with the largest number of parameters.\n        - If two or more methods have the same number of parameters, AWS Lambda selects the method that has the Context as the last parameter.\n+       - Non-Bridge methods are preferred\n        - If none or all of these methods have the Context parameter, then the behavior is undefined.\n+\n+       Examples:\n+       - handleA(String, String, Integer), handleB(String, Context) - handleA is selected (number of parameters)\n+       - handleA(String, String, Integer), handleB(String, String, Context) - handleB is selected (has Context as the last parameter)\n+       - generic method handleG(T, U, Context), implementation (T, U - String) handleA(String, String, Context), bridge method handleB(Object, Object, Context) - handleA is selected (non-bridge)\n     */\n     List<Method> methods = Arrays.asList(targetClass.getMethods());\n     Optional<Method> firstOptional =\n         methods.stream()\n             .filter((Method m) -> m.getName().equals(targetMethodName))\n             .sorted(\n                 (Method a, Method b) -> {\n-                  // sort descending (reverse of default ascending)\n+                  // larger number of params wins\n                   if (a.getParameterCount() != b.getParameterCount()) {\n                     return b.getParameterCount() - a.getParameterCount();\n                   }\n-                  if (isLastParameterContext(a.getParameters())) {\n-                    return -1;\n-                  } else if (isLastParameterContext(b.getParameters())) {\n-                    return 1;\n+                  boolean firstCtx = isLastParameterContext(a.getParameters());\n+                  boolean secondCtx = isLastParameterContext(b.getParameters());\n+                  // only one of the methods has last param context ?\n+                  if (firstCtx ^ secondCtx) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ecb2c67232a4112ea4d3e14c77675d6c22f17e23"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzc5MzYwNA==", "bodyText": "I also recommend putting all of this code into a method with a clear name. I honestly have no idea what the purpose of all this stuff is.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1650#discussion_r527793604", "createdAt": "2020-11-20T16:06:33Z", "author": {"login": "jkwatson"}, "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/WrappedLambda.java", "diffHunk": "@@ -92,24 +92,38 @@ Method getRequestTargetMethod() {\n        - Context can be omitted\n        - Select the method with the largest number of parameters.\n        - If two or more methods have the same number of parameters, AWS Lambda selects the method that has the Context as the last parameter.\n+       - Non-Bridge methods are preferred\n        - If none or all of these methods have the Context parameter, then the behavior is undefined.\n+\n+       Examples:\n+       - handleA(String, String, Integer), handleB(String, Context) - handleA is selected (number of parameters)\n+       - handleA(String, String, Integer), handleB(String, String, Context) - handleB is selected (has Context as the last parameter)\n+       - generic method handleG(T, U, Context), implementation (T, U - String) handleA(String, String, Context), bridge method handleB(Object, Object, Context) - handleA is selected (non-bridge)\n     */\n     List<Method> methods = Arrays.asList(targetClass.getMethods());\n     Optional<Method> firstOptional =\n         methods.stream()\n             .filter((Method m) -> m.getName().equals(targetMethodName))\n             .sorted(\n                 (Method a, Method b) -> {\n-                  // sort descending (reverse of default ascending)\n+                  // larger number of params wins\n                   if (a.getParameterCount() != b.getParameterCount()) {\n                     return b.getParameterCount() - a.getParameterCount();\n                   }\n-                  if (isLastParameterContext(a.getParameters())) {\n-                    return -1;\n-                  } else if (isLastParameterContext(b.getParameters())) {\n-                    return 1;\n+                  boolean firstCtx = isLastParameterContext(a.getParameters());\n+                  boolean secondCtx = isLastParameterContext(b.getParameters());\n+                  // only one of the methods has last param context ?\n+                  if (firstCtx ^ secondCtx) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzc5MjYxOQ=="}, "originalCommit": {"oid": "ecb2c67232a4112ea4d3e14c77675d6c22f17e23"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzc5NDQ5Mg==", "bodyText": "Also, are there tests for these changes?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1650#discussion_r527794492", "createdAt": "2020-11-20T16:08:00Z", "author": {"login": "jkwatson"}, "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/WrappedLambda.java", "diffHunk": "@@ -92,24 +92,38 @@ Method getRequestTargetMethod() {\n        - Context can be omitted\n        - Select the method with the largest number of parameters.\n        - If two or more methods have the same number of parameters, AWS Lambda selects the method that has the Context as the last parameter.\n+       - Non-Bridge methods are preferred\n        - If none or all of these methods have the Context parameter, then the behavior is undefined.\n+\n+       Examples:\n+       - handleA(String, String, Integer), handleB(String, Context) - handleA is selected (number of parameters)\n+       - handleA(String, String, Integer), handleB(String, String, Context) - handleB is selected (has Context as the last parameter)\n+       - generic method handleG(T, U, Context), implementation (T, U - String) handleA(String, String, Context), bridge method handleB(Object, Object, Context) - handleA is selected (non-bridge)\n     */\n     List<Method> methods = Arrays.asList(targetClass.getMethods());\n     Optional<Method> firstOptional =\n         methods.stream()\n             .filter((Method m) -> m.getName().equals(targetMethodName))\n             .sorted(\n                 (Method a, Method b) -> {\n-                  // sort descending (reverse of default ascending)\n+                  // larger number of params wins\n                   if (a.getParameterCount() != b.getParameterCount()) {\n                     return b.getParameterCount() - a.getParameterCount();\n                   }\n-                  if (isLastParameterContext(a.getParameters())) {\n-                    return -1;\n-                  } else if (isLastParameterContext(b.getParameters())) {\n-                    return 1;\n+                  boolean firstCtx = isLastParameterContext(a.getParameters());\n+                  boolean secondCtx = isLastParameterContext(b.getParameters());\n+                  // only one of the methods has last param context ?\n+                  if (firstCtx ^ secondCtx) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzc5MjYxOQ=="}, "originalCommit": {"oid": "ecb2c67232a4112ea4d3e14c77675d6c22f17e23"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzgxNTI1Nw==", "bodyText": "Honestly I had the same reaction, including the xor double take. The added javadoc helps a lot but if this can be restructured for more readability that would be nice - if it was just me whatever, but seems to be more general :)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1650#discussion_r527815257", "createdAt": "2020-11-20T16:39:39Z", "author": {"login": "anuraaga"}, "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/WrappedLambda.java", "diffHunk": "@@ -92,24 +92,38 @@ Method getRequestTargetMethod() {\n        - Context can be omitted\n        - Select the method with the largest number of parameters.\n        - If two or more methods have the same number of parameters, AWS Lambda selects the method that has the Context as the last parameter.\n+       - Non-Bridge methods are preferred\n        - If none or all of these methods have the Context parameter, then the behavior is undefined.\n+\n+       Examples:\n+       - handleA(String, String, Integer), handleB(String, Context) - handleA is selected (number of parameters)\n+       - handleA(String, String, Integer), handleB(String, String, Context) - handleB is selected (has Context as the last parameter)\n+       - generic method handleG(T, U, Context), implementation (T, U - String) handleA(String, String, Context), bridge method handleB(Object, Object, Context) - handleA is selected (non-bridge)\n     */\n     List<Method> methods = Arrays.asList(targetClass.getMethods());\n     Optional<Method> firstOptional =\n         methods.stream()\n             .filter((Method m) -> m.getName().equals(targetMethodName))\n             .sorted(\n                 (Method a, Method b) -> {\n-                  // sort descending (reverse of default ascending)\n+                  // larger number of params wins\n                   if (a.getParameterCount() != b.getParameterCount()) {\n                     return b.getParameterCount() - a.getParameterCount();\n                   }\n-                  if (isLastParameterContext(a.getParameters())) {\n-                    return -1;\n-                  } else if (isLastParameterContext(b.getParameters())) {\n-                    return 1;\n+                  boolean firstCtx = isLastParameterContext(a.getParameters());\n+                  boolean secondCtx = isLastParameterContext(b.getParameters());\n+                  // only one of the methods has last param context ?\n+                  if (firstCtx ^ secondCtx) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzc5MjYxOQ=="}, "originalCommit": {"oid": "ecb2c67232a4112ea4d3e14c77675d6c22f17e23"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg1OTM2NA==", "bodyText": "Yeah, I'm not fond of XOR either, however in this context - mutual exclusion - seemed to fit the bill nicely. However can restructure as requested.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1650#discussion_r528859364", "createdAt": "2020-11-23T17:02:57Z", "author": {"login": "kubawach"}, "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/WrappedLambda.java", "diffHunk": "@@ -92,24 +92,38 @@ Method getRequestTargetMethod() {\n        - Context can be omitted\n        - Select the method with the largest number of parameters.\n        - If two or more methods have the same number of parameters, AWS Lambda selects the method that has the Context as the last parameter.\n+       - Non-Bridge methods are preferred\n        - If none or all of these methods have the Context parameter, then the behavior is undefined.\n+\n+       Examples:\n+       - handleA(String, String, Integer), handleB(String, Context) - handleA is selected (number of parameters)\n+       - handleA(String, String, Integer), handleB(String, String, Context) - handleB is selected (has Context as the last parameter)\n+       - generic method handleG(T, U, Context), implementation (T, U - String) handleA(String, String, Context), bridge method handleB(Object, Object, Context) - handleA is selected (non-bridge)\n     */\n     List<Method> methods = Arrays.asList(targetClass.getMethods());\n     Optional<Method> firstOptional =\n         methods.stream()\n             .filter((Method m) -> m.getName().equals(targetMethodName))\n             .sorted(\n                 (Method a, Method b) -> {\n-                  // sort descending (reverse of default ascending)\n+                  // larger number of params wins\n                   if (a.getParameterCount() != b.getParameterCount()) {\n                     return b.getParameterCount() - a.getParameterCount();\n                   }\n-                  if (isLastParameterContext(a.getParameters())) {\n-                    return -1;\n-                  } else if (isLastParameterContext(b.getParameters())) {\n-                    return 1;\n+                  boolean firstCtx = isLastParameterContext(a.getParameters());\n+                  boolean secondCtx = isLastParameterContext(b.getParameters());\n+                  // only one of the methods has last param context ?\n+                  if (firstCtx ^ secondCtx) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzc5MjYxOQ=="}, "originalCommit": {"oid": "ecb2c67232a4112ea4d3e14c77675d6c22f17e23"}, "originalPosition": 30}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4602, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}