{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA5MjIxODUx", "number": 1471, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwNTo0NjozNVrOExwd-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwNTo0ODozNlrOExwfPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNjA5Nzg1OnYy", "diffSide": "RIGHT", "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/TracingRequestStreamHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwNTo0NjozNVrOHoBh5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwOTo1NjoyMVrOHoIJnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTczMDE0OQ==", "bodyText": "Thanks for handling the stream handlers :)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1471#discussion_r511730149", "createdAt": "2020-10-26T05:46:35Z", "author": {"login": "anuraaga"}, "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/TracingRequestStreamHandler.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.awslambda.v1_0;\n+\n+import com.amazonaws.services.lambda.runtime.Context;\n+import com.amazonaws.services.lambda.runtime.RequestStreamHandler;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * A base class similar to {@link RequestStreamHandler} but will automatically trace invocations of\n+ * {@link #doHandleRequest(InputStream input, OutputStream output, Context)}.\n+ */\n+public abstract class TracingRequestStreamHandler implements RequestStreamHandler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ad01d9afd9f03ea674576215014a9c6b7df74a3"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgzODYyMQ==", "bodyText": ":)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1471#discussion_r511838621", "createdAt": "2020-10-26T09:56:21Z", "author": {"login": "kubawach"}, "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/TracingRequestStreamHandler.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.awslambda.v1_0;\n+\n+import com.amazonaws.services.lambda.runtime.Context;\n+import com.amazonaws.services.lambda.runtime.RequestStreamHandler;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * A base class similar to {@link RequestStreamHandler} but will automatically trace invocations of\n+ * {@link #doHandleRequest(InputStream input, OutputStream output, Context)}.\n+ */\n+public abstract class TracingRequestStreamHandler implements RequestStreamHandler {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTczMDE0OQ=="}, "originalCommit": {"oid": "4ad01d9afd9f03ea674576215014a9c6b7df74a3"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNjA5ODkyOnYy", "diffSide": "RIGHT", "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/TracingRequestStreamHandler.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwNTo0NzoyNVrOHoBifg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxMTo0ODoxOFrOHoL-nQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTczMDMwMg==", "bodyText": "I think we need to wrap OutputStream so the span is closed on OutputStream.close which could be asynchronous?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1471#discussion_r511730302", "createdAt": "2020-10-26T05:47:25Z", "author": {"login": "anuraaga"}, "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/TracingRequestStreamHandler.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.awslambda.v1_0;\n+\n+import com.amazonaws.services.lambda.runtime.Context;\n+import com.amazonaws.services.lambda.runtime.RequestStreamHandler;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * A base class similar to {@link RequestStreamHandler} but will automatically trace invocations of\n+ * {@link #doHandleRequest(InputStream input, OutputStream output, Context)}.\n+ */\n+public abstract class TracingRequestStreamHandler implements RequestStreamHandler {\n+\n+  private final AwsLambdaTracer tracer;\n+\n+  /**\n+   * Creates a new {@link TracingRequestStreamHandler} which traces using the default {@link\n+   * Tracer}.\n+   */\n+  protected TracingRequestStreamHandler() {\n+    this.tracer = new AwsLambdaTracer();\n+  }\n+\n+  /**\n+   * Creates a new {@link TracingRequestStreamHandler} which traces using the specified {@link\n+   * Tracer}.\n+   */\n+  protected TracingRequestStreamHandler(Tracer tracer) {\n+    this.tracer = new AwsLambdaTracer(tracer);\n+  }\n+\n+  /**\n+   * Creates a new {@link TracingRequestStreamHandler} which traces using the specified {@link\n+   * AwsLambdaTracer}.\n+   */\n+  protected TracingRequestStreamHandler(AwsLambdaTracer tracer) {\n+    this.tracer = tracer;\n+  }\n+\n+  @Override\n+  public final void handleRequest(InputStream input, OutputStream output, Context context)\n+      throws IOException {\n+    Span span = tracer.startSpan(context, Kind.SERVER);\n+    Throwable error = null;\n+    try (Scope ignored = tracer.startScope(span)) {\n+      doHandleRequest(input, output, context);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ad01d9afd9f03ea674576215014a9c6b7df74a3"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgzODUxOQ==", "bodyText": "It's an option I considered. However now, with span issued on lambda exit, stream handler behaves exactly as \"no stream\" counterpart. In particular, the span gets send even if underlying output stream flush fails - I understand that in the case of RequestHandler implementations serialization / writing happens after the lambda exits. So with this implementation we have similar behaviour in both cases. What do you think?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1471#discussion_r511838519", "createdAt": "2020-10-26T09:56:10Z", "author": {"login": "kubawach"}, "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/TracingRequestStreamHandler.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.awslambda.v1_0;\n+\n+import com.amazonaws.services.lambda.runtime.Context;\n+import com.amazonaws.services.lambda.runtime.RequestStreamHandler;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * A base class similar to {@link RequestStreamHandler} but will automatically trace invocations of\n+ * {@link #doHandleRequest(InputStream input, OutputStream output, Context)}.\n+ */\n+public abstract class TracingRequestStreamHandler implements RequestStreamHandler {\n+\n+  private final AwsLambdaTracer tracer;\n+\n+  /**\n+   * Creates a new {@link TracingRequestStreamHandler} which traces using the default {@link\n+   * Tracer}.\n+   */\n+  protected TracingRequestStreamHandler() {\n+    this.tracer = new AwsLambdaTracer();\n+  }\n+\n+  /**\n+   * Creates a new {@link TracingRequestStreamHandler} which traces using the specified {@link\n+   * Tracer}.\n+   */\n+  protected TracingRequestStreamHandler(Tracer tracer) {\n+    this.tracer = new AwsLambdaTracer(tracer);\n+  }\n+\n+  /**\n+   * Creates a new {@link TracingRequestStreamHandler} which traces using the specified {@link\n+   * AwsLambdaTracer}.\n+   */\n+  protected TracingRequestStreamHandler(AwsLambdaTracer tracer) {\n+    this.tracer = tracer;\n+  }\n+\n+  @Override\n+  public final void handleRequest(InputStream input, OutputStream output, Context context)\n+      throws IOException {\n+    Span span = tracer.startSpan(context, Kind.SERVER);\n+    Throwable error = null;\n+    try (Scope ignored = tracer.startScope(span)) {\n+      doHandleRequest(input, output, context);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTczMDMwMg=="}, "originalCommit": {"oid": "4ad01d9afd9f03ea674576215014a9c6b7df74a3"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg0OTAwNA==", "bodyText": "I don't know the details of lambda well but does it not allow something like\nCompletableFuture<Foo> response = backend.getFoo();\n\nresponse.thenAccept(writeToOutputStream);\n\nIf this is allowed than I think we need to make sure the span survives until the output is closed since that's the length of the request and how we generally model async requests.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1471#discussion_r511849004", "createdAt": "2020-10-26T10:13:24Z", "author": {"login": "anuraaga"}, "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/TracingRequestStreamHandler.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.awslambda.v1_0;\n+\n+import com.amazonaws.services.lambda.runtime.Context;\n+import com.amazonaws.services.lambda.runtime.RequestStreamHandler;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * A base class similar to {@link RequestStreamHandler} but will automatically trace invocations of\n+ * {@link #doHandleRequest(InputStream input, OutputStream output, Context)}.\n+ */\n+public abstract class TracingRequestStreamHandler implements RequestStreamHandler {\n+\n+  private final AwsLambdaTracer tracer;\n+\n+  /**\n+   * Creates a new {@link TracingRequestStreamHandler} which traces using the default {@link\n+   * Tracer}.\n+   */\n+  protected TracingRequestStreamHandler() {\n+    this.tracer = new AwsLambdaTracer();\n+  }\n+\n+  /**\n+   * Creates a new {@link TracingRequestStreamHandler} which traces using the specified {@link\n+   * Tracer}.\n+   */\n+  protected TracingRequestStreamHandler(Tracer tracer) {\n+    this.tracer = new AwsLambdaTracer(tracer);\n+  }\n+\n+  /**\n+   * Creates a new {@link TracingRequestStreamHandler} which traces using the specified {@link\n+   * AwsLambdaTracer}.\n+   */\n+  protected TracingRequestStreamHandler(AwsLambdaTracer tracer) {\n+    this.tracer = tracer;\n+  }\n+\n+  @Override\n+  public final void handleRequest(InputStream input, OutputStream output, Context context)\n+      throws IOException {\n+    Span span = tracer.startSpan(context, Kind.SERVER);\n+    Throwable error = null;\n+    try (Scope ignored = tracer.startScope(span)) {\n+      doHandleRequest(input, output, context);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTczMDMwMg=="}, "originalCommit": {"oid": "4ad01d9afd9f03ea674576215014a9c6b7df74a3"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkwMTM0MQ==", "bodyText": "With this in mind, the idea totally makes sense. Will wrap OOS then :)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1471#discussion_r511901341", "createdAt": "2020-10-26T11:48:18Z", "author": {"login": "kubawach"}, "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/TracingRequestStreamHandler.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.awslambda.v1_0;\n+\n+import com.amazonaws.services.lambda.runtime.Context;\n+import com.amazonaws.services.lambda.runtime.RequestStreamHandler;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * A base class similar to {@link RequestStreamHandler} but will automatically trace invocations of\n+ * {@link #doHandleRequest(InputStream input, OutputStream output, Context)}.\n+ */\n+public abstract class TracingRequestStreamHandler implements RequestStreamHandler {\n+\n+  private final AwsLambdaTracer tracer;\n+\n+  /**\n+   * Creates a new {@link TracingRequestStreamHandler} which traces using the default {@link\n+   * Tracer}.\n+   */\n+  protected TracingRequestStreamHandler() {\n+    this.tracer = new AwsLambdaTracer();\n+  }\n+\n+  /**\n+   * Creates a new {@link TracingRequestStreamHandler} which traces using the specified {@link\n+   * Tracer}.\n+   */\n+  protected TracingRequestStreamHandler(Tracer tracer) {\n+    this.tracer = new AwsLambdaTracer(tracer);\n+  }\n+\n+  /**\n+   * Creates a new {@link TracingRequestStreamHandler} which traces using the specified {@link\n+   * AwsLambdaTracer}.\n+   */\n+  protected TracingRequestStreamHandler(AwsLambdaTracer tracer) {\n+    this.tracer = tracer;\n+  }\n+\n+  @Override\n+  public final void handleRequest(InputStream input, OutputStream output, Context context)\n+      throws IOException {\n+    Span span = tracer.startSpan(context, Kind.SERVER);\n+    Throwable error = null;\n+    try (Scope ignored = tracer.startScope(span)) {\n+      doHandleRequest(input, output, context);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTczMDMwMg=="}, "originalCommit": {"oid": "4ad01d9afd9f03ea674576215014a9c6b7df74a3"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNjEwMTA4OnYy", "diffSide": "RIGHT", "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/TracingRequestStreamWrapper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwNTo0ODozNlrOHoBjpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwOTozMzoxOVrOHoHTGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTczMDU5OQ==", "bodyText": "I wonder if we should just make this static since the configuration is?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1471#discussion_r511730599", "createdAt": "2020-10-26T05:48:36Z", "author": {"login": "anuraaga"}, "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/TracingRequestStreamWrapper.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.awslambda.v1_0;\n+\n+import com.amazonaws.services.lambda.runtime.Context;\n+import com.amazonaws.services.lambda.runtime.RequestStreamHandler;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+\n+/**\n+ * Wrapper for {@link TracingRequestStreamHandler}. Allows for wrapping a regular lambda, enabling\n+ * single span tracing. Main lambda class should be configured as env property OTEL_LAMBDA_HANDLER\n+ * in package.ClassName::methodName format. Lambda class must implement {@link\n+ * RequestStreamHandler}.\n+ */\n+public class TracingRequestStreamWrapper extends TracingRequestStreamHandler {\n+\n+  private WrappedLambda wrappedLambda;\n+\n+  @Override\n+  protected void doHandleRequest(InputStream input, OutputStream output, Context context)\n+      throws IOException {\n+\n+    if (wrappedLambda == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ad01d9afd9f03ea674576215014a9c6b7df74a3"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgyNDY2Ng==", "bodyText": "Good idea, changed.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1471#discussion_r511824666", "createdAt": "2020-10-26T09:33:19Z", "author": {"login": "kubawach"}, "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/TracingRequestStreamWrapper.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.awslambda.v1_0;\n+\n+import com.amazonaws.services.lambda.runtime.Context;\n+import com.amazonaws.services.lambda.runtime.RequestStreamHandler;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+\n+/**\n+ * Wrapper for {@link TracingRequestStreamHandler}. Allows for wrapping a regular lambda, enabling\n+ * single span tracing. Main lambda class should be configured as env property OTEL_LAMBDA_HANDLER\n+ * in package.ClassName::methodName format. Lambda class must implement {@link\n+ * RequestStreamHandler}.\n+ */\n+public class TracingRequestStreamWrapper extends TracingRequestStreamHandler {\n+\n+  private WrappedLambda wrappedLambda;\n+\n+  @Override\n+  protected void doHandleRequest(InputStream input, OutputStream output, Context context)\n+      throws IOException {\n+\n+    if (wrappedLambda == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTczMDU5OQ=="}, "originalCommit": {"oid": "4ad01d9afd9f03ea674576215014a9c6b7df74a3"}, "originalPosition": 28}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4737, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}