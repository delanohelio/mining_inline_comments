{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEzMzUxNzcy", "number": 379, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwOToyMTo1MVrOD5UiPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNDo1NzozMlrOD524qA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNDMxODcwOnYy", "diffSide": "RIGHT", "path": "instrumentation/trace-annotation/trace-annotation.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwOToyMTo1MVrOGQhKPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwOToyMTo1MVrOGQhKPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk3MzY5NQ==", "bodyText": "Need help here. I don't understand why this dependency is needed here. All instrumentation modules depend on agent-tooling which depends on agent-bootstrap which depends on this opentelemetry-contrib-auto-annotations. Why this needs to be specified as test dependency? Some other tests fail because they lack this declaration. But I assumed this jar will be automatically in the classpath of tests. What don't I understand?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/379#discussion_r419973695", "createdAt": "2020-05-05T09:21:51Z", "author": {"login": "iNikem"}, "path": "instrumentation/trace-annotation/trace-annotation.gradle", "diffHunk": "@@ -24,4 +24,5 @@ dependencies {\n   testCompile(group: 'org.springframework.cloud', name: 'spring-cloud-sleuth-core', version: '+') {\n     transitive = false\n   }\n+  testCompile group: 'io.opentelemetry', name: 'opentelemetry-contrib-auto-annotations', version: '+'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d7716614053f58eb5a33f238796def9aa2fcaa4"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzgxNTExOnYy", "diffSide": "RIGHT", "path": "instrumentation/trace-annotation/src/test/java/io/opentelemetry/test/annotation/TracedWithSpan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwMzoxNDowNFrOGRCtEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwMzoxNDowNFrOGRCtEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUyMzI4Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              @WithSpan()\n          \n          \n            \n              @WithSpan", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/379#discussion_r420523282", "createdAt": "2020-05-06T03:14:04Z", "author": {"login": "trask"}, "path": "instrumentation/trace-annotation/src/test/java/io/opentelemetry/test/annotation/TracedWithSpan.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.test.annotation;\n+\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.contrib.auto.annotations.WithSpan;\n+import io.opentelemetry.trace.Tracer;\n+\n+public class TracedWithSpan {\n+\n+  private static final Tracer TRACER =\n+      OpenTelemetry.getTracerProvider().get(\"io.opentelemetry.auto\");\n+\n+  @WithSpan()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee415edcf00ce82d589beca6023ff85b104066dd"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzgxODAzOnYy", "diffSide": "RIGHT", "path": "instrumentation/trace-annotation/src/test/groovy/WithSpanInstrumentationTest.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwMzoxNTo1N1rOGRCurQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwMzoxNTo1N1rOGRCurQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUyMzY5Mw==", "bodyText": "is this needed?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  System.clearProperty(\"ota.trace.annotations\")", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/379#discussion_r420523693", "createdAt": "2020-05-06T03:15:57Z", "author": {"login": "trask"}, "path": "instrumentation/trace-annotation/src/test/groovy/WithSpanInstrumentationTest.groovy", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+import io.opentelemetry.auto.test.AgentTestRunner\n+import io.opentelemetry.auto.test.utils.ConfigUtils\n+import io.opentelemetry.test.annotation.TracedWithSpan\n+\n+/**\n+ * This test verifies that auto-instr supports {@link io.opentelemetry.contrib.auto.annotations.WithSpan} contrib annotation.\n+ */\n+class WithSpanInstrumentationTest extends AgentTestRunner {\n+\n+  static {\n+    ConfigUtils.updateConfig {\n+      System.clearProperty(\"ota.trace.annotations\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee415edcf00ce82d589beca6023ff85b104066dd"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzgyMTA0OnYy", "diffSide": "RIGHT", "path": "instrumentation/trace-annotation/src/main/java/io/opentelemetry/auto/instrumentation/traceannotation/WithSpanAnnotationInstrumentation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwMzoxODoxMFrOGRCwYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwMzoxODoxMFrOGRCwYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUyNDEzMQ==", "bodyText": "unused\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Slf4j", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/379#discussion_r420524131", "createdAt": "2020-05-06T03:18:10Z", "author": {"login": "trask"}, "path": "instrumentation/trace-annotation/src/main/java/io/opentelemetry/auto/instrumentation/traceannotation/WithSpanAnnotationInstrumentation.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.auto.instrumentation.traceannotation;\n+\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.declaresMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.isAnnotatedWith;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.auto.tooling.Instrumenter;\n+import io.opentelemetry.contrib.auto.annotations.WithSpan;\n+import java.util.Map;\n+import lombok.extern.slf4j.Slf4j;\n+import net.bytebuddy.description.annotation.AnnotationSource;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+/**\n+ * Instrumentation for methods annotated with {@link\n+ * io.opentelemetry.contrib.auto.annotations.WithSpan} annotation. As that is Otel annotation, we\n+ * provide full support for all its attributes, as opposed to bare minimum functionality of {@link\n+ * TraceAnnotationsInstrumentation} for third party annotations.\n+ */\n+@Slf4j", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee415edcf00ce82d589beca6023ff85b104066dd"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzgyNTg2OnYy", "diffSide": "RIGHT", "path": "instrumentation/trace-annotation/src/main/java/io/opentelemetry/auto/instrumentation/traceannotation/WithSpanAnnotationInstrumentation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwMzoyMTo0MlrOGRCzIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwMzoyMTo0MlrOGRCzIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUyNDgzMg==", "bodyText": "\ud83d\udc4d this helped me understand why you didn't wedge this into the existing TraceAnnotationsInstrumentation. makes sense.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/379#discussion_r420524832", "createdAt": "2020-05-06T03:21:42Z", "author": {"login": "trask"}, "path": "instrumentation/trace-annotation/src/main/java/io/opentelemetry/auto/instrumentation/traceannotation/WithSpanAnnotationInstrumentation.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.auto.instrumentation.traceannotation;\n+\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.declaresMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.isAnnotatedWith;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.auto.tooling.Instrumenter;\n+import io.opentelemetry.contrib.auto.annotations.WithSpan;\n+import java.util.Map;\n+import lombok.extern.slf4j.Slf4j;\n+import net.bytebuddy.description.annotation.AnnotationSource;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+/**\n+ * Instrumentation for methods annotated with {@link\n+ * io.opentelemetry.contrib.auto.annotations.WithSpan} annotation. As that is Otel annotation, we\n+ * provide full support for all its attributes, as opposed to bare minimum functionality of {@link\n+ * TraceAnnotationsInstrumentation} for third party annotations.\n+ */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee415edcf00ce82d589beca6023ff85b104066dd"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzg0MDkxOnYy", "diffSide": "RIGHT", "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/BaseDecorator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwMzozMjowN1rOGRC7mQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwMzozMjowN1rOGRC7mQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUyNzAwMQ==", "bodyText": "I don't think we need this in BaseDecorator, maybe just (static) method in TraceDecorator?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/379#discussion_r420527001", "createdAt": "2020-05-06T03:32:07Z", "author": {"login": "trask"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/BaseDecorator.java", "diffHunk": "@@ -95,6 +96,21 @@ public String spanNameForMethod(final Method method) {\n     return spanNameForClass(method.getDeclaringClass()) + \".\" + method.getName();\n   }\n \n+  /**\n+   * This method is used to generate an acceptable span (operation) name based on a given method\n+   * reference. It first checks for existence of {@link WithSpan} annotation. If it is present, then\n+   * tries to derive name from its {@code value} attribute. Otherwise delegates to {@link\n+   * #spanNameForMethod(Method)}.\n+   */\n+  public String spanNameForMethodWithAnnotation(final Method method) {\n+    WithSpan annotation = method.getAnnotation(WithSpan.class);\n+    if (annotation != null && !annotation.value().isEmpty()) {\n+      return annotation.value();\n+    }\n+\n+    return spanNameForMethod(method);\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee415edcf00ce82d589beca6023ff85b104066dd"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzg1NzYxOnYy", "diffSide": "RIGHT", "path": "instrumentation/trace-annotation/src/main/java/io/opentelemetry/auto/instrumentation/traceannotation/WithSpanAnnotationInstrumentation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwMzo0Mzo0MFrOGRDFBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwMzo0Mzo0MFrOGRDFBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUyOTQxNA==", "bodyText": "for consistency with other instrumentation in this module (though probably worth revisit the convention in this module, and even the module name, but doesn't need to be in this PR)\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                super(\"api-contrib\");\n          \n          \n            \n                super(\"trace\", \"with-span-annotation\");", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/379#discussion_r420529414", "createdAt": "2020-05-06T03:43:40Z", "author": {"login": "trask"}, "path": "instrumentation/trace-annotation/src/main/java/io/opentelemetry/auto/instrumentation/traceannotation/WithSpanAnnotationInstrumentation.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.auto.instrumentation.traceannotation;\n+\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.declaresMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.isAnnotatedWith;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.auto.tooling.Instrumenter;\n+import io.opentelemetry.contrib.auto.annotations.WithSpan;\n+import java.util.Map;\n+import lombok.extern.slf4j.Slf4j;\n+import net.bytebuddy.description.annotation.AnnotationSource;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+/**\n+ * Instrumentation for methods annotated with {@link\n+ * io.opentelemetry.contrib.auto.annotations.WithSpan} annotation. As that is Otel annotation, we\n+ * provide full support for all its attributes, as opposed to bare minimum functionality of {@link\n+ * TraceAnnotationsInstrumentation} for third party annotations.\n+ */\n+@Slf4j\n+@AutoService(Instrumenter.class)\n+public final class WithSpanAnnotationInstrumentation extends Instrumenter.Default {\n+\n+  private final ElementMatcher.Junction<AnnotationSource> annotatedMethodMatcher;\n+\n+  public WithSpanAnnotationInstrumentation() {\n+    super(\"api-contrib\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee415edcf00ce82d589beca6023ff85b104066dd"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzg2MDE3OnYy", "diffSide": "RIGHT", "path": "instrumentation/trace-annotation/src/main/java/io/opentelemetry/auto/instrumentation/traceannotation/WithSpanAnnotationInstrumentation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwMzo0NTozMVrOGRDGcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMToxMTozN1rOGROKmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUyOTc3OQ==", "bodyText": "do we want to apply trace.methods.exclude here?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/379#discussion_r420529779", "createdAt": "2020-05-06T03:45:31Z", "author": {"login": "trask"}, "path": "instrumentation/trace-annotation/src/main/java/io/opentelemetry/auto/instrumentation/traceannotation/WithSpanAnnotationInstrumentation.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.auto.instrumentation.traceannotation;\n+\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.declaresMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.isAnnotatedWith;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.auto.tooling.Instrumenter;\n+import io.opentelemetry.contrib.auto.annotations.WithSpan;\n+import java.util.Map;\n+import lombok.extern.slf4j.Slf4j;\n+import net.bytebuddy.description.annotation.AnnotationSource;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+/**\n+ * Instrumentation for methods annotated with {@link\n+ * io.opentelemetry.contrib.auto.annotations.WithSpan} annotation. As that is Otel annotation, we\n+ * provide full support for all its attributes, as opposed to bare minimum functionality of {@link\n+ * TraceAnnotationsInstrumentation} for third party annotations.\n+ */\n+@Slf4j\n+@AutoService(Instrumenter.class)\n+public final class WithSpanAnnotationInstrumentation extends Instrumenter.Default {\n+\n+  private final ElementMatcher.Junction<AnnotationSource> annotatedMethodMatcher;\n+\n+  public WithSpanAnnotationInstrumentation() {\n+    super(\"api-contrib\");\n+    annotatedMethodMatcher = isAnnotatedWith(WithSpan.class);\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return declaresMethod(annotatedMethodMatcher);\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".TraceDecorator\",\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(annotatedMethodMatcher, packageName + \".WithSpanAdvice\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee415edcf00ce82d589beca6023ff85b104066dd"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcxMTA2Ng==", "bodyText": "Good catch, thank you! Will do", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/379#discussion_r420711066", "createdAt": "2020-05-06T11:11:37Z", "author": {"login": "iNikem"}, "path": "instrumentation/trace-annotation/src/main/java/io/opentelemetry/auto/instrumentation/traceannotation/WithSpanAnnotationInstrumentation.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.auto.instrumentation.traceannotation;\n+\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.declaresMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.isAnnotatedWith;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.auto.tooling.Instrumenter;\n+import io.opentelemetry.contrib.auto.annotations.WithSpan;\n+import java.util.Map;\n+import lombok.extern.slf4j.Slf4j;\n+import net.bytebuddy.description.annotation.AnnotationSource;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+/**\n+ * Instrumentation for methods annotated with {@link\n+ * io.opentelemetry.contrib.auto.annotations.WithSpan} annotation. As that is Otel annotation, we\n+ * provide full support for all its attributes, as opposed to bare minimum functionality of {@link\n+ * TraceAnnotationsInstrumentation} for third party annotations.\n+ */\n+@Slf4j\n+@AutoService(Instrumenter.class)\n+public final class WithSpanAnnotationInstrumentation extends Instrumenter.Default {\n+\n+  private final ElementMatcher.Junction<AnnotationSource> annotatedMethodMatcher;\n+\n+  public WithSpanAnnotationInstrumentation() {\n+    super(\"api-contrib\");\n+    annotatedMethodMatcher = isAnnotatedWith(WithSpan.class);\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return declaresMethod(annotatedMethodMatcher);\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".TraceDecorator\",\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(annotatedMethodMatcher, packageName + \".WithSpanAdvice\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUyOTc3OQ=="}, "originalCommit": {"oid": "ee415edcf00ce82d589beca6023ff85b104066dd"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxOTk0NjY0OnYy", "diffSide": "RIGHT", "path": "instrumentation/trace-annotation/src/main/java/io/opentelemetry/auto/instrumentation/traceannotation/TraceDecorator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNDo1NzozMlrOGRXNEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNTo0ODowNVrOGRZjyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg1OTE1NA==", "bodyText": "I think the cause of the muzzle failures is this method. I don't think the classloader that the advice classes are applied to has bytebuddy in it's classpath", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/379#discussion_r420859154", "createdAt": "2020-05-06T14:57:32Z", "author": {"login": "devinsba"}, "path": "instrumentation/trace-annotation/src/main/java/io/opentelemetry/auto/instrumentation/traceannotation/TraceDecorator.java", "diffHunk": "@@ -15,13 +15,66 @@\n  */\n package io.opentelemetry.auto.instrumentation.traceannotation;\n \n+import static net.bytebuddy.matcher.ElementMatchers.isDeclaredBy;\n+import static net.bytebuddy.matcher.ElementMatchers.none;\n+\n import io.opentelemetry.OpenTelemetry;\n import io.opentelemetry.auto.bootstrap.instrumentation.decorator.BaseDecorator;\n+import io.opentelemetry.auto.config.Config;\n+import io.opentelemetry.contrib.auto.annotations.WithSpan;\n import io.opentelemetry.trace.Tracer;\n+import java.lang.reflect.Method;\n+import java.util.Map;\n+import java.util.Set;\n+import net.bytebuddy.description.ByteCodeElement;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n \n public class TraceDecorator extends BaseDecorator {\n   public static final TraceDecorator DECORATE = new TraceDecorator();\n \n   public static final Tracer TRACER =\n       OpenTelemetry.getTracerProvider().get(\"io.opentelemetry.auto.trace-annotation\");\n+\n+  /**\n+   * This method is used to generate an acceptable span (operation) name based on a given method\n+   * reference. It first checks for existence of {@link WithSpan} annotation. If it is present, then\n+   * tries to derive name from its {@code value} attribute. Otherwise delegates to {@link\n+   * #spanNameForMethod(Method)}.\n+   */\n+  public String spanNameForMethodWithAnnotation(final Method method) {\n+    WithSpan annotation = method.getAnnotation(WithSpan.class);\n+    if (annotation != null && !annotation.value().isEmpty()) {\n+      return annotation.value();\n+    }\n+\n+    return spanNameForMethod(method);\n+  }\n+\n+  /*\n+  Returns a matcher for all methods that should be excluded from auto-instrumentation by\n+  annotation-based advices.\n+   */\n+  static ElementMatcher.Junction<MethodDescription> configureExcludedMethods() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98b29a6ddb0095821cd975d1afec5bdc744ca34a"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg1OTg0OQ==", "bodyText": "Looks like you moved it here from one of the Instrumenter classes, might want to make an abstract parent class if this is needed multiple places", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/379#discussion_r420859849", "createdAt": "2020-05-06T14:58:22Z", "author": {"login": "devinsba"}, "path": "instrumentation/trace-annotation/src/main/java/io/opentelemetry/auto/instrumentation/traceannotation/TraceDecorator.java", "diffHunk": "@@ -15,13 +15,66 @@\n  */\n package io.opentelemetry.auto.instrumentation.traceannotation;\n \n+import static net.bytebuddy.matcher.ElementMatchers.isDeclaredBy;\n+import static net.bytebuddy.matcher.ElementMatchers.none;\n+\n import io.opentelemetry.OpenTelemetry;\n import io.opentelemetry.auto.bootstrap.instrumentation.decorator.BaseDecorator;\n+import io.opentelemetry.auto.config.Config;\n+import io.opentelemetry.contrib.auto.annotations.WithSpan;\n import io.opentelemetry.trace.Tracer;\n+import java.lang.reflect.Method;\n+import java.util.Map;\n+import java.util.Set;\n+import net.bytebuddy.description.ByteCodeElement;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n \n public class TraceDecorator extends BaseDecorator {\n   public static final TraceDecorator DECORATE = new TraceDecorator();\n \n   public static final Tracer TRACER =\n       OpenTelemetry.getTracerProvider().get(\"io.opentelemetry.auto.trace-annotation\");\n+\n+  /**\n+   * This method is used to generate an acceptable span (operation) name based on a given method\n+   * reference. It first checks for existence of {@link WithSpan} annotation. If it is present, then\n+   * tries to derive name from its {@code value} attribute. Otherwise delegates to {@link\n+   * #spanNameForMethod(Method)}.\n+   */\n+  public String spanNameForMethodWithAnnotation(final Method method) {\n+    WithSpan annotation = method.getAnnotation(WithSpan.class);\n+    if (annotation != null && !annotation.value().isEmpty()) {\n+      return annotation.value();\n+    }\n+\n+    return spanNameForMethod(method);\n+  }\n+\n+  /*\n+  Returns a matcher for all methods that should be excluded from auto-instrumentation by\n+  annotation-based advices.\n+   */\n+  static ElementMatcher.Junction<MethodDescription> configureExcludedMethods() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg1OTE1NA=="}, "originalCommit": {"oid": "98b29a6ddb0095821cd975d1afec5bdc744ca34a"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg5NzczNg==", "bodyText": "Thanks!", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/379#discussion_r420897736", "createdAt": "2020-05-06T15:48:05Z", "author": {"login": "iNikem"}, "path": "instrumentation/trace-annotation/src/main/java/io/opentelemetry/auto/instrumentation/traceannotation/TraceDecorator.java", "diffHunk": "@@ -15,13 +15,66 @@\n  */\n package io.opentelemetry.auto.instrumentation.traceannotation;\n \n+import static net.bytebuddy.matcher.ElementMatchers.isDeclaredBy;\n+import static net.bytebuddy.matcher.ElementMatchers.none;\n+\n import io.opentelemetry.OpenTelemetry;\n import io.opentelemetry.auto.bootstrap.instrumentation.decorator.BaseDecorator;\n+import io.opentelemetry.auto.config.Config;\n+import io.opentelemetry.contrib.auto.annotations.WithSpan;\n import io.opentelemetry.trace.Tracer;\n+import java.lang.reflect.Method;\n+import java.util.Map;\n+import java.util.Set;\n+import net.bytebuddy.description.ByteCodeElement;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n \n public class TraceDecorator extends BaseDecorator {\n   public static final TraceDecorator DECORATE = new TraceDecorator();\n \n   public static final Tracer TRACER =\n       OpenTelemetry.getTracerProvider().get(\"io.opentelemetry.auto.trace-annotation\");\n+\n+  /**\n+   * This method is used to generate an acceptable span (operation) name based on a given method\n+   * reference. It first checks for existence of {@link WithSpan} annotation. If it is present, then\n+   * tries to derive name from its {@code value} attribute. Otherwise delegates to {@link\n+   * #spanNameForMethod(Method)}.\n+   */\n+  public String spanNameForMethodWithAnnotation(final Method method) {\n+    WithSpan annotation = method.getAnnotation(WithSpan.class);\n+    if (annotation != null && !annotation.value().isEmpty()) {\n+      return annotation.value();\n+    }\n+\n+    return spanNameForMethod(method);\n+  }\n+\n+  /*\n+  Returns a matcher for all methods that should be excluded from auto-instrumentation by\n+  annotation-based advices.\n+   */\n+  static ElementMatcher.Junction<MethodDescription> configureExcludedMethods() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg1OTE1NA=="}, "originalCommit": {"oid": "98b29a6ddb0095821cd975d1afec5bdc744ca34a"}, "originalPosition": 46}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 416, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}