{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg1MTMxNTMz", "number": 1193, "title": "Muzzle should fail on unimplemented abstract methods", "bodyText": "Resolves #1123", "createdAt": "2020-09-11T14:26:13Z", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1193", "merged": true, "mergeCommit": {"oid": "3d030288d2be39f69ce7dcda7036d3bcba859782"}, "closed": true, "closedAt": "2020-09-23T04:38:59Z", "author": {"login": "mateuszrzeszutek"}, "timelineItems": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdH3J_oABqjM3NTY4MDUxMDA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdLdzBrgFqTQ5MzgxMDYxMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f6e470584ffad1ed49b016debca82962a0afb054", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/f6e470584ffad1ed49b016debca82962a0afb054", "committedDate": "2020-09-11T14:24:35Z", "message": "Muzzle should fail on unimplemented abstract methods"}, "afterCommit": {"oid": "b8eed12c68ba2049cee8cff4ea317531bd490806", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/b8eed12c68ba2049cee8cff4ea317531bd490806", "committedDate": "2020-09-11T15:30:08Z", "message": "Muzzle should fail on unimplemented abstract methods"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b8eed12c68ba2049cee8cff4ea317531bd490806", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/b8eed12c68ba2049cee8cff4ea317531bd490806", "committedDate": "2020-09-11T15:30:08Z", "message": "Muzzle should fail on unimplemented abstract methods"}, "afterCommit": {"oid": "8cca70514ff33ccb91db9994916fdba540638866", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/8cca70514ff33ccb91db9994916fdba540638866", "committedDate": "2020-09-14T09:28:48Z", "message": "Muzzle should fail on unimplemented abstract methods"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8cca70514ff33ccb91db9994916fdba540638866", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/8cca70514ff33ccb91db9994916fdba540638866", "committedDate": "2020-09-14T09:28:48Z", "message": "Muzzle should fail on unimplemented abstract methods"}, "afterCommit": {"oid": "87db6c7e3ad73fc39ef6713c34f5a40af7fbaf17", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/87db6c7e3ad73fc39ef6713c34f5a40af7fbaf17", "committedDate": "2020-09-14T10:08:27Z", "message": "Muzzle should fail on unimplemented abstract methods"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "87db6c7e3ad73fc39ef6713c34f5a40af7fbaf17", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/87db6c7e3ad73fc39ef6713c34f5a40af7fbaf17", "committedDate": "2020-09-14T10:08:27Z", "message": "Muzzle should fail on unimplemented abstract methods"}, "afterCommit": {"oid": "1ec4b012f45945db1d4e6f96a4a24f71e5688dae", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/1ec4b012f45945db1d4e6f96a4a24f71e5688dae", "committedDate": "2020-09-14T11:39:44Z", "message": "Muzzle should fail on unimplemented abstract methods"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1ec4b012f45945db1d4e6f96a4a24f71e5688dae", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/1ec4b012f45945db1d4e6f96a4a24f71e5688dae", "committedDate": "2020-09-14T11:39:44Z", "message": "Muzzle should fail on unimplemented abstract methods"}, "afterCommit": {"oid": "42a90e6008cfa736b41cdf49f9c2e91ebba55234", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/42a90e6008cfa736b41cdf49f9c2e91ebba55234", "committedDate": "2020-09-15T12:37:16Z", "message": "Muzzle should fail on unimplemented abstract methods"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "42a90e6008cfa736b41cdf49f9c2e91ebba55234", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/42a90e6008cfa736b41cdf49f9c2e91ebba55234", "committedDate": "2020-09-15T12:37:16Z", "message": "Muzzle should fail on unimplemented abstract methods"}, "afterCommit": {"oid": "0adcc5d57fa957efb231de9c2e49cd4f29fe3c60", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/0adcc5d57fa957efb231de9c2e49cd4f29fe3c60", "committedDate": "2020-09-15T13:04:41Z", "message": "Muzzle should fail on unimplemented abstract methods"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0adcc5d57fa957efb231de9c2e49cd4f29fe3c60", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/0adcc5d57fa957efb231de9c2e49cd4f29fe3c60", "committedDate": "2020-09-15T13:04:41Z", "message": "Muzzle should fail on unimplemented abstract methods"}, "afterCommit": {"oid": "657025af32ff73b0e4c33968fb73aa131b07f57c", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/657025af32ff73b0e4c33968fb73aa131b07f57c", "committedDate": "2020-09-15T14:20:55Z", "message": "Muzzle should fail on unimplemented abstract methods"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "657025af32ff73b0e4c33968fb73aa131b07f57c", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/657025af32ff73b0e4c33968fb73aa131b07f57c", "committedDate": "2020-09-15T14:20:55Z", "message": "Muzzle should fail on unimplemented abstract methods"}, "afterCommit": {"oid": "55d1846d2d0875de04e4b4efbfb09f050a7536e5", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/55d1846d2d0875de04e4b4efbfb09f050a7536e5", "committedDate": "2020-09-15T14:35:15Z", "message": "Muzzle should fail on unimplemented abstract methods"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "55d1846d2d0875de04e4b4efbfb09f050a7536e5", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/55d1846d2d0875de04e4b4efbfb09f050a7536e5", "committedDate": "2020-09-15T14:35:15Z", "message": "Muzzle should fail on unimplemented abstract methods"}, "afterCommit": {"oid": "ec746b36a276ab931a3f4584b9265193bf259c09", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/ec746b36a276ab931a3f4584b9265193bf259c09", "committedDate": "2020-09-17T11:19:19Z", "message": "Muzzle should fail on unimplemented abstract methods"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b66d918b4efb05961bfe0cf8fdfc3ae7a8b12244", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/b66d918b4efb05961bfe0cf8fdfc3ae7a8b12244", "committedDate": "2020-09-17T12:37:43Z", "message": "Implement MDC auto-instrumentation for log4j2"}, "afterCommit": {"oid": "71ebbc31c0713c24cdf509e3f9715b9df4540527", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/71ebbc31c0713c24cdf509e3f9715b9df4540527", "committedDate": "2020-09-17T14:31:17Z", "message": "Implement MDC auto-instrumentation for log4j2"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "71ebbc31c0713c24cdf509e3f9715b9df4540527", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/71ebbc31c0713c24cdf509e3f9715b9df4540527", "committedDate": "2020-09-17T14:31:17Z", "message": "Implement MDC auto-instrumentation for log4j2"}, "afterCommit": {"oid": "b993119386f3630d3b0c602fa466184cbf54f95b", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/b993119386f3630d3b0c602fa466184cbf54f95b", "committedDate": "2020-09-17T15:24:20Z", "message": "Implement MDC auto-instrumentation for log4j2"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b993119386f3630d3b0c602fa466184cbf54f95b", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/b993119386f3630d3b0c602fa466184cbf54f95b", "committedDate": "2020-09-17T15:24:20Z", "message": "Implement MDC auto-instrumentation for log4j2"}, "afterCommit": {"oid": "00495e98a202468444180ea59d4152edd05450a8", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/00495e98a202468444180ea59d4152edd05450a8", "committedDate": "2020-09-17T16:06:39Z", "message": "Muzzle should fail on unimplemented abstract methods\n\nAdd references for super types and interfaces as well"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "00495e98a202468444180ea59d4152edd05450a8", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/00495e98a202468444180ea59d4152edd05450a8", "committedDate": "2020-09-17T16:06:39Z", "message": "Muzzle should fail on unimplemented abstract methods\n\nAdd references for super types and interfaces as well"}, "afterCommit": {"oid": "0ca0c3210c96b8c2ece6a28624dceefe23d53279", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/0ca0c3210c96b8c2ece6a28624dceefe23d53279", "committedDate": "2020-09-17T16:13:31Z", "message": "Muzzle should fail on unimplemented abstract methods\n\nAdd references for super types and interfaces as well"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0ca0c3210c96b8c2ece6a28624dceefe23d53279", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/0ca0c3210c96b8c2ece6a28624dceefe23d53279", "committedDate": "2020-09-17T16:13:31Z", "message": "Muzzle should fail on unimplemented abstract methods\n\nAdd references for super types and interfaces as well"}, "afterCommit": {"oid": "0123d3160403c64ce0858213707a15e34e272974", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/0123d3160403c64ce0858213707a15e34e272974", "committedDate": "2020-09-18T13:06:55Z", "message": "Muzzle should fail on unimplemented abstract methods"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0123d3160403c64ce0858213707a15e34e272974", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/0123d3160403c64ce0858213707a15e34e272974", "committedDate": "2020-09-18T13:06:55Z", "message": "Muzzle should fail on unimplemented abstract methods"}, "afterCommit": {"oid": "3e5d97ddd776626574b6374f5ae598e1d742e9c6", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/3e5d97ddd776626574b6374f5ae598e1d742e9c6", "committedDate": "2020-09-18T13:14:45Z", "message": "Muzzle should fail on unimplemented abstract methods"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3e5d97ddd776626574b6374f5ae598e1d742e9c6", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/3e5d97ddd776626574b6374f5ae598e1d742e9c6", "committedDate": "2020-09-18T13:14:45Z", "message": "Muzzle should fail on unimplemented abstract methods"}, "afterCommit": {"oid": "b8610f72b526b134c057167afdc87755aac49bdd", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/b8610f72b526b134c057167afdc87755aac49bdd", "committedDate": "2020-09-18T13:20:07Z", "message": "Muzzle should fail on unimplemented abstract methods"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b8610f72b526b134c057167afdc87755aac49bdd", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/b8610f72b526b134c057167afdc87755aac49bdd", "committedDate": "2020-09-18T13:20:07Z", "message": "Muzzle should fail on unimplemented abstract methods"}, "afterCommit": {"oid": "01e65e29437ef0e7dcea1d095e284d8ae10e0c4e", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/01e65e29437ef0e7dcea1d095e284d8ae10e0c4e", "committedDate": "2020-09-18T14:42:53Z", "message": "Muzzle should fail on unimplemented abstract methods"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "01e65e29437ef0e7dcea1d095e284d8ae10e0c4e", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/01e65e29437ef0e7dcea1d095e284d8ae10e0c4e", "committedDate": "2020-09-18T14:42:53Z", "message": "Muzzle should fail on unimplemented abstract methods"}, "afterCommit": {"oid": "173db14a4d19cd1a37a77d30163f96e5a3d7dddf", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/173db14a4d19cd1a37a77d30163f96e5a3d7dddf", "committedDate": "2020-09-18T14:58:30Z", "message": "Muzzle should fail on unimplemented abstract methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad9d1433c0817b5905db34c95a261d88f53351c9", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/ad9d1433c0817b5905db34c95a261d88f53351c9", "committedDate": "2020-09-18T15:33:26Z", "message": "Muzzle should fail on unimplemented abstract methods"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "173db14a4d19cd1a37a77d30163f96e5a3d7dddf", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/173db14a4d19cd1a37a77d30163f96e5a3d7dddf", "committedDate": "2020-09-18T14:58:30Z", "message": "Muzzle should fail on unimplemented abstract methods"}, "afterCommit": {"oid": "ad9d1433c0817b5905db34c95a261d88f53351c9", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/ad9d1433c0817b5905db34c95a261d88f53351c9", "committedDate": "2020-09-18T15:33:26Z", "message": "Muzzle should fail on unimplemented abstract methods"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyNTAzNTI4", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1193#pullrequestreview-492503528", "createdAt": "2020-09-21T11:32:00Z", "commit": {"oid": "ad9d1433c0817b5905db34c95a261d88f53351c9"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMTozMjowMVrOHVLgXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMTo0NzowMVrOHVL8Hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3MDY1NQ==", "bodyText": "Is private method overridable?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1193#discussion_r491970655", "createdAt": "2020-09-21T11:32:01Z", "author": {"login": "iNikem"}, "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/muzzle/HelperReferenceWrapper.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.javaagent.tooling.muzzle;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singleton;\n+import static net.bytebuddy.description.method.MethodDescription.CONSTRUCTOR_INTERNAL_NAME;\n+\n+import com.google.common.base.Function;\n+import com.google.common.base.Objects;\n+import com.google.common.base.Predicate;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Iterables;\n+import io.opentelemetry.javaagent.tooling.muzzle.Reference.Flag;\n+import java.util.Map;\n+import net.bytebuddy.description.method.MethodDescription.InDefinedShape;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.pool.TypePool;\n+import net.bytebuddy.pool.TypePool.Resolution;\n+\n+/** This class provides a common interface for {@link Reference} and {@link TypeDescription}. */\n+public interface HelperReferenceWrapper {\n+  boolean isAbstract();\n+\n+  /**\n+   * @return true if the wrapped type extends any class other than {@link Object} or implements any\n+   *     interface.\n+   */\n+  boolean hasSuperTypes();\n+\n+  /**\n+   * @return An iterable containing the wrapped type's super class (if exists) and implemented\n+   *     interfaces.\n+   */\n+  Iterable<HelperReferenceWrapper> getSuperTypes();\n+\n+  /** @return An iterable with all non-private, non-static methods declared in the wrapped type. */\n+  Iterable<Method> getMethods();\n+\n+  final class Method {\n+    private final boolean isAbstract;\n+    private final String declaringClass;\n+    private final String name;\n+    private final String descriptor;\n+\n+    public Method(boolean isAbstract, String declaringClass, String name, String descriptor) {\n+      this.isAbstract = isAbstract;\n+      this.declaringClass = declaringClass;\n+      this.name = name;\n+      this.descriptor = descriptor;\n+    }\n+\n+    public boolean isAbstract() {\n+      return isAbstract;\n+    }\n+\n+    public String getName() {\n+      return name;\n+    }\n+\n+    public String getDescriptor() {\n+      return descriptor;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) return true;\n+      if (o == null || getClass() != o.getClass()) return false;\n+      Method method = (Method) o;\n+      return Objects.equal(name, method.name) && Objects.equal(descriptor, method.descriptor);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hashCode(name, descriptor);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return declaringClass + \"#\" + name + descriptor;\n+    }\n+  }\n+\n+  class Factory {\n+    private final TypePool classpathPool;\n+    private final Map<String, Reference> helperReferences;\n+\n+    public Factory(TypePool classpathPool, Map<String, Reference> helperReferences) {\n+      this.classpathPool = classpathPool;\n+      this.helperReferences = helperReferences;\n+    }\n+\n+    public HelperReferenceWrapper create(Reference reference) {\n+      return new ReferenceType(reference);\n+    }\n+\n+    private HelperReferenceWrapper create(String className) {\n+      if (helperReferences.containsKey(className)) {\n+        return new ReferenceType(helperReferences.get(className));\n+      }\n+      Resolution resolution = classpathPool.describe(className);\n+      if (resolution.isResolved()) {\n+        return new ClasspathType(resolution.resolve());\n+      }\n+      throw new IllegalStateException(\"Missing class \" + className);\n+    }\n+\n+    private final class ReferenceType implements HelperReferenceWrapper {\n+      private final Reference reference;\n+\n+      private ReferenceType(Reference reference) {\n+        this.reference = reference;\n+      }\n+\n+      @Override\n+      public boolean isAbstract() {\n+        return reference.getFlags().contains(Flag.ABSTRACT);\n+      }\n+\n+      @Override\n+      public boolean hasSuperTypes() {\n+        return hasActualSuperType() || reference.getInterfaces().size() > 0;\n+      }\n+\n+      // Uses guava iterables to avoid unnecessary collection copying\n+      @Override\n+      public Iterable<HelperReferenceWrapper> getSuperTypes() {\n+        Iterable<HelperReferenceWrapper> superClass = emptyList();\n+        if (hasActualSuperType()) {\n+          superClass = singleton(Factory.this.create(reference.getSuperName()));\n+        }\n+\n+        Iterable<HelperReferenceWrapper> interfaces =\n+            FluentIterable.from(reference.getInterfaces()).transform(toWrapper());\n+\n+        return Iterables.concat(superClass, interfaces);\n+      }\n+\n+      private boolean hasActualSuperType() {\n+        return reference.getSuperName() != null\n+            && !reference.getSuperName().equals(Object.class.getName());\n+      }\n+\n+      private Function<String, HelperReferenceWrapper> toWrapper() {\n+        return new Function<String, HelperReferenceWrapper>() {\n+          @Override\n+          public HelperReferenceWrapper apply(String interfaceName) {\n+            return Factory.this.create(interfaceName);\n+          }\n+        };\n+      }\n+\n+      // Uses guava iterables to avoid unnecessary collection copying\n+      @Override\n+      public Iterable<Method> getMethods() {\n+        return FluentIterable.from(reference.getMethods())\n+            .filter(isOverrideable())\n+            .transform(toMethod());\n+      }\n+\n+      private Predicate<Reference.Method> isOverrideable() {\n+        return new Predicate<Reference.Method>() {\n+          @Override\n+          public boolean apply(Reference.Method input) {\n+            return !(input.getFlags().contains(Flag.STATIC)\n+                || input.getFlags().contains(Flag.PRIVATE_OR_HIGHER)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad9d1433c0817b5905db34c95a261d88f53351c9"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3MTgzNQ==", "bodyText": "Why this is not required any more?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1193#discussion_r491971835", "createdAt": "2020-09-21T11:34:36Z", "author": {"login": "iNikem"}, "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/muzzle/MuzzleVisitor.java", "diffHunk": "@@ -133,28 +133,18 @@ public MethodVisitor visitMethod(\n     }\n \n     public Reference[] generateReferences() {\n-      // track sources we've generated references from to avoid recursion", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad9d1433c0817b5905db34c95a261d88f53351c9"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3MzIzMw==", "bodyText": "Can you add javadoc to methods of Flag enum?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1193#discussion_r491973233", "createdAt": "2020-09-21T11:37:40Z", "author": {"login": "iNikem"}, "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/muzzle/Reference.java", "diffHunk": "@@ -363,25 +364,36 @@ public boolean matches(int asmFlags) {\n     NON_FINAL {\n       @Override\n       public boolean contradicts(Flag anotherFlag) {\n-        return anotherFlag == FINAL;\n+        return anotherFlag == FINAL || anotherFlag == ABSTRACT;\n       }\n \n       @Override\n       public boolean matches(int asmFlags) {\n-        return (Opcodes.ACC_FINAL & asmFlags) == 0;\n+        return ((Opcodes.ACC_ABSTRACT | Opcodes.ACC_FINAL) & asmFlags) == 0;\n       }\n     },\n     FINAL {\n       @Override\n       public boolean contradicts(Flag anotherFlag) {\n-        return anotherFlag == NON_FINAL;\n+        return anotherFlag == NON_FINAL || anotherFlag == ABSTRACT;\n       }\n \n       @Override\n       public boolean matches(int asmFlags) {\n         return (Opcodes.ACC_FINAL & asmFlags) != 0;\n       }\n     },\n+    ABSTRACT {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad9d1433c0817b5905db34c95a261d88f53351c9"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3NjQ1MA==", "bodyText": "Do we support abstract helpers?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1193#discussion_r491976450", "createdAt": "2020-09-21T11:44:32Z", "author": {"login": "iNikem"}, "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/muzzle/ReferenceMatcher.java", "diffHunk": "@@ -147,7 +157,64 @@ private boolean doesMatch(ClassLoader loader) {\n     }\n   }\n \n-  public static List<Reference.Mismatch> checkMatch(\n+  // for helper classes we make sure that all abstract methods from super classes and interfaces are\n+  // implemented\n+  private List<Reference.Mismatch> checkHelperClassMatch(Reference helperClass, TypePool typePool) {\n+    List<Mismatch> mismatches = Collections.emptyList();\n+\n+    HelperReferenceWrapper helperWrapper = new Factory(typePool, references).create(helperClass);\n+\n+    if (!helperWrapper.hasSuperTypes() || helperWrapper.isAbstract()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad9d1433c0817b5905db34c95a261d88f53351c9"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3Nzc1OQ==", "bodyText": "clone and finalize?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1193#discussion_r491977759", "createdAt": "2020-09-21T11:47:01Z", "author": {"login": "iNikem"}, "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/muzzle/ReferenceMatcher.java", "diffHunk": "@@ -147,7 +157,64 @@ private boolean doesMatch(ClassLoader loader) {\n     }\n   }\n \n-  public static List<Reference.Mismatch> checkMatch(\n+  // for helper classes we make sure that all abstract methods from super classes and interfaces are\n+  // implemented\n+  private List<Reference.Mismatch> checkHelperClassMatch(Reference helperClass, TypePool typePool) {\n+    List<Mismatch> mismatches = Collections.emptyList();\n+\n+    HelperReferenceWrapper helperWrapper = new Factory(typePool, references).create(helperClass);\n+\n+    if (!helperWrapper.hasSuperTypes() || helperWrapper.isAbstract()) {\n+      return mismatches;\n+    }\n+\n+    // treat the helper type as a bag of methods: collect all methods defined in the helper class,\n+    // all superclasses and interfaces and check if all abstract methods are implemented somewhere\n+    Set<HelperReferenceWrapper.Method> abstractMethods = new HashSet<>();\n+    Set<HelperReferenceWrapper.Method> plainMethods = new HashSet<>();\n+    collectMethodsFromTypeHierarchy(helperWrapper, abstractMethods, plainMethods);\n+\n+    Set<HelperReferenceWrapper.Method> unimplementedMethods =\n+        Sets.difference(abstractMethods, plainMethods);\n+    for (HelperReferenceWrapper.Method unimplementedMethod : unimplementedMethods) {\n+      mismatches =\n+          lazyAdd(\n+              mismatches,\n+              new Reference.Mismatch.MissingMethod(\n+                  helperClass.getSources().toArray(new Reference.Source[0]),\n+                  helperClass.getClassName(),\n+                  unimplementedMethod.toString()));\n+    }\n+\n+    return mismatches;\n+  }\n+\n+  private static void collectMethodsFromTypeHierarchy(\n+      HelperReferenceWrapper type, Set<Method> abstractMethods, Set<Method> plainMethods) {\n+\n+    for (HelperReferenceWrapper.Method method : type.getMethods()) {\n+      if (shouldIgnore(method)) {\n+        continue;\n+      }\n+      (method.isAbstract() ? abstractMethods : plainMethods).add(method);\n+    }\n+\n+    for (HelperReferenceWrapper superType : type.getSuperTypes()) {\n+      collectMethodsFromTypeHierarchy(superType, abstractMethods, plainMethods);\n+    }\n+  }\n+\n+  // ignore Object methods - sometimes defined by interfaces which causes them to be treated as\n+  // abstract\n+  private static boolean shouldIgnore(HelperReferenceWrapper.Method superMethod) {\n+    return \"hashCode\".equals(superMethod.getName()) && \"()I\".equals(superMethod.getDescriptor())\n+        || \"equals\".equals(superMethod.getName())\n+            && \"(Ljava/lang/Object;)Z\".equals(superMethod.getDescriptor())\n+        || \"toString\".equals(superMethod.getName())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad9d1433c0817b5905db34c95a261d88f53351c9"}, "originalPosition": 182}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff1833ce1d1a7557b613e1e24aa20d4bdd665606", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/ff1833ce1d1a7557b613e1e24aa20d4bdd665606", "committedDate": "2020-09-21T14:44:56Z", "message": "Muzzle should fail on unimplemented abstract methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c95fdfb040b140e8ebc70313694c5305074516b", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/1c95fdfb040b140e8ebc70313694c5305074516b", "committedDate": "2020-09-21T15:44:29Z", "message": "Muzzle should fail on unimplemented abstract methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dca390491bf5f52be3f3670b88622d95f0b48d78", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/dca390491bf5f52be3f3670b88622d95f0b48d78", "committedDate": "2020-09-21T16:32:22Z", "message": "Muzzle should fail on unimplemented abstract methods"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzMTE4NjE0", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1193#pullrequestreview-493118614", "createdAt": "2020-09-22T04:21:18Z", "commit": {"oid": "dca390491bf5f52be3f3670b88622d95f0b48d78"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwNDoyMzo0NlrOHVpzNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwNjoyNzo1MFrOHVrt1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ2Njk5Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return PUBLIC.matches(asmFlags) || PROTECTED.matches(asmFlags) || PACKAGE.matches(asmFlags);\n          \n          \n            \n                    return !PRIVATE.matches(asmFlags);", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1193#discussion_r492466997", "createdAt": "2020-09-22T04:23:46Z", "author": {"login": "trask"}, "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/muzzle/Reference.java", "diffHunk": "@@ -295,62 +296,63 @@ String getMismatchDetails() {\n \n     public static class MissingMethod extends Mismatch {\n       private final String className;\n-      private final String method;\n+      private final String methodSignature;\n \n-      public MissingMethod(Source[] sources, String className, String method) {\n+      public MissingMethod(Source[] sources, String className, String methodSignature) {\n         super(sources);\n         this.className = className;\n-        this.method = method;\n+        this.methodSignature = methodSignature;\n       }\n \n       @Override\n       String getMismatchDetails() {\n-        return \"Missing method \" + className + \"#\" + method;\n+        return \"Missing method \" + className + \"#\" + methodSignature;\n       }\n     }\n   }\n \n   /** Expected flag (or lack of flag) on a class, method, or field reference. */\n   public enum Flag {\n+    // The following constants represent the exact visibility of a referenced class/method\n     PUBLIC {\n       @Override\n-      public boolean supersedes(Flag anotherFlag) {\n-        switch (anotherFlag) {\n-          case PRIVATE_OR_HIGHER:\n-          case PROTECTED_OR_HIGHER:\n-          case PACKAGE_OR_HIGHER:\n-            return true;\n-          default:\n-            return false;\n-        }\n+      public boolean matches(int asmFlags) {\n+        return (Opcodes.ACC_PUBLIC & asmFlags) != 0;\n       }\n-\n+    },\n+    PROTECTED {\n       @Override\n       public boolean matches(int asmFlags) {\n-        return (Opcodes.ACC_PUBLIC & asmFlags) != 0;\n+        return (Opcodes.ACC_PROTECTED & asmFlags) != 0;\n       }\n     },\n-    PACKAGE_OR_HIGHER {\n+    PACKAGE {\n       @Override\n-      public boolean supersedes(Flag anotherFlag) {\n-        return anotherFlag == PRIVATE_OR_HIGHER;\n+      public boolean matches(int asmFlags) {\n+        return !(PUBLIC.matches(asmFlags)\n+            || PROTECTED.matches(asmFlags)\n+            || PRIVATE.matches(asmFlags));\n       }\n-\n+    },\n+    PRIVATE {\n       @Override\n       public boolean matches(int asmFlags) {\n-        return (Opcodes.ACC_PUBLIC & asmFlags) != 0\n-            || ((Opcodes.ACC_PRIVATE & asmFlags) == 0 && (Opcodes.ACC_PROTECTED & asmFlags) == 0);\n+        return (Opcodes.ACC_PRIVATE & asmFlags) != 0;\n       }\n     },\n+\n+    // The following constants represent a minimum access level required by a method call or field\n+    // access\n     PROTECTED_OR_HIGHER {\n       @Override\n-      public boolean supersedes(Flag anotherFlag) {\n-        return anotherFlag == PRIVATE_OR_HIGHER;\n+      public boolean matches(int asmFlags) {\n+        return PUBLIC.matches(asmFlags) || PROTECTED.matches(asmFlags);\n       }\n-\n+    },\n+    PACKAGE_OR_HIGHER {\n       @Override\n       public boolean matches(int asmFlags) {\n-        return PUBLIC.matches(asmFlags) || (Opcodes.ACC_PROTECTED & asmFlags) != 0;\n+        return PUBLIC.matches(asmFlags) || PROTECTED.matches(asmFlags) || PACKAGE.matches(asmFlags);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dca390491bf5f52be3f3670b88622d95f0b48d78"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ3MTk1NQ==", "bodyText": "Maybe we can split these grouping out into separate enums? e.g. ExactVisibilityFlag, MinVisibilityFlag, OwnershipFlag (for static?), ManifestationFlag (for abstract/final?)\nAnd then Reference.Method could have separate fields for the different enum types, and merging methods would hopefully make more sense, or at least the limitations of merging methods would be clearer, instead of current behavior of throwing all the flags into a big set during merging methods and hoping for the best \ud83d\ude02\n(doesn't need to be this PR)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1193#discussion_r492471955", "createdAt": "2020-09-22T04:47:34Z", "author": {"login": "trask"}, "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/muzzle/Reference.java", "diffHunk": "@@ -295,62 +296,63 @@ String getMismatchDetails() {\n \n     public static class MissingMethod extends Mismatch {\n       private final String className;\n-      private final String method;\n+      private final String methodSignature;\n \n-      public MissingMethod(Source[] sources, String className, String method) {\n+      public MissingMethod(Source[] sources, String className, String methodSignature) {\n         super(sources);\n         this.className = className;\n-        this.method = method;\n+        this.methodSignature = methodSignature;\n       }\n \n       @Override\n       String getMismatchDetails() {\n-        return \"Missing method \" + className + \"#\" + method;\n+        return \"Missing method \" + className + \"#\" + methodSignature;\n       }\n     }\n   }\n \n   /** Expected flag (or lack of flag) on a class, method, or field reference. */\n   public enum Flag {\n+    // The following constants represent the exact visibility of a referenced class/method", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dca390491bf5f52be3f3670b88622d95f0b48d78"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ4NTA0Mw==", "bodyText": "maybe a note about why the recursion ends before superName = java/lang/Object? (otherwise Object methods would get added to plainMethods above and this ignore method wouldn't be needed I think)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1193#discussion_r492485043", "createdAt": "2020-09-22T05:42:45Z", "author": {"login": "trask"}, "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/muzzle/ReferenceMatcher.java", "diffHunk": "@@ -147,7 +157,67 @@ private boolean doesMatch(ClassLoader loader) {\n     }\n   }\n \n-  public static List<Reference.Mismatch> checkMatch(\n+  // for helper classes we make sure that all abstract methods from super classes and interfaces are\n+  // implemented\n+  private List<Reference.Mismatch> checkHelperClassMatch(Reference helperClass, TypePool typePool) {\n+    List<Mismatch> mismatches = Collections.emptyList();\n+\n+    HelperReferenceWrapper helperWrapper = new Factory(typePool, references).create(helperClass);\n+\n+    if (!helperWrapper.hasSuperTypes() || helperWrapper.isAbstract()) {\n+      return mismatches;\n+    }\n+\n+    // treat the helper type as a bag of methods: collect all methods defined in the helper class,\n+    // all superclasses and interfaces and check if all abstract methods are implemented somewhere\n+    Set<HelperReferenceWrapper.Method> abstractMethods = new HashSet<>();\n+    Set<HelperReferenceWrapper.Method> plainMethods = new HashSet<>();\n+    collectMethodsFromTypeHierarchy(helperWrapper, abstractMethods, plainMethods);\n+\n+    Set<HelperReferenceWrapper.Method> unimplementedMethods =\n+        Sets.difference(abstractMethods, plainMethods);\n+    for (HelperReferenceWrapper.Method unimplementedMethod : unimplementedMethods) {\n+      mismatches =\n+          lazyAdd(\n+              mismatches,\n+              new Reference.Mismatch.MissingMethod(\n+                  helperClass.getSources().toArray(new Reference.Source[0]),\n+                  helperClass.getClassName(),\n+                  unimplementedMethod.toString()));\n+    }\n+\n+    return mismatches;\n+  }\n+\n+  private static void collectMethodsFromTypeHierarchy(\n+      HelperReferenceWrapper type, Set<Method> abstractMethods, Set<Method> plainMethods) {\n+\n+    for (HelperReferenceWrapper.Method method : type.getMethods()) {\n+      if (shouldIgnore(method)) {\n+        continue;\n+      }\n+      (method.isAbstract() ? abstractMethods : plainMethods).add(method);\n+    }\n+\n+    for (HelperReferenceWrapper superType : type.getSuperTypes()) {\n+      collectMethodsFromTypeHierarchy(superType, abstractMethods, plainMethods);\n+    }\n+  }\n+\n+  // ignore Object methods - sometimes defined by interfaces which causes them to be treated as\n+  // abstract", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dca390491bf5f52be3f3670b88622d95f0b48d78"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ4NjM4MA==", "bodyText": "see similar comment below, and add extra field to MissingMethod\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                              unimplementedMethod.toString()));\n          \n          \n            \n                              unimplementedMethod.getName(), unimplementedMethod.getDescriptor()));", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1193#discussion_r492486380", "createdAt": "2020-09-22T05:47:32Z", "author": {"login": "trask"}, "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/muzzle/ReferenceMatcher.java", "diffHunk": "@@ -147,7 +157,67 @@ private boolean doesMatch(ClassLoader loader) {\n     }\n   }\n \n-  public static List<Reference.Mismatch> checkMatch(\n+  // for helper classes we make sure that all abstract methods from super classes and interfaces are\n+  // implemented\n+  private List<Reference.Mismatch> checkHelperClassMatch(Reference helperClass, TypePool typePool) {\n+    List<Mismatch> mismatches = Collections.emptyList();\n+\n+    HelperReferenceWrapper helperWrapper = new Factory(typePool, references).create(helperClass);\n+\n+    if (!helperWrapper.hasSuperTypes() || helperWrapper.isAbstract()) {\n+      return mismatches;\n+    }\n+\n+    // treat the helper type as a bag of methods: collect all methods defined in the helper class,\n+    // all superclasses and interfaces and check if all abstract methods are implemented somewhere\n+    Set<HelperReferenceWrapper.Method> abstractMethods = new HashSet<>();\n+    Set<HelperReferenceWrapper.Method> plainMethods = new HashSet<>();\n+    collectMethodsFromTypeHierarchy(helperWrapper, abstractMethods, plainMethods);\n+\n+    Set<HelperReferenceWrapper.Method> unimplementedMethods =\n+        Sets.difference(abstractMethods, plainMethods);\n+    for (HelperReferenceWrapper.Method unimplementedMethod : unimplementedMethods) {\n+      mismatches =\n+          lazyAdd(\n+              mismatches,\n+              new Reference.Mismatch.MissingMethod(\n+                  helperClass.getSources().toArray(new Reference.Source[0]),\n+                  helperClass.getClassName(),\n+                  unimplementedMethod.toString()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dca390491bf5f52be3f3670b88622d95f0b48d78"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ4NjQ1MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                methodRef.getName() + methodRef.getDescriptor()));\n          \n          \n            \n                                methodRef.getName(), methodRef.getDescriptor()));", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1193#discussion_r492486450", "createdAt": "2020-09-22T05:47:48Z", "author": {"login": "trask"}, "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/muzzle/ReferenceMatcher.java", "diffHunk": "@@ -205,8 +275,8 @@ private boolean doesMatch(ClassLoader loader) {\n                 mismatches,\n                 new Reference.Mismatch.MissingMethod(\n                     methodRef.getSources().toArray(new Reference.Source[0]),\n-                    methodRef.getName(),\n-                    methodRef.getDescriptor()));\n+                    reference.getClassName(),\n+                    methodRef.getName() + methodRef.getDescriptor()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dca390491bf5f52be3f3670b88622d95f0b48d78"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ5ODM5MA==", "bodyText": "maybe as an optimization here, don't generate method references for private methods,  or  since they can't implement an abstract method", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1193#discussion_r492498390", "createdAt": "2020-09-22T06:27:50Z", "author": {"login": "trask"}, "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/muzzle/ReferenceCreator.java", "diffHunk": "@@ -244,12 +253,68 @@ public FieldVisitor visitField(\n   @Override\n   public MethodVisitor visitMethod(\n       int access, String name, String descriptor, String signature, String[] exceptions) {\n+\n+    // declared method references are not generated for advice classes, only for helper classes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dca390491bf5f52be3f3670b88622d95f0b48d78"}, "originalPosition": 156}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7df71f3e42dfe935c2dd98161f6ef52e7fc10650", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/7df71f3e42dfe935c2dd98161f6ef52e7fc10650", "committedDate": "2020-09-22T08:42:07Z", "message": "Update javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/muzzle/Reference.java\n\nCo-authored-by: Trask Stalnaker <trask.stalnaker@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "91597cdd95baf922776dce1774887c9232399147", "author": {"user": {"login": "mateuszrzeszutek", "name": "Mateusz Rzeszutek"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/91597cdd95baf922776dce1774887c9232399147", "committedDate": "2020-09-22T10:00:51Z", "message": "Muzzle should fail on unimplemented abstract methods"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNjg0OTk1", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1193#pullrequestreview-493684995", "createdAt": "2020-09-22T17:20:43Z", "commit": {"oid": "91597cdd95baf922776dce1774887c9232399147"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzODEwNjEy", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1193#pullrequestreview-493810612", "createdAt": "2020-09-22T20:13:23Z", "commit": {"oid": "91597cdd95baf922776dce1774887c9232399147"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2589, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}