{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA0OTQ3NzA5", "number": 1405, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjowNDo0MVrOEumBXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxODoyODowM1rOEvcyww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MjkyODk1OnYy", "diffSide": "RIGHT", "path": "instrumentation/lettuce/lettuce-5.1/src/main/java/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/RedisCommandNormalizer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjowNDo0MVrOHjGzZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNjoxMDozNlrOHjHBEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU3MzY3MA==", "bodyText": "This class can be reused by other Redis libraries' instrumentations; I'll move it to some common package (javaagent-api?) in next PR and call it whenever args are available. Currently lettuce 5.1 is the only Redis lib instrumentation that logs actual statement, not just the bare command.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r506573670", "createdAt": "2020-10-16T16:04:41Z", "author": {"login": "mateuszrzeszutek"}, "path": "instrumentation/lettuce/lettuce-5.1/src/main/java/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/RedisCommandNormalizer.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.lettuce.v5_1;\n+\n+import static java.util.Collections.unmodifiableMap;\n+\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.CommandAndNumArgs;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.Default;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.Eval;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.MultiKeyValue;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/** This class is responsible for masking potentially sensitive data in Redis commands. */\n+public final class RedisCommandNormalizer {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0f943b7d163f3e7dd981f282bc41f56269d0b7d"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU3NzE3MQ==", "bodyText": "#1406", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r506577171", "createdAt": "2020-10-16T16:10:36Z", "author": {"login": "mateuszrzeszutek"}, "path": "instrumentation/lettuce/lettuce-5.1/src/main/java/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/RedisCommandNormalizer.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.lettuce.v5_1;\n+\n+import static java.util.Collections.unmodifiableMap;\n+\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.CommandAndNumArgs;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.Default;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.Eval;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.MultiKeyValue;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/** This class is responsible for masking potentially sensitive data in Redis commands. */\n+public final class RedisCommandNormalizer {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU3MzY3MA=="}, "originalCommit": {"oid": "d0f943b7d163f3e7dd981f282bc41f56269d0b7d"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3Mzk3OTM1OnYy", "diffSide": "RIGHT", "path": "instrumentation/lettuce/lettuce-5.1/src/main/java/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/RedisCommandNormalizer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQyMTo1ODo0NVrOHjQ5fA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxMzoxMjoxNVrOHkNmAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjczOTA2OA==", "bodyText": "should the default be keepZeroArgs (same as AUTH) to be on the safe side (e.g. for future commands we don't know about yet)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r506739068", "createdAt": "2020-10-16T21:58:45Z", "author": {"login": "trask"}, "path": "instrumentation/lettuce/lettuce-5.1/src/main/java/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/RedisCommandNormalizer.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.lettuce.v5_1;\n+\n+import static java.util.Collections.unmodifiableMap;\n+\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.CommandAndNumArgs;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.Default;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.Eval;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.MultiKeyValue;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/** This class is responsible for masking potentially sensitive data in Redis commands. */\n+public final class RedisCommandNormalizer {\n+\n+  private static final Map<String, CommandNormalizer> NORMALIZERS;\n+\n+  static {\n+    Map<String, CommandNormalizer> normalizers = new HashMap<>();\n+\n+    CommandNormalizer keepOneArg = new CommandAndNumArgs(1);\n+    CommandNormalizer keepTwoArgs = new CommandAndNumArgs(2);\n+    CommandNormalizer setMultiHashField = new MultiKeyValue(1);\n+    CommandNormalizer setMultiField = new MultiKeyValue(0);\n+\n+    // Connection\n+    // can contain AUTH data\n+    normalizers.put(\"AUTH\", new CommandAndNumArgs(0));\n+    normalizers.put(\"HELLO\", keepTwoArgs);\n+\n+    // Hashes\n+    normalizers.put(\"HMSET\", setMultiHashField);\n+    normalizers.put(\"HSET\", setMultiHashField);\n+    normalizers.put(\"HSETNX\", keepTwoArgs);\n+\n+    // HyperLogLog\n+    normalizers.put(\"PFADD\", keepOneArg);\n+\n+    // Keys\n+    // can contain AUTH data\n+    normalizers.put(\"MIGRATE\", new CommandAndNumArgs(6));\n+\n+    // Lists\n+    normalizers.put(\"LINSERT\", keepTwoArgs);\n+    normalizers.put(\"LPOS\", keepOneArg);\n+    normalizers.put(\"LPUSH\", keepOneArg);\n+    normalizers.put(\"LPUSHX\", keepOneArg);\n+    normalizers.put(\"LREM\", keepOneArg);\n+    normalizers.put(\"LSET\", keepOneArg);\n+    normalizers.put(\"RPUSH\", keepOneArg);\n+    normalizers.put(\"RPUSHX\", keepOneArg);\n+\n+    // Pub/Sub\n+    normalizers.put(\"PUBLISH\", keepOneArg);\n+\n+    // Scripting\n+    normalizers.put(\"EVAL\", Eval.INSTANCE);\n+    normalizers.put(\"EVALSHA\", Eval.INSTANCE);\n+\n+    // Sets\n+    normalizers.put(\"SADD\", keepOneArg);\n+    normalizers.put(\"SISMEMBER\", keepOneArg);\n+    normalizers.put(\"SMISMEMBER\", keepOneArg);\n+    normalizers.put(\"SMOVE\", keepTwoArgs);\n+    normalizers.put(\"SREM\", keepOneArg);\n+\n+    // Sorted Sets\n+    normalizers.put(\"ZADD\", keepOneArg);\n+    normalizers.put(\"ZCOUNT\", keepOneArg);\n+    normalizers.put(\"ZINCRBY\", keepOneArg);\n+    normalizers.put(\"ZLEXCOUNT\", keepOneArg);\n+    normalizers.put(\"ZMSCORE\", keepOneArg);\n+    normalizers.put(\"ZRANGEBYLEX\", keepOneArg);\n+    normalizers.put(\"ZRANGEBYSCORE\", keepOneArg);\n+    normalizers.put(\"ZRANK\", keepOneArg);\n+    normalizers.put(\"ZREM\", keepOneArg);\n+    normalizers.put(\"ZREMRANGEBYLEX\", keepOneArg);\n+    normalizers.put(\"ZREMRANGEBYSCORE\", keepOneArg);\n+    normalizers.put(\"ZREVRANGEBYLEX\", keepOneArg);\n+    normalizers.put(\"ZREVRANGEBYSCORE\", keepOneArg);\n+    normalizers.put(\"ZREVRANK\", keepOneArg);\n+    normalizers.put(\"ZSCORE\", keepOneArg);\n+\n+    // Streams\n+    normalizers.put(\"XADD\", new MultiKeyValue(2));\n+\n+    // Strings\n+    normalizers.put(\"APPEND\", keepOneArg);\n+    normalizers.put(\"GETSET\", keepOneArg);\n+    normalizers.put(\"MSET\", setMultiField);\n+    normalizers.put(\"MSETNX\", setMultiField);\n+    normalizers.put(\"PSETEX\", keepTwoArgs);\n+    normalizers.put(\"SET\", keepOneArg);\n+    normalizers.put(\"SETEX\", keepTwoArgs);\n+    normalizers.put(\"SETNX\", keepOneArg);\n+    normalizers.put(\"SETRANGE\", keepOneArg);\n+\n+    NORMALIZERS = unmodifiableMap(normalizers);\n+  }\n+\n+  public static String normalize(String command, List<String> args) {\n+    return NORMALIZERS\n+        .getOrDefault(command.toUpperCase(), Default.INSTANCE)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0f943b7d163f3e7dd981f282bc41f56269d0b7d"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzczMzUwNQ==", "bodyText": "That's a very good idea - done.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r507733505", "createdAt": "2020-10-19T13:12:15Z", "author": {"login": "mateuszrzeszutek"}, "path": "instrumentation/lettuce/lettuce-5.1/src/main/java/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/RedisCommandNormalizer.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.lettuce.v5_1;\n+\n+import static java.util.Collections.unmodifiableMap;\n+\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.CommandAndNumArgs;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.Default;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.Eval;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.MultiKeyValue;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/** This class is responsible for masking potentially sensitive data in Redis commands. */\n+public final class RedisCommandNormalizer {\n+\n+  private static final Map<String, CommandNormalizer> NORMALIZERS;\n+\n+  static {\n+    Map<String, CommandNormalizer> normalizers = new HashMap<>();\n+\n+    CommandNormalizer keepOneArg = new CommandAndNumArgs(1);\n+    CommandNormalizer keepTwoArgs = new CommandAndNumArgs(2);\n+    CommandNormalizer setMultiHashField = new MultiKeyValue(1);\n+    CommandNormalizer setMultiField = new MultiKeyValue(0);\n+\n+    // Connection\n+    // can contain AUTH data\n+    normalizers.put(\"AUTH\", new CommandAndNumArgs(0));\n+    normalizers.put(\"HELLO\", keepTwoArgs);\n+\n+    // Hashes\n+    normalizers.put(\"HMSET\", setMultiHashField);\n+    normalizers.put(\"HSET\", setMultiHashField);\n+    normalizers.put(\"HSETNX\", keepTwoArgs);\n+\n+    // HyperLogLog\n+    normalizers.put(\"PFADD\", keepOneArg);\n+\n+    // Keys\n+    // can contain AUTH data\n+    normalizers.put(\"MIGRATE\", new CommandAndNumArgs(6));\n+\n+    // Lists\n+    normalizers.put(\"LINSERT\", keepTwoArgs);\n+    normalizers.put(\"LPOS\", keepOneArg);\n+    normalizers.put(\"LPUSH\", keepOneArg);\n+    normalizers.put(\"LPUSHX\", keepOneArg);\n+    normalizers.put(\"LREM\", keepOneArg);\n+    normalizers.put(\"LSET\", keepOneArg);\n+    normalizers.put(\"RPUSH\", keepOneArg);\n+    normalizers.put(\"RPUSHX\", keepOneArg);\n+\n+    // Pub/Sub\n+    normalizers.put(\"PUBLISH\", keepOneArg);\n+\n+    // Scripting\n+    normalizers.put(\"EVAL\", Eval.INSTANCE);\n+    normalizers.put(\"EVALSHA\", Eval.INSTANCE);\n+\n+    // Sets\n+    normalizers.put(\"SADD\", keepOneArg);\n+    normalizers.put(\"SISMEMBER\", keepOneArg);\n+    normalizers.put(\"SMISMEMBER\", keepOneArg);\n+    normalizers.put(\"SMOVE\", keepTwoArgs);\n+    normalizers.put(\"SREM\", keepOneArg);\n+\n+    // Sorted Sets\n+    normalizers.put(\"ZADD\", keepOneArg);\n+    normalizers.put(\"ZCOUNT\", keepOneArg);\n+    normalizers.put(\"ZINCRBY\", keepOneArg);\n+    normalizers.put(\"ZLEXCOUNT\", keepOneArg);\n+    normalizers.put(\"ZMSCORE\", keepOneArg);\n+    normalizers.put(\"ZRANGEBYLEX\", keepOneArg);\n+    normalizers.put(\"ZRANGEBYSCORE\", keepOneArg);\n+    normalizers.put(\"ZRANK\", keepOneArg);\n+    normalizers.put(\"ZREM\", keepOneArg);\n+    normalizers.put(\"ZREMRANGEBYLEX\", keepOneArg);\n+    normalizers.put(\"ZREMRANGEBYSCORE\", keepOneArg);\n+    normalizers.put(\"ZREVRANGEBYLEX\", keepOneArg);\n+    normalizers.put(\"ZREVRANGEBYSCORE\", keepOneArg);\n+    normalizers.put(\"ZREVRANK\", keepOneArg);\n+    normalizers.put(\"ZSCORE\", keepOneArg);\n+\n+    // Streams\n+    normalizers.put(\"XADD\", new MultiKeyValue(2));\n+\n+    // Strings\n+    normalizers.put(\"APPEND\", keepOneArg);\n+    normalizers.put(\"GETSET\", keepOneArg);\n+    normalizers.put(\"MSET\", setMultiField);\n+    normalizers.put(\"MSETNX\", setMultiField);\n+    normalizers.put(\"PSETEX\", keepTwoArgs);\n+    normalizers.put(\"SET\", keepOneArg);\n+    normalizers.put(\"SETEX\", keepTwoArgs);\n+    normalizers.put(\"SETNX\", keepOneArg);\n+    normalizers.put(\"SETRANGE\", keepOneArg);\n+\n+    NORMALIZERS = unmodifiableMap(normalizers);\n+  }\n+\n+  public static String normalize(String command, List<String> args) {\n+    return NORMALIZERS\n+        .getOrDefault(command.toUpperCase(), Default.INSTANCE)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjczOTA2OA=="}, "originalCommit": {"oid": "d0f943b7d163f3e7dd981f282bc41f56269d0b7d"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3Mzk5MzcwOnYy", "diffSide": "RIGHT", "path": "instrumentation/lettuce/lettuce-5.1/src/main/java/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/RedisCommandNormalizer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQyMjowNTo0MFrOHjRBlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQyMjowNTo0MFrOHjRBlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc0MTE0Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      normalised.append(\" \").append(\"?\");\n          \n          \n            \n                      normalised.append(\" ?\");", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r506741143", "createdAt": "2020-10-16T22:05:40Z", "author": {"login": "trask"}, "path": "instrumentation/lettuce/lettuce-5.1/src/main/java/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/RedisCommandNormalizer.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.lettuce.v5_1;\n+\n+import static java.util.Collections.unmodifiableMap;\n+\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.CommandAndNumArgs;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.Default;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.Eval;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.MultiKeyValue;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/** This class is responsible for masking potentially sensitive data in Redis commands. */\n+public final class RedisCommandNormalizer {\n+\n+  private static final Map<String, CommandNormalizer> NORMALIZERS;\n+\n+  static {\n+    Map<String, CommandNormalizer> normalizers = new HashMap<>();\n+\n+    CommandNormalizer keepOneArg = new CommandAndNumArgs(1);\n+    CommandNormalizer keepTwoArgs = new CommandAndNumArgs(2);\n+    CommandNormalizer setMultiHashField = new MultiKeyValue(1);\n+    CommandNormalizer setMultiField = new MultiKeyValue(0);\n+\n+    // Connection\n+    // can contain AUTH data\n+    normalizers.put(\"AUTH\", new CommandAndNumArgs(0));\n+    normalizers.put(\"HELLO\", keepTwoArgs);\n+\n+    // Hashes\n+    normalizers.put(\"HMSET\", setMultiHashField);\n+    normalizers.put(\"HSET\", setMultiHashField);\n+    normalizers.put(\"HSETNX\", keepTwoArgs);\n+\n+    // HyperLogLog\n+    normalizers.put(\"PFADD\", keepOneArg);\n+\n+    // Keys\n+    // can contain AUTH data\n+    normalizers.put(\"MIGRATE\", new CommandAndNumArgs(6));\n+\n+    // Lists\n+    normalizers.put(\"LINSERT\", keepTwoArgs);\n+    normalizers.put(\"LPOS\", keepOneArg);\n+    normalizers.put(\"LPUSH\", keepOneArg);\n+    normalizers.put(\"LPUSHX\", keepOneArg);\n+    normalizers.put(\"LREM\", keepOneArg);\n+    normalizers.put(\"LSET\", keepOneArg);\n+    normalizers.put(\"RPUSH\", keepOneArg);\n+    normalizers.put(\"RPUSHX\", keepOneArg);\n+\n+    // Pub/Sub\n+    normalizers.put(\"PUBLISH\", keepOneArg);\n+\n+    // Scripting\n+    normalizers.put(\"EVAL\", Eval.INSTANCE);\n+    normalizers.put(\"EVALSHA\", Eval.INSTANCE);\n+\n+    // Sets\n+    normalizers.put(\"SADD\", keepOneArg);\n+    normalizers.put(\"SISMEMBER\", keepOneArg);\n+    normalizers.put(\"SMISMEMBER\", keepOneArg);\n+    normalizers.put(\"SMOVE\", keepTwoArgs);\n+    normalizers.put(\"SREM\", keepOneArg);\n+\n+    // Sorted Sets\n+    normalizers.put(\"ZADD\", keepOneArg);\n+    normalizers.put(\"ZCOUNT\", keepOneArg);\n+    normalizers.put(\"ZINCRBY\", keepOneArg);\n+    normalizers.put(\"ZLEXCOUNT\", keepOneArg);\n+    normalizers.put(\"ZMSCORE\", keepOneArg);\n+    normalizers.put(\"ZRANGEBYLEX\", keepOneArg);\n+    normalizers.put(\"ZRANGEBYSCORE\", keepOneArg);\n+    normalizers.put(\"ZRANK\", keepOneArg);\n+    normalizers.put(\"ZREM\", keepOneArg);\n+    normalizers.put(\"ZREMRANGEBYLEX\", keepOneArg);\n+    normalizers.put(\"ZREMRANGEBYSCORE\", keepOneArg);\n+    normalizers.put(\"ZREVRANGEBYLEX\", keepOneArg);\n+    normalizers.put(\"ZREVRANGEBYSCORE\", keepOneArg);\n+    normalizers.put(\"ZREVRANK\", keepOneArg);\n+    normalizers.put(\"ZSCORE\", keepOneArg);\n+\n+    // Streams\n+    normalizers.put(\"XADD\", new MultiKeyValue(2));\n+\n+    // Strings\n+    normalizers.put(\"APPEND\", keepOneArg);\n+    normalizers.put(\"GETSET\", keepOneArg);\n+    normalizers.put(\"MSET\", setMultiField);\n+    normalizers.put(\"MSETNX\", setMultiField);\n+    normalizers.put(\"PSETEX\", keepTwoArgs);\n+    normalizers.put(\"SET\", keepOneArg);\n+    normalizers.put(\"SETEX\", keepTwoArgs);\n+    normalizers.put(\"SETNX\", keepOneArg);\n+    normalizers.put(\"SETRANGE\", keepOneArg);\n+\n+    NORMALIZERS = unmodifiableMap(normalizers);\n+  }\n+\n+  public static String normalize(String command, List<String> args) {\n+    return NORMALIZERS\n+        .getOrDefault(command.toUpperCase(), Default.INSTANCE)\n+        .normalize(command, args);\n+  }\n+\n+  public interface CommandNormalizer {\n+    String normalize(String command, List<String> args);\n+\n+    enum Default implements CommandNormalizer {\n+      INSTANCE;\n+\n+      @Override\n+      public String normalize(String command, List<String> args) {\n+        StringBuilder normalised = new StringBuilder(command);\n+        for (String arg : args) {\n+          normalised.append(\" \").append(arg);\n+        }\n+        return normalised.toString();\n+      }\n+    }\n+\n+    class CommandAndNumArgs implements CommandNormalizer {\n+      private final int numOfArgsToKeep;\n+\n+      public CommandAndNumArgs(int numOfArgsToKeep) {\n+        this.numOfArgsToKeep = numOfArgsToKeep;\n+      }\n+\n+      @Override\n+      public String normalize(String command, List<String> args) {\n+        StringBuilder normalised = new StringBuilder(command);\n+        int i = 0;\n+        for (; i < numOfArgsToKeep && i < args.size(); ++i) {\n+          normalised.append(\" \").append(args.get(i));\n+        }\n+        for (; i < args.size(); ++i) {\n+          normalised.append(\" \").append(\"?\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0f943b7d163f3e7dd981f282bc41f56269d0b7d"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3Mzk5NDkwOnYy", "diffSide": "RIGHT", "path": "instrumentation/lettuce/lettuce-5.1/src/main/java/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/RedisCommandNormalizer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQyMjowNjoyMFrOHjRCVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQyMjowNjoyMFrOHjRCVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc0MTMzNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      normalised.append(\" \").append(\"?\");\n          \n          \n            \n                      normalised.append(\" ?\");", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r506741335", "createdAt": "2020-10-16T22:06:20Z", "author": {"login": "trask"}, "path": "instrumentation/lettuce/lettuce-5.1/src/main/java/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/RedisCommandNormalizer.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.lettuce.v5_1;\n+\n+import static java.util.Collections.unmodifiableMap;\n+\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.CommandAndNumArgs;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.Default;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.Eval;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.MultiKeyValue;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/** This class is responsible for masking potentially sensitive data in Redis commands. */\n+public final class RedisCommandNormalizer {\n+\n+  private static final Map<String, CommandNormalizer> NORMALIZERS;\n+\n+  static {\n+    Map<String, CommandNormalizer> normalizers = new HashMap<>();\n+\n+    CommandNormalizer keepOneArg = new CommandAndNumArgs(1);\n+    CommandNormalizer keepTwoArgs = new CommandAndNumArgs(2);\n+    CommandNormalizer setMultiHashField = new MultiKeyValue(1);\n+    CommandNormalizer setMultiField = new MultiKeyValue(0);\n+\n+    // Connection\n+    // can contain AUTH data\n+    normalizers.put(\"AUTH\", new CommandAndNumArgs(0));\n+    normalizers.put(\"HELLO\", keepTwoArgs);\n+\n+    // Hashes\n+    normalizers.put(\"HMSET\", setMultiHashField);\n+    normalizers.put(\"HSET\", setMultiHashField);\n+    normalizers.put(\"HSETNX\", keepTwoArgs);\n+\n+    // HyperLogLog\n+    normalizers.put(\"PFADD\", keepOneArg);\n+\n+    // Keys\n+    // can contain AUTH data\n+    normalizers.put(\"MIGRATE\", new CommandAndNumArgs(6));\n+\n+    // Lists\n+    normalizers.put(\"LINSERT\", keepTwoArgs);\n+    normalizers.put(\"LPOS\", keepOneArg);\n+    normalizers.put(\"LPUSH\", keepOneArg);\n+    normalizers.put(\"LPUSHX\", keepOneArg);\n+    normalizers.put(\"LREM\", keepOneArg);\n+    normalizers.put(\"LSET\", keepOneArg);\n+    normalizers.put(\"RPUSH\", keepOneArg);\n+    normalizers.put(\"RPUSHX\", keepOneArg);\n+\n+    // Pub/Sub\n+    normalizers.put(\"PUBLISH\", keepOneArg);\n+\n+    // Scripting\n+    normalizers.put(\"EVAL\", Eval.INSTANCE);\n+    normalizers.put(\"EVALSHA\", Eval.INSTANCE);\n+\n+    // Sets\n+    normalizers.put(\"SADD\", keepOneArg);\n+    normalizers.put(\"SISMEMBER\", keepOneArg);\n+    normalizers.put(\"SMISMEMBER\", keepOneArg);\n+    normalizers.put(\"SMOVE\", keepTwoArgs);\n+    normalizers.put(\"SREM\", keepOneArg);\n+\n+    // Sorted Sets\n+    normalizers.put(\"ZADD\", keepOneArg);\n+    normalizers.put(\"ZCOUNT\", keepOneArg);\n+    normalizers.put(\"ZINCRBY\", keepOneArg);\n+    normalizers.put(\"ZLEXCOUNT\", keepOneArg);\n+    normalizers.put(\"ZMSCORE\", keepOneArg);\n+    normalizers.put(\"ZRANGEBYLEX\", keepOneArg);\n+    normalizers.put(\"ZRANGEBYSCORE\", keepOneArg);\n+    normalizers.put(\"ZRANK\", keepOneArg);\n+    normalizers.put(\"ZREM\", keepOneArg);\n+    normalizers.put(\"ZREMRANGEBYLEX\", keepOneArg);\n+    normalizers.put(\"ZREMRANGEBYSCORE\", keepOneArg);\n+    normalizers.put(\"ZREVRANGEBYLEX\", keepOneArg);\n+    normalizers.put(\"ZREVRANGEBYSCORE\", keepOneArg);\n+    normalizers.put(\"ZREVRANK\", keepOneArg);\n+    normalizers.put(\"ZSCORE\", keepOneArg);\n+\n+    // Streams\n+    normalizers.put(\"XADD\", new MultiKeyValue(2));\n+\n+    // Strings\n+    normalizers.put(\"APPEND\", keepOneArg);\n+    normalizers.put(\"GETSET\", keepOneArg);\n+    normalizers.put(\"MSET\", setMultiField);\n+    normalizers.put(\"MSETNX\", setMultiField);\n+    normalizers.put(\"PSETEX\", keepTwoArgs);\n+    normalizers.put(\"SET\", keepOneArg);\n+    normalizers.put(\"SETEX\", keepTwoArgs);\n+    normalizers.put(\"SETNX\", keepOneArg);\n+    normalizers.put(\"SETRANGE\", keepOneArg);\n+\n+    NORMALIZERS = unmodifiableMap(normalizers);\n+  }\n+\n+  public static String normalize(String command, List<String> args) {\n+    return NORMALIZERS\n+        .getOrDefault(command.toUpperCase(), Default.INSTANCE)\n+        .normalize(command, args);\n+  }\n+\n+  public interface CommandNormalizer {\n+    String normalize(String command, List<String> args);\n+\n+    enum Default implements CommandNormalizer {\n+      INSTANCE;\n+\n+      @Override\n+      public String normalize(String command, List<String> args) {\n+        StringBuilder normalised = new StringBuilder(command);\n+        for (String arg : args) {\n+          normalised.append(\" \").append(arg);\n+        }\n+        return normalised.toString();\n+      }\n+    }\n+\n+    class CommandAndNumArgs implements CommandNormalizer {\n+      private final int numOfArgsToKeep;\n+\n+      public CommandAndNumArgs(int numOfArgsToKeep) {\n+        this.numOfArgsToKeep = numOfArgsToKeep;\n+      }\n+\n+      @Override\n+      public String normalize(String command, List<String> args) {\n+        StringBuilder normalised = new StringBuilder(command);\n+        int i = 0;\n+        for (; i < numOfArgsToKeep && i < args.size(); ++i) {\n+          normalised.append(\" \").append(args.get(i));\n+        }\n+        for (; i < args.size(); ++i) {\n+          normalised.append(\" \").append(\"?\");\n+        }\n+        return normalised.toString();\n+      }\n+    }\n+\n+    class MultiKeyValue implements CommandNormalizer {\n+      private final int numOfArgsBeforeKeyValue;\n+\n+      public MultiKeyValue(int numOfArgsBeforeKeyValue) {\n+        this.numOfArgsBeforeKeyValue = numOfArgsBeforeKeyValue;\n+      }\n+\n+      @Override\n+      public String normalize(String command, List<String> args) {\n+        StringBuilder normalised = new StringBuilder(command);\n+        int i = 0;\n+        // append all \"initial\" arguments before key-value pairs start\n+        for (; i < numOfArgsBeforeKeyValue && i < args.size(); ++i) {\n+          normalised.append(\" \").append(args.get(i));\n+        }\n+\n+        // whether keys are on even or odd index depends on the number of initial args\n+        int keys = numOfArgsBeforeKeyValue % 2;\n+        for (; i < args.size(); ++i) {\n+          normalised\n+              .append(\" \")\n+              // append only keys, skip values\n+              .append(i % 2 == keys ? args.get(i) : \"?\");\n+        }\n+        return normalised.toString();\n+      }\n+    }\n+\n+    enum Eval implements CommandNormalizer {\n+      INSTANCE;\n+\n+      @Override\n+      public String normalize(String command, List<String> args) {\n+        StringBuilder normalised = new StringBuilder(command);\n+\n+        // get the number of keys passed from the command itself (second arg)\n+        int numberOfKeys = 0;\n+        if (args.size() > 2) {\n+          try {\n+            numberOfKeys = Integer.parseInt(args.get(1));\n+          } catch (NumberFormatException ignored) {\n+          }\n+        }\n+\n+        int i = 0;\n+        // log the script, number of keys and all keys\n+        for (; i < (numberOfKeys + 2) && i < args.size(); ++i) {\n+          normalised.append(\" \").append(args.get(i));\n+        }\n+        // mask the rest\n+        for (; i < args.size(); ++i) {\n+          normalised.append(\" \").append(\"?\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0f943b7d163f3e7dd981f282bc41f56269d0b7d"}, "originalPosition": 200}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDAwOTYwOnYy", "diffSide": "RIGHT", "path": "instrumentation/lettuce/lettuce-5.1/src/main/java/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/OpenTelemetryTracing.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQyMjoxMzo1N1rOHjRK3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQyMjoxMzo1N1rOHjRK3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc0MzUxOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  int end = 0;\n          \n          \n            \n                  int lastEnd = 0;", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r506743519", "createdAt": "2020-10-16T22:13:57Z", "author": {"login": "trask"}, "path": "instrumentation/lettuce/lettuce-5.1/src/main/java/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/OpenTelemetryTracing.java", "diffHunk": "@@ -249,50 +252,44 @@ public OpenTelemetrySpan nextSpan(TraceContext traceContext) {\n     public synchronized void finish() {\n       if (span != null) {\n         if (name != null) {\n-          String statement =\n-              (args != null && !args.isEmpty()) && !name.equals(\"AUTH\") ? name + \" \" + args : name;\n+          String statement = RedisCommandNormalizer.normalize(name, splitArgs());\n           span.setAttribute(SemanticAttributes.DB_STATEMENT, statement);\n         }\n         span.end();\n       }\n     }\n \n-    private static void fillEndpoint(Span.Builder span, OpenTelemetryEndpoint endpoint) {\n-      span.setAttribute(SemanticAttributes.NET_TRANSPORT, \"IP.TCP\");\n-      span.setAttribute(SemanticAttributes.NET_PEER_IP, endpoint.ip);\n-\n-      StringBuilder redisUrl = new StringBuilder(\"redis://\");\n+    private static final Pattern KEY_PATTERN = Pattern.compile(\"(?<wrappedKey>key<(?<key>[^>]+)>)\");\n \n-      if (endpoint.name != null) {\n-        span.setAttribute(SemanticAttributes.NET_PEER_NAME, endpoint.name);\n-        redisUrl.append(endpoint.name);\n-      } else {\n-        redisUrl.append(endpoint.ip);\n+    // this method removes the key<...> wrapper around redis keys and splits the args string\n+    private List<String> splitArgs() {\n+      if (args == null || args.isEmpty()) {\n+        return Collections.emptyList();\n       }\n \n-      if (endpoint.port != 0) {\n-        span.setAttribute(SemanticAttributes.NET_PEER_PORT, (long) endpoint.port);\n-        redisUrl.append(\":\").append(endpoint.port);\n+      StringBuilder newArgs = new StringBuilder(args.length());\n+\n+      Matcher m = KEY_PATTERN.matcher(args);\n+      int end = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0f943b7d163f3e7dd981f282bc41f56269d0b7d"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDAxNjcyOnYy", "diffSide": "RIGHT", "path": "instrumentation/lettuce/lettuce-5.1/src/main/java/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/OpenTelemetryTracing.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQyMjoxNzozMlrOHjRPCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQyMjoxNzozMlrOHjRPCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc0NDU4NQ==", "bodyText": "I'm not sure the wrappedKey named grouping helps readability here\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    int wrapperStart = m.start(\"wrappedKey\");\n          \n          \n            \n            \n          \n          \n            \n                    newArgs.append(args, end, wrapperStart).append(m.group(\"key\"));\n          \n          \n            \n            \n          \n          \n            \n                    end = m.end(\"wrappedKey\");\n          \n          \n            \n                    int start = m.start();\n          \n          \n            \n            \n          \n          \n            \n                    newArgs.append(args, lastEnd, start).append(m.group(\"key\"));\n          \n          \n            \n            \n          \n          \n            \n                    lastEnd = m.end();", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r506744585", "createdAt": "2020-10-16T22:17:32Z", "author": {"login": "trask"}, "path": "instrumentation/lettuce/lettuce-5.1/src/main/java/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/OpenTelemetryTracing.java", "diffHunk": "@@ -249,50 +252,44 @@ public OpenTelemetrySpan nextSpan(TraceContext traceContext) {\n     public synchronized void finish() {\n       if (span != null) {\n         if (name != null) {\n-          String statement =\n-              (args != null && !args.isEmpty()) && !name.equals(\"AUTH\") ? name + \" \" + args : name;\n+          String statement = RedisCommandNormalizer.normalize(name, splitArgs());\n           span.setAttribute(SemanticAttributes.DB_STATEMENT, statement);\n         }\n         span.end();\n       }\n     }\n \n-    private static void fillEndpoint(Span.Builder span, OpenTelemetryEndpoint endpoint) {\n-      span.setAttribute(SemanticAttributes.NET_TRANSPORT, \"IP.TCP\");\n-      span.setAttribute(SemanticAttributes.NET_PEER_IP, endpoint.ip);\n-\n-      StringBuilder redisUrl = new StringBuilder(\"redis://\");\n+    private static final Pattern KEY_PATTERN = Pattern.compile(\"(?<wrappedKey>key<(?<key>[^>]+)>)\");\n \n-      if (endpoint.name != null) {\n-        span.setAttribute(SemanticAttributes.NET_PEER_NAME, endpoint.name);\n-        redisUrl.append(endpoint.name);\n-      } else {\n-        redisUrl.append(endpoint.ip);\n+    // this method removes the key<...> wrapper around redis keys and splits the args string\n+    private List<String> splitArgs() {\n+      if (args == null || args.isEmpty()) {\n+        return Collections.emptyList();\n       }\n \n-      if (endpoint.port != 0) {\n-        span.setAttribute(SemanticAttributes.NET_PEER_PORT, (long) endpoint.port);\n-        redisUrl.append(\":\").append(endpoint.port);\n+      StringBuilder newArgs = new StringBuilder(args.length());\n+\n+      Matcher m = KEY_PATTERN.matcher(args);\n+      int end = 0;\n+      while (m.find()) {\n+        int wrapperStart = m.start(\"wrappedKey\");\n+\n+        newArgs.append(args, end, wrapperStart).append(m.group(\"key\"));\n+\n+        end = m.end(\"wrappedKey\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0f943b7d163f3e7dd981f282bc41f56269d0b7d"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDAzNTc2OnYy", "diffSide": "RIGHT", "path": "instrumentation/lettuce/lettuce-5.1/src/main/java/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/OpenTelemetryTracing.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQyMjoyNzo0MVrOHjRaEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxMDoxOTo0M1rOHkHjOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc0NzQxMA==", "bodyText": "instead of appending and then splitting, does it help if we build the list directly as we iterate above?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r506747410", "createdAt": "2020-10-16T22:27:41Z", "author": {"login": "trask"}, "path": "instrumentation/lettuce/lettuce-5.1/src/main/java/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/OpenTelemetryTracing.java", "diffHunk": "@@ -249,50 +252,44 @@ public OpenTelemetrySpan nextSpan(TraceContext traceContext) {\n     public synchronized void finish() {\n       if (span != null) {\n         if (name != null) {\n-          String statement =\n-              (args != null && !args.isEmpty()) && !name.equals(\"AUTH\") ? name + \" \" + args : name;\n+          String statement = RedisCommandNormalizer.normalize(name, splitArgs());\n           span.setAttribute(SemanticAttributes.DB_STATEMENT, statement);\n         }\n         span.end();\n       }\n     }\n \n-    private static void fillEndpoint(Span.Builder span, OpenTelemetryEndpoint endpoint) {\n-      span.setAttribute(SemanticAttributes.NET_TRANSPORT, \"IP.TCP\");\n-      span.setAttribute(SemanticAttributes.NET_PEER_IP, endpoint.ip);\n-\n-      StringBuilder redisUrl = new StringBuilder(\"redis://\");\n+    private static final Pattern KEY_PATTERN = Pattern.compile(\"(?<wrappedKey>key<(?<key>[^>]+)>)\");\n \n-      if (endpoint.name != null) {\n-        span.setAttribute(SemanticAttributes.NET_PEER_NAME, endpoint.name);\n-        redisUrl.append(endpoint.name);\n-      } else {\n-        redisUrl.append(endpoint.ip);\n+    // this method removes the key<...> wrapper around redis keys and splits the args string\n+    private List<String> splitArgs() {\n+      if (args == null || args.isEmpty()) {\n+        return Collections.emptyList();\n       }\n \n-      if (endpoint.port != 0) {\n-        span.setAttribute(SemanticAttributes.NET_PEER_PORT, (long) endpoint.port);\n-        redisUrl.append(\":\").append(endpoint.port);\n+      StringBuilder newArgs = new StringBuilder(args.length());\n+\n+      Matcher m = KEY_PATTERN.matcher(args);\n+      int end = 0;\n+      while (m.find()) {\n+        int wrapperStart = m.start(\"wrappedKey\");\n+\n+        newArgs.append(args, end, wrapperStart).append(m.group(\"key\"));\n+\n+        end = m.end(\"wrappedKey\");\n       }\n+      newArgs.append(args, end, args.length());\n \n-      span.setAttribute(SemanticAttributes.DB_CONNECTION_STRING, redisUrl.toString());\n+      return asList(newArgs.toString().split(\" \"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0f943b7d163f3e7dd981f282bc41f56269d0b7d"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzYzNDQ5MQ==", "bodyText": "Hmm, that'll be a bit more complicated but certainly doable.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r507634491", "createdAt": "2020-10-19T10:19:43Z", "author": {"login": "mateuszrzeszutek"}, "path": "instrumentation/lettuce/lettuce-5.1/src/main/java/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/OpenTelemetryTracing.java", "diffHunk": "@@ -249,50 +252,44 @@ public OpenTelemetrySpan nextSpan(TraceContext traceContext) {\n     public synchronized void finish() {\n       if (span != null) {\n         if (name != null) {\n-          String statement =\n-              (args != null && !args.isEmpty()) && !name.equals(\"AUTH\") ? name + \" \" + args : name;\n+          String statement = RedisCommandNormalizer.normalize(name, splitArgs());\n           span.setAttribute(SemanticAttributes.DB_STATEMENT, statement);\n         }\n         span.end();\n       }\n     }\n \n-    private static void fillEndpoint(Span.Builder span, OpenTelemetryEndpoint endpoint) {\n-      span.setAttribute(SemanticAttributes.NET_TRANSPORT, \"IP.TCP\");\n-      span.setAttribute(SemanticAttributes.NET_PEER_IP, endpoint.ip);\n-\n-      StringBuilder redisUrl = new StringBuilder(\"redis://\");\n+    private static final Pattern KEY_PATTERN = Pattern.compile(\"(?<wrappedKey>key<(?<key>[^>]+)>)\");\n \n-      if (endpoint.name != null) {\n-        span.setAttribute(SemanticAttributes.NET_PEER_NAME, endpoint.name);\n-        redisUrl.append(endpoint.name);\n-      } else {\n-        redisUrl.append(endpoint.ip);\n+    // this method removes the key<...> wrapper around redis keys and splits the args string\n+    private List<String> splitArgs() {\n+      if (args == null || args.isEmpty()) {\n+        return Collections.emptyList();\n       }\n \n-      if (endpoint.port != 0) {\n-        span.setAttribute(SemanticAttributes.NET_PEER_PORT, (long) endpoint.port);\n-        redisUrl.append(\":\").append(endpoint.port);\n+      StringBuilder newArgs = new StringBuilder(args.length());\n+\n+      Matcher m = KEY_PATTERN.matcher(args);\n+      int end = 0;\n+      while (m.find()) {\n+        int wrapperStart = m.start(\"wrappedKey\");\n+\n+        newArgs.append(args, end, wrapperStart).append(m.group(\"key\"));\n+\n+        end = m.end(\"wrappedKey\");\n       }\n+      newArgs.append(args, end, args.length());\n \n-      span.setAttribute(SemanticAttributes.DB_CONNECTION_STRING, redisUrl.toString());\n+      return asList(newArgs.toString().split(\" \"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc0NzQxMA=="}, "originalCommit": {"oid": "d0f943b7d163f3e7dd981f282bc41f56269d0b7d"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDAzNzU5OnYy", "diffSide": "RIGHT", "path": "instrumentation-api/src/main/java/io/opentelemetry/instrumentation/api/tracer/utils/NetPeerUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQyMjoyODo1NFrOHjRbLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQyMjoyODo1NFrOHjRbLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc0NzY5NQ==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r506747695", "createdAt": "2020-10-16T22:28:54Z", "author": {"login": "trask"}, "path": "instrumentation-api/src/main/java/io/opentelemetry/instrumentation/api/tracer/utils/NetPeerUtils.java", "diffHunk": "@@ -81,4 +88,12 @@ private static String mapToPeer(String endpoint) {\n \n     return ENDPOINT_PEER_SERVICE_MAPPING.get(endpoint);\n   }\n+\n+  /**\n+   * This helper interface allows setting attributes on both {@link Span} and {@link Span.Builder}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0f943b7d163f3e7dd981f282bc41f56269d0b7d"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDA0NjcyOnYy", "diffSide": "RIGHT", "path": "instrumentation/lettuce/lettuce-5.1/src/main/java/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/RedisCommandNormalizer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQyMjozNDowN1rOHjRggg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxMDowNToyMVrOHkHDBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc0OTA1OA==", "bodyText": "took me a while to understand the parity matching, I think something like this would be easier to read\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // whether keys are on even or odd index depends on the number of initial args\n          \n          \n            \n                    int keys = numOfArgsBeforeKeyValue % 2;\n          \n          \n            \n                    for (; i < args.size(); ++i) {\n          \n          \n            \n                      normalised\n          \n          \n            \n                          .append(\" \")\n          \n          \n            \n                          // append only keys, skip values\n          \n          \n            \n                          .append(i % 2 == keys ? args.get(i) : \"?\");\n          \n          \n            \n                    }\n          \n          \n            \n                    // loop over keys only\n          \n          \n            \n                    for (i = numOfArgsBeforeKeyValue; i < args.size(); i += 2) {\n          \n          \n            \n                      normalised\n          \n          \n            \n                          .append(\" \")\n          \n          \n            \n                          .append(args.get(i))\n          \n          \n            \n                          .append(\" ?\");\n          \n          \n            \n                    }", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r506749058", "createdAt": "2020-10-16T22:34:07Z", "author": {"login": "trask"}, "path": "instrumentation/lettuce/lettuce-5.1/src/main/java/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/RedisCommandNormalizer.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.lettuce.v5_1;\n+\n+import static java.util.Collections.unmodifiableMap;\n+\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.CommandAndNumArgs;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.Default;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.Eval;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.MultiKeyValue;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/** This class is responsible for masking potentially sensitive data in Redis commands. */\n+public final class RedisCommandNormalizer {\n+\n+  private static final Map<String, CommandNormalizer> NORMALIZERS;\n+\n+  static {\n+    Map<String, CommandNormalizer> normalizers = new HashMap<>();\n+\n+    CommandNormalizer keepOneArg = new CommandAndNumArgs(1);\n+    CommandNormalizer keepTwoArgs = new CommandAndNumArgs(2);\n+    CommandNormalizer setMultiHashField = new MultiKeyValue(1);\n+    CommandNormalizer setMultiField = new MultiKeyValue(0);\n+\n+    // Connection\n+    // can contain AUTH data\n+    normalizers.put(\"AUTH\", new CommandAndNumArgs(0));\n+    normalizers.put(\"HELLO\", keepTwoArgs);\n+\n+    // Hashes\n+    normalizers.put(\"HMSET\", setMultiHashField);\n+    normalizers.put(\"HSET\", setMultiHashField);\n+    normalizers.put(\"HSETNX\", keepTwoArgs);\n+\n+    // HyperLogLog\n+    normalizers.put(\"PFADD\", keepOneArg);\n+\n+    // Keys\n+    // can contain AUTH data\n+    normalizers.put(\"MIGRATE\", new CommandAndNumArgs(6));\n+\n+    // Lists\n+    normalizers.put(\"LINSERT\", keepTwoArgs);\n+    normalizers.put(\"LPOS\", keepOneArg);\n+    normalizers.put(\"LPUSH\", keepOneArg);\n+    normalizers.put(\"LPUSHX\", keepOneArg);\n+    normalizers.put(\"LREM\", keepOneArg);\n+    normalizers.put(\"LSET\", keepOneArg);\n+    normalizers.put(\"RPUSH\", keepOneArg);\n+    normalizers.put(\"RPUSHX\", keepOneArg);\n+\n+    // Pub/Sub\n+    normalizers.put(\"PUBLISH\", keepOneArg);\n+\n+    // Scripting\n+    normalizers.put(\"EVAL\", Eval.INSTANCE);\n+    normalizers.put(\"EVALSHA\", Eval.INSTANCE);\n+\n+    // Sets\n+    normalizers.put(\"SADD\", keepOneArg);\n+    normalizers.put(\"SISMEMBER\", keepOneArg);\n+    normalizers.put(\"SMISMEMBER\", keepOneArg);\n+    normalizers.put(\"SMOVE\", keepTwoArgs);\n+    normalizers.put(\"SREM\", keepOneArg);\n+\n+    // Sorted Sets\n+    normalizers.put(\"ZADD\", keepOneArg);\n+    normalizers.put(\"ZCOUNT\", keepOneArg);\n+    normalizers.put(\"ZINCRBY\", keepOneArg);\n+    normalizers.put(\"ZLEXCOUNT\", keepOneArg);\n+    normalizers.put(\"ZMSCORE\", keepOneArg);\n+    normalizers.put(\"ZRANGEBYLEX\", keepOneArg);\n+    normalizers.put(\"ZRANGEBYSCORE\", keepOneArg);\n+    normalizers.put(\"ZRANK\", keepOneArg);\n+    normalizers.put(\"ZREM\", keepOneArg);\n+    normalizers.put(\"ZREMRANGEBYLEX\", keepOneArg);\n+    normalizers.put(\"ZREMRANGEBYSCORE\", keepOneArg);\n+    normalizers.put(\"ZREVRANGEBYLEX\", keepOneArg);\n+    normalizers.put(\"ZREVRANGEBYSCORE\", keepOneArg);\n+    normalizers.put(\"ZREVRANK\", keepOneArg);\n+    normalizers.put(\"ZSCORE\", keepOneArg);\n+\n+    // Streams\n+    normalizers.put(\"XADD\", new MultiKeyValue(2));\n+\n+    // Strings\n+    normalizers.put(\"APPEND\", keepOneArg);\n+    normalizers.put(\"GETSET\", keepOneArg);\n+    normalizers.put(\"MSET\", setMultiField);\n+    normalizers.put(\"MSETNX\", setMultiField);\n+    normalizers.put(\"PSETEX\", keepTwoArgs);\n+    normalizers.put(\"SET\", keepOneArg);\n+    normalizers.put(\"SETEX\", keepTwoArgs);\n+    normalizers.put(\"SETNX\", keepOneArg);\n+    normalizers.put(\"SETRANGE\", keepOneArg);\n+\n+    NORMALIZERS = unmodifiableMap(normalizers);\n+  }\n+\n+  public static String normalize(String command, List<String> args) {\n+    return NORMALIZERS\n+        .getOrDefault(command.toUpperCase(), Default.INSTANCE)\n+        .normalize(command, args);\n+  }\n+\n+  public interface CommandNormalizer {\n+    String normalize(String command, List<String> args);\n+\n+    enum Default implements CommandNormalizer {\n+      INSTANCE;\n+\n+      @Override\n+      public String normalize(String command, List<String> args) {\n+        StringBuilder normalised = new StringBuilder(command);\n+        for (String arg : args) {\n+          normalised.append(\" \").append(arg);\n+        }\n+        return normalised.toString();\n+      }\n+    }\n+\n+    class CommandAndNumArgs implements CommandNormalizer {\n+      private final int numOfArgsToKeep;\n+\n+      public CommandAndNumArgs(int numOfArgsToKeep) {\n+        this.numOfArgsToKeep = numOfArgsToKeep;\n+      }\n+\n+      @Override\n+      public String normalize(String command, List<String> args) {\n+        StringBuilder normalised = new StringBuilder(command);\n+        int i = 0;\n+        for (; i < numOfArgsToKeep && i < args.size(); ++i) {\n+          normalised.append(\" \").append(args.get(i));\n+        }\n+        for (; i < args.size(); ++i) {\n+          normalised.append(\" \").append(\"?\");\n+        }\n+        return normalised.toString();\n+      }\n+    }\n+\n+    class MultiKeyValue implements CommandNormalizer {\n+      private final int numOfArgsBeforeKeyValue;\n+\n+      public MultiKeyValue(int numOfArgsBeforeKeyValue) {\n+        this.numOfArgsBeforeKeyValue = numOfArgsBeforeKeyValue;\n+      }\n+\n+      @Override\n+      public String normalize(String command, List<String> args) {\n+        StringBuilder normalised = new StringBuilder(command);\n+        int i = 0;\n+        // append all \"initial\" arguments before key-value pairs start\n+        for (; i < numOfArgsBeforeKeyValue && i < args.size(); ++i) {\n+          normalised.append(\" \").append(args.get(i));\n+        }\n+\n+        // whether keys are on even or odd index depends on the number of initial args\n+        int keys = numOfArgsBeforeKeyValue % 2;\n+        for (; i < args.size(); ++i) {\n+          normalised\n+              .append(\" \")\n+              // append only keys, skip values\n+              .append(i % 2 == keys ? args.get(i) : \"?\");\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0f943b7d163f3e7dd981f282bc41f56269d0b7d"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzYyNjI0NQ==", "bodyText": "That's much better!", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r507626245", "createdAt": "2020-10-19T10:05:21Z", "author": {"login": "mateuszrzeszutek"}, "path": "instrumentation/lettuce/lettuce-5.1/src/main/java/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/RedisCommandNormalizer.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.lettuce.v5_1;\n+\n+import static java.util.Collections.unmodifiableMap;\n+\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.CommandAndNumArgs;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.Default;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.Eval;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.MultiKeyValue;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/** This class is responsible for masking potentially sensitive data in Redis commands. */\n+public final class RedisCommandNormalizer {\n+\n+  private static final Map<String, CommandNormalizer> NORMALIZERS;\n+\n+  static {\n+    Map<String, CommandNormalizer> normalizers = new HashMap<>();\n+\n+    CommandNormalizer keepOneArg = new CommandAndNumArgs(1);\n+    CommandNormalizer keepTwoArgs = new CommandAndNumArgs(2);\n+    CommandNormalizer setMultiHashField = new MultiKeyValue(1);\n+    CommandNormalizer setMultiField = new MultiKeyValue(0);\n+\n+    // Connection\n+    // can contain AUTH data\n+    normalizers.put(\"AUTH\", new CommandAndNumArgs(0));\n+    normalizers.put(\"HELLO\", keepTwoArgs);\n+\n+    // Hashes\n+    normalizers.put(\"HMSET\", setMultiHashField);\n+    normalizers.put(\"HSET\", setMultiHashField);\n+    normalizers.put(\"HSETNX\", keepTwoArgs);\n+\n+    // HyperLogLog\n+    normalizers.put(\"PFADD\", keepOneArg);\n+\n+    // Keys\n+    // can contain AUTH data\n+    normalizers.put(\"MIGRATE\", new CommandAndNumArgs(6));\n+\n+    // Lists\n+    normalizers.put(\"LINSERT\", keepTwoArgs);\n+    normalizers.put(\"LPOS\", keepOneArg);\n+    normalizers.put(\"LPUSH\", keepOneArg);\n+    normalizers.put(\"LPUSHX\", keepOneArg);\n+    normalizers.put(\"LREM\", keepOneArg);\n+    normalizers.put(\"LSET\", keepOneArg);\n+    normalizers.put(\"RPUSH\", keepOneArg);\n+    normalizers.put(\"RPUSHX\", keepOneArg);\n+\n+    // Pub/Sub\n+    normalizers.put(\"PUBLISH\", keepOneArg);\n+\n+    // Scripting\n+    normalizers.put(\"EVAL\", Eval.INSTANCE);\n+    normalizers.put(\"EVALSHA\", Eval.INSTANCE);\n+\n+    // Sets\n+    normalizers.put(\"SADD\", keepOneArg);\n+    normalizers.put(\"SISMEMBER\", keepOneArg);\n+    normalizers.put(\"SMISMEMBER\", keepOneArg);\n+    normalizers.put(\"SMOVE\", keepTwoArgs);\n+    normalizers.put(\"SREM\", keepOneArg);\n+\n+    // Sorted Sets\n+    normalizers.put(\"ZADD\", keepOneArg);\n+    normalizers.put(\"ZCOUNT\", keepOneArg);\n+    normalizers.put(\"ZINCRBY\", keepOneArg);\n+    normalizers.put(\"ZLEXCOUNT\", keepOneArg);\n+    normalizers.put(\"ZMSCORE\", keepOneArg);\n+    normalizers.put(\"ZRANGEBYLEX\", keepOneArg);\n+    normalizers.put(\"ZRANGEBYSCORE\", keepOneArg);\n+    normalizers.put(\"ZRANK\", keepOneArg);\n+    normalizers.put(\"ZREM\", keepOneArg);\n+    normalizers.put(\"ZREMRANGEBYLEX\", keepOneArg);\n+    normalizers.put(\"ZREMRANGEBYSCORE\", keepOneArg);\n+    normalizers.put(\"ZREVRANGEBYLEX\", keepOneArg);\n+    normalizers.put(\"ZREVRANGEBYSCORE\", keepOneArg);\n+    normalizers.put(\"ZREVRANK\", keepOneArg);\n+    normalizers.put(\"ZSCORE\", keepOneArg);\n+\n+    // Streams\n+    normalizers.put(\"XADD\", new MultiKeyValue(2));\n+\n+    // Strings\n+    normalizers.put(\"APPEND\", keepOneArg);\n+    normalizers.put(\"GETSET\", keepOneArg);\n+    normalizers.put(\"MSET\", setMultiField);\n+    normalizers.put(\"MSETNX\", setMultiField);\n+    normalizers.put(\"PSETEX\", keepTwoArgs);\n+    normalizers.put(\"SET\", keepOneArg);\n+    normalizers.put(\"SETEX\", keepTwoArgs);\n+    normalizers.put(\"SETNX\", keepOneArg);\n+    normalizers.put(\"SETRANGE\", keepOneArg);\n+\n+    NORMALIZERS = unmodifiableMap(normalizers);\n+  }\n+\n+  public static String normalize(String command, List<String> args) {\n+    return NORMALIZERS\n+        .getOrDefault(command.toUpperCase(), Default.INSTANCE)\n+        .normalize(command, args);\n+  }\n+\n+  public interface CommandNormalizer {\n+    String normalize(String command, List<String> args);\n+\n+    enum Default implements CommandNormalizer {\n+      INSTANCE;\n+\n+      @Override\n+      public String normalize(String command, List<String> args) {\n+        StringBuilder normalised = new StringBuilder(command);\n+        for (String arg : args) {\n+          normalised.append(\" \").append(arg);\n+        }\n+        return normalised.toString();\n+      }\n+    }\n+\n+    class CommandAndNumArgs implements CommandNormalizer {\n+      private final int numOfArgsToKeep;\n+\n+      public CommandAndNumArgs(int numOfArgsToKeep) {\n+        this.numOfArgsToKeep = numOfArgsToKeep;\n+      }\n+\n+      @Override\n+      public String normalize(String command, List<String> args) {\n+        StringBuilder normalised = new StringBuilder(command);\n+        int i = 0;\n+        for (; i < numOfArgsToKeep && i < args.size(); ++i) {\n+          normalised.append(\" \").append(args.get(i));\n+        }\n+        for (; i < args.size(); ++i) {\n+          normalised.append(\" \").append(\"?\");\n+        }\n+        return normalised.toString();\n+      }\n+    }\n+\n+    class MultiKeyValue implements CommandNormalizer {\n+      private final int numOfArgsBeforeKeyValue;\n+\n+      public MultiKeyValue(int numOfArgsBeforeKeyValue) {\n+        this.numOfArgsBeforeKeyValue = numOfArgsBeforeKeyValue;\n+      }\n+\n+      @Override\n+      public String normalize(String command, List<String> args) {\n+        StringBuilder normalised = new StringBuilder(command);\n+        int i = 0;\n+        // append all \"initial\" arguments before key-value pairs start\n+        for (; i < numOfArgsBeforeKeyValue && i < args.size(); ++i) {\n+          normalised.append(\" \").append(args.get(i));\n+        }\n+\n+        // whether keys are on even or odd index depends on the number of initial args\n+        int keys = numOfArgsBeforeKeyValue % 2;\n+        for (; i < args.size(); ++i) {\n+          normalised\n+              .append(\" \")\n+              // append only keys, skip values\n+              .append(i % 2 == keys ? args.get(i) : \"?\");\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc0OTA1OA=="}, "originalCommit": {"oid": "d0f943b7d163f3e7dd981f282bc41f56269d0b7d"}, "originalPosition": 172}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDA1Mzk2OnYy", "diffSide": "RIGHT", "path": "instrumentation/lettuce/lettuce-5.1/src/main/java/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/RedisCommandNormalizer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQyMjozODoxNVrOHjRkhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxMDowNDozNVrOHkHBJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc1MDA4NA==", "bodyText": "I think this is easier to read, but curious other thoughts, I also see attractiveness of current approach which increments a single counter to show that everything is hit\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    int i = 0;\n          \n          \n            \n                    for (; i < numOfArgsToKeep && i < args.size(); ++i) {\n          \n          \n            \n                      normalised.append(\" \").append(args.get(i));\n          \n          \n            \n                    }\n          \n          \n            \n                    for (; i < args.size(); ++i) {\n          \n          \n            \n                    for (int i = 0; i < numOfArgsToKeep && i < args.size(); ++i) {\n          \n          \n            \n                      normalised.append(\" \").append(args.get(i));\n          \n          \n            \n                    }\n          \n          \n            \n                    for (int i = numOfArgsToKeep; i < args.size(); ++i) {", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r506750084", "createdAt": "2020-10-16T22:38:15Z", "author": {"login": "trask"}, "path": "instrumentation/lettuce/lettuce-5.1/src/main/java/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/RedisCommandNormalizer.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.lettuce.v5_1;\n+\n+import static java.util.Collections.unmodifiableMap;\n+\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.CommandAndNumArgs;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.Default;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.Eval;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.MultiKeyValue;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/** This class is responsible for masking potentially sensitive data in Redis commands. */\n+public final class RedisCommandNormalizer {\n+\n+  private static final Map<String, CommandNormalizer> NORMALIZERS;\n+\n+  static {\n+    Map<String, CommandNormalizer> normalizers = new HashMap<>();\n+\n+    CommandNormalizer keepOneArg = new CommandAndNumArgs(1);\n+    CommandNormalizer keepTwoArgs = new CommandAndNumArgs(2);\n+    CommandNormalizer setMultiHashField = new MultiKeyValue(1);\n+    CommandNormalizer setMultiField = new MultiKeyValue(0);\n+\n+    // Connection\n+    // can contain AUTH data\n+    normalizers.put(\"AUTH\", new CommandAndNumArgs(0));\n+    normalizers.put(\"HELLO\", keepTwoArgs);\n+\n+    // Hashes\n+    normalizers.put(\"HMSET\", setMultiHashField);\n+    normalizers.put(\"HSET\", setMultiHashField);\n+    normalizers.put(\"HSETNX\", keepTwoArgs);\n+\n+    // HyperLogLog\n+    normalizers.put(\"PFADD\", keepOneArg);\n+\n+    // Keys\n+    // can contain AUTH data\n+    normalizers.put(\"MIGRATE\", new CommandAndNumArgs(6));\n+\n+    // Lists\n+    normalizers.put(\"LINSERT\", keepTwoArgs);\n+    normalizers.put(\"LPOS\", keepOneArg);\n+    normalizers.put(\"LPUSH\", keepOneArg);\n+    normalizers.put(\"LPUSHX\", keepOneArg);\n+    normalizers.put(\"LREM\", keepOneArg);\n+    normalizers.put(\"LSET\", keepOneArg);\n+    normalizers.put(\"RPUSH\", keepOneArg);\n+    normalizers.put(\"RPUSHX\", keepOneArg);\n+\n+    // Pub/Sub\n+    normalizers.put(\"PUBLISH\", keepOneArg);\n+\n+    // Scripting\n+    normalizers.put(\"EVAL\", Eval.INSTANCE);\n+    normalizers.put(\"EVALSHA\", Eval.INSTANCE);\n+\n+    // Sets\n+    normalizers.put(\"SADD\", keepOneArg);\n+    normalizers.put(\"SISMEMBER\", keepOneArg);\n+    normalizers.put(\"SMISMEMBER\", keepOneArg);\n+    normalizers.put(\"SMOVE\", keepTwoArgs);\n+    normalizers.put(\"SREM\", keepOneArg);\n+\n+    // Sorted Sets\n+    normalizers.put(\"ZADD\", keepOneArg);\n+    normalizers.put(\"ZCOUNT\", keepOneArg);\n+    normalizers.put(\"ZINCRBY\", keepOneArg);\n+    normalizers.put(\"ZLEXCOUNT\", keepOneArg);\n+    normalizers.put(\"ZMSCORE\", keepOneArg);\n+    normalizers.put(\"ZRANGEBYLEX\", keepOneArg);\n+    normalizers.put(\"ZRANGEBYSCORE\", keepOneArg);\n+    normalizers.put(\"ZRANK\", keepOneArg);\n+    normalizers.put(\"ZREM\", keepOneArg);\n+    normalizers.put(\"ZREMRANGEBYLEX\", keepOneArg);\n+    normalizers.put(\"ZREMRANGEBYSCORE\", keepOneArg);\n+    normalizers.put(\"ZREVRANGEBYLEX\", keepOneArg);\n+    normalizers.put(\"ZREVRANGEBYSCORE\", keepOneArg);\n+    normalizers.put(\"ZREVRANK\", keepOneArg);\n+    normalizers.put(\"ZSCORE\", keepOneArg);\n+\n+    // Streams\n+    normalizers.put(\"XADD\", new MultiKeyValue(2));\n+\n+    // Strings\n+    normalizers.put(\"APPEND\", keepOneArg);\n+    normalizers.put(\"GETSET\", keepOneArg);\n+    normalizers.put(\"MSET\", setMultiField);\n+    normalizers.put(\"MSETNX\", setMultiField);\n+    normalizers.put(\"PSETEX\", keepTwoArgs);\n+    normalizers.put(\"SET\", keepOneArg);\n+    normalizers.put(\"SETEX\", keepTwoArgs);\n+    normalizers.put(\"SETNX\", keepOneArg);\n+    normalizers.put(\"SETRANGE\", keepOneArg);\n+\n+    NORMALIZERS = unmodifiableMap(normalizers);\n+  }\n+\n+  public static String normalize(String command, List<String> args) {\n+    return NORMALIZERS\n+        .getOrDefault(command.toUpperCase(), Default.INSTANCE)\n+        .normalize(command, args);\n+  }\n+\n+  public interface CommandNormalizer {\n+    String normalize(String command, List<String> args);\n+\n+    enum Default implements CommandNormalizer {\n+      INSTANCE;\n+\n+      @Override\n+      public String normalize(String command, List<String> args) {\n+        StringBuilder normalised = new StringBuilder(command);\n+        for (String arg : args) {\n+          normalised.append(\" \").append(arg);\n+        }\n+        return normalised.toString();\n+      }\n+    }\n+\n+    class CommandAndNumArgs implements CommandNormalizer {\n+      private final int numOfArgsToKeep;\n+\n+      public CommandAndNumArgs(int numOfArgsToKeep) {\n+        this.numOfArgsToKeep = numOfArgsToKeep;\n+      }\n+\n+      @Override\n+      public String normalize(String command, List<String> args) {\n+        StringBuilder normalised = new StringBuilder(command);\n+        int i = 0;\n+        for (; i < numOfArgsToKeep && i < args.size(); ++i) {\n+          normalised.append(\" \").append(args.get(i));\n+        }\n+        for (; i < args.size(); ++i) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0f943b7d163f3e7dd981f282bc41f56269d0b7d"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzYyNTc2Ng==", "bodyText": "Both are perfectly fine to me, I'll use your version if you think it's more readable.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r507625766", "createdAt": "2020-10-19T10:04:35Z", "author": {"login": "mateuszrzeszutek"}, "path": "instrumentation/lettuce/lettuce-5.1/src/main/java/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/RedisCommandNormalizer.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.lettuce.v5_1;\n+\n+import static java.util.Collections.unmodifiableMap;\n+\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.CommandAndNumArgs;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.Default;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.Eval;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.MultiKeyValue;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/** This class is responsible for masking potentially sensitive data in Redis commands. */\n+public final class RedisCommandNormalizer {\n+\n+  private static final Map<String, CommandNormalizer> NORMALIZERS;\n+\n+  static {\n+    Map<String, CommandNormalizer> normalizers = new HashMap<>();\n+\n+    CommandNormalizer keepOneArg = new CommandAndNumArgs(1);\n+    CommandNormalizer keepTwoArgs = new CommandAndNumArgs(2);\n+    CommandNormalizer setMultiHashField = new MultiKeyValue(1);\n+    CommandNormalizer setMultiField = new MultiKeyValue(0);\n+\n+    // Connection\n+    // can contain AUTH data\n+    normalizers.put(\"AUTH\", new CommandAndNumArgs(0));\n+    normalizers.put(\"HELLO\", keepTwoArgs);\n+\n+    // Hashes\n+    normalizers.put(\"HMSET\", setMultiHashField);\n+    normalizers.put(\"HSET\", setMultiHashField);\n+    normalizers.put(\"HSETNX\", keepTwoArgs);\n+\n+    // HyperLogLog\n+    normalizers.put(\"PFADD\", keepOneArg);\n+\n+    // Keys\n+    // can contain AUTH data\n+    normalizers.put(\"MIGRATE\", new CommandAndNumArgs(6));\n+\n+    // Lists\n+    normalizers.put(\"LINSERT\", keepTwoArgs);\n+    normalizers.put(\"LPOS\", keepOneArg);\n+    normalizers.put(\"LPUSH\", keepOneArg);\n+    normalizers.put(\"LPUSHX\", keepOneArg);\n+    normalizers.put(\"LREM\", keepOneArg);\n+    normalizers.put(\"LSET\", keepOneArg);\n+    normalizers.put(\"RPUSH\", keepOneArg);\n+    normalizers.put(\"RPUSHX\", keepOneArg);\n+\n+    // Pub/Sub\n+    normalizers.put(\"PUBLISH\", keepOneArg);\n+\n+    // Scripting\n+    normalizers.put(\"EVAL\", Eval.INSTANCE);\n+    normalizers.put(\"EVALSHA\", Eval.INSTANCE);\n+\n+    // Sets\n+    normalizers.put(\"SADD\", keepOneArg);\n+    normalizers.put(\"SISMEMBER\", keepOneArg);\n+    normalizers.put(\"SMISMEMBER\", keepOneArg);\n+    normalizers.put(\"SMOVE\", keepTwoArgs);\n+    normalizers.put(\"SREM\", keepOneArg);\n+\n+    // Sorted Sets\n+    normalizers.put(\"ZADD\", keepOneArg);\n+    normalizers.put(\"ZCOUNT\", keepOneArg);\n+    normalizers.put(\"ZINCRBY\", keepOneArg);\n+    normalizers.put(\"ZLEXCOUNT\", keepOneArg);\n+    normalizers.put(\"ZMSCORE\", keepOneArg);\n+    normalizers.put(\"ZRANGEBYLEX\", keepOneArg);\n+    normalizers.put(\"ZRANGEBYSCORE\", keepOneArg);\n+    normalizers.put(\"ZRANK\", keepOneArg);\n+    normalizers.put(\"ZREM\", keepOneArg);\n+    normalizers.put(\"ZREMRANGEBYLEX\", keepOneArg);\n+    normalizers.put(\"ZREMRANGEBYSCORE\", keepOneArg);\n+    normalizers.put(\"ZREVRANGEBYLEX\", keepOneArg);\n+    normalizers.put(\"ZREVRANGEBYSCORE\", keepOneArg);\n+    normalizers.put(\"ZREVRANK\", keepOneArg);\n+    normalizers.put(\"ZSCORE\", keepOneArg);\n+\n+    // Streams\n+    normalizers.put(\"XADD\", new MultiKeyValue(2));\n+\n+    // Strings\n+    normalizers.put(\"APPEND\", keepOneArg);\n+    normalizers.put(\"GETSET\", keepOneArg);\n+    normalizers.put(\"MSET\", setMultiField);\n+    normalizers.put(\"MSETNX\", setMultiField);\n+    normalizers.put(\"PSETEX\", keepTwoArgs);\n+    normalizers.put(\"SET\", keepOneArg);\n+    normalizers.put(\"SETEX\", keepTwoArgs);\n+    normalizers.put(\"SETNX\", keepOneArg);\n+    normalizers.put(\"SETRANGE\", keepOneArg);\n+\n+    NORMALIZERS = unmodifiableMap(normalizers);\n+  }\n+\n+  public static String normalize(String command, List<String> args) {\n+    return NORMALIZERS\n+        .getOrDefault(command.toUpperCase(), Default.INSTANCE)\n+        .normalize(command, args);\n+  }\n+\n+  public interface CommandNormalizer {\n+    String normalize(String command, List<String> args);\n+\n+    enum Default implements CommandNormalizer {\n+      INSTANCE;\n+\n+      @Override\n+      public String normalize(String command, List<String> args) {\n+        StringBuilder normalised = new StringBuilder(command);\n+        for (String arg : args) {\n+          normalised.append(\" \").append(arg);\n+        }\n+        return normalised.toString();\n+      }\n+    }\n+\n+    class CommandAndNumArgs implements CommandNormalizer {\n+      private final int numOfArgsToKeep;\n+\n+      public CommandAndNumArgs(int numOfArgsToKeep) {\n+        this.numOfArgsToKeep = numOfArgsToKeep;\n+      }\n+\n+      @Override\n+      public String normalize(String command, List<String> args) {\n+        StringBuilder normalised = new StringBuilder(command);\n+        int i = 0;\n+        for (; i < numOfArgsToKeep && i < args.size(); ++i) {\n+          normalised.append(\" \").append(args.get(i));\n+        }\n+        for (; i < args.size(); ++i) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc1MDA4NA=="}, "originalCommit": {"oid": "d0f943b7d163f3e7dd981f282bc41f56269d0b7d"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDMyNDU3OnYy", "diffSide": "RIGHT", "path": "instrumentation/lettuce/lettuce-5.1/src/main/java/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/RedisCommandNormalizer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwMzowOTo0NlrOHjTz0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxMzoxMTo1M1rOHkNlMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc4Njc2OA==", "bodyText": "Can you add examples for the various normalization?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r506786768", "createdAt": "2020-10-17T03:09:46Z", "author": {"login": "anuraaga"}, "path": "instrumentation/lettuce/lettuce-5.1/src/main/java/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/RedisCommandNormalizer.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.lettuce.v5_1;\n+\n+import static java.util.Collections.unmodifiableMap;\n+\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.CommandAndNumArgs;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.Default;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.Eval;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.MultiKeyValue;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/** This class is responsible for masking potentially sensitive data in Redis commands. */\n+public final class RedisCommandNormalizer {\n+\n+  private static final Map<String, CommandNormalizer> NORMALIZERS;\n+\n+  static {\n+    Map<String, CommandNormalizer> normalizers = new HashMap<>();\n+\n+    CommandNormalizer keepOneArg = new CommandAndNumArgs(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0f943b7d163f3e7dd981f282bc41f56269d0b7d"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzczMzI5Nw==", "bodyText": "Added some examples to class JavaDoc.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r507733297", "createdAt": "2020-10-19T13:11:53Z", "author": {"login": "mateuszrzeszutek"}, "path": "instrumentation/lettuce/lettuce-5.1/src/main/java/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/RedisCommandNormalizer.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.lettuce.v5_1;\n+\n+import static java.util.Collections.unmodifiableMap;\n+\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.CommandAndNumArgs;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.Default;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.Eval;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.MultiKeyValue;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/** This class is responsible for masking potentially sensitive data in Redis commands. */\n+public final class RedisCommandNormalizer {\n+\n+  private static final Map<String, CommandNormalizer> NORMALIZERS;\n+\n+  static {\n+    Map<String, CommandNormalizer> normalizers = new HashMap<>();\n+\n+    CommandNormalizer keepOneArg = new CommandAndNumArgs(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc4Njc2OA=="}, "originalCommit": {"oid": "d0f943b7d163f3e7dd981f282bc41f56269d0b7d"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDMyNjY2OnYy", "diffSide": "RIGHT", "path": "instrumentation/lettuce/lettuce-5.1/src/test/groovy/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/LettuceReactiveClientTest.groovy", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwMzoxMjo0OVrOHjT0uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxNToxMDoxNFrOHkTlmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc4NzAwMw==", "bodyText": "The rendering is a great improvement, thanks! But the spec seems to include argument values for statements\nhttps://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/database.md#redis\nI don't know if this is a good idea though - do you mind filing a spec issue to discuss the PII implications and adding scrubbing to the spec?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r506787003", "createdAt": "2020-10-17T03:12:49Z", "author": {"login": "anuraaga"}, "path": "instrumentation/lettuce/lettuce-5.1/src/test/groovy/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/LettuceReactiveClientTest.groovy", "diffHunk": "@@ -301,12 +301,12 @@ class LettuceReactiveClientTest extends AgentTestRunner {\n           errored false\n           childOf span(0)\n           attributes {\n-            \"${SemanticAttributes.NET_TRANSPORT.key()}\" \"IP.TCP\"\n-            \"${SemanticAttributes.NET_PEER_IP.key()}\" \"127.0.0.1\"\n-            \"${SemanticAttributes.NET_PEER_PORT.key()}\" port\n-            \"${SemanticAttributes.DB_CONNECTION_STRING.key()}\" \"redis://127.0.0.1:$port\"\n-            \"${SemanticAttributes.DB_SYSTEM.key()}\" \"redis\"\n-            \"${SemanticAttributes.DB_STATEMENT.key()}\" \"SET key<a> value<1>\"\n+            \"${SemanticAttributes.NET_TRANSPORT.key}\" \"IP.TCP\"\n+            \"${SemanticAttributes.NET_PEER_IP.key}\" \"127.0.0.1\"\n+            \"${SemanticAttributes.NET_PEER_PORT.key}\" port\n+            \"${SemanticAttributes.DB_CONNECTION_STRING.key}\" \"redis://127.0.0.1:$port\"\n+            \"${SemanticAttributes.DB_SYSTEM.key}\" \"redis\"\n+            \"${SemanticAttributes.DB_STATEMENT.key}\" \"SET a ?\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0f943b7d163f3e7dd981f282bc41f56269d0b7d"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc4NzA0OQ==", "bodyText": "Forgot to mention the improved rendering is very nice!", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r506787049", "createdAt": "2020-10-17T03:13:38Z", "author": {"login": "anuraaga"}, "path": "instrumentation/lettuce/lettuce-5.1/src/test/groovy/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/LettuceReactiveClientTest.groovy", "diffHunk": "@@ -301,12 +301,12 @@ class LettuceReactiveClientTest extends AgentTestRunner {\n           errored false\n           childOf span(0)\n           attributes {\n-            \"${SemanticAttributes.NET_TRANSPORT.key()}\" \"IP.TCP\"\n-            \"${SemanticAttributes.NET_PEER_IP.key()}\" \"127.0.0.1\"\n-            \"${SemanticAttributes.NET_PEER_PORT.key()}\" port\n-            \"${SemanticAttributes.DB_CONNECTION_STRING.key()}\" \"redis://127.0.0.1:$port\"\n-            \"${SemanticAttributes.DB_SYSTEM.key()}\" \"redis\"\n-            \"${SemanticAttributes.DB_STATEMENT.key()}\" \"SET key<a> value<1>\"\n+            \"${SemanticAttributes.NET_TRANSPORT.key}\" \"IP.TCP\"\n+            \"${SemanticAttributes.NET_PEER_IP.key}\" \"127.0.0.1\"\n+            \"${SemanticAttributes.NET_PEER_PORT.key}\" port\n+            \"${SemanticAttributes.DB_CONNECTION_STRING.key}\" \"redis://127.0.0.1:$port\"\n+            \"${SemanticAttributes.DB_SYSTEM.key}\" \"redis\"\n+            \"${SemanticAttributes.DB_STATEMENT.key}\" \"SET a ?\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc4NzAwMw=="}, "originalCommit": {"oid": "d0f943b7d163f3e7dd981f282bc41f56269d0b7d"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzYyNzY1OQ==", "bodyText": "I think this is in accordance with spec - see db.statement attribute spec:\n[3]: The value may be sanitized to exclude sensitive information.\n\nStill, I think that this could be described in a more clear and explicit way. I'll create a spec issue to add an example for masking/sanitization.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r507627659", "createdAt": "2020-10-19T10:07:56Z", "author": {"login": "mateuszrzeszutek"}, "path": "instrumentation/lettuce/lettuce-5.1/src/test/groovy/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/LettuceReactiveClientTest.groovy", "diffHunk": "@@ -301,12 +301,12 @@ class LettuceReactiveClientTest extends AgentTestRunner {\n           errored false\n           childOf span(0)\n           attributes {\n-            \"${SemanticAttributes.NET_TRANSPORT.key()}\" \"IP.TCP\"\n-            \"${SemanticAttributes.NET_PEER_IP.key()}\" \"127.0.0.1\"\n-            \"${SemanticAttributes.NET_PEER_PORT.key()}\" port\n-            \"${SemanticAttributes.DB_CONNECTION_STRING.key()}\" \"redis://127.0.0.1:$port\"\n-            \"${SemanticAttributes.DB_SYSTEM.key()}\" \"redis\"\n-            \"${SemanticAttributes.DB_STATEMENT.key()}\" \"SET key<a> value<1>\"\n+            \"${SemanticAttributes.NET_TRANSPORT.key}\" \"IP.TCP\"\n+            \"${SemanticAttributes.NET_PEER_IP.key}\" \"127.0.0.1\"\n+            \"${SemanticAttributes.NET_PEER_PORT.key}\" port\n+            \"${SemanticAttributes.DB_CONNECTION_STRING.key}\" \"redis://127.0.0.1:$port\"\n+            \"${SemanticAttributes.DB_SYSTEM.key}\" \"redis\"\n+            \"${SemanticAttributes.DB_STATEMENT.key}\" \"SET a ?\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc4NzAwMw=="}, "originalCommit": {"oid": "d0f943b7d163f3e7dd981f282bc41f56269d0b7d"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzYyNzg2Nw==", "bodyText": "Forgot to mention the improved rendering is very nice!\n\nThanks \ud83d\ude04", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r507627867", "createdAt": "2020-10-19T10:08:19Z", "author": {"login": "mateuszrzeszutek"}, "path": "instrumentation/lettuce/lettuce-5.1/src/test/groovy/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/LettuceReactiveClientTest.groovy", "diffHunk": "@@ -301,12 +301,12 @@ class LettuceReactiveClientTest extends AgentTestRunner {\n           errored false\n           childOf span(0)\n           attributes {\n-            \"${SemanticAttributes.NET_TRANSPORT.key()}\" \"IP.TCP\"\n-            \"${SemanticAttributes.NET_PEER_IP.key()}\" \"127.0.0.1\"\n-            \"${SemanticAttributes.NET_PEER_PORT.key()}\" port\n-            \"${SemanticAttributes.DB_CONNECTION_STRING.key()}\" \"redis://127.0.0.1:$port\"\n-            \"${SemanticAttributes.DB_SYSTEM.key()}\" \"redis\"\n-            \"${SemanticAttributes.DB_STATEMENT.key()}\" \"SET key<a> value<1>\"\n+            \"${SemanticAttributes.NET_TRANSPORT.key}\" \"IP.TCP\"\n+            \"${SemanticAttributes.NET_PEER_IP.key}\" \"127.0.0.1\"\n+            \"${SemanticAttributes.NET_PEER_PORT.key}\" port\n+            \"${SemanticAttributes.DB_CONNECTION_STRING.key}\" \"redis://127.0.0.1:$port\"\n+            \"${SemanticAttributes.DB_SYSTEM.key}\" \"redis\"\n+            \"${SemanticAttributes.DB_STATEMENT.key}\" \"SET a ?\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc4NzAwMw=="}, "originalCommit": {"oid": "d0f943b7d163f3e7dd981f282bc41f56269d0b7d"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzgzMTcwNg==", "bodyText": "open-telemetry/opentelemetry-specification#1106", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r507831706", "createdAt": "2020-10-19T15:10:14Z", "author": {"login": "mateuszrzeszutek"}, "path": "instrumentation/lettuce/lettuce-5.1/src/test/groovy/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/LettuceReactiveClientTest.groovy", "diffHunk": "@@ -301,12 +301,12 @@ class LettuceReactiveClientTest extends AgentTestRunner {\n           errored false\n           childOf span(0)\n           attributes {\n-            \"${SemanticAttributes.NET_TRANSPORT.key()}\" \"IP.TCP\"\n-            \"${SemanticAttributes.NET_PEER_IP.key()}\" \"127.0.0.1\"\n-            \"${SemanticAttributes.NET_PEER_PORT.key()}\" port\n-            \"${SemanticAttributes.DB_CONNECTION_STRING.key()}\" \"redis://127.0.0.1:$port\"\n-            \"${SemanticAttributes.DB_SYSTEM.key()}\" \"redis\"\n-            \"${SemanticAttributes.DB_STATEMENT.key()}\" \"SET key<a> value<1>\"\n+            \"${SemanticAttributes.NET_TRANSPORT.key}\" \"IP.TCP\"\n+            \"${SemanticAttributes.NET_PEER_IP.key}\" \"127.0.0.1\"\n+            \"${SemanticAttributes.NET_PEER_PORT.key}\" port\n+            \"${SemanticAttributes.DB_CONNECTION_STRING.key}\" \"redis://127.0.0.1:$port\"\n+            \"${SemanticAttributes.DB_SYSTEM.key}\" \"redis\"\n+            \"${SemanticAttributes.DB_STATEMENT.key}\" \"SET a ?\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc4NzAwMw=="}, "originalCommit": {"oid": "d0f943b7d163f3e7dd981f282bc41f56269d0b7d"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MTkwMjc1OnYy", "diffSide": "RIGHT", "path": "instrumentation/lettuce/lettuce-5.1/src/main/java/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/LettuceArgSplitter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxODoyODowM1rOHkcOuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMToxNDo1N1rOHk3Oxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk3MzMwNw==", "bodyText": "sorry, i didn't explain my thought about this well, this is more what i was thinking, keeping the previous KEY_PATTERN:\nplease pick whichever implementation you want (original, current, or below), i don't see a clear winner myself\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                while (m.find()) {\n          \n          \n            \n                  String wrapped = m.group(\"wrapped\");\n          \n          \n            \n                  if (wrapped != null) {\n          \n          \n            \n                    argsList.add(wrapped);\n          \n          \n            \n                  } else {\n          \n          \n            \n                    argsList.add(m.group(\"plain\"));\n          \n          \n            \n                  }\n          \n          \n            \n                }\n          \n          \n            \n                int lastEnd = 0;\n          \n          \n            \n                while (m.find()) {\n          \n          \n            \n                  int wrapperStart = m.start();\n          \n          \n            \n                  argsList.addAll(split(args, lastEnd, wrapperStart));\n          \n          \n            \n                  argsList.add(m.group(\"key\"));\n          \n          \n            \n                  lastEnd = m.end();\n          \n          \n            \n                }\n          \n          \n            \n                argsList.addAll(split(args, lastEnd, args.length()));\n          \n          \n            \n            \n          \n          \n            \n              ...\n          \n          \n            \n            \n          \n          \n            \n              private static final Pattern SPLIT_PATTERN = Pattern.compile(\" \");\n          \n          \n            \n            \n          \n          \n            \n              private static List<String> split(String args, int from, int to) {\n          \n          \n            \n                return Arrays.asList(SPLIT_PATTERN.split(args.subSequence(from, to)));\n          \n          \n            \n              }", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r507973307", "createdAt": "2020-10-19T18:28:03Z", "author": {"login": "trask"}, "path": "instrumentation/lettuce/lettuce-5.1/src/main/java/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/LettuceArgSplitter.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.lettuce.v5_1;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+\n+public final class LettuceArgSplitter {\n+  private static final Pattern KEY_PATTERN =\n+      Pattern.compile(\"((key|value)<(?<wrapped>[^>]+)>|(?<plain>[0-9A-Za-z=]+))(\\\\s+|$)\");\n+\n+  // this method removes the key|value<...> wrappers around redis keys or values and splits the args\n+  // string\n+  public static List<String> splitArgs(@Nullable String args) {\n+    if (args == null || args.isEmpty()) {\n+      return Collections.emptyList();\n+    }\n+\n+    List<String> argsList = new ArrayList<>();\n+    Matcher m = KEY_PATTERN.matcher(args);\n+    while (m.find()) {\n+      String wrapped = m.group(\"wrapped\");\n+      if (wrapped != null) {\n+        argsList.add(wrapped);\n+      } else {\n+        argsList.add(m.group(\"plain\"));\n+      }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf591f216acc92b1237cb4e9cd725ca652210d5d"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQxNTY4Ng==", "bodyText": "Oh, I see. Hmm, I think I'll leave it as it is now - the pattern is a bit more complex but I like the fact that we only go through the entire string once.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r508415686", "createdAt": "2020-10-20T11:14:57Z", "author": {"login": "mateuszrzeszutek"}, "path": "instrumentation/lettuce/lettuce-5.1/src/main/java/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/LettuceArgSplitter.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.lettuce.v5_1;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+\n+public final class LettuceArgSplitter {\n+  private static final Pattern KEY_PATTERN =\n+      Pattern.compile(\"((key|value)<(?<wrapped>[^>]+)>|(?<plain>[0-9A-Za-z=]+))(\\\\s+|$)\");\n+\n+  // this method removes the key|value<...> wrappers around redis keys or values and splits the args\n+  // string\n+  public static List<String> splitArgs(@Nullable String args) {\n+    if (args == null || args.isEmpty()) {\n+      return Collections.emptyList();\n+    }\n+\n+    List<String> argsList = new ArrayList<>();\n+    Matcher m = KEY_PATTERN.matcher(args);\n+    while (m.find()) {\n+      String wrapped = m.group(\"wrapped\");\n+      if (wrapped != null) {\n+        argsList.add(wrapped);\n+      } else {\n+        argsList.add(m.group(\"plain\"));\n+      }\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk3MzMwNw=="}, "originalCommit": {"oid": "bf591f216acc92b1237cb4e9cd725ca652210d5d"}, "originalPosition": 35}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4703, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}