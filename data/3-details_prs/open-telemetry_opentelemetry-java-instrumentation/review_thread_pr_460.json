{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI1NTY2OTQx", "number": 460, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwODoxMzowOFrOEBpAMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNjo1MDozMFrOEDUblA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMTU1ODI3OnYy", "diffSide": "RIGHT", "path": "instrumentation/apache-httpclient/apache-httpclient-4.0/src/main/java/io/opentelemetry/auto/instrumentation/apachehttpclient/v4_0/ApacheHttpClientInstrumentation.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwODoxMzowOFrOGdm2Ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwODoxMzowOFrOGdm2Ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY5ODMyMw==", "bodyText": "Ah noticed this is fixed in master of the SDK :)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r433698323", "createdAt": "2020-06-02T08:13:08Z", "author": {"login": "anuraaga"}, "path": "instrumentation/apache-httpclient/apache-httpclient-4.0/src/main/java/io/opentelemetry/auto/instrumentation/apachehttpclient/v4_0/ApacheHttpClientInstrumentation.java", "diffHunk": "@@ -172,16 +171,14 @@ public ApacheHttpClientInstrumentation() {\n \n   public static class HelperMethods {\n     public static SpanWithScope doMethodEnter(final HttpUriRequest request) {\n-      final Span span =\n-          TRACER.spanBuilder(DECORATE.spanNameForRequest(request)).setSpanKind(CLIENT).startSpan();\n+      final Span span = DECORATE.getOrCreateSpan(request, TRACER);\n \n       DECORATE.afterStart(span);\n       DECORATE.onRequest(span, request);\n \n-      final Context context = withSpan(span, Context.current());\n-      final boolean awsClientCall = request.getHeaders(\"amz-sdk-invocation-id\").length > 0;\n-      // AWS calls are often signed, so we can't add headers without breaking the signature.\n-      if (!awsClientCall) {\n+      final Context context = ClientDecorator.withSpan(span, Context.current());\n+      // TODO(anuraaga): Seems like a bug that invalid context still gets injected by the injector.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjE5NDE0OnYy", "diffSide": "RIGHT", "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMToyMTozN1rOGdtMYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMTowNzoyNFrOGeI07A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwMjMzOA==", "bodyText": "Setting parent is not required here. It will come automatically from current context", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r433802338", "createdAt": "2020-06-02T11:21:37Z", "author": {"login": "iNikem"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "diffHunk": "@@ -15,10 +15,51 @@\n  */\n package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n \n+import io.grpc.Context;\n+import io.opentelemetry.context.ContextUtils;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.DefaultSpan;\n import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n \n public abstract class ClientDecorator extends BaseDecorator {\n \n+  // Keeps track of the client span in a subtree corresponding to a client request.\n+  private static final Context.Key<Span> CONTEXT_CLIENT_SPAN_KEY =\n+      Context.key(\"opentelemetry-trace-auto-client-span-key\");\n+\n+  public static Scope currentContextWith(final Span clientSpan) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.currentContextWith(clientSpan);\n+    }\n+    return ContextUtils.withScopedContext(\n+        TracingContextUtils.withSpan(\n+            clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan)));\n+  }\n+\n+  public static Context withSpan(final Span clientSpan, final Context context) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.withSpan(clientSpan, context);\n+    }\n+    return TracingContextUtils.withSpan(\n+        clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan));\n+  }\n+\n+  public Span getOrCreateSpan(String name, Tracer tracer) {\n+    final Context context = Context.current();\n+    final Span clientSpan = CONTEXT_CLIENT_SPAN_KEY.get(context);\n+\n+    if (clientSpan != null) {\n+      // We don't want to create two client spans for a given client call, suppress inner spans.\n+      return DefaultSpan.getInvalid();\n+    }\n+\n+    final Span current = TracingContextUtils.getSpan(context);\n+    return tracer.spanBuilder(name).setSpanKind(Kind.CLIENT).setParent(current).startSpan();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEzMTQ5OQ==", "bodyText": "Setting the parent here does save a thread-local lookup since we already have the current context from above", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r434131499", "createdAt": "2020-06-02T19:39:02Z", "author": {"login": "trask"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "diffHunk": "@@ -15,10 +15,51 @@\n  */\n package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n \n+import io.grpc.Context;\n+import io.opentelemetry.context.ContextUtils;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.DefaultSpan;\n import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n \n public abstract class ClientDecorator extends BaseDecorator {\n \n+  // Keeps track of the client span in a subtree corresponding to a client request.\n+  private static final Context.Key<Span> CONTEXT_CLIENT_SPAN_KEY =\n+      Context.key(\"opentelemetry-trace-auto-client-span-key\");\n+\n+  public static Scope currentContextWith(final Span clientSpan) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.currentContextWith(clientSpan);\n+    }\n+    return ContextUtils.withScopedContext(\n+        TracingContextUtils.withSpan(\n+            clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan)));\n+  }\n+\n+  public static Context withSpan(final Span clientSpan, final Context context) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.withSpan(clientSpan, context);\n+    }\n+    return TracingContextUtils.withSpan(\n+        clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan));\n+  }\n+\n+  public Span getOrCreateSpan(String name, Tracer tracer) {\n+    final Context context = Context.current();\n+    final Span clientSpan = CONTEXT_CLIENT_SPAN_KEY.get(context);\n+\n+    if (clientSpan != null) {\n+      // We don't want to create two client spans for a given client call, suppress inner spans.\n+      return DefaultSpan.getInvalid();\n+    }\n+\n+    final Span current = TracingContextUtils.getSpan(context);\n+    return tracer.spanBuilder(name).setSpanKind(Kind.CLIENT).setParent(current).startSpan();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwMjMzOA=="}, "originalCommit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1NTA4NA==", "bodyText": "Yup the optimization is the only reason I did so", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r434255084", "createdAt": "2020-06-03T01:07:24Z", "author": {"login": "anuraaga"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "diffHunk": "@@ -15,10 +15,51 @@\n  */\n package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n \n+import io.grpc.Context;\n+import io.opentelemetry.context.ContextUtils;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.DefaultSpan;\n import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n \n public abstract class ClientDecorator extends BaseDecorator {\n \n+  // Keeps track of the client span in a subtree corresponding to a client request.\n+  private static final Context.Key<Span> CONTEXT_CLIENT_SPAN_KEY =\n+      Context.key(\"opentelemetry-trace-auto-client-span-key\");\n+\n+  public static Scope currentContextWith(final Span clientSpan) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.currentContextWith(clientSpan);\n+    }\n+    return ContextUtils.withScopedContext(\n+        TracingContextUtils.withSpan(\n+            clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan)));\n+  }\n+\n+  public static Context withSpan(final Span clientSpan, final Context context) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.withSpan(clientSpan, context);\n+    }\n+    return TracingContextUtils.withSpan(\n+        clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan));\n+  }\n+\n+  public Span getOrCreateSpan(String name, Tracer tracer) {\n+    final Context context = Context.current();\n+    final Span clientSpan = CONTEXT_CLIENT_SPAN_KEY.get(context);\n+\n+    if (clientSpan != null) {\n+      // We don't want to create two client spans for a given client call, suppress inner spans.\n+      return DefaultSpan.getInvalid();\n+    }\n+\n+    final Span current = TracingContextUtils.getSpan(context);\n+    return tracer.spanBuilder(name).setSpanKind(Kind.CLIENT).setParent(current).startSpan();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwMjMzOA=="}, "originalCommit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjIyMjU2OnYy", "diffSide": "RIGHT", "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMTozMDozN1rOGdtd7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMTozMDozN1rOGdtd7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwNjgyOA==", "bodyText": "This method certainly can delegate to withSpan below", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r433806828", "createdAt": "2020-06-02T11:30:37Z", "author": {"login": "iNikem"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "diffHunk": "@@ -15,10 +15,51 @@\n  */\n package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n \n+import io.grpc.Context;\n+import io.opentelemetry.context.ContextUtils;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.DefaultSpan;\n import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n \n public abstract class ClientDecorator extends BaseDecorator {\n \n+  // Keeps track of the client span in a subtree corresponding to a client request.\n+  private static final Context.Key<Span> CONTEXT_CLIENT_SPAN_KEY =\n+      Context.key(\"opentelemetry-trace-auto-client-span-key\");\n+\n+  public static Scope currentContextWith(final Span clientSpan) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjIyNDcxOnYy", "diffSide": "RIGHT", "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMTozMToxMlrOGdtfOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwOTo1NDoxNFrOGeUp5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwNzE2Mg==", "bodyText": "Here we are sure that we are currently creating first client span. I think this should be the right place to put that span into current context under CONTEXT_CLIENT_SPAN_KEY key.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r433807162", "createdAt": "2020-06-02T11:31:12Z", "author": {"login": "iNikem"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "diffHunk": "@@ -15,10 +15,51 @@\n  */\n package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n \n+import io.grpc.Context;\n+import io.opentelemetry.context.ContextUtils;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.DefaultSpan;\n import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n \n public abstract class ClientDecorator extends BaseDecorator {\n \n+  // Keeps track of the client span in a subtree corresponding to a client request.\n+  private static final Context.Key<Span> CONTEXT_CLIENT_SPAN_KEY =\n+      Context.key(\"opentelemetry-trace-auto-client-span-key\");\n+\n+  public static Scope currentContextWith(final Span clientSpan) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.currentContextWith(clientSpan);\n+    }\n+    return ContextUtils.withScopedContext(\n+        TracingContextUtils.withSpan(\n+            clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan)));\n+  }\n+\n+  public static Context withSpan(final Span clientSpan, final Context context) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.withSpan(clientSpan, context);\n+    }\n+    return TracingContextUtils.withSpan(\n+        clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan));\n+  }\n+\n+  public Span getOrCreateSpan(String name, Tracer tracer) {\n+    final Context context = Context.current();\n+    final Span clientSpan = CONTEXT_CLIENT_SPAN_KEY.get(context);\n+\n+    if (clientSpan != null) {\n+      // We don't want to create two client spans for a given client call, suppress inner spans.\n+      return DefaultSpan.getInvalid();\n+    }\n+\n+    final Span current = TracingContextUtils.getSpan(context);\n+    return tracer.spanBuilder(name).setSpanKind(Kind.CLIENT).setParent(current).startSpan();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1NjMyNA==", "bodyText": "I really wish I could - but context is immutable so AFAIK, we can really only \"add to context\" when mounting it, in these withSpan type of methods. I have left some comments in the context discussion doc before coincidentally, and it is running into these sort of cases where I really don't enjoy immutable context ;)\nIf there is an entrypoint that is guaranteed to be called with a new context, than it would be possible to put mutable state in at that point and then here we'd just update it. But I couldn't find one, if this span is the root of a trace (some non-server app running AWS SDK call for example), this span will be created before a new context is and we wouldn't have anywhere to store it until a call to with*.\nLet me know if I'm missing anything, I'd be happy to be since this API is otherwise somewhat ackward for duplicating the APIs in TracingContextUtils.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r434256324", "createdAt": "2020-06-03T01:12:00Z", "author": {"login": "anuraaga"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "diffHunk": "@@ -15,10 +15,51 @@\n  */\n package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n \n+import io.grpc.Context;\n+import io.opentelemetry.context.ContextUtils;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.DefaultSpan;\n import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n \n public abstract class ClientDecorator extends BaseDecorator {\n \n+  // Keeps track of the client span in a subtree corresponding to a client request.\n+  private static final Context.Key<Span> CONTEXT_CLIENT_SPAN_KEY =\n+      Context.key(\"opentelemetry-trace-auto-client-span-key\");\n+\n+  public static Scope currentContextWith(final Span clientSpan) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.currentContextWith(clientSpan);\n+    }\n+    return ContextUtils.withScopedContext(\n+        TracingContextUtils.withSpan(\n+            clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan)));\n+  }\n+\n+  public static Context withSpan(final Span clientSpan, final Context context) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.withSpan(clientSpan, context);\n+    }\n+    return TracingContextUtils.withSpan(\n+        clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan));\n+  }\n+\n+  public Span getOrCreateSpan(String name, Tracer tracer) {\n+    final Context context = Context.current();\n+    final Span clientSpan = CONTEXT_CLIENT_SPAN_KEY.get(context);\n+\n+    if (clientSpan != null) {\n+      // We don't want to create two client spans for a given client call, suppress inner spans.\n+      return DefaultSpan.getInvalid();\n+    }\n+\n+    final Span current = TracingContextUtils.getSpan(context);\n+    return tracer.spanBuilder(name).setSpanKind(Kind.CLIENT).setParent(current).startSpan();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwNzE2Mg=="}, "originalCommit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ0ODg3MA==", "bodyText": "I see what you mean. As long as you return Span from this method, you really cannot modify Context", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r434448870", "createdAt": "2020-06-03T09:54:14Z", "author": {"login": "iNikem"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "diffHunk": "@@ -15,10 +15,51 @@\n  */\n package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n \n+import io.grpc.Context;\n+import io.opentelemetry.context.ContextUtils;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.DefaultSpan;\n import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n \n public abstract class ClientDecorator extends BaseDecorator {\n \n+  // Keeps track of the client span in a subtree corresponding to a client request.\n+  private static final Context.Key<Span> CONTEXT_CLIENT_SPAN_KEY =\n+      Context.key(\"opentelemetry-trace-auto-client-span-key\");\n+\n+  public static Scope currentContextWith(final Span clientSpan) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.currentContextWith(clientSpan);\n+    }\n+    return ContextUtils.withScopedContext(\n+        TracingContextUtils.withSpan(\n+            clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan)));\n+  }\n+\n+  public static Context withSpan(final Span clientSpan, final Context context) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.withSpan(clientSpan, context);\n+    }\n+    return TracingContextUtils.withSpan(\n+        clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan));\n+  }\n+\n+  public Span getOrCreateSpan(String name, Tracer tracer) {\n+    final Context context = Context.current();\n+    final Span clientSpan = CONTEXT_CLIENT_SPAN_KEY.get(context);\n+\n+    if (clientSpan != null) {\n+      // We don't want to create two client spans for a given client call, suppress inner spans.\n+      return DefaultSpan.getInvalid();\n+    }\n+\n+    final Span current = TracingContextUtils.getSpan(context);\n+    return tracer.spanBuilder(name).setSpanKind(Kind.CLIENT).setParent(current).startSpan();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwNzE2Mg=="}, "originalCommit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjIyNzU2OnYy", "diffSide": "RIGHT", "path": "instrumentation/aws-sdk/aws-sdk-2.2/src/main/java8/io/opentelemetry/auto/instrumentation/awssdk/v2_2/TracingExecutionInterceptor.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMTozMjoyMFrOGdthFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjoxOToyN1rOGeZOOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwNzYzOQ==", "bodyText": "Do we still need this ScopeHolder? Why getting span from current context is not enough?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r433807639", "createdAt": "2020-06-02T11:32:20Z", "author": {"login": "iNikem"}, "path": "instrumentation/aws-sdk/aws-sdk-2.2/src/main/java8/io/opentelemetry/auto/instrumentation/awssdk/v2_2/TracingExecutionInterceptor.java", "diffHunk": "@@ -135,7 +132,7 @@ public void beforeTransmission(\n     if (span != null) {\n       // This scope will be closed by AwsHttpClientInstrumentation since ExecutionInterceptor API\n       // doesn't provide a way to run code in the same thread after transmission has been scheduled.\n-      ScopeHolder.CURRENT.set(currentContextWith(span));\n+      ScopeHolder.CURRENT.set(ClientDecorator.currentContextWith(span));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1NzUxNw==", "bodyText": "We get the span from current context here, but afterTransmission may be called on a different thread, e.g., from netty, so the current context won't be accessible there. This ScopeHolder is only to allow closing in that method where we don't have context.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r434257517", "createdAt": "2020-06-03T01:16:55Z", "author": {"login": "anuraaga"}, "path": "instrumentation/aws-sdk/aws-sdk-2.2/src/main/java8/io/opentelemetry/auto/instrumentation/awssdk/v2_2/TracingExecutionInterceptor.java", "diffHunk": "@@ -135,7 +132,7 @@ public void beforeTransmission(\n     if (span != null) {\n       // This scope will be closed by AwsHttpClientInstrumentation since ExecutionInterceptor API\n       // doesn't provide a way to run code in the same thread after transmission has been scheduled.\n-      ScopeHolder.CURRENT.set(currentContextWith(span));\n+      ScopeHolder.CURRENT.set(ClientDecorator.currentContextWith(span));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwNzYzOQ=="}, "originalCommit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ0OTE2OQ==", "bodyText": "And we don't have context propagation between here and Netty threads?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r434449169", "createdAt": "2020-06-03T09:54:46Z", "author": {"login": "iNikem"}, "path": "instrumentation/aws-sdk/aws-sdk-2.2/src/main/java8/io/opentelemetry/auto/instrumentation/awssdk/v2_2/TracingExecutionInterceptor.java", "diffHunk": "@@ -135,7 +132,7 @@ public void beforeTransmission(\n     if (span != null) {\n       // This scope will be closed by AwsHttpClientInstrumentation since ExecutionInterceptor API\n       // doesn't provide a way to run code in the same thread after transmission has been scheduled.\n-      ScopeHolder.CURRENT.set(currentContextWith(span));\n+      ScopeHolder.CURRENT.set(ClientDecorator.currentContextWith(span));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwNzYzOQ=="}, "originalCommit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUyMzcwNg==", "bodyText": "Don't seem to yet. Here's the negative test we have in master\nhttps://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/master/instrumentation/aws-sdk/aws-sdk-2.2/src/test/groovy/Aws2ClientTest.groovy#L223", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r434523706", "createdAt": "2020-06-03T12:19:27Z", "author": {"login": "anuraaga"}, "path": "instrumentation/aws-sdk/aws-sdk-2.2/src/main/java8/io/opentelemetry/auto/instrumentation/awssdk/v2_2/TracingExecutionInterceptor.java", "diffHunk": "@@ -135,7 +132,7 @@ public void beforeTransmission(\n     if (span != null) {\n       // This scope will be closed by AwsHttpClientInstrumentation since ExecutionInterceptor API\n       // doesn't provide a way to run code in the same thread after transmission has been scheduled.\n-      ScopeHolder.CURRENT.set(currentContextWith(span));\n+      ScopeHolder.CURRENT.set(ClientDecorator.currentContextWith(span));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwNzYzOQ=="}, "originalCommit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNDI1MDg0OnYy", "diffSide": "RIGHT", "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxOTo0ODoxNFrOGeBkiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxOTo0ODoxNFrOGeBkiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEzNjIwMA==", "bodyText": "i think?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan));\n          \n          \n            \n                    clientSpan, context.withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan));", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r434136200", "createdAt": "2020-06-02T19:48:14Z", "author": {"login": "trask"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "diffHunk": "@@ -15,10 +15,51 @@\n  */\n package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n \n+import io.grpc.Context;\n+import io.opentelemetry.context.ContextUtils;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.DefaultSpan;\n import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n \n public abstract class ClientDecorator extends BaseDecorator {\n \n+  // Keeps track of the client span in a subtree corresponding to a client request.\n+  private static final Context.Key<Span> CONTEXT_CLIENT_SPAN_KEY =\n+      Context.key(\"opentelemetry-trace-auto-client-span-key\");\n+\n+  public static Scope currentContextWith(final Span clientSpan) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.currentContextWith(clientSpan);\n+    }\n+    return ContextUtils.withScopedContext(\n+        TracingContextUtils.withSpan(\n+            clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan)));\n+  }\n+\n+  public static Context withSpan(final Span clientSpan, final Context context) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.withSpan(clientSpan, context);\n+    }\n+    return TracingContextUtils.withSpan(\n+        clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNDQyMDY1OnYy", "diffSide": "LEFT", "path": "instrumentation/apache-httpclient/apache-httpclient-4.0/src/main/java/io/opentelemetry/auto/instrumentation/apachehttpclient/v4_0/ApacheHttpClientInstrumentation.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQyMDo0Mzo0M1rOGeDR-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwODowODoxNFrOGgTOvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NDIxNg==", "bodyText": "I'm guessing you know something that we don't about this not being needed anymore? \ud83d\ude04", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r434164216", "createdAt": "2020-06-02T20:43:43Z", "author": {"login": "trask"}, "path": "instrumentation/apache-httpclient/apache-httpclient-4.0/src/main/java/io/opentelemetry/auto/instrumentation/apachehttpclient/v4_0/ApacheHttpClientInstrumentation.java", "diffHunk": "@@ -172,16 +171,14 @@ public ApacheHttpClientInstrumentation() {\n \n   public static class HelperMethods {\n     public static SpanWithScope doMethodEnter(final HttpUriRequest request) {\n-      final Span span =\n-          TRACER.spanBuilder(DECORATE.spanNameForRequest(request)).setSpanKind(CLIENT).startSpan();\n+      final Span span = DECORATE.getOrCreateSpan(request, TRACER);\n \n       DECORATE.afterStart(span);\n       DECORATE.onRequest(span, request);\n \n-      final Context context = withSpan(span, Context.current());\n-      final boolean awsClientCall = request.getHeaders(\"amz-sdk-invocation-id\").length > 0;\n-      // AWS calls are often signed, so we can't add headers without breaking the signature.\n-      if (!awsClientCall) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1NzAxMg==", "bodyText": "Now that there's only the SDK span and no Apache span, there's nothing to propagate here. That being said, it does seem safer to keep the check just in case something changes, at the same time, it seems pretty hacky to have the AWS-specific code here so it feels nice to remove it.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r434257012", "createdAt": "2020-06-03T01:14:52Z", "author": {"login": "anuraaga"}, "path": "instrumentation/apache-httpclient/apache-httpclient-4.0/src/main/java/io/opentelemetry/auto/instrumentation/apachehttpclient/v4_0/ApacheHttpClientInstrumentation.java", "diffHunk": "@@ -172,16 +171,14 @@ public ApacheHttpClientInstrumentation() {\n \n   public static class HelperMethods {\n     public static SpanWithScope doMethodEnter(final HttpUriRequest request) {\n-      final Span span =\n-          TRACER.spanBuilder(DECORATE.spanNameForRequest(request)).setSpanKind(CLIENT).startSpan();\n+      final Span span = DECORATE.getOrCreateSpan(request, TRACER);\n \n       DECORATE.afterStart(span);\n       DECORATE.onRequest(span, request);\n \n-      final Context context = withSpan(span, Context.current());\n-      final boolean awsClientCall = request.getHeaders(\"amz-sdk-invocation-id\").length > 0;\n-      // AWS calls are often signed, so we can't add headers without breaking the signature.\n-      if (!awsClientCall) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NDIxNg=="}, "originalCommit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcxMDAwNw==", "bodyText": "Oh, I understand now, right.\nDo the aws-sdk tests protect us here? If so I'm good removing it.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r434710007", "createdAt": "2020-06-03T16:45:09Z", "author": {"login": "trask"}, "path": "instrumentation/apache-httpclient/apache-httpclient-4.0/src/main/java/io/opentelemetry/auto/instrumentation/apachehttpclient/v4_0/ApacheHttpClientInstrumentation.java", "diffHunk": "@@ -172,16 +171,14 @@ public ApacheHttpClientInstrumentation() {\n \n   public static class HelperMethods {\n     public static SpanWithScope doMethodEnter(final HttpUriRequest request) {\n-      final Span span =\n-          TRACER.spanBuilder(DECORATE.spanNameForRequest(request)).setSpanKind(CLIENT).startSpan();\n+      final Span span = DECORATE.getOrCreateSpan(request, TRACER);\n \n       DECORATE.afterStart(span);\n       DECORATE.onRequest(span, request);\n \n-      final Context context = withSpan(span, Context.current());\n-      final boolean awsClientCall = request.getHeaders(\"amz-sdk-invocation-id\").length > 0;\n-      // AWS calls are often signed, so we can't add headers without breaking the signature.\n-      if (!awsClientCall) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NDIxNg=="}, "originalCommit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUyMjY4Ng==", "bodyText": "Yup the tests cover it. It's how I found this line of code :)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r436522686", "createdAt": "2020-06-08T08:08:14Z", "author": {"login": "anuraaga"}, "path": "instrumentation/apache-httpclient/apache-httpclient-4.0/src/main/java/io/opentelemetry/auto/instrumentation/apachehttpclient/v4_0/ApacheHttpClientInstrumentation.java", "diffHunk": "@@ -172,16 +171,14 @@ public ApacheHttpClientInstrumentation() {\n \n   public static class HelperMethods {\n     public static SpanWithScope doMethodEnter(final HttpUriRequest request) {\n-      final Span span =\n-          TRACER.spanBuilder(DECORATE.spanNameForRequest(request)).setSpanKind(CLIENT).startSpan();\n+      final Span span = DECORATE.getOrCreateSpan(request, TRACER);\n \n       DECORATE.afterStart(span);\n       DECORATE.onRequest(span, request);\n \n-      final Context context = withSpan(span, Context.current());\n-      final boolean awsClientCall = request.getHeaders(\"amz-sdk-invocation-id\").length > 0;\n-      // AWS calls are often signed, so we can't add headers without breaking the signature.\n-      if (!awsClientCall) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NDIxNg=="}, "originalCommit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNDU0NzA1OnYy", "diffSide": "RIGHT", "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQyMToyNTozMVrOGeEhXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNjo0Mzo1MVrOGgQ8jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE4NDU0MA==", "bodyText": "It looks like this is only called with Context.current(), so maybe this method isn't needed?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r434184540", "createdAt": "2020-06-02T21:25:31Z", "author": {"login": "trask"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "diffHunk": "@@ -15,10 +15,51 @@\n  */\n package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n \n+import io.grpc.Context;\n+import io.opentelemetry.context.ContextUtils;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.DefaultSpan;\n import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n \n public abstract class ClientDecorator extends BaseDecorator {\n \n+  // Keeps track of the client span in a subtree corresponding to a client request.\n+  private static final Context.Key<Span> CONTEXT_CLIENT_SPAN_KEY =\n+      Context.key(\"opentelemetry-trace-auto-client-span-key\");\n+\n+  public static Scope currentContextWith(final Span clientSpan) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.currentContextWith(clientSpan);\n+    }\n+    return ContextUtils.withScopedContext(\n+        TracingContextUtils.withSpan(\n+            clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan)));\n+  }\n+\n+  public static Context withSpan(final Span clientSpan, final Context context) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ1Mjk0OQ==", "bodyText": "I noticed the same lack of symmetry in TracingContextUtils and followed the pattern. Let me know if it's worth diverging.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r436452949", "createdAt": "2020-06-08T04:36:37Z", "author": {"login": "anuraaga"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "diffHunk": "@@ -15,10 +15,51 @@\n  */\n package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n \n+import io.grpc.Context;\n+import io.opentelemetry.context.ContextUtils;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.DefaultSpan;\n import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n \n public abstract class ClientDecorator extends BaseDecorator {\n \n+  // Keeps track of the client span in a subtree corresponding to a client request.\n+  private static final Context.Key<Span> CONTEXT_CLIENT_SPAN_KEY =\n+      Context.key(\"opentelemetry-trace-auto-client-span-key\");\n+\n+  public static Scope currentContextWith(final Span clientSpan) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.currentContextWith(clientSpan);\n+    }\n+    return ContextUtils.withScopedContext(\n+        TracingContextUtils.withSpan(\n+            clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan)));\n+  }\n+\n+  public static Context withSpan(final Span clientSpan, final Context context) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE4NDU0MA=="}, "originalCommit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NTI2Mw==", "bodyText": "io.opentelemetry.trace.TracingContextUtils#withSpan can potentially be called with contexts other than current during context extraction via io.opentelemetry.trace.propagation.HttpTraceContext#extract method. This client decorator is not general purpose util, but more specific one. Thus I think we indeed can merge these two methods together.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r436485263", "createdAt": "2020-06-08T06:43:51Z", "author": {"login": "iNikem"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "diffHunk": "@@ -15,10 +15,51 @@\n  */\n package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n \n+import io.grpc.Context;\n+import io.opentelemetry.context.ContextUtils;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.DefaultSpan;\n import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n \n public abstract class ClientDecorator extends BaseDecorator {\n \n+  // Keeps track of the client span in a subtree corresponding to a client request.\n+  private static final Context.Key<Span> CONTEXT_CLIENT_SPAN_KEY =\n+      Context.key(\"opentelemetry-trace-auto-client-span-key\");\n+\n+  public static Scope currentContextWith(final Span clientSpan) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.currentContextWith(clientSpan);\n+    }\n+    return ContextUtils.withScopedContext(\n+        TracingContextUtils.withSpan(\n+            clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan)));\n+  }\n+\n+  public static Context withSpan(final Span clientSpan, final Context context) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE4NDU0MA=="}, "originalCommit": {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxOTE0NDUyOnYy", "diffSide": "RIGHT", "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNjo0NDo1M1rOGgQ97g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNjo0NDo1M1rOGgQ97g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NTYxNA==", "bodyText": "I would extract common call to TracingContextUtils.withSpan from the if above.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r436485614", "createdAt": "2020-06-08T06:44:53Z", "author": {"login": "iNikem"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "diffHunk": "@@ -15,10 +15,59 @@\n  */\n package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n \n+import io.grpc.Context;\n+import io.opentelemetry.context.ContextUtils;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.DefaultSpan;\n import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n \n public abstract class ClientDecorator extends BaseDecorator {\n \n+  // Keeps track of the client span in a subtree corresponding to a client request.\n+  // Visible for testing\n+  static final Context.Key<Span> CONTEXT_CLIENT_SPAN_KEY =\n+      Context.key(\"opentelemetry-trace-auto-client-span-key\");\n+\n+  /**\n+   * Creates a {@link Context} with the provided {@link Span} and sets it as the current {@link\n+   * Context}\n+   *\n+   * @return a {@link Scope} that will restore the previous context. All callers of this method must\n+   *     also call {@link Scope#close()} when this next context is no longer needed.\n+   */\n+  public static Scope currentContextWith(final Span clientSpan) {\n+    return ContextUtils.withScopedContext(withSpan(clientSpan, Context.current()));\n+  }\n+\n+  /** Returns a new {@link Context} forked from {@code context} with the {@link Span} set. */\n+  public static Context withSpan(final Span clientSpan, final Context context) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.withSpan(clientSpan, context);\n+    }\n+    return TracingContextUtils.withSpan(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9051e500537a0ff117ae71141c2e62057c8ff6c0"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxOTE1NzIxOnYy", "diffSide": "RIGHT", "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNjo0OTo0NlrOGgRFQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwODoxMDozNVrOGgTTVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NzQ4OQ==", "bodyText": "Here is the interesting question: should we return clientSpan from here? This way lower level instrumentations can fill in e.g. net.* attributes", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r436487489", "createdAt": "2020-06-08T06:49:46Z", "author": {"login": "iNikem"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "diffHunk": "@@ -15,10 +15,59 @@\n  */\n package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n \n+import io.grpc.Context;\n+import io.opentelemetry.context.ContextUtils;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.DefaultSpan;\n import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n \n public abstract class ClientDecorator extends BaseDecorator {\n \n+  // Keeps track of the client span in a subtree corresponding to a client request.\n+  // Visible for testing\n+  static final Context.Key<Span> CONTEXT_CLIENT_SPAN_KEY =\n+      Context.key(\"opentelemetry-trace-auto-client-span-key\");\n+\n+  /**\n+   * Creates a {@link Context} with the provided {@link Span} and sets it as the current {@link\n+   * Context}\n+   *\n+   * @return a {@link Scope} that will restore the previous context. All callers of this method must\n+   *     also call {@link Scope#close()} when this next context is no longer needed.\n+   */\n+  public static Scope currentContextWith(final Span clientSpan) {\n+    return ContextUtils.withScopedContext(withSpan(clientSpan, Context.current()));\n+  }\n+\n+  /** Returns a new {@link Context} forked from {@code context} with the {@link Span} set. */\n+  public static Context withSpan(final Span clientSpan, final Context context) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.withSpan(clientSpan, context);\n+    }\n+    return TracingContextUtils.withSpan(\n+        clientSpan, context.withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan));\n+  }\n+\n+  /**\n+   * Returns a new client {@link Span} if there is no client {@link Span} in the current {@link\n+   * Context}, or an invalid {@link Span} otherwise.\n+   */\n+  public static Span getOrCreateSpan(String name, Tracer tracer) {\n+    final Context context = Context.current();\n+    final Span clientSpan = CONTEXT_CLIENT_SPAN_KEY.get(context);\n+\n+    if (clientSpan != null) {\n+      // We don't want to create two client spans for a given client call, suppress inner spans.\n+      return DefaultSpan.getInvalid();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9051e500537a0ff117ae71141c2e62057c8ff6c0"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUyMjE3Mw==", "bodyText": "Returning the span as is is dangerous due to methods like .end. I think we should return a wrapper that guards against these, but am thinking of prototyping such in a followup. But let me know if it seems better here.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r436522173", "createdAt": "2020-06-08T08:07:15Z", "author": {"login": "anuraaga"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "diffHunk": "@@ -15,10 +15,59 @@\n  */\n package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n \n+import io.grpc.Context;\n+import io.opentelemetry.context.ContextUtils;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.DefaultSpan;\n import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n \n public abstract class ClientDecorator extends BaseDecorator {\n \n+  // Keeps track of the client span in a subtree corresponding to a client request.\n+  // Visible for testing\n+  static final Context.Key<Span> CONTEXT_CLIENT_SPAN_KEY =\n+      Context.key(\"opentelemetry-trace-auto-client-span-key\");\n+\n+  /**\n+   * Creates a {@link Context} with the provided {@link Span} and sets it as the current {@link\n+   * Context}\n+   *\n+   * @return a {@link Scope} that will restore the previous context. All callers of this method must\n+   *     also call {@link Scope#close()} when this next context is no longer needed.\n+   */\n+  public static Scope currentContextWith(final Span clientSpan) {\n+    return ContextUtils.withScopedContext(withSpan(clientSpan, Context.current()));\n+  }\n+\n+  /** Returns a new {@link Context} forked from {@code context} with the {@link Span} set. */\n+  public static Context withSpan(final Span clientSpan, final Context context) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.withSpan(clientSpan, context);\n+    }\n+    return TracingContextUtils.withSpan(\n+        clientSpan, context.withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan));\n+  }\n+\n+  /**\n+   * Returns a new client {@link Span} if there is no client {@link Span} in the current {@link\n+   * Context}, or an invalid {@link Span} otherwise.\n+   */\n+  public static Span getOrCreateSpan(String name, Tracer tracer) {\n+    final Context context = Context.current();\n+    final Span clientSpan = CONTEXT_CLIENT_SPAN_KEY.get(context);\n+\n+    if (clientSpan != null) {\n+      // We don't want to create two client spans for a given client call, suppress inner spans.\n+      return DefaultSpan.getInvalid();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NzQ4OQ=="}, "originalCommit": {"oid": "9051e500537a0ff117ae71141c2e62057c8ff6c0"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUyMzg2MA==", "bodyText": "Aah, makes sense.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r436523860", "createdAt": "2020-06-08T08:10:35Z", "author": {"login": "iNikem"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "diffHunk": "@@ -15,10 +15,59 @@\n  */\n package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n \n+import io.grpc.Context;\n+import io.opentelemetry.context.ContextUtils;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.DefaultSpan;\n import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n \n public abstract class ClientDecorator extends BaseDecorator {\n \n+  // Keeps track of the client span in a subtree corresponding to a client request.\n+  // Visible for testing\n+  static final Context.Key<Span> CONTEXT_CLIENT_SPAN_KEY =\n+      Context.key(\"opentelemetry-trace-auto-client-span-key\");\n+\n+  /**\n+   * Creates a {@link Context} with the provided {@link Span} and sets it as the current {@link\n+   * Context}\n+   *\n+   * @return a {@link Scope} that will restore the previous context. All callers of this method must\n+   *     also call {@link Scope#close()} when this next context is no longer needed.\n+   */\n+  public static Scope currentContextWith(final Span clientSpan) {\n+    return ContextUtils.withScopedContext(withSpan(clientSpan, Context.current()));\n+  }\n+\n+  /** Returns a new {@link Context} forked from {@code context} with the {@link Span} set. */\n+  public static Context withSpan(final Span clientSpan, final Context context) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.withSpan(clientSpan, context);\n+    }\n+    return TracingContextUtils.withSpan(\n+        clientSpan, context.withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan));\n+  }\n+\n+  /**\n+   * Returns a new client {@link Span} if there is no client {@link Span} in the current {@link\n+   * Context}, or an invalid {@link Span} otherwise.\n+   */\n+  public static Span getOrCreateSpan(String name, Tracer tracer) {\n+    final Context context = Context.current();\n+    final Span clientSpan = CONTEXT_CLIENT_SPAN_KEY.get(context);\n+\n+    if (clientSpan != null) {\n+      // We don't want to create two client spans for a given client call, suppress inner spans.\n+      return DefaultSpan.getInvalid();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NzQ4OQ=="}, "originalCommit": {"oid": "9051e500537a0ff117ae71141c2e62057c8ff6c0"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxOTE1OTI0OnYy", "diffSide": "RIGHT", "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/HttpClientDecorator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNjo1MDozMFrOGgRGhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwODowNzo0N1rOGgTNwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NzgxNA==", "bodyText": "Can this be made private/protected now?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r436487814", "createdAt": "2020-06-08T06:50:30Z", "author": {"login": "iNikem"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/HttpClientDecorator.java", "diffHunk": "@@ -35,6 +36,10 @@\n \n   protected abstract Integer status(RESPONSE response);\n \n+  public Span getOrCreateSpan(REQUEST request, Tracer tracer) {\n+    return getOrCreateSpan(spanNameForRequest(request), tracer);\n+  }\n+\n   public String spanNameForRequest(final REQUEST request) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9051e500537a0ff117ae71141c2e62057c8ff6c0"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUyMjQzMg==", "bodyText": "Think it can when we migrate all the instrumentation to use getOrCeateSpan. Another PR?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r436522432", "createdAt": "2020-06-08T08:07:47Z", "author": {"login": "anuraaga"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/HttpClientDecorator.java", "diffHunk": "@@ -35,6 +36,10 @@\n \n   protected abstract Integer status(RESPONSE response);\n \n+  public Span getOrCreateSpan(REQUEST request, Tracer tracer) {\n+    return getOrCreateSpan(spanNameForRequest(request), tracer);\n+  }\n+\n   public String spanNameForRequest(final REQUEST request) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NzgxNA=="}, "originalCommit": {"oid": "9051e500537a0ff117ae71141c2e62057c8ff6c0"}, "originalPosition": 16}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 460, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}