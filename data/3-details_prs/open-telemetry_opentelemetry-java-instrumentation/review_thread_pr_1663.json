{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIyNjQ5MjIx", "number": 1663, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxOToxOToyM1rOE6LdtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxOToyOToyOVrOE6LtHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NDQwNjkzOnYy", "diffSide": "RIGHT", "path": "instrumentation/mongo/mongo-common/src/main/java/io/opentelemetry/javaagent/instrumentation/mongo/MongoClientTracer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxOToxOToyM1rOH1FWzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxOToxOToyM1rOH1FWzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQyNDMzNA==", "bodyText": "I got this default from the SqlNormalizer", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1663#discussion_r525424334", "createdAt": "2020-11-17T19:19:23Z", "author": {"login": "jyemin"}, "path": "instrumentation/mongo/mongo-common/src/main/java/io/opentelemetry/javaagent/instrumentation/mongo/MongoClientTracer.java", "diffHunk": "@@ -12,18 +12,35 @@\n import io.opentelemetry.api.trace.attributes.SemanticAttributes;\n import io.opentelemetry.instrumentation.api.tracer.DatabaseClientTracer;\n import io.opentelemetry.javaagent.instrumentation.api.db.DbSystem;\n+import java.io.StringWriter;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n import java.net.InetSocketAddress;\n import java.util.Arrays;\n-import java.util.List;\n import java.util.Map;\n+import java.util.Optional;\n import org.bson.BsonArray;\n import org.bson.BsonDocument;\n-import org.bson.BsonString;\n import org.bson.BsonValue;\n+import org.bson.json.JsonMode;\n+import org.bson.json.JsonWriter;\n+import org.bson.json.JsonWriterSettings;\n \n public class MongoClientTracer extends DatabaseClientTracer<CommandStartedEvent, BsonDocument> {\n   private static final MongoClientTracer TRACER = new MongoClientTracer();\n \n+  private final int maxNormalizedQueryLength;\n+  private final JsonWriterSettings jsonWriterSettings;\n+\n+  public MongoClientTracer() {\n+    this(32 * 1024);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0722efe8b0ab19b4bbd6d7f62f5c5a81609819e6"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NDQxMjc1OnYy", "diffSide": "RIGHT", "path": "instrumentation/mongo/mongo-common/src/main/java/io/opentelemetry/javaagent/instrumentation/mongo/MongoClientTracer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxOToyMDozOVrOH1FaJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxOToyMDozOVrOH1FaJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQyNTE5MA==", "bodyText": "This method was added in the 3.7 release of the driver so accessing it reflectively", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1663#discussion_r525425190", "createdAt": "2020-11-17T19:20:39Z", "author": {"login": "jyemin"}, "path": "instrumentation/mongo/mongo-common/src/main/java/io/opentelemetry/javaagent/instrumentation/mongo/MongoClientTracer.java", "diffHunk": "@@ -80,54 +97,111 @@ protected String dbConnectionString(CommandStartedEvent event) {\n     return null;\n   }\n \n-  @Override\n-  public String normalizeQuery(BsonDocument statement) {\n-    // scrub the Mongo command so that parameters are removed from the string\n-    BsonDocument scrubbed = scrub(statement);\n-    return scrubbed.toString();\n+  private static final Method IS_TRUNCATED_METHOD;\n+\n+  static {\n+    IS_TRUNCATED_METHOD = Arrays.stream(JsonWriter.class.getMethods())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0722efe8b0ab19b4bbd6d7f62f5c5a81609819e6"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NDQyMDk2OnYy", "diffSide": "RIGHT", "path": "instrumentation/mongo/mongo-common/src/main/java/io/opentelemetry/javaagent/instrumentation/mongo/MongoClientTracer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxOToyMjo1M1rOH1FfNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwNTozODoxNlrOH1d5Tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQyNjQ4Ng==", "bodyText": "Question for reviewers: should we append a \"...\" to the query or just cut it off?  Or do we need to make sure that even when truncated it remains valid JSON?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1663#discussion_r525426486", "createdAt": "2020-11-17T19:22:53Z", "author": {"login": "jyemin"}, "path": "instrumentation/mongo/mongo-common/src/main/java/io/opentelemetry/javaagent/instrumentation/mongo/MongoClientTracer.java", "diffHunk": "@@ -80,54 +97,111 @@ protected String dbConnectionString(CommandStartedEvent event) {\n     return null;\n   }\n \n-  @Override\n-  public String normalizeQuery(BsonDocument statement) {\n-    // scrub the Mongo command so that parameters are removed from the string\n-    BsonDocument scrubbed = scrub(statement);\n-    return scrubbed.toString();\n+  private static final Method IS_TRUNCATED_METHOD;\n+\n+  static {\n+    IS_TRUNCATED_METHOD = Arrays.stream(JsonWriter.class.getMethods())\n+        .filter(method -> method.getName().equals(\"isTruncated\")).findFirst().orElse(null);\n   }\n \n-  /**\n-   * The values of these mongo fields will not be scrubbed out. This allows the non-sensitive\n-   * collection names to be captured.\n-   */\n-  private static final List<String> UNSCRUBBED_FIELDS =\n-      Arrays.asList(\"ordered\", \"insert\", \"count\", \"find\", \"create\");\n+  private JsonWriterSettings createJsonWriterSettings(int maxNormalizedQueryLength)  {\n+    JsonWriterSettings settings = new JsonWriterSettings(false);\n+    try {\n+      // The static JsonWriterSettings.builder() method was introduced in the 3.5 release\n+      Optional<Method> buildMethod = Arrays.stream(JsonWriterSettings.class.getMethods())\n+          .filter(method -> method.getName().equals(\"builder\")).findFirst();\n+      if (buildMethod.isPresent()) {\n+        Class<?> builderClass = buildMethod.get().getReturnType();\n+        Object builder = buildMethod.get().invoke(null, (Object[]) null);\n+\n+        // The JsonWriterSettings.Builder.indent method was introduced in the 3.5 release,\n+        // but checking anyway\n+        Optional<Method> indentMethod = Arrays.stream(builderClass.getMethods())\n+            .filter(method -> method.getName().equals(\"indent\"))\n+            .findFirst();\n+        if (indentMethod.isPresent()) {\n+          indentMethod.get().invoke(builder, false);\n+        }\n \n-  private static final BsonValue HIDDEN_CHAR = new BsonString(\"?\");\n+        // The JsonWriterSettings.Builder.maxLength method was introduced in the 3.7 release\n+        Optional<Method> maxLengthMethod = Arrays.stream(builderClass.getMethods())\n+            .filter(method -> method.getName().equals(\"maxLength\"))\n+            .findFirst();\n+        if (maxLengthMethod.isPresent()) {\n+          maxLengthMethod.get().invoke(builder, maxNormalizedQueryLength);\n+        }\n+        settings = (JsonWriterSettings) builderClass.getMethod(\"build\", (Class<?>[]) null)\n+            .invoke(builder, (Object[]) null);\n+      }\n+    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException ignored) {\n+    }\n+    return settings;\n+  }\n \n-  private static BsonDocument scrub(BsonDocument origin) {\n-    BsonDocument scrub = new BsonDocument();\n+  @Override\n+  public String normalizeQuery(BsonDocument command) {\n+    StringWriter stringWriter = new StringWriter(128);\n+    writeScrubbed(command, new JsonWriter(stringWriter, jsonWriterSettings), true);\n+    // If using MongoDB driver >= 3.7, the substring invocation will be a no-op due to use of\n+    // JsonWriterSettings.Builder.maxLength in the static initializer for JSON_WRITER_SETTINGS\n+    return stringWriter.getBuffer()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0722efe8b0ab19b4bbd6d7f62f5c5a81609819e6"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTgyNjM4Mg==", "bodyText": "it looks like SQL just cuts off at the limit like here, so seems good", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1663#discussion_r525826382", "createdAt": "2020-11-18T05:38:16Z", "author": {"login": "trask"}, "path": "instrumentation/mongo/mongo-common/src/main/java/io/opentelemetry/javaagent/instrumentation/mongo/MongoClientTracer.java", "diffHunk": "@@ -80,54 +97,111 @@ protected String dbConnectionString(CommandStartedEvent event) {\n     return null;\n   }\n \n-  @Override\n-  public String normalizeQuery(BsonDocument statement) {\n-    // scrub the Mongo command so that parameters are removed from the string\n-    BsonDocument scrubbed = scrub(statement);\n-    return scrubbed.toString();\n+  private static final Method IS_TRUNCATED_METHOD;\n+\n+  static {\n+    IS_TRUNCATED_METHOD = Arrays.stream(JsonWriter.class.getMethods())\n+        .filter(method -> method.getName().equals(\"isTruncated\")).findFirst().orElse(null);\n   }\n \n-  /**\n-   * The values of these mongo fields will not be scrubbed out. This allows the non-sensitive\n-   * collection names to be captured.\n-   */\n-  private static final List<String> UNSCRUBBED_FIELDS =\n-      Arrays.asList(\"ordered\", \"insert\", \"count\", \"find\", \"create\");\n+  private JsonWriterSettings createJsonWriterSettings(int maxNormalizedQueryLength)  {\n+    JsonWriterSettings settings = new JsonWriterSettings(false);\n+    try {\n+      // The static JsonWriterSettings.builder() method was introduced in the 3.5 release\n+      Optional<Method> buildMethod = Arrays.stream(JsonWriterSettings.class.getMethods())\n+          .filter(method -> method.getName().equals(\"builder\")).findFirst();\n+      if (buildMethod.isPresent()) {\n+        Class<?> builderClass = buildMethod.get().getReturnType();\n+        Object builder = buildMethod.get().invoke(null, (Object[]) null);\n+\n+        // The JsonWriterSettings.Builder.indent method was introduced in the 3.5 release,\n+        // but checking anyway\n+        Optional<Method> indentMethod = Arrays.stream(builderClass.getMethods())\n+            .filter(method -> method.getName().equals(\"indent\"))\n+            .findFirst();\n+        if (indentMethod.isPresent()) {\n+          indentMethod.get().invoke(builder, false);\n+        }\n \n-  private static final BsonValue HIDDEN_CHAR = new BsonString(\"?\");\n+        // The JsonWriterSettings.Builder.maxLength method was introduced in the 3.7 release\n+        Optional<Method> maxLengthMethod = Arrays.stream(builderClass.getMethods())\n+            .filter(method -> method.getName().equals(\"maxLength\"))\n+            .findFirst();\n+        if (maxLengthMethod.isPresent()) {\n+          maxLengthMethod.get().invoke(builder, maxNormalizedQueryLength);\n+        }\n+        settings = (JsonWriterSettings) builderClass.getMethod(\"build\", (Class<?>[]) null)\n+            .invoke(builder, (Object[]) null);\n+      }\n+    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException ignored) {\n+    }\n+    return settings;\n+  }\n \n-  private static BsonDocument scrub(BsonDocument origin) {\n-    BsonDocument scrub = new BsonDocument();\n+  @Override\n+  public String normalizeQuery(BsonDocument command) {\n+    StringWriter stringWriter = new StringWriter(128);\n+    writeScrubbed(command, new JsonWriter(stringWriter, jsonWriterSettings), true);\n+    // If using MongoDB driver >= 3.7, the substring invocation will be a no-op due to use of\n+    // JsonWriterSettings.Builder.maxLength in the static initializer for JSON_WRITER_SETTINGS\n+    return stringWriter.getBuffer()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQyNjQ4Ng=="}, "originalCommit": {"oid": "0722efe8b0ab19b4bbd6d7f62f5c5a81609819e6"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NDQ0NjM4OnYy", "diffSide": "RIGHT", "path": "instrumentation/mongo/mongo-common/src/main/java/io/opentelemetry/javaagent/instrumentation/mongo/MongoClientTracer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxOToyOToyOVrOH1FvNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwNzo0OToyNVrOH1gyqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQzMDU4MA==", "bodyText": "Question for reviewers: since we already extract the collection name into the Span, is it even necessary to preserve it in the scrubbed command?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1663#discussion_r525430580", "createdAt": "2020-11-17T19:29:29Z", "author": {"login": "jyemin"}, "path": "instrumentation/mongo/mongo-common/src/main/java/io/opentelemetry/javaagent/instrumentation/mongo/MongoClientTracer.java", "diffHunk": "@@ -80,54 +97,111 @@ protected String dbConnectionString(CommandStartedEvent event) {\n     return null;\n   }\n \n-  @Override\n-  public String normalizeQuery(BsonDocument statement) {\n-    // scrub the Mongo command so that parameters are removed from the string\n-    BsonDocument scrubbed = scrub(statement);\n-    return scrubbed.toString();\n+  private static final Method IS_TRUNCATED_METHOD;\n+\n+  static {\n+    IS_TRUNCATED_METHOD = Arrays.stream(JsonWriter.class.getMethods())\n+        .filter(method -> method.getName().equals(\"isTruncated\")).findFirst().orElse(null);\n   }\n \n-  /**\n-   * The values of these mongo fields will not be scrubbed out. This allows the non-sensitive\n-   * collection names to be captured.\n-   */\n-  private static final List<String> UNSCRUBBED_FIELDS =\n-      Arrays.asList(\"ordered\", \"insert\", \"count\", \"find\", \"create\");\n+  private JsonWriterSettings createJsonWriterSettings(int maxNormalizedQueryLength)  {\n+    JsonWriterSettings settings = new JsonWriterSettings(false);\n+    try {\n+      // The static JsonWriterSettings.builder() method was introduced in the 3.5 release\n+      Optional<Method> buildMethod = Arrays.stream(JsonWriterSettings.class.getMethods())\n+          .filter(method -> method.getName().equals(\"builder\")).findFirst();\n+      if (buildMethod.isPresent()) {\n+        Class<?> builderClass = buildMethod.get().getReturnType();\n+        Object builder = buildMethod.get().invoke(null, (Object[]) null);\n+\n+        // The JsonWriterSettings.Builder.indent method was introduced in the 3.5 release,\n+        // but checking anyway\n+        Optional<Method> indentMethod = Arrays.stream(builderClass.getMethods())\n+            .filter(method -> method.getName().equals(\"indent\"))\n+            .findFirst();\n+        if (indentMethod.isPresent()) {\n+          indentMethod.get().invoke(builder, false);\n+        }\n \n-  private static final BsonValue HIDDEN_CHAR = new BsonString(\"?\");\n+        // The JsonWriterSettings.Builder.maxLength method was introduced in the 3.7 release\n+        Optional<Method> maxLengthMethod = Arrays.stream(builderClass.getMethods())\n+            .filter(method -> method.getName().equals(\"maxLength\"))\n+            .findFirst();\n+        if (maxLengthMethod.isPresent()) {\n+          maxLengthMethod.get().invoke(builder, maxNormalizedQueryLength);\n+        }\n+        settings = (JsonWriterSettings) builderClass.getMethod(\"build\", (Class<?>[]) null)\n+            .invoke(builder, (Object[]) null);\n+      }\n+    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException ignored) {\n+    }\n+    return settings;\n+  }\n \n-  private static BsonDocument scrub(BsonDocument origin) {\n-    BsonDocument scrub = new BsonDocument();\n+  @Override\n+  public String normalizeQuery(BsonDocument command) {\n+    StringWriter stringWriter = new StringWriter(128);\n+    writeScrubbed(command, new JsonWriter(stringWriter, jsonWriterSettings), true);\n+    // If using MongoDB driver >= 3.7, the substring invocation will be a no-op due to use of\n+    // JsonWriterSettings.Builder.maxLength in the static initializer for JSON_WRITER_SETTINGS\n+    return stringWriter.getBuffer()\n+        .substring(0, Math.min(maxNormalizedQueryLength, stringWriter.getBuffer().length()));\n+  }\n+\n+  private static final String HIDDEN_CHAR = \"?\";\n+\n+  private static boolean writeScrubbed(BsonDocument origin, JsonWriter writer, boolean isRoot) {\n+    writer.writeStartDocument();\n+    boolean firstField = true;\n     for (Map.Entry<String, BsonValue> entry : origin.entrySet()) {\n-      if (UNSCRUBBED_FIELDS.contains(entry.getKey()) && entry.getValue().isString()) {\n-        scrub.put(entry.getKey(), entry.getValue());\n+      writer.writeName(entry.getKey());\n+      // the first field of the root document is the command name, so we preserve its value", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0722efe8b0ab19b4bbd6d7f62f5c5a81609819e6"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg3MzgzMw==", "bodyText": "preserving it seems good, e.g. table names are preserved when scrubbing sql queries", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1663#discussion_r525873833", "createdAt": "2020-11-18T07:49:25Z", "author": {"login": "trask"}, "path": "instrumentation/mongo/mongo-common/src/main/java/io/opentelemetry/javaagent/instrumentation/mongo/MongoClientTracer.java", "diffHunk": "@@ -80,54 +97,111 @@ protected String dbConnectionString(CommandStartedEvent event) {\n     return null;\n   }\n \n-  @Override\n-  public String normalizeQuery(BsonDocument statement) {\n-    // scrub the Mongo command so that parameters are removed from the string\n-    BsonDocument scrubbed = scrub(statement);\n-    return scrubbed.toString();\n+  private static final Method IS_TRUNCATED_METHOD;\n+\n+  static {\n+    IS_TRUNCATED_METHOD = Arrays.stream(JsonWriter.class.getMethods())\n+        .filter(method -> method.getName().equals(\"isTruncated\")).findFirst().orElse(null);\n   }\n \n-  /**\n-   * The values of these mongo fields will not be scrubbed out. This allows the non-sensitive\n-   * collection names to be captured.\n-   */\n-  private static final List<String> UNSCRUBBED_FIELDS =\n-      Arrays.asList(\"ordered\", \"insert\", \"count\", \"find\", \"create\");\n+  private JsonWriterSettings createJsonWriterSettings(int maxNormalizedQueryLength)  {\n+    JsonWriterSettings settings = new JsonWriterSettings(false);\n+    try {\n+      // The static JsonWriterSettings.builder() method was introduced in the 3.5 release\n+      Optional<Method> buildMethod = Arrays.stream(JsonWriterSettings.class.getMethods())\n+          .filter(method -> method.getName().equals(\"builder\")).findFirst();\n+      if (buildMethod.isPresent()) {\n+        Class<?> builderClass = buildMethod.get().getReturnType();\n+        Object builder = buildMethod.get().invoke(null, (Object[]) null);\n+\n+        // The JsonWriterSettings.Builder.indent method was introduced in the 3.5 release,\n+        // but checking anyway\n+        Optional<Method> indentMethod = Arrays.stream(builderClass.getMethods())\n+            .filter(method -> method.getName().equals(\"indent\"))\n+            .findFirst();\n+        if (indentMethod.isPresent()) {\n+          indentMethod.get().invoke(builder, false);\n+        }\n \n-  private static final BsonValue HIDDEN_CHAR = new BsonString(\"?\");\n+        // The JsonWriterSettings.Builder.maxLength method was introduced in the 3.7 release\n+        Optional<Method> maxLengthMethod = Arrays.stream(builderClass.getMethods())\n+            .filter(method -> method.getName().equals(\"maxLength\"))\n+            .findFirst();\n+        if (maxLengthMethod.isPresent()) {\n+          maxLengthMethod.get().invoke(builder, maxNormalizedQueryLength);\n+        }\n+        settings = (JsonWriterSettings) builderClass.getMethod(\"build\", (Class<?>[]) null)\n+            .invoke(builder, (Object[]) null);\n+      }\n+    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException ignored) {\n+    }\n+    return settings;\n+  }\n \n-  private static BsonDocument scrub(BsonDocument origin) {\n-    BsonDocument scrub = new BsonDocument();\n+  @Override\n+  public String normalizeQuery(BsonDocument command) {\n+    StringWriter stringWriter = new StringWriter(128);\n+    writeScrubbed(command, new JsonWriter(stringWriter, jsonWriterSettings), true);\n+    // If using MongoDB driver >= 3.7, the substring invocation will be a no-op due to use of\n+    // JsonWriterSettings.Builder.maxLength in the static initializer for JSON_WRITER_SETTINGS\n+    return stringWriter.getBuffer()\n+        .substring(0, Math.min(maxNormalizedQueryLength, stringWriter.getBuffer().length()));\n+  }\n+\n+  private static final String HIDDEN_CHAR = \"?\";\n+\n+  private static boolean writeScrubbed(BsonDocument origin, JsonWriter writer, boolean isRoot) {\n+    writer.writeStartDocument();\n+    boolean firstField = true;\n     for (Map.Entry<String, BsonValue> entry : origin.entrySet()) {\n-      if (UNSCRUBBED_FIELDS.contains(entry.getKey()) && entry.getValue().isString()) {\n-        scrub.put(entry.getKey(), entry.getValue());\n+      writer.writeName(entry.getKey());\n+      // the first field of the root document is the command name, so we preserve its value", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQzMDU4MA=="}, "originalCommit": {"oid": "0722efe8b0ab19b4bbd6d7f62f5c5a81609819e6"}, "originalPosition": 116}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4613, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}