{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM1MDEyMjk1", "number": 535, "title": "Add lettuce 5.2 instrumentation that uses lettuce's native tracing functionality.", "bodyText": "If muzzle lets me through in one shot I'd be amazed :)\nWhile Tracing was added in 5.1, including the command was added in 5.2, and it doesn't seeem worth branching on this since this is new instrumentation, I just went ahead and targeted 5.2.\nDifferences in tracing\n\nconnection and some system commands aren't traced.\nnet / command tags are filled in. A couple of events that lettuce provides are too\nNo corner cases, while I preserved the async/reactive tests, there isn't as much value since there is no special-casing for the APIs\n\nFixes #408\nFixes #504", "createdAt": "2020-06-16T06:54:34Z", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535", "merged": true, "mergeCommit": {"oid": "9a2a0b5de97ee67e8cf1676c6f71e188bc6c4107"}, "closed": true, "closedAt": "2020-06-18T15:22:46Z", "author": {"login": "anuraaga"}, "timelineItems": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcqJg-iAH2gAyNDM1MDEyMjk1OjRlZDc0MzgyOWUxZWM0YWQ0NGM5ZmJlNTdhZDIzOGE0Mzc3YTI4NDA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcsgGTmAFqTQzMzM5NDQxNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "4ed743829e1ec4ad44c9fbe57ad238a4377a2840", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/4ed743829e1ec4ad44c9fbe57ad238a4377a2840", "committedDate": "2020-06-11T07:56:04Z", "message": "Copy Lettuce 5.0 to start 5.1 instrumentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "51ae5740954ea8071eb5034b8f8aacd71e60383d", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/51ae5740954ea8071eb5034b8f8aacd71e60383d", "committedDate": "2020-06-11T08:25:20Z", "message": "Begin tracing adapter implementation\n\nCo-authored-by: Dustin Neray <dustin.neray@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b73576bc9a373331314a50a89f654cfd2cd35b0a", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/b73576bc9a373331314a50a89f654cfd2cd35b0a", "committedDate": "2020-06-11T08:43:56Z", "message": "Set floor to 5.2 instead"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "80fb2c551ab68c8321b756094c0131918a5dc403", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/80fb2c551ab68c8321b756094c0131918a5dc403", "committedDate": "2020-06-12T04:57:31Z", "message": "Move around"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87e8547d14b6ec66592f81e3fc0694d69621da7c", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/87e8547d14b6ec66592f81e3fc0694d69621da7c", "committedDate": "2020-06-16T06:44:36Z", "message": "Finish"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMzQ4NzI2", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535#pullrequestreview-431348726", "createdAt": "2020-06-16T10:00:17Z", "commit": {"oid": "87e8547d14b6ec66592f81e3fc0694d69621da7c"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxMDowMDoxN1rOGkUOZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxMDoyMToyOFrOGkU9Lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDczMzI4Nw==", "bodyText": "Duplicate dep?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535#discussion_r440733287", "createdAt": "2020-06-16T10:00:17Z", "author": {"login": "iNikem"}, "path": "instrumentation/lettuce/lettuce-5.2/lettuce-5.2.gradle", "diffHunk": "@@ -0,0 +1,33 @@\n+// Set properties before any plugins get loaded\n+ext {\n+  minJavaVersionForTests = JavaVersion.VERSION_1_8\n+}\n+\n+apply from: \"${rootDir}/gradle/instrumentation.gradle\"\n+apply plugin: 'org.unbroken-dome.test-sets'\n+\n+muzzle {\n+  pass {\n+    group = \"io.lettuce\"\n+    module = \"lettuce-core\"\n+    versions = \"[5.2.0.RELEASE,)\"\n+    assertInverse = true\n+  }\n+}\n+\n+testSets {\n+  latestDepTest {\n+    dirName = 'test'\n+  }\n+}\n+\n+dependencies {\n+  compileOnly group: 'io.lettuce', name: 'lettuce-core', version: '5.2.0.RELEASE'\n+  compileOnly group: 'io.lettuce', name: 'lettuce-core', version: '5.2.0.RELEASE'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87e8547d14b6ec66592f81e3fc0694d69621da7c"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDczNDQ1NA==", "bodyText": "Do you need this class at all?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535#discussion_r440734454", "createdAt": "2020-06-16T10:02:17Z", "author": {"login": "iNikem"}, "path": "instrumentation/lettuce/lettuce-5.2/src/main/java8/io/opentelemetry/auto/instrumentation/lettuce/v5_2/LettuceClientDecorator.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.auto.instrumentation.lettuce.v5_2;\n+\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.trace.Tracer;\n+\n+// Currently don't use decorator pattern since lifecycle of lettuce Tracing is too different than\n+// what we expect.\n+public class LettuceClientDecorator {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87e8547d14b6ec66592f81e3fc0694d69621da7c"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDczODg3OQ==", "bodyText": "\"this until then\"? :)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535#discussion_r440738879", "createdAt": "2020-06-16T10:10:02Z", "author": {"login": "iNikem"}, "path": "instrumentation/lettuce/lettuce-5.2/src/main/java8/io/opentelemetry/auto/instrumentation/lettuce/v5_2/OpenTelemetryTracing.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.auto.instrumentation.lettuce.v5_2;\n+\n+import static io.opentelemetry.auto.instrumentation.lettuce.v5_2.LettuceClientDecorator.TRACER;\n+\n+import io.grpc.Context;\n+import io.lettuce.core.tracing.TraceContext;\n+import io.lettuce.core.tracing.TraceContextProvider;\n+import io.lettuce.core.tracing.Tracer;\n+import io.lettuce.core.tracing.TracerProvider;\n+import io.lettuce.core.tracing.Tracing;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import reactor.util.annotation.Nullable;\n+\n+public enum OpenTelemetryTracing implements Tracing {\n+  INSTANCE;\n+\n+  @Override\n+  public TracerProvider getTracerProvider() {\n+    return OpenTelemetryTracerProvider.INSTANCE;\n+  }\n+\n+  @Override\n+  public TraceContextProvider initialTraceContextProvider() {\n+    return OpenTelemetryTraceContextProvider.INSTANCE;\n+  }\n+\n+  @Override\n+  public boolean isEnabled() {\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean includeCommandArgsInSpanTags() {\n+    return true;\n+  }\n+\n+  @Override\n+  public Endpoint createEndpoint(SocketAddress socketAddress) {\n+    if (socketAddress instanceof InetSocketAddress) {\n+      InetSocketAddress address = (InetSocketAddress) socketAddress;\n+\n+      return new OpenTelemetryEndpoint(\n+          address.getAddress().getHostAddress(), address.getPort(), address.getHostString());\n+    }\n+    return null;\n+  }\n+\n+  enum OpenTelemetryTracerProvider implements TracerProvider {\n+    INSTANCE;\n+\n+    private final Tracer openTelemetryTracer = new OpenTelemetryTracer();\n+\n+    @Override\n+    public Tracer getTracer() {\n+      return openTelemetryTracer;\n+    }\n+  }\n+\n+  enum OpenTelemetryTraceContextProvider implements TraceContextProvider {\n+    INSTANCE;\n+\n+    @Override\n+    public TraceContext getTraceContext() {\n+      return new OpenTelemetryTraceContext();\n+    }\n+  }\n+\n+  static class OpenTelemetryTraceContext implements TraceContext {\n+    private final Context context;\n+\n+    protected OpenTelemetryTraceContext() {\n+      this.context = Context.current();\n+    }\n+\n+    public Context getContext() {\n+      return context;\n+    }\n+  }\n+\n+  static class OpenTelemetryEndpoint implements Endpoint {\n+    final String ip;\n+    final int port;\n+    @Nullable final String name;\n+\n+    protected OpenTelemetryEndpoint(String ip, int port, @Nullable String name) {\n+      this.ip = ip;\n+      this.port = port;\n+      if (!ip.equals(name)) {\n+        this.name = name;\n+      } else {\n+        this.name = null;\n+      }\n+    }\n+  }\n+\n+  static class OpenTelemetryTracer extends Tracer {\n+\n+    protected OpenTelemetryTracer() {}\n+\n+    @Override\n+    public OpenTelemetrySpan nextSpan() {\n+      return new OpenTelemetrySpan(null);\n+    }\n+\n+    @Override\n+    public OpenTelemetrySpan nextSpan(TraceContext traceContext) {\n+      if (!(traceContext instanceof OpenTelemetryTraceContext)) {\n+        return nextSpan();\n+      }\n+\n+      Context context = ((OpenTelemetryTraceContext) traceContext).getContext();\n+\n+      final io.opentelemetry.trace.Span parent = TracingContextUtils.getSpanWithoutDefault(context);\n+\n+      return new OpenTelemetrySpan(parent);\n+    }\n+  }\n+\n+  // The order that callbacks will be called in or which thread they are called from is not well\n+  // defined. We go ahead and buffer all data until we know we have a span. This implementation is\n+  // particularly safe, synchronizing all accesses. Relying on implementation details would allow\n+  // reducing synchronization but the impact should be minimal.\n+  static class OpenTelemetrySpan extends Tracer.Span {\n+    @Nullable private final Span parent;\n+\n+    @Nullable private OpenTelemetryEndpoint endpoint;\n+    @Nullable private String name;\n+\n+    @Nullable private List<Object> events;\n+    @Nullable private List<String> tags;\n+\n+    @Nullable private Status status;\n+\n+    @Nullable private Span span;\n+\n+    protected OpenTelemetrySpan(@Nullable Span parent) {\n+      this.parent = parent;\n+    }\n+\n+    // Called before start. We need to buffer because this until then.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87e8547d14b6ec66592f81e3fc0694d69621da7c"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDczOTY5Nw==", "bodyText": "If we don't call this, then we may get a span from current Otel context, don't you think?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535#discussion_r440739697", "createdAt": "2020-06-16T10:11:30Z", "author": {"login": "iNikem"}, "path": "instrumentation/lettuce/lettuce-5.2/src/main/java8/io/opentelemetry/auto/instrumentation/lettuce/v5_2/OpenTelemetryTracing.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.auto.instrumentation.lettuce.v5_2;\n+\n+import static io.opentelemetry.auto.instrumentation.lettuce.v5_2.LettuceClientDecorator.TRACER;\n+\n+import io.grpc.Context;\n+import io.lettuce.core.tracing.TraceContext;\n+import io.lettuce.core.tracing.TraceContextProvider;\n+import io.lettuce.core.tracing.Tracer;\n+import io.lettuce.core.tracing.TracerProvider;\n+import io.lettuce.core.tracing.Tracing;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import reactor.util.annotation.Nullable;\n+\n+public enum OpenTelemetryTracing implements Tracing {\n+  INSTANCE;\n+\n+  @Override\n+  public TracerProvider getTracerProvider() {\n+    return OpenTelemetryTracerProvider.INSTANCE;\n+  }\n+\n+  @Override\n+  public TraceContextProvider initialTraceContextProvider() {\n+    return OpenTelemetryTraceContextProvider.INSTANCE;\n+  }\n+\n+  @Override\n+  public boolean isEnabled() {\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean includeCommandArgsInSpanTags() {\n+    return true;\n+  }\n+\n+  @Override\n+  public Endpoint createEndpoint(SocketAddress socketAddress) {\n+    if (socketAddress instanceof InetSocketAddress) {\n+      InetSocketAddress address = (InetSocketAddress) socketAddress;\n+\n+      return new OpenTelemetryEndpoint(\n+          address.getAddress().getHostAddress(), address.getPort(), address.getHostString());\n+    }\n+    return null;\n+  }\n+\n+  enum OpenTelemetryTracerProvider implements TracerProvider {\n+    INSTANCE;\n+\n+    private final Tracer openTelemetryTracer = new OpenTelemetryTracer();\n+\n+    @Override\n+    public Tracer getTracer() {\n+      return openTelemetryTracer;\n+    }\n+  }\n+\n+  enum OpenTelemetryTraceContextProvider implements TraceContextProvider {\n+    INSTANCE;\n+\n+    @Override\n+    public TraceContext getTraceContext() {\n+      return new OpenTelemetryTraceContext();\n+    }\n+  }\n+\n+  static class OpenTelemetryTraceContext implements TraceContext {\n+    private final Context context;\n+\n+    protected OpenTelemetryTraceContext() {\n+      this.context = Context.current();\n+    }\n+\n+    public Context getContext() {\n+      return context;\n+    }\n+  }\n+\n+  static class OpenTelemetryEndpoint implements Endpoint {\n+    final String ip;\n+    final int port;\n+    @Nullable final String name;\n+\n+    protected OpenTelemetryEndpoint(String ip, int port, @Nullable String name) {\n+      this.ip = ip;\n+      this.port = port;\n+      if (!ip.equals(name)) {\n+        this.name = name;\n+      } else {\n+        this.name = null;\n+      }\n+    }\n+  }\n+\n+  static class OpenTelemetryTracer extends Tracer {\n+\n+    protected OpenTelemetryTracer() {}\n+\n+    @Override\n+    public OpenTelemetrySpan nextSpan() {\n+      return new OpenTelemetrySpan(null);\n+    }\n+\n+    @Override\n+    public OpenTelemetrySpan nextSpan(TraceContext traceContext) {\n+      if (!(traceContext instanceof OpenTelemetryTraceContext)) {\n+        return nextSpan();\n+      }\n+\n+      Context context = ((OpenTelemetryTraceContext) traceContext).getContext();\n+\n+      final io.opentelemetry.trace.Span parent = TracingContextUtils.getSpanWithoutDefault(context);\n+\n+      return new OpenTelemetrySpan(parent);\n+    }\n+  }\n+\n+  // The order that callbacks will be called in or which thread they are called from is not well\n+  // defined. We go ahead and buffer all data until we know we have a span. This implementation is\n+  // particularly safe, synchronizing all accesses. Relying on implementation details would allow\n+  // reducing synchronization but the impact should be minimal.\n+  static class OpenTelemetrySpan extends Tracer.Span {\n+    @Nullable private final Span parent;\n+\n+    @Nullable private OpenTelemetryEndpoint endpoint;\n+    @Nullable private String name;\n+\n+    @Nullable private List<Object> events;\n+    @Nullable private List<String> tags;\n+\n+    @Nullable private Status status;\n+\n+    @Nullable private Span span;\n+\n+    protected OpenTelemetrySpan(@Nullable Span parent) {\n+      this.parent = parent;\n+    }\n+\n+    // Called before start. We need to buffer because this until then.\n+    @Override\n+    public synchronized Tracer.Span name(String name) {\n+      if (span != null) {\n+        span.updateName(name);\n+      } else {\n+        this.name = name;\n+      }\n+\n+      return this;\n+    }\n+\n+    @Override\n+    public synchronized Tracer.Span remoteEndpoint(Endpoint endpoint) {\n+      if (endpoint instanceof OpenTelemetryEndpoint) {\n+        if (span != null) {\n+          fillEndpoint(span, (OpenTelemetryEndpoint) endpoint);\n+        } else {\n+          this.endpoint = (OpenTelemetryEndpoint) endpoint;\n+        }\n+      }\n+      return this;\n+    }\n+\n+    @Override\n+    public synchronized Tracer.Span start() {\n+      // If name() wasn't called yet we will update it later.\n+      String spanName = name != null ? name : \"REDIS\";\n+      Span.Builder builder = TRACER.spanBuilder(spanName).setSpanKind(Kind.CLIENT);\n+      if (parent != null) {\n+        builder.setParent(parent);\n+      } else {\n+        builder.setNoParent();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87e8547d14b6ec66592f81e3fc0694d69621da7c"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc0MTM2OA==", "bodyText": "Reading javadoc, it seems to be that UNKNOWN suits better here?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535#discussion_r440741368", "createdAt": "2020-06-16T10:14:31Z", "author": {"login": "iNikem"}, "path": "instrumentation/lettuce/lettuce-5.2/src/main/java8/io/opentelemetry/auto/instrumentation/lettuce/v5_2/OpenTelemetryTracing.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.auto.instrumentation.lettuce.v5_2;\n+\n+import static io.opentelemetry.auto.instrumentation.lettuce.v5_2.LettuceClientDecorator.TRACER;\n+\n+import io.grpc.Context;\n+import io.lettuce.core.tracing.TraceContext;\n+import io.lettuce.core.tracing.TraceContextProvider;\n+import io.lettuce.core.tracing.Tracer;\n+import io.lettuce.core.tracing.TracerProvider;\n+import io.lettuce.core.tracing.Tracing;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import reactor.util.annotation.Nullable;\n+\n+public enum OpenTelemetryTracing implements Tracing {\n+  INSTANCE;\n+\n+  @Override\n+  public TracerProvider getTracerProvider() {\n+    return OpenTelemetryTracerProvider.INSTANCE;\n+  }\n+\n+  @Override\n+  public TraceContextProvider initialTraceContextProvider() {\n+    return OpenTelemetryTraceContextProvider.INSTANCE;\n+  }\n+\n+  @Override\n+  public boolean isEnabled() {\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean includeCommandArgsInSpanTags() {\n+    return true;\n+  }\n+\n+  @Override\n+  public Endpoint createEndpoint(SocketAddress socketAddress) {\n+    if (socketAddress instanceof InetSocketAddress) {\n+      InetSocketAddress address = (InetSocketAddress) socketAddress;\n+\n+      return new OpenTelemetryEndpoint(\n+          address.getAddress().getHostAddress(), address.getPort(), address.getHostString());\n+    }\n+    return null;\n+  }\n+\n+  enum OpenTelemetryTracerProvider implements TracerProvider {\n+    INSTANCE;\n+\n+    private final Tracer openTelemetryTracer = new OpenTelemetryTracer();\n+\n+    @Override\n+    public Tracer getTracer() {\n+      return openTelemetryTracer;\n+    }\n+  }\n+\n+  enum OpenTelemetryTraceContextProvider implements TraceContextProvider {\n+    INSTANCE;\n+\n+    @Override\n+    public TraceContext getTraceContext() {\n+      return new OpenTelemetryTraceContext();\n+    }\n+  }\n+\n+  static class OpenTelemetryTraceContext implements TraceContext {\n+    private final Context context;\n+\n+    protected OpenTelemetryTraceContext() {\n+      this.context = Context.current();\n+    }\n+\n+    public Context getContext() {\n+      return context;\n+    }\n+  }\n+\n+  static class OpenTelemetryEndpoint implements Endpoint {\n+    final String ip;\n+    final int port;\n+    @Nullable final String name;\n+\n+    protected OpenTelemetryEndpoint(String ip, int port, @Nullable String name) {\n+      this.ip = ip;\n+      this.port = port;\n+      if (!ip.equals(name)) {\n+        this.name = name;\n+      } else {\n+        this.name = null;\n+      }\n+    }\n+  }\n+\n+  static class OpenTelemetryTracer extends Tracer {\n+\n+    protected OpenTelemetryTracer() {}\n+\n+    @Override\n+    public OpenTelemetrySpan nextSpan() {\n+      return new OpenTelemetrySpan(null);\n+    }\n+\n+    @Override\n+    public OpenTelemetrySpan nextSpan(TraceContext traceContext) {\n+      if (!(traceContext instanceof OpenTelemetryTraceContext)) {\n+        return nextSpan();\n+      }\n+\n+      Context context = ((OpenTelemetryTraceContext) traceContext).getContext();\n+\n+      final io.opentelemetry.trace.Span parent = TracingContextUtils.getSpanWithoutDefault(context);\n+\n+      return new OpenTelemetrySpan(parent);\n+    }\n+  }\n+\n+  // The order that callbacks will be called in or which thread they are called from is not well\n+  // defined. We go ahead and buffer all data until we know we have a span. This implementation is\n+  // particularly safe, synchronizing all accesses. Relying on implementation details would allow\n+  // reducing synchronization but the impact should be minimal.\n+  static class OpenTelemetrySpan extends Tracer.Span {\n+    @Nullable private final Span parent;\n+\n+    @Nullable private OpenTelemetryEndpoint endpoint;\n+    @Nullable private String name;\n+\n+    @Nullable private List<Object> events;\n+    @Nullable private List<String> tags;\n+\n+    @Nullable private Status status;\n+\n+    @Nullable private Span span;\n+\n+    protected OpenTelemetrySpan(@Nullable Span parent) {\n+      this.parent = parent;\n+    }\n+\n+    // Called before start. We need to buffer because this until then.\n+    @Override\n+    public synchronized Tracer.Span name(String name) {\n+      if (span != null) {\n+        span.updateName(name);\n+      } else {\n+        this.name = name;\n+      }\n+\n+      return this;\n+    }\n+\n+    @Override\n+    public synchronized Tracer.Span remoteEndpoint(Endpoint endpoint) {\n+      if (endpoint instanceof OpenTelemetryEndpoint) {\n+        if (span != null) {\n+          fillEndpoint(span, (OpenTelemetryEndpoint) endpoint);\n+        } else {\n+          this.endpoint = (OpenTelemetryEndpoint) endpoint;\n+        }\n+      }\n+      return this;\n+    }\n+\n+    @Override\n+    public synchronized Tracer.Span start() {\n+      // If name() wasn't called yet we will update it later.\n+      String spanName = name != null ? name : \"REDIS\";\n+      Span.Builder builder = TRACER.spanBuilder(spanName).setSpanKind(Kind.CLIENT);\n+      if (parent != null) {\n+        builder.setParent(parent);\n+      } else {\n+        builder.setNoParent();\n+      }\n+\n+      builder.setAttribute(SemanticAttributes.DB_TYPE.key(), \"redis\");\n+\n+      span = builder.startSpan();\n+\n+      if (endpoint != null) {\n+        fillEndpoint(span, endpoint);\n+        endpoint = null;\n+      }\n+\n+      if (events != null) {\n+        for (int i = 0; i < events.size(); i += 2) {\n+          span.addEvent((String) events.get(i), (long) events.get(i + 1));\n+        }\n+        events = null;\n+      }\n+\n+      if (tags != null) {\n+        for (int i = 0; i < tags.size(); i += 2) {\n+          span.setAttribute(tags.get(i), tags.get(i + 1));\n+        }\n+        tags = null;\n+      }\n+\n+      if (status != null) {\n+        span.setStatus(status);\n+        status = null;\n+      }\n+\n+      return this;\n+    }\n+\n+    @Override\n+    public synchronized Tracer.Span annotate(String value) {\n+      if (span != null) {\n+        span.addEvent(value);\n+      } else {\n+        if (events == null) {\n+          events = new ArrayList<>();\n+        }\n+        events.add(value);\n+        final Instant now = Instant.now();\n+        events.add(TimeUnit.SECONDS.toNanos(now.getEpochSecond()) + now.getNano());\n+      }\n+      return this;\n+    }\n+\n+    @Override\n+    public synchronized Tracer.Span tag(String key, String value) {\n+      key = translateTagKey(key);\n+      if (span != null) {\n+        span.setAttribute(key, value);\n+      } else {\n+        if (tags == null) {\n+          tags = new ArrayList<>();\n+        }\n+        tags.add(key);\n+        tags.add(value);\n+      }\n+      return this;\n+    }\n+\n+    @Override\n+    public synchronized Tracer.Span error(Throwable throwable) {\n+      // TODO(anuraaga): Check if any lettuce exceptions map well to a Status and try mapping.\n+      final Status status =\n+          Status.INTERNAL.withDescription(throwable.getClass() + \": \" + throwable.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87e8547d14b6ec66592f81e3fc0694d69621da7c"}, "originalPosition": 266}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc0MjkxNQ==", "bodyText": "This can block indefinitely, not good", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535#discussion_r440742915", "createdAt": "2020-06-16T10:17:11Z", "author": {"login": "iNikem"}, "path": "instrumentation/lettuce/lettuce-5.2/src/test/groovy/io/opentelemetry/auto/instrumentation/lettuce/v5_2/LettuceAsyncClientTest.groovy", "diffHunk": "@@ -0,0 +1,400 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.auto.instrumentation.lettuce.v5_2\n+\n+import io.lettuce.core.ClientOptions\n+import io.lettuce.core.ConnectionFuture\n+import io.lettuce.core.RedisClient\n+import io.lettuce.core.RedisFuture\n+import io.lettuce.core.RedisURI\n+import io.lettuce.core.api.StatefulConnection\n+import io.lettuce.core.api.async.RedisAsyncCommands\n+import io.lettuce.core.api.sync.RedisCommands\n+import io.lettuce.core.codec.StringCodec\n+import io.opentelemetry.auto.test.AgentTestRunner\n+import io.opentelemetry.auto.test.utils.PortUtils\n+import redis.embedded.RedisServer\n+import spock.lang.Shared\n+import spock.util.concurrent.AsyncConditions\n+\n+import java.util.concurrent.ExecutionException\n+import java.util.concurrent.TimeUnit\n+import java.util.function.BiConsumer\n+import java.util.function.BiFunction\n+import java.util.function.Consumer\n+import java.util.function.Function\n+\n+import static io.opentelemetry.trace.Span.Kind.CLIENT\n+\n+class LettuceAsyncClientTest extends AgentTestRunner {\n+  public static final String HOST = \"127.0.0.1\"\n+  public static final int DB_INDEX = 0\n+  // Disable autoreconnect so we do not get stray traces popping up on server shutdown\n+  public static final ClientOptions CLIENT_OPTIONS = ClientOptions.builder().autoReconnect(false).build()\n+\n+  @Shared\n+  int port\n+  @Shared\n+  int incorrectPort\n+  @Shared\n+  String dbAddr\n+  @Shared\n+  String dbAddrNonExistent\n+  @Shared\n+  String dbUriNonExistent\n+  @Shared\n+  String embeddedDbUri\n+\n+  @Shared\n+  RedisServer redisServer\n+\n+  @Shared\n+  Map<String, String> testHashMap = [\n+    firstname: \"John\",\n+    lastname : \"Doe\",\n+    age      : \"53\"\n+  ]\n+\n+  RedisClient redisClient\n+  StatefulConnection connection\n+  RedisAsyncCommands<String, ?> asyncCommands\n+  RedisCommands<String, ?> syncCommands\n+\n+  def setupSpec() {\n+    port = PortUtils.randomOpenPort()\n+    incorrectPort = PortUtils.randomOpenPort()\n+    dbAddr = HOST + \":\" + port + \"/\" + DB_INDEX\n+    dbAddrNonExistent = HOST + \":\" + incorrectPort + \"/\" + DB_INDEX\n+    dbUriNonExistent = \"redis://\" + dbAddrNonExistent\n+    embeddedDbUri = \"redis://\" + dbAddr\n+\n+    redisServer = RedisServer.builder()\n+    // bind to localhost to avoid firewall popup\n+      .setting(\"bind \" + HOST)\n+    // set max memory to avoid problems in CI\n+      .setting(\"maxmemory 128M\")\n+      .port(port).build()\n+  }\n+\n+  def setup() {\n+    redisClient = RedisClient.create(embeddedDbUri)\n+\n+    println \"Using redis: $redisServer.args\"\n+    redisServer.start()\n+    redisClient.setOptions(CLIENT_OPTIONS)\n+\n+    connection = redisClient.connect()\n+    asyncCommands = connection.async()\n+    syncCommands = connection.sync()\n+\n+    syncCommands.set(\"TESTKEY\", \"TESTVAL\")\n+\n+    // 1 set\n+    TEST_WRITER.waitForTraces(1)\n+    TEST_WRITER.clear()\n+  }\n+\n+  def cleanup() {\n+    connection.close()\n+    redisServer.stop()\n+  }\n+\n+  def \"connect using get on ConnectionFuture\"() {\n+    setup:\n+    RedisClient testConnectionClient = RedisClient.create(embeddedDbUri)\n+    testConnectionClient.setOptions(CLIENT_OPTIONS)\n+\n+    when:\n+    ConnectionFuture connectionFuture = testConnectionClient.connectAsync(StringCodec.UTF8,\n+      new RedisURI(HOST, port, 3, TimeUnit.SECONDS))\n+    StatefulConnection connection = connectionFuture.get()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87e8547d14b6ec66592f81e3fc0694d69621da7c"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc0MzMxMg==", "bodyText": "same here", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535#discussion_r440743312", "createdAt": "2020-06-16T10:17:49Z", "author": {"login": "iNikem"}, "path": "instrumentation/lettuce/lettuce-5.2/src/test/groovy/io/opentelemetry/auto/instrumentation/lettuce/v5_2/LettuceAsyncClientTest.groovy", "diffHunk": "@@ -0,0 +1,400 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.auto.instrumentation.lettuce.v5_2\n+\n+import io.lettuce.core.ClientOptions\n+import io.lettuce.core.ConnectionFuture\n+import io.lettuce.core.RedisClient\n+import io.lettuce.core.RedisFuture\n+import io.lettuce.core.RedisURI\n+import io.lettuce.core.api.StatefulConnection\n+import io.lettuce.core.api.async.RedisAsyncCommands\n+import io.lettuce.core.api.sync.RedisCommands\n+import io.lettuce.core.codec.StringCodec\n+import io.opentelemetry.auto.test.AgentTestRunner\n+import io.opentelemetry.auto.test.utils.PortUtils\n+import redis.embedded.RedisServer\n+import spock.lang.Shared\n+import spock.util.concurrent.AsyncConditions\n+\n+import java.util.concurrent.ExecutionException\n+import java.util.concurrent.TimeUnit\n+import java.util.function.BiConsumer\n+import java.util.function.BiFunction\n+import java.util.function.Consumer\n+import java.util.function.Function\n+\n+import static io.opentelemetry.trace.Span.Kind.CLIENT\n+\n+class LettuceAsyncClientTest extends AgentTestRunner {\n+  public static final String HOST = \"127.0.0.1\"\n+  public static final int DB_INDEX = 0\n+  // Disable autoreconnect so we do not get stray traces popping up on server shutdown\n+  public static final ClientOptions CLIENT_OPTIONS = ClientOptions.builder().autoReconnect(false).build()\n+\n+  @Shared\n+  int port\n+  @Shared\n+  int incorrectPort\n+  @Shared\n+  String dbAddr\n+  @Shared\n+  String dbAddrNonExistent\n+  @Shared\n+  String dbUriNonExistent\n+  @Shared\n+  String embeddedDbUri\n+\n+  @Shared\n+  RedisServer redisServer\n+\n+  @Shared\n+  Map<String, String> testHashMap = [\n+    firstname: \"John\",\n+    lastname : \"Doe\",\n+    age      : \"53\"\n+  ]\n+\n+  RedisClient redisClient\n+  StatefulConnection connection\n+  RedisAsyncCommands<String, ?> asyncCommands\n+  RedisCommands<String, ?> syncCommands\n+\n+  def setupSpec() {\n+    port = PortUtils.randomOpenPort()\n+    incorrectPort = PortUtils.randomOpenPort()\n+    dbAddr = HOST + \":\" + port + \"/\" + DB_INDEX\n+    dbAddrNonExistent = HOST + \":\" + incorrectPort + \"/\" + DB_INDEX\n+    dbUriNonExistent = \"redis://\" + dbAddrNonExistent\n+    embeddedDbUri = \"redis://\" + dbAddr\n+\n+    redisServer = RedisServer.builder()\n+    // bind to localhost to avoid firewall popup\n+      .setting(\"bind \" + HOST)\n+    // set max memory to avoid problems in CI\n+      .setting(\"maxmemory 128M\")\n+      .port(port).build()\n+  }\n+\n+  def setup() {\n+    redisClient = RedisClient.create(embeddedDbUri)\n+\n+    println \"Using redis: $redisServer.args\"\n+    redisServer.start()\n+    redisClient.setOptions(CLIENT_OPTIONS)\n+\n+    connection = redisClient.connect()\n+    asyncCommands = connection.async()\n+    syncCommands = connection.sync()\n+\n+    syncCommands.set(\"TESTKEY\", \"TESTVAL\")\n+\n+    // 1 set\n+    TEST_WRITER.waitForTraces(1)\n+    TEST_WRITER.clear()\n+  }\n+\n+  def cleanup() {\n+    connection.close()\n+    redisServer.stop()\n+  }\n+\n+  def \"connect using get on ConnectionFuture\"() {\n+    setup:\n+    RedisClient testConnectionClient = RedisClient.create(embeddedDbUri)\n+    testConnectionClient.setOptions(CLIENT_OPTIONS)\n+\n+    when:\n+    ConnectionFuture connectionFuture = testConnectionClient.connectAsync(StringCodec.UTF8,\n+      new RedisURI(HOST, port, 3, TimeUnit.SECONDS))\n+    StatefulConnection connection = connectionFuture.get()\n+\n+    then:\n+    connection != null\n+    // Lettuce tracing does not trace connect\n+    assertTraces(0) {}\n+\n+    cleanup:\n+    connection.close()\n+  }\n+\n+  def \"connect exception inside the connection future\"() {\n+    setup:\n+    RedisClient testConnectionClient = RedisClient.create(dbUriNonExistent)\n+    testConnectionClient.setOptions(CLIENT_OPTIONS)\n+\n+    when:\n+    ConnectionFuture connectionFuture = testConnectionClient.connectAsync(StringCodec.UTF8,\n+      new RedisURI(HOST, incorrectPort, 3, TimeUnit.SECONDS))\n+    StatefulConnection connection = connectionFuture.get()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87e8547d14b6ec66592f81e3fc0694d69621da7c"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc0NTI2Mg==", "bodyText": "Can you fill more attributes? https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/database.md", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535#discussion_r440745262", "createdAt": "2020-06-16T10:21:28Z", "author": {"login": "iNikem"}, "path": "instrumentation/lettuce/lettuce-5.2/src/test/groovy/io/opentelemetry/auto/instrumentation/lettuce/v5_2/LettuceAsyncClientTest.groovy", "diffHunk": "@@ -0,0 +1,400 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.auto.instrumentation.lettuce.v5_2\n+\n+import io.lettuce.core.ClientOptions\n+import io.lettuce.core.ConnectionFuture\n+import io.lettuce.core.RedisClient\n+import io.lettuce.core.RedisFuture\n+import io.lettuce.core.RedisURI\n+import io.lettuce.core.api.StatefulConnection\n+import io.lettuce.core.api.async.RedisAsyncCommands\n+import io.lettuce.core.api.sync.RedisCommands\n+import io.lettuce.core.codec.StringCodec\n+import io.opentelemetry.auto.test.AgentTestRunner\n+import io.opentelemetry.auto.test.utils.PortUtils\n+import redis.embedded.RedisServer\n+import spock.lang.Shared\n+import spock.util.concurrent.AsyncConditions\n+\n+import java.util.concurrent.ExecutionException\n+import java.util.concurrent.TimeUnit\n+import java.util.function.BiConsumer\n+import java.util.function.BiFunction\n+import java.util.function.Consumer\n+import java.util.function.Function\n+\n+import static io.opentelemetry.trace.Span.Kind.CLIENT\n+\n+class LettuceAsyncClientTest extends AgentTestRunner {\n+  public static final String HOST = \"127.0.0.1\"\n+  public static final int DB_INDEX = 0\n+  // Disable autoreconnect so we do not get stray traces popping up on server shutdown\n+  public static final ClientOptions CLIENT_OPTIONS = ClientOptions.builder().autoReconnect(false).build()\n+\n+  @Shared\n+  int port\n+  @Shared\n+  int incorrectPort\n+  @Shared\n+  String dbAddr\n+  @Shared\n+  String dbAddrNonExistent\n+  @Shared\n+  String dbUriNonExistent\n+  @Shared\n+  String embeddedDbUri\n+\n+  @Shared\n+  RedisServer redisServer\n+\n+  @Shared\n+  Map<String, String> testHashMap = [\n+    firstname: \"John\",\n+    lastname : \"Doe\",\n+    age      : \"53\"\n+  ]\n+\n+  RedisClient redisClient\n+  StatefulConnection connection\n+  RedisAsyncCommands<String, ?> asyncCommands\n+  RedisCommands<String, ?> syncCommands\n+\n+  def setupSpec() {\n+    port = PortUtils.randomOpenPort()\n+    incorrectPort = PortUtils.randomOpenPort()\n+    dbAddr = HOST + \":\" + port + \"/\" + DB_INDEX\n+    dbAddrNonExistent = HOST + \":\" + incorrectPort + \"/\" + DB_INDEX\n+    dbUriNonExistent = \"redis://\" + dbAddrNonExistent\n+    embeddedDbUri = \"redis://\" + dbAddr\n+\n+    redisServer = RedisServer.builder()\n+    // bind to localhost to avoid firewall popup\n+      .setting(\"bind \" + HOST)\n+    // set max memory to avoid problems in CI\n+      .setting(\"maxmemory 128M\")\n+      .port(port).build()\n+  }\n+\n+  def setup() {\n+    redisClient = RedisClient.create(embeddedDbUri)\n+\n+    println \"Using redis: $redisServer.args\"\n+    redisServer.start()\n+    redisClient.setOptions(CLIENT_OPTIONS)\n+\n+    connection = redisClient.connect()\n+    asyncCommands = connection.async()\n+    syncCommands = connection.sync()\n+\n+    syncCommands.set(\"TESTKEY\", \"TESTVAL\")\n+\n+    // 1 set\n+    TEST_WRITER.waitForTraces(1)\n+    TEST_WRITER.clear()\n+  }\n+\n+  def cleanup() {\n+    connection.close()\n+    redisServer.stop()\n+  }\n+\n+  def \"connect using get on ConnectionFuture\"() {\n+    setup:\n+    RedisClient testConnectionClient = RedisClient.create(embeddedDbUri)\n+    testConnectionClient.setOptions(CLIENT_OPTIONS)\n+\n+    when:\n+    ConnectionFuture connectionFuture = testConnectionClient.connectAsync(StringCodec.UTF8,\n+      new RedisURI(HOST, port, 3, TimeUnit.SECONDS))\n+    StatefulConnection connection = connectionFuture.get()\n+\n+    then:\n+    connection != null\n+    // Lettuce tracing does not trace connect\n+    assertTraces(0) {}\n+\n+    cleanup:\n+    connection.close()\n+  }\n+\n+  def \"connect exception inside the connection future\"() {\n+    setup:\n+    RedisClient testConnectionClient = RedisClient.create(dbUriNonExistent)\n+    testConnectionClient.setOptions(CLIENT_OPTIONS)\n+\n+    when:\n+    ConnectionFuture connectionFuture = testConnectionClient.connectAsync(StringCodec.UTF8,\n+      new RedisURI(HOST, incorrectPort, 3, TimeUnit.SECONDS))\n+    StatefulConnection connection = connectionFuture.get()\n+\n+    then:\n+    connection == null\n+    thrown ExecutionException\n+    // Lettuce tracing does not trace connect\n+    assertTraces(0) {}\n+  }\n+\n+  def \"set command using Future get with timeout\"() {\n+    setup:\n+    RedisFuture<String> redisFuture = asyncCommands.set(\"TESTSETKEY\", \"TESTSETVAL\")\n+    String res = redisFuture.get(3, TimeUnit.SECONDS)\n+\n+    expect:\n+    res == \"OK\"\n+    assertTraces(1) {\n+      trace(0, 1) {\n+        span(0) {\n+          operationName \"SET\"\n+          spanKind CLIENT\n+          errored false\n+          tags {\n+            \"net.transport\" \"IP.TCP\"\n+            \"net.peer.ip\" \"127.0.0.1\"\n+            \"net.peer.port\" port\n+            \"db.type\" \"redis\"\n+            \"db.statement\" \"key<TESTSETKEY> value<TESTSETVAL>\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87e8547d14b6ec66592f81e3fc0694d69621da7c"}, "originalPosition": 169}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxODgzMzE5", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535#pullrequestreview-431883319", "createdAt": "2020-06-16T20:53:49Z", "commit": {"oid": "87e8547d14b6ec66592f81e3fc0694d69621da7c"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDo1Mzo0OVrOGksx3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMjoyMTowMVrOGkvLPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzNTU4Mw==", "bodyText": "or maybe new OpenTelemetrySpan(TRACER.getCurrentSpan()) instead of new OpenTelemetrySpan(null) above to capture the parent (if there is one) earlier, and then don't need the conditional here", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535#discussion_r441135583", "createdAt": "2020-06-16T20:53:49Z", "author": {"login": "trask"}, "path": "instrumentation/lettuce/lettuce-5.2/src/main/java8/io/opentelemetry/auto/instrumentation/lettuce/v5_2/OpenTelemetryTracing.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.auto.instrumentation.lettuce.v5_2;\n+\n+import static io.opentelemetry.auto.instrumentation.lettuce.v5_2.LettuceClientDecorator.TRACER;\n+\n+import io.grpc.Context;\n+import io.lettuce.core.tracing.TraceContext;\n+import io.lettuce.core.tracing.TraceContextProvider;\n+import io.lettuce.core.tracing.Tracer;\n+import io.lettuce.core.tracing.TracerProvider;\n+import io.lettuce.core.tracing.Tracing;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import reactor.util.annotation.Nullable;\n+\n+public enum OpenTelemetryTracing implements Tracing {\n+  INSTANCE;\n+\n+  @Override\n+  public TracerProvider getTracerProvider() {\n+    return OpenTelemetryTracerProvider.INSTANCE;\n+  }\n+\n+  @Override\n+  public TraceContextProvider initialTraceContextProvider() {\n+    return OpenTelemetryTraceContextProvider.INSTANCE;\n+  }\n+\n+  @Override\n+  public boolean isEnabled() {\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean includeCommandArgsInSpanTags() {\n+    return true;\n+  }\n+\n+  @Override\n+  public Endpoint createEndpoint(SocketAddress socketAddress) {\n+    if (socketAddress instanceof InetSocketAddress) {\n+      InetSocketAddress address = (InetSocketAddress) socketAddress;\n+\n+      return new OpenTelemetryEndpoint(\n+          address.getAddress().getHostAddress(), address.getPort(), address.getHostString());\n+    }\n+    return null;\n+  }\n+\n+  enum OpenTelemetryTracerProvider implements TracerProvider {\n+    INSTANCE;\n+\n+    private final Tracer openTelemetryTracer = new OpenTelemetryTracer();\n+\n+    @Override\n+    public Tracer getTracer() {\n+      return openTelemetryTracer;\n+    }\n+  }\n+\n+  enum OpenTelemetryTraceContextProvider implements TraceContextProvider {\n+    INSTANCE;\n+\n+    @Override\n+    public TraceContext getTraceContext() {\n+      return new OpenTelemetryTraceContext();\n+    }\n+  }\n+\n+  static class OpenTelemetryTraceContext implements TraceContext {\n+    private final Context context;\n+\n+    protected OpenTelemetryTraceContext() {\n+      this.context = Context.current();\n+    }\n+\n+    public Context getContext() {\n+      return context;\n+    }\n+  }\n+\n+  static class OpenTelemetryEndpoint implements Endpoint {\n+    final String ip;\n+    final int port;\n+    @Nullable final String name;\n+\n+    protected OpenTelemetryEndpoint(String ip, int port, @Nullable String name) {\n+      this.ip = ip;\n+      this.port = port;\n+      if (!ip.equals(name)) {\n+        this.name = name;\n+      } else {\n+        this.name = null;\n+      }\n+    }\n+  }\n+\n+  static class OpenTelemetryTracer extends Tracer {\n+\n+    protected OpenTelemetryTracer() {}\n+\n+    @Override\n+    public OpenTelemetrySpan nextSpan() {\n+      return new OpenTelemetrySpan(null);\n+    }\n+\n+    @Override\n+    public OpenTelemetrySpan nextSpan(TraceContext traceContext) {\n+      if (!(traceContext instanceof OpenTelemetryTraceContext)) {\n+        return nextSpan();\n+      }\n+\n+      Context context = ((OpenTelemetryTraceContext) traceContext).getContext();\n+\n+      final io.opentelemetry.trace.Span parent = TracingContextUtils.getSpanWithoutDefault(context);\n+\n+      return new OpenTelemetrySpan(parent);\n+    }\n+  }\n+\n+  // The order that callbacks will be called in or which thread they are called from is not well\n+  // defined. We go ahead and buffer all data until we know we have a span. This implementation is\n+  // particularly safe, synchronizing all accesses. Relying on implementation details would allow\n+  // reducing synchronization but the impact should be minimal.\n+  static class OpenTelemetrySpan extends Tracer.Span {\n+    @Nullable private final Span parent;\n+\n+    @Nullable private OpenTelemetryEndpoint endpoint;\n+    @Nullable private String name;\n+\n+    @Nullable private List<Object> events;\n+    @Nullable private List<String> tags;\n+\n+    @Nullable private Status status;\n+\n+    @Nullable private Span span;\n+\n+    protected OpenTelemetrySpan(@Nullable Span parent) {\n+      this.parent = parent;\n+    }\n+\n+    // Called before start. We need to buffer because this until then.\n+    @Override\n+    public synchronized Tracer.Span name(String name) {\n+      if (span != null) {\n+        span.updateName(name);\n+      } else {\n+        this.name = name;\n+      }\n+\n+      return this;\n+    }\n+\n+    @Override\n+    public synchronized Tracer.Span remoteEndpoint(Endpoint endpoint) {\n+      if (endpoint instanceof OpenTelemetryEndpoint) {\n+        if (span != null) {\n+          fillEndpoint(span, (OpenTelemetryEndpoint) endpoint);\n+        } else {\n+          this.endpoint = (OpenTelemetryEndpoint) endpoint;\n+        }\n+      }\n+      return this;\n+    }\n+\n+    @Override\n+    public synchronized Tracer.Span start() {\n+      // If name() wasn't called yet we will update it later.\n+      String spanName = name != null ? name : \"REDIS\";\n+      Span.Builder builder = TRACER.spanBuilder(spanName).setSpanKind(Kind.CLIENT);\n+      if (parent != null) {\n+        builder.setParent(parent);\n+      } else {\n+        builder.setNoParent();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDczOTY5Nw=="}, "originalCommit": {"oid": "87e8547d14b6ec66592f81e3fc0694d69621da7c"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzODI1OQ==", "bodyText": "\ud83d\udc4d Closes #504?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535#discussion_r441138259", "createdAt": "2020-06-16T20:58:50Z", "author": {"login": "trask"}, "path": "instrumentation/lettuce/lettuce-5.0/lettuce-5.0.gradle", "diffHunk": "@@ -1,7 +1,6 @@\n // Set properties before any plugins get loaded\n ext {\n   minJavaVersionForTests = JavaVersion.VERSION_1_8\n-  maxJavaVersionForTests = JavaVersion.VERSION_1_8", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87e8547d14b6ec66592f81e3fc0694d69621da7c"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE1Njk4MQ==", "bodyText": "probably TRACER could be moved to OpenTelemetryTracing", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535#discussion_r441156981", "createdAt": "2020-06-16T21:37:59Z", "author": {"login": "trask"}, "path": "instrumentation/lettuce/lettuce-5.2/src/main/java8/io/opentelemetry/auto/instrumentation/lettuce/v5_2/LettuceClientDecorator.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.auto.instrumentation.lettuce.v5_2;\n+\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.trace.Tracer;\n+\n+// Currently don't use decorator pattern since lifecycle of lettuce Tracing is too different than\n+// what we expect.\n+public class LettuceClientDecorator {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDczNDQ1NA=="}, "originalCommit": {"oid": "87e8547d14b6ec66592f81e3fc0694d69621da7c"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE1ODU2OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return new OpenTelemetrySpan(null);\n          \n          \n            \n                  return new OpenTelemetrySpan(TRACER.getCurrentSpan());", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535#discussion_r441158568", "createdAt": "2020-06-16T21:41:36Z", "author": {"login": "trask"}, "path": "instrumentation/lettuce/lettuce-5.2/src/main/java8/io/opentelemetry/auto/instrumentation/lettuce/v5_2/OpenTelemetryTracing.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.auto.instrumentation.lettuce.v5_2;\n+\n+import static io.opentelemetry.auto.instrumentation.lettuce.v5_2.LettuceClientDecorator.TRACER;\n+\n+import io.grpc.Context;\n+import io.lettuce.core.tracing.TraceContext;\n+import io.lettuce.core.tracing.TraceContextProvider;\n+import io.lettuce.core.tracing.Tracer;\n+import io.lettuce.core.tracing.TracerProvider;\n+import io.lettuce.core.tracing.Tracing;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import reactor.util.annotation.Nullable;\n+\n+public enum OpenTelemetryTracing implements Tracing {\n+  INSTANCE;\n+\n+  @Override\n+  public TracerProvider getTracerProvider() {\n+    return OpenTelemetryTracerProvider.INSTANCE;\n+  }\n+\n+  @Override\n+  public TraceContextProvider initialTraceContextProvider() {\n+    return OpenTelemetryTraceContextProvider.INSTANCE;\n+  }\n+\n+  @Override\n+  public boolean isEnabled() {\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean includeCommandArgsInSpanTags() {\n+    return true;\n+  }\n+\n+  @Override\n+  public Endpoint createEndpoint(SocketAddress socketAddress) {\n+    if (socketAddress instanceof InetSocketAddress) {\n+      InetSocketAddress address = (InetSocketAddress) socketAddress;\n+\n+      return new OpenTelemetryEndpoint(\n+          address.getAddress().getHostAddress(), address.getPort(), address.getHostString());\n+    }\n+    return null;\n+  }\n+\n+  enum OpenTelemetryTracerProvider implements TracerProvider {\n+    INSTANCE;\n+\n+    private final Tracer openTelemetryTracer = new OpenTelemetryTracer();\n+\n+    @Override\n+    public Tracer getTracer() {\n+      return openTelemetryTracer;\n+    }\n+  }\n+\n+  enum OpenTelemetryTraceContextProvider implements TraceContextProvider {\n+    INSTANCE;\n+\n+    @Override\n+    public TraceContext getTraceContext() {\n+      return new OpenTelemetryTraceContext();\n+    }\n+  }\n+\n+  static class OpenTelemetryTraceContext implements TraceContext {\n+    private final Context context;\n+\n+    protected OpenTelemetryTraceContext() {\n+      this.context = Context.current();\n+    }\n+\n+    public Context getContext() {\n+      return context;\n+    }\n+  }\n+\n+  static class OpenTelemetryEndpoint implements Endpoint {\n+    final String ip;\n+    final int port;\n+    @Nullable final String name;\n+\n+    protected OpenTelemetryEndpoint(String ip, int port, @Nullable String name) {\n+      this.ip = ip;\n+      this.port = port;\n+      if (!ip.equals(name)) {\n+        this.name = name;\n+      } else {\n+        this.name = null;\n+      }\n+    }\n+  }\n+\n+  static class OpenTelemetryTracer extends Tracer {\n+\n+    protected OpenTelemetryTracer() {}\n+\n+    @Override\n+    public OpenTelemetrySpan nextSpan() {\n+      return new OpenTelemetrySpan(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87e8547d14b6ec66592f81e3fc0694d69621da7c"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE2OTI1MA==", "bodyText": "what do u think about replacing parent, endpoint, name and tags with Span.Builder?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535#discussion_r441169250", "createdAt": "2020-06-16T22:07:03Z", "author": {"login": "trask"}, "path": "instrumentation/lettuce/lettuce-5.2/src/main/java8/io/opentelemetry/auto/instrumentation/lettuce/v5_2/OpenTelemetryTracing.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.auto.instrumentation.lettuce.v5_2;\n+\n+import static io.opentelemetry.auto.instrumentation.lettuce.v5_2.LettuceClientDecorator.TRACER;\n+\n+import io.grpc.Context;\n+import io.lettuce.core.tracing.TraceContext;\n+import io.lettuce.core.tracing.TraceContextProvider;\n+import io.lettuce.core.tracing.Tracer;\n+import io.lettuce.core.tracing.TracerProvider;\n+import io.lettuce.core.tracing.Tracing;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import reactor.util.annotation.Nullable;\n+\n+public enum OpenTelemetryTracing implements Tracing {\n+  INSTANCE;\n+\n+  @Override\n+  public TracerProvider getTracerProvider() {\n+    return OpenTelemetryTracerProvider.INSTANCE;\n+  }\n+\n+  @Override\n+  public TraceContextProvider initialTraceContextProvider() {\n+    return OpenTelemetryTraceContextProvider.INSTANCE;\n+  }\n+\n+  @Override\n+  public boolean isEnabled() {\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean includeCommandArgsInSpanTags() {\n+    return true;\n+  }\n+\n+  @Override\n+  public Endpoint createEndpoint(SocketAddress socketAddress) {\n+    if (socketAddress instanceof InetSocketAddress) {\n+      InetSocketAddress address = (InetSocketAddress) socketAddress;\n+\n+      return new OpenTelemetryEndpoint(\n+          address.getAddress().getHostAddress(), address.getPort(), address.getHostString());\n+    }\n+    return null;\n+  }\n+\n+  enum OpenTelemetryTracerProvider implements TracerProvider {\n+    INSTANCE;\n+\n+    private final Tracer openTelemetryTracer = new OpenTelemetryTracer();\n+\n+    @Override\n+    public Tracer getTracer() {\n+      return openTelemetryTracer;\n+    }\n+  }\n+\n+  enum OpenTelemetryTraceContextProvider implements TraceContextProvider {\n+    INSTANCE;\n+\n+    @Override\n+    public TraceContext getTraceContext() {\n+      return new OpenTelemetryTraceContext();\n+    }\n+  }\n+\n+  static class OpenTelemetryTraceContext implements TraceContext {\n+    private final Context context;\n+\n+    protected OpenTelemetryTraceContext() {\n+      this.context = Context.current();\n+    }\n+\n+    public Context getContext() {\n+      return context;\n+    }\n+  }\n+\n+  static class OpenTelemetryEndpoint implements Endpoint {\n+    final String ip;\n+    final int port;\n+    @Nullable final String name;\n+\n+    protected OpenTelemetryEndpoint(String ip, int port, @Nullable String name) {\n+      this.ip = ip;\n+      this.port = port;\n+      if (!ip.equals(name)) {\n+        this.name = name;\n+      } else {\n+        this.name = null;\n+      }\n+    }\n+  }\n+\n+  static class OpenTelemetryTracer extends Tracer {\n+\n+    protected OpenTelemetryTracer() {}\n+\n+    @Override\n+    public OpenTelemetrySpan nextSpan() {\n+      return new OpenTelemetrySpan(null);\n+    }\n+\n+    @Override\n+    public OpenTelemetrySpan nextSpan(TraceContext traceContext) {\n+      if (!(traceContext instanceof OpenTelemetryTraceContext)) {\n+        return nextSpan();\n+      }\n+\n+      Context context = ((OpenTelemetryTraceContext) traceContext).getContext();\n+\n+      final io.opentelemetry.trace.Span parent = TracingContextUtils.getSpanWithoutDefault(context);\n+\n+      return new OpenTelemetrySpan(parent);\n+    }\n+  }\n+\n+  // The order that callbacks will be called in or which thread they are called from is not well\n+  // defined. We go ahead and buffer all data until we know we have a span. This implementation is\n+  // particularly safe, synchronizing all accesses. Relying on implementation details would allow\n+  // reducing synchronization but the impact should be minimal.\n+  static class OpenTelemetrySpan extends Tracer.Span {\n+    @Nullable private final Span parent;\n+\n+    @Nullable private OpenTelemetryEndpoint endpoint;\n+    @Nullable private String name;\n+\n+    @Nullable private List<Object> events;\n+    @Nullable private List<String> tags;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87e8547d14b6ec66592f81e3fc0694d69621da7c"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE3NDg0Ng==", "bodyText": "are these events worth capturing, given they are not part of the semantic conventions?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535#discussion_r441174846", "createdAt": "2020-06-16T22:21:01Z", "author": {"login": "trask"}, "path": "instrumentation/lettuce/lettuce-5.2/src/test/groovy/io/opentelemetry/auto/instrumentation/lettuce/v5_2/LettuceAsyncClientTest.groovy", "diffHunk": "@@ -0,0 +1,400 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.auto.instrumentation.lettuce.v5_2\n+\n+import io.lettuce.core.ClientOptions\n+import io.lettuce.core.ConnectionFuture\n+import io.lettuce.core.RedisClient\n+import io.lettuce.core.RedisFuture\n+import io.lettuce.core.RedisURI\n+import io.lettuce.core.api.StatefulConnection\n+import io.lettuce.core.api.async.RedisAsyncCommands\n+import io.lettuce.core.api.sync.RedisCommands\n+import io.lettuce.core.codec.StringCodec\n+import io.opentelemetry.auto.test.AgentTestRunner\n+import io.opentelemetry.auto.test.utils.PortUtils\n+import redis.embedded.RedisServer\n+import spock.lang.Shared\n+import spock.util.concurrent.AsyncConditions\n+\n+import java.util.concurrent.ExecutionException\n+import java.util.concurrent.TimeUnit\n+import java.util.function.BiConsumer\n+import java.util.function.BiFunction\n+import java.util.function.Consumer\n+import java.util.function.Function\n+\n+import static io.opentelemetry.trace.Span.Kind.CLIENT\n+\n+class LettuceAsyncClientTest extends AgentTestRunner {\n+  public static final String HOST = \"127.0.0.1\"\n+  public static final int DB_INDEX = 0\n+  // Disable autoreconnect so we do not get stray traces popping up on server shutdown\n+  public static final ClientOptions CLIENT_OPTIONS = ClientOptions.builder().autoReconnect(false).build()\n+\n+  @Shared\n+  int port\n+  @Shared\n+  int incorrectPort\n+  @Shared\n+  String dbAddr\n+  @Shared\n+  String dbAddrNonExistent\n+  @Shared\n+  String dbUriNonExistent\n+  @Shared\n+  String embeddedDbUri\n+\n+  @Shared\n+  RedisServer redisServer\n+\n+  @Shared\n+  Map<String, String> testHashMap = [\n+    firstname: \"John\",\n+    lastname : \"Doe\",\n+    age      : \"53\"\n+  ]\n+\n+  RedisClient redisClient\n+  StatefulConnection connection\n+  RedisAsyncCommands<String, ?> asyncCommands\n+  RedisCommands<String, ?> syncCommands\n+\n+  def setupSpec() {\n+    port = PortUtils.randomOpenPort()\n+    incorrectPort = PortUtils.randomOpenPort()\n+    dbAddr = HOST + \":\" + port + \"/\" + DB_INDEX\n+    dbAddrNonExistent = HOST + \":\" + incorrectPort + \"/\" + DB_INDEX\n+    dbUriNonExistent = \"redis://\" + dbAddrNonExistent\n+    embeddedDbUri = \"redis://\" + dbAddr\n+\n+    redisServer = RedisServer.builder()\n+    // bind to localhost to avoid firewall popup\n+      .setting(\"bind \" + HOST)\n+    // set max memory to avoid problems in CI\n+      .setting(\"maxmemory 128M\")\n+      .port(port).build()\n+  }\n+\n+  def setup() {\n+    redisClient = RedisClient.create(embeddedDbUri)\n+\n+    println \"Using redis: $redisServer.args\"\n+    redisServer.start()\n+    redisClient.setOptions(CLIENT_OPTIONS)\n+\n+    connection = redisClient.connect()\n+    asyncCommands = connection.async()\n+    syncCommands = connection.sync()\n+\n+    syncCommands.set(\"TESTKEY\", \"TESTVAL\")\n+\n+    // 1 set\n+    TEST_WRITER.waitForTraces(1)\n+    TEST_WRITER.clear()\n+  }\n+\n+  def cleanup() {\n+    connection.close()\n+    redisServer.stop()\n+  }\n+\n+  def \"connect using get on ConnectionFuture\"() {\n+    setup:\n+    RedisClient testConnectionClient = RedisClient.create(embeddedDbUri)\n+    testConnectionClient.setOptions(CLIENT_OPTIONS)\n+\n+    when:\n+    ConnectionFuture connectionFuture = testConnectionClient.connectAsync(StringCodec.UTF8,\n+      new RedisURI(HOST, port, 3, TimeUnit.SECONDS))\n+    StatefulConnection connection = connectionFuture.get()\n+\n+    then:\n+    connection != null\n+    // Lettuce tracing does not trace connect\n+    assertTraces(0) {}\n+\n+    cleanup:\n+    connection.close()\n+  }\n+\n+  def \"connect exception inside the connection future\"() {\n+    setup:\n+    RedisClient testConnectionClient = RedisClient.create(dbUriNonExistent)\n+    testConnectionClient.setOptions(CLIENT_OPTIONS)\n+\n+    when:\n+    ConnectionFuture connectionFuture = testConnectionClient.connectAsync(StringCodec.UTF8,\n+      new RedisURI(HOST, incorrectPort, 3, TimeUnit.SECONDS))\n+    StatefulConnection connection = connectionFuture.get()\n+\n+    then:\n+    connection == null\n+    thrown ExecutionException\n+    // Lettuce tracing does not trace connect\n+    assertTraces(0) {}\n+  }\n+\n+  def \"set command using Future get with timeout\"() {\n+    setup:\n+    RedisFuture<String> redisFuture = asyncCommands.set(\"TESTSETKEY\", \"TESTSETVAL\")\n+    String res = redisFuture.get(3, TimeUnit.SECONDS)\n+\n+    expect:\n+    res == \"OK\"\n+    assertTraces(1) {\n+      trace(0, 1) {\n+        span(0) {\n+          operationName \"SET\"\n+          spanKind CLIENT\n+          errored false\n+          tags {\n+            \"net.transport\" \"IP.TCP\"\n+            \"net.peer.ip\" \"127.0.0.1\"\n+            \"net.peer.port\" port\n+            \"db.type\" \"redis\"\n+            \"db.statement\" \"key<TESTSETKEY> value<TESTSETVAL>\"\n+          }\n+          event(0) {\n+            eventName \"redis.encode.start\"\n+          }\n+          event(1) {\n+            eventName \"redis.encode.end\"\n+          }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87e8547d14b6ec66592f81e3fc0694d69621da7c"}, "originalPosition": 176}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7cdf7ecbf8c555e339220c2507f3e75453f3d8e4", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/7cdf7ecbf8c555e339220c2507f3e75453f3d8e4", "committedDate": "2020-06-17T05:50:56Z", "message": "Cleanups"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36b141e9cca5910746e1b389ca2e7d153b5436f5", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/36b141e9cca5910746e1b389ca2e7d153b5436f5", "committedDate": "2020-06-17T06:25:03Z", "message": "Instrument 5.1+ instead"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyMDU3MDk5", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535#pullrequestreview-432057099", "createdAt": "2020-06-17T04:53:19Z", "commit": {"oid": "87e8547d14b6ec66592f81e3fc0694d69621da7c"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwNDo1MzoxOVrOGk1j0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwNTo0MDo0OFrOGk2WDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI3OTQ0MA==", "bodyText": "Copy-paste success! :)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535#discussion_r441279440", "createdAt": "2020-06-17T04:53:19Z", "author": {"login": "anuraaga"}, "path": "instrumentation/lettuce/lettuce-5.2/lettuce-5.2.gradle", "diffHunk": "@@ -0,0 +1,33 @@\n+// Set properties before any plugins get loaded\n+ext {\n+  minJavaVersionForTests = JavaVersion.VERSION_1_8\n+}\n+\n+apply from: \"${rootDir}/gradle/instrumentation.gradle\"\n+apply plugin: 'org.unbroken-dome.test-sets'\n+\n+muzzle {\n+  pass {\n+    group = \"io.lettuce\"\n+    module = \"lettuce-core\"\n+    versions = \"[5.2.0.RELEASE,)\"\n+    assertInverse = true\n+  }\n+}\n+\n+testSets {\n+  latestDepTest {\n+    dirName = 'test'\n+  }\n+}\n+\n+dependencies {\n+  compileOnly group: 'io.lettuce', name: 'lettuce-core', version: '5.2.0.RELEASE'\n+  compileOnly group: 'io.lettuce', name: 'lettuce-core', version: '5.2.0.RELEASE'", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDczMzI4Nw=="}, "originalCommit": {"oid": "87e8547d14b6ec66592f81e3fc0694d69621da7c"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI4MTA0OQ==", "bodyText": "Hehe this is from when I considered taking advantage of implementation details to reduce synchronization but ended up being safe.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535#discussion_r441281049", "createdAt": "2020-06-17T05:00:00Z", "author": {"login": "anuraaga"}, "path": "instrumentation/lettuce/lettuce-5.2/src/main/java8/io/opentelemetry/auto/instrumentation/lettuce/v5_2/OpenTelemetryTracing.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.auto.instrumentation.lettuce.v5_2;\n+\n+import static io.opentelemetry.auto.instrumentation.lettuce.v5_2.LettuceClientDecorator.TRACER;\n+\n+import io.grpc.Context;\n+import io.lettuce.core.tracing.TraceContext;\n+import io.lettuce.core.tracing.TraceContextProvider;\n+import io.lettuce.core.tracing.Tracer;\n+import io.lettuce.core.tracing.TracerProvider;\n+import io.lettuce.core.tracing.Tracing;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import reactor.util.annotation.Nullable;\n+\n+public enum OpenTelemetryTracing implements Tracing {\n+  INSTANCE;\n+\n+  @Override\n+  public TracerProvider getTracerProvider() {\n+    return OpenTelemetryTracerProvider.INSTANCE;\n+  }\n+\n+  @Override\n+  public TraceContextProvider initialTraceContextProvider() {\n+    return OpenTelemetryTraceContextProvider.INSTANCE;\n+  }\n+\n+  @Override\n+  public boolean isEnabled() {\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean includeCommandArgsInSpanTags() {\n+    return true;\n+  }\n+\n+  @Override\n+  public Endpoint createEndpoint(SocketAddress socketAddress) {\n+    if (socketAddress instanceof InetSocketAddress) {\n+      InetSocketAddress address = (InetSocketAddress) socketAddress;\n+\n+      return new OpenTelemetryEndpoint(\n+          address.getAddress().getHostAddress(), address.getPort(), address.getHostString());\n+    }\n+    return null;\n+  }\n+\n+  enum OpenTelemetryTracerProvider implements TracerProvider {\n+    INSTANCE;\n+\n+    private final Tracer openTelemetryTracer = new OpenTelemetryTracer();\n+\n+    @Override\n+    public Tracer getTracer() {\n+      return openTelemetryTracer;\n+    }\n+  }\n+\n+  enum OpenTelemetryTraceContextProvider implements TraceContextProvider {\n+    INSTANCE;\n+\n+    @Override\n+    public TraceContext getTraceContext() {\n+      return new OpenTelemetryTraceContext();\n+    }\n+  }\n+\n+  static class OpenTelemetryTraceContext implements TraceContext {\n+    private final Context context;\n+\n+    protected OpenTelemetryTraceContext() {\n+      this.context = Context.current();\n+    }\n+\n+    public Context getContext() {\n+      return context;\n+    }\n+  }\n+\n+  static class OpenTelemetryEndpoint implements Endpoint {\n+    final String ip;\n+    final int port;\n+    @Nullable final String name;\n+\n+    protected OpenTelemetryEndpoint(String ip, int port, @Nullable String name) {\n+      this.ip = ip;\n+      this.port = port;\n+      if (!ip.equals(name)) {\n+        this.name = name;\n+      } else {\n+        this.name = null;\n+      }\n+    }\n+  }\n+\n+  static class OpenTelemetryTracer extends Tracer {\n+\n+    protected OpenTelemetryTracer() {}\n+\n+    @Override\n+    public OpenTelemetrySpan nextSpan() {\n+      return new OpenTelemetrySpan(null);\n+    }\n+\n+    @Override\n+    public OpenTelemetrySpan nextSpan(TraceContext traceContext) {\n+      if (!(traceContext instanceof OpenTelemetryTraceContext)) {\n+        return nextSpan();\n+      }\n+\n+      Context context = ((OpenTelemetryTraceContext) traceContext).getContext();\n+\n+      final io.opentelemetry.trace.Span parent = TracingContextUtils.getSpanWithoutDefault(context);\n+\n+      return new OpenTelemetrySpan(parent);\n+    }\n+  }\n+\n+  // The order that callbacks will be called in or which thread they are called from is not well\n+  // defined. We go ahead and buffer all data until we know we have a span. This implementation is\n+  // particularly safe, synchronizing all accesses. Relying on implementation details would allow\n+  // reducing synchronization but the impact should be minimal.\n+  static class OpenTelemetrySpan extends Tracer.Span {\n+    @Nullable private final Span parent;\n+\n+    @Nullable private OpenTelemetryEndpoint endpoint;\n+    @Nullable private String name;\n+\n+    @Nullable private List<Object> events;\n+    @Nullable private List<String> tags;\n+\n+    @Nullable private Status status;\n+\n+    @Nullable private Span span;\n+\n+    protected OpenTelemetrySpan(@Nullable Span parent) {\n+      this.parent = parent;\n+    }\n+\n+    // Called before start. We need to buffer because this until then.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDczODg3OQ=="}, "originalCommit": {"oid": "87e8547d14b6ec66592f81e3fc0694d69621da7c"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI4MTYxMA==", "bodyText": "Yep - I think we do want to rely on explicit context propagation here since no clue what thread this is being run on (it probably won't but technically there's nothing wrong with a lettuce threadpool itself being traced by lettuce) while Lettuce provides the OpenTelemetryTracer SPI as the place to determine parent. So went with @trask's suggestion.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535#discussion_r441281610", "createdAt": "2020-06-17T05:02:03Z", "author": {"login": "anuraaga"}, "path": "instrumentation/lettuce/lettuce-5.2/src/main/java8/io/opentelemetry/auto/instrumentation/lettuce/v5_2/OpenTelemetryTracing.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.auto.instrumentation.lettuce.v5_2;\n+\n+import static io.opentelemetry.auto.instrumentation.lettuce.v5_2.LettuceClientDecorator.TRACER;\n+\n+import io.grpc.Context;\n+import io.lettuce.core.tracing.TraceContext;\n+import io.lettuce.core.tracing.TraceContextProvider;\n+import io.lettuce.core.tracing.Tracer;\n+import io.lettuce.core.tracing.TracerProvider;\n+import io.lettuce.core.tracing.Tracing;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import reactor.util.annotation.Nullable;\n+\n+public enum OpenTelemetryTracing implements Tracing {\n+  INSTANCE;\n+\n+  @Override\n+  public TracerProvider getTracerProvider() {\n+    return OpenTelemetryTracerProvider.INSTANCE;\n+  }\n+\n+  @Override\n+  public TraceContextProvider initialTraceContextProvider() {\n+    return OpenTelemetryTraceContextProvider.INSTANCE;\n+  }\n+\n+  @Override\n+  public boolean isEnabled() {\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean includeCommandArgsInSpanTags() {\n+    return true;\n+  }\n+\n+  @Override\n+  public Endpoint createEndpoint(SocketAddress socketAddress) {\n+    if (socketAddress instanceof InetSocketAddress) {\n+      InetSocketAddress address = (InetSocketAddress) socketAddress;\n+\n+      return new OpenTelemetryEndpoint(\n+          address.getAddress().getHostAddress(), address.getPort(), address.getHostString());\n+    }\n+    return null;\n+  }\n+\n+  enum OpenTelemetryTracerProvider implements TracerProvider {\n+    INSTANCE;\n+\n+    private final Tracer openTelemetryTracer = new OpenTelemetryTracer();\n+\n+    @Override\n+    public Tracer getTracer() {\n+      return openTelemetryTracer;\n+    }\n+  }\n+\n+  enum OpenTelemetryTraceContextProvider implements TraceContextProvider {\n+    INSTANCE;\n+\n+    @Override\n+    public TraceContext getTraceContext() {\n+      return new OpenTelemetryTraceContext();\n+    }\n+  }\n+\n+  static class OpenTelemetryTraceContext implements TraceContext {\n+    private final Context context;\n+\n+    protected OpenTelemetryTraceContext() {\n+      this.context = Context.current();\n+    }\n+\n+    public Context getContext() {\n+      return context;\n+    }\n+  }\n+\n+  static class OpenTelemetryEndpoint implements Endpoint {\n+    final String ip;\n+    final int port;\n+    @Nullable final String name;\n+\n+    protected OpenTelemetryEndpoint(String ip, int port, @Nullable String name) {\n+      this.ip = ip;\n+      this.port = port;\n+      if (!ip.equals(name)) {\n+        this.name = name;\n+      } else {\n+        this.name = null;\n+      }\n+    }\n+  }\n+\n+  static class OpenTelemetryTracer extends Tracer {\n+\n+    protected OpenTelemetryTracer() {}\n+\n+    @Override\n+    public OpenTelemetrySpan nextSpan() {\n+      return new OpenTelemetrySpan(null);\n+    }\n+\n+    @Override\n+    public OpenTelemetrySpan nextSpan(TraceContext traceContext) {\n+      if (!(traceContext instanceof OpenTelemetryTraceContext)) {\n+        return nextSpan();\n+      }\n+\n+      Context context = ((OpenTelemetryTraceContext) traceContext).getContext();\n+\n+      final io.opentelemetry.trace.Span parent = TracingContextUtils.getSpanWithoutDefault(context);\n+\n+      return new OpenTelemetrySpan(parent);\n+    }\n+  }\n+\n+  // The order that callbacks will be called in or which thread they are called from is not well\n+  // defined. We go ahead and buffer all data until we know we have a span. This implementation is\n+  // particularly safe, synchronizing all accesses. Relying on implementation details would allow\n+  // reducing synchronization but the impact should be minimal.\n+  static class OpenTelemetrySpan extends Tracer.Span {\n+    @Nullable private final Span parent;\n+\n+    @Nullable private OpenTelemetryEndpoint endpoint;\n+    @Nullable private String name;\n+\n+    @Nullable private List<Object> events;\n+    @Nullable private List<String> tags;\n+\n+    @Nullable private Status status;\n+\n+    @Nullable private Span span;\n+\n+    protected OpenTelemetrySpan(@Nullable Span parent) {\n+      this.parent = parent;\n+    }\n+\n+    // Called before start. We need to buffer because this until then.\n+    @Override\n+    public synchronized Tracer.Span name(String name) {\n+      if (span != null) {\n+        span.updateName(name);\n+      } else {\n+        this.name = name;\n+      }\n+\n+      return this;\n+    }\n+\n+    @Override\n+    public synchronized Tracer.Span remoteEndpoint(Endpoint endpoint) {\n+      if (endpoint instanceof OpenTelemetryEndpoint) {\n+        if (span != null) {\n+          fillEndpoint(span, (OpenTelemetryEndpoint) endpoint);\n+        } else {\n+          this.endpoint = (OpenTelemetryEndpoint) endpoint;\n+        }\n+      }\n+      return this;\n+    }\n+\n+    @Override\n+    public synchronized Tracer.Span start() {\n+      // If name() wasn't called yet we will update it later.\n+      String spanName = name != null ? name : \"REDIS\";\n+      Span.Builder builder = TRACER.spanBuilder(spanName).setSpanKind(Kind.CLIENT);\n+      if (parent != null) {\n+        builder.setParent(parent);\n+      } else {\n+        builder.setNoParent();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDczOTY5Nw=="}, "originalCommit": {"oid": "87e8547d14b6ec66592f81e3fc0694d69621da7c"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI4NDUyOQ==", "bodyText": "Unfortunately had to keep name since spanBuilder doesn't allow setting it, and some awkwardness for endpoint, but it seems to still be worth it.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535#discussion_r441284529", "createdAt": "2020-06-17T05:13:23Z", "author": {"login": "anuraaga"}, "path": "instrumentation/lettuce/lettuce-5.2/src/main/java8/io/opentelemetry/auto/instrumentation/lettuce/v5_2/OpenTelemetryTracing.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.auto.instrumentation.lettuce.v5_2;\n+\n+import static io.opentelemetry.auto.instrumentation.lettuce.v5_2.LettuceClientDecorator.TRACER;\n+\n+import io.grpc.Context;\n+import io.lettuce.core.tracing.TraceContext;\n+import io.lettuce.core.tracing.TraceContextProvider;\n+import io.lettuce.core.tracing.Tracer;\n+import io.lettuce.core.tracing.TracerProvider;\n+import io.lettuce.core.tracing.Tracing;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import reactor.util.annotation.Nullable;\n+\n+public enum OpenTelemetryTracing implements Tracing {\n+  INSTANCE;\n+\n+  @Override\n+  public TracerProvider getTracerProvider() {\n+    return OpenTelemetryTracerProvider.INSTANCE;\n+  }\n+\n+  @Override\n+  public TraceContextProvider initialTraceContextProvider() {\n+    return OpenTelemetryTraceContextProvider.INSTANCE;\n+  }\n+\n+  @Override\n+  public boolean isEnabled() {\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean includeCommandArgsInSpanTags() {\n+    return true;\n+  }\n+\n+  @Override\n+  public Endpoint createEndpoint(SocketAddress socketAddress) {\n+    if (socketAddress instanceof InetSocketAddress) {\n+      InetSocketAddress address = (InetSocketAddress) socketAddress;\n+\n+      return new OpenTelemetryEndpoint(\n+          address.getAddress().getHostAddress(), address.getPort(), address.getHostString());\n+    }\n+    return null;\n+  }\n+\n+  enum OpenTelemetryTracerProvider implements TracerProvider {\n+    INSTANCE;\n+\n+    private final Tracer openTelemetryTracer = new OpenTelemetryTracer();\n+\n+    @Override\n+    public Tracer getTracer() {\n+      return openTelemetryTracer;\n+    }\n+  }\n+\n+  enum OpenTelemetryTraceContextProvider implements TraceContextProvider {\n+    INSTANCE;\n+\n+    @Override\n+    public TraceContext getTraceContext() {\n+      return new OpenTelemetryTraceContext();\n+    }\n+  }\n+\n+  static class OpenTelemetryTraceContext implements TraceContext {\n+    private final Context context;\n+\n+    protected OpenTelemetryTraceContext() {\n+      this.context = Context.current();\n+    }\n+\n+    public Context getContext() {\n+      return context;\n+    }\n+  }\n+\n+  static class OpenTelemetryEndpoint implements Endpoint {\n+    final String ip;\n+    final int port;\n+    @Nullable final String name;\n+\n+    protected OpenTelemetryEndpoint(String ip, int port, @Nullable String name) {\n+      this.ip = ip;\n+      this.port = port;\n+      if (!ip.equals(name)) {\n+        this.name = name;\n+      } else {\n+        this.name = null;\n+      }\n+    }\n+  }\n+\n+  static class OpenTelemetryTracer extends Tracer {\n+\n+    protected OpenTelemetryTracer() {}\n+\n+    @Override\n+    public OpenTelemetrySpan nextSpan() {\n+      return new OpenTelemetrySpan(null);\n+    }\n+\n+    @Override\n+    public OpenTelemetrySpan nextSpan(TraceContext traceContext) {\n+      if (!(traceContext instanceof OpenTelemetryTraceContext)) {\n+        return nextSpan();\n+      }\n+\n+      Context context = ((OpenTelemetryTraceContext) traceContext).getContext();\n+\n+      final io.opentelemetry.trace.Span parent = TracingContextUtils.getSpanWithoutDefault(context);\n+\n+      return new OpenTelemetrySpan(parent);\n+    }\n+  }\n+\n+  // The order that callbacks will be called in or which thread they are called from is not well\n+  // defined. We go ahead and buffer all data until we know we have a span. This implementation is\n+  // particularly safe, synchronizing all accesses. Relying on implementation details would allow\n+  // reducing synchronization but the impact should be minimal.\n+  static class OpenTelemetrySpan extends Tracer.Span {\n+    @Nullable private final Span parent;\n+\n+    @Nullable private OpenTelemetryEndpoint endpoint;\n+    @Nullable private String name;\n+\n+    @Nullable private List<Object> events;\n+    @Nullable private List<String> tags;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE2OTI1MA=="}, "originalCommit": {"oid": "87e8547d14b6ec66592f81e3fc0694d69621da7c"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI4NDg3MA==", "bodyText": "Don't tests have a test timeout?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535#discussion_r441284870", "createdAt": "2020-06-17T05:14:36Z", "author": {"login": "anuraaga"}, "path": "instrumentation/lettuce/lettuce-5.2/src/test/groovy/io/opentelemetry/auto/instrumentation/lettuce/v5_2/LettuceAsyncClientTest.groovy", "diffHunk": "@@ -0,0 +1,400 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.auto.instrumentation.lettuce.v5_2\n+\n+import io.lettuce.core.ClientOptions\n+import io.lettuce.core.ConnectionFuture\n+import io.lettuce.core.RedisClient\n+import io.lettuce.core.RedisFuture\n+import io.lettuce.core.RedisURI\n+import io.lettuce.core.api.StatefulConnection\n+import io.lettuce.core.api.async.RedisAsyncCommands\n+import io.lettuce.core.api.sync.RedisCommands\n+import io.lettuce.core.codec.StringCodec\n+import io.opentelemetry.auto.test.AgentTestRunner\n+import io.opentelemetry.auto.test.utils.PortUtils\n+import redis.embedded.RedisServer\n+import spock.lang.Shared\n+import spock.util.concurrent.AsyncConditions\n+\n+import java.util.concurrent.ExecutionException\n+import java.util.concurrent.TimeUnit\n+import java.util.function.BiConsumer\n+import java.util.function.BiFunction\n+import java.util.function.Consumer\n+import java.util.function.Function\n+\n+import static io.opentelemetry.trace.Span.Kind.CLIENT\n+\n+class LettuceAsyncClientTest extends AgentTestRunner {\n+  public static final String HOST = \"127.0.0.1\"\n+  public static final int DB_INDEX = 0\n+  // Disable autoreconnect so we do not get stray traces popping up on server shutdown\n+  public static final ClientOptions CLIENT_OPTIONS = ClientOptions.builder().autoReconnect(false).build()\n+\n+  @Shared\n+  int port\n+  @Shared\n+  int incorrectPort\n+  @Shared\n+  String dbAddr\n+  @Shared\n+  String dbAddrNonExistent\n+  @Shared\n+  String dbUriNonExistent\n+  @Shared\n+  String embeddedDbUri\n+\n+  @Shared\n+  RedisServer redisServer\n+\n+  @Shared\n+  Map<String, String> testHashMap = [\n+    firstname: \"John\",\n+    lastname : \"Doe\",\n+    age      : \"53\"\n+  ]\n+\n+  RedisClient redisClient\n+  StatefulConnection connection\n+  RedisAsyncCommands<String, ?> asyncCommands\n+  RedisCommands<String, ?> syncCommands\n+\n+  def setupSpec() {\n+    port = PortUtils.randomOpenPort()\n+    incorrectPort = PortUtils.randomOpenPort()\n+    dbAddr = HOST + \":\" + port + \"/\" + DB_INDEX\n+    dbAddrNonExistent = HOST + \":\" + incorrectPort + \"/\" + DB_INDEX\n+    dbUriNonExistent = \"redis://\" + dbAddrNonExistent\n+    embeddedDbUri = \"redis://\" + dbAddr\n+\n+    redisServer = RedisServer.builder()\n+    // bind to localhost to avoid firewall popup\n+      .setting(\"bind \" + HOST)\n+    // set max memory to avoid problems in CI\n+      .setting(\"maxmemory 128M\")\n+      .port(port).build()\n+  }\n+\n+  def setup() {\n+    redisClient = RedisClient.create(embeddedDbUri)\n+\n+    println \"Using redis: $redisServer.args\"\n+    redisServer.start()\n+    redisClient.setOptions(CLIENT_OPTIONS)\n+\n+    connection = redisClient.connect()\n+    asyncCommands = connection.async()\n+    syncCommands = connection.sync()\n+\n+    syncCommands.set(\"TESTKEY\", \"TESTVAL\")\n+\n+    // 1 set\n+    TEST_WRITER.waitForTraces(1)\n+    TEST_WRITER.clear()\n+  }\n+\n+  def cleanup() {\n+    connection.close()\n+    redisServer.stop()\n+  }\n+\n+  def \"connect using get on ConnectionFuture\"() {\n+    setup:\n+    RedisClient testConnectionClient = RedisClient.create(embeddedDbUri)\n+    testConnectionClient.setOptions(CLIENT_OPTIONS)\n+\n+    when:\n+    ConnectionFuture connectionFuture = testConnectionClient.connectAsync(StringCodec.UTF8,\n+      new RedisURI(HOST, port, 3, TimeUnit.SECONDS))\n+    StatefulConnection connection = connectionFuture.get()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc0MjkxNQ=="}, "originalCommit": {"oid": "87e8547d14b6ec66592f81e3fc0694d69621da7c"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI5MDAyNQ==", "bodyText": "I tend to lean towards instrumenting what we can, and users can use a downstream mechanism, e.g. span processor, to remove fields they don't need. Might help someone and while data can be filtered, there's no way to work around the lack of instrumentation.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535#discussion_r441290025", "createdAt": "2020-06-17T05:33:30Z", "author": {"login": "anuraaga"}, "path": "instrumentation/lettuce/lettuce-5.2/src/test/groovy/io/opentelemetry/auto/instrumentation/lettuce/v5_2/LettuceAsyncClientTest.groovy", "diffHunk": "@@ -0,0 +1,400 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.auto.instrumentation.lettuce.v5_2\n+\n+import io.lettuce.core.ClientOptions\n+import io.lettuce.core.ConnectionFuture\n+import io.lettuce.core.RedisClient\n+import io.lettuce.core.RedisFuture\n+import io.lettuce.core.RedisURI\n+import io.lettuce.core.api.StatefulConnection\n+import io.lettuce.core.api.async.RedisAsyncCommands\n+import io.lettuce.core.api.sync.RedisCommands\n+import io.lettuce.core.codec.StringCodec\n+import io.opentelemetry.auto.test.AgentTestRunner\n+import io.opentelemetry.auto.test.utils.PortUtils\n+import redis.embedded.RedisServer\n+import spock.lang.Shared\n+import spock.util.concurrent.AsyncConditions\n+\n+import java.util.concurrent.ExecutionException\n+import java.util.concurrent.TimeUnit\n+import java.util.function.BiConsumer\n+import java.util.function.BiFunction\n+import java.util.function.Consumer\n+import java.util.function.Function\n+\n+import static io.opentelemetry.trace.Span.Kind.CLIENT\n+\n+class LettuceAsyncClientTest extends AgentTestRunner {\n+  public static final String HOST = \"127.0.0.1\"\n+  public static final int DB_INDEX = 0\n+  // Disable autoreconnect so we do not get stray traces popping up on server shutdown\n+  public static final ClientOptions CLIENT_OPTIONS = ClientOptions.builder().autoReconnect(false).build()\n+\n+  @Shared\n+  int port\n+  @Shared\n+  int incorrectPort\n+  @Shared\n+  String dbAddr\n+  @Shared\n+  String dbAddrNonExistent\n+  @Shared\n+  String dbUriNonExistent\n+  @Shared\n+  String embeddedDbUri\n+\n+  @Shared\n+  RedisServer redisServer\n+\n+  @Shared\n+  Map<String, String> testHashMap = [\n+    firstname: \"John\",\n+    lastname : \"Doe\",\n+    age      : \"53\"\n+  ]\n+\n+  RedisClient redisClient\n+  StatefulConnection connection\n+  RedisAsyncCommands<String, ?> asyncCommands\n+  RedisCommands<String, ?> syncCommands\n+\n+  def setupSpec() {\n+    port = PortUtils.randomOpenPort()\n+    incorrectPort = PortUtils.randomOpenPort()\n+    dbAddr = HOST + \":\" + port + \"/\" + DB_INDEX\n+    dbAddrNonExistent = HOST + \":\" + incorrectPort + \"/\" + DB_INDEX\n+    dbUriNonExistent = \"redis://\" + dbAddrNonExistent\n+    embeddedDbUri = \"redis://\" + dbAddr\n+\n+    redisServer = RedisServer.builder()\n+    // bind to localhost to avoid firewall popup\n+      .setting(\"bind \" + HOST)\n+    // set max memory to avoid problems in CI\n+      .setting(\"maxmemory 128M\")\n+      .port(port).build()\n+  }\n+\n+  def setup() {\n+    redisClient = RedisClient.create(embeddedDbUri)\n+\n+    println \"Using redis: $redisServer.args\"\n+    redisServer.start()\n+    redisClient.setOptions(CLIENT_OPTIONS)\n+\n+    connection = redisClient.connect()\n+    asyncCommands = connection.async()\n+    syncCommands = connection.sync()\n+\n+    syncCommands.set(\"TESTKEY\", \"TESTVAL\")\n+\n+    // 1 set\n+    TEST_WRITER.waitForTraces(1)\n+    TEST_WRITER.clear()\n+  }\n+\n+  def cleanup() {\n+    connection.close()\n+    redisServer.stop()\n+  }\n+\n+  def \"connect using get on ConnectionFuture\"() {\n+    setup:\n+    RedisClient testConnectionClient = RedisClient.create(embeddedDbUri)\n+    testConnectionClient.setOptions(CLIENT_OPTIONS)\n+\n+    when:\n+    ConnectionFuture connectionFuture = testConnectionClient.connectAsync(StringCodec.UTF8,\n+      new RedisURI(HOST, port, 3, TimeUnit.SECONDS))\n+    StatefulConnection connection = connectionFuture.get()\n+\n+    then:\n+    connection != null\n+    // Lettuce tracing does not trace connect\n+    assertTraces(0) {}\n+\n+    cleanup:\n+    connection.close()\n+  }\n+\n+  def \"connect exception inside the connection future\"() {\n+    setup:\n+    RedisClient testConnectionClient = RedisClient.create(dbUriNonExistent)\n+    testConnectionClient.setOptions(CLIENT_OPTIONS)\n+\n+    when:\n+    ConnectionFuture connectionFuture = testConnectionClient.connectAsync(StringCodec.UTF8,\n+      new RedisURI(HOST, incorrectPort, 3, TimeUnit.SECONDS))\n+    StatefulConnection connection = connectionFuture.get()\n+\n+    then:\n+    connection == null\n+    thrown ExecutionException\n+    // Lettuce tracing does not trace connect\n+    assertTraces(0) {}\n+  }\n+\n+  def \"set command using Future get with timeout\"() {\n+    setup:\n+    RedisFuture<String> redisFuture = asyncCommands.set(\"TESTSETKEY\", \"TESTSETVAL\")\n+    String res = redisFuture.get(3, TimeUnit.SECONDS)\n+\n+    expect:\n+    res == \"OK\"\n+    assertTraces(1) {\n+      trace(0, 1) {\n+        span(0) {\n+          operationName \"SET\"\n+          spanKind CLIENT\n+          errored false\n+          tags {\n+            \"net.transport\" \"IP.TCP\"\n+            \"net.peer.ip\" \"127.0.0.1\"\n+            \"net.peer.port\" port\n+            \"db.type\" \"redis\"\n+            \"db.statement\" \"key<TESTSETKEY> value<TESTSETVAL>\"\n+          }\n+          event(0) {\n+            eventName \"redis.encode.start\"\n+          }\n+          event(1) {\n+            eventName \"redis.encode.end\"\n+          }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE3NDg0Ng=="}, "originalCommit": {"oid": "87e8547d14b6ec66592f81e3fc0694d69621da7c"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI5MjMwMA==", "bodyText": "Unfortunately the interface doesn't provide RedisURI, I have filed an issue for it\nlettuce-io/lettuce-core#1312\nI think user and db_index are less commonly used with redis and we can probably live without them for now.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535#discussion_r441292300", "createdAt": "2020-06-17T05:40:48Z", "author": {"login": "anuraaga"}, "path": "instrumentation/lettuce/lettuce-5.2/src/test/groovy/io/opentelemetry/auto/instrumentation/lettuce/v5_2/LettuceAsyncClientTest.groovy", "diffHunk": "@@ -0,0 +1,400 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.auto.instrumentation.lettuce.v5_2\n+\n+import io.lettuce.core.ClientOptions\n+import io.lettuce.core.ConnectionFuture\n+import io.lettuce.core.RedisClient\n+import io.lettuce.core.RedisFuture\n+import io.lettuce.core.RedisURI\n+import io.lettuce.core.api.StatefulConnection\n+import io.lettuce.core.api.async.RedisAsyncCommands\n+import io.lettuce.core.api.sync.RedisCommands\n+import io.lettuce.core.codec.StringCodec\n+import io.opentelemetry.auto.test.AgentTestRunner\n+import io.opentelemetry.auto.test.utils.PortUtils\n+import redis.embedded.RedisServer\n+import spock.lang.Shared\n+import spock.util.concurrent.AsyncConditions\n+\n+import java.util.concurrent.ExecutionException\n+import java.util.concurrent.TimeUnit\n+import java.util.function.BiConsumer\n+import java.util.function.BiFunction\n+import java.util.function.Consumer\n+import java.util.function.Function\n+\n+import static io.opentelemetry.trace.Span.Kind.CLIENT\n+\n+class LettuceAsyncClientTest extends AgentTestRunner {\n+  public static final String HOST = \"127.0.0.1\"\n+  public static final int DB_INDEX = 0\n+  // Disable autoreconnect so we do not get stray traces popping up on server shutdown\n+  public static final ClientOptions CLIENT_OPTIONS = ClientOptions.builder().autoReconnect(false).build()\n+\n+  @Shared\n+  int port\n+  @Shared\n+  int incorrectPort\n+  @Shared\n+  String dbAddr\n+  @Shared\n+  String dbAddrNonExistent\n+  @Shared\n+  String dbUriNonExistent\n+  @Shared\n+  String embeddedDbUri\n+\n+  @Shared\n+  RedisServer redisServer\n+\n+  @Shared\n+  Map<String, String> testHashMap = [\n+    firstname: \"John\",\n+    lastname : \"Doe\",\n+    age      : \"53\"\n+  ]\n+\n+  RedisClient redisClient\n+  StatefulConnection connection\n+  RedisAsyncCommands<String, ?> asyncCommands\n+  RedisCommands<String, ?> syncCommands\n+\n+  def setupSpec() {\n+    port = PortUtils.randomOpenPort()\n+    incorrectPort = PortUtils.randomOpenPort()\n+    dbAddr = HOST + \":\" + port + \"/\" + DB_INDEX\n+    dbAddrNonExistent = HOST + \":\" + incorrectPort + \"/\" + DB_INDEX\n+    dbUriNonExistent = \"redis://\" + dbAddrNonExistent\n+    embeddedDbUri = \"redis://\" + dbAddr\n+\n+    redisServer = RedisServer.builder()\n+    // bind to localhost to avoid firewall popup\n+      .setting(\"bind \" + HOST)\n+    // set max memory to avoid problems in CI\n+      .setting(\"maxmemory 128M\")\n+      .port(port).build()\n+  }\n+\n+  def setup() {\n+    redisClient = RedisClient.create(embeddedDbUri)\n+\n+    println \"Using redis: $redisServer.args\"\n+    redisServer.start()\n+    redisClient.setOptions(CLIENT_OPTIONS)\n+\n+    connection = redisClient.connect()\n+    asyncCommands = connection.async()\n+    syncCommands = connection.sync()\n+\n+    syncCommands.set(\"TESTKEY\", \"TESTVAL\")\n+\n+    // 1 set\n+    TEST_WRITER.waitForTraces(1)\n+    TEST_WRITER.clear()\n+  }\n+\n+  def cleanup() {\n+    connection.close()\n+    redisServer.stop()\n+  }\n+\n+  def \"connect using get on ConnectionFuture\"() {\n+    setup:\n+    RedisClient testConnectionClient = RedisClient.create(embeddedDbUri)\n+    testConnectionClient.setOptions(CLIENT_OPTIONS)\n+\n+    when:\n+    ConnectionFuture connectionFuture = testConnectionClient.connectAsync(StringCodec.UTF8,\n+      new RedisURI(HOST, port, 3, TimeUnit.SECONDS))\n+    StatefulConnection connection = connectionFuture.get()\n+\n+    then:\n+    connection != null\n+    // Lettuce tracing does not trace connect\n+    assertTraces(0) {}\n+\n+    cleanup:\n+    connection.close()\n+  }\n+\n+  def \"connect exception inside the connection future\"() {\n+    setup:\n+    RedisClient testConnectionClient = RedisClient.create(dbUriNonExistent)\n+    testConnectionClient.setOptions(CLIENT_OPTIONS)\n+\n+    when:\n+    ConnectionFuture connectionFuture = testConnectionClient.connectAsync(StringCodec.UTF8,\n+      new RedisURI(HOST, incorrectPort, 3, TimeUnit.SECONDS))\n+    StatefulConnection connection = connectionFuture.get()\n+\n+    then:\n+    connection == null\n+    thrown ExecutionException\n+    // Lettuce tracing does not trace connect\n+    assertTraces(0) {}\n+  }\n+\n+  def \"set command using Future get with timeout\"() {\n+    setup:\n+    RedisFuture<String> redisFuture = asyncCommands.set(\"TESTSETKEY\", \"TESTSETVAL\")\n+    String res = redisFuture.get(3, TimeUnit.SECONDS)\n+\n+    expect:\n+    res == \"OK\"\n+    assertTraces(1) {\n+      trace(0, 1) {\n+        span(0) {\n+          operationName \"SET\"\n+          spanKind CLIENT\n+          errored false\n+          tags {\n+            \"net.transport\" \"IP.TCP\"\n+            \"net.peer.ip\" \"127.0.0.1\"\n+            \"net.peer.port\" port\n+            \"db.type\" \"redis\"\n+            \"db.statement\" \"key<TESTSETKEY> value<TESTSETVAL>\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc0NTI2Mg=="}, "originalCommit": {"oid": "87e8547d14b6ec66592f81e3fc0694d69621da7c"}, "originalPosition": 169}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyMDk5MDM4", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535#pullrequestreview-432099038", "createdAt": "2020-06-17T06:39:32Z", "commit": {"oid": "36b141e9cca5910746e1b389ca2e7d153b5436f5"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwNjozOTozMlrOGk3opA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwNjo0NToyN1rOGk3yEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxMzQ0NA==", "bodyText": "Shouldn't this be 5.1.0.RELEASE?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535#discussion_r441313444", "createdAt": "2020-06-17T06:39:32Z", "author": {"login": "iNikem"}, "path": "instrumentation/lettuce/lettuce-5.1/lettuce-5.1.gradle", "diffHunk": "@@ -0,0 +1,32 @@\n+// Set properties before any plugins get loaded\n+ext {\n+  minJavaVersionForTests = JavaVersion.VERSION_1_8\n+}\n+\n+apply from: \"${rootDir}/gradle/instrumentation.gradle\"\n+apply plugin: 'org.unbroken-dome.test-sets'\n+\n+muzzle {\n+  pass {\n+    group = \"io.lettuce\"\n+    module = \"lettuce-core\"\n+    versions = \"[5.1.0.RELEASE,)\"\n+    assertInverse = true\n+  }\n+}\n+\n+testSets {\n+  latestDepTest {\n+    dirName = 'test'\n+  }\n+}\n+\n+dependencies {\n+  compileOnly group: 'io.lettuce', name: 'lettuce-core', version: '5.2.0.RELEASE'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36b141e9cca5910746e1b389ca2e7d153b5436f5"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxNTQwOA==", "bodyText": "db.instance and db.statement are marked as required in https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/database.md", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535#discussion_r441315408", "createdAt": "2020-06-17T06:44:21Z", "author": {"login": "iNikem"}, "path": "instrumentation/lettuce/lettuce-5.1/src/test/groovy/io/opentelemetry/auto/instrumentation/lettuce/v5_1/LettuceReactiveClientTest.groovy", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.auto.instrumentation.lettuce.v5_1\n+\n+import io.lettuce.core.ClientOptions\n+import io.lettuce.core.RedisClient\n+import io.lettuce.core.api.StatefulConnection\n+import io.lettuce.core.api.reactive.RedisReactiveCommands\n+import io.lettuce.core.api.sync.RedisCommands\n+import io.opentelemetry.auto.test.AgentTestRunner\n+import io.opentelemetry.auto.test.utils.PortUtils\n+import reactor.core.scheduler.Schedulers\n+import redis.embedded.RedisServer\n+import spock.lang.Shared\n+import spock.util.concurrent.AsyncConditions\n+\n+import java.util.function.Consumer\n+\n+import static io.opentelemetry.auto.test.utils.TraceUtils.runUnderTrace\n+import static io.opentelemetry.trace.Span.Kind.CLIENT\n+\n+class LettuceReactiveClientTest extends AgentTestRunner {\n+  public static final String HOST = \"127.0.0.1\"\n+  public static final int DB_INDEX = 0\n+  // Disable autoreconnect so we do not get stray traces popping up on server shutdown\n+  public static final ClientOptions CLIENT_OPTIONS = ClientOptions.builder().autoReconnect(false).build()\n+\n+  @Shared\n+  int port\n+  @Shared\n+  String embeddedDbUri\n+\n+  @Shared\n+  RedisServer redisServer\n+\n+  RedisClient redisClient\n+  StatefulConnection connection\n+  RedisReactiveCommands<String, ?> reactiveCommands\n+  RedisCommands<String, ?> syncCommands\n+\n+  def setupSpec() {\n+    port = PortUtils.randomOpenPort()\n+    String dbAddr = HOST + \":\" + port + \"/\" + DB_INDEX\n+    embeddedDbUri = \"redis://\" + dbAddr\n+\n+    redisServer = RedisServer.builder()\n+    // bind to localhost to avoid firewall popup\n+      .setting(\"bind \" + HOST)\n+    // set max memory to avoid problems in CI\n+      .setting(\"maxmemory 128M\")\n+      .port(port).build()\n+  }\n+\n+  def setup() {\n+    redisClient = RedisClient.create(embeddedDbUri)\n+\n+    println \"Using redis: $redisServer.args\"\n+    redisServer.start()\n+    redisClient.setOptions(CLIENT_OPTIONS)\n+\n+    connection = redisClient.connect()\n+    reactiveCommands = connection.reactive()\n+    syncCommands = connection.sync()\n+\n+    syncCommands.set(\"TESTKEY\", \"TESTVAL\")\n+\n+    // 1 set\n+    TEST_WRITER.waitForTraces(1)\n+    TEST_WRITER.clear()\n+  }\n+\n+  def cleanup() {\n+    connection.close()\n+    redisClient.shutdown()\n+    redisServer.stop()\n+  }\n+\n+  def \"set command with subscribe on a defined consumer\"() {\n+    setup:\n+    def conds = new AsyncConditions()\n+    Consumer<String> consumer = new Consumer<String>() {\n+      @Override\n+      void accept(String res) {\n+        conds.evaluate {\n+          assert res == \"OK\"\n+        }\n+      }\n+    }\n+\n+    when:\n+    reactiveCommands.set(\"TESTSETKEY\", \"TESTSETVAL\").subscribe(consumer)\n+\n+    then:\n+    conds.await()\n+    assertTraces(1) {\n+      trace(0, 1) {\n+        span(0) {\n+          operationName \"SET\"\n+          spanKind CLIENT\n+          errored false\n+          tags {\n+            \"net.transport\" \"IP.TCP\"\n+            \"net.peer.ip\" \"127.0.0.1\"\n+            \"net.peer.port\" port\n+            \"db.url\" \"redis://127.0.0.1:$port\"\n+            \"db.type\" \"redis\"\n+            \"db.statement\" \"key<TESTSETKEY> value<TESTSETVAL>\"\n+          }\n+          event(0) {\n+            eventName \"redis.encode.start\"\n+          }\n+          event(1) {\n+            eventName \"redis.encode.end\"\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  def \"get command with lambda function\"() {\n+    setup:\n+    def conds = new AsyncConditions()\n+\n+    when:\n+    reactiveCommands.get(\"TESTKEY\").subscribe { res -> conds.evaluate { assert res == \"TESTVAL\" } }\n+\n+    then:\n+    conds.await()\n+    assertTraces(1) {\n+      trace(0, 1) {\n+        span(0) {\n+          operationName \"GET\"\n+          spanKind CLIENT\n+          errored false\n+          tags {\n+            \"net.transport\" \"IP.TCP\"\n+            \"net.peer.ip\" \"127.0.0.1\"\n+            \"net.peer.port\" port\n+            \"db.url\" \"redis://127.0.0.1:$port\"\n+            \"db.type\" \"redis\"\n+            \"db.statement\" \"key<TESTKEY>\"\n+          }\n+          event(0) {\n+            eventName \"redis.encode.start\"\n+          }\n+          event(1) {\n+            eventName \"redis.encode.end\"\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  // to make sure instrumentation's chained completion stages won't interfere with user's, while still\n+  // recording metrics\n+  def \"get non existent key command\"() {\n+    setup:\n+    def conds = new AsyncConditions()\n+    final defaultVal = \"NOT THIS VALUE\"\n+\n+    when:\n+    reactiveCommands.get(\"NON_EXISTENT_KEY\").defaultIfEmpty(defaultVal).subscribe {\n+      res ->\n+        conds.evaluate {\n+          assert res == defaultVal\n+        }\n+    }\n+\n+    then:\n+    conds.await()\n+    assertTraces(1) {\n+      trace(0, 1) {\n+        span(0) {\n+          operationName \"GET\"\n+          spanKind CLIENT\n+          errored false\n+          tags {\n+            \"net.transport\" \"IP.TCP\"\n+            \"net.peer.ip\" \"127.0.0.1\"\n+            \"net.peer.port\" port\n+            \"db.url\" \"redis://127.0.0.1:$port\"\n+            \"db.type\" \"redis\"\n+            \"db.statement\" \"key<NON_EXISTENT_KEY>\"\n+          }\n+          event(0) {\n+            eventName \"redis.encode.start\"\n+          }\n+          event(1) {\n+            eventName \"redis.encode.end\"\n+          }\n+        }\n+      }\n+    }\n+\n+  }\n+\n+  def \"command with no arguments\"() {\n+    setup:\n+    def conds = new AsyncConditions()\n+\n+    when:\n+    reactiveCommands.randomkey().subscribe {\n+      res ->\n+        conds.evaluate {\n+          assert res == \"TESTKEY\"\n+        }\n+    }\n+\n+    then:\n+    conds.await()\n+    assertTraces(1) {\n+      trace(0, 1) {\n+        span(0) {\n+          operationName \"RANDOMKEY\"\n+          spanKind CLIENT\n+          errored false\n+          tags {\n+            \"net.transport\" \"IP.TCP\"\n+            \"net.peer.ip\" \"127.0.0.1\"\n+            \"net.peer.port\" port\n+            \"db.url\" \"redis://127.0.0.1:$port\"\n+            \"db.type\" \"redis\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36b141e9cca5910746e1b389ca2e7d153b5436f5"}, "originalPosition": 235}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxNTg1Ng==", "bodyText": "I don't think that all our tests has inherent timeout. At least I have seen test hanging for a very long time before I abort them manually.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535#discussion_r441315856", "createdAt": "2020-06-17T06:45:27Z", "author": {"login": "iNikem"}, "path": "instrumentation/lettuce/lettuce-5.1/src/test/groovy/io/opentelemetry/auto/instrumentation/lettuce/v5_1/LettuceAsyncClientTest.groovy", "diffHunk": "@@ -0,0 +1,406 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.auto.instrumentation.lettuce.v5_1\n+\n+import io.lettuce.core.ClientOptions\n+import io.lettuce.core.ConnectionFuture\n+import io.lettuce.core.RedisClient\n+import io.lettuce.core.RedisFuture\n+import io.lettuce.core.RedisURI\n+import io.lettuce.core.api.StatefulConnection\n+import io.lettuce.core.api.async.RedisAsyncCommands\n+import io.lettuce.core.api.sync.RedisCommands\n+import io.lettuce.core.codec.StringCodec\n+import io.opentelemetry.auto.test.AgentTestRunner\n+import io.opentelemetry.auto.test.utils.PortUtils\n+import redis.embedded.RedisServer\n+import spock.lang.Shared\n+import spock.util.concurrent.AsyncConditions\n+\n+import java.util.concurrent.ExecutionException\n+import java.util.concurrent.TimeUnit\n+import java.util.function.BiConsumer\n+import java.util.function.BiFunction\n+import java.util.function.Consumer\n+import java.util.function.Function\n+\n+import static io.opentelemetry.trace.Span.Kind.CLIENT\n+\n+class LettuceAsyncClientTest extends AgentTestRunner {\n+  public static final String HOST = \"127.0.0.1\"\n+  public static final int DB_INDEX = 0\n+  // Disable autoreconnect so we do not get stray traces popping up on server shutdown\n+  public static final ClientOptions CLIENT_OPTIONS = ClientOptions.builder().autoReconnect(false).build()\n+\n+  @Shared\n+  int port\n+  @Shared\n+  int incorrectPort\n+  @Shared\n+  String dbAddr\n+  @Shared\n+  String dbAddrNonExistent\n+  @Shared\n+  String dbUriNonExistent\n+  @Shared\n+  String embeddedDbUri\n+\n+  @Shared\n+  RedisServer redisServer\n+\n+  @Shared\n+  Map<String, String> testHashMap = [\n+    firstname: \"John\",\n+    lastname : \"Doe\",\n+    age      : \"53\"\n+  ]\n+\n+  RedisClient redisClient\n+  StatefulConnection connection\n+  RedisAsyncCommands<String, ?> asyncCommands\n+  RedisCommands<String, ?> syncCommands\n+\n+  def setupSpec() {\n+    port = PortUtils.randomOpenPort()\n+    incorrectPort = PortUtils.randomOpenPort()\n+    dbAddr = HOST + \":\" + port + \"/\" + DB_INDEX\n+    dbAddrNonExistent = HOST + \":\" + incorrectPort + \"/\" + DB_INDEX\n+    dbUriNonExistent = \"redis://\" + dbAddrNonExistent\n+    embeddedDbUri = \"redis://\" + dbAddr\n+\n+    redisServer = RedisServer.builder()\n+    // bind to localhost to avoid firewall popup\n+      .setting(\"bind \" + HOST)\n+    // set max memory to avoid problems in CI\n+      .setting(\"maxmemory 128M\")\n+      .port(port).build()\n+  }\n+\n+  def setup() {\n+    redisClient = RedisClient.create(embeddedDbUri)\n+\n+    println \"Using redis: $redisServer.args\"\n+    redisServer.start()\n+    redisClient.setOptions(CLIENT_OPTIONS)\n+\n+    connection = redisClient.connect()\n+    asyncCommands = connection.async()\n+    syncCommands = connection.sync()\n+\n+    syncCommands.set(\"TESTKEY\", \"TESTVAL\")\n+\n+    // 1 set\n+    TEST_WRITER.waitForTraces(1)\n+    TEST_WRITER.clear()\n+  }\n+\n+  def cleanup() {\n+    connection.close()\n+    redisServer.stop()\n+  }\n+\n+  def \"connect using get on ConnectionFuture\"() {\n+    setup:\n+    RedisClient testConnectionClient = RedisClient.create(embeddedDbUri)\n+    testConnectionClient.setOptions(CLIENT_OPTIONS)\n+\n+    when:\n+    ConnectionFuture connectionFuture = testConnectionClient.connectAsync(StringCodec.UTF8,\n+      new RedisURI(HOST, port, 3, TimeUnit.SECONDS))\n+    StatefulConnection connection = connectionFuture.get()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36b141e9cca5910746e1b389ca2e7d153b5436f5"}, "originalPosition": 123}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5fab23d0b1d171973b1eec353a2c1193ca9d5601", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/5fab23d0b1d171973b1eec353a2c1193ca9d5601", "committedDate": "2020-06-17T07:24:43Z", "message": "Cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d8ee86fa2cf866c06d1850419a2f5b5ef9c3324b", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/d8ee86fa2cf866c06d1850419a2f5b5ef9c3324b", "committedDate": "2020-06-17T07:30:31Z", "message": "5.1"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e516d1ad6bacbde9da1bc6caf2332d916e2e0457", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/e516d1ad6bacbde9da1bc6caf2332d916e2e0457", "committedDate": "2020-06-17T08:06:19Z", "message": "Remove latestDepTest from lettuce-5.0 since we have a newer lettuce-5.1."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09a2b49f96e5a2391fb2818448bce06010677c95", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/09a2b49f96e5a2391fb2818448bce06010677c95", "committedDate": "2020-06-17T08:10:18Z", "message": "Remove"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3faa4dea420b8144dcf0ad6564ba72e127ecc82c", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/3faa4dea420b8144dcf0ad6564ba72e127ecc82c", "committedDate": "2020-06-18T05:26:33Z", "message": "Remove package check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b5e8c78be855b28f03b228091d46bfb9c4ccd69", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/8b5e8c78be855b28f03b228091d46bfb9c4ccd69", "committedDate": "2020-06-18T06:46:31Z", "message": "Spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8595dd87b12eff137e730779645636d9dcfd6f9e", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/8595dd87b12eff137e730779645636d9dcfd6f9e", "committedDate": "2020-06-18T08:05:49Z", "message": "Merge branch 'master' into lettuce-51"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzMzk0NDE0", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535#pullrequestreview-433394414", "createdAt": "2020-06-18T15:22:36Z", "commit": {"oid": "8595dd87b12eff137e730779645636d9dcfd6f9e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3262, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}