{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM5OTEwOTgx", "number": 1908, "title": "HTTP client instrumentation cleanup: http-url-connection", "bodyText": "Split out from #1840", "createdAt": "2020-12-15T01:26:11Z", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1908", "merged": true, "mergeCommit": {"oid": "9e38f521f8606eef838bf2f24cb60c8ecdeded81"}, "closed": true, "closedAt": "2020-12-16T05:52:17Z", "author": {"login": "trask"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdmP_tJgH2gAyNTM5OTEwOTgxOjc0YjljYWNjNjhkZWM5Yjc1Njg0Nzc4YTIzZGI3MDdhNjhlZmQ1ZDI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdmobFygFqTU1MzM3NTM1NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "74b9cacc68dec9b75684778a23db707a68efd5d2", "author": {"user": {"login": "trask", "name": "Trask Stalnaker"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/74b9cacc68dec9b75684778a23db707a68efd5d2", "committedDate": "2020-12-15T01:24:31Z", "message": "HttpClientTracer cleanup: http-url-connection"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9bff43281b156650b3e06df48baf8c16c52fcb2", "author": {"user": {"login": "trask", "name": "Trask Stalnaker"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/f9bff43281b156650b3e06df48baf8c16c52fcb2", "committedDate": "2020-12-15T01:50:16Z", "message": "Checkstyle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyMTIxNTAx", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1908#pullrequestreview-552121501", "createdAt": "2020-12-15T05:42:36Z", "commit": {"oid": "f9bff43281b156650b3e06df48baf8c16c52fcb2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyMTUxNzg5", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1908#pullrequestreview-552151789", "createdAt": "2020-12-15T06:55:51Z", "commit": {"oid": "f9bff43281b156650b3e06df48baf8c16c52fcb2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwNjo1NTo1MVrOIF7rXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwNjo1NTo1MVrOIF7rXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA5MTU1MA==", "bodyText": "We don't have similar condition in other instrumentations, right? Why do we need it here?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1908#discussion_r543091550", "createdAt": "2020-12-15T06:55:51Z", "author": {"login": "iNikem"}, "path": "instrumentation/http-url-connection/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/httpurlconnection/HttpUrlConnectionInstrumentationModule.java", "diffHunk": "@@ -79,75 +81,65 @@ public HttpUrlConnectionInstrumentationModule() {\n   public static class HttpUrlConnectionAdvice {\n \n     @Advice.OnMethodEnter(suppress = Throwable.class)\n-    public static HttpUrlState methodEnter(\n+    public static void methodEnter(\n         @Advice.This HttpURLConnection connection,\n         @Advice.FieldValue(\"connected\") boolean connected,\n-        @Advice.Local(\"otelScope\") Scope scope) {\n-\n-      int callDepth = CallDepthThreadLocalMap.incrementCallDepth(HttpURLConnection.class);\n-      if (callDepth > 0) {\n-        return null;\n+        @Advice.Local(\"otelContext\") Context context,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") CallDepth callDepth) {\n+\n+      callDepth = CallDepthThreadLocalMap.getCallDepth(HttpURLConnection.class);\n+      if (callDepth.getAndIncrement() > 0) {\n+        // only want the rest of the instrumentation rules (which are complex enough) to apply to\n+        // top-level HttpURLConnection calls\n+        return;\n+      }\n+      Context parentContext = currentContext();\n+      if (!tracer().shouldStartSpan(parentContext)) {\n+        return;\n       }\n \n-      ContextStore<HttpURLConnection, HttpUrlState> contextStore =\n-          InstrumentationContext.get(HttpURLConnection.class, HttpUrlState.class);\n-      HttpUrlState state = contextStore.putIfAbsent(connection, HttpUrlState::new);\n-\n-      synchronized (state) {\n-        if (!state.initialized) {\n-          Context parentContext = currentContext();\n-          if (tracer().shouldStartSpan(parentContext)) {\n-            state.context = tracer().startSpan(parentContext, connection, connection);\n-            if (!connected) {\n-              scope = state.context.makeCurrent();\n-            }\n-          }\n-          state.initialized = true;\n-        }\n+      // putting into storage for a couple of reasons:\n+      // - to start an operation in connect() and end it in getInputStream()\n+      // - to avoid creating new operation on multiple subsequent calls to getInputStream()\n+      ContextStore<HttpURLConnection, Context> storage =\n+          InstrumentationContext.get(HttpURLConnection.class, Context.class);\n+      context = storage.get(connection);\n+\n+      if (context == null) {\n+        context = tracer().startSpan(parentContext, connection);\n+        storage.put(connection, context);\n       }\n-      return state;\n+\n+      scope = context.makeCurrent();\n     }\n \n     @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n     public static void methodExit(\n-        @Advice.Enter HttpUrlState state,\n         @Advice.This HttpURLConnection connection,\n         @Advice.FieldValue(\"responseCode\") int responseCode,\n         @Advice.Thrown Throwable throwable,\n         @Advice.Origin(\"#m\") String methodName,\n-        @Advice.Local(\"otelScope\") Scope scope) {\n-\n-      if (scope != null) {\n-        scope.close();\n+        @Advice.Local(\"otelContext\") Context context,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") CallDepth callDepth) {\n+      if (callDepth.decrementAndGet() > 0) {\n+        return;\n       }\n-      if (state == null) {\n+      if (scope == null) {\n         return;\n       }\n-      CallDepthThreadLocalMap.reset(HttpURLConnection.class);\n-\n-      synchronized (state) {\n-        if (state.context != null && !state.finished) {\n-          if (throwable != null) {\n-            tracer().endExceptionally(state.context, throwable);\n-            state.finished = true;\n-          } else if (\"getInputStream\".equals(methodName)) {\n-            // responseCode field is sometimes not populated.\n-            // We can't call getResponseCode() due to some unwanted side-effects\n-            // (e.g. breaks getOutputStream).\n-            if (responseCode > 0) {\n-              tracer().end(state.context, new HttpUrlResponse(connection, responseCode));\n-              state.finished = true;\n-            }\n-          }\n+      scope.close();\n+      if (Span.fromContext(context).isRecording()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9bff43281b156650b3e06df48baf8c16c52fcb2"}, "originalPosition": 126}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyNDQyMTgy", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1908#pullrequestreview-552442182", "createdAt": "2020-12-15T13:22:21Z", "commit": {"oid": "f9bff43281b156650b3e06df48baf8c16c52fcb2"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMzoyMjoyMVrOIGKmEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMzoyMjoyMVrOIGKmEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzMzNTk1NA==", "bodyText": "isRecording() is the same as previous !state.finished. No idea why it was used here though", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1908#discussion_r543335954", "createdAt": "2020-12-15T13:22:21Z", "author": {"login": "mateuszrzeszutek"}, "path": "instrumentation/http-url-connection/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/httpurlconnection/HttpUrlConnectionInstrumentationModule.java", "diffHunk": "@@ -79,75 +81,65 @@ public HttpUrlConnectionInstrumentationModule() {\n   public static class HttpUrlConnectionAdvice {\n \n     @Advice.OnMethodEnter(suppress = Throwable.class)\n-    public static HttpUrlState methodEnter(\n+    public static void methodEnter(\n         @Advice.This HttpURLConnection connection,\n         @Advice.FieldValue(\"connected\") boolean connected,\n-        @Advice.Local(\"otelScope\") Scope scope) {\n-\n-      int callDepth = CallDepthThreadLocalMap.incrementCallDepth(HttpURLConnection.class);\n-      if (callDepth > 0) {\n-        return null;\n+        @Advice.Local(\"otelContext\") Context context,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") CallDepth callDepth) {\n+\n+      callDepth = CallDepthThreadLocalMap.getCallDepth(HttpURLConnection.class);\n+      if (callDepth.getAndIncrement() > 0) {\n+        // only want the rest of the instrumentation rules (which are complex enough) to apply to\n+        // top-level HttpURLConnection calls\n+        return;\n+      }\n+      Context parentContext = currentContext();\n+      if (!tracer().shouldStartSpan(parentContext)) {\n+        return;\n       }\n \n-      ContextStore<HttpURLConnection, HttpUrlState> contextStore =\n-          InstrumentationContext.get(HttpURLConnection.class, HttpUrlState.class);\n-      HttpUrlState state = contextStore.putIfAbsent(connection, HttpUrlState::new);\n-\n-      synchronized (state) {\n-        if (!state.initialized) {\n-          Context parentContext = currentContext();\n-          if (tracer().shouldStartSpan(parentContext)) {\n-            state.context = tracer().startSpan(parentContext, connection, connection);\n-            if (!connected) {\n-              scope = state.context.makeCurrent();\n-            }\n-          }\n-          state.initialized = true;\n-        }\n+      // putting into storage for a couple of reasons:\n+      // - to start an operation in connect() and end it in getInputStream()\n+      // - to avoid creating new operation on multiple subsequent calls to getInputStream()\n+      ContextStore<HttpURLConnection, Context> storage =\n+          InstrumentationContext.get(HttpURLConnection.class, Context.class);\n+      context = storage.get(connection);\n+\n+      if (context == null) {\n+        context = tracer().startSpan(parentContext, connection);\n+        storage.put(connection, context);\n       }\n-      return state;\n+\n+      scope = context.makeCurrent();\n     }\n \n     @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n     public static void methodExit(\n-        @Advice.Enter HttpUrlState state,\n         @Advice.This HttpURLConnection connection,\n         @Advice.FieldValue(\"responseCode\") int responseCode,\n         @Advice.Thrown Throwable throwable,\n         @Advice.Origin(\"#m\") String methodName,\n-        @Advice.Local(\"otelScope\") Scope scope) {\n-\n-      if (scope != null) {\n-        scope.close();\n+        @Advice.Local(\"otelContext\") Context context,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") CallDepth callDepth) {\n+      if (callDepth.decrementAndGet() > 0) {\n+        return;\n       }\n-      if (state == null) {\n+      if (scope == null) {\n         return;\n       }\n-      CallDepthThreadLocalMap.reset(HttpURLConnection.class);\n-\n-      synchronized (state) {\n-        if (state.context != null && !state.finished) {\n-          if (throwable != null) {\n-            tracer().endExceptionally(state.context, throwable);\n-            state.finished = true;\n-          } else if (\"getInputStream\".equals(methodName)) {\n-            // responseCode field is sometimes not populated.\n-            // We can't call getResponseCode() due to some unwanted side-effects\n-            // (e.g. breaks getOutputStream).\n-            if (responseCode > 0) {\n-              tracer().end(state.context, new HttpUrlResponse(connection, responseCode));\n-              state.finished = true;\n-            }\n-          }\n+      scope.close();\n+      if (Span.fromContext(context).isRecording()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA5MTU1MA=="}, "originalCommit": {"oid": "f9bff43281b156650b3e06df48baf8c16c52fcb2"}, "originalPosition": 126}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc45d8d307365d84b2072c9a460e447e90b5eeda", "author": {"user": {"login": "trask", "name": "Trask Stalnaker"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/fc45d8d307365d84b2072c9a460e447e90b5eeda", "committedDate": "2020-12-15T23:11:39Z", "message": "Feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzMzc1MzU1", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1908#pullrequestreview-553375355", "createdAt": "2020-12-16T05:52:09Z", "commit": {"oid": "fc45d8d307365d84b2072c9a460e447e90b5eeda"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2000, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}