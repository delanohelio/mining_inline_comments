{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM3MTk0MTkx", "number": 548, "reviewThreads": {"totalCount": 33, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMjoyMTowMlrOEHygOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQyMjoxMTo1MlrOEI8ROQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NjAyOTM2OnYy", "diffSide": "RIGHT", "path": "instrumentation-core/spring/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMjoyMTowMlrOGnW-og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMjoyMTowMlrOGnW-og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkyNDEzMA==", "bodyText": "conventional ordering\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               private final static tracerName = \"fooTracer\"; \n          \n          \n            \n               private static final tracerName = \"fooTracer\";", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r443924130", "createdAt": "2020-06-23T02:21:02Z", "author": {"login": "trask"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -114,7 +114,7 @@ import io.opentelemetry.exporters.logging.*;\n \n @Configuration\n public class OtelConfig {\n-   private static tracerName = \"fooTracer\"; \n+   private final static tracerName = \"fooTracer\"; ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99afb1ad3338d338fb2d1007159e0021cdb69f98"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NjAzOTcwOnYy", "diffSide": "RIGHT", "path": "instrumentation-core/spring/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMjoyNzowN1rOGnXEsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMjoyNzowN1rOGnXEsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkyNTY4MQ==", "bodyText": "final on classes is not super common, so i'd leave off of this example code\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public final class HttpUtils {\n          \n          \n            \n            public class HttpUtils {", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r443925681", "createdAt": "2020-06-23T02:27:07Z", "author": {"login": "trask"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -237,7 +239,7 @@ import io.opentelemetry.trace.SpanContext;\n import io.opentelemetry.trace.Tracer;\n \n @Component\n-public class HttpUtils {\n+public final class HttpUtils {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99afb1ad3338d338fb2d1007159e0021cdb69f98"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NjEwODkwOnYy", "diffSide": "RIGHT", "path": "instrumentation-core/spring/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMzowOToxOVrOGnXuGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMzowOToxOVrOGnXuGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkzNjI4MA==", "bodyText": "I think this reads better:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Here we will create RestControllers for `FirstService` and `SecondService`.\n          \n          \n            \n            Here we will create REST controllers for `FirstService` and `SecondService`.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r443936280", "createdAt": "2020-06-23T03:09:19Z", "author": {"login": "trask"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -144,7 +144,7 @@ OpenTelemetrySdk.getTracerProvider().addSpanProcessor(jaegerProcessor);\n        \n ### Project Background\n \n-Here we will create rest controllers for `FirstService` and `SecondService`.\n+Here we will create RestControllers for `FirstService` and `SecondService`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99afb1ad3338d338fb2d1007159e0021cdb69f98"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NjEwOTM3OnYy", "diffSide": "RIGHT", "path": "instrumentation-core/spring/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMzowOTo0MlrOGnXucQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMzowOTo0MlrOGnXucQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkzNjM2OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In this section, we will implement the Spring HandlerInerceptor interface to wrap all requests to FirstService and Second Service controllers in a span. \n          \n          \n            \n            In this section, we will implement the Spring HandlerInerceptor interface to wrap all requests to FirstService and SecondService controllers in a span.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r443936369", "createdAt": "2020-06-23T03:09:42Z", "author": {"login": "trask"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -340,6 +341,323 @@ After running Jaeger locally, navigate to the url below. Make sure to refresh th\n \n Run FirstService and SecondService from command line or using an IDE. The end point of interest for FirstService is `http://localhost:8080/message` and  `http://localhost:8081/time` for SecondService. Entering `localhost:8080/message` in a browser should call FirstService and then SecondService, creating a trace. \n \n-***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.secondServiceUrl. ***\n+***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.SECOND_SERVICE_URL. ***\n \n Congrats, we just created a distributed service with OpenTelemetry!\n+\n+## Manual Instrumentation using Handlers and Interceptors\n+\n+In this section, we will implement the Spring HandlerInerceptor interface to wrap all requests to FirstService and Second Service controllers in a span. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99afb1ad3338d338fb2d1007159e0021cdb69f98"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NjExMDIyOnYy", "diffSide": "RIGHT", "path": "instrumentation-core/spring/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMzoxMDoyNFrOGnXvEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMzoxMDoyNFrOGnXvEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkzNjUzMQ==", "bodyText": "two alternate suggestions here:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ### Setup FirstService and SecondService\n          \n          \n            \n            ### Set up FirstService and SecondService\n          \n      \n    \n    \n  \n\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ### Setup FirstService and SecondService\n          \n          \n            \n            ### Setup for FirstService and SecondService", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r443936531", "createdAt": "2020-06-23T03:10:24Z", "author": {"login": "trask"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -340,6 +341,323 @@ After running Jaeger locally, navigate to the url below. Make sure to refresh th\n \n Run FirstService and SecondService from command line or using an IDE. The end point of interest for FirstService is `http://localhost:8080/message` and  `http://localhost:8081/time` for SecondService. Entering `localhost:8080/message` in a browser should call FirstService and then SecondService, creating a trace. \n \n-***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.secondServiceUrl. ***\n+***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.SECOND_SERVICE_URL. ***\n \n Congrats, we just created a distributed service with OpenTelemetry!\n+\n+## Manual Instrumentation using Handlers and Interceptors\n+\n+In this section, we will implement the Spring HandlerInerceptor interface to wrap all requests to FirstService and Second Service controllers in a span. \n+\n+We will also use the RestTemplate HTTP client to send requests from FirstService to SecondService. To propagate the trace in this request we will also implement the ClientHttpRequestInterceptor interface. This implementation is only required for projects that send outbound requests. In this example it is only required for FirstService. \n+\n+### Setup FirstService and SecondService", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99afb1ad3338d338fb2d1007159e0021cdb69f98"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NjExMjY0OnYy", "diffSide": "RIGHT", "path": "instrumentation-core/spring/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMzoxMTo1OVrOGnXwfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMzoxMTo1OVrOGnXwfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkzNjg5NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Using the earlier instructions [create two example projects](#create-two-spring-projects) and add the required [dependencies and configurations](#setup-for-manual-instrumentation). \n          \n          \n            \n            Using the earlier instructions [create two spring projects](#create-two-spring-projects) and add the required [dependencies and configurations](#setup-for-manual-instrumentation).", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r443936894", "createdAt": "2020-06-23T03:11:59Z", "author": {"login": "trask"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -340,6 +341,323 @@ After running Jaeger locally, navigate to the url below. Make sure to refresh th\n \n Run FirstService and SecondService from command line or using an IDE. The end point of interest for FirstService is `http://localhost:8080/message` and  `http://localhost:8081/time` for SecondService. Entering `localhost:8080/message` in a browser should call FirstService and then SecondService, creating a trace. \n \n-***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.secondServiceUrl. ***\n+***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.SECOND_SERVICE_URL. ***\n \n Congrats, we just created a distributed service with OpenTelemetry!\n+\n+## Manual Instrumentation using Handlers and Interceptors\n+\n+In this section, we will implement the Spring HandlerInerceptor interface to wrap all requests to FirstService and Second Service controllers in a span. \n+\n+We will also use the RestTemplate HTTP client to send requests from FirstService to SecondService. To propagate the trace in this request we will also implement the ClientHttpRequestInterceptor interface. This implementation is only required for projects that send outbound requests. In this example it is only required for FirstService. \n+\n+### Setup FirstService and SecondService\n+\n+Using the earlier instructions [create two example projects](#create-two-spring-projects) and add the required [dependencies and configurations](#setup-for-manual-instrumentation). ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99afb1ad3338d338fb2d1007159e0021cdb69f98"}, "originalPosition": 148}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NjExNzY0OnYy", "diffSide": "RIGHT", "path": "instrumentation-core/spring/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMzoxNToxOVrOGnXzcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMzoxNToxOVrOGnXzcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkzNzY1MQ==", "bodyText": "these imports aren't used\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import io.opentelemetry.context.Scope;\n          \n          \n            \n            import io.opentelemetry.trace.Span;\n          \n          \n            \n            import io.opentelemetry.trace.Tracer;", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r443937651", "createdAt": "2020-06-23T03:15:19Z", "author": {"login": "trask"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -340,6 +341,323 @@ After running Jaeger locally, navigate to the url below. Make sure to refresh th\n \n Run FirstService and SecondService from command line or using an IDE. The end point of interest for FirstService is `http://localhost:8080/message` and  `http://localhost:8081/time` for SecondService. Entering `localhost:8080/message` in a browser should call FirstService and then SecondService, creating a trace. \n \n-***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.secondServiceUrl. ***\n+***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.SECOND_SERVICE_URL. ***\n \n Congrats, we just created a distributed service with OpenTelemetry!\n+\n+## Manual Instrumentation using Handlers and Interceptors\n+\n+In this section, we will implement the Spring HandlerInerceptor interface to wrap all requests to FirstService and Second Service controllers in a span. \n+\n+We will also use the RestTemplate HTTP client to send requests from FirstService to SecondService. To propagate the trace in this request we will also implement the ClientHttpRequestInterceptor interface. This implementation is only required for projects that send outbound requests. In this example it is only required for FirstService. \n+\n+### Setup FirstService and SecondService\n+\n+Using the earlier instructions [create two example projects](#create-two-spring-projects) and add the required [dependencies and configurations](#setup-for-manual-instrumentation). \n+\n+### Instrumentation of Client Service: SecondService\n+\n+Ensure the main method in SecondServiceApplication is defined. This will be the entry point to the SecondService project. This file should be created by the Spring Boot project initializer.\n+\n+```java\n+import java.io.IOException;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+\n+@SpringBootApplication\n+public class SecondServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(SecondServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+Add the RestController below to your SecondService project. This controller will return a string when SecondServiceController.secondTracedMethod is called:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99afb1ad3338d338fb2d1007159e0021cdb69f98"}, "originalPosition": 180}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NjEyMDQ1OnYy", "diffSide": "RIGHT", "path": "instrumentation-core/spring/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMzoxNzoxM1rOGnX1GQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMzoxNzoxM1rOGnX1GQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkzODA3Mw==", "bodyText": "no need to add span context to the response header\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The preHandle method starts a span for each request. The postHandle method closes the span and adds the span context to the response header. This implementation is shown below:    \n          \n          \n            \n            The preHandle method starts a span for each request. This implementation is shown below:", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r443938073", "createdAt": "2020-06-23T03:17:13Z", "author": {"login": "trask"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -340,6 +341,323 @@ After running Jaeger locally, navigate to the url below. Make sure to refresh th\n \n Run FirstService and SecondService from command line or using an IDE. The end point of interest for FirstService is `http://localhost:8080/message` and  `http://localhost:8081/time` for SecondService. Entering `localhost:8080/message` in a browser should call FirstService and then SecondService, creating a trace. \n \n-***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.secondServiceUrl. ***\n+***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.SECOND_SERVICE_URL. ***\n \n Congrats, we just created a distributed service with OpenTelemetry!\n+\n+## Manual Instrumentation using Handlers and Interceptors\n+\n+In this section, we will implement the Spring HandlerInerceptor interface to wrap all requests to FirstService and Second Service controllers in a span. \n+\n+We will also use the RestTemplate HTTP client to send requests from FirstService to SecondService. To propagate the trace in this request we will also implement the ClientHttpRequestInterceptor interface. This implementation is only required for projects that send outbound requests. In this example it is only required for FirstService. \n+\n+### Setup FirstService and SecondService\n+\n+Using the earlier instructions [create two example projects](#create-two-spring-projects) and add the required [dependencies and configurations](#setup-for-manual-instrumentation). \n+\n+### Instrumentation of Client Service: SecondService\n+\n+Ensure the main method in SecondServiceApplication is defined. This will be the entry point to the SecondService project. This file should be created by the Spring Boot project initializer.\n+\n+```java\n+import java.io.IOException;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+\n+@SpringBootApplication\n+public class SecondServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(SecondServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+Add the RestController below to your SecondService project. This controller will return a string when SecondServiceController.secondTracedMethod is called:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+\n+@RestController\n+@RequestMapping(value = \"/time\")\n+public class SecondServiceController {\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @GetMapping\n+   public String secondTracedMethod() {\n+      return \"It's time to get a watch\";\n+   }\n+}\n+```\n+\n+#### Create Controller Interceptor\n+\n+Add the class below to wrap all requests to the SecondServiceController in a span. This class will call the preHandle method before the RestController is entered and the postHandle method after a response is created. \n+\n+The preHandle method starts a span for each request. The postHandle method closes the span and adds the span context to the response header. This implementation is shown below:    ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99afb1ad3338d338fb2d1007159e0021cdb69f98"}, "originalPosition": 198}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NjEyMTAyOnYy", "diffSide": "RIGHT", "path": "instrumentation-core/spring/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMzoxNzozOFrOGnX1gA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMzoxNzozOFrOGnX1gA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkzODE3Ng==", "bodyText": "no need to add span context to the response header\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               private static final HttpTextFormat.Setter<HttpServletResponse> setter =\n          \n          \n            \n                     new HttpTextFormat.Setter<HttpServletResponse>() {\n          \n          \n            \n                        @Override\n          \n          \n            \n                        public void set(HttpServletResponse response, String key, String value) {\n          \n          \n            \n                           response.addHeader(key, value);\n          \n          \n            \n                        }\n          \n          \n            \n                     };", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r443938176", "createdAt": "2020-06-23T03:17:38Z", "author": {"login": "trask"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -340,6 +341,323 @@ After running Jaeger locally, navigate to the url below. Make sure to refresh th\n \n Run FirstService and SecondService from command line or using an IDE. The end point of interest for FirstService is `http://localhost:8080/message` and  `http://localhost:8081/time` for SecondService. Entering `localhost:8080/message` in a browser should call FirstService and then SecondService, creating a trace. \n \n-***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.secondServiceUrl. ***\n+***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.SECOND_SERVICE_URL. ***\n \n Congrats, we just created a distributed service with OpenTelemetry!\n+\n+## Manual Instrumentation using Handlers and Interceptors\n+\n+In this section, we will implement the Spring HandlerInerceptor interface to wrap all requests to FirstService and Second Service controllers in a span. \n+\n+We will also use the RestTemplate HTTP client to send requests from FirstService to SecondService. To propagate the trace in this request we will also implement the ClientHttpRequestInterceptor interface. This implementation is only required for projects that send outbound requests. In this example it is only required for FirstService. \n+\n+### Setup FirstService and SecondService\n+\n+Using the earlier instructions [create two example projects](#create-two-spring-projects) and add the required [dependencies and configurations](#setup-for-manual-instrumentation). \n+\n+### Instrumentation of Client Service: SecondService\n+\n+Ensure the main method in SecondServiceApplication is defined. This will be the entry point to the SecondService project. This file should be created by the Spring Boot project initializer.\n+\n+```java\n+import java.io.IOException;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+\n+@SpringBootApplication\n+public class SecondServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(SecondServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+Add the RestController below to your SecondService project. This controller will return a string when SecondServiceController.secondTracedMethod is called:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+\n+@RestController\n+@RequestMapping(value = \"/time\")\n+public class SecondServiceController {\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @GetMapping\n+   public String secondTracedMethod() {\n+      return \"It's time to get a watch\";\n+   }\n+}\n+```\n+\n+#### Create Controller Interceptor\n+\n+Add the class below to wrap all requests to the SecondServiceController in a span. This class will call the preHandle method before the RestController is entered and the postHandle method after a response is created. \n+\n+The preHandle method starts a span for each request. The postHandle method closes the span and adds the span context to the response header. This implementation is shown below:    \n+\n+```java\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.servlet.HandlerInterceptor;\n+import org.springframework.web.servlet.ModelAndView;\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n+\n+@Component\n+public class ControllerTraceInterceptor implements HandlerInterceptor {\n+\n+   private static final HttpTextFormat.Getter<HttpServletRequest> getter =\n+         new HttpTextFormat.Getter<HttpServletRequest>() {\n+            public String get(HttpServletRequest req, String key) {\n+               return req.getHeader(key);\n+            }\n+         };\n+\n+   private static final HttpTextFormat.Setter<HttpServletResponse> setter =\n+         new HttpTextFormat.Setter<HttpServletResponse>() {\n+            @Override\n+            public void set(HttpServletResponse response, String key, String value) {\n+               response.addHeader(key, value);\n+            }\n+         };\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99afb1ad3338d338fb2d1007159e0021cdb69f98"}, "originalPosition": 233}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NjEyMTg0OnYy", "diffSide": "RIGHT", "path": "instrumentation-core/spring/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMzoxODoxMFrOGnX1-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMzoxODoxMFrOGnX1-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkzODI5OQ==", "bodyText": "no need to add span context to the response header\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  OpenTelemetry.getPropagators().getHttpTextFormat().inject(Context.current(), response, setter);", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r443938299", "createdAt": "2020-06-23T03:18:10Z", "author": {"login": "trask"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -340,6 +341,323 @@ After running Jaeger locally, navigate to the url below. Make sure to refresh th\n \n Run FirstService and SecondService from command line or using an IDE. The end point of interest for FirstService is `http://localhost:8080/message` and  `http://localhost:8081/time` for SecondService. Entering `localhost:8080/message` in a browser should call FirstService and then SecondService, creating a trace. \n \n-***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.secondServiceUrl. ***\n+***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.SECOND_SERVICE_URL. ***\n \n Congrats, we just created a distributed service with OpenTelemetry!\n+\n+## Manual Instrumentation using Handlers and Interceptors\n+\n+In this section, we will implement the Spring HandlerInerceptor interface to wrap all requests to FirstService and Second Service controllers in a span. \n+\n+We will also use the RestTemplate HTTP client to send requests from FirstService to SecondService. To propagate the trace in this request we will also implement the ClientHttpRequestInterceptor interface. This implementation is only required for projects that send outbound requests. In this example it is only required for FirstService. \n+\n+### Setup FirstService and SecondService\n+\n+Using the earlier instructions [create two example projects](#create-two-spring-projects) and add the required [dependencies and configurations](#setup-for-manual-instrumentation). \n+\n+### Instrumentation of Client Service: SecondService\n+\n+Ensure the main method in SecondServiceApplication is defined. This will be the entry point to the SecondService project. This file should be created by the Spring Boot project initializer.\n+\n+```java\n+import java.io.IOException;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+\n+@SpringBootApplication\n+public class SecondServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(SecondServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+Add the RestController below to your SecondService project. This controller will return a string when SecondServiceController.secondTracedMethod is called:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+\n+@RestController\n+@RequestMapping(value = \"/time\")\n+public class SecondServiceController {\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @GetMapping\n+   public String secondTracedMethod() {\n+      return \"It's time to get a watch\";\n+   }\n+}\n+```\n+\n+#### Create Controller Interceptor\n+\n+Add the class below to wrap all requests to the SecondServiceController in a span. This class will call the preHandle method before the RestController is entered and the postHandle method after a response is created. \n+\n+The preHandle method starts a span for each request. The postHandle method closes the span and adds the span context to the response header. This implementation is shown below:    \n+\n+```java\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.servlet.HandlerInterceptor;\n+import org.springframework.web.servlet.ModelAndView;\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n+\n+@Component\n+public class ControllerTraceInterceptor implements HandlerInterceptor {\n+\n+   private static final HttpTextFormat.Getter<HttpServletRequest> getter =\n+         new HttpTextFormat.Getter<HttpServletRequest>() {\n+            public String get(HttpServletRequest req, String key) {\n+               return req.getHeader(key);\n+            }\n+         };\n+\n+   private static final HttpTextFormat.Setter<HttpServletResponse> setter =\n+         new HttpTextFormat.Setter<HttpServletResponse>() {\n+            @Override\n+            public void set(HttpServletResponse response, String key, String value) {\n+               response.addHeader(key, value);\n+            }\n+         };\n+\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @Override\n+   public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n+         throws Exception {\n+     \n+      Span span = createSpanWithParent(request, context);\n+      span.setAttribute(\"handler\", \"pre\");\n+      tracer.withSpan(span);\n+\n+      return true;\n+   }\n+\n+   @Override\n+   public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n+         ModelAndView modelAndView) throws Exception {\n+\n+      Span currentSpan = tracer.getCurrentSpan();\n+      currentSpan.setAttribute(\"handler\", \"post\");\n+      OpenTelemetry.getPropagators().getHttpTextFormat().inject(Context.current(), response, setter);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99afb1ad3338d338fb2d1007159e0021cdb69f98"}, "originalPosition": 254}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NjEyMzc0OnYy", "diffSide": "RIGHT", "path": "instrumentation-core/spring/README.md", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMzoxOToyNFrOGnX3Fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxODowMDo0MVrOGodLDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkzODU4Mg==", "bodyText": "it looks like this Scope is never closed?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r443938582", "createdAt": "2020-06-23T03:19:24Z", "author": {"login": "trask"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -340,6 +341,323 @@ After running Jaeger locally, navigate to the url below. Make sure to refresh th\n \n Run FirstService and SecondService from command line or using an IDE. The end point of interest for FirstService is `http://localhost:8080/message` and  `http://localhost:8081/time` for SecondService. Entering `localhost:8080/message` in a browser should call FirstService and then SecondService, creating a trace. \n \n-***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.secondServiceUrl. ***\n+***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.SECOND_SERVICE_URL. ***\n \n Congrats, we just created a distributed service with OpenTelemetry!\n+\n+## Manual Instrumentation using Handlers and Interceptors\n+\n+In this section, we will implement the Spring HandlerInerceptor interface to wrap all requests to FirstService and Second Service controllers in a span. \n+\n+We will also use the RestTemplate HTTP client to send requests from FirstService to SecondService. To propagate the trace in this request we will also implement the ClientHttpRequestInterceptor interface. This implementation is only required for projects that send outbound requests. In this example it is only required for FirstService. \n+\n+### Setup FirstService and SecondService\n+\n+Using the earlier instructions [create two example projects](#create-two-spring-projects) and add the required [dependencies and configurations](#setup-for-manual-instrumentation). \n+\n+### Instrumentation of Client Service: SecondService\n+\n+Ensure the main method in SecondServiceApplication is defined. This will be the entry point to the SecondService project. This file should be created by the Spring Boot project initializer.\n+\n+```java\n+import java.io.IOException;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+\n+@SpringBootApplication\n+public class SecondServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(SecondServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+Add the RestController below to your SecondService project. This controller will return a string when SecondServiceController.secondTracedMethod is called:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+\n+@RestController\n+@RequestMapping(value = \"/time\")\n+public class SecondServiceController {\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @GetMapping\n+   public String secondTracedMethod() {\n+      return \"It's time to get a watch\";\n+   }\n+}\n+```\n+\n+#### Create Controller Interceptor\n+\n+Add the class below to wrap all requests to the SecondServiceController in a span. This class will call the preHandle method before the RestController is entered and the postHandle method after a response is created. \n+\n+The preHandle method starts a span for each request. The postHandle method closes the span and adds the span context to the response header. This implementation is shown below:    \n+\n+```java\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.servlet.HandlerInterceptor;\n+import org.springframework.web.servlet.ModelAndView;\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n+\n+@Component\n+public class ControllerTraceInterceptor implements HandlerInterceptor {\n+\n+   private static final HttpTextFormat.Getter<HttpServletRequest> getter =\n+         new HttpTextFormat.Getter<HttpServletRequest>() {\n+            public String get(HttpServletRequest req, String key) {\n+               return req.getHeader(key);\n+            }\n+         };\n+\n+   private static final HttpTextFormat.Setter<HttpServletResponse> setter =\n+         new HttpTextFormat.Setter<HttpServletResponse>() {\n+            @Override\n+            public void set(HttpServletResponse response, String key, String value) {\n+               response.addHeader(key, value);\n+            }\n+         };\n+\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @Override\n+   public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n+         throws Exception {\n+     \n+      Span span = createSpanWithParent(request, context);\n+      span.setAttribute(\"handler\", \"pre\");\n+      tracer.withSpan(span);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99afb1ad3338d338fb2d1007159e0021cdb69f98"}, "originalPosition": 243}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDYzMjE2Mg==", "bodyText": "this is important to address because the scope is bound to ThreadLocal and so will leak, and if/when that thread is reused it will have wrong/old span bound to it", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r444632162", "createdAt": "2020-06-24T04:04:01Z", "author": {"login": "trask"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -340,6 +341,323 @@ After running Jaeger locally, navigate to the url below. Make sure to refresh th\n \n Run FirstService and SecondService from command line or using an IDE. The end point of interest for FirstService is `http://localhost:8080/message` and  `http://localhost:8081/time` for SecondService. Entering `localhost:8080/message` in a browser should call FirstService and then SecondService, creating a trace. \n \n-***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.secondServiceUrl. ***\n+***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.SECOND_SERVICE_URL. ***\n \n Congrats, we just created a distributed service with OpenTelemetry!\n+\n+## Manual Instrumentation using Handlers and Interceptors\n+\n+In this section, we will implement the Spring HandlerInerceptor interface to wrap all requests to FirstService and Second Service controllers in a span. \n+\n+We will also use the RestTemplate HTTP client to send requests from FirstService to SecondService. To propagate the trace in this request we will also implement the ClientHttpRequestInterceptor interface. This implementation is only required for projects that send outbound requests. In this example it is only required for FirstService. \n+\n+### Setup FirstService and SecondService\n+\n+Using the earlier instructions [create two example projects](#create-two-spring-projects) and add the required [dependencies and configurations](#setup-for-manual-instrumentation). \n+\n+### Instrumentation of Client Service: SecondService\n+\n+Ensure the main method in SecondServiceApplication is defined. This will be the entry point to the SecondService project. This file should be created by the Spring Boot project initializer.\n+\n+```java\n+import java.io.IOException;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+\n+@SpringBootApplication\n+public class SecondServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(SecondServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+Add the RestController below to your SecondService project. This controller will return a string when SecondServiceController.secondTracedMethod is called:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+\n+@RestController\n+@RequestMapping(value = \"/time\")\n+public class SecondServiceController {\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @GetMapping\n+   public String secondTracedMethod() {\n+      return \"It's time to get a watch\";\n+   }\n+}\n+```\n+\n+#### Create Controller Interceptor\n+\n+Add the class below to wrap all requests to the SecondServiceController in a span. This class will call the preHandle method before the RestController is entered and the postHandle method after a response is created. \n+\n+The preHandle method starts a span for each request. The postHandle method closes the span and adds the span context to the response header. This implementation is shown below:    \n+\n+```java\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.servlet.HandlerInterceptor;\n+import org.springframework.web.servlet.ModelAndView;\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n+\n+@Component\n+public class ControllerTraceInterceptor implements HandlerInterceptor {\n+\n+   private static final HttpTextFormat.Getter<HttpServletRequest> getter =\n+         new HttpTextFormat.Getter<HttpServletRequest>() {\n+            public String get(HttpServletRequest req, String key) {\n+               return req.getHeader(key);\n+            }\n+         };\n+\n+   private static final HttpTextFormat.Setter<HttpServletResponse> setter =\n+         new HttpTextFormat.Setter<HttpServletResponse>() {\n+            @Override\n+            public void set(HttpServletResponse response, String key, String value) {\n+               response.addHeader(key, value);\n+            }\n+         };\n+\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @Override\n+   public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n+         throws Exception {\n+     \n+      Span span = createSpanWithParent(request, context);\n+      span.setAttribute(\"handler\", \"pre\");\n+      tracer.withSpan(span);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkzODU4Mg=="}, "originalCommit": {"oid": "99afb1ad3338d338fb2d1007159e0021cdb69f98"}, "originalPosition": 243}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk3Nzc1Ng==", "bodyText": "Interesting. I noticed that the HandlerInterceptor.postHandle is not called when an unhandled exception is thrown. So I moved this code to afterCompletion but that doesn't address this threading issue. Would you recommend implementing a Serverlet Filter instead of a HandlerInterceptor to wrap controllers in a span?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r444977756", "createdAt": "2020-06-24T15:23:58Z", "author": {"login": "mabdinur"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -340,6 +341,323 @@ After running Jaeger locally, navigate to the url below. Make sure to refresh th\n \n Run FirstService and SecondService from command line or using an IDE. The end point of interest for FirstService is `http://localhost:8080/message` and  `http://localhost:8081/time` for SecondService. Entering `localhost:8080/message` in a browser should call FirstService and then SecondService, creating a trace. \n \n-***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.secondServiceUrl. ***\n+***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.SECOND_SERVICE_URL. ***\n \n Congrats, we just created a distributed service with OpenTelemetry!\n+\n+## Manual Instrumentation using Handlers and Interceptors\n+\n+In this section, we will implement the Spring HandlerInerceptor interface to wrap all requests to FirstService and Second Service controllers in a span. \n+\n+We will also use the RestTemplate HTTP client to send requests from FirstService to SecondService. To propagate the trace in this request we will also implement the ClientHttpRequestInterceptor interface. This implementation is only required for projects that send outbound requests. In this example it is only required for FirstService. \n+\n+### Setup FirstService and SecondService\n+\n+Using the earlier instructions [create two example projects](#create-two-spring-projects) and add the required [dependencies and configurations](#setup-for-manual-instrumentation). \n+\n+### Instrumentation of Client Service: SecondService\n+\n+Ensure the main method in SecondServiceApplication is defined. This will be the entry point to the SecondService project. This file should be created by the Spring Boot project initializer.\n+\n+```java\n+import java.io.IOException;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+\n+@SpringBootApplication\n+public class SecondServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(SecondServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+Add the RestController below to your SecondService project. This controller will return a string when SecondServiceController.secondTracedMethod is called:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+\n+@RestController\n+@RequestMapping(value = \"/time\")\n+public class SecondServiceController {\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @GetMapping\n+   public String secondTracedMethod() {\n+      return \"It's time to get a watch\";\n+   }\n+}\n+```\n+\n+#### Create Controller Interceptor\n+\n+Add the class below to wrap all requests to the SecondServiceController in a span. This class will call the preHandle method before the RestController is entered and the postHandle method after a response is created. \n+\n+The preHandle method starts a span for each request. The postHandle method closes the span and adds the span context to the response header. This implementation is shown below:    \n+\n+```java\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.servlet.HandlerInterceptor;\n+import org.springframework.web.servlet.ModelAndView;\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n+\n+@Component\n+public class ControllerTraceInterceptor implements HandlerInterceptor {\n+\n+   private static final HttpTextFormat.Getter<HttpServletRequest> getter =\n+         new HttpTextFormat.Getter<HttpServletRequest>() {\n+            public String get(HttpServletRequest req, String key) {\n+               return req.getHeader(key);\n+            }\n+         };\n+\n+   private static final HttpTextFormat.Setter<HttpServletResponse> setter =\n+         new HttpTextFormat.Setter<HttpServletResponse>() {\n+            @Override\n+            public void set(HttpServletResponse response, String key, String value) {\n+               response.addHeader(key, value);\n+            }\n+         };\n+\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @Override\n+   public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n+         throws Exception {\n+     \n+      Span span = createSpanWithParent(request, context);\n+      span.setAttribute(\"handler\", \"pre\");\n+      tracer.withSpan(span);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkzODU4Mg=="}, "originalCommit": {"oid": "99afb1ad3338d338fb2d1007159e0021cdb69f98"}, "originalPosition": 243}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA3NDE4OQ==", "bodyText": "servlet filter sounds good \ud83d\udc4d", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r445074189", "createdAt": "2020-06-24T18:00:41Z", "author": {"login": "trask"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -340,6 +341,323 @@ After running Jaeger locally, navigate to the url below. Make sure to refresh th\n \n Run FirstService and SecondService from command line or using an IDE. The end point of interest for FirstService is `http://localhost:8080/message` and  `http://localhost:8081/time` for SecondService. Entering `localhost:8080/message` in a browser should call FirstService and then SecondService, creating a trace. \n \n-***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.secondServiceUrl. ***\n+***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.SECOND_SERVICE_URL. ***\n \n Congrats, we just created a distributed service with OpenTelemetry!\n+\n+## Manual Instrumentation using Handlers and Interceptors\n+\n+In this section, we will implement the Spring HandlerInerceptor interface to wrap all requests to FirstService and Second Service controllers in a span. \n+\n+We will also use the RestTemplate HTTP client to send requests from FirstService to SecondService. To propagate the trace in this request we will also implement the ClientHttpRequestInterceptor interface. This implementation is only required for projects that send outbound requests. In this example it is only required for FirstService. \n+\n+### Setup FirstService and SecondService\n+\n+Using the earlier instructions [create two example projects](#create-two-spring-projects) and add the required [dependencies and configurations](#setup-for-manual-instrumentation). \n+\n+### Instrumentation of Client Service: SecondService\n+\n+Ensure the main method in SecondServiceApplication is defined. This will be the entry point to the SecondService project. This file should be created by the Spring Boot project initializer.\n+\n+```java\n+import java.io.IOException;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+\n+@SpringBootApplication\n+public class SecondServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(SecondServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+Add the RestController below to your SecondService project. This controller will return a string when SecondServiceController.secondTracedMethod is called:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+\n+@RestController\n+@RequestMapping(value = \"/time\")\n+public class SecondServiceController {\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @GetMapping\n+   public String secondTracedMethod() {\n+      return \"It's time to get a watch\";\n+   }\n+}\n+```\n+\n+#### Create Controller Interceptor\n+\n+Add the class below to wrap all requests to the SecondServiceController in a span. This class will call the preHandle method before the RestController is entered and the postHandle method after a response is created. \n+\n+The preHandle method starts a span for each request. The postHandle method closes the span and adds the span context to the response header. This implementation is shown below:    \n+\n+```java\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.servlet.HandlerInterceptor;\n+import org.springframework.web.servlet.ModelAndView;\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n+\n+@Component\n+public class ControllerTraceInterceptor implements HandlerInterceptor {\n+\n+   private static final HttpTextFormat.Getter<HttpServletRequest> getter =\n+         new HttpTextFormat.Getter<HttpServletRequest>() {\n+            public String get(HttpServletRequest req, String key) {\n+               return req.getHeader(key);\n+            }\n+         };\n+\n+   private static final HttpTextFormat.Setter<HttpServletResponse> setter =\n+         new HttpTextFormat.Setter<HttpServletResponse>() {\n+            @Override\n+            public void set(HttpServletResponse response, String key, String value) {\n+               response.addHeader(key, value);\n+            }\n+         };\n+\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @Override\n+   public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n+         throws Exception {\n+     \n+      Span span = createSpanWithParent(request, context);\n+      span.setAttribute(\"handler\", \"pre\");\n+      tracer.withSpan(span);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkzODU4Mg=="}, "originalCommit": {"oid": "99afb1ad3338d338fb2d1007159e0021cdb69f98"}, "originalPosition": 243}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NjEzNzU0OnYy", "diffSide": "RIGHT", "path": "instrumentation-core/spring/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMzoyNzo1NlrOGnX_Dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwNDowNzo1MVrOGoCP0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk0MDYyMg==", "bodyText": "would it be better to end the span in afterCompletion?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r443940622", "createdAt": "2020-06-23T03:27:56Z", "author": {"login": "trask"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -340,6 +341,324 @@ After running Jaeger locally, navigate to the url below. Make sure to refresh th\n \n Run FirstService and SecondService from command line or using an IDE. The end point of interest for FirstService is `http://localhost:8080/message` and  `http://localhost:8081/time` for SecondService. Entering `localhost:8080/message` in a browser should call FirstService and then SecondService, creating a trace. \n \n-***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.secondServiceUrl. ***\n+***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.SECOND_SERVICE_URL. ***\n \n Congrats, we just created a distributed service with OpenTelemetry!\n+\n+## Manual Instrumentation using Handlers and Interceptors\n+\n+In this section, we will implement the Spring HandlerInerceptor interface to wrap all requests to FirstService and Second Service controllers in a span. \n+\n+We will also use the RestTemplate HTTP client to send requests from FirstService to SecondService. To propagate the trace in this request we will also implement the ClientHttpRequestInterceptor interface. This implementation is only required for projects that send outbound requests. In this example it is only required for FirstService. \n+\n+### Setup FirstService and SecondService\n+\n+Using the earlier instructions [create two example projects](#create-two-spring-projects) and add the required [dependencies and configurations](#setup-for-manual-instrumentation). \n+\n+### Instrumentation of Client Service: SecondService\n+\n+Ensure the main method in SecondServiceApplication is defined. This will be the entry point to the SecondService project. This file should be created by the Spring Boot project initializer.\n+\n+```java\n+import java.io.IOException;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+\n+@SpringBootApplication\n+public class SecondServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(SecondServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+Add the RestController below to your SecondService project. This controller will return a string when SecondServiceController.secondTracedMethod is called:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+\n+@RestController\n+@RequestMapping(value = \"/time\")\n+public class SecondServiceController {\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @GetMapping\n+   public String secondTracedMethod() {\n+      return \"It's time to get a watch\";\n+   }\n+}\n+```\n+\n+#### Create Controller Interceptor\n+\n+Add the class below to wrap all requests to the SecondServiceController in a span. This class will call the preHandle method before the RestController is entered and the postHandle method after a response is created. \n+\n+The preHandle method starts a span for each request. The postHandle method closes the span and adds the span context to the response header. This implementation is shown below:    \n+\n+```java\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.servlet.HandlerInterceptor;\n+import org.springframework.web.servlet.ModelAndView;\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n+\n+@Component\n+public class ControllerTraceInterceptor implements HandlerInterceptor {\n+\n+   private static final HttpTextFormat.Getter<HttpServletRequest> getter =\n+         new HttpTextFormat.Getter<HttpServletRequest>() {\n+            public String get(HttpServletRequest req, String key) {\n+               return req.getHeader(key);\n+            }\n+         };\n+\n+   private static final HttpTextFormat.Setter<HttpServletResponse> setter =\n+         new HttpTextFormat.Setter<HttpServletResponse>() {\n+            @Override\n+            public void set(HttpServletResponse response, String key, String value) {\n+               response.addHeader(key, value);\n+            }\n+         };\n+\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @Override\n+   public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n+         throws Exception {\n+      Context context = OpenTelemetry.getPropagators().getHttpTextFormat()\n+          .extract(Context.current(), request, getter);\n+      Span span = createSpanWithParent(request, context);\n+      span.setAttribute(\"handler\", \"pre\");\n+      tracer.withSpan(span);\n+\n+      return true;\n+   }\n+\n+   @Override\n+   public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n+         ModelAndView modelAndView) throws Exception {\n+\n+      Span currentSpan = tracer.getCurrentSpan();\n+      currentSpan.setAttribute(\"handler\", \"post\");\n+      OpenTelemetry.getPropagators().getHttpTextFormat().inject(Context.current(), response, setter);\n+      currentSpan.end();\n+   }\n+\n+   @Override\n+   public void afterCompletion(HttpServletRequest request, HttpServletResponse response,\n+         Object handler, Exception exception) throws Exception {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b27f2c9a2ce013c6b80118d7e4ca962e720bc27"}, "originalPosition": 261}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDYzMzA0MQ==", "bodyText": "bumping this, it seems github is hiding a couple of conversations even though they aren't marked resolved", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r444633041", "createdAt": "2020-06-24T04:07:51Z", "author": {"login": "trask"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -340,6 +341,324 @@ After running Jaeger locally, navigate to the url below. Make sure to refresh th\n \n Run FirstService and SecondService from command line or using an IDE. The end point of interest for FirstService is `http://localhost:8080/message` and  `http://localhost:8081/time` for SecondService. Entering `localhost:8080/message` in a browser should call FirstService and then SecondService, creating a trace. \n \n-***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.secondServiceUrl. ***\n+***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.SECOND_SERVICE_URL. ***\n \n Congrats, we just created a distributed service with OpenTelemetry!\n+\n+## Manual Instrumentation using Handlers and Interceptors\n+\n+In this section, we will implement the Spring HandlerInerceptor interface to wrap all requests to FirstService and Second Service controllers in a span. \n+\n+We will also use the RestTemplate HTTP client to send requests from FirstService to SecondService. To propagate the trace in this request we will also implement the ClientHttpRequestInterceptor interface. This implementation is only required for projects that send outbound requests. In this example it is only required for FirstService. \n+\n+### Setup FirstService and SecondService\n+\n+Using the earlier instructions [create two example projects](#create-two-spring-projects) and add the required [dependencies and configurations](#setup-for-manual-instrumentation). \n+\n+### Instrumentation of Client Service: SecondService\n+\n+Ensure the main method in SecondServiceApplication is defined. This will be the entry point to the SecondService project. This file should be created by the Spring Boot project initializer.\n+\n+```java\n+import java.io.IOException;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+\n+@SpringBootApplication\n+public class SecondServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(SecondServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+Add the RestController below to your SecondService project. This controller will return a string when SecondServiceController.secondTracedMethod is called:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+\n+@RestController\n+@RequestMapping(value = \"/time\")\n+public class SecondServiceController {\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @GetMapping\n+   public String secondTracedMethod() {\n+      return \"It's time to get a watch\";\n+   }\n+}\n+```\n+\n+#### Create Controller Interceptor\n+\n+Add the class below to wrap all requests to the SecondServiceController in a span. This class will call the preHandle method before the RestController is entered and the postHandle method after a response is created. \n+\n+The preHandle method starts a span for each request. The postHandle method closes the span and adds the span context to the response header. This implementation is shown below:    \n+\n+```java\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.servlet.HandlerInterceptor;\n+import org.springframework.web.servlet.ModelAndView;\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n+\n+@Component\n+public class ControllerTraceInterceptor implements HandlerInterceptor {\n+\n+   private static final HttpTextFormat.Getter<HttpServletRequest> getter =\n+         new HttpTextFormat.Getter<HttpServletRequest>() {\n+            public String get(HttpServletRequest req, String key) {\n+               return req.getHeader(key);\n+            }\n+         };\n+\n+   private static final HttpTextFormat.Setter<HttpServletResponse> setter =\n+         new HttpTextFormat.Setter<HttpServletResponse>() {\n+            @Override\n+            public void set(HttpServletResponse response, String key, String value) {\n+               response.addHeader(key, value);\n+            }\n+         };\n+\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @Override\n+   public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n+         throws Exception {\n+      Context context = OpenTelemetry.getPropagators().getHttpTextFormat()\n+          .extract(Context.current(), request, getter);\n+      Span span = createSpanWithParent(request, context);\n+      span.setAttribute(\"handler\", \"pre\");\n+      tracer.withSpan(span);\n+\n+      return true;\n+   }\n+\n+   @Override\n+   public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n+         ModelAndView modelAndView) throws Exception {\n+\n+      Span currentSpan = tracer.getCurrentSpan();\n+      currentSpan.setAttribute(\"handler\", \"post\");\n+      OpenTelemetry.getPropagators().getHttpTextFormat().inject(Context.current(), response, setter);\n+      currentSpan.end();\n+   }\n+\n+   @Override\n+   public void afterCompletion(HttpServletRequest request, HttpServletResponse response,\n+         Object handler, Exception exception) throws Exception {}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk0MDYyMg=="}, "originalCommit": {"oid": "0b27f2c9a2ce013c6b80118d7e4ca962e720bc27"}, "originalPosition": 261}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NjE0MDYwOnYy", "diffSide": "RIGHT", "path": "instrumentation-core/spring/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMzozMDowNFrOGnYA2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMzozMDowNFrOGnYA2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk0MTA4Mg==", "bodyText": "for consistency with the other fields\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               HttpUtils httpUtils;\n          \n          \n            \n               private HttpUtils httpUtils;", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r443941082", "createdAt": "2020-06-23T03:30:04Z", "author": {"login": "trask"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -340,6 +341,324 @@ After running Jaeger locally, navigate to the url below. Make sure to refresh th\n \n Run FirstService and SecondService from command line or using an IDE. The end point of interest for FirstService is `http://localhost:8080/message` and  `http://localhost:8081/time` for SecondService. Entering `localhost:8080/message` in a browser should call FirstService and then SecondService, creating a trace. \n \n-***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.secondServiceUrl. ***\n+***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.SECOND_SERVICE_URL. ***\n \n Congrats, we just created a distributed service with OpenTelemetry!\n+\n+## Manual Instrumentation using Handlers and Interceptors\n+\n+In this section, we will implement the Spring HandlerInerceptor interface to wrap all requests to FirstService and Second Service controllers in a span. \n+\n+We will also use the RestTemplate HTTP client to send requests from FirstService to SecondService. To propagate the trace in this request we will also implement the ClientHttpRequestInterceptor interface. This implementation is only required for projects that send outbound requests. In this example it is only required for FirstService. \n+\n+### Setup FirstService and SecondService\n+\n+Using the earlier instructions [create two example projects](#create-two-spring-projects) and add the required [dependencies and configurations](#setup-for-manual-instrumentation). \n+\n+### Instrumentation of Client Service: SecondService\n+\n+Ensure the main method in SecondServiceApplication is defined. This will be the entry point to the SecondService project. This file should be created by the Spring Boot project initializer.\n+\n+```java\n+import java.io.IOException;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+\n+@SpringBootApplication\n+public class SecondServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(SecondServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+Add the RestController below to your SecondService project. This controller will return a string when SecondServiceController.secondTracedMethod is called:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+\n+@RestController\n+@RequestMapping(value = \"/time\")\n+public class SecondServiceController {\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @GetMapping\n+   public String secondTracedMethod() {\n+      return \"It's time to get a watch\";\n+   }\n+}\n+```\n+\n+#### Create Controller Interceptor\n+\n+Add the class below to wrap all requests to the SecondServiceController in a span. This class will call the preHandle method before the RestController is entered and the postHandle method after a response is created. \n+\n+The preHandle method starts a span for each request. The postHandle method closes the span and adds the span context to the response header. This implementation is shown below:    \n+\n+```java\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.servlet.HandlerInterceptor;\n+import org.springframework.web.servlet.ModelAndView;\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n+\n+@Component\n+public class ControllerTraceInterceptor implements HandlerInterceptor {\n+\n+   private static final HttpTextFormat.Getter<HttpServletRequest> getter =\n+         new HttpTextFormat.Getter<HttpServletRequest>() {\n+            public String get(HttpServletRequest req, String key) {\n+               return req.getHeader(key);\n+            }\n+         };\n+\n+   private static final HttpTextFormat.Setter<HttpServletResponse> setter =\n+         new HttpTextFormat.Setter<HttpServletResponse>() {\n+            @Override\n+            public void set(HttpServletResponse response, String key, String value) {\n+               response.addHeader(key, value);\n+            }\n+         };\n+\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @Override\n+   public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n+         throws Exception {\n+      Context context = OpenTelemetry.getPropagators().getHttpTextFormat()\n+          .extract(Context.current(), request, getter);\n+      Span span = createSpanWithParent(request, context);\n+      span.setAttribute(\"handler\", \"pre\");\n+      tracer.withSpan(span);\n+\n+      return true;\n+   }\n+\n+   @Override\n+   public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n+         ModelAndView modelAndView) throws Exception {\n+\n+      Span currentSpan = tracer.getCurrentSpan();\n+      currentSpan.setAttribute(\"handler\", \"post\");\n+      OpenTelemetry.getPropagators().getHttpTextFormat().inject(Context.current(), response, setter);\n+      currentSpan.end();\n+   }\n+\n+   @Override\n+   public void afterCompletion(HttpServletRequest request, HttpServletResponse response,\n+         Object handler, Exception exception) throws Exception {}\n+   \n+   private Span createSpanWithParent(HttpServletRequest request, Context context) {\n+      Span parentSpan = TracingContextUtils.getSpan(context);\n+\n+      if (parentSpan.getContext().isValid()) {\n+         return  tracer.spanBuilder(request.getRequestURI()).setParent(parentSpan).startSpan();\n+      }\n+\n+      Span span = tracer.spanBuilder(request.getRequestURI()).startSpan();\n+      span.addEvent(\"Parent Span Not Found\");\n+\n+      return span;\n+   }\n+}\n+\n+```\n+\n+The final step is to register an instance of the ControllerTraceInterceptor:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.servlet.config.annotation.InterceptorRegistry;\n+import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\n+\n+@Component\n+public class InterceptorConfig extends WebMvcConfigurationSupport {\n+\n+   @Autowired\n+   ControllerTraceInterceptor controllerTraceInterceptor;\n+\n+   @Override\n+   public void addInterceptors(InterceptorRegistry registry) {\n+      registry.addInterceptor(controllerTraceInterceptor);\n+   }\n+}\n+```\n+\n+Now your SecondService application is complete. Create the FirstService application using the instructions below and then run your distributed service!\n+\n+### Instrumentation of Receiving Service: FirstService\n+\n+Ensure the main method in FirstServiceApplication is defined. This will be the entry point to the FirstService project. This file should be created by the Spring Boot project initializer.\n+\n+```java\n+@SpringBootApplication\n+public class FirstServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(FirstServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+Create a RestController for FirstService. This controller will send a request to SecondService and then return the response to the client:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpEntity;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+\n+@RestController\n+@RequestMapping(value = \"/message\")\n+public class FirstServiceController {\n+   @Autowired\n+   private Tracer tracer;\n+\t\n+   @Autowired\n+   private RestTemplate restTemplate;\n+\n+   @Autowired\n+   HttpUtils httpUtils;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b27f2c9a2ce013c6b80118d7e4ca962e720bc27"}, "originalPosition": 338}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NjE0MjEyOnYy", "diffSide": "RIGHT", "path": "instrumentation-core/spring/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMzozMTowM1rOGnYBzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMzozMTowM1rOGnYBzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk0MTMyNA==", "bodyText": "constants are typically static and final\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               private static String SECOND_SERVICE_URL = \"http://localhost:8081/time\";\n          \n          \n            \n               private static final String SECOND_SERVICE_URL = \"http://localhost:8081/time\";", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r443941324", "createdAt": "2020-06-23T03:31:03Z", "author": {"login": "trask"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -340,6 +341,324 @@ After running Jaeger locally, navigate to the url below. Make sure to refresh th\n \n Run FirstService and SecondService from command line or using an IDE. The end point of interest for FirstService is `http://localhost:8080/message` and  `http://localhost:8081/time` for SecondService. Entering `localhost:8080/message` in a browser should call FirstService and then SecondService, creating a trace. \n \n-***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.secondServiceUrl. ***\n+***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.SECOND_SERVICE_URL. ***\n \n Congrats, we just created a distributed service with OpenTelemetry!\n+\n+## Manual Instrumentation using Handlers and Interceptors\n+\n+In this section, we will implement the Spring HandlerInerceptor interface to wrap all requests to FirstService and Second Service controllers in a span. \n+\n+We will also use the RestTemplate HTTP client to send requests from FirstService to SecondService. To propagate the trace in this request we will also implement the ClientHttpRequestInterceptor interface. This implementation is only required for projects that send outbound requests. In this example it is only required for FirstService. \n+\n+### Setup FirstService and SecondService\n+\n+Using the earlier instructions [create two example projects](#create-two-spring-projects) and add the required [dependencies and configurations](#setup-for-manual-instrumentation). \n+\n+### Instrumentation of Client Service: SecondService\n+\n+Ensure the main method in SecondServiceApplication is defined. This will be the entry point to the SecondService project. This file should be created by the Spring Boot project initializer.\n+\n+```java\n+import java.io.IOException;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+\n+@SpringBootApplication\n+public class SecondServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(SecondServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+Add the RestController below to your SecondService project. This controller will return a string when SecondServiceController.secondTracedMethod is called:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+\n+@RestController\n+@RequestMapping(value = \"/time\")\n+public class SecondServiceController {\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @GetMapping\n+   public String secondTracedMethod() {\n+      return \"It's time to get a watch\";\n+   }\n+}\n+```\n+\n+#### Create Controller Interceptor\n+\n+Add the class below to wrap all requests to the SecondServiceController in a span. This class will call the preHandle method before the RestController is entered and the postHandle method after a response is created. \n+\n+The preHandle method starts a span for each request. The postHandle method closes the span and adds the span context to the response header. This implementation is shown below:    \n+\n+```java\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.servlet.HandlerInterceptor;\n+import org.springframework.web.servlet.ModelAndView;\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n+\n+@Component\n+public class ControllerTraceInterceptor implements HandlerInterceptor {\n+\n+   private static final HttpTextFormat.Getter<HttpServletRequest> getter =\n+         new HttpTextFormat.Getter<HttpServletRequest>() {\n+            public String get(HttpServletRequest req, String key) {\n+               return req.getHeader(key);\n+            }\n+         };\n+\n+   private static final HttpTextFormat.Setter<HttpServletResponse> setter =\n+         new HttpTextFormat.Setter<HttpServletResponse>() {\n+            @Override\n+            public void set(HttpServletResponse response, String key, String value) {\n+               response.addHeader(key, value);\n+            }\n+         };\n+\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @Override\n+   public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n+         throws Exception {\n+      Context context = OpenTelemetry.getPropagators().getHttpTextFormat()\n+          .extract(Context.current(), request, getter);\n+      Span span = createSpanWithParent(request, context);\n+      span.setAttribute(\"handler\", \"pre\");\n+      tracer.withSpan(span);\n+\n+      return true;\n+   }\n+\n+   @Override\n+   public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n+         ModelAndView modelAndView) throws Exception {\n+\n+      Span currentSpan = tracer.getCurrentSpan();\n+      currentSpan.setAttribute(\"handler\", \"post\");\n+      OpenTelemetry.getPropagators().getHttpTextFormat().inject(Context.current(), response, setter);\n+      currentSpan.end();\n+   }\n+\n+   @Override\n+   public void afterCompletion(HttpServletRequest request, HttpServletResponse response,\n+         Object handler, Exception exception) throws Exception {}\n+   \n+   private Span createSpanWithParent(HttpServletRequest request, Context context) {\n+      Span parentSpan = TracingContextUtils.getSpan(context);\n+\n+      if (parentSpan.getContext().isValid()) {\n+         return  tracer.spanBuilder(request.getRequestURI()).setParent(parentSpan).startSpan();\n+      }\n+\n+      Span span = tracer.spanBuilder(request.getRequestURI()).startSpan();\n+      span.addEvent(\"Parent Span Not Found\");\n+\n+      return span;\n+   }\n+}\n+\n+```\n+\n+The final step is to register an instance of the ControllerTraceInterceptor:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.servlet.config.annotation.InterceptorRegistry;\n+import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\n+\n+@Component\n+public class InterceptorConfig extends WebMvcConfigurationSupport {\n+\n+   @Autowired\n+   ControllerTraceInterceptor controllerTraceInterceptor;\n+\n+   @Override\n+   public void addInterceptors(InterceptorRegistry registry) {\n+      registry.addInterceptor(controllerTraceInterceptor);\n+   }\n+}\n+```\n+\n+Now your SecondService application is complete. Create the FirstService application using the instructions below and then run your distributed service!\n+\n+### Instrumentation of Receiving Service: FirstService\n+\n+Ensure the main method in FirstServiceApplication is defined. This will be the entry point to the FirstService project. This file should be created by the Spring Boot project initializer.\n+\n+```java\n+@SpringBootApplication\n+public class FirstServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(FirstServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+Create a RestController for FirstService. This controller will send a request to SecondService and then return the response to the client:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpEntity;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+\n+@RestController\n+@RequestMapping(value = \"/message\")\n+public class FirstServiceController {\n+   @Autowired\n+   private Tracer tracer;\n+\t\n+   @Autowired\n+   private RestTemplate restTemplate;\n+\n+   @Autowired\n+   HttpUtils httpUtils;\n+\n+   private static String SECOND_SERVICE_URL = \"http://localhost:8081/time\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b27f2c9a2ce013c6b80118d7e4ca962e720bc27"}, "originalPosition": 340}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NjE0Mzk1OnYy", "diffSide": "RIGHT", "path": "instrumentation-core/spring/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMzozMjoyMFrOGnYC2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMzozMjoyMFrOGnYC2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk0MTU5Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            As seen in the setup of SecondService, create implement the TraceInterceptor interface to wrap requests to the SecondServiceController in a span. Then register this new handler by extending the HandlerInterceptor. In effect, we will be taking a copy of the InterceptorConfig.java and ControllerTraceInterceptor.java defined in SecondService and adding it to FirstService. These files are referenced [here](#create-controller-interceptor).\n          \n          \n            \n            As seen in the setup of SecondService, implement the TraceInterceptor interface to wrap requests to the SecondServiceController in a span. Then register this new handler by extending the HandlerInterceptor. In effect, we will be taking a copy of the InterceptorConfig.java and ControllerTraceInterceptor.java defined in SecondService and adding it to FirstService. These files are referenced [here](#create-controller-interceptor).", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r443941593", "createdAt": "2020-06-23T03:32:20Z", "author": {"login": "trask"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -340,6 +341,324 @@ After running Jaeger locally, navigate to the url below. Make sure to refresh th\n \n Run FirstService and SecondService from command line or using an IDE. The end point of interest for FirstService is `http://localhost:8080/message` and  `http://localhost:8081/time` for SecondService. Entering `localhost:8080/message` in a browser should call FirstService and then SecondService, creating a trace. \n \n-***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.secondServiceUrl. ***\n+***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.SECOND_SERVICE_URL. ***\n \n Congrats, we just created a distributed service with OpenTelemetry!\n+\n+## Manual Instrumentation using Handlers and Interceptors\n+\n+In this section, we will implement the Spring HandlerInerceptor interface to wrap all requests to FirstService and Second Service controllers in a span. \n+\n+We will also use the RestTemplate HTTP client to send requests from FirstService to SecondService. To propagate the trace in this request we will also implement the ClientHttpRequestInterceptor interface. This implementation is only required for projects that send outbound requests. In this example it is only required for FirstService. \n+\n+### Setup FirstService and SecondService\n+\n+Using the earlier instructions [create two example projects](#create-two-spring-projects) and add the required [dependencies and configurations](#setup-for-manual-instrumentation). \n+\n+### Instrumentation of Client Service: SecondService\n+\n+Ensure the main method in SecondServiceApplication is defined. This will be the entry point to the SecondService project. This file should be created by the Spring Boot project initializer.\n+\n+```java\n+import java.io.IOException;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+\n+@SpringBootApplication\n+public class SecondServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(SecondServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+Add the RestController below to your SecondService project. This controller will return a string when SecondServiceController.secondTracedMethod is called:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+\n+@RestController\n+@RequestMapping(value = \"/time\")\n+public class SecondServiceController {\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @GetMapping\n+   public String secondTracedMethod() {\n+      return \"It's time to get a watch\";\n+   }\n+}\n+```\n+\n+#### Create Controller Interceptor\n+\n+Add the class below to wrap all requests to the SecondServiceController in a span. This class will call the preHandle method before the RestController is entered and the postHandle method after a response is created. \n+\n+The preHandle method starts a span for each request. The postHandle method closes the span and adds the span context to the response header. This implementation is shown below:    \n+\n+```java\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.servlet.HandlerInterceptor;\n+import org.springframework.web.servlet.ModelAndView;\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n+\n+@Component\n+public class ControllerTraceInterceptor implements HandlerInterceptor {\n+\n+   private static final HttpTextFormat.Getter<HttpServletRequest> getter =\n+         new HttpTextFormat.Getter<HttpServletRequest>() {\n+            public String get(HttpServletRequest req, String key) {\n+               return req.getHeader(key);\n+            }\n+         };\n+\n+   private static final HttpTextFormat.Setter<HttpServletResponse> setter =\n+         new HttpTextFormat.Setter<HttpServletResponse>() {\n+            @Override\n+            public void set(HttpServletResponse response, String key, String value) {\n+               response.addHeader(key, value);\n+            }\n+         };\n+\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @Override\n+   public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n+         throws Exception {\n+      Context context = OpenTelemetry.getPropagators().getHttpTextFormat()\n+          .extract(Context.current(), request, getter);\n+      Span span = createSpanWithParent(request, context);\n+      span.setAttribute(\"handler\", \"pre\");\n+      tracer.withSpan(span);\n+\n+      return true;\n+   }\n+\n+   @Override\n+   public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n+         ModelAndView modelAndView) throws Exception {\n+\n+      Span currentSpan = tracer.getCurrentSpan();\n+      currentSpan.setAttribute(\"handler\", \"post\");\n+      OpenTelemetry.getPropagators().getHttpTextFormat().inject(Context.current(), response, setter);\n+      currentSpan.end();\n+   }\n+\n+   @Override\n+   public void afterCompletion(HttpServletRequest request, HttpServletResponse response,\n+         Object handler, Exception exception) throws Exception {}\n+   \n+   private Span createSpanWithParent(HttpServletRequest request, Context context) {\n+      Span parentSpan = TracingContextUtils.getSpan(context);\n+\n+      if (parentSpan.getContext().isValid()) {\n+         return  tracer.spanBuilder(request.getRequestURI()).setParent(parentSpan).startSpan();\n+      }\n+\n+      Span span = tracer.spanBuilder(request.getRequestURI()).startSpan();\n+      span.addEvent(\"Parent Span Not Found\");\n+\n+      return span;\n+   }\n+}\n+\n+```\n+\n+The final step is to register an instance of the ControllerTraceInterceptor:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.servlet.config.annotation.InterceptorRegistry;\n+import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\n+\n+@Component\n+public class InterceptorConfig extends WebMvcConfigurationSupport {\n+\n+   @Autowired\n+   ControllerTraceInterceptor controllerTraceInterceptor;\n+\n+   @Override\n+   public void addInterceptors(InterceptorRegistry registry) {\n+      registry.addInterceptor(controllerTraceInterceptor);\n+   }\n+}\n+```\n+\n+Now your SecondService application is complete. Create the FirstService application using the instructions below and then run your distributed service!\n+\n+### Instrumentation of Receiving Service: FirstService\n+\n+Ensure the main method in FirstServiceApplication is defined. This will be the entry point to the FirstService project. This file should be created by the Spring Boot project initializer.\n+\n+```java\n+@SpringBootApplication\n+public class FirstServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(FirstServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+Create a RestController for FirstService. This controller will send a request to SecondService and then return the response to the client:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpEntity;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+\n+@RestController\n+@RequestMapping(value = \"/message\")\n+public class FirstServiceController {\n+   @Autowired\n+   private Tracer tracer;\n+\t\n+   @Autowired\n+   private RestTemplate restTemplate;\n+\n+   @Autowired\n+   HttpUtils httpUtils;\n+\n+   private static String SECOND_SERVICE_URL = \"http://localhost:8081/time\";\n+\n+   @GetMapping\n+   public String firstTracedMethod() {\n+\n+      ResponseEntity<String> response =\n+            restTemplate.exchange(SECOND_SERVICE_URL, HttpMethod.GET, null, String.class);\n+      String secondServiceTime = response.getBody();\n+\n+      return \"Second Service says: \" + secondServiceTime;\n+\n+   }\n+}\n+```\n+\n+As seen in the setup of SecondService, create implement the TraceInterceptor interface to wrap requests to the SecondServiceController in a span. Then register this new handler by extending the HandlerInterceptor. In effect, we will be taking a copy of the InterceptorConfig.java and ControllerTraceInterceptor.java defined in SecondService and adding it to FirstService. These files are referenced [here](#create-controller-interceptor).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b27f2c9a2ce013c6b80118d7e4ca962e720bc27"}, "originalPosition": 355}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NjE0NTg5OnYy", "diffSide": "RIGHT", "path": "instrumentation-core/spring/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMzozMzozMVrOGnYD9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMzozMzozMVrOGnYD9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk0MTg3Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            To propagate the span context from FirstService to SecondService we must inject the trace id and trace state into the outgoing request header. In section 1 this was done using the helper class HttpUtils. In this section, we will implement the ClientHttpRequestInterceptor interface and register this interceptor in our application. \n          \n          \n            \n            To propagate the span context from FirstService to SecondService we must inject the trace parent and trace state into the outgoing request header. In section 1 this was done using the helper class HttpUtils. In this section, we will implement the ClientHttpRequestInterceptor interface and register this interceptor in our application.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r443941876", "createdAt": "2020-06-23T03:33:31Z", "author": {"login": "trask"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -340,6 +341,324 @@ After running Jaeger locally, navigate to the url below. Make sure to refresh th\n \n Run FirstService and SecondService from command line or using an IDE. The end point of interest for FirstService is `http://localhost:8080/message` and  `http://localhost:8081/time` for SecondService. Entering `localhost:8080/message` in a browser should call FirstService and then SecondService, creating a trace. \n \n-***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.secondServiceUrl. ***\n+***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.SECOND_SERVICE_URL. ***\n \n Congrats, we just created a distributed service with OpenTelemetry!\n+\n+## Manual Instrumentation using Handlers and Interceptors\n+\n+In this section, we will implement the Spring HandlerInerceptor interface to wrap all requests to FirstService and Second Service controllers in a span. \n+\n+We will also use the RestTemplate HTTP client to send requests from FirstService to SecondService. To propagate the trace in this request we will also implement the ClientHttpRequestInterceptor interface. This implementation is only required for projects that send outbound requests. In this example it is only required for FirstService. \n+\n+### Setup FirstService and SecondService\n+\n+Using the earlier instructions [create two example projects](#create-two-spring-projects) and add the required [dependencies and configurations](#setup-for-manual-instrumentation). \n+\n+### Instrumentation of Client Service: SecondService\n+\n+Ensure the main method in SecondServiceApplication is defined. This will be the entry point to the SecondService project. This file should be created by the Spring Boot project initializer.\n+\n+```java\n+import java.io.IOException;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+\n+@SpringBootApplication\n+public class SecondServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(SecondServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+Add the RestController below to your SecondService project. This controller will return a string when SecondServiceController.secondTracedMethod is called:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+\n+@RestController\n+@RequestMapping(value = \"/time\")\n+public class SecondServiceController {\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @GetMapping\n+   public String secondTracedMethod() {\n+      return \"It's time to get a watch\";\n+   }\n+}\n+```\n+\n+#### Create Controller Interceptor\n+\n+Add the class below to wrap all requests to the SecondServiceController in a span. This class will call the preHandle method before the RestController is entered and the postHandle method after a response is created. \n+\n+The preHandle method starts a span for each request. The postHandle method closes the span and adds the span context to the response header. This implementation is shown below:    \n+\n+```java\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.servlet.HandlerInterceptor;\n+import org.springframework.web.servlet.ModelAndView;\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n+\n+@Component\n+public class ControllerTraceInterceptor implements HandlerInterceptor {\n+\n+   private static final HttpTextFormat.Getter<HttpServletRequest> getter =\n+         new HttpTextFormat.Getter<HttpServletRequest>() {\n+            public String get(HttpServletRequest req, String key) {\n+               return req.getHeader(key);\n+            }\n+         };\n+\n+   private static final HttpTextFormat.Setter<HttpServletResponse> setter =\n+         new HttpTextFormat.Setter<HttpServletResponse>() {\n+            @Override\n+            public void set(HttpServletResponse response, String key, String value) {\n+               response.addHeader(key, value);\n+            }\n+         };\n+\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @Override\n+   public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n+         throws Exception {\n+      Context context = OpenTelemetry.getPropagators().getHttpTextFormat()\n+          .extract(Context.current(), request, getter);\n+      Span span = createSpanWithParent(request, context);\n+      span.setAttribute(\"handler\", \"pre\");\n+      tracer.withSpan(span);\n+\n+      return true;\n+   }\n+\n+   @Override\n+   public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n+         ModelAndView modelAndView) throws Exception {\n+\n+      Span currentSpan = tracer.getCurrentSpan();\n+      currentSpan.setAttribute(\"handler\", \"post\");\n+      OpenTelemetry.getPropagators().getHttpTextFormat().inject(Context.current(), response, setter);\n+      currentSpan.end();\n+   }\n+\n+   @Override\n+   public void afterCompletion(HttpServletRequest request, HttpServletResponse response,\n+         Object handler, Exception exception) throws Exception {}\n+   \n+   private Span createSpanWithParent(HttpServletRequest request, Context context) {\n+      Span parentSpan = TracingContextUtils.getSpan(context);\n+\n+      if (parentSpan.getContext().isValid()) {\n+         return  tracer.spanBuilder(request.getRequestURI()).setParent(parentSpan).startSpan();\n+      }\n+\n+      Span span = tracer.spanBuilder(request.getRequestURI()).startSpan();\n+      span.addEvent(\"Parent Span Not Found\");\n+\n+      return span;\n+   }\n+}\n+\n+```\n+\n+The final step is to register an instance of the ControllerTraceInterceptor:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.servlet.config.annotation.InterceptorRegistry;\n+import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\n+\n+@Component\n+public class InterceptorConfig extends WebMvcConfigurationSupport {\n+\n+   @Autowired\n+   ControllerTraceInterceptor controllerTraceInterceptor;\n+\n+   @Override\n+   public void addInterceptors(InterceptorRegistry registry) {\n+      registry.addInterceptor(controllerTraceInterceptor);\n+   }\n+}\n+```\n+\n+Now your SecondService application is complete. Create the FirstService application using the instructions below and then run your distributed service!\n+\n+### Instrumentation of Receiving Service: FirstService\n+\n+Ensure the main method in FirstServiceApplication is defined. This will be the entry point to the FirstService project. This file should be created by the Spring Boot project initializer.\n+\n+```java\n+@SpringBootApplication\n+public class FirstServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(FirstServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+Create a RestController for FirstService. This controller will send a request to SecondService and then return the response to the client:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpEntity;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+\n+@RestController\n+@RequestMapping(value = \"/message\")\n+public class FirstServiceController {\n+   @Autowired\n+   private Tracer tracer;\n+\t\n+   @Autowired\n+   private RestTemplate restTemplate;\n+\n+   @Autowired\n+   HttpUtils httpUtils;\n+\n+   private static String SECOND_SERVICE_URL = \"http://localhost:8081/time\";\n+\n+   @GetMapping\n+   public String firstTracedMethod() {\n+\n+      ResponseEntity<String> response =\n+            restTemplate.exchange(SECOND_SERVICE_URL, HttpMethod.GET, null, String.class);\n+      String secondServiceTime = response.getBody();\n+\n+      return \"Second Service says: \" + secondServiceTime;\n+\n+   }\n+}\n+```\n+\n+As seen in the setup of SecondService, create implement the TraceInterceptor interface to wrap requests to the SecondServiceController in a span. Then register this new handler by extending the HandlerInterceptor. In effect, we will be taking a copy of the InterceptorConfig.java and ControllerTraceInterceptor.java defined in SecondService and adding it to FirstService. These files are referenced [here](#create-controller-interceptor).\n+\n+#### Create Client Http Request Interceptor\n+\n+Next, we will configure the ClientHttpRequestInterceptor to intercept all client HTTP requests made using RestTemplate.\n+\n+To propagate the span context from FirstService to SecondService we must inject the trace id and trace state into the outgoing request header. In section 1 this was done using the helper class HttpUtils. In this section, we will implement the ClientHttpRequestInterceptor interface and register this interceptor in our application. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b27f2c9a2ce013c6b80118d7e4ca962e720bc27"}, "originalPosition": 361}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NjE0NzYzOnYy", "diffSide": "RIGHT", "path": "instrumentation-core/spring/README.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMzozNDozOVrOGnYE9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwMzo1NTozN1rOGoCEwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk0MjEzMw==", "bodyText": "this span is not ended", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r443942133", "createdAt": "2020-06-23T03:34:39Z", "author": {"login": "trask"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -340,6 +341,324 @@ After running Jaeger locally, navigate to the url below. Make sure to refresh th\n \n Run FirstService and SecondService from command line or using an IDE. The end point of interest for FirstService is `http://localhost:8080/message` and  `http://localhost:8081/time` for SecondService. Entering `localhost:8080/message` in a browser should call FirstService and then SecondService, creating a trace. \n \n-***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.secondServiceUrl. ***\n+***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.SECOND_SERVICE_URL. ***\n \n Congrats, we just created a distributed service with OpenTelemetry!\n+\n+## Manual Instrumentation using Handlers and Interceptors\n+\n+In this section, we will implement the Spring HandlerInerceptor interface to wrap all requests to FirstService and Second Service controllers in a span. \n+\n+We will also use the RestTemplate HTTP client to send requests from FirstService to SecondService. To propagate the trace in this request we will also implement the ClientHttpRequestInterceptor interface. This implementation is only required for projects that send outbound requests. In this example it is only required for FirstService. \n+\n+### Setup FirstService and SecondService\n+\n+Using the earlier instructions [create two example projects](#create-two-spring-projects) and add the required [dependencies and configurations](#setup-for-manual-instrumentation). \n+\n+### Instrumentation of Client Service: SecondService\n+\n+Ensure the main method in SecondServiceApplication is defined. This will be the entry point to the SecondService project. This file should be created by the Spring Boot project initializer.\n+\n+```java\n+import java.io.IOException;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+\n+@SpringBootApplication\n+public class SecondServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(SecondServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+Add the RestController below to your SecondService project. This controller will return a string when SecondServiceController.secondTracedMethod is called:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+\n+@RestController\n+@RequestMapping(value = \"/time\")\n+public class SecondServiceController {\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @GetMapping\n+   public String secondTracedMethod() {\n+      return \"It's time to get a watch\";\n+   }\n+}\n+```\n+\n+#### Create Controller Interceptor\n+\n+Add the class below to wrap all requests to the SecondServiceController in a span. This class will call the preHandle method before the RestController is entered and the postHandle method after a response is created. \n+\n+The preHandle method starts a span for each request. The postHandle method closes the span and adds the span context to the response header. This implementation is shown below:    \n+\n+```java\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.servlet.HandlerInterceptor;\n+import org.springframework.web.servlet.ModelAndView;\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n+\n+@Component\n+public class ControllerTraceInterceptor implements HandlerInterceptor {\n+\n+   private static final HttpTextFormat.Getter<HttpServletRequest> getter =\n+         new HttpTextFormat.Getter<HttpServletRequest>() {\n+            public String get(HttpServletRequest req, String key) {\n+               return req.getHeader(key);\n+            }\n+         };\n+\n+   private static final HttpTextFormat.Setter<HttpServletResponse> setter =\n+         new HttpTextFormat.Setter<HttpServletResponse>() {\n+            @Override\n+            public void set(HttpServletResponse response, String key, String value) {\n+               response.addHeader(key, value);\n+            }\n+         };\n+\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @Override\n+   public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n+         throws Exception {\n+      Context context = OpenTelemetry.getPropagators().getHttpTextFormat()\n+          .extract(Context.current(), request, getter);\n+      Span span = createSpanWithParent(request, context);\n+      span.setAttribute(\"handler\", \"pre\");\n+      tracer.withSpan(span);\n+\n+      return true;\n+   }\n+\n+   @Override\n+   public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n+         ModelAndView modelAndView) throws Exception {\n+\n+      Span currentSpan = tracer.getCurrentSpan();\n+      currentSpan.setAttribute(\"handler\", \"post\");\n+      OpenTelemetry.getPropagators().getHttpTextFormat().inject(Context.current(), response, setter);\n+      currentSpan.end();\n+   }\n+\n+   @Override\n+   public void afterCompletion(HttpServletRequest request, HttpServletResponse response,\n+         Object handler, Exception exception) throws Exception {}\n+   \n+   private Span createSpanWithParent(HttpServletRequest request, Context context) {\n+      Span parentSpan = TracingContextUtils.getSpan(context);\n+\n+      if (parentSpan.getContext().isValid()) {\n+         return  tracer.spanBuilder(request.getRequestURI()).setParent(parentSpan).startSpan();\n+      }\n+\n+      Span span = tracer.spanBuilder(request.getRequestURI()).startSpan();\n+      span.addEvent(\"Parent Span Not Found\");\n+\n+      return span;\n+   }\n+}\n+\n+```\n+\n+The final step is to register an instance of the ControllerTraceInterceptor:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.servlet.config.annotation.InterceptorRegistry;\n+import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\n+\n+@Component\n+public class InterceptorConfig extends WebMvcConfigurationSupport {\n+\n+   @Autowired\n+   ControllerTraceInterceptor controllerTraceInterceptor;\n+\n+   @Override\n+   public void addInterceptors(InterceptorRegistry registry) {\n+      registry.addInterceptor(controllerTraceInterceptor);\n+   }\n+}\n+```\n+\n+Now your SecondService application is complete. Create the FirstService application using the instructions below and then run your distributed service!\n+\n+### Instrumentation of Receiving Service: FirstService\n+\n+Ensure the main method in FirstServiceApplication is defined. This will be the entry point to the FirstService project. This file should be created by the Spring Boot project initializer.\n+\n+```java\n+@SpringBootApplication\n+public class FirstServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(FirstServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+Create a RestController for FirstService. This controller will send a request to SecondService and then return the response to the client:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpEntity;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+\n+@RestController\n+@RequestMapping(value = \"/message\")\n+public class FirstServiceController {\n+   @Autowired\n+   private Tracer tracer;\n+\t\n+   @Autowired\n+   private RestTemplate restTemplate;\n+\n+   @Autowired\n+   HttpUtils httpUtils;\n+\n+   private static String SECOND_SERVICE_URL = \"http://localhost:8081/time\";\n+\n+   @GetMapping\n+   public String firstTracedMethod() {\n+\n+      ResponseEntity<String> response =\n+            restTemplate.exchange(SECOND_SERVICE_URL, HttpMethod.GET, null, String.class);\n+      String secondServiceTime = response.getBody();\n+\n+      return \"Second Service says: \" + secondServiceTime;\n+\n+   }\n+}\n+```\n+\n+As seen in the setup of SecondService, create implement the TraceInterceptor interface to wrap requests to the SecondServiceController in a span. Then register this new handler by extending the HandlerInterceptor. In effect, we will be taking a copy of the InterceptorConfig.java and ControllerTraceInterceptor.java defined in SecondService and adding it to FirstService. These files are referenced [here](#create-controller-interceptor).\n+\n+#### Create Client Http Request Interceptor\n+\n+Next, we will configure the ClientHttpRequestInterceptor to intercept all client HTTP requests made using RestTemplate.\n+\n+To propagate the span context from FirstService to SecondService we must inject the trace id and trace state into the outgoing request header. In section 1 this was done using the helper class HttpUtils. In this section, we will implement the ClientHttpRequestInterceptor interface and register this interceptor in our application. \n+\n+Include the two classes below to your FirstService project to add this functionality:\n+\n+\n+```java\n+\n+import java.io.IOException;\n+\n+import io.grpc.Context;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpRequest;\n+\n+import org.springframework.http.client.ClientHttpRequestExecution;\n+import org.springframework.http.client.ClientHttpRequestInterceptor;\n+import org.springframework.http.client.ClientHttpResponse;\n+import org.springframework.stereotype.Component;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+\n+@Component\n+public class RestTemplateHeaderModifierInterceptor implements ClientHttpRequestInterceptor {\n+\n+   @Autowired\n+   private Tracer tracer;\n+\n+   private static final HttpTextFormat.Setter<HttpRequest> setter =\n+         new HttpTextFormat.Setter<HttpRequest>() {\n+            @Override\n+            public void set(HttpRequest carrier, String key, String value) {\n+               carrier.getHeaders().set(key, value);\n+            }\n+         };\n+\n+\n+   @Override\n+   public ClientHttpResponse intercept(HttpRequest request, byte[] body,\n+         ClientHttpRequestExecution execution) throws IOException {\n+\n+      Span currentSpan = tracer.getCurrentSpan();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b27f2c9a2ce013c6b80118d7e4ca962e720bc27"}, "originalPosition": 402}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDMyNTg2Mg==", "bodyText": "I can see why this can be a bit cryptic but I started the span in ControllerTraceInterceptor.preHandle (line 442) and I end the span in ControllerTraceInterceptor.postHandle (line 454). currentSpan is opened and closed by the Controller Interceptor. Here I wrap each request in one span and I add events to this span in other parts of the application. I do not create sub spans with in a rest controller. In the RestTemplate interceptor defined above, I get the controller span from the tracer and I add an event. Although I'm not sure if this approach follows best practices for tracing or if I'm missing something here. Please advise and thanks again for your help.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r444325862", "createdAt": "2020-06-23T15:46:57Z", "author": {"login": "mabdinur"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -340,6 +341,324 @@ After running Jaeger locally, navigate to the url below. Make sure to refresh th\n \n Run FirstService and SecondService from command line or using an IDE. The end point of interest for FirstService is `http://localhost:8080/message` and  `http://localhost:8081/time` for SecondService. Entering `localhost:8080/message` in a browser should call FirstService and then SecondService, creating a trace. \n \n-***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.secondServiceUrl. ***\n+***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.SECOND_SERVICE_URL. ***\n \n Congrats, we just created a distributed service with OpenTelemetry!\n+\n+## Manual Instrumentation using Handlers and Interceptors\n+\n+In this section, we will implement the Spring HandlerInerceptor interface to wrap all requests to FirstService and Second Service controllers in a span. \n+\n+We will also use the RestTemplate HTTP client to send requests from FirstService to SecondService. To propagate the trace in this request we will also implement the ClientHttpRequestInterceptor interface. This implementation is only required for projects that send outbound requests. In this example it is only required for FirstService. \n+\n+### Setup FirstService and SecondService\n+\n+Using the earlier instructions [create two example projects](#create-two-spring-projects) and add the required [dependencies and configurations](#setup-for-manual-instrumentation). \n+\n+### Instrumentation of Client Service: SecondService\n+\n+Ensure the main method in SecondServiceApplication is defined. This will be the entry point to the SecondService project. This file should be created by the Spring Boot project initializer.\n+\n+```java\n+import java.io.IOException;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+\n+@SpringBootApplication\n+public class SecondServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(SecondServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+Add the RestController below to your SecondService project. This controller will return a string when SecondServiceController.secondTracedMethod is called:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+\n+@RestController\n+@RequestMapping(value = \"/time\")\n+public class SecondServiceController {\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @GetMapping\n+   public String secondTracedMethod() {\n+      return \"It's time to get a watch\";\n+   }\n+}\n+```\n+\n+#### Create Controller Interceptor\n+\n+Add the class below to wrap all requests to the SecondServiceController in a span. This class will call the preHandle method before the RestController is entered and the postHandle method after a response is created. \n+\n+The preHandle method starts a span for each request. The postHandle method closes the span and adds the span context to the response header. This implementation is shown below:    \n+\n+```java\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.servlet.HandlerInterceptor;\n+import org.springframework.web.servlet.ModelAndView;\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n+\n+@Component\n+public class ControllerTraceInterceptor implements HandlerInterceptor {\n+\n+   private static final HttpTextFormat.Getter<HttpServletRequest> getter =\n+         new HttpTextFormat.Getter<HttpServletRequest>() {\n+            public String get(HttpServletRequest req, String key) {\n+               return req.getHeader(key);\n+            }\n+         };\n+\n+   private static final HttpTextFormat.Setter<HttpServletResponse> setter =\n+         new HttpTextFormat.Setter<HttpServletResponse>() {\n+            @Override\n+            public void set(HttpServletResponse response, String key, String value) {\n+               response.addHeader(key, value);\n+            }\n+         };\n+\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @Override\n+   public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n+         throws Exception {\n+      Context context = OpenTelemetry.getPropagators().getHttpTextFormat()\n+          .extract(Context.current(), request, getter);\n+      Span span = createSpanWithParent(request, context);\n+      span.setAttribute(\"handler\", \"pre\");\n+      tracer.withSpan(span);\n+\n+      return true;\n+   }\n+\n+   @Override\n+   public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n+         ModelAndView modelAndView) throws Exception {\n+\n+      Span currentSpan = tracer.getCurrentSpan();\n+      currentSpan.setAttribute(\"handler\", \"post\");\n+      OpenTelemetry.getPropagators().getHttpTextFormat().inject(Context.current(), response, setter);\n+      currentSpan.end();\n+   }\n+\n+   @Override\n+   public void afterCompletion(HttpServletRequest request, HttpServletResponse response,\n+         Object handler, Exception exception) throws Exception {}\n+   \n+   private Span createSpanWithParent(HttpServletRequest request, Context context) {\n+      Span parentSpan = TracingContextUtils.getSpan(context);\n+\n+      if (parentSpan.getContext().isValid()) {\n+         return  tracer.spanBuilder(request.getRequestURI()).setParent(parentSpan).startSpan();\n+      }\n+\n+      Span span = tracer.spanBuilder(request.getRequestURI()).startSpan();\n+      span.addEvent(\"Parent Span Not Found\");\n+\n+      return span;\n+   }\n+}\n+\n+```\n+\n+The final step is to register an instance of the ControllerTraceInterceptor:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.servlet.config.annotation.InterceptorRegistry;\n+import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\n+\n+@Component\n+public class InterceptorConfig extends WebMvcConfigurationSupport {\n+\n+   @Autowired\n+   ControllerTraceInterceptor controllerTraceInterceptor;\n+\n+   @Override\n+   public void addInterceptors(InterceptorRegistry registry) {\n+      registry.addInterceptor(controllerTraceInterceptor);\n+   }\n+}\n+```\n+\n+Now your SecondService application is complete. Create the FirstService application using the instructions below and then run your distributed service!\n+\n+### Instrumentation of Receiving Service: FirstService\n+\n+Ensure the main method in FirstServiceApplication is defined. This will be the entry point to the FirstService project. This file should be created by the Spring Boot project initializer.\n+\n+```java\n+@SpringBootApplication\n+public class FirstServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(FirstServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+Create a RestController for FirstService. This controller will send a request to SecondService and then return the response to the client:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpEntity;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+\n+@RestController\n+@RequestMapping(value = \"/message\")\n+public class FirstServiceController {\n+   @Autowired\n+   private Tracer tracer;\n+\t\n+   @Autowired\n+   private RestTemplate restTemplate;\n+\n+   @Autowired\n+   HttpUtils httpUtils;\n+\n+   private static String SECOND_SERVICE_URL = \"http://localhost:8081/time\";\n+\n+   @GetMapping\n+   public String firstTracedMethod() {\n+\n+      ResponseEntity<String> response =\n+            restTemplate.exchange(SECOND_SERVICE_URL, HttpMethod.GET, null, String.class);\n+      String secondServiceTime = response.getBody();\n+\n+      return \"Second Service says: \" + secondServiceTime;\n+\n+   }\n+}\n+```\n+\n+As seen in the setup of SecondService, create implement the TraceInterceptor interface to wrap requests to the SecondServiceController in a span. Then register this new handler by extending the HandlerInterceptor. In effect, we will be taking a copy of the InterceptorConfig.java and ControllerTraceInterceptor.java defined in SecondService and adding it to FirstService. These files are referenced [here](#create-controller-interceptor).\n+\n+#### Create Client Http Request Interceptor\n+\n+Next, we will configure the ClientHttpRequestInterceptor to intercept all client HTTP requests made using RestTemplate.\n+\n+To propagate the span context from FirstService to SecondService we must inject the trace id and trace state into the outgoing request header. In section 1 this was done using the helper class HttpUtils. In this section, we will implement the ClientHttpRequestInterceptor interface and register this interceptor in our application. \n+\n+Include the two classes below to your FirstService project to add this functionality:\n+\n+\n+```java\n+\n+import java.io.IOException;\n+\n+import io.grpc.Context;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpRequest;\n+\n+import org.springframework.http.client.ClientHttpRequestExecution;\n+import org.springframework.http.client.ClientHttpRequestInterceptor;\n+import org.springframework.http.client.ClientHttpResponse;\n+import org.springframework.stereotype.Component;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+\n+@Component\n+public class RestTemplateHeaderModifierInterceptor implements ClientHttpRequestInterceptor {\n+\n+   @Autowired\n+   private Tracer tracer;\n+\n+   private static final HttpTextFormat.Setter<HttpRequest> setter =\n+         new HttpTextFormat.Setter<HttpRequest>() {\n+            @Override\n+            public void set(HttpRequest carrier, String key, String value) {\n+               carrier.getHeaders().set(key, value);\n+            }\n+         };\n+\n+\n+   @Override\n+   public ClientHttpResponse intercept(HttpRequest request, byte[] body,\n+         ClientHttpRequestExecution execution) throws IOException {\n+\n+      Span currentSpan = tracer.getCurrentSpan();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk0MjEzMw=="}, "originalCommit": {"oid": "0b27f2c9a2ce013c6b80118d7e4ca962e720bc27"}, "originalPosition": 402}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDYzMDIwOQ==", "bodyText": "oh yes, i missed that you are not creating a new span here\nya, best practice is to create a new span here (with kind Span.Kind.CLIENT), instead of adding an event \ud83d\udc4d", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r444630209", "createdAt": "2020-06-24T03:55:37Z", "author": {"login": "trask"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -340,6 +341,324 @@ After running Jaeger locally, navigate to the url below. Make sure to refresh th\n \n Run FirstService and SecondService from command line or using an IDE. The end point of interest for FirstService is `http://localhost:8080/message` and  `http://localhost:8081/time` for SecondService. Entering `localhost:8080/message` in a browser should call FirstService and then SecondService, creating a trace. \n \n-***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.secondServiceUrl. ***\n+***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.SECOND_SERVICE_URL. ***\n \n Congrats, we just created a distributed service with OpenTelemetry!\n+\n+## Manual Instrumentation using Handlers and Interceptors\n+\n+In this section, we will implement the Spring HandlerInerceptor interface to wrap all requests to FirstService and Second Service controllers in a span. \n+\n+We will also use the RestTemplate HTTP client to send requests from FirstService to SecondService. To propagate the trace in this request we will also implement the ClientHttpRequestInterceptor interface. This implementation is only required for projects that send outbound requests. In this example it is only required for FirstService. \n+\n+### Setup FirstService and SecondService\n+\n+Using the earlier instructions [create two example projects](#create-two-spring-projects) and add the required [dependencies and configurations](#setup-for-manual-instrumentation). \n+\n+### Instrumentation of Client Service: SecondService\n+\n+Ensure the main method in SecondServiceApplication is defined. This will be the entry point to the SecondService project. This file should be created by the Spring Boot project initializer.\n+\n+```java\n+import java.io.IOException;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+\n+@SpringBootApplication\n+public class SecondServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(SecondServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+Add the RestController below to your SecondService project. This controller will return a string when SecondServiceController.secondTracedMethod is called:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+\n+@RestController\n+@RequestMapping(value = \"/time\")\n+public class SecondServiceController {\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @GetMapping\n+   public String secondTracedMethod() {\n+      return \"It's time to get a watch\";\n+   }\n+}\n+```\n+\n+#### Create Controller Interceptor\n+\n+Add the class below to wrap all requests to the SecondServiceController in a span. This class will call the preHandle method before the RestController is entered and the postHandle method after a response is created. \n+\n+The preHandle method starts a span for each request. The postHandle method closes the span and adds the span context to the response header. This implementation is shown below:    \n+\n+```java\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.servlet.HandlerInterceptor;\n+import org.springframework.web.servlet.ModelAndView;\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n+\n+@Component\n+public class ControllerTraceInterceptor implements HandlerInterceptor {\n+\n+   private static final HttpTextFormat.Getter<HttpServletRequest> getter =\n+         new HttpTextFormat.Getter<HttpServletRequest>() {\n+            public String get(HttpServletRequest req, String key) {\n+               return req.getHeader(key);\n+            }\n+         };\n+\n+   private static final HttpTextFormat.Setter<HttpServletResponse> setter =\n+         new HttpTextFormat.Setter<HttpServletResponse>() {\n+            @Override\n+            public void set(HttpServletResponse response, String key, String value) {\n+               response.addHeader(key, value);\n+            }\n+         };\n+\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @Override\n+   public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n+         throws Exception {\n+      Context context = OpenTelemetry.getPropagators().getHttpTextFormat()\n+          .extract(Context.current(), request, getter);\n+      Span span = createSpanWithParent(request, context);\n+      span.setAttribute(\"handler\", \"pre\");\n+      tracer.withSpan(span);\n+\n+      return true;\n+   }\n+\n+   @Override\n+   public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n+         ModelAndView modelAndView) throws Exception {\n+\n+      Span currentSpan = tracer.getCurrentSpan();\n+      currentSpan.setAttribute(\"handler\", \"post\");\n+      OpenTelemetry.getPropagators().getHttpTextFormat().inject(Context.current(), response, setter);\n+      currentSpan.end();\n+   }\n+\n+   @Override\n+   public void afterCompletion(HttpServletRequest request, HttpServletResponse response,\n+         Object handler, Exception exception) throws Exception {}\n+   \n+   private Span createSpanWithParent(HttpServletRequest request, Context context) {\n+      Span parentSpan = TracingContextUtils.getSpan(context);\n+\n+      if (parentSpan.getContext().isValid()) {\n+         return  tracer.spanBuilder(request.getRequestURI()).setParent(parentSpan).startSpan();\n+      }\n+\n+      Span span = tracer.spanBuilder(request.getRequestURI()).startSpan();\n+      span.addEvent(\"Parent Span Not Found\");\n+\n+      return span;\n+   }\n+}\n+\n+```\n+\n+The final step is to register an instance of the ControllerTraceInterceptor:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.servlet.config.annotation.InterceptorRegistry;\n+import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\n+\n+@Component\n+public class InterceptorConfig extends WebMvcConfigurationSupport {\n+\n+   @Autowired\n+   ControllerTraceInterceptor controllerTraceInterceptor;\n+\n+   @Override\n+   public void addInterceptors(InterceptorRegistry registry) {\n+      registry.addInterceptor(controllerTraceInterceptor);\n+   }\n+}\n+```\n+\n+Now your SecondService application is complete. Create the FirstService application using the instructions below and then run your distributed service!\n+\n+### Instrumentation of Receiving Service: FirstService\n+\n+Ensure the main method in FirstServiceApplication is defined. This will be the entry point to the FirstService project. This file should be created by the Spring Boot project initializer.\n+\n+```java\n+@SpringBootApplication\n+public class FirstServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(FirstServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+Create a RestController for FirstService. This controller will send a request to SecondService and then return the response to the client:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpEntity;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+\n+@RestController\n+@RequestMapping(value = \"/message\")\n+public class FirstServiceController {\n+   @Autowired\n+   private Tracer tracer;\n+\t\n+   @Autowired\n+   private RestTemplate restTemplate;\n+\n+   @Autowired\n+   HttpUtils httpUtils;\n+\n+   private static String SECOND_SERVICE_URL = \"http://localhost:8081/time\";\n+\n+   @GetMapping\n+   public String firstTracedMethod() {\n+\n+      ResponseEntity<String> response =\n+            restTemplate.exchange(SECOND_SERVICE_URL, HttpMethod.GET, null, String.class);\n+      String secondServiceTime = response.getBody();\n+\n+      return \"Second Service says: \" + secondServiceTime;\n+\n+   }\n+}\n+```\n+\n+As seen in the setup of SecondService, create implement the TraceInterceptor interface to wrap requests to the SecondServiceController in a span. Then register this new handler by extending the HandlerInterceptor. In effect, we will be taking a copy of the InterceptorConfig.java and ControllerTraceInterceptor.java defined in SecondService and adding it to FirstService. These files are referenced [here](#create-controller-interceptor).\n+\n+#### Create Client Http Request Interceptor\n+\n+Next, we will configure the ClientHttpRequestInterceptor to intercept all client HTTP requests made using RestTemplate.\n+\n+To propagate the span context from FirstService to SecondService we must inject the trace id and trace state into the outgoing request header. In section 1 this was done using the helper class HttpUtils. In this section, we will implement the ClientHttpRequestInterceptor interface and register this interceptor in our application. \n+\n+Include the two classes below to your FirstService project to add this functionality:\n+\n+\n+```java\n+\n+import java.io.IOException;\n+\n+import io.grpc.Context;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpRequest;\n+\n+import org.springframework.http.client.ClientHttpRequestExecution;\n+import org.springframework.http.client.ClientHttpRequestInterceptor;\n+import org.springframework.http.client.ClientHttpResponse;\n+import org.springframework.stereotype.Component;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+\n+@Component\n+public class RestTemplateHeaderModifierInterceptor implements ClientHttpRequestInterceptor {\n+\n+   @Autowired\n+   private Tracer tracer;\n+\n+   private static final HttpTextFormat.Setter<HttpRequest> setter =\n+         new HttpTextFormat.Setter<HttpRequest>() {\n+            @Override\n+            public void set(HttpRequest carrier, String key, String value) {\n+               carrier.getHeaders().set(key, value);\n+            }\n+         };\n+\n+\n+   @Override\n+   public ClientHttpResponse intercept(HttpRequest request, byte[] body,\n+         ClientHttpRequestExecution execution) throws IOException {\n+\n+      Span currentSpan = tracer.getCurrentSpan();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk0MjEzMw=="}, "originalCommit": {"oid": "0b27f2c9a2ce013c6b80118d7e4ca962e720bc27"}, "originalPosition": 402}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NjE1MDE2OnYy", "diffSide": "RIGHT", "path": "instrumentation-core/spring/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMzozNjoyMFrOGnYGew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMzozNjoyMFrOGnYGew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk0MjUyMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  List<ClientHttpRequestInterceptor> interceptors = restTemplate.getInterceptors();\n          \n          \n            \n                  if (interceptors.isEmpty()) {\n          \n          \n            \n                     interceptors = new ArrayList<>();\n          \n          \n            \n                  }\n          \n          \n            \n                  interceptors.add(restTemplateHeaderModifierInterceptor);\n          \n          \n            \n                  restTemplate.setInterceptors(interceptors);\n          \n          \n            \n                  restTemplate.getInterceptors().add(restTemplateHeaderModifierInterceptor);", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r443942523", "createdAt": "2020-06-23T03:36:20Z", "author": {"login": "trask"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -340,6 +341,324 @@ After running Jaeger locally, navigate to the url below. Make sure to refresh th\n \n Run FirstService and SecondService from command line or using an IDE. The end point of interest for FirstService is `http://localhost:8080/message` and  `http://localhost:8081/time` for SecondService. Entering `localhost:8080/message` in a browser should call FirstService and then SecondService, creating a trace. \n \n-***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.secondServiceUrl. ***\n+***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.SECOND_SERVICE_URL. ***\n \n Congrats, we just created a distributed service with OpenTelemetry!\n+\n+## Manual Instrumentation using Handlers and Interceptors\n+\n+In this section, we will implement the Spring HandlerInerceptor interface to wrap all requests to FirstService and Second Service controllers in a span. \n+\n+We will also use the RestTemplate HTTP client to send requests from FirstService to SecondService. To propagate the trace in this request we will also implement the ClientHttpRequestInterceptor interface. This implementation is only required for projects that send outbound requests. In this example it is only required for FirstService. \n+\n+### Setup FirstService and SecondService\n+\n+Using the earlier instructions [create two example projects](#create-two-spring-projects) and add the required [dependencies and configurations](#setup-for-manual-instrumentation). \n+\n+### Instrumentation of Client Service: SecondService\n+\n+Ensure the main method in SecondServiceApplication is defined. This will be the entry point to the SecondService project. This file should be created by the Spring Boot project initializer.\n+\n+```java\n+import java.io.IOException;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+\n+@SpringBootApplication\n+public class SecondServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(SecondServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+Add the RestController below to your SecondService project. This controller will return a string when SecondServiceController.secondTracedMethod is called:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+\n+@RestController\n+@RequestMapping(value = \"/time\")\n+public class SecondServiceController {\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @GetMapping\n+   public String secondTracedMethod() {\n+      return \"It's time to get a watch\";\n+   }\n+}\n+```\n+\n+#### Create Controller Interceptor\n+\n+Add the class below to wrap all requests to the SecondServiceController in a span. This class will call the preHandle method before the RestController is entered and the postHandle method after a response is created. \n+\n+The preHandle method starts a span for each request. The postHandle method closes the span and adds the span context to the response header. This implementation is shown below:    \n+\n+```java\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.servlet.HandlerInterceptor;\n+import org.springframework.web.servlet.ModelAndView;\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n+\n+@Component\n+public class ControllerTraceInterceptor implements HandlerInterceptor {\n+\n+   private static final HttpTextFormat.Getter<HttpServletRequest> getter =\n+         new HttpTextFormat.Getter<HttpServletRequest>() {\n+            public String get(HttpServletRequest req, String key) {\n+               return req.getHeader(key);\n+            }\n+         };\n+\n+   private static final HttpTextFormat.Setter<HttpServletResponse> setter =\n+         new HttpTextFormat.Setter<HttpServletResponse>() {\n+            @Override\n+            public void set(HttpServletResponse response, String key, String value) {\n+               response.addHeader(key, value);\n+            }\n+         };\n+\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @Override\n+   public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n+         throws Exception {\n+      Context context = OpenTelemetry.getPropagators().getHttpTextFormat()\n+          .extract(Context.current(), request, getter);\n+      Span span = createSpanWithParent(request, context);\n+      span.setAttribute(\"handler\", \"pre\");\n+      tracer.withSpan(span);\n+\n+      return true;\n+   }\n+\n+   @Override\n+   public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n+         ModelAndView modelAndView) throws Exception {\n+\n+      Span currentSpan = tracer.getCurrentSpan();\n+      currentSpan.setAttribute(\"handler\", \"post\");\n+      OpenTelemetry.getPropagators().getHttpTextFormat().inject(Context.current(), response, setter);\n+      currentSpan.end();\n+   }\n+\n+   @Override\n+   public void afterCompletion(HttpServletRequest request, HttpServletResponse response,\n+         Object handler, Exception exception) throws Exception {}\n+   \n+   private Span createSpanWithParent(HttpServletRequest request, Context context) {\n+      Span parentSpan = TracingContextUtils.getSpan(context);\n+\n+      if (parentSpan.getContext().isValid()) {\n+         return  tracer.spanBuilder(request.getRequestURI()).setParent(parentSpan).startSpan();\n+      }\n+\n+      Span span = tracer.spanBuilder(request.getRequestURI()).startSpan();\n+      span.addEvent(\"Parent Span Not Found\");\n+\n+      return span;\n+   }\n+}\n+\n+```\n+\n+The final step is to register an instance of the ControllerTraceInterceptor:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.servlet.config.annotation.InterceptorRegistry;\n+import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\n+\n+@Component\n+public class InterceptorConfig extends WebMvcConfigurationSupport {\n+\n+   @Autowired\n+   ControllerTraceInterceptor controllerTraceInterceptor;\n+\n+   @Override\n+   public void addInterceptors(InterceptorRegistry registry) {\n+      registry.addInterceptor(controllerTraceInterceptor);\n+   }\n+}\n+```\n+\n+Now your SecondService application is complete. Create the FirstService application using the instructions below and then run your distributed service!\n+\n+### Instrumentation of Receiving Service: FirstService\n+\n+Ensure the main method in FirstServiceApplication is defined. This will be the entry point to the FirstService project. This file should be created by the Spring Boot project initializer.\n+\n+```java\n+@SpringBootApplication\n+public class FirstServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(FirstServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+Create a RestController for FirstService. This controller will send a request to SecondService and then return the response to the client:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpEntity;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+\n+@RestController\n+@RequestMapping(value = \"/message\")\n+public class FirstServiceController {\n+   @Autowired\n+   private Tracer tracer;\n+\t\n+   @Autowired\n+   private RestTemplate restTemplate;\n+\n+   @Autowired\n+   HttpUtils httpUtils;\n+\n+   private static String SECOND_SERVICE_URL = \"http://localhost:8081/time\";\n+\n+   @GetMapping\n+   public String firstTracedMethod() {\n+\n+      ResponseEntity<String> response =\n+            restTemplate.exchange(SECOND_SERVICE_URL, HttpMethod.GET, null, String.class);\n+      String secondServiceTime = response.getBody();\n+\n+      return \"Second Service says: \" + secondServiceTime;\n+\n+   }\n+}\n+```\n+\n+As seen in the setup of SecondService, create implement the TraceInterceptor interface to wrap requests to the SecondServiceController in a span. Then register this new handler by extending the HandlerInterceptor. In effect, we will be taking a copy of the InterceptorConfig.java and ControllerTraceInterceptor.java defined in SecondService and adding it to FirstService. These files are referenced [here](#create-controller-interceptor).\n+\n+#### Create Client Http Request Interceptor\n+\n+Next, we will configure the ClientHttpRequestInterceptor to intercept all client HTTP requests made using RestTemplate.\n+\n+To propagate the span context from FirstService to SecondService we must inject the trace id and trace state into the outgoing request header. In section 1 this was done using the helper class HttpUtils. In this section, we will implement the ClientHttpRequestInterceptor interface and register this interceptor in our application. \n+\n+Include the two classes below to your FirstService project to add this functionality:\n+\n+\n+```java\n+\n+import java.io.IOException;\n+\n+import io.grpc.Context;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpRequest;\n+\n+import org.springframework.http.client.ClientHttpRequestExecution;\n+import org.springframework.http.client.ClientHttpRequestInterceptor;\n+import org.springframework.http.client.ClientHttpResponse;\n+import org.springframework.stereotype.Component;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+\n+@Component\n+public class RestTemplateHeaderModifierInterceptor implements ClientHttpRequestInterceptor {\n+\n+   @Autowired\n+   private Tracer tracer;\n+\n+   private static final HttpTextFormat.Setter<HttpRequest> setter =\n+         new HttpTextFormat.Setter<HttpRequest>() {\n+            @Override\n+            public void set(HttpRequest carrier, String key, String value) {\n+               carrier.getHeaders().set(key, value);\n+            }\n+         };\n+\n+\n+   @Override\n+   public ClientHttpResponse intercept(HttpRequest request, byte[] body,\n+         ClientHttpRequestExecution execution) throws IOException {\n+\n+      Span currentSpan = tracer.getCurrentSpan();\n+      currentSpan.setAttribute(\"client_http\", \"inject\");\n+      currentSpan.addEvent(\"Request sent to SecondService\");\n+\n+      OpenTelemetry.getPropagators().getHttpTextFormat().inject(Context.current(), request, setter);\n+\n+      ClientHttpResponse response = execution.execute(request, body);\n+\n+      return response;\n+   }\n+}\n+\n+```\n+\n+```java\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.http.client.ClientHttpRequestInterceptor;\n+import org.springframework.web.client.RestTemplate;\n+\n+@Configuration\n+public class RestClientConfig {\n+\n+   @Autowired\n+   RestTemplateHeaderModifierInterceptor restTemplateHeaderModifierInterceptor;\n+\n+   @Bean\n+   public RestTemplate restTemplate() {\n+      RestTemplate restTemplate = new RestTemplate();\n+\n+      List<ClientHttpRequestInterceptor> interceptors = restTemplate.getInterceptors();\n+      if (interceptors.isEmpty()) {\n+         interceptors = new ArrayList<>();\n+      }\n+      interceptors.add(restTemplateHeaderModifierInterceptor);\n+      restTemplate.setInterceptors(interceptors);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b27f2c9a2ce013c6b80118d7e4ca962e720bc27"}, "originalPosition": 441}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MDQzMzE5OnYy", "diffSide": "RIGHT", "path": "instrumentation-core/spring/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwMzo1ODoxOFrOGoCHCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwMzo1ODoxOFrOGoCHCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDYzMDc5Mw==", "bodyText": "also good to set span kind: .setKind(Span.Kind.SERVER)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r444630793", "createdAt": "2020-06-24T03:58:18Z", "author": {"login": "trask"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -340,6 +341,306 @@ After running Jaeger locally, navigate to the url below. Make sure to refresh th\n \n Run FirstService and SecondService from command line or using an IDE. The end point of interest for FirstService is `http://localhost:8080/message` and  `http://localhost:8081/time` for SecondService. Entering `localhost:8080/message` in a browser should call FirstService and then SecondService, creating a trace. \n \n-***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.secondServiceUrl. ***\n+***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.SECOND_SERVICE_URL. ***\n \n Congrats, we just created a distributed service with OpenTelemetry!\n+\n+## Manual Instrumentation using Handlers and Interceptors\n+\n+In this section, we will implement the Spring HandlerInerceptor interface to wrap all requests to FirstService and SecondService controllers in a span. \n+\n+We will also use the RestTemplate HTTP client to send requests from FirstService to SecondService. To propagate the trace in this request we will also implement the ClientHttpRequestInterceptor interface. This implementation is only required for projects that send outbound requests. In this example it is only required for FirstService. \n+\n+### Set up FirstService and SecondService\n+\n+Using the earlier instructions [create two spring projects](#create-two-spring-projects) and add the required [dependencies and configurations](#setup-for-manual-instrumentation). \n+\n+### Instrumentation of Client Service: SecondService\n+\n+Ensure the main method in SecondServiceApplication is defined. This will be the entry point to the SecondService project. This file should be created by the Spring Boot project initializer.\n+\n+```java\n+import java.io.IOException;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+\n+@SpringBootApplication\n+public class SecondServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(SecondServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+Add the REST controller below to your SecondService project. This controller will return a string when SecondServiceController.secondTracedMethod is called:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+@RestController\n+@RequestMapping(value = \"/time\")\n+public class SecondServiceController {\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @GetMapping\n+   public String secondTracedMethod() {\n+      return \"It's time to get a watch\";\n+   }\n+}\n+```\n+\n+#### Create Controller Interceptor\n+\n+Add the class below to wrap all requests to the SecondServiceController in a span. This class will call the preHandle method before the REST controller is entered and the postHandle method after a response is created. \n+\n+The preHandle method starts a span for each request. This implementation is shown below:    \n+\n+```java\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.servlet.HandlerInterceptor;\n+import org.springframework.web.servlet.ModelAndView;\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n+\n+@Component\n+public class ControllerTraceInterceptor implements HandlerInterceptor {\n+\n+   private static final HttpTextFormat.Getter<HttpServletRequest> getter =\n+         new HttpTextFormat.Getter<HttpServletRequest>() {\n+            public String get(HttpServletRequest req, String key) {\n+               return req.getHeader(key);\n+            }\n+         };\n+\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @Override\n+   public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n+         throws Exception {\n+      Context context = OpenTelemetry.getPropagators().getHttpTextFormat()\n+          .extract(Context.current(), request, getter);\n+      Span span = createSpanWithParent(request, context);\n+      span.setAttribute(\"handler\", \"pre\");\n+      tracer.withSpan(span);\n+\n+      return true;\n+   }\n+\n+   @Override\n+   public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n+         ModelAndView modelAndView) throws Exception {\n+\n+      Span currentSpan = tracer.getCurrentSpan();\n+      currentSpan.setAttribute(\"handler\", \"post\");\n+      currentSpan.end();\n+   }\n+\n+   @Override\n+   public void afterCompletion(HttpServletRequest request, HttpServletResponse response,\n+         Object handler, Exception exception) throws Exception {}\n+   \n+   private Span createSpanWithParent(HttpServletRequest request, Context context) {\n+      Span parentSpan = TracingContextUtils.getSpan(context);\n+\n+      if (parentSpan.getContext().isValid()) {\n+         return  tracer.spanBuilder(request.getRequestURI()).setParent(parentSpan).startSpan();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9562c85d762f9163f533bc69ec9f092324d6ef21"}, "originalPosition": 249}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MDQzNjIxOnYy", "diffSide": "RIGHT", "path": "instrumentation-core/spring/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwMzo1OTo1MVrOGoCItg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwMzo1OTo1MVrOGoCItg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDYzMTIyMg==", "bodyText": "same as above: .setKind(Span.Kind.SERVER)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r444631222", "createdAt": "2020-06-24T03:59:51Z", "author": {"login": "trask"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -340,6 +341,306 @@ After running Jaeger locally, navigate to the url below. Make sure to refresh th\n \n Run FirstService and SecondService from command line or using an IDE. The end point of interest for FirstService is `http://localhost:8080/message` and  `http://localhost:8081/time` for SecondService. Entering `localhost:8080/message` in a browser should call FirstService and then SecondService, creating a trace. \n \n-***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.secondServiceUrl. ***\n+***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.SECOND_SERVICE_URL. ***\n \n Congrats, we just created a distributed service with OpenTelemetry!\n+\n+## Manual Instrumentation using Handlers and Interceptors\n+\n+In this section, we will implement the Spring HandlerInerceptor interface to wrap all requests to FirstService and SecondService controllers in a span. \n+\n+We will also use the RestTemplate HTTP client to send requests from FirstService to SecondService. To propagate the trace in this request we will also implement the ClientHttpRequestInterceptor interface. This implementation is only required for projects that send outbound requests. In this example it is only required for FirstService. \n+\n+### Set up FirstService and SecondService\n+\n+Using the earlier instructions [create two spring projects](#create-two-spring-projects) and add the required [dependencies and configurations](#setup-for-manual-instrumentation). \n+\n+### Instrumentation of Client Service: SecondService\n+\n+Ensure the main method in SecondServiceApplication is defined. This will be the entry point to the SecondService project. This file should be created by the Spring Boot project initializer.\n+\n+```java\n+import java.io.IOException;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+\n+@SpringBootApplication\n+public class SecondServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(SecondServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+Add the REST controller below to your SecondService project. This controller will return a string when SecondServiceController.secondTracedMethod is called:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+@RestController\n+@RequestMapping(value = \"/time\")\n+public class SecondServiceController {\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @GetMapping\n+   public String secondTracedMethod() {\n+      return \"It's time to get a watch\";\n+   }\n+}\n+```\n+\n+#### Create Controller Interceptor\n+\n+Add the class below to wrap all requests to the SecondServiceController in a span. This class will call the preHandle method before the REST controller is entered and the postHandle method after a response is created. \n+\n+The preHandle method starts a span for each request. This implementation is shown below:    \n+\n+```java\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.servlet.HandlerInterceptor;\n+import org.springframework.web.servlet.ModelAndView;\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n+\n+@Component\n+public class ControllerTraceInterceptor implements HandlerInterceptor {\n+\n+   private static final HttpTextFormat.Getter<HttpServletRequest> getter =\n+         new HttpTextFormat.Getter<HttpServletRequest>() {\n+            public String get(HttpServletRequest req, String key) {\n+               return req.getHeader(key);\n+            }\n+         };\n+\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @Override\n+   public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n+         throws Exception {\n+      Context context = OpenTelemetry.getPropagators().getHttpTextFormat()\n+          .extract(Context.current(), request, getter);\n+      Span span = createSpanWithParent(request, context);\n+      span.setAttribute(\"handler\", \"pre\");\n+      tracer.withSpan(span);\n+\n+      return true;\n+   }\n+\n+   @Override\n+   public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n+         ModelAndView modelAndView) throws Exception {\n+\n+      Span currentSpan = tracer.getCurrentSpan();\n+      currentSpan.setAttribute(\"handler\", \"post\");\n+      currentSpan.end();\n+   }\n+\n+   @Override\n+   public void afterCompletion(HttpServletRequest request, HttpServletResponse response,\n+         Object handler, Exception exception) throws Exception {}\n+   \n+   private Span createSpanWithParent(HttpServletRequest request, Context context) {\n+      Span parentSpan = TracingContextUtils.getSpan(context);\n+\n+      if (parentSpan.getContext().isValid()) {\n+         return  tracer.spanBuilder(request.getRequestURI()).setParent(parentSpan).startSpan();\n+      }\n+\n+      Span span = tracer.spanBuilder(request.getRequestURI()).startSpan();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9562c85d762f9163f533bc69ec9f092324d6ef21"}, "originalPosition": 252}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MzE3NjgzOnYy", "diffSide": "RIGHT", "path": "instrumentation-core/spring/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNzo1ODo0MFrOGodGpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwNDo1MTo0MlrOGorSQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA3MzA2Mw==", "bodyText": "Context.current() here is going to refer to the parent span, b/c you haven't put currentSpan into scope, e.g. using tracer.withSpan(currentSpan)\nthe problem with this, is that then downstream server span will not have the correct parent", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r445073063", "createdAt": "2020-06-24T17:58:40Z", "author": {"login": "trask"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -593,16 +594,19 @@ public class RestTemplateHeaderModifierInterceptor implements ClientHttpRequestI\n    @Override\n    public ClientHttpResponse intercept(HttpRequest request, byte[] body,\n          ClientHttpRequestExecution execution) throws IOException {\n-\n-      Span currentSpan = tracer.getCurrentSpan();\n-      currentSpan.setAttribute(\"client_http\", \"inject\");\n-      currentSpan.addEvent(\"Request sent to SecondService\");\n-\n-      OpenTelemetry.getPropagators().getHttpTextFormat().inject(Context.current(), request, setter);\n-\n-      ClientHttpResponse response = execution.execute(request, body);\n-\n-      return response;\n+      \n+      String spanName = request.getMethodValue() +  \" \" + request.getURI().toString();\n+      Span currentSpan = tracer.spanBuilder(spanName).setSpanKind(Span.Kind.CLIENT).startSpan();\n+      \n+      try {\n+        OpenTelemetry.getPropagators().getHttpTextFormat().inject(Context.current(), request, setter);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f8254e9e6acffc6ad5fbb6617471d13471d6f1c"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMwNTQwOQ==", "bodyText": "I added tracer.withSpan(currentSpan) to the try block", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r445305409", "createdAt": "2020-06-25T04:51:42Z", "author": {"login": "mabdinur"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -593,16 +594,19 @@ public class RestTemplateHeaderModifierInterceptor implements ClientHttpRequestI\n    @Override\n    public ClientHttpResponse intercept(HttpRequest request, byte[] body,\n          ClientHttpRequestExecution execution) throws IOException {\n-\n-      Span currentSpan = tracer.getCurrentSpan();\n-      currentSpan.setAttribute(\"client_http\", \"inject\");\n-      currentSpan.addEvent(\"Request sent to SecondService\");\n-\n-      OpenTelemetry.getPropagators().getHttpTextFormat().inject(Context.current(), request, setter);\n-\n-      ClientHttpResponse response = execution.execute(request, body);\n-\n-      return response;\n+      \n+      String spanName = request.getMethodValue() +  \" \" + request.getURI().toString();\n+      Span currentSpan = tracer.spanBuilder(spanName).setSpanKind(Span.Kind.CLIENT).startSpan();\n+      \n+      try {\n+        OpenTelemetry.getPropagators().getHttpTextFormat().inject(Context.current(), request, setter);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA3MzA2Mw=="}, "originalCommit": {"oid": "6f8254e9e6acffc6ad5fbb6617471d13471d6f1c"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3ODAzMjk0OnYy", "diffSide": "RIGHT", "path": "instrumentation-core/spring/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQyMTo0MDo0NVrOGpMyfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQyMTo0MDo0NVrOGpMyfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTg1NDMzNQ==", "bodyText": "need to close the scope, e.g.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  try {\n          \n          \n            \n                     tracer.withSpan(currentSpan);\n          \n          \n            \n                  try (Scope scope = tracer.withSpan(currentSpan)) {", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r445854335", "createdAt": "2020-06-25T21:40:45Z", "author": {"login": "trask"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -340,6 +341,274 @@ After running Jaeger locally, navigate to the url below. Make sure to refresh th\n \n Run FirstService and SecondService from command line or using an IDE. The end point of interest for FirstService is `http://localhost:8080/message` and  `http://localhost:8081/time` for SecondService. Entering `localhost:8080/message` in a browser should call FirstService and then SecondService, creating a trace. \n \n-***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.secondServiceUrl. ***\n+***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.SECOND_SERVICE_URL. ***\n \n Congrats, we just created a distributed service with OpenTelemetry!\n+\n+## Manual Instrumentation using Handlers and Filters\n+\n+In this section, we will implement the javax Serverlet Filter interface to wrap all requests to FirstService and SecondService controllers in a span. \n+\n+We will also use the RestTemplate HTTP client to send requests from FirstService to SecondService. To propagate the trace in this request we will also implement the ClientHttpRequestInterceptor interface. This implementation is only required for projects that send outbound requests. In this example it is only required for FirstService. \n+\n+### Set up FirstService and SecondService\n+\n+Using the earlier instructions [create two spring projects](#create-two-spring-projects) and add the required [dependencies and configurations](#setup-for-manual-instrumentation). \n+\n+### Instrumentation of Client Service: SecondService\n+\n+Ensure the main method in SecondServiceApplication is defined. This will be the entry point to the SecondService project. This file should be created by the Spring Boot project initializer.\n+\n+```java\n+import java.io.IOException;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+\n+@SpringBootApplication\n+public class SecondServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(SecondServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+Add the REST controller below to your SecondService project. This controller will return a string when SecondServiceController.secondTracedMethod is called:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+@RestController\n+@RequestMapping(value = \"/time\")\n+public class SecondServiceController {\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @GetMapping\n+   public String secondTracedMethod() {\n+      return \"It's time to get a watch\";\n+   }\n+}\n+```\n+\n+#### Create Controller Filter\n+\n+Add the class below to wrap all requests to the SecondServiceController in a span. This class will call the preHandle method before the REST controller is entered and the postHandle method after a response is created. \n+\n+The preHandle method starts a span for each request. This implementation is shown below:    \n+\n+```java\n+\n+@Component\n+public class ControllerFilter implements Filter {\n+  \n+  @Autowired\n+  Tracer tracer;\n+  \n+  private final Logger LOG = Logger.getLogger(ControllerFilter.class.getName());\n+\n+  private final HttpTextFormat.Getter<HttpServletRequest> GETTER =\n+      new HttpTextFormat.Getter<HttpServletRequest>() {\n+        public String get(HttpServletRequest req, String key) {\n+          return req.getHeader(key);\n+        }\n+      };\n+\n+  @Override\n+  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n+      throws IOException, ServletException {\n+    LOG.info(\"start doFilter\");\n+    \n+    HttpServletRequest req = (HttpServletRequest) request;\n+    Context context = OpenTelemetry.getPropagators().getHttpTextFormat()\n+        .extract(Context.current(), req, GETTER);\n+    Span currentSpan = createSpanWithParent(req, context);\n+    try {\n+      tracer.withSpan(currentSpan);\n+      currentSpan.addEvent(\"dofilter\");\n+      chain.doFilter(req, response);\n+    }finally {\n+      LOG.info(\"end doFilter\");\n+      currentSpan.end();\n+    }\n+    \n+  }\n+  \n+  private Span createSpanWithParent(HttpServletRequest request, Context context) {\n+    Span parentSpan = TracingContextUtils.getSpan(context);\n+    Span.Builder spanBuilder = tracer.spanBuilder(request.getRequestURI()).setSpanKind(Span.Kind.SERVER);\n+    \n+    if (parentSpan.getContext().isValid()) {\n+      return spanBuilder.setParent(parentSpan).startSpan();\n+    }\n+\n+    Span span = spanBuilder.startSpan();\n+    span.addEvent(\"Parent Span Not Found\");\n+\n+    return span;\n+  }\n+}\n+}\n+\n+```\n+\n+Now your SecondService application is complete. Create the FirstService application using the instructions below and then run your distributed service!\n+\n+### Instrumentation of Receiving Service: FirstService\n+\n+Ensure the main method in FirstServiceApplication is defined. This will be the entry point to the FirstService project. This file should be created by the Spring Boot project initializer.\n+\n+```java\n+@SpringBootApplication\n+public class FirstServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(FirstServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+Create a REST controller for FirstService. This controller will send a request to SecondService and then return the response to the client:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpEntity;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+\n+@RestController\n+@RequestMapping(value = \"/message\")\n+public class FirstServiceController {\n+   @Autowired\n+   private Tracer tracer;\n+\t\n+   @Autowired\n+   private RestTemplate restTemplate;\n+\n+   @Autowired\n+   private HttpUtils httpUtils;\n+\n+   private static final String SECOND_SERVICE_URL = \"http://localhost:8081/time\";\n+\n+   @GetMapping\n+   public String firstTracedMethod() {\n+\n+      ResponseEntity<String> response =\n+            restTemplate.exchange(SECOND_SERVICE_URL, HttpMethod.GET, null, String.class);\n+      String secondServiceTime = response.getBody();\n+\n+      return \"Second Service says: \" + secondServiceTime;\n+\n+   }\n+}\n+```\n+\n+As seen in the setup of SecondService, implement the javax serverlet filter interface to wrap requests to the SecondServiceController in a span. In effect, we will be taking a copy of the [ControllerFilter.java](#create-controller-filter) file defined in SecondService and adding it to FirstService.\n+\n+#### Create Client Http Request Interceptor\n+\n+Next, we will configure the ClientHttpRequestInterceptor to intercept all client HTTP requests made using RestTemplate.\n+\n+To propagate the span context from FirstService to SecondService we must inject the trace parent and trace state into the outgoing request header. In section 1 this was done using the helper class HttpUtils. In this section, we will implement the ClientHttpRequestInterceptor interface and register this interceptor in our application. \n+\n+Include the two classes below to your FirstService project to add this functionality:\n+\n+\n+```java\n+\n+import java.io.IOException;\n+\n+import io.grpc.Context;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpRequest;\n+\n+import org.springframework.http.client.ClientHttpRequestExecution;\n+import org.springframework.http.client.ClientHttpRequestInterceptor;\n+import org.springframework.http.client.ClientHttpResponse;\n+import org.springframework.stereotype.Component;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+\n+@Component\n+public class RestTemplateInterceptor implements ClientHttpRequestInterceptor {\n+\n+   @Autowired\n+   private Tracer tracer;\n+\n+   private static final HttpTextFormat.Setter<HttpRequest> setter =\n+         new HttpTextFormat.Setter<HttpRequest>() {\n+            @Override\n+            public void set(HttpRequest carrier, String key, String value) {\n+               carrier.getHeaders().set(key, value);\n+            }\n+         };\n+\n+\n+   @Override\n+   public ClientHttpResponse intercept(HttpRequest request, byte[] body,\n+         ClientHttpRequestExecution execution) throws IOException {\n+      \n+      String spanName = request.getMethodValue() +  \" \" + request.getURI().toString();\n+      Span currentSpan = tracer.spanBuilder(spanName).setSpanKind(Span.Kind.CLIENT).startSpan();\n+      \n+      try {\n+         tracer.withSpan(currentSpan);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3e906fbc09444ecacceb3e8d61397fb98690d67"}, "originalPosition": 352}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3ODAzNDcxOnYy", "diffSide": "RIGHT", "path": "instrumentation-core/spring/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQyMTo0MToyMlrOGpMznA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQyMTo0MToyMlrOGpMznA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTg1NDYyMA==", "bodyText": "need to close the scope, e.g.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                try {\n          \n          \n            \n                  tracer.withSpan(currentSpan);\n          \n          \n            \n                  try (Scope scope = tracer.withSpan(currentSpan)) {", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r445854620", "createdAt": "2020-06-25T21:41:22Z", "author": {"login": "trask"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -340,6 +341,274 @@ After running Jaeger locally, navigate to the url below. Make sure to refresh th\n \n Run FirstService and SecondService from command line or using an IDE. The end point of interest for FirstService is `http://localhost:8080/message` and  `http://localhost:8081/time` for SecondService. Entering `localhost:8080/message` in a browser should call FirstService and then SecondService, creating a trace. \n \n-***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.secondServiceUrl. ***\n+***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.SECOND_SERVICE_URL. ***\n \n Congrats, we just created a distributed service with OpenTelemetry!\n+\n+## Manual Instrumentation using Handlers and Filters\n+\n+In this section, we will implement the javax Serverlet Filter interface to wrap all requests to FirstService and SecondService controllers in a span. \n+\n+We will also use the RestTemplate HTTP client to send requests from FirstService to SecondService. To propagate the trace in this request we will also implement the ClientHttpRequestInterceptor interface. This implementation is only required for projects that send outbound requests. In this example it is only required for FirstService. \n+\n+### Set up FirstService and SecondService\n+\n+Using the earlier instructions [create two spring projects](#create-two-spring-projects) and add the required [dependencies and configurations](#setup-for-manual-instrumentation). \n+\n+### Instrumentation of Client Service: SecondService\n+\n+Ensure the main method in SecondServiceApplication is defined. This will be the entry point to the SecondService project. This file should be created by the Spring Boot project initializer.\n+\n+```java\n+import java.io.IOException;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+\n+@SpringBootApplication\n+public class SecondServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(SecondServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+Add the REST controller below to your SecondService project. This controller will return a string when SecondServiceController.secondTracedMethod is called:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+@RestController\n+@RequestMapping(value = \"/time\")\n+public class SecondServiceController {\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @GetMapping\n+   public String secondTracedMethod() {\n+      return \"It's time to get a watch\";\n+   }\n+}\n+```\n+\n+#### Create Controller Filter\n+\n+Add the class below to wrap all requests to the SecondServiceController in a span. This class will call the preHandle method before the REST controller is entered and the postHandle method after a response is created. \n+\n+The preHandle method starts a span for each request. This implementation is shown below:    \n+\n+```java\n+\n+@Component\n+public class ControllerFilter implements Filter {\n+  \n+  @Autowired\n+  Tracer tracer;\n+  \n+  private final Logger LOG = Logger.getLogger(ControllerFilter.class.getName());\n+\n+  private final HttpTextFormat.Getter<HttpServletRequest> GETTER =\n+      new HttpTextFormat.Getter<HttpServletRequest>() {\n+        public String get(HttpServletRequest req, String key) {\n+          return req.getHeader(key);\n+        }\n+      };\n+\n+  @Override\n+  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n+      throws IOException, ServletException {\n+    LOG.info(\"start doFilter\");\n+    \n+    HttpServletRequest req = (HttpServletRequest) request;\n+    Context context = OpenTelemetry.getPropagators().getHttpTextFormat()\n+        .extract(Context.current(), req, GETTER);\n+    Span currentSpan = createSpanWithParent(req, context);\n+    try {\n+      tracer.withSpan(currentSpan);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3e906fbc09444ecacceb3e8d61397fb98690d67"}, "originalPosition": 218}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3ODAzNzk5OnYy", "diffSide": "RIGHT", "path": "instrumentation-core/spring/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQyMTo0Mjo0MFrOGpM1nQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQyMTo0Mjo0MFrOGpM1nQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTg1NTEzMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In this section, we will implement the javax Serverlet Filter interface to wrap all requests to FirstService and SecondService controllers in a span. \n          \n          \n            \n            In this section, we will implement the javax Servlet Filter interface to wrap all requests to FirstService and SecondService controllers in a span.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r445855133", "createdAt": "2020-06-25T21:42:40Z", "author": {"login": "trask"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -345,9 +345,9 @@ Run FirstService and SecondService from command line or using an IDE. The end po\n \n Congrats, we just created a distributed service with OpenTelemetry!\n \n-## Manual Instrumentation using Handlers and Interceptors\n+## Manual Instrumentation using Handlers and Filters\n \n-In this section, we will implement the Spring HandlerInerceptor interface to wrap all requests to FirstService and SecondService controllers in a span. \n+In this section, we will implement the javax Serverlet Filter interface to wrap all requests to FirstService and SecondService controllers in a span. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa8f9191e698243ef4dc83cedc6f4248f708a18a"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3ODA0MjcyOnYy", "diffSide": "RIGHT", "path": "instrumentation-core/spring/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQyMTo0NDoyNlrOGpM4hQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNDo0MDoxOFrOGqUI7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTg1NTg3Nw==", "bodyText": "is this extra }, or maybe indentation issue?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r445855877", "createdAt": "2020-06-25T21:44:26Z", "author": {"login": "trask"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -395,102 +395,65 @@ public class SecondServiceController {\n }\n ```\n \n-#### Create Controller Interceptor\n+#### Create Controller Filter\n \n Add the class below to wrap all requests to the SecondServiceController in a span. This class will call the preHandle method before the REST controller is entered and the postHandle method after a response is created. \n \n The preHandle method starts a span for each request. This implementation is shown below:    \n \n ```java\n \n-import javax.servlet.http.HttpServletRequest;\n-import javax.servlet.http.HttpServletResponse;\n-\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Component;\n-import org.springframework.web.servlet.HandlerInterceptor;\n-import org.springframework.web.servlet.ModelAndView;\n-import io.grpc.Context;\n-import io.opentelemetry.OpenTelemetry;\n-import io.opentelemetry.context.propagation.HttpTextFormat;\n-import io.opentelemetry.trace.Span;\n-import io.opentelemetry.trace.Tracer;\n-import io.opentelemetry.trace.TracingContextUtils;\n-\n @Component\n-public class ControllerTraceInterceptor implements HandlerInterceptor {\n-\n-   private static final HttpTextFormat.Getter<HttpServletRequest> getter =\n-         new HttpTextFormat.Getter<HttpServletRequest>() {\n-            public String get(HttpServletRequest req, String key) {\n-               return req.getHeader(key);\n-            }\n-         };\n-\n-   @Autowired\n-   private Tracer tracer;\n-\n-   @Override\n-   public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n-         throws Exception {\n-      Context context = OpenTelemetry.getPropagators().getHttpTextFormat()\n-          .extract(Context.current(), request, getter);\n-      Span span = createSpanWithParent(request, context);\n-      span.addEvent(\"controller handler pre\");\n-      tracer.withSpan(span);\n-\n-      return true;\n-   }\n+public class ControllerFilter implements Filter {\n+  \n+  @Autowired\n+  Tracer tracer;\n+  \n+  private final Logger LOG = Logger.getLogger(ControllerFilter.class.getName());\n \n-   @Override\n-   public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n-         ModelAndView modelAndView) throws Exception {}\n+  private final HttpTextFormat.Getter<HttpServletRequest> GETTER =\n+      new HttpTextFormat.Getter<HttpServletRequest>() {\n+        public String get(HttpServletRequest req, String key) {\n+          return req.getHeader(key);\n+        }\n+      };\n \n-   @Override\n-   public void afterCompletion(HttpServletRequest request, HttpServletResponse response,\n-         Object handler, Exception exception) throws Exception {\n-     \n-      Span currentSpan = tracer.getCurrentSpan();\n-      currentSpan.addEvent(\"controller post\");\n+  @Override\n+  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n+      throws IOException, ServletException {\n+    LOG.info(\"start doFilter\");\n+    \n+    HttpServletRequest req = (HttpServletRequest) request;\n+    Context context = OpenTelemetry.getPropagators().getHttpTextFormat()\n+        .extract(Context.current(), req, GETTER);\n+    Span currentSpan = createSpanWithParent(req, context);\n+    try {\n+      tracer.withSpan(currentSpan);\n+      currentSpan.addEvent(\"dofilter\");\n+      chain.doFilter(req, response);\n+    }finally {\n+      LOG.info(\"end doFilter\");\n       currentSpan.end();\n-   }\n-   \n-   private Span createSpanWithParent(HttpServletRequest request, Context context) {\n-      Span parentSpan = TracingContextUtils.getSpan(context);\n-      Span.Builder spanBuilder = tracer.spanBuilder(request.getRequestURI()).setSpanKind(Span.Kind.SERVER);\n-      \n-      if (parentSpan.getContext().isValid()) {\n-        return spanBuilder.setParent(parentSpan).startSpan();\n-      }\n+    }\n+    \n+  }\n   \n-      Span span = spanBuilder.startSpan();\n-      span.addEvent(\"Parent Span Not Found\");\n-\n-      return span;\n+  private Span createSpanWithParent(HttpServletRequest request, Context context) {\n+    Span parentSpan = TracingContextUtils.getSpan(context);\n+    Span.Builder spanBuilder = tracer.spanBuilder(request.getRequestURI()).setSpanKind(Span.Kind.SERVER);\n+    \n+    if (parentSpan.getContext().isValid()) {\n+      return spanBuilder.setParent(parentSpan).startSpan();\n     }\n-}\n-\n-```\n-\n-The final step is to register an instance of the ControllerTraceInterceptor:\n \n-```java\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Component;\n-import org.springframework.web.servlet.config.annotation.InterceptorRegistry;\n-import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\n+    Span span = spanBuilder.startSpan();\n+    span.addEvent(\"Parent Span Not Found\");\n \n-@Component\n-public class InterceptorConfig extends WebMvcConfigurationSupport {\n-\n-   @Autowired\n-   ControllerTraceInterceptor controllerTraceInterceptor;\n-\n-   @Override\n-   public void addInterceptors(InterceptorRegistry registry) {\n-      registry.addInterceptor(controllerTraceInterceptor);\n-   }\n+    return span;\n+  }\n }\n+}\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa8f9191e698243ef4dc83cedc6f4248f708a18a"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAyMzM0MQ==", "bodyText": "Good catch. It's an extra bracket. I removed it", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r447023341", "createdAt": "2020-06-29T14:40:18Z", "author": {"login": "mabdinur"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -395,102 +395,65 @@ public class SecondServiceController {\n }\n ```\n \n-#### Create Controller Interceptor\n+#### Create Controller Filter\n \n Add the class below to wrap all requests to the SecondServiceController in a span. This class will call the preHandle method before the REST controller is entered and the postHandle method after a response is created. \n \n The preHandle method starts a span for each request. This implementation is shown below:    \n \n ```java\n \n-import javax.servlet.http.HttpServletRequest;\n-import javax.servlet.http.HttpServletResponse;\n-\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Component;\n-import org.springframework.web.servlet.HandlerInterceptor;\n-import org.springframework.web.servlet.ModelAndView;\n-import io.grpc.Context;\n-import io.opentelemetry.OpenTelemetry;\n-import io.opentelemetry.context.propagation.HttpTextFormat;\n-import io.opentelemetry.trace.Span;\n-import io.opentelemetry.trace.Tracer;\n-import io.opentelemetry.trace.TracingContextUtils;\n-\n @Component\n-public class ControllerTraceInterceptor implements HandlerInterceptor {\n-\n-   private static final HttpTextFormat.Getter<HttpServletRequest> getter =\n-         new HttpTextFormat.Getter<HttpServletRequest>() {\n-            public String get(HttpServletRequest req, String key) {\n-               return req.getHeader(key);\n-            }\n-         };\n-\n-   @Autowired\n-   private Tracer tracer;\n-\n-   @Override\n-   public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n-         throws Exception {\n-      Context context = OpenTelemetry.getPropagators().getHttpTextFormat()\n-          .extract(Context.current(), request, getter);\n-      Span span = createSpanWithParent(request, context);\n-      span.addEvent(\"controller handler pre\");\n-      tracer.withSpan(span);\n-\n-      return true;\n-   }\n+public class ControllerFilter implements Filter {\n+  \n+  @Autowired\n+  Tracer tracer;\n+  \n+  private final Logger LOG = Logger.getLogger(ControllerFilter.class.getName());\n \n-   @Override\n-   public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n-         ModelAndView modelAndView) throws Exception {}\n+  private final HttpTextFormat.Getter<HttpServletRequest> GETTER =\n+      new HttpTextFormat.Getter<HttpServletRequest>() {\n+        public String get(HttpServletRequest req, String key) {\n+          return req.getHeader(key);\n+        }\n+      };\n \n-   @Override\n-   public void afterCompletion(HttpServletRequest request, HttpServletResponse response,\n-         Object handler, Exception exception) throws Exception {\n-     \n-      Span currentSpan = tracer.getCurrentSpan();\n-      currentSpan.addEvent(\"controller post\");\n+  @Override\n+  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n+      throws IOException, ServletException {\n+    LOG.info(\"start doFilter\");\n+    \n+    HttpServletRequest req = (HttpServletRequest) request;\n+    Context context = OpenTelemetry.getPropagators().getHttpTextFormat()\n+        .extract(Context.current(), req, GETTER);\n+    Span currentSpan = createSpanWithParent(req, context);\n+    try {\n+      tracer.withSpan(currentSpan);\n+      currentSpan.addEvent(\"dofilter\");\n+      chain.doFilter(req, response);\n+    }finally {\n+      LOG.info(\"end doFilter\");\n       currentSpan.end();\n-   }\n-   \n-   private Span createSpanWithParent(HttpServletRequest request, Context context) {\n-      Span parentSpan = TracingContextUtils.getSpan(context);\n-      Span.Builder spanBuilder = tracer.spanBuilder(request.getRequestURI()).setSpanKind(Span.Kind.SERVER);\n-      \n-      if (parentSpan.getContext().isValid()) {\n-        return spanBuilder.setParent(parentSpan).startSpan();\n-      }\n+    }\n+    \n+  }\n   \n-      Span span = spanBuilder.startSpan();\n-      span.addEvent(\"Parent Span Not Found\");\n-\n-      return span;\n+  private Span createSpanWithParent(HttpServletRequest request, Context context) {\n+    Span parentSpan = TracingContextUtils.getSpan(context);\n+    Span.Builder spanBuilder = tracer.spanBuilder(request.getRequestURI()).setSpanKind(Span.Kind.SERVER);\n+    \n+    if (parentSpan.getContext().isValid()) {\n+      return spanBuilder.setParent(parentSpan).startSpan();\n     }\n-}\n-\n-```\n-\n-The final step is to register an instance of the ControllerTraceInterceptor:\n \n-```java\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Component;\n-import org.springframework.web.servlet.config.annotation.InterceptorRegistry;\n-import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\n+    Span span = spanBuilder.startSpan();\n+    span.addEvent(\"Parent Span Not Found\");\n \n-@Component\n-public class InterceptorConfig extends WebMvcConfigurationSupport {\n-\n-   @Autowired\n-   ControllerTraceInterceptor controllerTraceInterceptor;\n-\n-   @Override\n-   public void addInterceptors(InterceptorRegistry registry) {\n-      registry.addInterceptor(controllerTraceInterceptor);\n-   }\n+    return span;\n+  }\n }\n+}\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTg1NTg3Nw=="}, "originalCommit": {"oid": "fa8f9191e698243ef4dc83cedc6f4248f708a18a"}, "originalPosition": 163}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3ODA0MzMwOnYy", "diffSide": "RIGHT", "path": "instrumentation-core/spring/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQyMTo0NDozOFrOGpM43A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQyMTo0NDozOFrOGpM43A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTg1NTk2NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            As seen in the setup of SecondService, implement the javax serverlet filter interface to wrap requests to the SecondServiceController in a span. In effect, we will be taking a copy of the [ControllerFilter.java](#create-controller-filter) file defined in SecondService and adding it to FirstService.\n          \n          \n            \n            As seen in the setup of SecondService, implement the javax servlet filter interface to wrap requests to the SecondServiceController in a span. In effect, we will be taking a copy of the [ControllerFilter.java](#create-controller-filter) file defined in SecondService and adding it to FirstService.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r445855964", "createdAt": "2020-06-25T21:44:38Z", "author": {"login": "trask"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -548,7 +511,7 @@ public class FirstServiceController {\n }\n ```\n \n-As seen in the setup of SecondService, implement the TraceInterceptor interface to wrap requests to the SecondServiceController in a span. Then register this new handler by extending the HandlerInterceptor. In effect, we will be taking a copy of the InterceptorConfig.java and ControllerTraceInterceptor.java defined in SecondService and adding it to FirstService. These files are referenced [here](#create-controller-interceptor).\n+As seen in the setup of SecondService, implement the javax serverlet filter interface to wrap requests to the SecondServiceController in a span. In effect, we will be taking a copy of the [ControllerFilter.java](#create-controller-filter) file defined in SecondService and adding it to FirstService.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa8f9191e698243ef4dc83cedc6f4248f708a18a"}, "originalPosition": 172}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3ODA1MjE3OnYy", "diffSide": "RIGHT", "path": "instrumentation-core/spring/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQyMTo0NzozOFrOGpM-MQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQyMTo0NzozOFrOGpM-MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTg1NzMyOQ==", "bodyText": "since this is example, maybe better to stick with canonical usage, e.g.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Span parentSpan = TracingContextUtils.getSpan(context);\n          \n          \n            \n                Span.Builder spanBuilder = tracer.spanBuilder(request.getRequestURI()).setSpanKind(Span.Kind.SERVER);\n          \n          \n            \n                \n          \n          \n            \n                if (parentSpan.getContext().isValid()) {\n          \n          \n            \n                  return spanBuilder.setParent(parentSpan).startSpan();\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                Span span = spanBuilder.startSpan();\n          \n          \n            \n                span.addEvent(\"Parent Span Not Found\");\n          \n          \n            \n            \n          \n          \n            \n                return span;\n          \n          \n            \n                return tracer.spanBuilder(request.getRequestURI()).setSpanKind(Span.Kind.SERVER).startSpan();", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r445857329", "createdAt": "2020-06-25T21:47:38Z", "author": {"login": "trask"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -340,6 +341,274 @@ After running Jaeger locally, navigate to the url below. Make sure to refresh th\n \n Run FirstService and SecondService from command line or using an IDE. The end point of interest for FirstService is `http://localhost:8080/message` and  `http://localhost:8081/time` for SecondService. Entering `localhost:8080/message` in a browser should call FirstService and then SecondService, creating a trace. \n \n-***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.secondServiceUrl. ***\n+***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.SECOND_SERVICE_URL. ***\n \n Congrats, we just created a distributed service with OpenTelemetry!\n+\n+## Manual Instrumentation using Handlers and Filters\n+\n+In this section, we will implement the javax Serverlet Filter interface to wrap all requests to FirstService and SecondService controllers in a span. \n+\n+We will also use the RestTemplate HTTP client to send requests from FirstService to SecondService. To propagate the trace in this request we will also implement the ClientHttpRequestInterceptor interface. This implementation is only required for projects that send outbound requests. In this example it is only required for FirstService. \n+\n+### Set up FirstService and SecondService\n+\n+Using the earlier instructions [create two spring projects](#create-two-spring-projects) and add the required [dependencies and configurations](#setup-for-manual-instrumentation). \n+\n+### Instrumentation of Client Service: SecondService\n+\n+Ensure the main method in SecondServiceApplication is defined. This will be the entry point to the SecondService project. This file should be created by the Spring Boot project initializer.\n+\n+```java\n+import java.io.IOException;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+\n+@SpringBootApplication\n+public class SecondServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(SecondServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+Add the REST controller below to your SecondService project. This controller will return a string when SecondServiceController.secondTracedMethod is called:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+@RestController\n+@RequestMapping(value = \"/time\")\n+public class SecondServiceController {\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @GetMapping\n+   public String secondTracedMethod() {\n+      return \"It's time to get a watch\";\n+   }\n+}\n+```\n+\n+#### Create Controller Filter\n+\n+Add the class below to wrap all requests to the SecondServiceController in a span. This class will call the preHandle method before the REST controller is entered and the postHandle method after a response is created. \n+\n+The preHandle method starts a span for each request. This implementation is shown below:    \n+\n+```java\n+\n+@Component\n+public class ControllerFilter implements Filter {\n+  \n+  @Autowired\n+  Tracer tracer;\n+  \n+  private final Logger LOG = Logger.getLogger(ControllerFilter.class.getName());\n+\n+  private final HttpTextFormat.Getter<HttpServletRequest> GETTER =\n+      new HttpTextFormat.Getter<HttpServletRequest>() {\n+        public String get(HttpServletRequest req, String key) {\n+          return req.getHeader(key);\n+        }\n+      };\n+\n+  @Override\n+  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n+      throws IOException, ServletException {\n+    LOG.info(\"start doFilter\");\n+    \n+    HttpServletRequest req = (HttpServletRequest) request;\n+    Context context = OpenTelemetry.getPropagators().getHttpTextFormat()\n+        .extract(Context.current(), req, GETTER);\n+    Span currentSpan = createSpanWithParent(req, context);\n+    try {\n+      tracer.withSpan(currentSpan);\n+      currentSpan.addEvent(\"dofilter\");\n+      chain.doFilter(req, response);\n+    }finally {\n+      LOG.info(\"end doFilter\");\n+      currentSpan.end();\n+    }\n+    \n+  }\n+  \n+  private Span createSpanWithParent(HttpServletRequest request, Context context) {\n+    Span parentSpan = TracingContextUtils.getSpan(context);\n+    Span.Builder spanBuilder = tracer.spanBuilder(request.getRequestURI()).setSpanKind(Span.Kind.SERVER);\n+    \n+    if (parentSpan.getContext().isValid()) {\n+      return spanBuilder.setParent(parentSpan).startSpan();\n+    }\n+\n+    Span span = spanBuilder.startSpan();\n+    span.addEvent(\"Parent Span Not Found\");\n+\n+    return span;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3e906fbc09444ecacceb3e8d61397fb98690d67"}, "originalPosition": 239}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3ODA1ODM5OnYy", "diffSide": "RIGHT", "path": "instrumentation-core/spring/README.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQyMTo0OTo1MFrOGpNCCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQyMTo0OTo1MFrOGpNCCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTg1ODMxNQ==", "bodyText": "and then common for static fields to be at top of class\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private final HttpTextFormat.Getter<HttpServletRequest> GETTER =\n          \n          \n            \n              private static final HttpTextFormat.Getter<HttpServletRequest> GETTER =", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r445858315", "createdAt": "2020-06-25T21:49:50Z", "author": {"login": "trask"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -340,6 +341,274 @@ After running Jaeger locally, navigate to the url below. Make sure to refresh th\n \n Run FirstService and SecondService from command line or using an IDE. The end point of interest for FirstService is `http://localhost:8080/message` and  `http://localhost:8081/time` for SecondService. Entering `localhost:8080/message` in a browser should call FirstService and then SecondService, creating a trace. \n \n-***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.secondServiceUrl. ***\n+***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.SECOND_SERVICE_URL. ***\n \n Congrats, we just created a distributed service with OpenTelemetry!\n+\n+## Manual Instrumentation using Handlers and Filters\n+\n+In this section, we will implement the javax Serverlet Filter interface to wrap all requests to FirstService and SecondService controllers in a span. \n+\n+We will also use the RestTemplate HTTP client to send requests from FirstService to SecondService. To propagate the trace in this request we will also implement the ClientHttpRequestInterceptor interface. This implementation is only required for projects that send outbound requests. In this example it is only required for FirstService. \n+\n+### Set up FirstService and SecondService\n+\n+Using the earlier instructions [create two spring projects](#create-two-spring-projects) and add the required [dependencies and configurations](#setup-for-manual-instrumentation). \n+\n+### Instrumentation of Client Service: SecondService\n+\n+Ensure the main method in SecondServiceApplication is defined. This will be the entry point to the SecondService project. This file should be created by the Spring Boot project initializer.\n+\n+```java\n+import java.io.IOException;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+\n+@SpringBootApplication\n+public class SecondServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(SecondServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+Add the REST controller below to your SecondService project. This controller will return a string when SecondServiceController.secondTracedMethod is called:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+@RestController\n+@RequestMapping(value = \"/time\")\n+public class SecondServiceController {\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @GetMapping\n+   public String secondTracedMethod() {\n+      return \"It's time to get a watch\";\n+   }\n+}\n+```\n+\n+#### Create Controller Filter\n+\n+Add the class below to wrap all requests to the SecondServiceController in a span. This class will call the preHandle method before the REST controller is entered and the postHandle method after a response is created. \n+\n+The preHandle method starts a span for each request. This implementation is shown below:    \n+\n+```java\n+\n+@Component\n+public class ControllerFilter implements Filter {\n+  \n+  @Autowired\n+  Tracer tracer;\n+  \n+  private final Logger LOG = Logger.getLogger(ControllerFilter.class.getName());\n+\n+  private final HttpTextFormat.Getter<HttpServletRequest> GETTER =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3e906fbc09444ecacceb3e8d61397fb98690d67"}, "originalPosition": 201}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3ODA1ODQ3OnYy", "diffSide": "RIGHT", "path": "instrumentation-core/spring/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQyMTo0OTo1MlrOGpNCHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQyMTo0OTo1MlrOGpNCHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTg1ODMzMg==", "bodyText": "and then common for static fields to be at top of class\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private final Logger LOG = Logger.getLogger(ControllerFilter.class.getName());\n          \n          \n            \n              private static final Logger LOG = Logger.getLogger(ControllerFilter.class.getName());", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r445858332", "createdAt": "2020-06-25T21:49:52Z", "author": {"login": "trask"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -340,6 +341,274 @@ After running Jaeger locally, navigate to the url below. Make sure to refresh th\n \n Run FirstService and SecondService from command line or using an IDE. The end point of interest for FirstService is `http://localhost:8080/message` and  `http://localhost:8081/time` for SecondService. Entering `localhost:8080/message` in a browser should call FirstService and then SecondService, creating a trace. \n \n-***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.secondServiceUrl. ***\n+***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.SECOND_SERVICE_URL. ***\n \n Congrats, we just created a distributed service with OpenTelemetry!\n+\n+## Manual Instrumentation using Handlers and Filters\n+\n+In this section, we will implement the javax Serverlet Filter interface to wrap all requests to FirstService and SecondService controllers in a span. \n+\n+We will also use the RestTemplate HTTP client to send requests from FirstService to SecondService. To propagate the trace in this request we will also implement the ClientHttpRequestInterceptor interface. This implementation is only required for projects that send outbound requests. In this example it is only required for FirstService. \n+\n+### Set up FirstService and SecondService\n+\n+Using the earlier instructions [create two spring projects](#create-two-spring-projects) and add the required [dependencies and configurations](#setup-for-manual-instrumentation). \n+\n+### Instrumentation of Client Service: SecondService\n+\n+Ensure the main method in SecondServiceApplication is defined. This will be the entry point to the SecondService project. This file should be created by the Spring Boot project initializer.\n+\n+```java\n+import java.io.IOException;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+\n+@SpringBootApplication\n+public class SecondServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(SecondServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+Add the REST controller below to your SecondService project. This controller will return a string when SecondServiceController.secondTracedMethod is called:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+@RestController\n+@RequestMapping(value = \"/time\")\n+public class SecondServiceController {\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @GetMapping\n+   public String secondTracedMethod() {\n+      return \"It's time to get a watch\";\n+   }\n+}\n+```\n+\n+#### Create Controller Filter\n+\n+Add the class below to wrap all requests to the SecondServiceController in a span. This class will call the preHandle method before the REST controller is entered and the postHandle method after a response is created. \n+\n+The preHandle method starts a span for each request. This implementation is shown below:    \n+\n+```java\n+\n+@Component\n+public class ControllerFilter implements Filter {\n+  \n+  @Autowired\n+  Tracer tracer;\n+  \n+  private final Logger LOG = Logger.getLogger(ControllerFilter.class.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3e906fbc09444ecacceb3e8d61397fb98690d67"}, "originalPosition": 199}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3ODA2NzYzOnYy", "diffSide": "RIGHT", "path": "instrumentation-core/spring/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQyMTo1MzoxM1rOGpNHrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQyMTo1MzoxM1rOGpNHrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTg1OTc1OA==", "bodyText": "common for static fields to be at top of class", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r445859758", "createdAt": "2020-06-25T21:53:13Z", "author": {"login": "trask"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -340,6 +341,274 @@ After running Jaeger locally, navigate to the url below. Make sure to refresh th\n \n Run FirstService and SecondService from command line or using an IDE. The end point of interest for FirstService is `http://localhost:8080/message` and  `http://localhost:8081/time` for SecondService. Entering `localhost:8080/message` in a browser should call FirstService and then SecondService, creating a trace. \n \n-***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.secondServiceUrl. ***\n+***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.SECOND_SERVICE_URL. ***\n \n Congrats, we just created a distributed service with OpenTelemetry!\n+\n+## Manual Instrumentation using Handlers and Filters\n+\n+In this section, we will implement the javax Serverlet Filter interface to wrap all requests to FirstService and SecondService controllers in a span. \n+\n+We will also use the RestTemplate HTTP client to send requests from FirstService to SecondService. To propagate the trace in this request we will also implement the ClientHttpRequestInterceptor interface. This implementation is only required for projects that send outbound requests. In this example it is only required for FirstService. \n+\n+### Set up FirstService and SecondService\n+\n+Using the earlier instructions [create two spring projects](#create-two-spring-projects) and add the required [dependencies and configurations](#setup-for-manual-instrumentation). \n+\n+### Instrumentation of Client Service: SecondService\n+\n+Ensure the main method in SecondServiceApplication is defined. This will be the entry point to the SecondService project. This file should be created by the Spring Boot project initializer.\n+\n+```java\n+import java.io.IOException;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+\n+@SpringBootApplication\n+public class SecondServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(SecondServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+Add the REST controller below to your SecondService project. This controller will return a string when SecondServiceController.secondTracedMethod is called:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+@RestController\n+@RequestMapping(value = \"/time\")\n+public class SecondServiceController {\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @GetMapping\n+   public String secondTracedMethod() {\n+      return \"It's time to get a watch\";\n+   }\n+}\n+```\n+\n+#### Create Controller Filter\n+\n+Add the class below to wrap all requests to the SecondServiceController in a span. This class will call the preHandle method before the REST controller is entered and the postHandle method after a response is created. \n+\n+The preHandle method starts a span for each request. This implementation is shown below:    \n+\n+```java\n+\n+@Component\n+public class ControllerFilter implements Filter {\n+  \n+  @Autowired\n+  Tracer tracer;\n+  \n+  private final Logger LOG = Logger.getLogger(ControllerFilter.class.getName());\n+\n+  private final HttpTextFormat.Getter<HttpServletRequest> GETTER =\n+      new HttpTextFormat.Getter<HttpServletRequest>() {\n+        public String get(HttpServletRequest req, String key) {\n+          return req.getHeader(key);\n+        }\n+      };\n+\n+  @Override\n+  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n+      throws IOException, ServletException {\n+    LOG.info(\"start doFilter\");\n+    \n+    HttpServletRequest req = (HttpServletRequest) request;\n+    Context context = OpenTelemetry.getPropagators().getHttpTextFormat()\n+        .extract(Context.current(), req, GETTER);\n+    Span currentSpan = createSpanWithParent(req, context);\n+    try {\n+      tracer.withSpan(currentSpan);\n+      currentSpan.addEvent(\"dofilter\");\n+      chain.doFilter(req, response);\n+    }finally {\n+      LOG.info(\"end doFilter\");\n+      currentSpan.end();\n+    }\n+    \n+  }\n+  \n+  private Span createSpanWithParent(HttpServletRequest request, Context context) {\n+    Span parentSpan = TracingContextUtils.getSpan(context);\n+    Span.Builder spanBuilder = tracer.spanBuilder(request.getRequestURI()).setSpanKind(Span.Kind.SERVER);\n+    \n+    if (parentSpan.getContext().isValid()) {\n+      return spanBuilder.setParent(parentSpan).startSpan();\n+    }\n+\n+    Span span = spanBuilder.startSpan();\n+    span.addEvent(\"Parent Span Not Found\");\n+\n+    return span;\n+  }\n+}\n+}\n+\n+```\n+\n+Now your SecondService application is complete. Create the FirstService application using the instructions below and then run your distributed service!\n+\n+### Instrumentation of Receiving Service: FirstService\n+\n+Ensure the main method in FirstServiceApplication is defined. This will be the entry point to the FirstService project. This file should be created by the Spring Boot project initializer.\n+\n+```java\n+@SpringBootApplication\n+public class FirstServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(FirstServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+Create a REST controller for FirstService. This controller will send a request to SecondService and then return the response to the client:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpEntity;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+\n+@RestController\n+@RequestMapping(value = \"/message\")\n+public class FirstServiceController {\n+   @Autowired\n+   private Tracer tracer;\n+\t\n+   @Autowired\n+   private RestTemplate restTemplate;\n+\n+   @Autowired\n+   private HttpUtils httpUtils;\n+\n+   private static final String SECOND_SERVICE_URL = \"http://localhost:8081/time\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3e906fbc09444ecacceb3e8d61397fb98690d67"}, "originalPosition": 286}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3ODA4NjQyOnYy", "diffSide": "RIGHT", "path": "instrumentation-core/spring/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQyMjowMDoxOFrOGpNTZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNDo0NDoxN1rOGqUUkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTg2Mjc1OA==", "bodyText": "i think the names \"Receiving Service\" and \"Client Service\" are not too clear\ni like the idea of trying to give them more descriptive names, instead of FirstService and SecondService though\nmaybe MainService / TimeService?\nor FrontService / TimeService ?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r445862758", "createdAt": "2020-06-25T22:00:18Z", "author": {"login": "trask"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -153,7 +153,7 @@ Here we will create rest controllers for `FirstService` and `SecondService`.\n \n Required dependencies and configurations for FirstService and SecondService projects can be found [here](#setup-for-manual-instrumentation).\n \n-### FirstService\n+### Instrumentation of Receiving Service: FirstService", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3e906fbc09444ecacceb3e8d61397fb98690d67"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAyNjMyMg==", "bodyText": "MainService and TimeService sounds good", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r447026322", "createdAt": "2020-06-29T14:44:17Z", "author": {"login": "mabdinur"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -153,7 +153,7 @@ Here we will create rest controllers for `FirstService` and `SecondService`.\n \n Required dependencies and configurations for FirstService and SecondService projects can be found [here](#setup-for-manual-instrumentation).\n \n-### FirstService\n+### Instrumentation of Receiving Service: FirstService", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTg2Mjc1OA=="}, "originalCommit": {"oid": "a3e906fbc09444ecacceb3e8d61397fb98690d67"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3ODEwNjc5OnYy", "diffSide": "RIGHT", "path": "instrumentation-core/spring/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQyMjowODo0OFrOGpNgJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQyMjowODo0OFrOGpNgJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTg2NjAyMw==", "bodyText": "common for static fields to be at top of class", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r445866023", "createdAt": "2020-06-25T22:08:48Z", "author": {"login": "trask"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -188,27 +188,29 @@ import HttpUtils;\n @RestController\n @RequestMapping(value = \"/message\")\n public class FirstServiceController {\n+   private static int requestCount = 1;\n+   \n    @Autowired\n    private Tracer tracer;\n \n    @Autowired\n-   HttpUtils httpUtils;\n+   private HttpUtils httpUtils;\n \n-   private static String secondServiceUrl = \"http://localhost:8081/time\";\n+   private static final String SECOND_SERVICE_URL = \"http://localhost:8081/time\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3e906fbc09444ecacceb3e8d61397fb98690d67"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3ODExNTEzOnYy", "diffSide": "RIGHT", "path": "instrumentation-core/spring/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQyMjoxMTo1MlrOGpNlBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNDozODozMFrOGqUDdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTg2NzI2OQ==", "bodyText": "i forget, does this get automatically picked up by Spring, do we need to define a url mapping for it?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r445867269", "createdAt": "2020-06-25T22:11:52Z", "author": {"login": "trask"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -340,6 +341,274 @@ After running Jaeger locally, navigate to the url below. Make sure to refresh th\n \n Run FirstService and SecondService from command line or using an IDE. The end point of interest for FirstService is `http://localhost:8080/message` and  `http://localhost:8081/time` for SecondService. Entering `localhost:8080/message` in a browser should call FirstService and then SecondService, creating a trace. \n \n-***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.secondServiceUrl. ***\n+***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.SECOND_SERVICE_URL. ***\n \n Congrats, we just created a distributed service with OpenTelemetry!\n+\n+## Manual Instrumentation using Handlers and Filters\n+\n+In this section, we will implement the javax Serverlet Filter interface to wrap all requests to FirstService and SecondService controllers in a span. \n+\n+We will also use the RestTemplate HTTP client to send requests from FirstService to SecondService. To propagate the trace in this request we will also implement the ClientHttpRequestInterceptor interface. This implementation is only required for projects that send outbound requests. In this example it is only required for FirstService. \n+\n+### Set up FirstService and SecondService\n+\n+Using the earlier instructions [create two spring projects](#create-two-spring-projects) and add the required [dependencies and configurations](#setup-for-manual-instrumentation). \n+\n+### Instrumentation of Client Service: SecondService\n+\n+Ensure the main method in SecondServiceApplication is defined. This will be the entry point to the SecondService project. This file should be created by the Spring Boot project initializer.\n+\n+```java\n+import java.io.IOException;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+\n+@SpringBootApplication\n+public class SecondServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(SecondServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+Add the REST controller below to your SecondService project. This controller will return a string when SecondServiceController.secondTracedMethod is called:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+@RestController\n+@RequestMapping(value = \"/time\")\n+public class SecondServiceController {\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @GetMapping\n+   public String secondTracedMethod() {\n+      return \"It's time to get a watch\";\n+   }\n+}\n+```\n+\n+#### Create Controller Filter\n+\n+Add the class below to wrap all requests to the SecondServiceController in a span. This class will call the preHandle method before the REST controller is entered and the postHandle method after a response is created. \n+\n+The preHandle method starts a span for each request. This implementation is shown below:    \n+\n+```java\n+\n+@Component\n+public class ControllerFilter implements Filter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3e906fbc09444ecacceb3e8d61397fb98690d67"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAyMTk0Mg==", "bodyText": "It gets picked up automatically and it's applied to all REST controllers", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/548#discussion_r447021942", "createdAt": "2020-06-29T14:38:30Z", "author": {"login": "mabdinur"}, "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -340,6 +341,274 @@ After running Jaeger locally, navigate to the url below. Make sure to refresh th\n \n Run FirstService and SecondService from command line or using an IDE. The end point of interest for FirstService is `http://localhost:8080/message` and  `http://localhost:8081/time` for SecondService. Entering `localhost:8080/message` in a browser should call FirstService and then SecondService, creating a trace. \n \n-***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.secondServiceUrl. ***\n+***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.SECOND_SERVICE_URL. ***\n \n Congrats, we just created a distributed service with OpenTelemetry!\n+\n+## Manual Instrumentation using Handlers and Filters\n+\n+In this section, we will implement the javax Serverlet Filter interface to wrap all requests to FirstService and SecondService controllers in a span. \n+\n+We will also use the RestTemplate HTTP client to send requests from FirstService to SecondService. To propagate the trace in this request we will also implement the ClientHttpRequestInterceptor interface. This implementation is only required for projects that send outbound requests. In this example it is only required for FirstService. \n+\n+### Set up FirstService and SecondService\n+\n+Using the earlier instructions [create two spring projects](#create-two-spring-projects) and add the required [dependencies and configurations](#setup-for-manual-instrumentation). \n+\n+### Instrumentation of Client Service: SecondService\n+\n+Ensure the main method in SecondServiceApplication is defined. This will be the entry point to the SecondService project. This file should be created by the Spring Boot project initializer.\n+\n+```java\n+import java.io.IOException;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+\n+@SpringBootApplication\n+public class SecondServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(SecondServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+Add the REST controller below to your SecondService project. This controller will return a string when SecondServiceController.secondTracedMethod is called:\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+@RestController\n+@RequestMapping(value = \"/time\")\n+public class SecondServiceController {\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @GetMapping\n+   public String secondTracedMethod() {\n+      return \"It's time to get a watch\";\n+   }\n+}\n+```\n+\n+#### Create Controller Filter\n+\n+Add the class below to wrap all requests to the SecondServiceController in a span. This class will call the preHandle method before the REST controller is entered and the postHandle method after a response is created. \n+\n+The preHandle method starts a span for each request. This implementation is shown below:    \n+\n+```java\n+\n+@Component\n+public class ControllerFilter implements Filter {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTg2NzI2OQ=="}, "originalCommit": {"oid": "a3e906fbc09444ecacceb3e8d61397fb98690d67"}, "originalPosition": 194}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 258, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}