{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI1NTEzODQy", "number": 456, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQwMzo1MTozOVrOEBJzPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQwMzo1MTozOVrOEBJzPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NjQ0NjA3OnYy", "diffSide": "RIGHT", "path": "instrumentation/kafka-clients-0.11/src/main/java/io/opentelemetry/auto/instrumentation/kafkaclients/KafkaDecorator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQwMzo1MTozOVrOGc2i1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQyMjoyMDoyMFrOGdb_Aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwNjk2NQ==", "bodyText": "I am not sure about this attribute:\n\nIs this naming convention consistent? Do we already have attributes with names in snake_case?\nShould we produce \"derived\" attributes? Instead of 2 separate attributes \"startTime\" and \"produceTime\".\nIn any case would like to see at least a comment, explaining its meaning.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/456#discussion_r432906965", "createdAt": "2020-05-31T03:51:39Z", "author": {"login": "iNikem"}, "path": "instrumentation/kafka-clients-0.11/src/main/java/io/opentelemetry/auto/instrumentation/kafkaclients/KafkaDecorator.java", "diffHunk": "@@ -47,16 +48,21 @@ public String spanNameOnProduce(final ProducerRecord record) {\n     return \"destination\";\n   }\n \n-  public void onConsume(final Span span, final ConsumerRecord record) {\n+  public void onConsume(final Span span, final long startTimeMillis, final ConsumerRecord record) {\n     span.setAttribute(\"partition\", record.partition());\n     span.setAttribute(\"offset\", record.offset());\n+    // don't record a duration if the message was sent from an old Kafka client\n+    if (record.timestampType() != TimestampType.NO_TIMESTAMP_TYPE) {\n+      final long produceTime = record.timestamp();\n+      span.setAttribute(\"record.queue_time_ms\", Math.max(0L, startTimeMillis - produceTime));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51297ce023d962a5ce51ad998d0d08f2e598aedc"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUyMDM4Nw==", "bodyText": "Is this naming convention consistent? Do we already have attributes with names in snake_case?\n\nI see a couple existing with snake_case:\n\namqp.routing_key\namqp.delivery_mode\ncouchbase.operation_id\n\nI propose that we leave the name for now since we are already planning to review all non- semantic attributes for consistency / documentation.\n\nShould we produce \"derived\" attributes? Instead of 2 separate attributes \"startTime\" and \"produceTime\".\n\nSince it's not a semantic attribute, backends won't understand it, so I think better to leave it in format that is most directly queryable/interesting to users (but this is me making stuff up, I haven't seen any related spec guidance around this).\n\nIn any case would like to see at least a comment, explaining its meaning.\n\ndone", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/456#discussion_r433520387", "createdAt": "2020-06-01T22:20:20Z", "author": {"login": "trask"}, "path": "instrumentation/kafka-clients-0.11/src/main/java/io/opentelemetry/auto/instrumentation/kafkaclients/KafkaDecorator.java", "diffHunk": "@@ -47,16 +48,21 @@ public String spanNameOnProduce(final ProducerRecord record) {\n     return \"destination\";\n   }\n \n-  public void onConsume(final Span span, final ConsumerRecord record) {\n+  public void onConsume(final Span span, final long startTimeMillis, final ConsumerRecord record) {\n     span.setAttribute(\"partition\", record.partition());\n     span.setAttribute(\"offset\", record.offset());\n+    // don't record a duration if the message was sent from an old Kafka client\n+    if (record.timestampType() != TimestampType.NO_TIMESTAMP_TYPE) {\n+      final long produceTime = record.timestamp();\n+      span.setAttribute(\"record.queue_time_ms\", Math.max(0L, startTimeMillis - produceTime));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwNjk2NQ=="}, "originalCommit": {"oid": "51297ce023d962a5ce51ad998d0d08f2e598aedc"}, "originalPosition": 19}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 458, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}