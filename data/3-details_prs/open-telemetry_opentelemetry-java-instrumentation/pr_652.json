{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ2NjM4NDc0", "number": 652, "title": "Docs for writing new instrumentation...", "bodyText": "... and migrates AWS SDK 2.2 instrumentation to the pattern proposed in these docs.\nHope this is what you had in mind @iNikem. I tried to keep things mostly conceptual and process, but not code since it has a higher chance of drifting vs the real code. But can add more or less detail as anyone thinks makes sense!", "createdAt": "2020-07-09T06:04:46Z", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652", "merged": true, "mergeCommit": {"oid": "d8355c672d1f45ffec9e6bafbf7f74c7d675d46f"}, "closed": true, "closedAt": "2020-07-19T05:21:20Z", "author": {"login": "anuraaga"}, "timelineItems": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABczIsEsAH2gAyNDQ2NjM4NDc0OmI5MmU2ZDI5YTA4ZTFkMTk3ZDI0ZjZmODQyMDlmNzVkNWQ2YzIwZTY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc2VuY0AH2gAyNDQ2NjM4NDc0OjZmOGIxMTcwMTc4M2UzNWI1NTZlZDVjYzk5MTFlYTY2YTk1MmY4NGU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "b92e6d29a08e1d197d24f6f84209f75d5d6c20e6", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/b92e6d29a08e1d197d24f6f84209f75d5d6c20e6", "committedDate": "2020-07-09T06:03:36Z", "message": "Docs for writing new instrumentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ac4552300ebfbe8fc65f45684184c0358defcad", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/4ac4552300ebfbe8fc65f45684184c0358defcad", "committedDate": "2020-07-10T06:36:21Z", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-java-instrumentation into instrumentation-docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46030a5b1f8c6db5c8379c25bf6cc5f5fe78e337", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/46030a5b1f8c6db5c8379c25bf6cc5f5fe78e337", "committedDate": "2020-07-10T06:55:34Z", "message": "Move aws sdk agent / library folders"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a148a588b7afae05b044b89e33e62127c788ba1", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/5a148a588b7afae05b044b89e33e62127c788ba1", "committedDate": "2020-07-10T07:42:24Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d9d8bb754deeb037eee52c8d012c30acc8397f45", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/d9d8bb754deeb037eee52c8d012c30acc8397f45", "committedDate": "2020-07-13T05:20:17Z", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-java-instrumentation into instrumentation-docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1022a0b7dc545d06816f30c8a45e727ede6aab4", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/a1022a0b7dc545d06816f30c8a45e727ede6aab4", "committedDate": "2020-07-13T05:41:33Z", "message": "SpockRunner"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca8ce6a65434aaf95d9faee8d21df82fb728821c", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/ca8ce6a65434aaf95d9faee8d21df82fb728821c", "committedDate": "2020-07-13T05:48:00Z", "message": "Move testing -> testing-common"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac77748ea3eac783e84ad84cbcd250d35e75611c", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/ac77748ea3eac783e84ad84cbcd250d35e75611c", "committedDate": "2020-07-13T06:03:46Z", "message": "Spotless and tweaks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4f3a3786e0a5f107f22b6e95b1963aa73a6fde8", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/e4f3a3786e0a5f107f22b6e95b1963aa73a6fde8", "committedDate": "2020-07-13T06:21:12Z", "message": "Cleanups"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd511304b3377c035b8ea75ceb29ca6e7b406ced", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/dd511304b3377c035b8ea75ceb29ca6e7b406ced", "committedDate": "2020-07-13T06:22:18Z", "message": "Cleanups"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2148cf071270beff25ed432649b5d248647fb06", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/e2148cf071270beff25ed432649b5d248647fb06", "committedDate": "2020-07-13T06:31:59Z", "message": "Spotless"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "70fb67dc24834d81b8ca4e8f3a4f2001f20807b6", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/70fb67dc24834d81b8ca4e8f3a4f2001f20807b6", "committedDate": "2020-07-13T06:27:20Z", "message": "Spotless"}, "afterCommit": {"oid": "e2148cf071270beff25ed432649b5d248647fb06", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/e2148cf071270beff25ed432649b5d248647fb06", "committedDate": "2020-07-13T06:31:59Z", "message": "Spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cac54eac419f3c6272c01b97ab1a21022294f474", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/cac54eac419f3c6272c01b97ab1a21022294f474", "committedDate": "2020-07-13T06:42:52Z", "message": "narc"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ4NzkwODgy", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#pullrequestreview-448790882", "createdAt": "2020-07-15T09:38:00Z", "commit": {"oid": "cac54eac419f3c6272c01b97ab1a21022294f474"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwOTozODowMFrOGx2UaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwOTo1NjoyOVrOGx2-kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyMzM2OA==", "bodyText": "It is worth mentioning here \"and the oldest version being target\"", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#discussion_r454923368", "createdAt": "2020-07-15T09:38:00Z", "author": {"login": "iNikem"}, "path": "CONTRIBUTING.md", "diffHunk": "@@ -78,6 +78,123 @@ available in bootstrap classloader.\n dependencies. Shaded during creation of `java-agent` jar file by Shadow\n Gradle plugin.\n \n+### Writing instrumentation\n+\n+**Warning**: The repository is still in the process of migrating to the structure described here.\n+\n+Any time we want to add OpenTelemetry support for a new Java library, e.g., so usage\n+of that library has tracing, we must write new instrumentation for that library. Let's\n+go over some terms first.\n+\n+**Manual Instrumentation**: This is logic that creates spans and enriches them with data\n+using library-specific monitoring APIs. For example, when instrumenting an RPC library,\n+the instrumentation will use some library-specific functionality to listen to events such\n+as the start and end of a request and will execute code to start and end spans in these\n+listeners. Many of these libraries will provide interception type APIs such as the gRPC\n+`ClientInterceptor` or servlet's `Filter`. Others will provide a Java interface whose methods\n+correspond to a request, and instrumentation can define an implementation which delegates\n+to the standard, wrapping methods with the logic to manage spans. Users will add code to their\n+apps that initialize the classes provided by manual instrumentation libraries and the libraries\n+can be found inside the user's app itself.\n+\n+Some libraries will have no way of intercepting requests because they only expose static APIs\n+and no interception hooks. For these libraries it is not possible to create manual\n+instrumentation.\n+\n+**Auto Instrumentation**: This is logic that is similar to manual instrumentation, but instead\n+of a user initializing classes themselves, a Java agent automatically initializes them during\n+class loading by manipulating byte code. This allows a user to develop their apps without thinking\n+about instrumentation and get it \"for free\". Often, the auto instrumentation will generate bytecode\n+that is more or less identical to what a user would have written themselves in their app.\n+\n+In addition to automatically initializing manual instrumentation, auto instrumentation can be used\n+for libraries where manual instrumentation is not possible, such as `URLConnection`, because it can\n+intercept even the JDK's classes. Such libraries will not have manual instrumentation but will have\n+auto instrumentation.\n+\n+#### Folder Structure\n+\n+When writing new instrumentation, create a new subfolder of `instrumentation` to correspond to the\n+instrumented library and the version being targeted. Ideally an old version of the library is", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cac54eac419f3c6272c01b97ab1a21022294f474"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyMzk5Mw==", "bodyText": "Gradle files names should be unique, so likely yarpc-1.0-agent.gradle", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#discussion_r454923993", "createdAt": "2020-07-15T09:39:07Z", "author": {"login": "iNikem"}, "path": "CONTRIBUTING.md", "diffHunk": "@@ -78,6 +78,123 @@ available in bootstrap classloader.\n dependencies. Shaded during creation of `java-agent` jar file by Shadow\n Gradle plugin.\n \n+### Writing instrumentation\n+\n+**Warning**: The repository is still in the process of migrating to the structure described here.\n+\n+Any time we want to add OpenTelemetry support for a new Java library, e.g., so usage\n+of that library has tracing, we must write new instrumentation for that library. Let's\n+go over some terms first.\n+\n+**Manual Instrumentation**: This is logic that creates spans and enriches them with data\n+using library-specific monitoring APIs. For example, when instrumenting an RPC library,\n+the instrumentation will use some library-specific functionality to listen to events such\n+as the start and end of a request and will execute code to start and end spans in these\n+listeners. Many of these libraries will provide interception type APIs such as the gRPC\n+`ClientInterceptor` or servlet's `Filter`. Others will provide a Java interface whose methods\n+correspond to a request, and instrumentation can define an implementation which delegates\n+to the standard, wrapping methods with the logic to manage spans. Users will add code to their\n+apps that initialize the classes provided by manual instrumentation libraries and the libraries\n+can be found inside the user's app itself.\n+\n+Some libraries will have no way of intercepting requests because they only expose static APIs\n+and no interception hooks. For these libraries it is not possible to create manual\n+instrumentation.\n+\n+**Auto Instrumentation**: This is logic that is similar to manual instrumentation, but instead\n+of a user initializing classes themselves, a Java agent automatically initializes them during\n+class loading by manipulating byte code. This allows a user to develop their apps without thinking\n+about instrumentation and get it \"for free\". Often, the auto instrumentation will generate bytecode\n+that is more or less identical to what a user would have written themselves in their app.\n+\n+In addition to automatically initializing manual instrumentation, auto instrumentation can be used\n+for libraries where manual instrumentation is not possible, such as `URLConnection`, because it can\n+intercept even the JDK's classes. Such libraries will not have manual instrumentation but will have\n+auto instrumentation.\n+\n+#### Folder Structure\n+\n+When writing new instrumentation, create a new subfolder of `instrumentation` to correspond to the\n+instrumented library and the version being targeted. Ideally an old version of the library is\n+targeted in a way that the instrumentation applies to a large range of versions, but this may be\n+restricted by the interception APIs provided by the library.\n+\n+Within the subfolder, create three folders `library` (skip if manual instrumentation is not possible),\n+`agent`, and `testing`.\n+\n+For example, if we are targeting an RPC framework `yarpc` at version `1.0` we would have a tree like\n+\n+```\n+instrumentation ->\n+    ...\n+    yarpc-1.0 ->\n+        agent\n+            agent.gradle", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cac54eac419f3c6272c01b97ab1a21022294f474"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyNTc2OQ==", "bodyText": "We should point to an example instrumentation library right away, so that reader could see actual code behind following explanations.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#discussion_r454925769", "createdAt": "2020-07-15T09:42:07Z", "author": {"login": "iNikem"}, "path": "CONTRIBUTING.md", "diffHunk": "@@ -78,6 +78,123 @@ available in bootstrap classloader.\n dependencies. Shaded during creation of `java-agent` jar file by Shadow\n Gradle plugin.\n \n+### Writing instrumentation\n+\n+**Warning**: The repository is still in the process of migrating to the structure described here.\n+\n+Any time we want to add OpenTelemetry support for a new Java library, e.g., so usage\n+of that library has tracing, we must write new instrumentation for that library. Let's\n+go over some terms first.\n+\n+**Manual Instrumentation**: This is logic that creates spans and enriches them with data\n+using library-specific monitoring APIs. For example, when instrumenting an RPC library,\n+the instrumentation will use some library-specific functionality to listen to events such\n+as the start and end of a request and will execute code to start and end spans in these\n+listeners. Many of these libraries will provide interception type APIs such as the gRPC\n+`ClientInterceptor` or servlet's `Filter`. Others will provide a Java interface whose methods\n+correspond to a request, and instrumentation can define an implementation which delegates\n+to the standard, wrapping methods with the logic to manage spans. Users will add code to their\n+apps that initialize the classes provided by manual instrumentation libraries and the libraries\n+can be found inside the user's app itself.\n+\n+Some libraries will have no way of intercepting requests because they only expose static APIs\n+and no interception hooks. For these libraries it is not possible to create manual\n+instrumentation.\n+\n+**Auto Instrumentation**: This is logic that is similar to manual instrumentation, but instead\n+of a user initializing classes themselves, a Java agent automatically initializes them during\n+class loading by manipulating byte code. This allows a user to develop their apps without thinking\n+about instrumentation and get it \"for free\". Often, the auto instrumentation will generate bytecode\n+that is more or less identical to what a user would have written themselves in their app.\n+\n+In addition to automatically initializing manual instrumentation, auto instrumentation can be used\n+for libraries where manual instrumentation is not possible, such as `URLConnection`, because it can\n+intercept even the JDK's classes. Such libraries will not have manual instrumentation but will have\n+auto instrumentation.\n+\n+#### Folder Structure\n+\n+When writing new instrumentation, create a new subfolder of `instrumentation` to correspond to the\n+instrumented library and the version being targeted. Ideally an old version of the library is\n+targeted in a way that the instrumentation applies to a large range of versions, but this may be\n+restricted by the interception APIs provided by the library.\n+\n+Within the subfolder, create three folders `library` (skip if manual instrumentation is not possible),\n+`agent`, and `testing`.\n+\n+For example, if we are targeting an RPC framework `yarpc` at version `1.0` we would have a tree like\n+\n+```\n+instrumentation ->\n+    ...\n+    yarpc-1.0 ->\n+        agent\n+            agent.gradle\n+        library\n+            library.gradle\n+        testing\n+            testing.gradle\n+```\n+\n+and in the top level `settings.gradle`\n+\n+```groovy\n+\n+include 'instrumentation:yarpc-1.0:agent'\n+include 'instrumentation:yarpc-1.0:library'\n+include 'instrumentation:yarpc-1.0:testing'\n+```\n+\n+#### Writing manual instrumentation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cac54eac419f3c6272c01b97ab1a21022294f474"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyODA2Ng==", "bodyText": "This doc is a very good starting point. But we have to write more extensive guide with code examples and, probably, method-by-method explanations. Or may be just a series of blog posts ;)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#discussion_r454928066", "createdAt": "2020-07-15T09:46:02Z", "author": {"login": "iNikem"}, "path": "CONTRIBUTING.md", "diffHunk": "@@ -78,6 +78,123 @@ available in bootstrap classloader.\n dependencies. Shaded during creation of `java-agent` jar file by Shadow\n Gradle plugin.\n \n+### Writing instrumentation\n+\n+**Warning**: The repository is still in the process of migrating to the structure described here.\n+\n+Any time we want to add OpenTelemetry support for a new Java library, e.g., so usage\n+of that library has tracing, we must write new instrumentation for that library. Let's\n+go over some terms first.\n+\n+**Manual Instrumentation**: This is logic that creates spans and enriches them with data\n+using library-specific monitoring APIs. For example, when instrumenting an RPC library,\n+the instrumentation will use some library-specific functionality to listen to events such\n+as the start and end of a request and will execute code to start and end spans in these\n+listeners. Many of these libraries will provide interception type APIs such as the gRPC\n+`ClientInterceptor` or servlet's `Filter`. Others will provide a Java interface whose methods\n+correspond to a request, and instrumentation can define an implementation which delegates\n+to the standard, wrapping methods with the logic to manage spans. Users will add code to their\n+apps that initialize the classes provided by manual instrumentation libraries and the libraries\n+can be found inside the user's app itself.\n+\n+Some libraries will have no way of intercepting requests because they only expose static APIs\n+and no interception hooks. For these libraries it is not possible to create manual\n+instrumentation.\n+\n+**Auto Instrumentation**: This is logic that is similar to manual instrumentation, but instead\n+of a user initializing classes themselves, a Java agent automatically initializes them during\n+class loading by manipulating byte code. This allows a user to develop their apps without thinking\n+about instrumentation and get it \"for free\". Often, the auto instrumentation will generate bytecode\n+that is more or less identical to what a user would have written themselves in their app.\n+\n+In addition to automatically initializing manual instrumentation, auto instrumentation can be used\n+for libraries where manual instrumentation is not possible, such as `URLConnection`, because it can\n+intercept even the JDK's classes. Such libraries will not have manual instrumentation but will have\n+auto instrumentation.\n+\n+#### Folder Structure\n+\n+When writing new instrumentation, create a new subfolder of `instrumentation` to correspond to the\n+instrumented library and the version being targeted. Ideally an old version of the library is\n+targeted in a way that the instrumentation applies to a large range of versions, but this may be\n+restricted by the interception APIs provided by the library.\n+\n+Within the subfolder, create three folders `library` (skip if manual instrumentation is not possible),\n+`agent`, and `testing`.\n+\n+For example, if we are targeting an RPC framework `yarpc` at version `1.0` we would have a tree like\n+\n+```\n+instrumentation ->\n+    ...\n+    yarpc-1.0 ->\n+        agent\n+            agent.gradle\n+        library\n+            library.gradle\n+        testing\n+            testing.gradle\n+```\n+\n+and in the top level `settings.gradle`\n+\n+```groovy\n+\n+include 'instrumentation:yarpc-1.0:agent'\n+include 'instrumentation:yarpc-1.0:library'\n+include 'instrumentation:yarpc-1.0:testing'\n+```\n+\n+#### Writing manual instrumentation\n+\n+Begin by writing the instrumentation for the library in `library`. This generally involves defining a", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cac54eac419f3c6272c01b97ab1a21022294f474"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyOTQ2Mw==", "bodyText": "If we have naming convention for modules, as suggested above, we may replace this configuration with convention. publish.gradle should figure out itself that instrumentations should publish regular jars and only exporters and agent itself should publish fat jar.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#discussion_r454929463", "createdAt": "2020-07-15T09:48:22Z", "author": {"login": "iNikem"}, "path": "gradle/instrumentation-library.gradle", "diffHunk": "@@ -0,0 +1,29 @@\n+ext {\n+  noShadowPublish = true", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cac54eac419f3c6272c01b97ab1a21022294f474"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkzMDAwNQ==", "bodyText": "Same remark about module naming and convention over configuration", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#discussion_r454930005", "createdAt": "2020-07-15T09:49:20Z", "author": {"login": "iNikem"}, "path": "gradle/instrumentation.gradle", "diffHunk": "@@ -3,6 +3,10 @@\n apply plugin: 'net.bytebuddy.byte-buddy'\n apply plugin: 'muzzle'\n \n+ext {\n+  packageInAgentBundle = true", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cac54eac419f3c6272c01b97ab1a21022294f474"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkzMDY5NQ==", "bodyText": "Do we need extra folder layer? instrumentation/aws-sdk/aws-sdk-2.2 vs instrumentation/aws-sdk-2.2", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#discussion_r454930695", "createdAt": "2020-07-15T09:50:26Z", "author": {"login": "iNikem"}, "path": "instrumentation/aws-sdk/aws-sdk-2.2/agent/agent.gradle", "diffHunk": "@@ -0,0 +1,36 @@\n+ext {\n+  minJavaVersionForTests = JavaVersion.VERSION_1_8\n+}\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cac54eac419f3c6272c01b97ab1a21022294f474"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkzMTc3NA==", "bodyText": "should this be compileOnly?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#discussion_r454931774", "createdAt": "2020-07-15T09:52:14Z", "author": {"login": "iNikem"}, "path": "instrumentation/aws-sdk/aws-sdk-2.2/library/library.gradle", "diffHunk": "@@ -0,0 +1,27 @@\n+ext {\n+  minJavaVersionForTests = JavaVersion.VERSION_1_8\n+  javaSubPackage = 'awssdk.v2_2'\n+}\n+\n+apply from: \"$rootDir/gradle/instrumentation-library.gradle\"\n+apply plugin: 'org.unbroken-dome.test-sets'\n+\n+testSets {\n+  latestDepTest {\n+    dirName = 'test'\n+  }\n+}\n+\n+dependencies {\n+  api group: 'software.amazon.awssdk', name: 'aws-core', version: '2.2.0'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cac54eac419f3c6272c01b97ab1a21022294f474"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkzMjM5Ng==", "bodyText": "Are you sure you want to call this on every method? Not in setupSpec?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#discussion_r454932396", "createdAt": "2020-07-15T09:53:23Z", "author": {"login": "iNikem"}, "path": "instrumentation/aws-sdk/aws-sdk-2.2/testing/src/main/groovy/io/opentelemetry/instrumentation/awssdk/v2_2/AbstractAws2ClientTest.groovy", "diffHunk": "@@ -72,15 +72,15 @@ class Aws2ClientCoreTest extends InstrumentationTestRunner {\n     }\n   }\n \n-  def \"send #operation request with builder {#builder.class.getName()} mocked response\"() {\n+  abstract void configureSdkClient(SdkClientBuilder builder)\n+\n+  def \"send #operation request with builder #builder.class.getName() mocked response\"() {\n     setup:\n+    configureSdkClient(builder)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cac54eac419f3c6272c01b97ab1a21022294f474"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkzMzYyMw==", "bodyText": "Somewhere should be documentation about childSetupSpec and childSetup methods", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#discussion_r454933623", "createdAt": "2020-07-15T09:55:27Z", "author": {"login": "iNikem"}, "path": "testing-common/src/main/groovy/io/opentelemetry/auto/test/AgentTestTrait.groovy", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.auto.test\n+\n+import com.google.common.base.Predicate\n+import groovy.transform.stc.ClosureParams\n+import groovy.transform.stc.SimpleType\n+import io.opentelemetry.auto.test.asserts.InMemoryExporterAssert\n+import io.opentelemetry.sdk.trace.data.SpanData\n+\n+/**\n+ * A trait which initializes agent tests, including bytecode manipulation and a test span exporter.\n+ * All agent tests should implement this trait.\n+ */\n+trait AgentTestTrait {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cac54eac419f3c6272c01b97ab1a21022294f474"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkzNDE2Mg==", "bodyText": "Why do we need 2 traits?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#discussion_r454934162", "createdAt": "2020-07-15T09:56:29Z", "author": {"login": "iNikem"}, "path": "testing-common/src/main/groovy/io/opentelemetry/auto/test/InstrumentationTestTrait.groovy", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.auto.test\n+\n+import com.google.common.base.Predicate\n+import groovy.transform.stc.ClosureParams\n+import groovy.transform.stc.SimpleType\n+import io.opentelemetry.auto.test.asserts.InMemoryExporterAssert\n+import io.opentelemetry.sdk.trace.data.SpanData\n+\n+/**\n+ * A trait which initializes instrumentation library tests, including a test span exporter. All\n+ * library tests should implement this trait.\n+ */\n+trait InstrumentationTestTrait {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cac54eac419f3c6272c01b97ab1a21022294f474"}, "originalPosition": 29}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "91e30c959c09b02dc1b17204c5079d92eb2ec9d2", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/91e30c959c09b02dc1b17204c5079d92eb2ec9d2", "committedDate": "2020-07-16T08:09:44Z", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-auto-instr-java into instrumentation-docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3dc70256e7c5e4c5d3174c78501548a54f65f91c", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/3dc70256e7c5e4c5d3174c78501548a54f65f91c", "committedDate": "2020-07-16T09:09:14Z", "message": "Fix archives name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78b239723b657f77bf1328d5fb3929c426d36f57", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/78b239723b657f77bf1328d5fb3929c426d36f57", "committedDate": "2020-07-16T09:13:01Z", "message": "Document traits"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwMzYwNDUw", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#pullrequestreview-450360450", "createdAt": "2020-07-17T04:11:04Z", "commit": {"oid": "78b239723b657f77bf1328d5fb3929c426d36f57"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwNDoxMTowNFrOGzEtmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwNDoxMTowNFrOGzEtmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIwNzc3MA==", "bodyText": "Maybe @iNikem meant this?\ninstrumentation ->\n  yarpc ->\n    yarpc-1.0 ->\n      agent ->\n        yarpc-1.0-agent.gradle\n      library ->\n        yarpc-1.0-library.gradle\n\nand module names\n\n:yarpc:yarpc-1.0:agent\n:yarpc:yarpc-1.0:library", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#discussion_r456207770", "createdAt": "2020-07-17T04:11:04Z", "author": {"login": "trask"}, "path": "CONTRIBUTING.md", "diffHunk": "@@ -78,6 +78,123 @@ available in bootstrap classloader.\n dependencies. Shaded during creation of `java-agent` jar file by Shadow\n Gradle plugin.\n \n+### Writing instrumentation\n+\n+**Warning**: The repository is still in the process of migrating to the structure described here.\n+\n+Any time we want to add OpenTelemetry support for a new Java library, e.g., so usage\n+of that library has tracing, we must write new instrumentation for that library. Let's\n+go over some terms first.\n+\n+**Manual Instrumentation**: This is logic that creates spans and enriches them with data\n+using library-specific monitoring APIs. For example, when instrumenting an RPC library,\n+the instrumentation will use some library-specific functionality to listen to events such\n+as the start and end of a request and will execute code to start and end spans in these\n+listeners. Many of these libraries will provide interception type APIs such as the gRPC\n+`ClientInterceptor` or servlet's `Filter`. Others will provide a Java interface whose methods\n+correspond to a request, and instrumentation can define an implementation which delegates\n+to the standard, wrapping methods with the logic to manage spans. Users will add code to their\n+apps that initialize the classes provided by manual instrumentation libraries and the libraries\n+can be found inside the user's app itself.\n+\n+Some libraries will have no way of intercepting requests because they only expose static APIs\n+and no interception hooks. For these libraries it is not possible to create manual\n+instrumentation.\n+\n+**Auto Instrumentation**: This is logic that is similar to manual instrumentation, but instead\n+of a user initializing classes themselves, a Java agent automatically initializes them during\n+class loading by manipulating byte code. This allows a user to develop their apps without thinking\n+about instrumentation and get it \"for free\". Often, the auto instrumentation will generate bytecode\n+that is more or less identical to what a user would have written themselves in their app.\n+\n+In addition to automatically initializing manual instrumentation, auto instrumentation can be used\n+for libraries where manual instrumentation is not possible, such as `URLConnection`, because it can\n+intercept even the JDK's classes. Such libraries will not have manual instrumentation but will have\n+auto instrumentation.\n+\n+#### Folder Structure\n+\n+When writing new instrumentation, create a new subfolder of `instrumentation` to correspond to the\n+instrumented library and the version being targeted. Ideally an old version of the library is\n+targeted in a way that the instrumentation applies to a large range of versions, but this may be\n+restricted by the interception APIs provided by the library.\n+\n+Within the subfolder, create three folders `library` (skip if manual instrumentation is not possible),\n+`agent`, and `testing`.\n+\n+For example, if we are targeting an RPC framework `yarpc` at version `1.0` we would have a tree like\n+\n+```\n+instrumentation ->\n+    ...\n+    yarpc-1.0 ->\n+        agent\n+            agent.gradle", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyMzk5Mw=="}, "originalCommit": {"oid": "cac54eac419f3c6272c01b97ab1a21022294f474"}, "originalPosition": 55}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4db78e1156b6a6c486050b53cbce6bdfc05f5c3", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/e4db78e1156b6a6c486050b53cbce6bdfc05f5c3", "committedDate": "2020-07-17T07:00:53Z", "message": "agent -> auto and gradle files"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b86efb35a507dcc6be5d97114e2c0d368851a846", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/b86efb35a507dcc6be5d97114e2c0d368851a846", "committedDate": "2020-07-17T07:02:35Z", "message": "Add auto for real"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b151f53c9ba3ba6d4aa3a52fd5e283250f125b47", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/b151f53c9ba3ba6d4aa3a52fd5e283250f125b47", "committedDate": "2020-07-17T07:03:21Z", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-auto-instr-java into instrumentation-docs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxMDMyNTA1", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#pullrequestreview-451032505", "createdAt": "2020-07-18T05:13:02Z", "commit": {"oid": "b151f53c9ba3ba6d4aa3a52fd5e283250f125b47"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxMDMzNDc0", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#pullrequestreview-451033474", "createdAt": "2020-07-18T05:35:58Z", "commit": {"oid": "b151f53c9ba3ba6d4aa3a52fd5e283250f125b47"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f8b11701783e35b556ed5cc9911ea66a952f84e", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/6f8b11701783e35b556ed5cc9911ea66a952f84e", "committedDate": "2020-07-19T04:56:40Z", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-java-instrumentation into instrumentation-docs"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3077, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}