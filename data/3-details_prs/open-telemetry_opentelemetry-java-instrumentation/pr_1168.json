{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc4NzQwNzkz", "number": 1168, "title": "Properly track causality of kotlin suspend functions", "bodyText": "Fix propagation/causality when kotlin suspend functions are used, by adding instrumentation specific to the kotlin coroutine system.", "createdAt": "2020-09-03T16:11:59Z", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168", "merged": true, "mergeCommit": {"oid": "030e9fe107981f36c7bcfdd52b10b1bb4d6d373e"}, "closed": true, "closedAt": "2020-09-09T05:11:01Z", "author": {"login": "johnbley"}, "timelineItems": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdFS1-PAH2gAyNDc4NzQwNzkzOmQzZjNiZmY5MWU1OWFkYmUzNDk5ZjVkNTRiZmExMTgxMzJlNGI2OWE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdHDzW5gFqTQ4NDYzOTIyMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d3f3bff91e59adbe3499f5d54bfa118132e4b69a", "author": {"user": {"login": "johnbley", "name": "John Bley"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/d3f3bff91e59adbe3499f5d54bfa118132e4b69a", "committedDate": "2020-09-03T16:04:06Z", "message": "Initial work on kotlin suspend functions.\n\nIntroduce new instrumentation to capture kotlin suspended coroutines\nand track/update Context appropriately.  Add high-concurrency test\nshowing the issue and that it is solved."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e79e539cd0aec0003ab984267bcf15b04df9efd", "author": {"user": {"login": "johnbley", "name": "John Bley"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/4e79e539cd0aec0003ab984267bcf15b04df9efd", "committedDate": "2020-09-03T16:07:10Z", "message": "spotlessApply"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79f4b99af966340d18dfa2836dd4521ee5c33fc9", "author": {"user": {"login": "johnbley", "name": "John Bley"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/79f4b99af966340d18dfa2836dd4521ee5c33fc9", "committedDate": "2020-09-03T16:08:54Z", "message": "Fix spelling of continuation."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "db0a92514191069119bc380a788165909a4b4c97", "author": {"user": {"login": "johnbley", "name": "John Bley"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/db0a92514191069119bc380a788165909a4b4c97", "committedDate": "2020-09-03T18:07:12Z", "message": "Fix kotlin style"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyMTM0MjI0", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#pullrequestreview-482134224", "createdAt": "2020-09-03T19:19:48Z", "commit": {"oid": "db0a92514191069119bc380a788165909a4b4c97"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxOToxOTo0OVrOHM0UsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxOToxOTo0OVrOHM0UsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwMjIyNQ==", "bodyText": "You may want to use runBlocking: https://kotlinlang.org/docs/reference/coroutines/basics.html#structured-concurrency", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483202225", "createdAt": "2020-09-03T19:19:49Z", "author": {"login": "iNikem"}, "path": "instrumentation/java-concurrent/kotlin-testing/src/test/kotlin/KotlinCoroutineTests.kt", "diffHunk": "@@ -138,6 +140,55 @@ class KotlinCoroutineTests(private val dispatcher: CoroutineDispatcher) {\n     }\n   }\n \n+  fun launchConcurrentSuspendFunctions(numIters: Int) {\n+    for (i in 0 until numIters) {\n+      GlobalScope.launch {\n+        a(i.toLong())\n+      }\n+      GlobalScope.launch {\n+        b(i.toLong())\n+      }\n+    }\n+    // A simple and generous timeout (as opposed to joining on all the generated Jobs) also helps\n+    // fail the test if our overhead throws the cost of context switching 100s of times way out of normal\n+    Thread.sleep(4000)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db0a92514191069119bc380a788165909a4b4c97"}, "originalPosition": 30}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b72f3459df4043e11677a0c8f280e2ffdabaab20", "author": {"user": {"login": "johnbley", "name": "John Bley"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/b72f3459df4043e11677a0c8f280e2ffdabaab20", "committedDate": "2020-09-03T19:43:33Z", "message": "Add kotlin dependencies to muzzle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d9211b9b333dc599159d072737acd37a1201a3ea", "author": {"user": {"login": "johnbley", "name": "John Bley"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/d9211b9b333dc599159d072737acd37a1201a3ea", "committedDate": "2020-09-03T23:10:55Z", "message": "Fix muzzle in another package that pulls in java-concurrent."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7aae4c4cfe714961f27d62287bbb9134921f51e3", "author": {"user": {"login": "johnbley", "name": "John Bley"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/7aae4c4cfe714961f27d62287bbb9134921f51e3", "committedDate": "2020-09-03T23:30:18Z", "message": "Use runBlocking instead of a sleep to finish test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyNDA0MTgx", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#pullrequestreview-482404181", "createdAt": "2020-09-04T06:57:40Z", "commit": {"oid": "7aae4c4cfe714961f27d62287bbb9134921f51e3"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwNjo1Nzo0MVrOHNB7Yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwNzowODo0OFrOHNCN7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNTEyMw==", "bodyText": "Could you add a bit more about why exactly it gets lost? Is it because with low concurrency, suspend functions are effectively executed in order on a single thread?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483425123", "createdAt": "2020-09-04T06:57:41Z", "author": {"login": "anuraaga"}, "path": "instrumentation/java-concurrent/src/main/java/io/opentelemetry/instrumentation/auto/javaconcurrent/KotlinProbeInstrumentation.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.javaconcurrent;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import kotlin.coroutines.Continuation;\n+import kotlin.coroutines.CoroutineContext;\n+import kotlin.jvm.functions.Function2;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+@AutoService(Instrumenter.class)\n+public class KotlinProbeInstrumentation extends Instrumenter.Default {\n+  /*\n+  Kotlin coroutines with suspend functions are a form of cooperative \"userland\" threading\n+  (you might also know this pattern as \"fibers\" or \"green threading\", where the OS/kernel-level thread\n+  has no idea of switching between tasks.  Fortunately kotlin exposes hooks for the key events: knowing when\n+  coroutines are being created, when they are suspended (swapped out/inactive), and when they are resumed (about to\n+  run again).\n+\n+  Without this instrumentation, heavy concurrency and usage of kotlin suspend functions will break causality", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7aae4c4cfe714961f27d62287bbb9134921f51e3"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNTI1Nw==", "bodyText": "I think the above context is great for this class, this one we can just keep in PR comments :)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483425257", "createdAt": "2020-09-04T06:58:00Z", "author": {"login": "anuraaga"}, "path": "instrumentation/java-concurrent/src/main/java/io/opentelemetry/instrumentation/auto/javaconcurrent/KotlinProbeInstrumentation.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.javaconcurrent;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import kotlin.coroutines.Continuation;\n+import kotlin.coroutines.CoroutineContext;\n+import kotlin.jvm.functions.Function2;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+@AutoService(Instrumenter.class)\n+public class KotlinProbeInstrumentation extends Instrumenter.Default {\n+  /*\n+  Kotlin coroutines with suspend functions are a form of cooperative \"userland\" threading\n+  (you might also know this pattern as \"fibers\" or \"green threading\", where the OS/kernel-level thread\n+  has no idea of switching between tasks.  Fortunately kotlin exposes hooks for the key events: knowing when\n+  coroutines are being created, when they are suspended (swapped out/inactive), and when they are resumed (about to\n+  run again).\n+\n+  Without this instrumentation, heavy concurrency and usage of kotlin suspend functions will break causality\n+  and cause nonsensical span parents/context propagation.\n+\n+  The basic strategy here is:\n+  1) Use the DebugProbes callbacks to learn about coroutine create, resume, and suspend operations\n+  2) Wrap the creation Coroutine and its Context and use that wrapping to add an extra Context \"key\"\n+  3) Use the callback for resume and suspend to manipulate our context \"key\" whereby an appropriate state\n+     object can be found (tied to the chain of Continutations in the Coroutine).\n+  4) Do our swapping-context dance with that appropriate state\n+  5) Test with highly concurrent well-known span causality and ensure everything looks right.\n+     Without this instrumentation, this test fails with concurrency=2; with this instrumentation,\n+     it passes with concurrency=200.\n+\n+  I've run the basic shape of this by an expert in kotlin coroutines (Roman Elizarov) and he agreed that the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7aae4c4cfe714961f27d62287bbb9134921f51e3"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNjE3Nw==", "bodyText": "I think it'd make sense for us to rename kotlin-testing to kotlin-coroutines and add this instrumentation there too since this isn't instrumenting the JDK itself. It removes that corner case of muzzle you found too I believe.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483426177", "createdAt": "2020-09-04T07:00:09Z", "author": {"login": "anuraaga"}, "path": "instrumentation/java-concurrent/src/main/java/io/opentelemetry/instrumentation/auto/javaconcurrent/KotlinProbeInstrumentation.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.javaconcurrent;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import kotlin.coroutines.Continuation;\n+import kotlin.coroutines.CoroutineContext;\n+import kotlin.jvm.functions.Function2;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+@AutoService(Instrumenter.class)\n+public class KotlinProbeInstrumentation extends Instrumenter.Default {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7aae4c4cfe714961f27d62287bbb9134921f51e3"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNzU4Nw==", "bodyText": "Is it possible to use ThreadContextElement instead of hooking into the lifecycle ourselves? If not, can we add some docs on why that doesn't work? I haven't used kotlin much TBH, but my understanding is that's the standard way of syncing a threadlocal with coroutines, which is what we want to achieve here.\nhttps://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-thread-context-element/", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483427587", "createdAt": "2020-09-04T07:03:33Z", "author": {"login": "anuraaga"}, "path": "instrumentation/java-concurrent/src/main/java/io/opentelemetry/instrumentation/auto/javaconcurrent/KotlinProbeInstrumentation.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.javaconcurrent;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import kotlin.coroutines.Continuation;\n+import kotlin.coroutines.CoroutineContext;\n+import kotlin.jvm.functions.Function2;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+@AutoService(Instrumenter.class)\n+public class KotlinProbeInstrumentation extends Instrumenter.Default {\n+  /*\n+  Kotlin coroutines with suspend functions are a form of cooperative \"userland\" threading\n+  (you might also know this pattern as \"fibers\" or \"green threading\", where the OS/kernel-level thread\n+  has no idea of switching between tasks.  Fortunately kotlin exposes hooks for the key events: knowing when\n+  coroutines are being created, when they are suspended (swapped out/inactive), and when they are resumed (about to\n+  run again).\n+\n+  Without this instrumentation, heavy concurrency and usage of kotlin suspend functions will break causality\n+  and cause nonsensical span parents/context propagation.\n+\n+  The basic strategy here is:\n+  1) Use the DebugProbes callbacks to learn about coroutine create, resume, and suspend operations\n+  2) Wrap the creation Coroutine and its Context and use that wrapping to add an extra Context \"key\"\n+  3) Use the callback for resume and suspend to manipulate our context \"key\" whereby an appropriate state\n+     object can be found (tied to the chain of Continutations in the Coroutine).\n+  4) Do our swapping-context dance with that appropriate state\n+  5) Test with highly concurrent well-known span causality and ensure everything looks right.\n+     Without this instrumentation, this test fails with concurrency=2; with this instrumentation,\n+     it passes with concurrency=200.\n+\n+  I've run the basic shape of this by an expert in kotlin coroutines (Roman Elizarov) and he agreed that the\n+  overhead should be fine for production usage.\n+  */\n+\n+  public KotlinProbeInstrumentation() {\n+    super(\"kotlin-coroutines\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"kotlin.coroutines.jvm.internal.DebugProbesKt\");\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        named(\"probeCoroutineCreated\").and(takesArguments(1)),\n+        CoroutineCreatedAdvice.class.getName());\n+    transformers.put(\n+        named(\"probeCoroutineResumed\").and(takesArguments(1)),\n+        CoroutineResumedAdvice.class.getName());\n+    transformers.put(\n+        named(\"probeCoroutineSuspended\").and(takesArguments(1)),\n+        CoroutineSuspendedAdvice.class.getName());\n+    return transformers;\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      \"io.opentelemetry.instrumentation.auto.javaconcurrent.KotlinProbeInstrumentation$CoroutineWrapper\",\n+      \"io.opentelemetry.instrumentation.auto.javaconcurrent.KotlinProbeInstrumentation$TraceScopeKey\",\n+      \"io.opentelemetry.instrumentation.auto.javaconcurrent.KotlinProbeInstrumentation$CoroutineContextWrapper\",\n+    };\n+  }\n+\n+  public static class CoroutineCreatedAdvice {\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void exit(\n+        @Advice.Return(readOnly = false) kotlin.coroutines.Continuation retVal) {\n+      if (!(retVal instanceof CoroutineWrapper)) {\n+        retVal = new CoroutineWrapper(retVal);\n+      }\n+    }\n+  }\n+\n+  public static class CoroutineResumedAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void enter(\n+        @Advice.Argument(0) final kotlin.coroutines.Continuation continuation) {\n+      continuation.getContext().get(TraceScopeKey.INSTANCE);\n+    }\n+  }\n+\n+  public static class CoroutineSuspendedAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void enter(\n+        @Advice.Argument(0) final kotlin.coroutines.Continuation continuation) {\n+      continuation.getContext().minusKey(TraceScopeKey.INSTANCE);\n+    }\n+  }\n+\n+  public static class TraceScopeKey implements CoroutineContext.Key {\n+    public static final TraceScopeKey INSTANCE = new TraceScopeKey();\n+  }\n+\n+  public static class CoroutineWrapper implements kotlin.coroutines.Continuation {\n+    private final Continuation proxy;\n+    private final CoroutineContextWrapper contextWrapper;\n+\n+    public CoroutineWrapper(Continuation proxy) {\n+      this.proxy = proxy;\n+      this.contextWrapper = new CoroutineContextWrapper(proxy.getContext());\n+    }\n+\n+    public String toString() {\n+      return proxy.toString();\n+    }\n+\n+    @NotNull\n+    @Override\n+    public CoroutineContext getContext() {\n+      return contextWrapper;\n+    }\n+\n+    @Override\n+    public void resumeWith(@NotNull Object o) {\n+      proxy.resumeWith(o);\n+    }\n+  }\n+\n+  public static class CoroutineContextWrapper implements CoroutineContext {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7aae4c4cfe714961f27d62287bbb9134921f51e3"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyODQ1Mw==", "bodyText": "Also, just brainstorming, but is there an approach that wraps dispatchers using something like https://grpc.github.io/grpc-java/javadoc/io/grpc/Context.html#currentContextExecutor-java.util.concurrent.Executor- ? I have no idea the pros/cons for kotlin :) But in Java, my goto for context propagation is usually a wrapped Executor so it just came to mind. I've used this approach in some of the only kotlin I've ever written outside of build scripts.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483428453", "createdAt": "2020-09-04T07:05:34Z", "author": {"login": "anuraaga"}, "path": "instrumentation/java-concurrent/src/main/java/io/opentelemetry/instrumentation/auto/javaconcurrent/KotlinProbeInstrumentation.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.javaconcurrent;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import kotlin.coroutines.Continuation;\n+import kotlin.coroutines.CoroutineContext;\n+import kotlin.jvm.functions.Function2;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+@AutoService(Instrumenter.class)\n+public class KotlinProbeInstrumentation extends Instrumenter.Default {\n+  /*\n+  Kotlin coroutines with suspend functions are a form of cooperative \"userland\" threading\n+  (you might also know this pattern as \"fibers\" or \"green threading\", where the OS/kernel-level thread\n+  has no idea of switching between tasks.  Fortunately kotlin exposes hooks for the key events: knowing when\n+  coroutines are being created, when they are suspended (swapped out/inactive), and when they are resumed (about to\n+  run again).\n+\n+  Without this instrumentation, heavy concurrency and usage of kotlin suspend functions will break causality\n+  and cause nonsensical span parents/context propagation.\n+\n+  The basic strategy here is:\n+  1) Use the DebugProbes callbacks to learn about coroutine create, resume, and suspend operations\n+  2) Wrap the creation Coroutine and its Context and use that wrapping to add an extra Context \"key\"\n+  3) Use the callback for resume and suspend to manipulate our context \"key\" whereby an appropriate state\n+     object can be found (tied to the chain of Continutations in the Coroutine).\n+  4) Do our swapping-context dance with that appropriate state\n+  5) Test with highly concurrent well-known span causality and ensure everything looks right.\n+     Without this instrumentation, this test fails with concurrency=2; with this instrumentation,\n+     it passes with concurrency=200.\n+\n+  I've run the basic shape of this by an expert in kotlin coroutines (Roman Elizarov) and he agreed that the\n+  overhead should be fine for production usage.\n+  */\n+\n+  public KotlinProbeInstrumentation() {\n+    super(\"kotlin-coroutines\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"kotlin.coroutines.jvm.internal.DebugProbesKt\");\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        named(\"probeCoroutineCreated\").and(takesArguments(1)),\n+        CoroutineCreatedAdvice.class.getName());\n+    transformers.put(\n+        named(\"probeCoroutineResumed\").and(takesArguments(1)),\n+        CoroutineResumedAdvice.class.getName());\n+    transformers.put(\n+        named(\"probeCoroutineSuspended\").and(takesArguments(1)),\n+        CoroutineSuspendedAdvice.class.getName());\n+    return transformers;\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      \"io.opentelemetry.instrumentation.auto.javaconcurrent.KotlinProbeInstrumentation$CoroutineWrapper\",\n+      \"io.opentelemetry.instrumentation.auto.javaconcurrent.KotlinProbeInstrumentation$TraceScopeKey\",\n+      \"io.opentelemetry.instrumentation.auto.javaconcurrent.KotlinProbeInstrumentation$CoroutineContextWrapper\",\n+    };\n+  }\n+\n+  public static class CoroutineCreatedAdvice {\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void exit(\n+        @Advice.Return(readOnly = false) kotlin.coroutines.Continuation retVal) {\n+      if (!(retVal instanceof CoroutineWrapper)) {\n+        retVal = new CoroutineWrapper(retVal);\n+      }\n+    }\n+  }\n+\n+  public static class CoroutineResumedAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void enter(\n+        @Advice.Argument(0) final kotlin.coroutines.Continuation continuation) {\n+      continuation.getContext().get(TraceScopeKey.INSTANCE);\n+    }\n+  }\n+\n+  public static class CoroutineSuspendedAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void enter(\n+        @Advice.Argument(0) final kotlin.coroutines.Continuation continuation) {\n+      continuation.getContext().minusKey(TraceScopeKey.INSTANCE);\n+    }\n+  }\n+\n+  public static class TraceScopeKey implements CoroutineContext.Key {\n+    public static final TraceScopeKey INSTANCE = new TraceScopeKey();\n+  }\n+\n+  public static class CoroutineWrapper implements kotlin.coroutines.Continuation {\n+    private final Continuation proxy;\n+    private final CoroutineContextWrapper contextWrapper;\n+\n+    public CoroutineWrapper(Continuation proxy) {\n+      this.proxy = proxy;\n+      this.contextWrapper = new CoroutineContextWrapper(proxy.getContext());\n+    }\n+\n+    public String toString() {\n+      return proxy.toString();\n+    }\n+\n+    @NotNull\n+    @Override\n+    public CoroutineContext getContext() {\n+      return contextWrapper;\n+    }\n+\n+    @Override\n+    public void resumeWith(@NotNull Object o) {\n+      proxy.resumeWith(o);\n+    }\n+  }\n+\n+  public static class CoroutineContextWrapper implements CoroutineContext {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNzU4Nw=="}, "originalCommit": {"oid": "7aae4c4cfe714961f27d62287bbb9134921f51e3"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyOTg2OA==", "bodyText": "Just to confirm, I guess there's no public entrypoint that is similar to this one? For example, we won't have any breakage across kotlin version if we can stick to public APIs than internal ones. One API that comes to mind is startCoroutine\nhttps://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/start-coroutine.html\nPerhaps my other suggestions can bring to light an idea that can keep interception to the public API. But if not, it's ok too we have other instrumentation reliant on private APIs and use muzzle to bite us when something breaks.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483429868", "createdAt": "2020-09-04T07:08:48Z", "author": {"login": "anuraaga"}, "path": "instrumentation/java-concurrent/src/main/java/io/opentelemetry/instrumentation/auto/javaconcurrent/KotlinProbeInstrumentation.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.javaconcurrent;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import kotlin.coroutines.Continuation;\n+import kotlin.coroutines.CoroutineContext;\n+import kotlin.jvm.functions.Function2;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+@AutoService(Instrumenter.class)\n+public class KotlinProbeInstrumentation extends Instrumenter.Default {\n+  /*\n+  Kotlin coroutines with suspend functions are a form of cooperative \"userland\" threading\n+  (you might also know this pattern as \"fibers\" or \"green threading\", where the OS/kernel-level thread\n+  has no idea of switching between tasks.  Fortunately kotlin exposes hooks for the key events: knowing when\n+  coroutines are being created, when they are suspended (swapped out/inactive), and when they are resumed (about to\n+  run again).\n+\n+  Without this instrumentation, heavy concurrency and usage of kotlin suspend functions will break causality\n+  and cause nonsensical span parents/context propagation.\n+\n+  The basic strategy here is:\n+  1) Use the DebugProbes callbacks to learn about coroutine create, resume, and suspend operations\n+  2) Wrap the creation Coroutine and its Context and use that wrapping to add an extra Context \"key\"\n+  3) Use the callback for resume and suspend to manipulate our context \"key\" whereby an appropriate state\n+     object can be found (tied to the chain of Continutations in the Coroutine).\n+  4) Do our swapping-context dance with that appropriate state\n+  5) Test with highly concurrent well-known span causality and ensure everything looks right.\n+     Without this instrumentation, this test fails with concurrency=2; with this instrumentation,\n+     it passes with concurrency=200.\n+\n+  I've run the basic shape of this by an expert in kotlin coroutines (Roman Elizarov) and he agreed that the\n+  overhead should be fine for production usage.\n+  */\n+\n+  public KotlinProbeInstrumentation() {\n+    super(\"kotlin-coroutines\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"kotlin.coroutines.jvm.internal.DebugProbesKt\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7aae4c4cfe714961f27d62287bbb9134921f51e3"}, "originalPosition": 69}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "41d9f17beee5f100821da791ceee1631e17e4fce", "author": {"user": {"login": "johnbley", "name": "John Bley"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/41d9f17beee5f100821da791ceee1631e17e4fce", "committedDate": "2020-09-04T14:25:53Z", "message": "Clarify and improve comments on how/why"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b8346dc04e3b8d9070aa57b066b396b1a772bc4", "author": {"user": {"login": "johnbley", "name": "John Bley"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/9b8346dc04e3b8d9070aa57b066b396b1a772bc4", "committedDate": "2020-09-04T15:06:59Z", "message": "Move kotlin coroutines instrumentation to top-level instrumentation module"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzMDIyNDgz", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#pullrequestreview-483022483", "createdAt": "2020-09-05T02:03:19Z", "commit": {"oid": "9b8346dc04e3b8d9070aa57b066b396b1a772bc4"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQwMjowMzoyMFrOHNey3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQwMjowOToxN1rOHNe1Lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg5ODA3OA==", "bodyText": "Do we need a separate testing project? Can we just merge this into kotlin-coroutines since these are tests for that instrumentation?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483898078", "createdAt": "2020-09-05T02:03:20Z", "author": {"login": "anuraaga"}, "path": "instrumentation/kotlin-coroutines/kotlin-testing/kotlin-testing.gradle", "diffHunk": "@@ -3,6 +3,8 @@ apply from: \"$rootDir/gradle/instrumentation.gradle\"\n apply from: \"$rootDir/gradle/test-with-kotlin.gradle\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b8346dc04e3b8d9070aa57b066b396b1a772bc4"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg5ODY3MA==", "bodyText": "Since we're not instrumenting the JDK we shouldn't need this. We want muzzle to run against kotlin-coroutines versions so that also should be the target rather than an extra dependency. The normal muzzle pattern looks something like this, which is verifying the implementation applies to the range of versions of the library (we're interested in kotlin-coroutine-core).\nhttps://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/master/instrumentation/jetty-8.0/jetty-8.0.gradle#L5", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483898670", "createdAt": "2020-09-05T02:09:17Z", "author": {"login": "anuraaga"}, "path": "instrumentation/kotlin-coroutines/kotlin-coroutines.gradle", "diffHunk": "@@ -0,0 +1,21 @@\n+ext {\n+  // TODO (trask) currently this is only needed for LambdaGen\n+  //  revisit if we don't end up dropping Java 7\n+  minJavaVersionForTests = JavaVersion.VERSION_1_8\n+}\n+\n+apply from: \"$rootDir/gradle/instrumentation.gradle\"\n+\n+muzzle {\n+  pass {\n+    extraDependency('org.jetbrains.kotlin:kotlin-stdlib-common:1.3.72')\n+    extraDependency('org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.7')\n+    coreJdk()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b8346dc04e3b8d9070aa57b066b396b1a772bc4"}, "originalPosition": 13}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "94ba53a9c376753f91edb7f4bfeff0051619b3e8", "author": {"user": {"login": "johnbley", "name": "John Bley"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/94ba53a9c376753f91edb7f4bfeff0051619b3e8", "committedDate": "2020-09-07T18:24:56Z", "message": "Properly build muzzle check for kotlin-coroutines"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "96a2b59f33f904cca47dec3382ce15a498431476", "author": {"user": {"login": "johnbley", "name": "John Bley"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/96a2b59f33f904cca47dec3382ce15a498431476", "committedDate": "2020-09-07T18:31:04Z", "message": "Merge kotlin-testing into regular src/test rather than separate module"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "81f76506e7b31957e25a22ad6cd723fd373470f6", "author": {"user": {"login": "johnbley", "name": "John Bley"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/81f76506e7b31957e25a22ad6cd723fd373470f6", "committedDate": "2020-09-07T18:49:00Z", "message": "Clean up attach/detach logic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b9c1ea6b96204892332d3a88836e26bd70c581c", "author": {"user": {"login": "johnbley", "name": "John Bley"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/0b9c1ea6b96204892332d3a88836e26bd70c581c", "committedDate": "2020-09-07T20:29:58Z", "message": "Tighten bounds and skipVersions on kotlin muzzle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzNzM1NTQz", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#pullrequestreview-483735543", "createdAt": "2020-09-08T00:43:58Z", "commit": {"oid": "0b9c1ea6b96204892332d3a88836e26bd70c581c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzODI5OTEy", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#pullrequestreview-483829912", "createdAt": "2020-09-08T06:32:25Z", "commit": {"oid": "0b9c1ea6b96204892332d3a88836e26bd70c581c"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwNjozMjoyNVrOHOOjFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwNjo0Mzo1N1rOHOO18A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY4MDQ2OA==", "bodyText": "1.4 is not supported?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r484680468", "createdAt": "2020-09-08T06:32:25Z", "author": {"login": "iNikem"}, "path": "instrumentation/kotlin-coroutines/kotlin-coroutines.gradle", "diffHunk": "@@ -0,0 +1,25 @@\n+ext {\n+  // TODO (trask) currently this is only needed for LambdaGen\n+  //  revisit if we don't end up dropping Java 7\n+  minJavaVersionForTests = JavaVersion.VERSION_1_8\n+}\n+\n+apply from: \"$rootDir/gradle/instrumentation.gradle\"\n+apply from: \"$rootDir/gradle/test-with-kotlin.gradle\"\n+muzzle {\n+  pass {\n+    group = 'org.jetbrains.kotlinx'\n+    module = 'kotlinx-coroutines-core'\n+    versions = \"[1.0.0,1.3.8)\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b9c1ea6b96204892332d3a88836e26bd70c581c"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY4MjE5Mw==", "bodyText": "As there are a lot of contexts flying around here, I think it would decrease confusion, if these names somehow referenced \"tracing\" or similar context. To distinguish them from coroutine context.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r484682193", "createdAt": "2020-09-08T06:36:25Z", "author": {"login": "iNikem"}, "path": "instrumentation/kotlin-coroutines/src/main/java/io/opentelemetry/instrumentation/auto/kotlincoroutines/KotlinProbeInstrumentation.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.kotlincoroutines;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import kotlin.coroutines.Continuation;\n+import kotlin.coroutines.CoroutineContext;\n+import kotlin.jvm.functions.Function2;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+@AutoService(Instrumenter.class)\n+public class KotlinProbeInstrumentation extends Instrumenter.Default {\n+  /*\n+  Kotlin coroutines with suspend functions are a form of cooperative \"userland\" threading\n+  (you might also know this pattern as \"fibers\" or \"green threading\", where the OS/kernel-level thread\n+  has no idea of switching between tasks.  Fortunately kotlin exposes hooks for the key events: knowing when\n+  coroutines are being created, when they are suspended (swapped out/inactive), and when they are resumed (about to\n+  run again).\n+\n+  Without this instrumentation, heavy concurrency and usage of kotlin suspend functions will break causality\n+  and cause nonsensical span parents/context propagation.  This is because a single JVM thread will run a series of\n+  coroutines in an \"arbitrary\" order, and a context set by coroutine A (which then gets suspended) will be picked up\n+  by completely-unrelated coroutine B.\n+\n+  The basic strategy here is:\n+  1) Use the DebugProbes callbacks to learn about coroutine create, resume, and suspend operations\n+  2) Wrap the creation Coroutine and its Context and use that wrapping to add an extra Context \"key\"\n+  3) Use the callback for resume and suspend to manipulate our context \"key\" whereby an appropriate state\n+     object can be found (tied to the chain of Continutations in the Coroutine).\n+  4) Do our swapping-context dance with that appropriate state\n+  5) Test with highly concurrent well-known span causality and ensure everything looks right.\n+     Without this instrumentation, this test fails with concurrency=2; with this instrumentation,\n+     it passes with concurrency=200.\n+  */\n+\n+  public KotlinProbeInstrumentation() {\n+    super(\"kotlin-coroutines\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"kotlin.coroutines.jvm.internal.DebugProbesKt\");\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        named(\"probeCoroutineCreated\").and(takesArguments(1)),\n+        CoroutineCreatedAdvice.class.getName());\n+    transformers.put(\n+        named(\"probeCoroutineResumed\").and(takesArguments(1)),\n+        CoroutineResumedAdvice.class.getName());\n+    transformers.put(\n+        named(\"probeCoroutineSuspended\").and(takesArguments(1)),\n+        CoroutineSuspendedAdvice.class.getName());\n+    return transformers;\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      \"io.opentelemetry.instrumentation.auto.kotlincoroutines.KotlinProbeInstrumentation$CoroutineWrapper\",\n+      \"io.opentelemetry.instrumentation.auto.kotlincoroutines.KotlinProbeInstrumentation$TraceScopeKey\",\n+      \"io.opentelemetry.instrumentation.auto.kotlincoroutines.KotlinProbeInstrumentation$CoroutineContextWrapper\",\n+    };\n+  }\n+\n+  public static class CoroutineCreatedAdvice {\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void exit(\n+        @Advice.Return(readOnly = false) kotlin.coroutines.Continuation retVal) {\n+      if (!(retVal instanceof CoroutineWrapper)) {\n+        retVal = new CoroutineWrapper(retVal);\n+      }\n+    }\n+  }\n+\n+  public static class CoroutineResumedAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void enter(\n+        @Advice.Argument(0) final kotlin.coroutines.Continuation continuation) {\n+      continuation.getContext().get(TraceScopeKey.INSTANCE);\n+    }\n+  }\n+\n+  public static class CoroutineSuspendedAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void enter(\n+        @Advice.Argument(0) final kotlin.coroutines.Continuation continuation) {\n+      continuation.getContext().minusKey(TraceScopeKey.INSTANCE);\n+    }\n+  }\n+\n+  public static class TraceScopeKey implements CoroutineContext.Key {\n+    public static final TraceScopeKey INSTANCE = new TraceScopeKey();\n+  }\n+\n+  public static class CoroutineWrapper implements kotlin.coroutines.Continuation {\n+    private final Continuation proxy;\n+    private final CoroutineContextWrapper contextWrapper;\n+\n+    public CoroutineWrapper(Continuation proxy) {\n+      this.proxy = proxy;\n+      this.contextWrapper = new CoroutineContextWrapper(proxy.getContext());\n+    }\n+\n+    public String toString() {\n+      return proxy.toString();\n+    }\n+\n+    @NotNull\n+    @Override\n+    public CoroutineContext getContext() {\n+      return contextWrapper;\n+    }\n+\n+    @Override\n+    public void resumeWith(@NotNull Object o) {\n+      proxy.resumeWith(o);\n+    }\n+  }\n+\n+  public static class CoroutineContextWrapper implements CoroutineContext {\n+    private final CoroutineContext proxy;\n+    private Context myContext;\n+    private Context prevContext;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b9c1ea6b96204892332d3a88836e26bd70c581c"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY4MzA4Nw==", "bodyText": "Reading javadoc for io.grpc.Context#attach, I think you better doing myContext.detach(prevContext) here. Otherwise you just piling contexts on top of each other...", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r484683087", "createdAt": "2020-09-08T06:38:43Z", "author": {"login": "iNikem"}, "path": "instrumentation/kotlin-coroutines/src/main/java/io/opentelemetry/instrumentation/auto/kotlincoroutines/KotlinProbeInstrumentation.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.kotlincoroutines;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import kotlin.coroutines.Continuation;\n+import kotlin.coroutines.CoroutineContext;\n+import kotlin.jvm.functions.Function2;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+@AutoService(Instrumenter.class)\n+public class KotlinProbeInstrumentation extends Instrumenter.Default {\n+  /*\n+  Kotlin coroutines with suspend functions are a form of cooperative \"userland\" threading\n+  (you might also know this pattern as \"fibers\" or \"green threading\", where the OS/kernel-level thread\n+  has no idea of switching between tasks.  Fortunately kotlin exposes hooks for the key events: knowing when\n+  coroutines are being created, when they are suspended (swapped out/inactive), and when they are resumed (about to\n+  run again).\n+\n+  Without this instrumentation, heavy concurrency and usage of kotlin suspend functions will break causality\n+  and cause nonsensical span parents/context propagation.  This is because a single JVM thread will run a series of\n+  coroutines in an \"arbitrary\" order, and a context set by coroutine A (which then gets suspended) will be picked up\n+  by completely-unrelated coroutine B.\n+\n+  The basic strategy here is:\n+  1) Use the DebugProbes callbacks to learn about coroutine create, resume, and suspend operations\n+  2) Wrap the creation Coroutine and its Context and use that wrapping to add an extra Context \"key\"\n+  3) Use the callback for resume and suspend to manipulate our context \"key\" whereby an appropriate state\n+     object can be found (tied to the chain of Continutations in the Coroutine).\n+  4) Do our swapping-context dance with that appropriate state\n+  5) Test with highly concurrent well-known span causality and ensure everything looks right.\n+     Without this instrumentation, this test fails with concurrency=2; with this instrumentation,\n+     it passes with concurrency=200.\n+  */\n+\n+  public KotlinProbeInstrumentation() {\n+    super(\"kotlin-coroutines\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"kotlin.coroutines.jvm.internal.DebugProbesKt\");\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        named(\"probeCoroutineCreated\").and(takesArguments(1)),\n+        CoroutineCreatedAdvice.class.getName());\n+    transformers.put(\n+        named(\"probeCoroutineResumed\").and(takesArguments(1)),\n+        CoroutineResumedAdvice.class.getName());\n+    transformers.put(\n+        named(\"probeCoroutineSuspended\").and(takesArguments(1)),\n+        CoroutineSuspendedAdvice.class.getName());\n+    return transformers;\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      \"io.opentelemetry.instrumentation.auto.kotlincoroutines.KotlinProbeInstrumentation$CoroutineWrapper\",\n+      \"io.opentelemetry.instrumentation.auto.kotlincoroutines.KotlinProbeInstrumentation$TraceScopeKey\",\n+      \"io.opentelemetry.instrumentation.auto.kotlincoroutines.KotlinProbeInstrumentation$CoroutineContextWrapper\",\n+    };\n+  }\n+\n+  public static class CoroutineCreatedAdvice {\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void exit(\n+        @Advice.Return(readOnly = false) kotlin.coroutines.Continuation retVal) {\n+      if (!(retVal instanceof CoroutineWrapper)) {\n+        retVal = new CoroutineWrapper(retVal);\n+      }\n+    }\n+  }\n+\n+  public static class CoroutineResumedAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void enter(\n+        @Advice.Argument(0) final kotlin.coroutines.Continuation continuation) {\n+      continuation.getContext().get(TraceScopeKey.INSTANCE);\n+    }\n+  }\n+\n+  public static class CoroutineSuspendedAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void enter(\n+        @Advice.Argument(0) final kotlin.coroutines.Continuation continuation) {\n+      continuation.getContext().minusKey(TraceScopeKey.INSTANCE);\n+    }\n+  }\n+\n+  public static class TraceScopeKey implements CoroutineContext.Key {\n+    public static final TraceScopeKey INSTANCE = new TraceScopeKey();\n+  }\n+\n+  public static class CoroutineWrapper implements kotlin.coroutines.Continuation {\n+    private final Continuation proxy;\n+    private final CoroutineContextWrapper contextWrapper;\n+\n+    public CoroutineWrapper(Continuation proxy) {\n+      this.proxy = proxy;\n+      this.contextWrapper = new CoroutineContextWrapper(proxy.getContext());\n+    }\n+\n+    public String toString() {\n+      return proxy.toString();\n+    }\n+\n+    @NotNull\n+    @Override\n+    public CoroutineContext getContext() {\n+      return contextWrapper;\n+    }\n+\n+    @Override\n+    public void resumeWith(@NotNull Object o) {\n+      proxy.resumeWith(o);\n+    }\n+  }\n+\n+  public static class CoroutineContextWrapper implements CoroutineContext {\n+    private final CoroutineContext proxy;\n+    private Context myContext;\n+    private Context prevContext;\n+\n+    public CoroutineContextWrapper(CoroutineContext proxy) {\n+      this.proxy = proxy;\n+      this.myContext = Context.current();\n+    }\n+\n+    @Override\n+    public <R> R fold(R r, @NotNull Function2<? super R, ? super Element, ? extends R> function2) {\n+      return proxy.fold(r, function2);\n+    }\n+\n+    @Nullable\n+    @Override\n+    public <E extends Element> E get(@NotNull Key<E> key) {\n+      if (key == TraceScopeKey.INSTANCE) {\n+        prevContext = myContext.attach();\n+      }\n+      return proxy.get(key);\n+    }\n+\n+    @NotNull\n+    @Override\n+    public CoroutineContext minusKey(@NotNull Key<?> key) {\n+      if (key == TraceScopeKey.INSTANCE) {\n+        myContext = prevContext.attach();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b9c1ea6b96204892332d3a88836e26bd70c581c"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY4NDI3MA==", "bodyText": "Are you sure that get with side effect is a good idea? CoroutineResumedAdvice.enter looks strange as well, when you get a value and then ignore it. May be you can extract context manipulation from get and minusKey and do that directly in advice methods?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r484684270", "createdAt": "2020-09-08T06:41:33Z", "author": {"login": "iNikem"}, "path": "instrumentation/kotlin-coroutines/src/main/java/io/opentelemetry/instrumentation/auto/kotlincoroutines/KotlinProbeInstrumentation.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.kotlincoroutines;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import kotlin.coroutines.Continuation;\n+import kotlin.coroutines.CoroutineContext;\n+import kotlin.jvm.functions.Function2;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+@AutoService(Instrumenter.class)\n+public class KotlinProbeInstrumentation extends Instrumenter.Default {\n+  /*\n+  Kotlin coroutines with suspend functions are a form of cooperative \"userland\" threading\n+  (you might also know this pattern as \"fibers\" or \"green threading\", where the OS/kernel-level thread\n+  has no idea of switching between tasks.  Fortunately kotlin exposes hooks for the key events: knowing when\n+  coroutines are being created, when they are suspended (swapped out/inactive), and when they are resumed (about to\n+  run again).\n+\n+  Without this instrumentation, heavy concurrency and usage of kotlin suspend functions will break causality\n+  and cause nonsensical span parents/context propagation.  This is because a single JVM thread will run a series of\n+  coroutines in an \"arbitrary\" order, and a context set by coroutine A (which then gets suspended) will be picked up\n+  by completely-unrelated coroutine B.\n+\n+  The basic strategy here is:\n+  1) Use the DebugProbes callbacks to learn about coroutine create, resume, and suspend operations\n+  2) Wrap the creation Coroutine and its Context and use that wrapping to add an extra Context \"key\"\n+  3) Use the callback for resume and suspend to manipulate our context \"key\" whereby an appropriate state\n+     object can be found (tied to the chain of Continutations in the Coroutine).\n+  4) Do our swapping-context dance with that appropriate state\n+  5) Test with highly concurrent well-known span causality and ensure everything looks right.\n+     Without this instrumentation, this test fails with concurrency=2; with this instrumentation,\n+     it passes with concurrency=200.\n+  */\n+\n+  public KotlinProbeInstrumentation() {\n+    super(\"kotlin-coroutines\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"kotlin.coroutines.jvm.internal.DebugProbesKt\");\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        named(\"probeCoroutineCreated\").and(takesArguments(1)),\n+        CoroutineCreatedAdvice.class.getName());\n+    transformers.put(\n+        named(\"probeCoroutineResumed\").and(takesArguments(1)),\n+        CoroutineResumedAdvice.class.getName());\n+    transformers.put(\n+        named(\"probeCoroutineSuspended\").and(takesArguments(1)),\n+        CoroutineSuspendedAdvice.class.getName());\n+    return transformers;\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      \"io.opentelemetry.instrumentation.auto.kotlincoroutines.KotlinProbeInstrumentation$CoroutineWrapper\",\n+      \"io.opentelemetry.instrumentation.auto.kotlincoroutines.KotlinProbeInstrumentation$TraceScopeKey\",\n+      \"io.opentelemetry.instrumentation.auto.kotlincoroutines.KotlinProbeInstrumentation$CoroutineContextWrapper\",\n+    };\n+  }\n+\n+  public static class CoroutineCreatedAdvice {\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void exit(\n+        @Advice.Return(readOnly = false) kotlin.coroutines.Continuation retVal) {\n+      if (!(retVal instanceof CoroutineWrapper)) {\n+        retVal = new CoroutineWrapper(retVal);\n+      }\n+    }\n+  }\n+\n+  public static class CoroutineResumedAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void enter(\n+        @Advice.Argument(0) final kotlin.coroutines.Continuation continuation) {\n+      continuation.getContext().get(TraceScopeKey.INSTANCE);\n+    }\n+  }\n+\n+  public static class CoroutineSuspendedAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void enter(\n+        @Advice.Argument(0) final kotlin.coroutines.Continuation continuation) {\n+      continuation.getContext().minusKey(TraceScopeKey.INSTANCE);\n+    }\n+  }\n+\n+  public static class TraceScopeKey implements CoroutineContext.Key {\n+    public static final TraceScopeKey INSTANCE = new TraceScopeKey();\n+  }\n+\n+  public static class CoroutineWrapper implements kotlin.coroutines.Continuation {\n+    private final Continuation proxy;\n+    private final CoroutineContextWrapper contextWrapper;\n+\n+    public CoroutineWrapper(Continuation proxy) {\n+      this.proxy = proxy;\n+      this.contextWrapper = new CoroutineContextWrapper(proxy.getContext());\n+    }\n+\n+    public String toString() {\n+      return proxy.toString();\n+    }\n+\n+    @NotNull\n+    @Override\n+    public CoroutineContext getContext() {\n+      return contextWrapper;\n+    }\n+\n+    @Override\n+    public void resumeWith(@NotNull Object o) {\n+      proxy.resumeWith(o);\n+    }\n+  }\n+\n+  public static class CoroutineContextWrapper implements CoroutineContext {\n+    private final CoroutineContext proxy;\n+    private Context myContext;\n+    private Context prevContext;\n+\n+    public CoroutineContextWrapper(CoroutineContext proxy) {\n+      this.proxy = proxy;\n+      this.myContext = Context.current();\n+    }\n+\n+    @Override\n+    public <R> R fold(R r, @NotNull Function2<? super R, ? super Element, ? extends R> function2) {\n+      return proxy.fold(r, function2);\n+    }\n+\n+    @Nullable\n+    @Override\n+    public <E extends Element> E get(@NotNull Key<E> key) {\n+      if (key == TraceScopeKey.INSTANCE) {\n+        prevContext = myContext.attach();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b9c1ea6b96204892332d3a88836e26bd70c581c"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY4NTI5Ng==", "bodyText": "Why do you need scope and delay here?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r484685296", "createdAt": "2020-09-08T06:43:57Z", "author": {"login": "iNikem"}, "path": "instrumentation/kotlin-coroutines/src/test/kotlin/KotlinCoroutineTests.kt", "diffHunk": "@@ -138,6 +140,54 @@ class KotlinCoroutineTests(private val dispatcher: CoroutineDispatcher) {\n     }\n   }\n \n+  fun launchConcurrentSuspendFunctions(numIters: Int) {\n+    runBlocking {\n+      for (i in 0 until numIters) {\n+        GlobalScope.launch {\n+          a(i.toLong())\n+        }\n+        GlobalScope.launch {\n+          b(i.toLong())\n+        }\n+      }\n+    }\n+  }\n+\n+  suspend fun a(iter: Long) {\n+    var span = tracer.spanBuilder(\"a\").startSpan()\n+    span.setAttribute(\"iter\", iter)\n+    var scope = currentContextWith(span)\n+    delay(10)\n+    a2(iter)\n+    scope.close()\n+    span.end()\n+  }\n+  suspend fun a2(iter: Long) {\n+    var span = tracer.spanBuilder(\"a2\").startSpan()\n+    span.setAttribute(\"iter\", iter)\n+    var scope = currentContextWith(span)\n+    delay(10)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b9c1ea6b96204892332d3a88836e26bd70c581c"}, "originalPosition": 45}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c6341880ef31c94f0e7ac6f1c54973419df2afd", "author": {"user": {"login": "johnbley", "name": "John Bley"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/2c6341880ef31c94f0e7ac6f1c54973419df2afd", "committedDate": "2020-09-08T15:56:08Z", "message": "Rename fields and clean up attach logic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4248e57013ed84e077048d597e9b23de321fa5de", "author": {"user": {"login": "johnbley", "name": "John Bley"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/4248e57013ed84e077048d597e9b23de321fa5de", "committedDate": "2020-09-08T16:19:48Z", "message": "Clean up types/side-effect code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a5a803e4e69468bf86534a0aff692f3f002d11c", "author": {"user": {"login": "johnbley", "name": "John Bley"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/1a5a803e4e69468bf86534a0aff692f3f002d11c", "committedDate": "2020-09-08T17:01:58Z", "message": "spotlessApply"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4e65d795911654c0122d5281435e3f5ad9d4d0d", "author": {"user": {"login": "johnbley", "name": "John Bley"}}, "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/e4e65d795911654c0122d5281435e3f5ad9d4d0d", "committedDate": "2020-09-08T21:48:45Z", "message": "Enhance muzzle testing to properly test latest kotlin.\nRequired updating a few kotlin-y things to latest version to properly resolve the jvm\nvariant of their new multiplatform stuff."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NjM5MjIz", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#pullrequestreview-484639223", "createdAt": "2020-09-09T03:40:31Z", "commit": {"oid": "e4e65d795911654c0122d5281435e3f5ad9d4d0d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2561, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}