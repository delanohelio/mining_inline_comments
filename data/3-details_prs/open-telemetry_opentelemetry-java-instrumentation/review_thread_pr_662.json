{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ3NTkxMDc0", "number": 662, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxOTowMDozMVrOENYnjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxOTozMzoxMVrOENZKFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNDcwMjg1OnYy", "diffSide": "RIGHT", "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/HttpServerTracer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxOTowMDozMVrOGwCiDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxOTowMDozMVrOGwCiDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAyNjMxOA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/662#discussion_r453026318", "createdAt": "2020-07-10T19:00:31Z", "author": {"login": "trask"}, "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/HttpServerTracer.java", "diffHunk": "@@ -226,8 +226,11 @@ protected Throwable unwrapThrowable(Throwable throwable) {\n   }\n \n   private <C> SpanContext extract(final C carrier, final HttpTextFormat.Getter<C> getter) {\n+    // Using Context.ROOT here may be quite unexpected, but the reason is simple.\n+    // We want either span context extracted from the carrier or invalid one.\n+    // We DO NOT want any span context potentially lingering in the current context.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f15b68c3f0f5375b1a2f4046598cb3e9824f127"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNDc4NTY5OnYy", "diffSide": "RIGHT", "path": "auto-exporters/logging/src/main/java/io/opentelemetry/auto/exporters/logging/LoggingExporter.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxOTozMTowNlrOGwDWIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxOTo0NDo0MVrOGwDroQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAzOTY0OA==", "bodyText": "Not directly relevant to this PR, but why do we have one of these here, when we have one in the main repo?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/662#discussion_r453039648", "createdAt": "2020-07-10T19:31:06Z", "author": {"login": "jkwatson"}, "path": "auto-exporters/logging/src/main/java/io/opentelemetry/auto/exporters/logging/LoggingExporter.java", "diffHunk": "@@ -17,10 +17,10 @@\n package io.opentelemetry.auto.exporters.logging;\n \n import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.ReadableKeyValuePairs.KeyValueConsumer;\n import io.opentelemetry.sdk.trace.data.SpanData;\n import io.opentelemetry.sdk.trace.export.SpanExporter;\n import java.util.Collection;\n-import java.util.Map;\n \n public class LoggingExporter implements SpanExporter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a05d3c2819e0dd4342b06c1f0c6d51fd8814ece1"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA0Mjc3Ng==", "bodyText": "That is a great question. Please, file a bug to us :)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/662#discussion_r453042776", "createdAt": "2020-07-10T19:38:44Z", "author": {"login": "iNikem"}, "path": "auto-exporters/logging/src/main/java/io/opentelemetry/auto/exporters/logging/LoggingExporter.java", "diffHunk": "@@ -17,10 +17,10 @@\n package io.opentelemetry.auto.exporters.logging;\n \n import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.ReadableKeyValuePairs.KeyValueConsumer;\n import io.opentelemetry.sdk.trace.data.SpanData;\n import io.opentelemetry.sdk.trace.export.SpanExporter;\n import java.util.Collection;\n-import java.util.Map;\n \n public class LoggingExporter implements SpanExporter {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAzOTY0OA=="}, "originalCommit": {"oid": "a05d3c2819e0dd4342b06c1f0c6d51fd8814ece1"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA0NTE1Mw==", "bodyText": "will do. I think yours has much cleaner output, but it's also not using a logging framework, but just using System.out so maybe they're not compatible?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/662#discussion_r453045153", "createdAt": "2020-07-10T19:44:41Z", "author": {"login": "jkwatson"}, "path": "auto-exporters/logging/src/main/java/io/opentelemetry/auto/exporters/logging/LoggingExporter.java", "diffHunk": "@@ -17,10 +17,10 @@\n package io.opentelemetry.auto.exporters.logging;\n \n import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.ReadableKeyValuePairs.KeyValueConsumer;\n import io.opentelemetry.sdk.trace.data.SpanData;\n import io.opentelemetry.sdk.trace.export.SpanExporter;\n import java.util.Collection;\n-import java.util.Map;\n \n public class LoggingExporter implements SpanExporter {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAzOTY0OA=="}, "originalCommit": {"oid": "a05d3c2819e0dd4342b06c1f0c6d51fd8814ece1"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNDc5MTI0OnYy", "diffSide": "RIGHT", "path": "instrumentation/opentelemetry-api-beta/src/test/groovy/MeterTest.groovy", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxOTozMzoxMVrOGwDZnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxOTo1NTozMFrOGwD9QQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA0MDU0MA==", "bodyText": "import?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/662#discussion_r453040540", "createdAt": "2020-07-10T19:33:11Z", "author": {"login": "jkwatson"}, "path": "instrumentation/opentelemetry-api-beta/src/test/groovy/MeterTest.groovy", "diffHunk": "@@ -96,34 +92,34 @@ class MeterTest extends AgentTestRunner {\n     def instrument = meter.\"$builderMethod\"(\"test\")\n       .setDescription(\"d\")\n       .setUnit(\"u\")\n-      .setConstantLabels([\"m\": \"n\", \"o\": \"p\"])\n+      .setConstantLabels(Labels.of(\"m\", \"n\", \"o\", \"p\"))\n       .build()\n     if (bind) {\n-      instrument = instrument.bind()\n+      instrument = instrument.bind(Labels.empty())\n     }\n     if (bind) {\n       instrument.record(value1)\n       instrument.record(value2)\n     } else {\n-      instrument.record(value1, \"q\", \"r\")\n-      instrument.record(value2, \"q\", \"r\")\n+      instrument.record(value1, Labels.of(\"q\", \"r\"))\n+      instrument.record(value2, Labels.of(\"q\", \"r\"))\n     }\n \n     then:\n-    def metricData = metricData(instrumentationName, \"test\")\n+    def metricData = findMetric(OpenTelemetrySdk.getMeterProvider().getMetricProducer().getAllMetrics(), instrumentationName, \"test\")\n     metricData != null\n     metricData.descriptor.description == \"d\"\n     metricData.descriptor.unit == \"u\"\n     metricData.descriptor.type == SUMMARY\n-    metricData.descriptor.constantLabels == [\"m\": \"n\", \"o\": \"p\"]\n+    metricData.descriptor.constantLabels == io.opentelemetry.common.Labels.of(\"m\", \"n\", \"o\", \"p\")\n     metricData.instrumentationLibraryInfo.name == instrumentationName\n     metricData.instrumentationLibraryInfo.version == \"1.2.3\"\n     metricData.points.size() == 1\n     def point = metricData.points.iterator().next()\n     if (bind) {\n-      point.labels == [\"w\": \"x\", \"y\": \"z\"]\n+      point.labels == io.opentelemetry.common.Labels.of(\"w\", \"x\", \"y\", \"z\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a05d3c2819e0dd4342b06c1f0c6d51fd8814ece1"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA0MzE5Mg==", "bodyText": "We already have an import for unshaded.io.opentelemetry.common.Labels, which is used for creating instruments.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/662#discussion_r453043192", "createdAt": "2020-07-10T19:39:47Z", "author": {"login": "iNikem"}, "path": "instrumentation/opentelemetry-api-beta/src/test/groovy/MeterTest.groovy", "diffHunk": "@@ -96,34 +92,34 @@ class MeterTest extends AgentTestRunner {\n     def instrument = meter.\"$builderMethod\"(\"test\")\n       .setDescription(\"d\")\n       .setUnit(\"u\")\n-      .setConstantLabels([\"m\": \"n\", \"o\": \"p\"])\n+      .setConstantLabels(Labels.of(\"m\", \"n\", \"o\", \"p\"))\n       .build()\n     if (bind) {\n-      instrument = instrument.bind()\n+      instrument = instrument.bind(Labels.empty())\n     }\n     if (bind) {\n       instrument.record(value1)\n       instrument.record(value2)\n     } else {\n-      instrument.record(value1, \"q\", \"r\")\n-      instrument.record(value2, \"q\", \"r\")\n+      instrument.record(value1, Labels.of(\"q\", \"r\"))\n+      instrument.record(value2, Labels.of(\"q\", \"r\"))\n     }\n \n     then:\n-    def metricData = metricData(instrumentationName, \"test\")\n+    def metricData = findMetric(OpenTelemetrySdk.getMeterProvider().getMetricProducer().getAllMetrics(), instrumentationName, \"test\")\n     metricData != null\n     metricData.descriptor.description == \"d\"\n     metricData.descriptor.unit == \"u\"\n     metricData.descriptor.type == SUMMARY\n-    metricData.descriptor.constantLabels == [\"m\": \"n\", \"o\": \"p\"]\n+    metricData.descriptor.constantLabels == io.opentelemetry.common.Labels.of(\"m\", \"n\", \"o\", \"p\")\n     metricData.instrumentationLibraryInfo.name == instrumentationName\n     metricData.instrumentationLibraryInfo.version == \"1.2.3\"\n     metricData.points.size() == 1\n     def point = metricData.points.iterator().next()\n     if (bind) {\n-      point.labels == [\"w\": \"x\", \"y\": \"z\"]\n+      point.labels == io.opentelemetry.common.Labels.of(\"w\", \"x\", \"y\", \"z\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA0MDU0MA=="}, "originalCommit": {"oid": "a05d3c2819e0dd4342b06c1f0c6d51fd8814ece1"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA0OTY2NQ==", "bodyText": "oh I see. carry on, then.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/662#discussion_r453049665", "createdAt": "2020-07-10T19:55:30Z", "author": {"login": "jkwatson"}, "path": "instrumentation/opentelemetry-api-beta/src/test/groovy/MeterTest.groovy", "diffHunk": "@@ -96,34 +92,34 @@ class MeterTest extends AgentTestRunner {\n     def instrument = meter.\"$builderMethod\"(\"test\")\n       .setDescription(\"d\")\n       .setUnit(\"u\")\n-      .setConstantLabels([\"m\": \"n\", \"o\": \"p\"])\n+      .setConstantLabels(Labels.of(\"m\", \"n\", \"o\", \"p\"))\n       .build()\n     if (bind) {\n-      instrument = instrument.bind()\n+      instrument = instrument.bind(Labels.empty())\n     }\n     if (bind) {\n       instrument.record(value1)\n       instrument.record(value2)\n     } else {\n-      instrument.record(value1, \"q\", \"r\")\n-      instrument.record(value2, \"q\", \"r\")\n+      instrument.record(value1, Labels.of(\"q\", \"r\"))\n+      instrument.record(value2, Labels.of(\"q\", \"r\"))\n     }\n \n     then:\n-    def metricData = metricData(instrumentationName, \"test\")\n+    def metricData = findMetric(OpenTelemetrySdk.getMeterProvider().getMetricProducer().getAllMetrics(), instrumentationName, \"test\")\n     metricData != null\n     metricData.descriptor.description == \"d\"\n     metricData.descriptor.unit == \"u\"\n     metricData.descriptor.type == SUMMARY\n-    metricData.descriptor.constantLabels == [\"m\": \"n\", \"o\": \"p\"]\n+    metricData.descriptor.constantLabels == io.opentelemetry.common.Labels.of(\"m\", \"n\", \"o\", \"p\")\n     metricData.instrumentationLibraryInfo.name == instrumentationName\n     metricData.instrumentationLibraryInfo.version == \"1.2.3\"\n     metricData.points.size() == 1\n     def point = metricData.points.iterator().next()\n     if (bind) {\n-      point.labels == [\"w\": \"x\", \"y\": \"z\"]\n+      point.labels == io.opentelemetry.common.Labels.of(\"w\", \"x\", \"y\", \"z\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA0MDU0MA=="}, "originalCommit": {"oid": "a05d3c2819e0dd4342b06c1f0c6d51fd8814ece1"}, "originalPosition": 96}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 369, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}