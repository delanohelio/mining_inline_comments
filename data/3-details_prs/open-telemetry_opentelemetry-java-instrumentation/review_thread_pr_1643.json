{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIxNTI0NDIy", "number": 1643, "reviewThreads": {"totalCount": 60, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOToxNDo1OVrOE5VnrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QxMTowODozOVrOFIitOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTU4NTA5OnYy", "diffSide": "RIGHT", "path": "javaagent-spi/src/main/java/io/opentelemetry/javaagent/spi/exporter/SpanExporterFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOToxNDo1OVrOHzuyOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOToxNDo1OVrOHzuyOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAwNTk0Nw==", "bodyText": "Quick and dirty - I think better is to have a otel_ flag to disable batch span processor since some people may want to do so.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r524005947", "createdAt": "2020-11-16T09:14:59Z", "author": {"login": "anuraaga"}, "path": "javaagent-spi/src/main/java/io/opentelemetry/javaagent/spi/exporter/SpanExporterFactory.java", "diffHunk": "@@ -32,4 +32,9 @@\n    * @return The exporter names supported by this factory\n    */\n   Set<String> getNames();\n+\n+  /** Returns whether the batch span processor should not be used with this exporter. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2f1604e43052ce3c668e774f1826e9c1257b04e"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTYwMTg0OnYy", "diffSide": "RIGHT", "path": "testing-common/src/main/java/io/opentelemetry/javaagent/testing/common/AgentTestingExporterAccess.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOToxNzoyNlrOHzu9jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOToxNzoyNlrOHzu9jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAwODg0Nw==", "bodyText": "Annoying - but seems a simple way to get exported spans across the classloader. However, I will play with whether Jackson can marshal them for free (the SpanWrapper worries me)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r524008847", "createdAt": "2020-11-16T09:17:26Z", "author": {"login": "anuraaga"}, "path": "testing-common/src/main/java/io/opentelemetry/javaagent/testing/common/AgentTestingExporterAccess.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.testing.common;\n+\n+import static io.opentelemetry.api.common.AttributeKey.booleanArrayKey;\n+import static io.opentelemetry.api.common.AttributeKey.doubleArrayKey;\n+import static io.opentelemetry.api.common.AttributeKey.longArrayKey;\n+import static io.opentelemetry.api.common.AttributeKey.stringArrayKey;\n+\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import io.opentelemetry.api.common.Attributes;\n+import io.opentelemetry.api.trace.Span.Kind;\n+import io.opentelemetry.api.trace.SpanContext;\n+import io.opentelemetry.api.trace.SpanId;\n+import io.opentelemetry.api.trace.StatusCode;\n+import io.opentelemetry.api.trace.TraceFlags;\n+import io.opentelemetry.api.trace.TraceId;\n+import io.opentelemetry.api.trace.TraceState;\n+import io.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest;\n+import io.opentelemetry.proto.common.v1.AnyValue;\n+import io.opentelemetry.proto.common.v1.ArrayValue;\n+import io.opentelemetry.proto.common.v1.InstrumentationLibrary;\n+import io.opentelemetry.proto.common.v1.KeyValue;\n+import io.opentelemetry.proto.resource.v1.Resource;\n+import io.opentelemetry.proto.trace.v1.InstrumentationLibrarySpans;\n+import io.opentelemetry.proto.trace.v1.ResourceSpans;\n+import io.opentelemetry.proto.trace.v1.Span;\n+import io.opentelemetry.proto.trace.v1.Status;\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import io.opentelemetry.sdk.testing.trace.TestSpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+public final class AgentTestingExporterAccess {\n+  private static final char TRACESTATE_KEY_VALUE_DELIMITER = '=';\n+  private static final char TRACESTATE_ENTRY_DELIMITER = ',';\n+  private static final Pattern TRACESTATE_ENTRY_DELIMITER_SPLIT_PATTERN =\n+      Pattern.compile(\"[ \\t]*\" + TRACESTATE_ENTRY_DELIMITER + \"[ \\t]*\");\n+\n+  private static final MethodHandle getExportRequests;\n+  private static final MethodHandle reset;\n+\n+  static {\n+    try {\n+      Class<?> agentTestingExporterFactoryClass =\n+          AgentClassLoaderAccess.loadClass(\n+              \"io.opentelemetry.javaagent.testing.exporter.AgentTestingExporterFactory\");\n+      getExportRequests =\n+          MethodHandles.lookup()\n+              .findStatic(\n+                  agentTestingExporterFactoryClass,\n+                  \"getExportRequests\",\n+                  MethodType.methodType(List.class));\n+      reset =\n+          MethodHandles.lookup()\n+              .findStatic(\n+                  agentTestingExporterFactoryClass, \"reset\", MethodType.methodType(void.class));\n+    } catch (Exception e) {\n+      throw new Error(\"Error accessing fields with reflection.\", e);\n+    }\n+  }\n+\n+  public static void reset() {\n+    try {\n+      reset.invokeExact();\n+    } catch (Throwable t) {\n+      throw new Error(\"Could not invoke reset\", t);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public static List<SpanData> getExportedSpans() {\n+    final List<byte[]> exportRequests;\n+    try {\n+      exportRequests = (List<byte[]>) getExportRequests.invokeExact();\n+    } catch (Throwable t) {\n+      throw new Error(\"Could not invoke getExportRequests\", t);\n+    }\n+\n+    List<ResourceSpans> allResourceSpans =\n+        exportRequests.stream()\n+            .map(\n+                serialized -> {\n+                  try {\n+                    return ExportTraceServiceRequest.parseFrom(serialized);\n+                  } catch (InvalidProtocolBufferException e) {\n+                    throw new Error(e);\n+                  }\n+                })\n+            .flatMap(request -> request.getResourceSpansList().stream())\n+            .collect(Collectors.toList());\n+    List<SpanData> spans = new ArrayList<>();\n+    for (ResourceSpans resourceSpans : allResourceSpans) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2f1604e43052ce3c668e774f1826e9c1257b04e"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTYwNjE2OnYy", "diffSide": "RIGHT", "path": "testing-common/src/main/java/io/opentelemetry/javaagent/testing/common/AgentTestingExporterAccess.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOToxODoxMVrOHzvAxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOToxODoxMVrOHzvAxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAwOTY3MQ==", "bodyText": "I realized this is why a lot of people have problems identifying local root in collector :O", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r524009671", "createdAt": "2020-11-16T09:18:11Z", "author": {"login": "anuraaga"}, "path": "testing-common/src/main/java/io/opentelemetry/javaagent/testing/common/AgentTestingExporterAccess.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.testing.common;\n+\n+import static io.opentelemetry.api.common.AttributeKey.booleanArrayKey;\n+import static io.opentelemetry.api.common.AttributeKey.doubleArrayKey;\n+import static io.opentelemetry.api.common.AttributeKey.longArrayKey;\n+import static io.opentelemetry.api.common.AttributeKey.stringArrayKey;\n+\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import io.opentelemetry.api.common.Attributes;\n+import io.opentelemetry.api.trace.Span.Kind;\n+import io.opentelemetry.api.trace.SpanContext;\n+import io.opentelemetry.api.trace.SpanId;\n+import io.opentelemetry.api.trace.StatusCode;\n+import io.opentelemetry.api.trace.TraceFlags;\n+import io.opentelemetry.api.trace.TraceId;\n+import io.opentelemetry.api.trace.TraceState;\n+import io.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest;\n+import io.opentelemetry.proto.common.v1.AnyValue;\n+import io.opentelemetry.proto.common.v1.ArrayValue;\n+import io.opentelemetry.proto.common.v1.InstrumentationLibrary;\n+import io.opentelemetry.proto.common.v1.KeyValue;\n+import io.opentelemetry.proto.resource.v1.Resource;\n+import io.opentelemetry.proto.trace.v1.InstrumentationLibrarySpans;\n+import io.opentelemetry.proto.trace.v1.ResourceSpans;\n+import io.opentelemetry.proto.trace.v1.Span;\n+import io.opentelemetry.proto.trace.v1.Status;\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import io.opentelemetry.sdk.testing.trace.TestSpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+public final class AgentTestingExporterAccess {\n+  private static final char TRACESTATE_KEY_VALUE_DELIMITER = '=';\n+  private static final char TRACESTATE_ENTRY_DELIMITER = ',';\n+  private static final Pattern TRACESTATE_ENTRY_DELIMITER_SPLIT_PATTERN =\n+      Pattern.compile(\"[ \\t]*\" + TRACESTATE_ENTRY_DELIMITER + \"[ \\t]*\");\n+\n+  private static final MethodHandle getExportRequests;\n+  private static final MethodHandle reset;\n+\n+  static {\n+    try {\n+      Class<?> agentTestingExporterFactoryClass =\n+          AgentClassLoaderAccess.loadClass(\n+              \"io.opentelemetry.javaagent.testing.exporter.AgentTestingExporterFactory\");\n+      getExportRequests =\n+          MethodHandles.lookup()\n+              .findStatic(\n+                  agentTestingExporterFactoryClass,\n+                  \"getExportRequests\",\n+                  MethodType.methodType(List.class));\n+      reset =\n+          MethodHandles.lookup()\n+              .findStatic(\n+                  agentTestingExporterFactoryClass, \"reset\", MethodType.methodType(void.class));\n+    } catch (Exception e) {\n+      throw new Error(\"Error accessing fields with reflection.\", e);\n+    }\n+  }\n+\n+  public static void reset() {\n+    try {\n+      reset.invokeExact();\n+    } catch (Throwable t) {\n+      throw new Error(\"Could not invoke reset\", t);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public static List<SpanData> getExportedSpans() {\n+    final List<byte[]> exportRequests;\n+    try {\n+      exportRequests = (List<byte[]>) getExportRequests.invokeExact();\n+    } catch (Throwable t) {\n+      throw new Error(\"Could not invoke getExportRequests\", t);\n+    }\n+\n+    List<ResourceSpans> allResourceSpans =\n+        exportRequests.stream()\n+            .map(\n+                serialized -> {\n+                  try {\n+                    return ExportTraceServiceRequest.parseFrom(serialized);\n+                  } catch (InvalidProtocolBufferException e) {\n+                    throw new Error(e);\n+                  }\n+                })\n+            .flatMap(request -> request.getResourceSpansList().stream())\n+            .collect(Collectors.toList());\n+    List<SpanData> spans = new ArrayList<>();\n+    for (ResourceSpans resourceSpans : allResourceSpans) {\n+      Resource resource = resourceSpans.getResource();\n+      for (InstrumentationLibrarySpans ilSpans :\n+          resourceSpans.getInstrumentationLibrarySpansList()) {\n+        InstrumentationLibrary instrumentationLibrary = ilSpans.getInstrumentationLibrary();\n+        for (Span span : ilSpans.getSpansList()) {\n+          spans.add(\n+              TestSpanData.builder()\n+                  .setTraceId(TraceId.bytesToHex(span.getTraceId().toByteArray()))\n+                  .setSpanId(SpanId.bytesToHex(span.getSpanId().toByteArray()))\n+                  .setTraceState(extractTraceState(span.getTraceState()))\n+                  .setParentSpanId(SpanId.bytesToHex(span.getParentSpanId().toByteArray()))\n+                  .setResource(\n+                      io.opentelemetry.sdk.resources.Resource.create(\n+                          fromProto(resource.getAttributesList())))\n+                  .setInstrumentationLibraryInfo(\n+                      InstrumentationLibraryInfo.create(\n+                          instrumentationLibrary.getName(), instrumentationLibrary.getVersion()))\n+                  .setName(span.getName())\n+                  .setStartEpochNanos(span.getStartTimeUnixNano())\n+                  .setEndEpochNanos(span.getEndTimeUnixNano())\n+                  .setAttributes(fromProto(span.getAttributesList()))\n+                  .setEvents(\n+                      span.getEventsList().stream()\n+                          .map(\n+                              event ->\n+                                  SpanData.Event.create(\n+                                      event.getTimeUnixNano(),\n+                                      event.getName(),\n+                                      fromProto(event.getAttributesList()),\n+                                      event.getDroppedAttributesCount()\n+                                          + event.getAttributesCount()))\n+                          .collect(Collectors.toList()))\n+                  .setStatus(fromProto(span.getStatus()))\n+                  .setKind(fromProto(span.getKind()))\n+                  .setLinks(\n+                      span.getLinksList().stream()\n+                          .map(\n+                              link ->\n+                                  SpanData.Link.create(\n+                                      SpanContext.create(\n+                                          TraceId.bytesToHex(link.getTraceId().toByteArray()),\n+                                          SpanId.bytesToHex(link.getSpanId().toByteArray()),\n+                                          TraceFlags.getDefault(),\n+                                          extractTraceState(link.getTraceState())),\n+                                      fromProto(link.getAttributesList()),\n+                                      link.getDroppedAttributesCount() + link.getAttributesCount()))\n+                          .collect(Collectors.toList()))\n+                  // OTLP doesn't have hasRemoteParent", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2f1604e43052ce3c668e774f1826e9c1257b04e"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTYxNjc1OnYy", "diffSide": "RIGHT", "path": "testing/agent-exporter/src/main/java/io/opentelemetry/javaagent/testing/exporter/OtlpInMemorySpanExporter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOToxOTo0NFrOHzvHdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOToxOTo0NFrOHzvHdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAxMTM4Mg==", "bodyText": "Realized I shouldn't drain here since we want to be able to wait for traces.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r524011382", "createdAt": "2020-11-16T09:19:44Z", "author": {"login": "anuraaga"}, "path": "testing/agent-exporter/src/main/java/io/opentelemetry/javaagent/testing/exporter/OtlpInMemorySpanExporter.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.testing.exporter;\n+\n+import io.grpc.Server;\n+import io.grpc.inprocess.InProcessChannelBuilder;\n+import io.grpc.inprocess.InProcessServerBuilder;\n+import io.grpc.stub.StreamObserver;\n+import io.opentelemetry.exporter.otlp.OtlpGrpcSpanExporter;\n+import io.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest;\n+import io.opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse;\n+import io.opentelemetry.proto.collector.trace.v1.TraceServiceGrpc;\n+import io.opentelemetry.sdk.common.CompletableResultCode;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+class OtlpInMemorySpanExporter implements SpanExporter {\n+\n+  private final BlockingQueue<ExportTraceServiceRequest> collectedRequests =\n+      new LinkedBlockingQueue<>();\n+\n+  List<byte[]> getCollectedExportRequests() {\n+    List<ExportTraceServiceRequest> collected = new ArrayList<>(collectedRequests.size());\n+    collectedRequests.drainTo(collected);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2f1604e43052ce3c668e774f1826e9c1257b04e"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTYyMTA5OnYy", "diffSide": "RIGHT", "path": "testing/agent-for-testing/agent-for-testing.gradle", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOToyMDoyM1rOHzvKUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOToyMDoyM1rOHzvKUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAxMjExNQ==", "bodyText": "This project is essentially a \"custom distro\", with no instrumentation included, and the testing exporter included.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r524012115", "createdAt": "2020-11-16T09:20:23Z", "author": {"login": "anuraaga"}, "path": "testing/agent-for-testing/agent-for-testing.gradle", "diffHunk": "@@ -0,0 +1,80 @@\n+plugins {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2f1604e43052ce3c668e774f1826e9c1257b04e"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTYyMzkwOnYy", "diffSide": "RIGHT", "path": "testing/agent-for-testing/agent-for-testing.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOToyMDo0NlrOHzvMFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo0Mzo0OFrOHzwxVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAxMjU2NA==", "bodyText": "This test is using OpenTelemetry API, I loaded the instrumentation in here.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r524012564", "createdAt": "2020-11-16T09:20:46Z", "author": {"login": "anuraaga"}, "path": "testing/agent-for-testing/agent-for-testing.gradle", "diffHunk": "@@ -0,0 +1,80 @@\n+plugins {\n+  id \"com.github.johnrengelman.shadow\"\n+}\n+\n+apply from: \"$rootDir/gradle/java.gradle\"\n+\n+jar {\n+  manifest {\n+    attributes(\n+      \"Main-Class\": \"io.opentelemetry.javaagent.OpenTelemetryAgent\",\n+      \"Agent-Class\": \"io.opentelemetry.javaagent.OpenTelemetryAgent\",\n+      \"Premain-Class\": \"io.opentelemetry.javaagent.OpenTelemetryAgent\",\n+      \"Can-Redefine-Classes\": true,\n+      \"Can-Retransform-Classes\": true,\n+    )\n+  }\n+}\n+\n+CopySpec isolateSpec(Collection<Jar> shadowJarTasks) {\n+  return copySpec {\n+    from({ shadowJarTasks.collect { zipTree(it.archiveFile) } }) {\n+      // important to keep prefix 'inst' short, as it is prefixed to lots of strings in runtime mem\n+      into 'inst'\n+      rename '(^.*)\\\\.class$', '$1.classdata'\n+      // Rename LICENSE file since it clashes with license dir on non-case sensitive FSs (i.e. Mac)\n+      rename '^LICENSE$', 'LICENSE.renamed'\n+    }\n+  }\n+}\n+\n+configurations {\n+  shadowInclude\n+}\n+\n+shadowJar {\n+  configurations = [project.configurations.shadowInclude]\n+  archiveFileName = 'javaagent-for-testing.jar'\n+\n+  dependsOn ':testing:agent-exporter:shadowJar'\n+  with isolateSpec([project(':testing:agent-exporter').tasks.shadowJar])\n+\n+  manifest {\n+    inheritFrom project.tasks.jar.manifest\n+  }\n+\n+  mergeServiceFiles()\n+\n+  exclude '**/module-info.class'\n+\n+  // Prevents conflict with other SLF4J instances. Important for premain.\n+  relocate 'org.slf4j', 'io.opentelemetry.javaagent.slf4j'\n+  // rewrite dependencies calling Logger.getLogger\n+  relocate 'java.util.logging.Logger', 'io.opentelemetry.javaagent.bootstrap.PatchLogger'\n+\n+  // prevents conflict with library instrumentation\n+  relocate 'io.opentelemetry.instrumentation.api', 'io.opentelemetry.javaagent.shaded.instrumentation.api'\n+\n+  // relocate OpenTelemetry API\n+  relocate \"io.opentelemetry.api\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.api\"\n+  relocate \"io.opentelemetry.context\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.context\"\n+}\n+\n+dependencies {\n+  // Dependencies to include without obfuscation.\n+  shadowInclude project(':javaagent-bootstrap')\n+\n+  testImplementation project(':testing-common')\n+  testImplementation deps.opentelemetryApi\n+}\n+\n+tasks.withType(Test).configureEach {\n+  jvmArgs \"-Dio.opentelemetry.javaagent.slf4j.simpleLogger.defaultLogLevel=debug\"\n+  jvmArgs \"-Dorg.slf4j.simpleLogger.defaultLogLevel=debug\"\n+  jvmArgs \"-Dnet.bytebuddy.raw=true\"\n+  jvmArgs \"-javaagent:${shadowJar.archiveFile.get().asFile.absolutePath}\"\n+  jvmArgs \"-Dotel.initializer.jar=${project(':instrumentation:opentelemetry-api-beta').tasks.shadowJar.archiveFile.get().asFile.absolutePath}\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2f1604e43052ce3c668e774f1826e9c1257b04e"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAzODQ4Nw==", "bodyText": "Ah by the way this stuff will go in instrumentation.gradle once I'm ready to take the leap to the next stage :)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r524038487", "createdAt": "2020-11-16T09:43:48Z", "author": {"login": "anuraaga"}, "path": "testing/agent-for-testing/agent-for-testing.gradle", "diffHunk": "@@ -0,0 +1,80 @@\n+plugins {\n+  id \"com.github.johnrengelman.shadow\"\n+}\n+\n+apply from: \"$rootDir/gradle/java.gradle\"\n+\n+jar {\n+  manifest {\n+    attributes(\n+      \"Main-Class\": \"io.opentelemetry.javaagent.OpenTelemetryAgent\",\n+      \"Agent-Class\": \"io.opentelemetry.javaagent.OpenTelemetryAgent\",\n+      \"Premain-Class\": \"io.opentelemetry.javaagent.OpenTelemetryAgent\",\n+      \"Can-Redefine-Classes\": true,\n+      \"Can-Retransform-Classes\": true,\n+    )\n+  }\n+}\n+\n+CopySpec isolateSpec(Collection<Jar> shadowJarTasks) {\n+  return copySpec {\n+    from({ shadowJarTasks.collect { zipTree(it.archiveFile) } }) {\n+      // important to keep prefix 'inst' short, as it is prefixed to lots of strings in runtime mem\n+      into 'inst'\n+      rename '(^.*)\\\\.class$', '$1.classdata'\n+      // Rename LICENSE file since it clashes with license dir on non-case sensitive FSs (i.e. Mac)\n+      rename '^LICENSE$', 'LICENSE.renamed'\n+    }\n+  }\n+}\n+\n+configurations {\n+  shadowInclude\n+}\n+\n+shadowJar {\n+  configurations = [project.configurations.shadowInclude]\n+  archiveFileName = 'javaagent-for-testing.jar'\n+\n+  dependsOn ':testing:agent-exporter:shadowJar'\n+  with isolateSpec([project(':testing:agent-exporter').tasks.shadowJar])\n+\n+  manifest {\n+    inheritFrom project.tasks.jar.manifest\n+  }\n+\n+  mergeServiceFiles()\n+\n+  exclude '**/module-info.class'\n+\n+  // Prevents conflict with other SLF4J instances. Important for premain.\n+  relocate 'org.slf4j', 'io.opentelemetry.javaagent.slf4j'\n+  // rewrite dependencies calling Logger.getLogger\n+  relocate 'java.util.logging.Logger', 'io.opentelemetry.javaagent.bootstrap.PatchLogger'\n+\n+  // prevents conflict with library instrumentation\n+  relocate 'io.opentelemetry.instrumentation.api', 'io.opentelemetry.javaagent.shaded.instrumentation.api'\n+\n+  // relocate OpenTelemetry API\n+  relocate \"io.opentelemetry.api\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.api\"\n+  relocate \"io.opentelemetry.context\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.context\"\n+}\n+\n+dependencies {\n+  // Dependencies to include without obfuscation.\n+  shadowInclude project(':javaagent-bootstrap')\n+\n+  testImplementation project(':testing-common')\n+  testImplementation deps.opentelemetryApi\n+}\n+\n+tasks.withType(Test).configureEach {\n+  jvmArgs \"-Dio.opentelemetry.javaagent.slf4j.simpleLogger.defaultLogLevel=debug\"\n+  jvmArgs \"-Dorg.slf4j.simpleLogger.defaultLogLevel=debug\"\n+  jvmArgs \"-Dnet.bytebuddy.raw=true\"\n+  jvmArgs \"-javaagent:${shadowJar.archiveFile.get().asFile.absolutePath}\"\n+  jvmArgs \"-Dotel.initializer.jar=${project(':instrumentation:opentelemetry-api-beta').tasks.shadowJar.archiveFile.get().asFile.absolutePath}\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAxMjU2NA=="}, "originalCommit": {"oid": "a2f1604e43052ce3c668e774f1826e9c1257b04e"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTYyNzM3OnYy", "diffSide": "RIGHT", "path": "testing/agent-for-testing/src/test/java/io/opentelemetry/javaagent/testing/AgentForTestingTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOToyMToyMFrOHzvOVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwMTozNTo0NlrOH0g9aA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAxMzE0Mg==", "bodyText": "Goes through instrumentation API bridge, comes back from the SDK exporter through the agent classloader access", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r524013142", "createdAt": "2020-11-16T09:21:20Z", "author": {"login": "anuraaga"}, "path": "testing/agent-for-testing/src/test/java/io/opentelemetry/javaagent/testing/AgentForTestingTest.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.testing;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import io.opentelemetry.api.OpenTelemetry;\n+import io.opentelemetry.javaagent.testing.common.AgentTestingExporterAccess;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+class AgentForTestingTest {\n+\n+  @BeforeEach\n+  void reset() {\n+    AgentTestingExporterAccess.reset();\n+  }\n+\n+  @Test\n+  void empty() {\n+    assertEquals(0, AgentTestingExporterAccess.getExportedSpans().size());\n+  }\n+\n+  @Test\n+  void exportAndRetrieve() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2f1604e43052ce3c668e774f1826e9c1257b04e"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDgyODAwOA==", "bodyText": "\ud83d\udc4f", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r524828008", "createdAt": "2020-11-17T01:35:46Z", "author": {"login": "trask"}, "path": "testing/agent-for-testing/src/test/java/io/opentelemetry/javaagent/testing/AgentForTestingTest.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.testing;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import io.opentelemetry.api.OpenTelemetry;\n+import io.opentelemetry.javaagent.testing.common.AgentTestingExporterAccess;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+class AgentForTestingTest {\n+\n+  @BeforeEach\n+  void reset() {\n+    AgentTestingExporterAccess.reset();\n+  }\n+\n+  @Test\n+  void empty() {\n+    assertEquals(0, AgentTestingExporterAccess.getExportedSpans().size());\n+  }\n+\n+  @Test\n+  void exportAndRetrieve() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAxMzE0Mg=="}, "originalCommit": {"oid": "a2f1604e43052ce3c668e774f1826e9c1257b04e"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MDU1MzQ5OnYy", "diffSide": "RIGHT", "path": "testing-common/src/main/java/io/opentelemetry/javaagent/testing/common/AgentInstallerAccess.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwMToyOToyNFrOH0g0qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwMToyOToyNFrOH0g0qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDgyNTc3MA==", "bodyText": "do we still need this now that running with real javaagent which should call it already?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r524825770", "createdAt": "2020-11-17T01:29:24Z", "author": {"login": "trask"}, "path": "testing-common/src/main/java/io/opentelemetry/javaagent/testing/common/AgentInstallerAccess.java", "diffHunk": "@@ -0,0 +1,60 @@\n+package io.opentelemetry.javaagent.testing.common;\n+\n+import static java.lang.invoke.MethodType.methodType;\n+\n+import io.opentelemetry.javaagent.bootstrap.TransformationListener;\n+import java.lang.instrument.ClassFileTransformer;\n+import java.lang.instrument.Instrumentation;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+\n+public final class AgentInstallerAccess {\n+\n+  private static final MethodHandle getInstrumentation;\n+  private static final MethodHandle installBytebuddyAgent;\n+\n+  static {\n+    try {\n+      Class<?> agentInstallerClass =\n+          AgentClassLoaderAccess.loadClass(\"io.opentelemetry.javaagent.tooling.AgentInstaller\");\n+      MethodHandles.Lookup lookup = MethodHandles.lookup();\n+      getInstrumentation =\n+          lookup.findStatic(\n+              agentInstallerClass, \"getInstrumentation\", methodType(Instrumentation.class));\n+\n+      installBytebuddyAgent =\n+          lookup.findStatic(\n+              agentInstallerClass,\n+              \"installBytebuddyAgent\",\n+              methodType(\n+                  ClassFileTransformer.class,\n+                  Instrumentation.class,\n+                  boolean.class,\n+                  TransformationListener[].class));\n+    } catch (Throwable t) {\n+      throw new Error(\"Could not load agent installer.\", t);\n+    }\n+  }\n+\n+  public static Instrumentation getInstrumentation() {\n+    try {\n+      return (Instrumentation) getInstrumentation.invokeExact();\n+    } catch (Throwable t) {\n+      throw new Error(\"Could not invoke getInstrumentation\", t);\n+    }\n+  }\n+\n+  public static ClassFileTransformer installBytebuddyAgent(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02b72aab66d9c219a3f44289addf339cd6f8ba3b"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MTA4NTQ1OnYy", "diffSide": "RIGHT", "path": "testing/agent-exporter/src/main/java/io/opentelemetry/javaagent/testing/bytebuddy/TestAgentListener.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwNjowNToxMlrOH0lktA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwNjowNToxMlrOH0lktA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDkwMzYwNA==", "bodyText": "nice idea to push this down into the custom distro", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r524903604", "createdAt": "2020-11-17T06:05:12Z", "author": {"login": "trask"}, "path": "testing/agent-exporter/src/main/java/io/opentelemetry/javaagent/testing/bytebuddy/TestAgentListener.java", "diffHunk": "@@ -0,0 +1,115 @@\n+package io.opentelemetry.javaagent.testing.bytebuddy;\n+\n+import io.opentelemetry.javaagent.tooling.matcher.AdditionalLibraryIgnoresMatcher;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+import net.bytebuddy.agent.builder.AgentBuilder;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.dynamic.DynamicType;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.utility.JavaModule;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class TestAgentListener implements AgentBuilder.Listener {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd1eff3977111121bbcd03a57cc04edb5ce5421c"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MTA4NzIxOnYy", "diffSide": "RIGHT", "path": "testing/agent-exporter/src/main/java/io/opentelemetry/javaagent/testing/bytebuddy/TestByteBuddyAgentCustomizer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwNjowNjowM1rOH0llsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwNzozNDo1OFrOH0njjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDkwMzg1Ng==", "bodyText": "cc: @pavolloffay \ud83d\ude01", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r524903856", "createdAt": "2020-11-17T06:06:03Z", "author": {"login": "trask"}, "path": "testing/agent-exporter/src/main/java/io/opentelemetry/javaagent/testing/bytebuddy/TestByteBuddyAgentCustomizer.java", "diffHunk": "@@ -0,0 +1,13 @@\n+package io.opentelemetry.javaagent.testing.bytebuddy;\n+\n+import net.bytebuddy.agent.builder.AgentBuilder;\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.javaagent.spi.ByteBuddyAgentCustomizer;\n+\n+@AutoService(ByteBuddyAgentCustomizer.class)\n+public class TestByteBuddyAgentCustomizer implements ByteBuddyAgentCustomizer {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd1eff3977111121bbcd03a57cc04edb5ce5421c"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDkzNjA3Ng==", "bodyText": "wow that was fast :P. Accessing the engine seems to be useful :D", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r524936076", "createdAt": "2020-11-17T07:34:58Z", "author": {"login": "pavolloffay"}, "path": "testing/agent-exporter/src/main/java/io/opentelemetry/javaagent/testing/bytebuddy/TestByteBuddyAgentCustomizer.java", "diffHunk": "@@ -0,0 +1,13 @@\n+package io.opentelemetry.javaagent.testing.bytebuddy;\n+\n+import net.bytebuddy.agent.builder.AgentBuilder;\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.javaagent.spi.ByteBuddyAgentCustomizer;\n+\n+@AutoService(ByteBuddyAgentCustomizer.class)\n+public class TestByteBuddyAgentCustomizer implements ByteBuddyAgentCustomizer {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDkwMzg1Ng=="}, "originalCommit": {"oid": "dd1eff3977111121bbcd03a57cc04edb5ce5421c"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MTA5Mzk5OnYy", "diffSide": "RIGHT", "path": "testing-common/src/main/groovy/io/opentelemetry/instrumentation/test/AgentTestRunner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwNjowOTozNFrOH0lpqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwNjowOTozNFrOH0lpqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDkwNDg3Mg==", "bodyText": "looks like these can go away too \ud83c\udf89", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r524904872", "createdAt": "2020-11-17T06:09:34Z", "author": {"login": "trask"}, "path": "testing-common/src/main/groovy/io/opentelemetry/instrumentation/test/AgentTestRunner.java", "diffHunk": "@@ -75,12 +68,6 @@\n \n   protected static final Tracer TEST_TRACER;\n \n-  protected static final Set<String> TRANSFORMED_CLASSES_NAMES = Sets.newConcurrentHashSet();\n-  protected static final Set<String> TRANSFORMED_CLASSES_NAMES_THAT_SHOULD_HAVE_BEEN_IGNORED =\n-      Sets.newConcurrentHashSet();\n-  private static final AtomicInteger INSTRUMENTATION_ERROR_COUNT = new AtomicInteger(0);\n-  private static final TestRunnerListener TEST_LISTENER = new TestRunnerListener();\n-\n   private static final Instrumentation INSTRUMENTATION;\n   private static volatile ClassFileTransformer activeTransformer = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd1eff3977111121bbcd03a57cc04edb5ce5421c"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MTEwNjE0OnYy", "diffSide": "RIGHT", "path": "testing-common/src/main/groovy/io/opentelemetry/instrumentation/test/AgentTestRunner.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwNjoxNTowNVrOH0lwjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwNjoxODo0MlrOH0l00A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDkwNjYzOQ==", "bodyText": "maybe we need to add opentelemetry-api-beta as default instrumentation for all tests? lots of tests use TraceUtils.runUnderTrace()", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r524906639", "createdAt": "2020-11-17T06:15:05Z", "author": {"login": "trask"}, "path": "testing-common/src/main/groovy/io/opentelemetry/instrumentation/test/AgentTestRunner.java", "diffHunk": "@@ -105,31 +92,13 @@\n               .addTextMapPropagator(HttpTraceContext.getInstance())\n               .build());\n     }\n-    OpenTelemetrySdk.getGlobalTracerManagement().addSpanProcessor(TEST_WRITER);\n     TEST_TRACER = OpenTelemetry.getGlobalTracer(\"io.opentelemetry.auto\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd1eff3977111121bbcd03a57cc04edb5ce5421c"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDkwNzcyOA==", "bodyText": "Ah I guess that's because previously SDK and API were in the same classloader without bridging so it wasn't necessary, now we do need it. Sounds good", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r524907728", "createdAt": "2020-11-17T06:18:42Z", "author": {"login": "anuraaga"}, "path": "testing-common/src/main/groovy/io/opentelemetry/instrumentation/test/AgentTestRunner.java", "diffHunk": "@@ -105,31 +92,13 @@\n               .addTextMapPropagator(HttpTraceContext.getInstance())\n               .build());\n     }\n-    OpenTelemetrySdk.getGlobalTracerManagement().addSpanProcessor(TEST_WRITER);\n     TEST_TRACER = OpenTelemetry.getGlobalTracer(\"io.opentelemetry.auto\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDkwNjYzOQ=="}, "originalCommit": {"oid": "dd1eff3977111121bbcd03a57cc04edb5ce5421c"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MTYxOTQzOnYy", "diffSide": "RIGHT", "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/AgentInstaller.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwODo1NTo1MlrOH0qgrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwODo1NTo1MlrOH0qgrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk4NDQ5NA==", "bodyText": "I copied the redefinition strategy from other usages in this file but have no clue what I'm doing :P", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r524984494", "createdAt": "2020-11-17T08:55:52Z", "author": {"login": "anuraaga"}, "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/AgentInstaller.java", "diffHunk": "@@ -65,24 +72,29 @@ public static Instrumentation getInstrumentation() {\n \n   public static void installBytebuddyAgent(Instrumentation inst) {\n     if (Config.get().getBooleanProperty(TRACE_ENABLED_CONFIG, true)) {\n-      installBytebuddyAgent(inst, false);\n+      ACTIVE_TRANSFORMER = doInstallBytebuddyAgent(inst);\n     } else {\n       log.debug(\"Tracing is disabled, not installing instrumentations.\");\n     }\n   }\n \n+  public static void resetInstrumentation() {\n+    Instrumentation instrumentation = INSTRUMENTATION;\n+    ResettableClassFileTransformer activeTransformer = ACTIVE_TRANSFORMER;\n+    if (instrumentation != null && activeTransformer != null) {\n+      activeTransformer.reset(INSTRUMENTATION, AgentBuilder.RedefinitionStrategy.RETRANSFORMATION);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e34a57573487606184c22bca71ce3c0e29e08a9"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODMxODEyOnYy", "diffSide": "RIGHT", "path": "gradle/instrumentation.gradle", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMTozODo1OFrOH3MQWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMTozODo1OFrOH3MQWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzYzNDUyMw==", "bodyText": "This seemingly innocent change caused a lot of breakage since guava, previously set by autoservice, ended up getting too new for many of our projects. But it's probably better to have the manual downgrading as now to know about these instead of the luck.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r527634523", "createdAt": "2020-11-20T11:38:58Z", "author": {"login": "anuraaga"}, "path": "gradle/instrumentation.gradle", "diffHunk": "@@ -23,24 +23,24 @@ if (projectDir.name == 'javaagent') {\n \n afterEvaluate {\n   dependencies {\n-    implementation project(':instrumentation-api')\n-    implementation project(':javaagent-api')\n+    compileOnly project(':instrumentation-api')\n+    compileOnly project(':javaagent-api')\n+    compileOnly project(':javaagent-bootstrap')\n     // Apply common dependencies for instrumentation.\n-    implementation(project(':javaagent-tooling')) {\n+    compileOnly(project(':javaagent-tooling')) {\n       // OpenTelemetry SDK is not needed for compilation, and :opentelemetry-sdk-shaded-for-testing\n       // is brought in for tests by project(:testing-common) below\n       exclude group: 'io.opentelemetry', module: 'opentelemetry-sdk'\n     }\n     implementation deps.bytebuddy\n     annotationProcessor deps.autoservice\n-    implementation deps.autoservice\n+    compileOnly deps.autoservice", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec435b69871db64fd850ed34dab18131e7e5317c"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODMyMDM0OnYy", "diffSide": "RIGHT", "path": "gradle/instrumentation.gradle", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMTozOTozM1rOH3MRmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMTozOTozM1rOH3MRmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzYzNDg0MA==", "bodyText": "I realized my previous testing wasn't actually doing what we wanted - the non-shaded classes from the test classpath would still be used from the agent. Now it's always the shaded ones.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r527634840", "createdAt": "2020-11-20T11:39:33Z", "author": {"login": "anuraaga"}, "path": "gradle/instrumentation.gradle", "diffHunk": "@@ -57,3 +57,71 @@ afterEvaluate {\n     sourceSets.main.output.files\n   ]).configure()\n }\n+\n+configurations {\n+  testInstrumentation\n+}\n+\n+shadowJar {\n+  configurations = [project.configurations.runtimeClasspath, project.configurations.testInstrumentation]\n+  mergeServiceFiles()\n+\n+  archiveFileName = 'agent-testing.jar'\n+\n+  dependencies {\n+    exclude(project(':javaagent-bootstrap'))\n+    exclude(project(':instrumentation-api'))\n+    exclude(project(':javaagent-api'))\n+    exclude(project(':javaagent-tooling'))\n+    exclude(dependency(deps.bytebuddy))\n+    exclude(dependency(deps.opentelemetryApi))\n+    exclude(dependency(deps.opentelemetryContext))\n+    exclude(dependency(deps.slf4j))\n+  }\n+\n+  // rewrite library instrumentation dependencies\n+  relocate \"io.opentelemetry.instrumentation\", \"io.opentelemetry.javaagent.shaded.instrumentation\"\n+\n+  // Prevents conflict with other SLF4J instances. Important for premain.\n+  relocate 'org.slf4j', 'io.opentelemetry.javaagent.slf4j'\n+  // rewrite dependencies calling Logger.getLogger\n+  relocate 'java.util.logging.Logger', 'io.opentelemetry.javaagent.bootstrap.PatchLogger'\n+\n+  // prevents conflict with library instrumentation\n+  relocate 'io.opentelemetry.instrumentation.api', 'io.opentelemetry.javaagent.shaded.instrumentation.api'\n+\n+  // relocate OpenTelemetry API usage\n+  relocate \"io.opentelemetry.api\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.api\"\n+  relocate \"io.opentelemetry.context\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.context\"\n+\n+  // this is for instrumentation on opentelemetry-api itself\n+  relocate \"application.io.opentelemetry\", \"io.opentelemetry\"\n+}\n+\n+tasks.withType(Test).configureEach {\n+  jvmArgs \"-Dio.opentelemetry.javaagent.slf4j.simpleLogger.defaultLogLevel=debug\"\n+  jvmArgs \"-Dorg.slf4j.simpleLogger.defaultLogLevel=debug\"\n+  jvmArgs \"-Dnet.bytebuddy.raw=true\"\n+  jvmArgs \"-javaagent:${project(\":testing:agent-for-testing\").buildDir}/libs/javaagent-for-testing.jar\"\n+  jvmArgs \"-Dotel.initializer.jar=${shadowJar.archiveFile.get().asFile.absolutePath}\"\n+  jvmArgs \"-Dinternal.testing.disable.global.library.ignores=true\"\n+\n+  dependsOn shadowJar\n+  dependsOn \":testing:agent-for-testing:shadowJar\"\n+\n+  // The sources are packaged into the testing jar so we need to make sure to exclude from the test\n+  // classpath, which automatically inherits them, to ensure our shaded versions are used.\n+  classpath = classpath.filter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec435b69871db64fd850ed34dab18131e7e5317c"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODMyNTg0OnYy", "diffSide": "RIGHT", "path": "instrumentation/aws-sdk/aws-sdk-2.2/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/awssdk/v2_2/ExecutionInterceptorInstrumentation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMTo0MDo1OFrOH3MUuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMTo0MDo1OFrOH3MUuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzYzNTY0Mw==", "bodyText": "After getting the shading working, I found the aws SDK instrumentation probably currently has a bug, because the helpers are injected when matching HTTP classes, so the first client in an app couldn't be instrumented. Hooray for running tests with real agent.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r527635643", "createdAt": "2020-11-20T11:40:58Z", "author": {"login": "anuraaga"}, "path": "instrumentation/aws-sdk/aws-sdk-2.2/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/awssdk/v2_2/ExecutionInterceptorInstrumentation.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.awssdk.v2_2;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import io.opentelemetry.javaagent.tooling.TypeInstrumentation;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+final class ExecutionInterceptorInstrumentation implements TypeInstrumentation {\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    // This is essentially the entry point of the AWS SDK, all clients implement it. We can ensure", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec435b69871db64fd850ed34dab18131e7e5317c"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODMzNzE2OnYy", "diffSide": "LEFT", "path": "testing-common/src/main/groovy/io/opentelemetry/instrumentation/test/InMemoryExporter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMTo0NDozOVrOH3MbzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMTo0NDozOVrOH3MbzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzYzNzQ1Mg==", "bodyText": "This statement is wrong I think - async instrumentation would have root spans completing early. I'm not sure why this seemed to work ok before my change, but I couldn't get most async tests to pass until changing the waiting logic to be closer to what we do in smoke tests.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r527637452", "createdAt": "2020-11-20T11:44:39Z", "author": {"login": "anuraaga"}, "path": "testing-common/src/main/groovy/io/opentelemetry/instrumentation/test/InMemoryExporter.java", "diffHunk": "@@ -290,37 +214,8 @@ private long getMinSpanOrder(List<SpanData> spans) {\n     return orderedSpans;\n   }\n \n-  private void sortOneLevel(List<Node> nodes) {\n-    Collections.sort(\n-        nodes,\n-        new Comparator<Node>() {\n-          @Override\n-          public int compare(Node node1, Node node2) {\n-            return Ints.compare(getSpanOrder(node1.span), getSpanOrder(node2.span));\n-          }\n-        });\n-  }\n-\n-  private int getSpanOrder(SpanData span) {\n-    Integer order = spanOrders.get(span.getSpanId());\n-    if (order == null) {\n-      throw new IllegalStateException(\"order not found for span: \" + span);\n-    }\n-    return order;\n-  }\n-\n-  // trace is completed if root span is present", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "916fc2e87512df1d80a2bde2fa2161e882650645"}, "originalPosition": 274}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMTg1MjYwOnYy", "diffSide": "RIGHT", "path": "instrumentation/servlet/servlet-common/src/test/groovy/RequestDispatcherTest.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQxMDoyMzozNVrOH3te6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQxMDoyMzozNVrOH3te6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODE3ODkyMg==", "bodyText": "Not sure how to fix these tests, the context objects need to be shaded.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r528178922", "createdAt": "2020-11-21T10:23:35Z", "author": {"login": "anuraaga"}, "path": "instrumentation/servlet/servlet-common/src/test/groovy/RequestDispatcherTest.groovy", "diffHunk": "@@ -61,11 +60,11 @@ class RequestDispatcherTest extends AgentTestRunner {\n     }\n \n     then:\n-    1 * request.getAttribute(CONTEXT_ATTRIBUTE) >> mockContext\n+    1 * request.getAttribute(\"io.opentelemetry.javaagent.shaded.instrumentation.context\") >> mockContext", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06ca46962767f547a3c33e9abffd6d8ca1c62808"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMTg1Mzc1OnYy", "diffSide": "RIGHT", "path": "testing/agent-exporter/agent-exporter.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQxMDoyNDo1NlrOH3tfZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQxMDoyNDo1NlrOH3tfZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODE3OTA0Nw==", "bodyText": "Had forgotten this - surprised most tests still passed without this :O", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r528179047", "createdAt": "2020-11-21T10:24:56Z", "author": {"login": "anuraaga"}, "path": "testing/agent-exporter/agent-exporter.gradle", "diffHunk": "@@ -38,6 +38,10 @@ shadowJar {\n \n   // Prevents conflict with other SLF4J instances. Important for premain.\n   relocate 'org.slf4j', 'io.opentelemetry.javaagent.slf4j'\n+\n+  // rewrite library instrumentation dependencies", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06ca46962767f547a3c33e9abffd6d8ca1c62808"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMjU3NDMwOnYy", "diffSide": "LEFT", "path": "README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMlQwMTowMTo1NlrOH3yrVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMlQwMTowMTo1NlrOH3yrVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODI2NDAyMw==", "bodyText": "unrelated cleanup (just documenting for future reviewers)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r528264023", "createdAt": "2020-11-22T01:01:56Z", "author": {"login": "trask"}, "path": "README.md", "diffHunk": "@@ -279,7 +279,6 @@ Because the automatic instrumentation runs in a different classpath than the ins\n Some instrumentations can produce too many spans and make traces very noisy.\n For this reason, the following instrumentations are disabled by default:\n - `jdbc-datasource` which creates spans whenever the `java.sql.DataSource#getConnection` method is called.\n-- `servlet-service` which creates spans around Servlet methods.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca5a1189ae1f6f494165a9c55c47638acaf329f2"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMjU3NDQ2OnYy", "diffSide": "RIGHT", "path": "examples/distro/instrumentation/build.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMlQwMTowMjowM1rOH3yraA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMlQwMTowMjowM1rOH3yraA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODI2NDA0MA==", "bodyText": "unrelated cleanup (just documenting for future reviewers)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r528264040", "createdAt": "2020-11-22T01:02:03Z", "author": {"login": "trask"}, "path": "examples/distro/instrumentation/build.gradle", "diffHunk": "@@ -50,6 +50,7 @@ shadowJar {\n \n   // relocate OpenTelemetry API usage\n   relocate \"io.opentelemetry.api\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.api\"\n+  relocate \"io.opentelemetry.spi\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.spi\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca5a1189ae1f6f494165a9c55c47638acaf329f2"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMjU3NDk5OnYy", "diffSide": "RIGHT", "path": "gradle/dependencies.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMlQwMTowMjo0MlrOH3yrpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMlQwMTowMjo0MlrOH3yrpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODI2NDEwMA==", "bodyText": "unrelated cleanup (renamed opentelemetryAutoAnnotations to opentelemetryExtAnnotations and everything shifted left)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r528264100", "createdAt": "2020-11-22T01:02:42Z", "author": {"login": "trask"}, "path": "gradle/dependencies.gradle", "diffHunk": "@@ -39,57 +39,58 @@ ext {\n \n   deps = [\n     // OpenTelemetry\n-    opentelemetryApi            : dependencies.create(group: 'io.opentelemetry', name: 'opentelemetry-api', version: versions.opentelemetry),\n-    opentelemetryAutoAnnotations: dependencies.create(group: 'io.opentelemetry', name: 'opentelemetry-extension-annotations', version: versions.opentelemetryAnother),\n-    opentelemetryContext        : dependencies.create(group: 'io.opentelemetry', name: 'opentelemetry-context', version: versions.opentelemetryContext),\n-    opentelemetryTraceProps     : dependencies.create(group: 'io.opentelemetry', name: 'opentelemetry-extension-trace-propagators', version: versions.opentelemetry),\n-    opentelemetrySdk            : dependencies.create(group: 'io.opentelemetry', name: 'opentelemetry-sdk', version: versions.opentelemetryAnother),\n-    opentelemetryJaeger         : dependencies.create(group: 'io.opentelemetry', name: 'opentelemetry-exporter-jaeger', version: versions.opentelemetryOther),\n-    opentelemetryOtlp           : dependencies.create(group: 'io.opentelemetry', name: 'opentelemetry-exporter-otlp', version: versions.opentelemetryOther),\n-    opentelemetryZipkin         : dependencies.create(group: 'io.opentelemetry', name: 'opentelemetry-exporter-zipkin', version: versions.opentelemetryOther),\n-    opentelemetryPrometheus     : dependencies.create(group: 'io.opentelemetry', name: 'opentelemetry-exporter-prometheus', version: versions.opentelemetryOther),\n-    opentelemetryLogging        : dependencies.create(group: 'io.opentelemetry', name: 'opentelemetry-exporter-logging', version: versions.opentelemetryOther),\n-    opentelemetryProto          : dependencies.create(group: 'io.opentelemetry', name: 'opentelemetry-proto', version: versions.opentelemetryAnother),\n+    opentelemetryApi           : dependencies.create(group: 'io.opentelemetry', name: 'opentelemetry-api', version: versions.opentelemetry),\n+    opentelemetryExtAnnotations: dependencies.create(group: 'io.opentelemetry', name: 'opentelemetry-extension-annotations', version: versions.opentelemetryAnother),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca5a1189ae1f6f494165a9c55c47638acaf329f2"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMjU3NTcxOnYy", "diffSide": "RIGHT", "path": "instrumentation/akka-actor-2.5/src/test/scala/AkkaActors.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMlQwMTowNDoyN1rOH3yr-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMlQwMTowNDoyN1rOH3yr-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODI2NDE4Ng==", "bodyText": "unrelated cleanup (just documenting for future reviewers)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r528264186", "createdAt": "2020-11-22T01:04:27Z", "author": {"login": "trask"}, "path": "instrumentation/akka-actor-2.5/src/test/scala/AkkaActors.scala", "diffHunk": "@@ -6,10 +6,8 @@\n import akka.actor.{Actor, ActorLogging, ActorRef, ActorSystem, Props}\n import akka.pattern.ask\n import akka.util.Timeout\n-import io.opentelemetry.api.OpenTelemetry\n-import io.opentelemetry.context.Context\n-import io.opentelemetry.javaagent.instrumentation.api.Java8BytecodeBridge\n import io.opentelemetry.api.trace.Tracer\n+import io.opentelemetry.javaagent.testing.common.Java8BytecodeBridge", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca5a1189ae1f6f494165a9c55c47638acaf329f2"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxOTgyNjUxOnYy", "diffSide": "LEFT", "path": "instrumentation/hystrix-1.4/src/test/groovy/HystrixObservableTest.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwOToyNzozMVrOH40itA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwOToyNzozMVrOH40itA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTM0MzE1Ng==", "bodyText": "These are tested in the span name instead so I didn't bother exposing this through the agent classloader. It'd be simple enough though if we want to keep the functionality, these were the only tests using it though.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r529343156", "createdAt": "2020-11-24T09:27:31Z", "author": {"login": "anuraaga"}, "path": "instrumentation/hystrix-1.4/src/test/groovy/HystrixObservableTest.groovy", "diffHunk": "@@ -62,7 +62,6 @@ class HystrixObservableTest extends AgentTestRunner {\n     }\n \n     expect:\n-    TRANSFORMED_CLASSES_NAMES.contains(\"HystrixObservableTest\\$1\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d76d9dddf8ab8bc33f9bfb57bb88ab67b4e71c23"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxOTgzMTg0OnYy", "diffSide": "LEFT", "path": "instrumentation/jaxrs-client/jaxrs-client-2.0/jaxrs-client-2.0-jersey-2.0/src/main/java/io/opentelemetry/javaagent/instrumentation/jaxrsclient/v2_0/JerseyClientInstrumentationModule.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwOToyODoxOFrOH40mdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwOToyODoxOFrOH40mdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTM0NDExNw==", "bodyText": "Test was failing since groovy eagerly calls getEnclosingClass() on almost everything! But technically this was a bug in our agent since there's nothing stopping (other than mostly having no use case for it) a user from calling getEnclsoingClass() too. As a general pattern we should avoid helper classes that are inner to the instrumentation.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r529344117", "createdAt": "2020-11-24T09:28:18Z", "author": {"login": "anuraaga"}, "path": "instrumentation/jaxrs-client/jaxrs-client-2.0/jaxrs-client-2.0-jersey-2.0/src/main/java/io/opentelemetry/javaagent/instrumentation/jaxrsclient/v2_0/JerseyClientInstrumentationModule.java", "diffHunk": "@@ -104,56 +101,4 @@ public static void handleError(\n     }\n   }\n \n-  public static class WrappedFuture<T> implements Future<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d76d9dddf8ab8bc33f9bfb57bb88ab67b4e71c23"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxOTg0MDQwOnYy", "diffSide": "LEFT", "path": "instrumentation/jaxrs/jaxrs-1.0/src/test/groovy/JaxRsAnnotations1InstrumentationTest.groovy", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwOToyOToyOVrOH40sRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwOToyOToyOVrOH40sRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTM0NTYwNA==", "bodyText": "These tests looked really had to do with the agent separation. We have other caches where we don't have this sort of test, so guessing it's not a huge regression.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r529345604", "createdAt": "2020-11-24T09:29:29Z", "author": {"login": "anuraaga"}, "path": "instrumentation/jaxrs/jaxrs-1.0/src/test/groovy/JaxRsAnnotations1InstrumentationTest.groovy", "diffHunk": "@@ -42,7 +41,6 @@ class JaxRsAnnotations1InstrumentationTest extends AgentTestRunner {\n \n   def \"span named '#name' from annotations on class when is not root span\"() {\n     setup:\n-    def startingCacheSize = spanNames.size()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d76d9dddf8ab8bc33f9bfb57bb88ab67b4e71c23"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxOTg0NTg2OnYy", "diffSide": "RIGHT", "path": "instrumentation/jdbc/src/test/groovy/JdbcInstrumentationTest.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwOTozMDoxMVrOH40vww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwOTozMDoxMVrOH40vww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTM0NjQ5OQ==", "bodyText": "The readability improvement of the tests seems worth it - thanks @trask", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r529346499", "createdAt": "2020-11-24T09:30:11Z", "author": {"login": "anuraaga"}, "path": "instrumentation/jdbc/src/test/groovy/JdbcInstrumentationTest.groovy", "diffHunk": "@@ -206,22 +198,22 @@ class JdbcInstrumentationTest extends AgentTestRunner {\n     connection.close()\n \n     where:\n-    system   | connection                                                           | username | query                                           | spanName                                                | url\n-    \"h2\"     | new Driver().connect(jdbcUrls.get(\"h2\"), null)                       | null     | \"SELECT 3\"                                      | \"SELECT $dbNameLower\"                                   | \"h2:mem:\"\n-    \"derby\"  | new EmbeddedDriver().connect(jdbcUrls.get(\"derby\"), null)            | \"APP\"    | \"SELECT 3 FROM SYSIBM.SYSDUMMY1\"                | \"SELECT ${dbNameLower}.SYSIBM.SYSDUMMY1\"                | \"derby:memory:\"\n-    \"hsqldb\" | new JDBCDriver().connect(jdbcUrls.get(\"hsqldb\"), null)               | \"SA\"     | \"SELECT 3 FROM INFORMATION_SCHEMA.SYSTEM_USERS\" | \"SELECT ${dbNameLower}.INFORMATION_SCHEMA.SYSTEM_USERS\" | \"hsqldb:mem:\"\n-    \"h2\"     | new Driver().connect(jdbcUrls.get(\"h2\"), connectionProps)            | null     | \"SELECT 3\"                                      | \"SELECT $dbNameLower\"                                   | \"h2:mem:\"\n-    \"derby\"  | new EmbeddedDriver().connect(jdbcUrls.get(\"derby\"), connectionProps) | \"APP\"    | \"SELECT 3 FROM SYSIBM.SYSDUMMY1\"                | \"SELECT ${dbNameLower}.SYSIBM.SYSDUMMY1\"                | \"derby:memory:\"\n-    \"hsqldb\" | new JDBCDriver().connect(jdbcUrls.get(\"hsqldb\"), connectionProps)    | \"SA\"     | \"SELECT 3 FROM INFORMATION_SCHEMA.SYSTEM_USERS\" | \"SELECT ${dbNameLower}.INFORMATION_SCHEMA.SYSTEM_USERS\" | \"hsqldb:mem:\"\n-    \"h2\"     | cpDatasources.get(\"tomcat\").get(\"h2\").getConnection()                | null     | \"SELECT 3\"                                      | \"SELECT $dbNameLower\"                                   | \"h2:mem:\"\n-    \"derby\"  | cpDatasources.get(\"tomcat\").get(\"derby\").getConnection()             | \"APP\"    | \"SELECT 3 FROM SYSIBM.SYSDUMMY1\"                | \"SELECT ${dbNameLower}.SYSIBM.SYSDUMMY1\"                | \"derby:memory:\"\n-    \"hsqldb\" | cpDatasources.get(\"tomcat\").get(\"hsqldb\").getConnection()            | \"SA\"     | \"SELECT 3 FROM INFORMATION_SCHEMA.SYSTEM_USERS\" | \"SELECT ${dbNameLower}.INFORMATION_SCHEMA.SYSTEM_USERS\" | \"hsqldb:mem:\"\n-    \"h2\"     | cpDatasources.get(\"hikari\").get(\"h2\").getConnection()                | null     | \"SELECT 3\"                                      | \"SELECT $dbNameLower\"                                   | \"h2:mem:\"\n-    \"derby\"  | cpDatasources.get(\"hikari\").get(\"derby\").getConnection()             | \"APP\"    | \"SELECT 3 FROM SYSIBM.SYSDUMMY1\"                | \"SELECT ${dbNameLower}.SYSIBM.SYSDUMMY1\"                | \"derby:memory:\"\n-    \"hsqldb\" | cpDatasources.get(\"hikari\").get(\"hsqldb\").getConnection()            | \"SA\"     | \"SELECT 3 FROM INFORMATION_SCHEMA.SYSTEM_USERS\" | \"SELECT ${dbNameLower}.INFORMATION_SCHEMA.SYSTEM_USERS\" | \"hsqldb:mem:\"\n-    \"h2\"     | cpDatasources.get(\"c3p0\").get(\"h2\").getConnection()                  | null     | \"SELECT 3\"                                      | \"SELECT $dbNameLower\"                                   | \"h2:mem:\"\n-    \"derby\"  | cpDatasources.get(\"c3p0\").get(\"derby\").getConnection()               | \"APP\"    | \"SELECT 3 FROM SYSIBM.SYSDUMMY1\"                | \"SELECT ${dbNameLower}.SYSIBM.SYSDUMMY1\"                | \"derby:memory:\"\n-    \"hsqldb\" | cpDatasources.get(\"c3p0\").get(\"hsqldb\").getConnection()              | \"SA\"     | \"SELECT 3 FROM INFORMATION_SCHEMA.SYSTEM_USERS\" | \"SELECT ${dbNameLower}.INFORMATION_SCHEMA.SYSTEM_USERS\" | \"hsqldb:mem:\"\n+    system   | connection                                                           | username | query                                           | normalizedQuery                                 | spanName                                                | url\n+    \"h2\"     | new Driver().connect(jdbcUrls.get(\"h2\"), null)                       | null     | \"SELECT 3\"                                      | \"SELECT ?\"                                      | \"SELECT $dbNameLower\"                                   | \"h2:mem:\"\n+    \"derby\"  | new EmbeddedDriver().connect(jdbcUrls.get(\"derby\"), null)            | \"APP\"    | \"SELECT 3 FROM SYSIBM.SYSDUMMY1\"                | \"SELECT ? FROM SYSIBM.SYSDUMMY1\"                | \"SELECT ${dbNameLower}.SYSIBM.SYSDUMMY1\"                | \"derby:memory:\"\n+    \"hsqldb\" | new JDBCDriver().connect(jdbcUrls.get(\"hsqldb\"), null)               | \"SA\"     | \"SELECT 3 FROM INFORMATION_SCHEMA.SYSTEM_USERS\" | \"SELECT ? FROM INFORMATION_SCHEMA.SYSTEM_USERS\" | \"SELECT ${dbNameLower}.INFORMATION_SCHEMA.SYSTEM_USERS\" | \"hsqldb:mem:\"\n+    \"h2\"     | new Driver().connect(jdbcUrls.get(\"h2\"), connectionProps)            | null     | \"SELECT 3\"                                      | \"SELECT ?\"                                      | \"SELECT $dbNameLower\"                                   | \"h2:mem:\"\n+    \"derby\"  | new EmbeddedDriver().connect(jdbcUrls.get(\"derby\"), connectionProps) | \"APP\"    | \"SELECT 3 FROM SYSIBM.SYSDUMMY1\"                | \"SELECT ? FROM SYSIBM.SYSDUMMY1\"                | \"SELECT ${dbNameLower}.SYSIBM.SYSDUMMY1\"                | \"derby:memory:\"\n+    \"hsqldb\" | new JDBCDriver().connect(jdbcUrls.get(\"hsqldb\"), connectionProps)    | \"SA\"     | \"SELECT 3 FROM INFORMATION_SCHEMA.SYSTEM_USERS\" | \"SELECT ? FROM INFORMATION_SCHEMA.SYSTEM_USERS\" | \"SELECT ${dbNameLower}.INFORMATION_SCHEMA.SYSTEM_USERS\" | \"hsqldb:mem:\"\n+    \"h2\"     | cpDatasources.get(\"tomcat\").get(\"h2\").getConnection()                | null     | \"SELECT 3\"                                      | \"SELECT ?\"                                      | \"SELECT $dbNameLower\"                                   | \"h2:mem:\"\n+    \"derby\"  | cpDatasources.get(\"tomcat\").get(\"derby\").getConnection()             | \"APP\"    | \"SELECT 3 FROM SYSIBM.SYSDUMMY1\"                | \"SELECT ? FROM SYSIBM.SYSDUMMY1\"                | \"SELECT ${dbNameLower}.SYSIBM.SYSDUMMY1\"                | \"derby:memory:\"\n+    \"hsqldb\" | cpDatasources.get(\"tomcat\").get(\"hsqldb\").getConnection()            | \"SA\"     | \"SELECT 3 FROM INFORMATION_SCHEMA.SYSTEM_USERS\" | \"SELECT ? FROM INFORMATION_SCHEMA.SYSTEM_USERS\" | \"SELECT ${dbNameLower}.INFORMATION_SCHEMA.SYSTEM_USERS\" | \"hsqldb:mem:\"\n+    \"h2\"     | cpDatasources.get(\"hikari\").get(\"h2\").getConnection()                | null     | \"SELECT 3\"                                      | \"SELECT ?\"                                      | \"SELECT $dbNameLower\"                                   | \"h2:mem:\"\n+    \"derby\"  | cpDatasources.get(\"hikari\").get(\"derby\").getConnection()             | \"APP\"    | \"SELECT 3 FROM SYSIBM.SYSDUMMY1\"                | \"SELECT ? FROM SYSIBM.SYSDUMMY1\"                | \"SELECT ${dbNameLower}.SYSIBM.SYSDUMMY1\"                | \"derby:memory:\"\n+    \"hsqldb\" | cpDatasources.get(\"hikari\").get(\"hsqldb\").getConnection()            | \"SA\"     | \"SELECT 3 FROM INFORMATION_SCHEMA.SYSTEM_USERS\" | \"SELECT ? FROM INFORMATION_SCHEMA.SYSTEM_USERS\" | \"SELECT ${dbNameLower}.INFORMATION_SCHEMA.SYSTEM_USERS\" | \"hsqldb:mem:\"\n+    \"h2\"     | cpDatasources.get(\"c3p0\").get(\"h2\").getConnection()                  | null     | \"SELECT 3\"                                      | \"SELECT ?\"                                      | \"SELECT $dbNameLower\"                                   | \"h2:mem:\"\n+    \"derby\"  | cpDatasources.get(\"c3p0\").get(\"derby\").getConnection()               | \"APP\"    | \"SELECT 3 FROM SYSIBM.SYSDUMMY1\"                | \"SELECT ? FROM SYSIBM.SYSDUMMY1\"                | \"SELECT ${dbNameLower}.SYSIBM.SYSDUMMY1\"                | \"derby:memory:\"\n+    \"hsqldb\" | cpDatasources.get(\"c3p0\").get(\"hsqldb\").getConnection()              | \"SA\"     | \"SELECT 3 FROM INFORMATION_SCHEMA.SYSTEM_USERS\" | \"SELECT ? FROM INFORMATION_SCHEMA.SYSTEM_USERS\" | \"SELECT ${dbNameLower}.INFORMATION_SCHEMA.SYSTEM_USERS\" | \"hsqldb:mem:\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d76d9dddf8ab8bc33f9bfb57bb88ab67b4e71c23"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxOTg1NTM0OnYy", "diffSide": "RIGHT", "path": "instrumentation/jms-1.1/src/jms2Test/groovy/SpringListenerJms2Test.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwOTozMToyNFrOH401uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwODowNjoyMFrOIJPfYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTM0ODAyNw==", "bodyText": "My exporter orders everything by startTimeNanos - the previous one had some strange ordering hacks in it (presumably since things were timed by micros instead of nanos in opentracing?). I feel like previous successes for JMS were coincidence (possibly helped by gradle-retry-plugin) and the best fix will be to make assertTraces order-agnostic", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r529348027", "createdAt": "2020-11-24T09:31:24Z", "author": {"login": "anuraaga"}, "path": "instrumentation/jms-1.1/src/jms2Test/groovy/SpringListenerJms2Test.groovy", "diffHunk": "@@ -18,17 +18,21 @@ class SpringListenerJms2Test extends AgentTestRunner {\n     def context = new AnnotationConfigApplicationContext(Config)\n     def factory = context.getBean(ConnectionFactory)\n     def template = new JmsTemplate(factory)\n+    // TODO(anuraaga): There is no defined order between when JMS starts receiving and our attempt", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d76d9dddf8ab8bc33f9bfb57bb88ab67b4e71c23"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU2MTg5MQ==", "bodyText": "previously the ordering was based on when the startSpan() was called, not based on the start time, and the JMS receive instrumentation is weird in that it doesn't start the span until the message is received, and back-dates it to when receive call was started, which is why the test ordering flip flopped a bit in the JMS tests (I was wondering this today when reviewing also)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r546561891", "createdAt": "2020-12-21T08:06:20Z", "author": {"login": "trask"}, "path": "instrumentation/jms-1.1/src/jms2Test/groovy/SpringListenerJms2Test.groovy", "diffHunk": "@@ -18,17 +18,21 @@ class SpringListenerJms2Test extends AgentTestRunner {\n     def context = new AnnotationConfigApplicationContext(Config)\n     def factory = context.getBean(ConnectionFactory)\n     def template = new JmsTemplate(factory)\n+    // TODO(anuraaga): There is no defined order between when JMS starts receiving and our attempt", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTM0ODAyNw=="}, "originalCommit": {"oid": "d76d9dddf8ab8bc33f9bfb57bb88ab67b4e71c23"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxOTg2MjA5OnYy", "diffSide": "RIGHT", "path": "instrumentation/jms-1.1/src/jms2Test/groovy/SpringTemplateJms2Test.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwOTozMjoxM1rOH406HA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwOTozMjoxM1rOH406HA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTM0OTE0OA==", "bodyText": "I didn't add a sleep after Thread.start but maybe should, will see if this is flaky", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r529349148", "createdAt": "2020-11-24T09:32:13Z", "author": {"login": "anuraaga"}, "path": "instrumentation/jms-1.1/src/jms2Test/groovy/SpringTemplateJms2Test.groovy", "diffHunk": "@@ -119,16 +119,16 @@ class SpringTemplateJms2Test extends AgentTestRunner {\n     receivedMessage.text == \"responded!\"\n     assertTraces(4) {\n       trace(0, 1) {\n-        producerSpan(it, 0, destinationType, destinationName)\n+        consumerSpan(it, 0, destinationType, destinationName, msgId.get(), null, \"receive\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d76d9dddf8ab8bc33f9bfb57bb88ab67b4e71c23"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxOTg3MTg0OnYy", "diffSide": "RIGHT", "path": "instrumentation/kubernetes-client-7.0/src/test/groovy/KubernetesRequestUtilsTest.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwOTozMzozOFrOH41AyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwOTozMzozOFrOH41AyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTM1MDg1Nw==", "bodyText": "Presumably the \"best\" way of handling these tests is to have separate library and agent instrumentation - library instrumentation tests handle any unit tests that require classes not available when running with agent.\nI could temporarily add a unit tests test set for these, but want to be a bit lazy - there are very few projects this affected.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r529350857", "createdAt": "2020-11-24T09:33:38Z", "author": {"login": "anuraaga"}, "path": "instrumentation/kubernetes-client-7.0/src/test/groovy/KubernetesRequestUtilsTest.groovy", "diffHunk": "@@ -3,85 +3,89 @@\n  * SPDX-License-Identifier: Apache-2.0\n  */\n \n-import io.opentelemetry.javaagent.instrumentation.kubernetesclient.KubernetesRequestDigest\n-import io.opentelemetry.javaagent.instrumentation.kubernetesclient.KubernetesResource\n-import io.opentelemetry.javaagent.instrumentation.kubernetesclient.KubernetesVerb\n-import spock.lang.Specification\n-\n-class KubernetesRequestUtilsTest extends Specification {\n-  def \"asserting non-resource requests should work\"() {\n-    expect:\n-    !KubernetesRequestDigest.isResourceRequest(\"/api\")\n-    !KubernetesRequestDigest.isResourceRequest(\"/apis\")\n-    !KubernetesRequestDigest.isResourceRequest(\"/apis/v1\")\n-    !KubernetesRequestDigest.isResourceRequest(\"/healthz\")\n-    !KubernetesRequestDigest.isResourceRequest(\"/swagger.json\")\n-    !KubernetesRequestDigest.isResourceRequest(\"/api/v1\")\n-    !KubernetesRequestDigest.isResourceRequest(\"/api/v1/\")\n-    !KubernetesRequestDigest.isResourceRequest(\"/apis/apps/v1\")\n-    !KubernetesRequestDigest.isResourceRequest(\"/apis/apps/v1/\")\n-  }\n-\n-  def \"asserting resource requests should work\"() {\n-    expect:\n-    KubernetesRequestDigest.isResourceRequest(\"/apis/example.io/v1/foos\")\n-    KubernetesRequestDigest.isResourceRequest(\"/apis/example.io/v1/namespaces/default/foos\")\n-    KubernetesRequestDigest.isResourceRequest(\"/api/v1/namespaces\")\n-    KubernetesRequestDigest.isResourceRequest(\"/api/v1/pods\")\n-    KubernetesRequestDigest.isResourceRequest(\"/api/v1/namespaces/default/pods\")\n-  }\n-\n-  def \"parsing core resource from url-path should work\"(String urlPath, String apiGroup, String apiVersion, String resource, String subResource, String namespace, String name) {\n-    expect:\n-    KubernetesResource.parseCoreResource(urlPath).apiGroup == apiGroup\n-    KubernetesResource.parseCoreResource(urlPath).apiVersion == apiVersion\n-    KubernetesResource.parseCoreResource(urlPath).resource == resource\n-    KubernetesResource.parseCoreResource(urlPath).subResource == subResource\n-    KubernetesResource.parseCoreResource(urlPath).namespace == namespace\n-    KubernetesResource.parseCoreResource(urlPath).name == name\n-\n-    where:\n-    urlPath                                    | apiGroup | apiVersion | resource | subResource | namespace | name\n-    \"/api/v1/pods\"                             | \"\"       | \"v1\"       | \"pods\"   | null        | null      | null\n-    \"/api/v1/namespaces/default/pods\"          | \"\"       | \"v1\"       | \"pods\"   | null        | \"default\" | null\n-    \"/api/v1/namespaces/default/pods/foo\"      | \"\"       | \"v1\"       | \"pods\"   | null        | \"default\" | \"foo\"\n-    \"/api/v1/namespaces/default/pods/foo/exec\" | \"\"       | \"v1\"       | \"pods\"   | \"exec\"      | \"default\" | \"foo\"\n-  }\n-\n-  def \"parsing regular non-core resource from url-path should work\"(String urlPath, String apiGroup, String apiVersion, String resource, String subResource, String namespace, String name) {\n-    expect:\n-    KubernetesResource.parseRegularResource(urlPath).apiGroup == apiGroup\n-    KubernetesResource.parseRegularResource(urlPath).apiVersion == apiVersion\n-    KubernetesResource.parseRegularResource(urlPath).resource == resource\n-    KubernetesResource.parseRegularResource(urlPath).subResource == subResource\n-    KubernetesResource.parseRegularResource(urlPath).namespace == namespace\n-    KubernetesResource.parseRegularResource(urlPath).name == name\n-\n-    where:\n-    urlPath                                                        | apiGroup     | apiVersion | resource      | subResource | namespace | name\n-    \"/apis/apps/v1/deployments\"                                    | \"apps\"       | \"v1\"       | \"deployments\" | null        | null      | null\n-    \"/apis/apps/v1/namespaces/default/deployments\"                 | \"apps\"       | \"v1\"       | \"deployments\" | null        | \"default\" | null\n-    \"/apis/apps/v1/namespaces/default/deployments/foo\"             | \"apps\"       | \"v1\"       | \"deployments\" | null        | \"default\" | \"foo\"\n-    \"/apis/apps/v1/namespaces/default/deployments/foo/status\"      | \"apps\"       | \"v1\"       | \"deployments\" | \"status\"    | \"default\" | \"foo\"\n-    \"/apis/example.io/v1alpha1/foos\"                               | \"example.io\" | \"v1alpha1\" | \"foos\"        | null        | null      | null\n-    \"/apis/example.io/v1alpha1/namespaces/default/foos\"            | \"example.io\" | \"v1alpha1\" | \"foos\"        | null        | \"default\" | null\n-    \"/apis/example.io/v1alpha1/namespaces/default/foos/foo\"        | \"example.io\" | \"v1alpha1\" | \"foos\"        | null        | \"default\" | \"foo\"\n-    \"/apis/example.io/v1alpha1/namespaces/default/foos/foo/status\" | \"example.io\" | \"v1alpha1\" | \"foos\"        | \"status\"    | \"default\" | \"foo\"\n-  }\n-\n-  def \"parsing kubernetes request verbs should work\"(String httpVerb, boolean hasNamePathParam, boolean hasWatchParam, KubernetesVerb kubernetesVerb) {\n-    expect:\n-    KubernetesVerb.of(httpVerb, hasNamePathParam, hasWatchParam) == kubernetesVerb\n-\n-    where:\n-    httpVerb | hasNamePathParam | hasWatchParam | kubernetesVerb\n-    \"GET\"    | true             | false         | KubernetesVerb.GET\n-    \"GET\"    | false            | true          | KubernetesVerb.WATCH\n-    \"GET\"    | false            | false         | KubernetesVerb.LIST\n-    \"POST\"   | false            | false         | KubernetesVerb.CREATE\n-    \"PUT\"    | false            | false         | KubernetesVerb.UPDATE\n-    \"PATCH\"  | false            | false         | KubernetesVerb.PATCH\n-    \"DELETE\" | true             | false         | KubernetesVerb.DELETE\n-    \"DELETE\" | false            | false         | KubernetesVerb.DELETE_COLLECTION\n-  }\n-}\n+// WIP(anuraaga): The best way to support these sort of unit tests is to separate out library /", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d76d9dddf8ab8bc33f9bfb57bb88ab67b4e71c23"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNjIwOTE3OnYy", "diffSide": "RIGHT", "path": "instrumentation/external-annotations/external-annotations.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOFQwNDo0OTowOVrOH7Og2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOFQwNDo0OTowOVrOH7Og2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTg2NTgxNw==", "bodyText": "@anuraaga any words of wisdom?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r531865817", "createdAt": "2020-11-28T04:49:09Z", "author": {"login": "trask"}, "path": "instrumentation/external-annotations/external-annotations.gradle", "diffHunk": "@@ -38,3 +38,11 @@ def testTraceProviders = tasks.register('testTraceProviders', Test) {\n   }\n }\n test.dependsOn(testTraceProviders)\n+\n+tasks.withType(Test) {\n+  // TODO only run ConfiguredTraceAnnotationsTest with this:\n+  jvmArgs \"-Dotel.instrumentation.external-annotations.include=package.Class\\$Name;OuterClass\\$InterestingMethod\"\n+\n+  // TODO only run TracedMethodsExclusionTest with this:\n+  jvmArgs \"-Dotel.instrumentation.external-annotations.exclude-methods=TracedMethodsExclusionTest\\$TestClass[excluded,annotatedButExcluded]\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcb702678e66530a3922484d5b6df07830fed05f"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzODIzODY3OnYy", "diffSide": "RIGHT", "path": "instrumentation-api/src/main/java/io/opentelemetry/instrumentation/api/tracer/utils/NetPeerUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQwNjo1MTowMFrOH7gxig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQwNzozMzowN1rOH7hAjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE2NTAwMg==", "bodyText": "any thoughts/preferences on this approach to making this class more testable?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r532165002", "createdAt": "2020-11-29T06:51:00Z", "author": {"login": "trask"}, "path": "instrumentation-api/src/main/java/io/opentelemetry/instrumentation/api/tracer/utils/NetPeerUtils.java", "diffHunk": "@@ -17,13 +18,17 @@\n \n public final class NetPeerUtils {\n \n-  private static final Map<String, String> ENDPOINT_PEER_SERVICE_MAPPING =\n-      Collections.unmodifiableMap(\n-          Config.get().getMapProperty(\"otel.endpoint.peer.service.mapping\"));\n+  public static final NetPeerUtils INSTANCE = new NetPeerUtils(Config.get());\n \n-  private NetPeerUtils() {}\n+  private final Map<String, String> endpointPeerServiceMapping;\n \n-  public static void setNetPeer(Span span, @Nullable InetSocketAddress remoteConnection) {\n+  // visible for testing\n+  NetPeerUtils(Config config) {\n+    this.endpointPeerServiceMapping =\n+        Collections.unmodifiableMap(config.getMapProperty(\"otel.endpoint.peer.service.mapping\"));\n+  }\n+\n+  public void setNetPeer(Span span, @Nullable InetSocketAddress remoteConnection) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a2bafaae171e132874411b81f3160648a21f355"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE2ODg0Nw==", "bodyText": "Dependency injection like this is a standard approach I think \ud83d\udc4d", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r532168847", "createdAt": "2020-11-29T07:33:07Z", "author": {"login": "anuraaga"}, "path": "instrumentation-api/src/main/java/io/opentelemetry/instrumentation/api/tracer/utils/NetPeerUtils.java", "diffHunk": "@@ -17,13 +18,17 @@\n \n public final class NetPeerUtils {\n \n-  private static final Map<String, String> ENDPOINT_PEER_SERVICE_MAPPING =\n-      Collections.unmodifiableMap(\n-          Config.get().getMapProperty(\"otel.endpoint.peer.service.mapping\"));\n+  public static final NetPeerUtils INSTANCE = new NetPeerUtils(Config.get());\n \n-  private NetPeerUtils() {}\n+  private final Map<String, String> endpointPeerServiceMapping;\n \n-  public static void setNetPeer(Span span, @Nullable InetSocketAddress remoteConnection) {\n+  // visible for testing\n+  NetPeerUtils(Config config) {\n+    this.endpointPeerServiceMapping =\n+        Collections.unmodifiableMap(config.getMapProperty(\"otel.endpoint.peer.service.mapping\"));\n+  }\n+\n+  public void setNetPeer(Span span, @Nullable InetSocketAddress remoteConnection) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE2NTAwMg=="}, "originalCommit": {"oid": "9a2bafaae171e132874411b81f3160648a21f355"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNTUxMTMyOnYy", "diffSide": "RIGHT", "path": "gradle/instrumentation.gradle", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwMToyNzoyMlrOIJJwXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QwNDoyMDoyOVrOIKQwWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ2NzkzMg==", "bodyText": "this is a bummer, see similar comment in javaagent.gradle\nhere's a deadlock I captured locally (interestingly doesn't deadlock on windows, but does on linux):\nFound one Java-level deadlock:\n=============================\n\"main\":\n  waiting to lock monitor 0x00007f1b64008580 (object 0x00000000fd873d20, a java.lang.Object),\n  which is held by \"IntervalMetricReader-1\"\n\"IntervalMetricReader-1\":\n  waiting for ownable synchronizer 0x00000000fba0b0b0, (a java.util.concurrent.locks.ReentrantLock$NonfairSync),\n  which is held by \"main\"\n\nJava stack information for the threads listed above:\n===================================================\n\"main\":\n        at org.gradle.internal.logging.sink.OutputEventRenderer.onOutput(OutputEventRenderer.java:431)\n        - waiting to lock <0x00000000fd873d20> (a java.lang.Object)\n        at org.gradle.internal.logging.sink.OutputEventListenerManager$1.onOutput(OutputEventListenerManager.java:36)\n        at org.gradle.internal.logging.services.TextStreamOutputEventListener.onTextEvent(TextStreamOutputEventListener.java:58)\n        at org.gradle.internal.logging.services.TextStreamOutputEventListener.onOutput(TextStreamOutputEventListener.java:42)\n        at org.gradle.internal.logging.source.PrintStreamLoggingSystem$OutputEventDestination.onOutput(PrintStreamLoggingSystem.java:173)\n        at org.gradle.internal.logging.source.PrintStreamLoggingSystem$1.text(PrintStreamLoggingSystem.java:45)\n        at org.gradle.internal.io.LineBufferingOutputStream.flush(LineBufferingOutputStream.java:98)\n        at org.gradle.internal.io.LineBufferingOutputStream.write(LineBufferingOutputStream.java:82)\n        at java.io.OutputStream.write(java.base@11.0.4/OutputStream.java:157)\n        at java.io.PrintStream.write(java.base@11.0.4/PrintStream.java:559)\n        - locked <0x00000000faf18930> (a java.io.PrintStream)\n        at sun.nio.cs.StreamEncoder.writeBytes(java.base@11.0.4/StreamEncoder.java:233)\n        at sun.nio.cs.StreamEncoder.implFlushBuffer(java.base@11.0.4/StreamEncoder.java:312)\n        at sun.nio.cs.StreamEncoder.flushBuffer(java.base@11.0.4/StreamEncoder.java:104)\n        - locked <0x00000000faf1aa50> (a java.io.OutputStreamWriter)\n        at java.io.OutputStreamWriter.flushBuffer(java.base@11.0.4/OutputStreamWriter.java:184)\n        at java.io.PrintStream.newLine(java.base@11.0.4/PrintStream.java:625)\n        - locked <0x00000000faf18930> (a java.io.PrintStream)\n        at java.io.PrintStream.println(java.base@11.0.4/PrintStream.java:883)\n        - locked <0x00000000faf18930> (a java.io.PrintStream)\n        at org.gradle.internal.io.LinePerThreadBufferingOutputStream.println(LinePerThreadBufferingOutputStream.java:203)\n        at io.opentelemetry.javaagent.slf4j.impl.SimpleLogger.write(SimpleLogger.java:318)\n        at io.opentelemetry.javaagent.slf4j.impl.SimpleLogger.log(SimpleLogger.java:295)\n        at io.opentelemetry.javaagent.slf4j.impl.SimpleLogger.formatAndLog(SimpleLogger.java:355)\n        at io.opentelemetry.javaagent.slf4j.impl.SimpleLogger.debug(SimpleLogger.java:446)\n        at io.opentelemetry.javaagent.tooling.context.FieldBackedProvider$1$1$1.visitMethodInsn(FieldBackedProvider.java:201)\n        at net.bytebuddy.jar.asm.MethodVisitor.visitMethodInsn(MethodVisitor.java:438)\n        at net.bytebuddy.utility.visitor.ExceptionTableSensitiveMethodVisitor.onVisitMethodInsn(ExceptionTableSensitiveMethodVisitor.java:199)\n        at net.bytebuddy.utility.visitor.ExceptionTableSensitiveMethodVisitor.visitMethodInsn(ExceptionTableSensitiveMethodVisitor.java:186)\n        at net.bytebuddy.jar.asm.MethodVisitor.visitMethodInsn(MethodVisitor.java:438)\n        at net.bytebuddy.utility.visitor.FramePaddingMethodVisitor.visitMethodInsn(FramePaddingMethodVisitor.java:94)\n        at net.bytebuddy.jar.asm.MethodVisitor.visitMethodInsn(MethodVisitor.java:438)\n        at net.bytebuddy.utility.visitor.StackAwareMethodVisitor.visitMethodInsn(StackAwareMethodVisitor.java:302)\n        at net.bytebuddy.jar.asm.MethodVisitor.visitMethodInsn(MethodVisitor.java:438)\n        at net.bytebuddy.utility.visitor.StackAwareMethodVisitor.visitMethodInsn(StackAwareMethodVisitor.java:302)\n        at net.bytebuddy.jar.asm.MethodVisitor.visitMethodInsn(MethodVisitor.java:438)\n        at net.bytebuddy.jar.asm.MethodVisitor.visitMethodInsn(MethodVisitor.java:438)\n        at net.bytebuddy.jar.asm.ClassReader.readCode(ClassReader.java:2412)\n        at net.bytebuddy.jar.asm.ClassReader.readMethod(ClassReader.java:1481)\n        at net.bytebuddy.jar.asm.ClassReader.accept(ClassReader.java:711)\n        at net.bytebuddy.jar.asm.ClassReader.accept(ClassReader.java:394)\n        at net.bytebuddy.asm.Advice$Dispatcher$Inlining$Resolved$AdviceMethodInliner.apply(Advice.java:7821)\n        at net.bytebuddy.asm.Advice$AdviceVisitor.onAfterExceptionTable(Advice.java:9955)\n        at net.bytebuddy.utility.visitor.ExceptionTableSensitiveMethodVisitor.considerEndOfExceptionTable(ExceptionTableSensitiveMethodVisitor.java:49)\n        at net.bytebuddy.utility.visitor.ExceptionTableSensitiveMethodVisitor.visitLabel(ExceptionTableSensitiveMethodVisitor.java:81)\n        at net.bytebuddy.jar.asm.Label.accept(Label.java:358)\n        at net.bytebuddy.jar.asm.ClassReader.readCode(ClassReader.java:2021)\n        at net.bytebuddy.jar.asm.ClassReader.readMethod(ClassReader.java:1481)\n        at net.bytebuddy.jar.asm.ClassReader.accept(ClassReader.java:711)\n        at net.bytebuddy.jar.asm.ClassReader.accept(ClassReader.java:394)\n        at net.bytebuddy.dynamic.scaffold.TypeWriter$Default$ForInlining.create(TypeWriter.java:3892)\n        at net.bytebuddy.dynamic.scaffold.TypeWriter$Default.make(TypeWriter.java:2166)\n        at net.bytebuddy.dynamic.scaffold.inline.RedefinitionDynamicTypeBuilder.make(RedefinitionDynamicTypeBuilder.java:224)\n        at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.doTransform(AgentBuilder.java:10366)\n        at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.transform(AgentBuilder.java:10302)\n        at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.access$1600(AgentBuilder.java:10068)\n        at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer$Java9CapableVmDispatcher.run(AgentBuilder.java:10761)\n        at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer$Java9CapableVmDispatcher.run(AgentBuilder.java:10699)\n        at java.security.AccessController.doPrivileged(java.base@11.0.4/Native Method)\n        at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.transform(AgentBuilder.java:10258)\n        at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer$ByteBuddy$ModuleSupport.transform(Unknown Source)\n        at sun.instrument.TransformerManager.transform(java.instrument@11.0.4/TransformerManager.java:188)\n        at sun.instrument.InstrumentationImpl.transform(java.instrument@11.0.4/InstrumentationImpl.java:563)\n        at java.lang.ClassLoader.defineClass1(java.base@11.0.4/Native Method)\n        at java.lang.ClassLoader.defineClass(java.base@11.0.4/ClassLoader.java:1016)\n        at java.security.SecureClassLoader.defineClass(java.base@11.0.4/SecureClassLoader.java:174)\n        at java.net.URLClassLoader.defineClass(java.base@11.0.4/URLClassLoader.java:550)\n        at java.net.URLClassLoader$1.run(java.base@11.0.4/URLClassLoader.java:458)\n        at java.net.URLClassLoader$1.run(java.base@11.0.4/URLClassLoader.java:452)\n        at java.security.AccessController.doPrivileged(java.base@11.0.4/Native Method)\n        at java.net.URLClassLoader.findClass(java.base@11.0.4/URLClassLoader.java:451)\n        at java.lang.ClassLoader.loadClass(java.base@11.0.4/ClassLoader.java:588)\n        - locked <0x00000000fae3f740> (a java.lang.Object)\n        at java.lang.ClassLoader.loadClass(java.base@11.0.4/ClassLoader.java:521)\n        at org.gradle.internal.concurrent.ThreadFactoryImpl.newThread(ThreadFactoryImpl.java:36)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.<init>(java.base@11.0.4/ThreadPoolExecutor.java:623)\n        at java.util.concurrent.ThreadPoolExecutor.addWorker(java.base@11.0.4/ThreadPoolExecutor.java:912)\n        at java.util.concurrent.ThreadPoolExecutor.execute(java.base@11.0.4/ThreadPoolExecutor.java:1354)\n        at org.gradle.internal.concurrent.ManagedExecutorImpl.execute(ManagedExecutorImpl.java:39)\n        at org.gradle.internal.remote.internal.hub.MessageHub.addHandler(MessageHub.java:133)\n        at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection.addIncoming(MessageHubBackedObjectConnection.java:100)\n        at org.gradle.api.internal.tasks.testing.worker.TestWorker.startReceivingTests(TestWorker.java:105)\n        at org.gradle.api.internal.tasks.testing.worker.TestWorker.execute(TestWorker.java:69)\n        at org.gradle.api.internal.tasks.testing.worker.TestWorker.execute(TestWorker.java:47)\n        at org.gradle.process.internal.worker.child.ActionExecutionWorker.execute(ActionExecutionWorker.java:56)\n        at org.gradle.process.internal.worker.child.SystemApplicationClassLoaderWorker.call(SystemApplicationClassLoaderWorker.java:133)\n        at org.gradle.process.internal.worker.child.SystemApplicationClassLoaderWorker.call(SystemApplicationClassLoaderWorker.java:71)\n        at worker.org.gradle.process.internal.worker.GradleWorkerMain.run(GradleWorkerMain.java:69)\n        at worker.org.gradle.process.internal.worker.GradleWorkerMain.main(GradleWorkerMain.java:74)\n\"IntervalMetricReader-1\":\n        at jdk.internal.misc.Unsafe.park(java.base@11.0.4/Native Method)\n        - parking to wait for  <0x00000000fba0b0b0> (a java.util.concurrent.locks.ReentrantLock$NonfairSync)\n        at java.util.concurrent.locks.LockSupport.park(java.base@11.0.4/LockSupport.java:194)\n        at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(java.base@11.0.4/AbstractQueuedSynchronizer.java:885)\n        at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(java.base@11.0.4/AbstractQueuedSynchronizer.java:917)\n        at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(java.base@11.0.4/AbstractQueuedSynchronizer.java:1240)\n        at java.util.concurrent.locks.ReentrantLock.lock(java.base@11.0.4/ReentrantLock.java:267)\n        at org.gradle.internal.remote.internal.hub.MessageHub$ChannelDispatch.dispatch(MessageHub.java:370)\n        at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:94)\n        at com.sun.proxy.$Proxy10.sendOutputEvent(Unknown Source)\n        at org.gradle.process.internal.worker.child.WorkerLogEventListener.onOutput(WorkerLogEventListener.java:58)\n        at jdk.internal.reflect.GeneratedMethodAccessor9.invoke(Unknown Source)\n        at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(java.base@11.0.4/DelegatingMethodAccessorImpl.java:43)\n        at java.lang.reflect.Method.invoke(java.base@11.0.4/Method.java:566)\n        at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36)\n        at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)\n        at org.gradle.internal.event.AbstractBroadcastDispatch.dispatch(AbstractBroadcastDispatch.java:43)\n        at org.gradle.internal.event.BroadcastDispatch$SingletonDispatch.dispatch(BroadcastDispatch.java:245)\n        at org.gradle.internal.event.BroadcastDispatch$SingletonDispatch.dispatch(BroadcastDispatch.java:157)\n        at org.gradle.internal.event.ListenerBroadcast.dispatch(ListenerBroadcast.java:141)\n        at org.gradle.internal.event.ListenerBroadcast.dispatch(ListenerBroadcast.java:37)\n        at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:94)\n        at com.sun.proxy.$Proxy9.onOutput(Unknown Source)\n        at org.gradle.internal.logging.sink.OutputEventTransformer.onOutput(OutputEventTransformer.java:104)\n        at org.gradle.internal.logging.sink.OutputEventRenderer.onOutput(OutputEventRenderer.java:431)\n        - locked <0x00000000fd873d20> (a java.lang.Object)\n        at org.gradle.internal.logging.sink.OutputEventListenerManager$1.onOutput(OutputEventListenerManager.java:36)\n        at org.gradle.internal.logging.services.TextStreamOutputEventListener.onTextEvent(TextStreamOutputEventListener.java:58)\n        at org.gradle.internal.logging.services.TextStreamOutputEventListener.onOutput(TextStreamOutputEventListener.java:42)\n        at org.gradle.internal.logging.source.PrintStreamLoggingSystem$OutputEventDestination.onOutput(PrintStreamLoggingSystem.java:173)\n        at org.gradle.internal.logging.source.PrintStreamLoggingSystem$1.text(PrintStreamLoggingSystem.java:45)\n        at org.gradle.internal.io.LineBufferingOutputStream.flush(LineBufferingOutputStream.java:98)\n        at org.gradle.internal.io.LineBufferingOutputStream.write(LineBufferingOutputStream.java:82)\n        at java.io.OutputStream.write(java.base@11.0.4/OutputStream.java:157)\n        at java.io.PrintStream.write(java.base@11.0.4/PrintStream.java:559)\n        - locked <0x00000000faff6630> (a java.io.PrintStream)\n        at sun.nio.cs.StreamEncoder.writeBytes(java.base@11.0.4/StreamEncoder.java:233)\n        at sun.nio.cs.StreamEncoder.implFlushBuffer(java.base@11.0.4/StreamEncoder.java:312)\n        at sun.nio.cs.StreamEncoder.flushBuffer(java.base@11.0.4/StreamEncoder.java:104)\n        - locked <0x00000000faff8750> (a java.io.OutputStreamWriter)\n        at java.io.OutputStreamWriter.flushBuffer(java.base@11.0.4/OutputStreamWriter.java:184)\n        at java.io.PrintStream.newLine(java.base@11.0.4/PrintStream.java:625)\n        - locked <0x00000000faff6630> (a java.io.PrintStream)\n        at java.io.PrintStream.println(java.base@11.0.4/PrintStream.java:883)\n        - locked <0x00000000faff6630> (a java.io.PrintStream)\n        at org.gradle.internal.io.LinePerThreadBufferingOutputStream.println(LinePerThreadBufferingOutputStream.java:203)\n        at io.opentelemetry.javaagent.slf4j.impl.SimpleLogger.write(SimpleLogger.java:318)\n        at io.opentelemetry.javaagent.slf4j.impl.SimpleLogger.log(SimpleLogger.java:295)\n        at io.opentelemetry.javaagent.slf4j.impl.SimpleLogger.formatAndLog(SimpleLogger.java:355)\n        at io.opentelemetry.javaagent.slf4j.impl.SimpleLogger.debug(SimpleLogger.java:446)\n        at io.opentelemetry.javaagent.instrumentation.javaconcurrent.FutureInstrumentation$1.matches(FutureInstrumentation.java:85)\n        at io.opentelemetry.javaagent.instrumentation.javaconcurrent.FutureInstrumentation$1.matches(FutureInstrumentation.java:80)\n        at net.bytebuddy.matcher.ElementMatcher$Junction$Conjunction.matches(ElementMatcher.java:122)\n        at io.opentelemetry.javaagent.tooling.bytebuddy.matcher.LoggingFailSafeMatcher.matches(LoggingFailSafeMatcher.java:52)\n        at net.bytebuddy.agent.builder.AgentBuilder$RawMatcher$ForElementMatchers.matches(AgentBuilder.java:1312)\n        at net.bytebuddy.agent.builder.AgentBuilder$RawMatcher$Conjunction.matches(AgentBuilder.java:1163)\n        at net.bytebuddy.agent.builder.AgentBuilder$RawMatcher$Conjunction.matches(AgentBuilder.java:1163)\n        at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.doTransform(AgentBuilder.java:10343)\n        at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.transform(AgentBuilder.java:10302)\n        at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.access$1600(AgentBuilder.java:10068)\n        at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer$Java9CapableVmDispatcher.run(AgentBuilder.java:10761)\n        at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer$Java9CapableVmDispatcher.run(AgentBuilder.java:10699)\n        at java.security.AccessController.doPrivileged(java.base@11.0.4/Native Method)\n        at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer.transform(AgentBuilder.java:10258)\n        at net.bytebuddy.agent.builder.AgentBuilder$Default$ExecutingTransformer$ByteBuddy$ModuleSupport.transform(Unknown Source)\n        at sun.instrument.TransformerManager.transform(java.instrument@11.0.4/TransformerManager.java:188)\n        at sun.instrument.InstrumentationImpl.transform(java.instrument@11.0.4/InstrumentationImpl.java:563)\n        at java.util.concurrent.CompletableFuture.uniHandleStage(java.base@11.0.4/CompletableFuture.java:944)\n        at java.util.concurrent.CompletableFuture.handle(java.base@11.0.4/CompletableFuture.java:2266)\n        at java.lang.ProcessImpl.initStreams(java.base@11.0.4/ProcessImpl.java:389)\n        at java.lang.ProcessImpl.lambda$new$0(java.base@11.0.4/ProcessImpl.java:352)\n        at java.lang.ProcessImpl$$Lambda$116/0x00000001002f9c40.run(java.base@11.0.4/Unknown Source)\n        at java.security.AccessController.doPrivileged(java.base@11.0.4/Native Method)\n        at java.lang.ProcessImpl.<init>(java.base@11.0.4/ProcessImpl.java:351)\n        at java.lang.ProcessImpl.start(java.base@11.0.4/ProcessImpl.java:271)\n        at java.lang.ProcessBuilder.start(java.base@11.0.4/ProcessBuilder.java:1107)\n        at java.lang.ProcessBuilder.start(java.base@11.0.4/ProcessBuilder.java:1071)\n        at java.lang.Runtime.exec(java.base@11.0.4/Runtime.java:591)\n        at java.lang.Runtime.exec(java.base@11.0.4/Runtime.java:415)\n        at java.lang.Runtime.exec(java.base@11.0.4/Runtime.java:312)\n        at com.sun.jna.NativeLibrary.getLinuxLdPaths(NativeLibrary.java:999)\n        at com.sun.jna.NativeLibrary.<clinit>(NativeLibrary.java:941)\n        at com.sun.jna.Library$Handler.<init>(Library.java:192)\n        at com.sun.jna.Native.load(Native.java:596)\n        at com.sun.jna.Native.load(Native.java:570)\n        at com.sun.jna.platform.linux.Udev.<clinit>(Udev.java:37)\n        at oshi.hardware.platform.linux.LinuxHWDiskStore.getDisks(LinuxHWDiskStore.java:160)\n        at oshi.hardware.platform.linux.LinuxHWDiskStore.getDisks(LinuxHWDiskStore.java:151)\n        at oshi.hardware.platform.linux.LinuxHardwareAbstractionLayer.getDiskStores(LinuxHardwareAbstractionLayer.java:75)\n        at io.opentelemetry.javaagent.shaded.instrumentation.oshi.SystemMetrics.lambda$registerObservers$6(SystemMetrics.java:138)\n        at io.opentelemetry.javaagent.shaded.instrumentation.oshi.SystemMetrics$$Lambda$108/0x00000001002c4840.accept(Unknown Source)\n        at io.opentelemetry.sdk.metrics.AsynchronousInstrumentAccumulator.lambda$longAsynchronousAccumulator$3(AsynchronousInstrumentAccumulator.java:59)\n        at io.opentelemetry.sdk.metrics.AsynchronousInstrumentAccumulator$$Lambda$98/0x00000001002c2040.accept(Unknown Source)\n        at io.opentelemetry.sdk.metrics.AsynchronousInstrumentAccumulator.collectAll(AsynchronousInstrumentAccumulator.java:31)\n        at io.opentelemetry.sdk.metrics.AbstractAsynchronousInstrument.collectAll(AbstractAsynchronousInstrument.java:23)\n        at io.opentelemetry.sdk.metrics.SdkMeter.collectAll(SdkMeter.java:102)\n        at io.opentelemetry.sdk.metrics.SdkMeterProvider$MetricProducerSdk.collectAllMetrics(SdkMeterProvider.java:174)\n        at io.opentelemetry.sdk.metrics.export.IntervalMetricReader$Exporter.run(IntervalMetricReader.java:192)\n        at java.util.concurrent.Executors$RunnableAdapter.call(java.base@11.0.4/Executors.java:515)\n        at java.util.concurrent.FutureTask.runAndReset(java.base@11.0.4/FutureTask.java:305)\n        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(java.base@11.0.4/ScheduledThreadPoolExecutor.java:305)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(java.base@11.0.4/ThreadPoolExecutor.java:1128)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(java.base@11.0.4/ThreadPoolExecutor.java:628)\n        at java.lang.Thread.run(java.base@11.0.4/Thread.java:834)\n\nFound 1 deadlock.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r546467932", "createdAt": "2020-12-21T01:27:22Z", "author": {"login": "trask"}, "path": "gradle/instrumentation.gradle", "diffHunk": "@@ -55,3 +51,73 @@ afterEvaluate {\n     project(':javaagent-tooling').configurations.instrumentationMuzzle + configurations.runtimeClasspath\n   ).configure()\n }\n+\n+configurations {\n+  testInstrumentation\n+}\n+\n+shadowJar {\n+  configurations = [project.configurations.runtimeClasspath, project.configurations.testInstrumentation]\n+  mergeServiceFiles()\n+\n+  archiveFileName = 'agent-testing.jar'\n+\n+  dependencies {\n+    exclude(project(':javaagent-bootstrap'))\n+    exclude(project(':instrumentation-api'))\n+    exclude(project(':javaagent-api'))\n+    exclude(project(':javaagent-tooling'))\n+    exclude(dependency(deps.bytebuddy))\n+    exclude(dependency(deps.opentelemetryApi))\n+    exclude(dependency(deps.opentelemetryContext))\n+    exclude(dependency(deps.slf4j))\n+  }\n+\n+  // rewrite library instrumentation dependencies\n+  relocate \"io.opentelemetry.instrumentation\", \"io.opentelemetry.javaagent.shaded.instrumentation\"\n+\n+  // Prevents conflict with other SLF4J instances. Important for premain.\n+  relocate 'org.slf4j', 'io.opentelemetry.javaagent.slf4j'\n+  // rewrite dependencies calling Logger.getLogger\n+  relocate 'java.util.logging.Logger', 'io.opentelemetry.javaagent.bootstrap.PatchLogger'\n+\n+  // prevents conflict with library instrumentation\n+  relocate 'io.opentelemetry.instrumentation.api', 'io.opentelemetry.javaagent.shaded.instrumentation.api'\n+\n+  // relocate OpenTelemetry API usage\n+  relocate \"io.opentelemetry.api\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.api\"\n+  relocate \"io.opentelemetry.spi\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.spi\"\n+  relocate \"io.opentelemetry.context\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.context\"\n+\n+  // this is for instrumentation on opentelemetry-api itself\n+  relocate \"application.io.opentelemetry\", \"io.opentelemetry\"\n+}\n+\n+tasks.withType(Test).configureEach {\n+  // Multi-threaded logging seems to be causing deadlocks with Gradle's log capture.\n+  //  jvmArgs \"-Dio.opentelemetry.javaagent.slf4j.simpleLogger.defaultLogLevel=debug\"\n+  //  jvmArgs \"-Dorg.slf4j.simpleLogger.defaultLogLevel=debug\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e7576087ca05a4daf0e87fa2078394b6eb3dcb5"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjUzMTkxMg==", "bodyText": "Have you reported that to Gradle?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r546531912", "createdAt": "2020-12-21T06:32:52Z", "author": {"login": "iNikem"}, "path": "gradle/instrumentation.gradle", "diffHunk": "@@ -55,3 +51,73 @@ afterEvaluate {\n     project(':javaagent-tooling').configurations.instrumentationMuzzle + configurations.runtimeClasspath\n   ).configure()\n }\n+\n+configurations {\n+  testInstrumentation\n+}\n+\n+shadowJar {\n+  configurations = [project.configurations.runtimeClasspath, project.configurations.testInstrumentation]\n+  mergeServiceFiles()\n+\n+  archiveFileName = 'agent-testing.jar'\n+\n+  dependencies {\n+    exclude(project(':javaagent-bootstrap'))\n+    exclude(project(':instrumentation-api'))\n+    exclude(project(':javaagent-api'))\n+    exclude(project(':javaagent-tooling'))\n+    exclude(dependency(deps.bytebuddy))\n+    exclude(dependency(deps.opentelemetryApi))\n+    exclude(dependency(deps.opentelemetryContext))\n+    exclude(dependency(deps.slf4j))\n+  }\n+\n+  // rewrite library instrumentation dependencies\n+  relocate \"io.opentelemetry.instrumentation\", \"io.opentelemetry.javaagent.shaded.instrumentation\"\n+\n+  // Prevents conflict with other SLF4J instances. Important for premain.\n+  relocate 'org.slf4j', 'io.opentelemetry.javaagent.slf4j'\n+  // rewrite dependencies calling Logger.getLogger\n+  relocate 'java.util.logging.Logger', 'io.opentelemetry.javaagent.bootstrap.PatchLogger'\n+\n+  // prevents conflict with library instrumentation\n+  relocate 'io.opentelemetry.instrumentation.api', 'io.opentelemetry.javaagent.shaded.instrumentation.api'\n+\n+  // relocate OpenTelemetry API usage\n+  relocate \"io.opentelemetry.api\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.api\"\n+  relocate \"io.opentelemetry.spi\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.spi\"\n+  relocate \"io.opentelemetry.context\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.context\"\n+\n+  // this is for instrumentation on opentelemetry-api itself\n+  relocate \"application.io.opentelemetry\", \"io.opentelemetry\"\n+}\n+\n+tasks.withType(Test).configureEach {\n+  // Multi-threaded logging seems to be causing deadlocks with Gradle's log capture.\n+  //  jvmArgs \"-Dio.opentelemetry.javaagent.slf4j.simpleLogger.defaultLogLevel=debug\"\n+  //  jvmArgs \"-Dorg.slf4j.simpleLogger.defaultLogLevel=debug\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ2NzkzMg=="}, "originalCommit": {"oid": "1e7576087ca05a4daf0e87fa2078394b6eb3dcb5"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU1Njk5NQ==", "bodyText": "no, I can report it tomorrow", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r546556995", "createdAt": "2020-12-21T07:53:40Z", "author": {"login": "trask"}, "path": "gradle/instrumentation.gradle", "diffHunk": "@@ -55,3 +51,73 @@ afterEvaluate {\n     project(':javaagent-tooling').configurations.instrumentationMuzzle + configurations.runtimeClasspath\n   ).configure()\n }\n+\n+configurations {\n+  testInstrumentation\n+}\n+\n+shadowJar {\n+  configurations = [project.configurations.runtimeClasspath, project.configurations.testInstrumentation]\n+  mergeServiceFiles()\n+\n+  archiveFileName = 'agent-testing.jar'\n+\n+  dependencies {\n+    exclude(project(':javaagent-bootstrap'))\n+    exclude(project(':instrumentation-api'))\n+    exclude(project(':javaagent-api'))\n+    exclude(project(':javaagent-tooling'))\n+    exclude(dependency(deps.bytebuddy))\n+    exclude(dependency(deps.opentelemetryApi))\n+    exclude(dependency(deps.opentelemetryContext))\n+    exclude(dependency(deps.slf4j))\n+  }\n+\n+  // rewrite library instrumentation dependencies\n+  relocate \"io.opentelemetry.instrumentation\", \"io.opentelemetry.javaagent.shaded.instrumentation\"\n+\n+  // Prevents conflict with other SLF4J instances. Important for premain.\n+  relocate 'org.slf4j', 'io.opentelemetry.javaagent.slf4j'\n+  // rewrite dependencies calling Logger.getLogger\n+  relocate 'java.util.logging.Logger', 'io.opentelemetry.javaagent.bootstrap.PatchLogger'\n+\n+  // prevents conflict with library instrumentation\n+  relocate 'io.opentelemetry.instrumentation.api', 'io.opentelemetry.javaagent.shaded.instrumentation.api'\n+\n+  // relocate OpenTelemetry API usage\n+  relocate \"io.opentelemetry.api\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.api\"\n+  relocate \"io.opentelemetry.spi\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.spi\"\n+  relocate \"io.opentelemetry.context\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.context\"\n+\n+  // this is for instrumentation on opentelemetry-api itself\n+  relocate \"application.io.opentelemetry\", \"io.opentelemetry\"\n+}\n+\n+tasks.withType(Test).configureEach {\n+  // Multi-threaded logging seems to be causing deadlocks with Gradle's log capture.\n+  //  jvmArgs \"-Dio.opentelemetry.javaagent.slf4j.simpleLogger.defaultLogLevel=debug\"\n+  //  jvmArgs \"-Dorg.slf4j.simpleLogger.defaultLogLevel=debug\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ2NzkzMg=="}, "originalCommit": {"oid": "1e7576087ca05a4daf0e87fa2078394b6eb3dcb5"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAxNTk0NA==", "bodyText": "been investigating, not a gradle bug, the javaagent is conspiring to cause the deadlock, finally found a way to resolve it (along with lots of ways not to resolve it \ud83d\ude2d), I still need to write up explanation and add comments, will do that later today", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r547015944", "createdAt": "2020-12-22T01:28:43Z", "author": {"login": "trask"}, "path": "gradle/instrumentation.gradle", "diffHunk": "@@ -55,3 +51,73 @@ afterEvaluate {\n     project(':javaagent-tooling').configurations.instrumentationMuzzle + configurations.runtimeClasspath\n   ).configure()\n }\n+\n+configurations {\n+  testInstrumentation\n+}\n+\n+shadowJar {\n+  configurations = [project.configurations.runtimeClasspath, project.configurations.testInstrumentation]\n+  mergeServiceFiles()\n+\n+  archiveFileName = 'agent-testing.jar'\n+\n+  dependencies {\n+    exclude(project(':javaagent-bootstrap'))\n+    exclude(project(':instrumentation-api'))\n+    exclude(project(':javaagent-api'))\n+    exclude(project(':javaagent-tooling'))\n+    exclude(dependency(deps.bytebuddy))\n+    exclude(dependency(deps.opentelemetryApi))\n+    exclude(dependency(deps.opentelemetryContext))\n+    exclude(dependency(deps.slf4j))\n+  }\n+\n+  // rewrite library instrumentation dependencies\n+  relocate \"io.opentelemetry.instrumentation\", \"io.opentelemetry.javaagent.shaded.instrumentation\"\n+\n+  // Prevents conflict with other SLF4J instances. Important for premain.\n+  relocate 'org.slf4j', 'io.opentelemetry.javaagent.slf4j'\n+  // rewrite dependencies calling Logger.getLogger\n+  relocate 'java.util.logging.Logger', 'io.opentelemetry.javaagent.bootstrap.PatchLogger'\n+\n+  // prevents conflict with library instrumentation\n+  relocate 'io.opentelemetry.instrumentation.api', 'io.opentelemetry.javaagent.shaded.instrumentation.api'\n+\n+  // relocate OpenTelemetry API usage\n+  relocate \"io.opentelemetry.api\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.api\"\n+  relocate \"io.opentelemetry.spi\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.spi\"\n+  relocate \"io.opentelemetry.context\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.context\"\n+\n+  // this is for instrumentation on opentelemetry-api itself\n+  relocate \"application.io.opentelemetry\", \"io.opentelemetry\"\n+}\n+\n+tasks.withType(Test).configureEach {\n+  // Multi-threaded logging seems to be causing deadlocks with Gradle's log capture.\n+  //  jvmArgs \"-Dio.opentelemetry.javaagent.slf4j.simpleLogger.defaultLogLevel=debug\"\n+  //  jvmArgs \"-Dorg.slf4j.simpleLogger.defaultLogLevel=debug\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ2NzkzMg=="}, "originalCommit": {"oid": "1e7576087ca05a4daf0e87fa2078394b6eb3dcb5"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA4NTQ3NA==", "bodyText": "spoke too soon \ud83d\ude2d\ud83d\ude2d\ud83d\ude2d\nstill hanging on CI sporadically, need to investigate more\nThe basic problem is:\n\n\ngradle does some locking, assuming it knows what happens under those locks\n\n\ngradle accesses some classes that haven't been loaded yet, triggering class loading underneath those locks\n\n\nduring that class loading, we perform some debug logging (particularly in FieldBackedProvider)\n\n\nbut we are logging to System.out, and gradle has hijacked System.out, so that logging goes back to gradle\n\n\nwhere gradle does more locking\n\n\n[add multiple threads]\n\n\nLooking at heap dumps from the deadlocked state shows what class gradle was accessing that was triggering class loading, which is what led me to add org.gradle. to the GlobalIgnoresMatcher and to preload io.opentelemetry.javaagent.instrumentation.api.concurrent.RunnableWrapper during agent startup, so gradle wouldn't be causing it to be loaded (see e39246e).", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r547085474", "createdAt": "2020-12-22T06:03:17Z", "author": {"login": "trask"}, "path": "gradle/instrumentation.gradle", "diffHunk": "@@ -55,3 +51,73 @@ afterEvaluate {\n     project(':javaagent-tooling').configurations.instrumentationMuzzle + configurations.runtimeClasspath\n   ).configure()\n }\n+\n+configurations {\n+  testInstrumentation\n+}\n+\n+shadowJar {\n+  configurations = [project.configurations.runtimeClasspath, project.configurations.testInstrumentation]\n+  mergeServiceFiles()\n+\n+  archiveFileName = 'agent-testing.jar'\n+\n+  dependencies {\n+    exclude(project(':javaagent-bootstrap'))\n+    exclude(project(':instrumentation-api'))\n+    exclude(project(':javaagent-api'))\n+    exclude(project(':javaagent-tooling'))\n+    exclude(dependency(deps.bytebuddy))\n+    exclude(dependency(deps.opentelemetryApi))\n+    exclude(dependency(deps.opentelemetryContext))\n+    exclude(dependency(deps.slf4j))\n+  }\n+\n+  // rewrite library instrumentation dependencies\n+  relocate \"io.opentelemetry.instrumentation\", \"io.opentelemetry.javaagent.shaded.instrumentation\"\n+\n+  // Prevents conflict with other SLF4J instances. Important for premain.\n+  relocate 'org.slf4j', 'io.opentelemetry.javaagent.slf4j'\n+  // rewrite dependencies calling Logger.getLogger\n+  relocate 'java.util.logging.Logger', 'io.opentelemetry.javaagent.bootstrap.PatchLogger'\n+\n+  // prevents conflict with library instrumentation\n+  relocate 'io.opentelemetry.instrumentation.api', 'io.opentelemetry.javaagent.shaded.instrumentation.api'\n+\n+  // relocate OpenTelemetry API usage\n+  relocate \"io.opentelemetry.api\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.api\"\n+  relocate \"io.opentelemetry.spi\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.spi\"\n+  relocate \"io.opentelemetry.context\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.context\"\n+\n+  // this is for instrumentation on opentelemetry-api itself\n+  relocate \"application.io.opentelemetry\", \"io.opentelemetry\"\n+}\n+\n+tasks.withType(Test).configureEach {\n+  // Multi-threaded logging seems to be causing deadlocks with Gradle's log capture.\n+  //  jvmArgs \"-Dio.opentelemetry.javaagent.slf4j.simpleLogger.defaultLogLevel=debug\"\n+  //  jvmArgs \"-Dorg.slf4j.simpleLogger.defaultLogLevel=debug\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ2NzkzMg=="}, "originalCommit": {"oid": "1e7576087ca05a4daf0e87fa2078394b6eb3dcb5"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzExMTk1Nw==", "bodyText": "I reverted the deadlock related changes from today so that it's green for @iNikem to review\nI'll continue looking into the deadlock issue tomorrow (I can either continue in this PR, or leave debug logging disabled in this PR and work on re-enabling it in a separate PR)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r547111957", "createdAt": "2020-12-22T07:26:22Z", "author": {"login": "trask"}, "path": "gradle/instrumentation.gradle", "diffHunk": "@@ -55,3 +51,73 @@ afterEvaluate {\n     project(':javaagent-tooling').configurations.instrumentationMuzzle + configurations.runtimeClasspath\n   ).configure()\n }\n+\n+configurations {\n+  testInstrumentation\n+}\n+\n+shadowJar {\n+  configurations = [project.configurations.runtimeClasspath, project.configurations.testInstrumentation]\n+  mergeServiceFiles()\n+\n+  archiveFileName = 'agent-testing.jar'\n+\n+  dependencies {\n+    exclude(project(':javaagent-bootstrap'))\n+    exclude(project(':instrumentation-api'))\n+    exclude(project(':javaagent-api'))\n+    exclude(project(':javaagent-tooling'))\n+    exclude(dependency(deps.bytebuddy))\n+    exclude(dependency(deps.opentelemetryApi))\n+    exclude(dependency(deps.opentelemetryContext))\n+    exclude(dependency(deps.slf4j))\n+  }\n+\n+  // rewrite library instrumentation dependencies\n+  relocate \"io.opentelemetry.instrumentation\", \"io.opentelemetry.javaagent.shaded.instrumentation\"\n+\n+  // Prevents conflict with other SLF4J instances. Important for premain.\n+  relocate 'org.slf4j', 'io.opentelemetry.javaagent.slf4j'\n+  // rewrite dependencies calling Logger.getLogger\n+  relocate 'java.util.logging.Logger', 'io.opentelemetry.javaagent.bootstrap.PatchLogger'\n+\n+  // prevents conflict with library instrumentation\n+  relocate 'io.opentelemetry.instrumentation.api', 'io.opentelemetry.javaagent.shaded.instrumentation.api'\n+\n+  // relocate OpenTelemetry API usage\n+  relocate \"io.opentelemetry.api\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.api\"\n+  relocate \"io.opentelemetry.spi\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.spi\"\n+  relocate \"io.opentelemetry.context\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.context\"\n+\n+  // this is for instrumentation on opentelemetry-api itself\n+  relocate \"application.io.opentelemetry\", \"io.opentelemetry\"\n+}\n+\n+tasks.withType(Test).configureEach {\n+  // Multi-threaded logging seems to be causing deadlocks with Gradle's log capture.\n+  //  jvmArgs \"-Dio.opentelemetry.javaagent.slf4j.simpleLogger.defaultLogLevel=debug\"\n+  //  jvmArgs \"-Dorg.slf4j.simpleLogger.defaultLogLevel=debug\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ2NzkzMg=="}, "originalCommit": {"oid": "1e7576087ca05a4daf0e87fa2078394b6eb3dcb5"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYzMTE5Mg==", "bodyText": "I think 839c55e is a reasonable solution (now part of this PR).\nThese were the three classes that I saw being instrumented when deadlocking occurred:\n\nio.opentelemetry.javaagent.instrumentation.api.concurrent.RunnableWrapper\njava.util.concurrent.ForkJoinPool\norg.gradle.something (I don't remember - but this PR adds org.gradle to the GlobalIgnoresMatcher so this one is not a problem anymore)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r547631192", "createdAt": "2020-12-23T04:20:29Z", "author": {"login": "trask"}, "path": "gradle/instrumentation.gradle", "diffHunk": "@@ -55,3 +51,73 @@ afterEvaluate {\n     project(':javaagent-tooling').configurations.instrumentationMuzzle + configurations.runtimeClasspath\n   ).configure()\n }\n+\n+configurations {\n+  testInstrumentation\n+}\n+\n+shadowJar {\n+  configurations = [project.configurations.runtimeClasspath, project.configurations.testInstrumentation]\n+  mergeServiceFiles()\n+\n+  archiveFileName = 'agent-testing.jar'\n+\n+  dependencies {\n+    exclude(project(':javaagent-bootstrap'))\n+    exclude(project(':instrumentation-api'))\n+    exclude(project(':javaagent-api'))\n+    exclude(project(':javaagent-tooling'))\n+    exclude(dependency(deps.bytebuddy))\n+    exclude(dependency(deps.opentelemetryApi))\n+    exclude(dependency(deps.opentelemetryContext))\n+    exclude(dependency(deps.slf4j))\n+  }\n+\n+  // rewrite library instrumentation dependencies\n+  relocate \"io.opentelemetry.instrumentation\", \"io.opentelemetry.javaagent.shaded.instrumentation\"\n+\n+  // Prevents conflict with other SLF4J instances. Important for premain.\n+  relocate 'org.slf4j', 'io.opentelemetry.javaagent.slf4j'\n+  // rewrite dependencies calling Logger.getLogger\n+  relocate 'java.util.logging.Logger', 'io.opentelemetry.javaagent.bootstrap.PatchLogger'\n+\n+  // prevents conflict with library instrumentation\n+  relocate 'io.opentelemetry.instrumentation.api', 'io.opentelemetry.javaagent.shaded.instrumentation.api'\n+\n+  // relocate OpenTelemetry API usage\n+  relocate \"io.opentelemetry.api\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.api\"\n+  relocate \"io.opentelemetry.spi\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.spi\"\n+  relocate \"io.opentelemetry.context\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.context\"\n+\n+  // this is for instrumentation on opentelemetry-api itself\n+  relocate \"application.io.opentelemetry\", \"io.opentelemetry\"\n+}\n+\n+tasks.withType(Test).configureEach {\n+  // Multi-threaded logging seems to be causing deadlocks with Gradle's log capture.\n+  //  jvmArgs \"-Dio.opentelemetry.javaagent.slf4j.simpleLogger.defaultLogLevel=debug\"\n+  //  jvmArgs \"-Dorg.slf4j.simpleLogger.defaultLogLevel=debug\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ2NzkzMg=="}, "originalCommit": {"oid": "1e7576087ca05a4daf0e87fa2078394b6eb3dcb5"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNTc2ODg5OnYy", "diffSide": "RIGHT", "path": "instrumentation/kotlinx-coroutines/javaagent/src/test/groovy/KotlinCoroutineInstrumentationTest.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwNDozMTo0NVrOIJL8kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwNzo1MjoyNlrOIJPKdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjUwMzgyNg==", "bodyText": "@anuraaga I left this one for you \ud83d\ude01", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r546503826", "createdAt": "2020-12-21T04:31:45Z", "author": {"login": "trask"}, "path": "instrumentation/kotlinx-coroutines/javaagent/src/test/groovy/KotlinCoroutineInstrumentationTest.groovy", "diffHunk": "@@ -7,7 +7,10 @@ import io.opentelemetry.api.common.AttributeKey\n import io.opentelemetry.instrumentation.test.AgentTestRunner\n import kotlinx.coroutines.Dispatchers\n import kotlinx.coroutines.ThreadPoolDispatcherKt\n+import spock.lang.Ignore\n \n+// FIXME (trask)\n+@Ignore", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a44cefd04e11ae646b56bc987eb64f9fac677cda"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU1NjUzMg==", "bodyText": "ignore me, this is done \ud83d\udc4d", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r546556532", "createdAt": "2020-12-21T07:52:26Z", "author": {"login": "trask"}, "path": "instrumentation/kotlinx-coroutines/javaagent/src/test/groovy/KotlinCoroutineInstrumentationTest.groovy", "diffHunk": "@@ -7,7 +7,10 @@ import io.opentelemetry.api.common.AttributeKey\n import io.opentelemetry.instrumentation.test.AgentTestRunner\n import kotlinx.coroutines.Dispatchers\n import kotlinx.coroutines.ThreadPoolDispatcherKt\n+import spock.lang.Ignore\n \n+// FIXME (trask)\n+@Ignore", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjUwMzgyNg=="}, "originalCommit": {"oid": "a44cefd04e11ae646b56bc987eb64f9fac677cda"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNjA3ODM3OnYy", "diffSide": "RIGHT", "path": "instrumentation/kotlinx-coroutines/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/kotlinxcoroutines/KotlinCoroutinesInstrumentationModule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwNzoyNjo0MlrOIJOoFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwNzoyNjo0MlrOIJOoFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU0NzczMw==", "bodyText": "Hooray for better tests!", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r546547733", "createdAt": "2020-12-21T07:26:42Z", "author": {"login": "anuraaga"}, "path": "instrumentation/kotlinx-coroutines/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/kotlinxcoroutines/KotlinCoroutinesInstrumentationModule.java", "diffHunk": "@@ -28,6 +28,15 @@ public KotlinCoroutinesInstrumentationModule() {\n     super(\"kotlinx-coroutines\");\n   }\n \n+  @Override\n+  public String[] additionalHelperClassNames() {\n+    return new String[] {\n+      \"io.opentelemetry.extension.kotlin.ContextExtensionsKt\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2264e26f1ec3917b4d1c5a84dbb9b06237555063"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNjI4MzM2OnYy", "diffSide": "LEFT", "path": "instrumentation/hystrix-1.4/javaagent/src/test/groovy/HystrixObservableTest.groovy", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwODo0NTozMlrOIJQe6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwODo0NTozMlrOIJQe6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU3ODE1Mw==", "bodyText": "Note to reviewers, the span name already asserts this, no need for a testing-only API", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r546578153", "createdAt": "2020-12-21T08:45:32Z", "author": {"login": "anuraaga"}, "path": "instrumentation/hystrix-1.4/javaagent/src/test/groovy/HystrixObservableTest.groovy", "diffHunk": "@@ -62,7 +46,6 @@ class HystrixObservableTest extends AgentTestRunner {\n     }\n \n     expect:\n-    TRANSFORMED_CLASSES_NAMES.contains(\"HystrixObservableTest\\$1\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21acc89ec7b325198b7d492b66cef3f7eeb5a2cd"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNjMxMTIwOnYy", "diffSide": "RIGHT", "path": "instrumentation/opentelemetry-api-1.0/javaagent/src/test/groovy/ContextBridgeTest.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwODo1NDoyNVrOIJQu3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwODo1NDoyNVrOIJQu3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU4MjIzOQ==", "bodyText": "\ud83d\ude38", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r546582239", "createdAt": "2020-12-21T08:54:25Z", "author": {"login": "anuraaga"}, "path": "instrumentation/opentelemetry-api-1.0/javaagent/src/test/groovy/ContextBridgeTest.groovy", "diffHunk": "@@ -3,192 +3,150 @@\n  * SPDX-License-Identifier: Apache-2.0\n  */\n \n-import application.io.opentelemetry.api.OpenTelemetry\n-import application.io.opentelemetry.api.baggage.Baggage\n-import application.io.opentelemetry.api.baggage.BaggageEntryMetadata\n-import application.io.opentelemetry.api.trace.Span\n-import application.io.opentelemetry.context.Context\n-import application.io.opentelemetry.context.ContextKey\n+import io.opentelemetry.api.OpenTelemetry\n+import io.opentelemetry.api.baggage.Baggage\n+import io.opentelemetry.api.trace.Span\n+import io.opentelemetry.context.Context\n+import io.opentelemetry.context.ContextKey\n+import io.opentelemetry.extension.annotations.WithSpan\n import io.opentelemetry.instrumentation.test.AgentTestRunner\n+import java.util.concurrent.CountDownLatch\n+import java.util.concurrent.Executors\n import java.util.concurrent.atomic.AtomicReference\n \n class ContextBridgeTest extends AgentTestRunner {\n \n   private static final ContextKey<String> ANIMAL = ContextKey.named(\"animal\")\n \n-  private static final io.opentelemetry.context.ContextKey<String> FOOD =\n-    io.opentelemetry.context.ContextKey.named(\"food\")\n-  private static final io.opentelemetry.context.ContextKey<String> COUNTRY =\n-    io.opentelemetry.context.ContextKey.named(\"country\")\n-\n-  def \"agent and application mix\"() {\n-    expect:\n-    def agentContext = io.opentelemetry.context.Context.current().with(COUNTRY, \"japan\")\n-    io.opentelemetry.context.Context.current().get(COUNTRY) == null\n-    agentContext.makeCurrent().withCloseable {\n-      io.opentelemetry.context.Context.current().get(COUNTRY) == \"japan\"\n-      Context.current().with(ANIMAL, \"cat\").makeCurrent().withCloseable {\n-        Context.current().get(ANIMAL) == \"cat\"\n-        io.opentelemetry.context.Context.current().get(COUNTRY) == \"japan\"\n-\n-        def agentContext2 = io.opentelemetry.context.Context.current().with(FOOD, \"cheese\")\n-        io.opentelemetry.context.Context.current().get(FOOD) == null\n-        agentContext2.makeCurrent().withCloseable {\n-          io.opentelemetry.context.Context.current().get(FOOD) == \"cheese\"\n-          io.opentelemetry.context.Context.current().get(COUNTRY) == \"japan\"\n-          Context.current().get(ANIMAL) == \"cat\"\n-        }\n-      }\n+  def \"agent propagates application's context\"() {\n+    when:\n+    def context = Context.current().with(ANIMAL, \"cat\")\n+    def captured = new AtomicReference<String>()\n+    context.makeCurrent().withCloseable {\n+      Executors.newSingleThreadExecutor().submit({\n+        captured.set(Context.current().get(ANIMAL))\n+      }).get()\n     }\n+\n+    then:\n+    captured.get() == \"cat\"\n   }\n \n-  // The difference between \"standard\" context interop and our bridge is that with normal interop,\n-  // keys are still isolated completely. We have special logic to share the same data for our known\n-  // types like span.\n-  def \"agent and application share span\"() {\n+  def \"application propagates agent's context\"() {\n     when:\n-    def applicationTracer = OpenTelemetry.getGlobalTracer(\"test\")\n-    def agentTracer = io.opentelemetry.api.OpenTelemetry.getGlobalTracer(\"test\")\n+    new Runnable() {\n+      @WithSpan(\"test\")\n+      @Override\n+      void run() {\n+        // using @WithSpan above to make the agent generate a context\n+        // and then using manual propagation below to verify that context can be propagated by user\n+        def context = Context.current()\n+        Context.root().makeCurrent().withCloseable {\n+          Span.current().setAttribute(\"dog\", \"no\")\n+          context.makeCurrent().withCloseable {\n+            Span.current().setAttribute(\"cat\", \"yes\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21acc89ec7b325198b7d492b66cef3f7eeb5a2cd"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNjMyNDcwOnYy", "diffSide": "RIGHT", "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/matcher/AdditionalLibraryIgnoresMatcher.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwODo1ODozMVrOIJQ2vA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QyMzo0MzozNlrOIK65Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU4NDI1Mg==", "bodyText": "What's this change for? Existing bug?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r546584252", "createdAt": "2020-12-21T08:58:31Z", "author": {"login": "anuraaga"}, "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/matcher/AdditionalLibraryIgnoresMatcher.java", "diffHunk": "@@ -42,14 +42,17 @@ public boolean matches(T target) {\n         || name.startsWith(\"com.jayway.jsonpath.\")\n         || name.startsWith(\"com.lightbend.lagom.\")\n         || name.startsWith(\"javax.el.\")\n-        || name.startsWith(\"net.sf.cglib.\")\n         || name.startsWith(\"org.apache.lucene.\")\n         || name.startsWith(\"org.apache.tartarus.\")\n         || name.startsWith(\"org.json.simple.\")\n         || name.startsWith(\"org.yaml.snakeyaml.\")) {\n       return true;\n     }\n \n+    if (name.startsWith(\"net.sf.cglib.\")) {\n+      return !name.equals(\"net.sf.cglib.core.internal.LoadingCache$2\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21acc89ec7b325198b7d492b66cef3f7eeb5a2cd"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjkyMzQ0OQ==", "bodyText": "doesn't seem needed (anymore?), removed", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r546923449", "createdAt": "2020-12-21T20:51:23Z", "author": {"login": "trask"}, "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/matcher/AdditionalLibraryIgnoresMatcher.java", "diffHunk": "@@ -42,14 +42,17 @@ public boolean matches(T target) {\n         || name.startsWith(\"com.jayway.jsonpath.\")\n         || name.startsWith(\"com.lightbend.lagom.\")\n         || name.startsWith(\"javax.el.\")\n-        || name.startsWith(\"net.sf.cglib.\")\n         || name.startsWith(\"org.apache.lucene.\")\n         || name.startsWith(\"org.apache.tartarus.\")\n         || name.startsWith(\"org.json.simple.\")\n         || name.startsWith(\"org.yaml.snakeyaml.\")) {\n       return true;\n     }\n \n+    if (name.startsWith(\"net.sf.cglib.\")) {\n+      return !name.equals(\"net.sf.cglib.core.internal.LoadingCache$2\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU4NDI1Mg=="}, "originalCommit": {"oid": "21acc89ec7b325198b7d492b66cef3f7eeb5a2cd"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkwNjQyNg==", "bodyText": "I still see it :)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r547906426", "createdAt": "2020-12-23T11:11:52Z", "author": {"login": "iNikem"}, "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/matcher/AdditionalLibraryIgnoresMatcher.java", "diffHunk": "@@ -42,14 +42,17 @@ public boolean matches(T target) {\n         || name.startsWith(\"com.jayway.jsonpath.\")\n         || name.startsWith(\"com.lightbend.lagom.\")\n         || name.startsWith(\"javax.el.\")\n-        || name.startsWith(\"net.sf.cglib.\")\n         || name.startsWith(\"org.apache.lucene.\")\n         || name.startsWith(\"org.apache.tartarus.\")\n         || name.startsWith(\"org.json.simple.\")\n         || name.startsWith(\"org.yaml.snakeyaml.\")) {\n       return true;\n     }\n \n+    if (name.startsWith(\"net.sf.cglib.\")) {\n+      return !name.equals(\"net.sf.cglib.core.internal.LoadingCache$2\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU4NDI1Mg=="}, "originalCommit": {"oid": "21acc89ec7b325198b7d492b66cef3f7eeb5a2cd"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMyMTU4Nw==", "bodyText": "I had to bring it back, :testing-common:integration-tests needs it to pass, same reason as other exclusions in here, some test triggers it to load, and our test verification complains that we transformed a class that would have been ignored via the AdditionalLibraryIgnoresMatcher", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r548321587", "createdAt": "2020-12-23T23:43:36Z", "author": {"login": "trask"}, "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/matcher/AdditionalLibraryIgnoresMatcher.java", "diffHunk": "@@ -42,14 +42,17 @@ public boolean matches(T target) {\n         || name.startsWith(\"com.jayway.jsonpath.\")\n         || name.startsWith(\"com.lightbend.lagom.\")\n         || name.startsWith(\"javax.el.\")\n-        || name.startsWith(\"net.sf.cglib.\")\n         || name.startsWith(\"org.apache.lucene.\")\n         || name.startsWith(\"org.apache.tartarus.\")\n         || name.startsWith(\"org.json.simple.\")\n         || name.startsWith(\"org.yaml.snakeyaml.\")) {\n       return true;\n     }\n \n+    if (name.startsWith(\"net.sf.cglib.\")) {\n+      return !name.equals(\"net.sf.cglib.core.internal.LoadingCache$2\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU4NDI1Mg=="}, "originalCommit": {"oid": "21acc89ec7b325198b7d492b66cef3f7eeb5a2cd"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNjMyNjczOnYy", "diffSide": "RIGHT", "path": "settings.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwODo1OTowOFrOIJQ33Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwODo1OTowOFrOIJQ33Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU4NDU0MQ==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r546584541", "createdAt": "2020-12-21T08:59:08Z", "author": {"login": "anuraaga"}, "path": "settings.gradle", "diffHunk": "@@ -217,7 +221,9 @@ include ':benchmark-integration'\n include ':benchmark-integration:jetty-perftest'\n \n def setBuildFile(project) {\n-  if (['javaagent', 'library', 'testing'].contains(project.projectDir.name) && project.path != ':javaagent') {\n+  // javaagent-unittests modules are needed until those projects have library modules", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21acc89ec7b325198b7d492b66cef3f7eeb5a2cd"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNjMzMDI0OnYy", "diffSide": "RIGHT", "path": "testing-common/integration-tests/src/main/java/context/ContextTestInstrumentationModule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwOTowMDoxOFrOIJQ6Bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQyMDo0MTowMFrOIJlUSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU4NTA5NQ==", "bodyText": "Is this needed even though we don't have a suppress? Well IIRC default of bytebuddy is to suppress, should we disable suppression instead and let it throw?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r546585095", "createdAt": "2020-12-21T09:00:18Z", "author": {"login": "anuraaga"}, "path": "testing-common/integration-tests/src/main/java/context/ContextTestInstrumentationModule.java", "diffHunk": "@@ -87,10 +93,14 @@ public static void methodExit(@Advice.Return(readOnly = false) boolean isInstrum\n     @Advice.OnMethodExit\n     public static void methodExit(\n         @Advice.This KeyClass thiz, @Advice.Return(readOnly = false) int contextCount) {\n-      ContextStore<KeyClass, Context> contextStore =\n-          InstrumentationContext.get(KeyClass.class, Context.class);\n-      Context context = contextStore.putIfAbsent(thiz, new Context());\n-      contextCount = ++context.count;\n+      try {\n+        ContextStore<KeyClass, Context> contextStore =\n+            InstrumentationContext.get(KeyClass.class, Context.class);\n+        Context context = contextStore.putIfAbsent(thiz, new Context());\n+        contextCount = ++context.count;\n+      } catch (Throwable t) {\n+        t.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21acc89ec7b325198b7d492b66cef3f7eeb5a2cd"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjkxOTQ5OA==", "bodyText": "oops, this was just debugging code that I forgot to remove \ud83d\udc4d", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r546919498", "createdAt": "2020-12-21T20:41:00Z", "author": {"login": "trask"}, "path": "testing-common/integration-tests/src/main/java/context/ContextTestInstrumentationModule.java", "diffHunk": "@@ -87,10 +93,14 @@ public static void methodExit(@Advice.Return(readOnly = false) boolean isInstrum\n     @Advice.OnMethodExit\n     public static void methodExit(\n         @Advice.This KeyClass thiz, @Advice.Return(readOnly = false) int contextCount) {\n-      ContextStore<KeyClass, Context> contextStore =\n-          InstrumentationContext.get(KeyClass.class, Context.class);\n-      Context context = contextStore.putIfAbsent(thiz, new Context());\n-      contextCount = ++context.count;\n+      try {\n+        ContextStore<KeyClass, Context> contextStore =\n+            InstrumentationContext.get(KeyClass.class, Context.class);\n+        Context context = contextStore.putIfAbsent(thiz, new Context());\n+        contextCount = ++context.count;\n+      } catch (Throwable t) {\n+        t.printStackTrace();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU4NTA5NQ=="}, "originalCommit": {"oid": "21acc89ec7b325198b7d492b66cef3f7eeb5a2cd"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNjMzNDg3OnYy", "diffSide": "RIGHT", "path": "testing-common/integration-tests/src/test/groovy/context/FieldInjectionDisabledTest.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwOTowMTo1N1rOIJQ86g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwOTowMTo1N1rOIJQ86g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU4NTgzNA==", "bodyText": "We do this for many tests, is there anything specific for this one?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r546585834", "createdAt": "2020-12-21T09:01:57Z", "author": {"login": "anuraaga"}, "path": "testing-common/integration-tests/src/test/groovy/context/FieldInjectionDisabledTest.groovy", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package context\n+\n+import io.opentelemetry.instrumentation.test.AgentTestRunner\n+import java.lang.reflect.Field\n+import java.util.function.BiFunction\n+import library.DisabledKeyClass\n+\n+/**\n+ * Make sure that fields not get injected into the class if it is disabled via system properties.\n+ *\n+ * Unfortunately we cannot set system properties here early enough for AgentTestRunner to see.\n+ * Instead we have to configure this via Gradle. Ideally we should not have to do this.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21acc89ec7b325198b7d492b66cef3f7eeb5a2cd"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNjMzNzM0OnYy", "diffSide": "LEFT", "path": "testing-common/src/main/groovy/io/opentelemetry/instrumentation/test/InstrumentationSpecification.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwOTowMjo1NVrOIJQ-bQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwOTowMjo1NVrOIJQ-bQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU4NjIyMQ==", "bodyText": "Nice", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r546586221", "createdAt": "2020-12-21T09:02:55Z", "author": {"login": "anuraaga"}, "path": "testing-common/src/main/groovy/io/opentelemetry/instrumentation/test/InstrumentationSpecification.groovy", "diffHunk": "@@ -25,13 +24,4 @@ abstract class InstrumentationSpecification extends Specification {\n       options = \"io.opentelemetry.instrumentation.test.asserts.ListWriterAssert\")\n     @DelegatesTo(value = InMemoryExporterAssert, strategy = Closure.DELEGATE_FIRST)\n     final Closure spec)\n-\n-  abstract void assertTracesWithFilter(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21acc89ec7b325198b7d492b66cef3f7eeb5a2cd"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNjMzOTA5OnYy", "diffSide": "RIGHT", "path": "testing-common/src/main/groovy/io/opentelemetry/instrumentation/test/InstrumentationTestRunner.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwOTowMzoyNlrOIJQ_bQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwOTowMzoyNlrOIJQ_bQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU4NjQ3Nw==", "bodyText": "Oh - yeah should be able to", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r546586477", "createdAt": "2020-12-21T09:03:26Z", "author": {"login": "anuraaga"}, "path": "testing-common/src/main/groovy/io/opentelemetry/instrumentation/test/InstrumentationTestRunner.groovy", "diffHunk": "@@ -5,64 +5,98 @@\n \n package io.opentelemetry.instrumentation.test\n \n-import com.google.common.base.Predicate\n-import com.google.common.base.Predicates\n+\n import groovy.transform.stc.ClosureParams\n import groovy.transform.stc.SimpleType\n import io.opentelemetry.api.OpenTelemetry\n import io.opentelemetry.api.trace.propagation.W3CTraceContextPropagator\n+import io.opentelemetry.context.Context\n import io.opentelemetry.context.propagation.ContextPropagators\n import io.opentelemetry.instrumentation.test.asserts.InMemoryExporterAssert\n import io.opentelemetry.sdk.OpenTelemetrySdk\n-import io.opentelemetry.sdk.trace.data.SpanData\n+import io.opentelemetry.sdk.common.CompletableResultCode\n+import io.opentelemetry.sdk.testing.exporter.InMemorySpanExporter\n+import io.opentelemetry.sdk.trace.ReadWriteSpan\n+import io.opentelemetry.sdk.trace.ReadableSpan\n+import io.opentelemetry.sdk.trace.SpanProcessor\n+import io.opentelemetry.sdk.trace.export.SimpleSpanProcessor\n import org.junit.Before\n import spock.lang.Specification\n+\n /**\n  * A spock test runner which automatically initializes an in-memory exporter that can be used to\n  * verify traces.\n  */\n abstract class InstrumentationTestRunner extends Specification {\n \n-  protected static final InMemoryExporter TEST_WRITER\n+  protected static final InMemorySpanExporter testExporter\n+\n+  private static boolean forceFlushCalled\n \n   static {\n-    TEST_WRITER = new InMemoryExporter()\n+    testExporter = InMemorySpanExporter.create()\n     // TODO this is probably temporary until default propagators are supplied by SDK\n     //  https://github.com/open-telemetry/opentelemetry-java/issues/1742\n     //  currently checking against no-op implementation so that it won't override aws-lambda\n     //  propagator configuration\n     if (OpenTelemetry.getGlobalPropagators().getTextMapPropagator().getClass().getSimpleName() == \"NoopTextMapPropagator\") {\n-      // Workaround https://github.com/open-telemetry/opentelemetry-java/pull/2096\n       OpenTelemetry.setGlobalPropagators(\n         ContextPropagators.create(W3CTraceContextPropagator.getInstance()))\n     }\n-    OpenTelemetrySdk.getGlobalTracerManagement().addSpanProcessor(TEST_WRITER)\n+    // TODO (trask) can we add 2 span processors here and not delegate?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21acc89ec7b325198b7d492b66cef3f7eeb5a2cd"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNjM0MDkwOnYy", "diffSide": "RIGHT", "path": "testing-common/src/main/groovy/io/opentelemetry/instrumentation/test/asserts/TraceAssert.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwOTowMzo1OFrOIJRAbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwOTowMzo1OFrOIJRAbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU4NjczNA==", "bodyText": "Remove?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r546586734", "createdAt": "2020-12-21T09:03:58Z", "author": {"login": "anuraaga"}, "path": "testing-common/src/main/groovy/io/opentelemetry/instrumentation/test/asserts/TraceAssert.groovy", "diffHunk": "@@ -23,14 +24,16 @@ class TraceAssert {\n     this.spans = spans\n   }\n \n-  static void assertTrace(InMemoryExporter writer, String traceId, int expectedSize,\n+  static void assertTrace(Supplier<List<SpanData>> spanSupplier, String traceId, int expectedSize,\n                           @ClosureParams(value = SimpleType, options = ['io.opentelemetry.instrumentation.test.asserts.TraceAssert'])\n                           @DelegatesTo(value = TraceAssert, strategy = Closure.DELEGATE_FIRST) Closure spec) {\n-    def spans = getTrace(writer, traceId)\n+    def spans = getTrace(spanSupplier, traceId)\n     Stopwatch stopwatch = Stopwatch.createStarted()\n     while (spans.size() < expectedSize && stopwatch.elapsed(TimeUnit.SECONDS) < 10) {\n       Thread.sleep(10)\n-      spans = getTrace(writer, traceId)\n+      spans = getTrace(spanSupplier, traceId)\n+      println spans.size()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21acc89ec7b325198b7d492b66cef3f7eeb5a2cd"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNjM0Mjc5OnYy", "diffSide": "RIGHT", "path": "testing-common/src/main/java/io/opentelemetry/instrumentation/test/InMemoryExporter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwOTowNDozN1rOIJRBjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQyMDo0Mjo0MVrOIJlWrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU4NzAyMA==", "bodyText": "Technically it's not an exporter but we can cleanup in followups", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r546587020", "createdAt": "2020-12-21T09:04:37Z", "author": {"login": "anuraaga"}, "path": "testing-common/src/main/java/io/opentelemetry/instrumentation/test/InMemoryExporter.java", "diffHunk": "@@ -5,240 +5,93 @@\n \n package io.opentelemetry.instrumentation.test;\n \n-import com.google.common.base.Predicate;\n-import com.google.common.base.Predicates;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static java.util.stream.Collectors.toList;\n+\n import com.google.common.base.Stopwatch;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.TreeTraverser;\n-import com.google.common.primitives.Ints;\n-import com.google.common.primitives.Longs;\n import io.opentelemetry.api.trace.SpanId;\n-import io.opentelemetry.context.Context;\n-import io.opentelemetry.sdk.common.CompletableResultCode;\n-import io.opentelemetry.sdk.trace.ReadWriteSpan;\n-import io.opentelemetry.sdk.trace.ReadableSpan;\n-import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.javaagent.testing.common.AgentTestingExporterAccess;\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n import io.opentelemetry.sdk.trace.data.SpanData;\n import java.util.ArrayList;\n-import java.util.Collections;\n import java.util.Comparator;\n import java.util.HashMap;\n-import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.CopyOnWriteArrayList;\n-import java.util.concurrent.TimeUnit;\n import java.util.concurrent.TimeoutException;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-public class InMemoryExporter implements SpanProcessor {\n-\n-  private static final Logger log = LoggerFactory.getLogger(InMemoryExporter.class);\n-\n-  private final List<List<SpanData>> traces = new ArrayList<>(); // guarded by tracesLock\n-\n-  private boolean needsTraceSorting; // guarded by tracesLock\n-  private final Set<String> needsSpanSorting = new HashSet<>(); // guarded by tracesLock\n-\n-  private final Object tracesLock = new Object();\n-\n-  // not using span startEpochNanos since that is not strictly increasing so can lead to ties\n-  private final Map<String, Integer> spanOrders = new ConcurrentHashMap<>();\n-  private final AtomicInteger nextSpanOrder = new AtomicInteger();\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n \n-  private volatile boolean forceFlushCalled;\n+public class InMemoryExporter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21acc89ec7b325198b7d492b66cef3f7eeb5a2cd"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjkyMDExMQ==", "bodyText": "\ud83d\udc4d #1955", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r546920111", "createdAt": "2020-12-21T20:42:41Z", "author": {"login": "trask"}, "path": "testing-common/src/main/java/io/opentelemetry/instrumentation/test/InMemoryExporter.java", "diffHunk": "@@ -5,240 +5,93 @@\n \n package io.opentelemetry.instrumentation.test;\n \n-import com.google.common.base.Predicate;\n-import com.google.common.base.Predicates;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static java.util.stream.Collectors.toList;\n+\n import com.google.common.base.Stopwatch;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.TreeTraverser;\n-import com.google.common.primitives.Ints;\n-import com.google.common.primitives.Longs;\n import io.opentelemetry.api.trace.SpanId;\n-import io.opentelemetry.context.Context;\n-import io.opentelemetry.sdk.common.CompletableResultCode;\n-import io.opentelemetry.sdk.trace.ReadWriteSpan;\n-import io.opentelemetry.sdk.trace.ReadableSpan;\n-import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.javaagent.testing.common.AgentTestingExporterAccess;\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n import io.opentelemetry.sdk.trace.data.SpanData;\n import java.util.ArrayList;\n-import java.util.Collections;\n import java.util.Comparator;\n import java.util.HashMap;\n-import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.CopyOnWriteArrayList;\n-import java.util.concurrent.TimeUnit;\n import java.util.concurrent.TimeoutException;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-public class InMemoryExporter implements SpanProcessor {\n-\n-  private static final Logger log = LoggerFactory.getLogger(InMemoryExporter.class);\n-\n-  private final List<List<SpanData>> traces = new ArrayList<>(); // guarded by tracesLock\n-\n-  private boolean needsTraceSorting; // guarded by tracesLock\n-  private final Set<String> needsSpanSorting = new HashSet<>(); // guarded by tracesLock\n-\n-  private final Object tracesLock = new Object();\n-\n-  // not using span startEpochNanos since that is not strictly increasing so can lead to ties\n-  private final Map<String, Integer> spanOrders = new ConcurrentHashMap<>();\n-  private final AtomicInteger nextSpanOrder = new AtomicInteger();\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n \n-  private volatile boolean forceFlushCalled;\n+public class InMemoryExporter {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU4NzAyMA=="}, "originalCommit": {"oid": "21acc89ec7b325198b7d492b66cef3f7eeb5a2cd"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNjM0NzM3OnYy", "diffSide": "RIGHT", "path": "testing-common/src/main/java/io/opentelemetry/javaagent/testing/common/Java8BytecodeBridge.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwOTowNjowM1rOIJRELQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwOTowNjowM1rOIJRELQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU4NzY5Mw==", "bodyText": "Does this javadoc apply? I guess it's just to use in scala / kotlin tests", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r546587693", "createdAt": "2020-12-21T09:06:03Z", "author": {"login": "anuraaga"}, "path": "testing-common/src/main/java/io/opentelemetry/javaagent/testing/common/Java8BytecodeBridge.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.testing.common;\n+\n+import io.opentelemetry.api.OpenTelemetry;\n+import io.opentelemetry.api.trace.Span;\n+import io.opentelemetry.api.trace.Tracer;\n+import io.opentelemetry.context.Context;\n+import io.opentelemetry.context.propagation.ContextPropagators;\n+\n+/**\n+ * A helper for accessing methods that rely on new Java 8 bytecode features such as calling a static\n+ * interface methods. In instrumentation, we may need to call these methods in code that is inlined", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21acc89ec7b325198b7d492b66cef3f7eeb5a2cd"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzOTgyOTU5OnYy", "diffSide": "RIGHT", "path": "gradle/instrumentation.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwNzowNToxNlrOIJwnKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QwNzo0MjoxMVrOIKYvMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzEwNDU1Mg==", "bodyText": "These are compileOnly, do we still have to exclude them?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r547104552", "createdAt": "2020-12-22T07:05:16Z", "author": {"login": "iNikem"}, "path": "gradle/instrumentation.gradle", "diffHunk": "@@ -55,3 +51,76 @@ afterEvaluate {\n     project(':javaagent-tooling').configurations.instrumentationMuzzle + configurations.runtimeClasspath\n   ).configure()\n }\n+\n+configurations {\n+  testInstrumentation\n+}\n+\n+shadowJar {\n+  configurations = [project.configurations.runtimeClasspath, project.configurations.testInstrumentation]\n+  mergeServiceFiles()\n+\n+  archiveFileName = 'agent-testing.jar'\n+\n+  dependencies {\n+    exclude(project(':javaagent-bootstrap'))\n+    exclude(project(':instrumentation-api'))\n+    exclude(project(':javaagent-api'))\n+    exclude(project(':javaagent-tooling'))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb58976873752f8b868542c22dc25b67912a4b55"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzc2MTk3MQ==", "bodyText": "removed", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r547761971", "createdAt": "2020-12-23T07:42:11Z", "author": {"login": "trask"}, "path": "gradle/instrumentation.gradle", "diffHunk": "@@ -55,3 +51,76 @@ afterEvaluate {\n     project(':javaagent-tooling').configurations.instrumentationMuzzle + configurations.runtimeClasspath\n   ).configure()\n }\n+\n+configurations {\n+  testInstrumentation\n+}\n+\n+shadowJar {\n+  configurations = [project.configurations.runtimeClasspath, project.configurations.testInstrumentation]\n+  mergeServiceFiles()\n+\n+  archiveFileName = 'agent-testing.jar'\n+\n+  dependencies {\n+    exclude(project(':javaagent-bootstrap'))\n+    exclude(project(':instrumentation-api'))\n+    exclude(project(':javaagent-api'))\n+    exclude(project(':javaagent-tooling'))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzEwNDU1Mg=="}, "originalCommit": {"oid": "eb58976873752f8b868542c22dc25b67912a4b55"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzOTgzNDYwOnYy", "diffSide": "RIGHT", "path": "gradle/instrumentation.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwNzowNzoxOVrOIJwp7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwODozMzo0M1rOIJyvIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzEwNTI2Mg==", "bodyText": "Why this?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r547105262", "createdAt": "2020-12-22T07:07:19Z", "author": {"login": "iNikem"}, "path": "gradle/instrumentation.gradle", "diffHunk": "@@ -55,3 +51,76 @@ afterEvaluate {\n     project(':javaagent-tooling').configurations.instrumentationMuzzle + configurations.runtimeClasspath\n   ).configure()\n }\n+\n+configurations {\n+  testInstrumentation\n+}\n+\n+shadowJar {\n+  configurations = [project.configurations.runtimeClasspath, project.configurations.testInstrumentation]\n+  mergeServiceFiles()\n+\n+  archiveFileName = 'agent-testing.jar'\n+\n+  dependencies {\n+    exclude(project(':javaagent-bootstrap'))\n+    exclude(project(':instrumentation-api'))\n+    exclude(project(':javaagent-api'))\n+    exclude(project(':javaagent-tooling'))\n+    exclude(dependency(deps.bytebuddy))\n+    exclude(dependency(deps.opentelemetryApi))\n+    exclude(dependency(deps.opentelemetryContext))\n+    exclude(dependency(deps.slf4j))\n+  }\n+\n+  // rewrite library instrumentation dependencies\n+  relocate \"io.opentelemetry.instrumentation\", \"io.opentelemetry.javaagent.shaded.instrumentation\"\n+\n+  // Prevents conflict with other SLF4J instances. Important for premain.\n+  relocate 'org.slf4j', 'io.opentelemetry.javaagent.slf4j'\n+  // rewrite dependencies calling Logger.getLogger\n+  relocate 'java.util.logging.Logger', 'io.opentelemetry.javaagent.bootstrap.PatchLogger'\n+\n+  // prevents conflict with library instrumentation\n+  relocate 'io.opentelemetry.instrumentation.api', 'io.opentelemetry.javaagent.shaded.instrumentation.api'\n+\n+  // relocate OpenTelemetry API usage\n+  relocate \"io.opentelemetry.api\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.api\"\n+  relocate \"io.opentelemetry.spi\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.spi\"\n+  relocate \"io.opentelemetry.context\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.context\"\n+\n+  // relocate OpenTelemetry extensions\n+  relocate \"io.opentelemetry.extension.kotlin\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.extension.kotlin\"\n+  relocate \"io.opentelemetry.extension.trace.propagation\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.extension.trace.propagation\"\n+\n+  // this is for instrumentation on opentelemetry-api itself\n+  relocate \"application.io.opentelemetry\", \"io.opentelemetry\"\n+}\n+\n+tasks.withType(Test).configureEach {\n+  jvmArgs \"-Dio.opentelemetry.javaagent.slf4j.simpleLogger.defaultLogLevel=debug\"\n+  jvmArgs \"-Dorg.slf4j.simpleLogger.defaultLogLevel=debug\"\n+  jvmArgs \"-Dnet.bytebuddy.raw=true\"\n+  jvmArgs \"-javaagent:${project(\":testing:agent-for-testing\").buildDir}/libs/javaagent-for-testing.jar\"\n+  jvmArgs \"-Dotel.initializer.jar=${shadowJar.archiveFile.get().asFile.absolutePath}\"\n+  jvmArgs \"-Dinternal.testing.disable.global.library.ignores=true\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb58976873752f8b868542c22dc25b67912a4b55"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzEzOTM2Mg==", "bodyText": "this controls AdditionalLibraryIgnoresMatcher (similar to how tests disabled that before and then verified none of the transformed classes would have matched it)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r547139362", "createdAt": "2020-12-22T08:33:43Z", "author": {"login": "trask"}, "path": "gradle/instrumentation.gradle", "diffHunk": "@@ -55,3 +51,76 @@ afterEvaluate {\n     project(':javaagent-tooling').configurations.instrumentationMuzzle + configurations.runtimeClasspath\n   ).configure()\n }\n+\n+configurations {\n+  testInstrumentation\n+}\n+\n+shadowJar {\n+  configurations = [project.configurations.runtimeClasspath, project.configurations.testInstrumentation]\n+  mergeServiceFiles()\n+\n+  archiveFileName = 'agent-testing.jar'\n+\n+  dependencies {\n+    exclude(project(':javaagent-bootstrap'))\n+    exclude(project(':instrumentation-api'))\n+    exclude(project(':javaagent-api'))\n+    exclude(project(':javaagent-tooling'))\n+    exclude(dependency(deps.bytebuddy))\n+    exclude(dependency(deps.opentelemetryApi))\n+    exclude(dependency(deps.opentelemetryContext))\n+    exclude(dependency(deps.slf4j))\n+  }\n+\n+  // rewrite library instrumentation dependencies\n+  relocate \"io.opentelemetry.instrumentation\", \"io.opentelemetry.javaagent.shaded.instrumentation\"\n+\n+  // Prevents conflict with other SLF4J instances. Important for premain.\n+  relocate 'org.slf4j', 'io.opentelemetry.javaagent.slf4j'\n+  // rewrite dependencies calling Logger.getLogger\n+  relocate 'java.util.logging.Logger', 'io.opentelemetry.javaagent.bootstrap.PatchLogger'\n+\n+  // prevents conflict with library instrumentation\n+  relocate 'io.opentelemetry.instrumentation.api', 'io.opentelemetry.javaagent.shaded.instrumentation.api'\n+\n+  // relocate OpenTelemetry API usage\n+  relocate \"io.opentelemetry.api\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.api\"\n+  relocate \"io.opentelemetry.spi\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.spi\"\n+  relocate \"io.opentelemetry.context\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.context\"\n+\n+  // relocate OpenTelemetry extensions\n+  relocate \"io.opentelemetry.extension.kotlin\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.extension.kotlin\"\n+  relocate \"io.opentelemetry.extension.trace.propagation\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.extension.trace.propagation\"\n+\n+  // this is for instrumentation on opentelemetry-api itself\n+  relocate \"application.io.opentelemetry\", \"io.opentelemetry\"\n+}\n+\n+tasks.withType(Test).configureEach {\n+  jvmArgs \"-Dio.opentelemetry.javaagent.slf4j.simpleLogger.defaultLogLevel=debug\"\n+  jvmArgs \"-Dorg.slf4j.simpleLogger.defaultLogLevel=debug\"\n+  jvmArgs \"-Dnet.bytebuddy.raw=true\"\n+  jvmArgs \"-javaagent:${project(\":testing:agent-for-testing\").buildDir}/libs/javaagent-for-testing.jar\"\n+  jvmArgs \"-Dotel.initializer.jar=${shadowJar.archiveFile.get().asFile.absolutePath}\"\n+  jvmArgs \"-Dinternal.testing.disable.global.library.ignores=true\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzEwNTI2Mg=="}, "originalCommit": {"oid": "eb58976873752f8b868542c22dc25b67912a4b55"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzOTg0MDMxOnYy", "diffSide": "RIGHT", "path": "gradle/instrumentation.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwNzowOTozOFrOIJwtMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QwNzo0MzowNlrOIKYyJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzEwNjA5OA==", "bodyText": "I think we have to use sourceSets.main.output here somehow :)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r547106098", "createdAt": "2020-12-22T07:09:38Z", "author": {"login": "iNikem"}, "path": "gradle/instrumentation.gradle", "diffHunk": "@@ -55,3 +51,76 @@ afterEvaluate {\n     project(':javaagent-tooling').configurations.instrumentationMuzzle + configurations.runtimeClasspath\n   ).configure()\n }\n+\n+configurations {\n+  testInstrumentation\n+}\n+\n+shadowJar {\n+  configurations = [project.configurations.runtimeClasspath, project.configurations.testInstrumentation]\n+  mergeServiceFiles()\n+\n+  archiveFileName = 'agent-testing.jar'\n+\n+  dependencies {\n+    exclude(project(':javaagent-bootstrap'))\n+    exclude(project(':instrumentation-api'))\n+    exclude(project(':javaagent-api'))\n+    exclude(project(':javaagent-tooling'))\n+    exclude(dependency(deps.bytebuddy))\n+    exclude(dependency(deps.opentelemetryApi))\n+    exclude(dependency(deps.opentelemetryContext))\n+    exclude(dependency(deps.slf4j))\n+  }\n+\n+  // rewrite library instrumentation dependencies\n+  relocate \"io.opentelemetry.instrumentation\", \"io.opentelemetry.javaagent.shaded.instrumentation\"\n+\n+  // Prevents conflict with other SLF4J instances. Important for premain.\n+  relocate 'org.slf4j', 'io.opentelemetry.javaagent.slf4j'\n+  // rewrite dependencies calling Logger.getLogger\n+  relocate 'java.util.logging.Logger', 'io.opentelemetry.javaagent.bootstrap.PatchLogger'\n+\n+  // prevents conflict with library instrumentation\n+  relocate 'io.opentelemetry.instrumentation.api', 'io.opentelemetry.javaagent.shaded.instrumentation.api'\n+\n+  // relocate OpenTelemetry API usage\n+  relocate \"io.opentelemetry.api\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.api\"\n+  relocate \"io.opentelemetry.spi\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.spi\"\n+  relocate \"io.opentelemetry.context\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.context\"\n+\n+  // relocate OpenTelemetry extensions\n+  relocate \"io.opentelemetry.extension.kotlin\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.extension.kotlin\"\n+  relocate \"io.opentelemetry.extension.trace.propagation\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.extension.trace.propagation\"\n+\n+  // this is for instrumentation on opentelemetry-api itself\n+  relocate \"application.io.opentelemetry\", \"io.opentelemetry\"\n+}\n+\n+tasks.withType(Test).configureEach {\n+  jvmArgs \"-Dio.opentelemetry.javaagent.slf4j.simpleLogger.defaultLogLevel=debug\"\n+  jvmArgs \"-Dorg.slf4j.simpleLogger.defaultLogLevel=debug\"\n+  jvmArgs \"-Dnet.bytebuddy.raw=true\"\n+  jvmArgs \"-javaagent:${project(\":testing:agent-for-testing\").buildDir}/libs/javaagent-for-testing.jar\"\n+  jvmArgs \"-Dotel.initializer.jar=${shadowJar.archiveFile.get().asFile.absolutePath}\"\n+  jvmArgs \"-Dinternal.testing.disable.global.library.ignores=true\"\n+\n+  dependsOn shadowJar\n+  dependsOn \":testing:agent-for-testing:shadowJar\"\n+\n+  // The sources are packaged into the testing jar so we need to make sure to exclude from the test\n+  // classpath, which automatically inherits them, to ensure our shaded versions are used.\n+  classpath = classpath.filter {\n+    if (file(\"$buildDir/resources/main\").equals(it) || file(\"$buildDir/classes/java/main\").equals(it)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb58976873752f8b868542c22dc25b67912a4b55"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzc2MjcyNQ==", "bodyText": "@anuraaga tried lots of options here, this was only thing that worked for now", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r547762725", "createdAt": "2020-12-23T07:43:06Z", "author": {"login": "trask"}, "path": "gradle/instrumentation.gradle", "diffHunk": "@@ -55,3 +51,76 @@ afterEvaluate {\n     project(':javaagent-tooling').configurations.instrumentationMuzzle + configurations.runtimeClasspath\n   ).configure()\n }\n+\n+configurations {\n+  testInstrumentation\n+}\n+\n+shadowJar {\n+  configurations = [project.configurations.runtimeClasspath, project.configurations.testInstrumentation]\n+  mergeServiceFiles()\n+\n+  archiveFileName = 'agent-testing.jar'\n+\n+  dependencies {\n+    exclude(project(':javaagent-bootstrap'))\n+    exclude(project(':instrumentation-api'))\n+    exclude(project(':javaagent-api'))\n+    exclude(project(':javaagent-tooling'))\n+    exclude(dependency(deps.bytebuddy))\n+    exclude(dependency(deps.opentelemetryApi))\n+    exclude(dependency(deps.opentelemetryContext))\n+    exclude(dependency(deps.slf4j))\n+  }\n+\n+  // rewrite library instrumentation dependencies\n+  relocate \"io.opentelemetry.instrumentation\", \"io.opentelemetry.javaagent.shaded.instrumentation\"\n+\n+  // Prevents conflict with other SLF4J instances. Important for premain.\n+  relocate 'org.slf4j', 'io.opentelemetry.javaagent.slf4j'\n+  // rewrite dependencies calling Logger.getLogger\n+  relocate 'java.util.logging.Logger', 'io.opentelemetry.javaagent.bootstrap.PatchLogger'\n+\n+  // prevents conflict with library instrumentation\n+  relocate 'io.opentelemetry.instrumentation.api', 'io.opentelemetry.javaagent.shaded.instrumentation.api'\n+\n+  // relocate OpenTelemetry API usage\n+  relocate \"io.opentelemetry.api\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.api\"\n+  relocate \"io.opentelemetry.spi\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.spi\"\n+  relocate \"io.opentelemetry.context\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.context\"\n+\n+  // relocate OpenTelemetry extensions\n+  relocate \"io.opentelemetry.extension.kotlin\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.extension.kotlin\"\n+  relocate \"io.opentelemetry.extension.trace.propagation\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.extension.trace.propagation\"\n+\n+  // this is for instrumentation on opentelemetry-api itself\n+  relocate \"application.io.opentelemetry\", \"io.opentelemetry\"\n+}\n+\n+tasks.withType(Test).configureEach {\n+  jvmArgs \"-Dio.opentelemetry.javaagent.slf4j.simpleLogger.defaultLogLevel=debug\"\n+  jvmArgs \"-Dorg.slf4j.simpleLogger.defaultLogLevel=debug\"\n+  jvmArgs \"-Dnet.bytebuddy.raw=true\"\n+  jvmArgs \"-javaagent:${project(\":testing:agent-for-testing\").buildDir}/libs/javaagent-for-testing.jar\"\n+  jvmArgs \"-Dotel.initializer.jar=${shadowJar.archiveFile.get().asFile.absolutePath}\"\n+  jvmArgs \"-Dinternal.testing.disable.global.library.ignores=true\"\n+\n+  dependsOn shadowJar\n+  dependsOn \":testing:agent-for-testing:shadowJar\"\n+\n+  // The sources are packaged into the testing jar so we need to make sure to exclude from the test\n+  // classpath, which automatically inherits them, to ensure our shaded versions are used.\n+  classpath = classpath.filter {\n+    if (file(\"$buildDir/resources/main\").equals(it) || file(\"$buildDir/classes/java/main\").equals(it)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzEwNjA5OA=="}, "originalCommit": {"oid": "eb58976873752f8b868542c22dc25b67912a4b55"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzOTg0NjM0OnYy", "diffSide": "RIGHT", "path": "instrumentation/aws-lambda-1.0/library/src/test/groovy/io/opentelemetry/instrumentation/awslambda/v1_0/AwsLambdaSqsHandlerTest.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwNzoxMjoyOVrOIJwwyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwNzo1NjoyN1rOIJxxXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzEwNzAxOA==", "bodyText": "Why do you have propagators configuration both here and in gradle build script?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r547107018", "createdAt": "2020-12-22T07:12:29Z", "author": {"login": "iNikem"}, "path": "instrumentation/aws-lambda-1.0/library/src/test/groovy/io/opentelemetry/instrumentation/awslambda/v1_0/AwsLambdaSqsHandlerTest.groovy", "diffHunk": "@@ -8,10 +8,22 @@ package io.opentelemetry.instrumentation.awslambda.v1_0\n import com.amazonaws.services.lambda.runtime.Context\n import com.amazonaws.services.lambda.runtime.RequestHandler\n import com.amazonaws.services.lambda.runtime.events.SQSEvent\n+import io.opentelemetry.api.OpenTelemetry\n+import io.opentelemetry.api.trace.propagation.W3CTraceContextPropagator\n+import io.opentelemetry.context.propagation.ContextPropagators\n+import io.opentelemetry.context.propagation.TextMapPropagator\n+import io.opentelemetry.extension.trace.propagation.AwsXRayPropagator\n import io.opentelemetry.instrumentation.test.InstrumentationTestTrait\n \n class AwsLambdaSqsHandlerTest extends AbstractAwsLambdaSqsHandlerTest implements InstrumentationTestTrait {\n \n+  // Lambda instrumentation requires XRay propagator to be enabled.\n+  static {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb58976873752f8b868542c22dc25b67912a4b55"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzEyMzU0OQ==", "bodyText": "this is a library test, only javaagent tests have configuration in the gradle build script", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r547123549", "createdAt": "2020-12-22T07:56:27Z", "author": {"login": "trask"}, "path": "instrumentation/aws-lambda-1.0/library/src/test/groovy/io/opentelemetry/instrumentation/awslambda/v1_0/AwsLambdaSqsHandlerTest.groovy", "diffHunk": "@@ -8,10 +8,22 @@ package io.opentelemetry.instrumentation.awslambda.v1_0\n import com.amazonaws.services.lambda.runtime.Context\n import com.amazonaws.services.lambda.runtime.RequestHandler\n import com.amazonaws.services.lambda.runtime.events.SQSEvent\n+import io.opentelemetry.api.OpenTelemetry\n+import io.opentelemetry.api.trace.propagation.W3CTraceContextPropagator\n+import io.opentelemetry.context.propagation.ContextPropagators\n+import io.opentelemetry.context.propagation.TextMapPropagator\n+import io.opentelemetry.extension.trace.propagation.AwsXRayPropagator\n import io.opentelemetry.instrumentation.test.InstrumentationTestTrait\n \n class AwsLambdaSqsHandlerTest extends AbstractAwsLambdaSqsHandlerTest implements InstrumentationTestTrait {\n \n+  // Lambda instrumentation requires XRay propagator to be enabled.\n+  static {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzEwNzAxOA=="}, "originalCommit": {"oid": "eb58976873752f8b868542c22dc25b67912a4b55"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzOTg1NzE4OnYy", "diffSide": "LEFT", "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/AgentInstaller.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwNzoxNjo1NlrOIJw25A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwODoyNToxNVrOIJygQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzEwODU4MA==", "bodyText": "skipAdditionalLibraryMatcher is now unused?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r547108580", "createdAt": "2020-12-22T07:16:56Z", "author": {"login": "iNikem"}, "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/AgentInstaller.java", "diffHunk": "@@ -109,7 +115,9 @@ public static ResettableClassFileTransformer installBytebuddyAgent(\n             .ignore(any(), skipClassLoader());\n \n     ignoredAgentBuilder =\n-        ignoredAgentBuilder.or(globalIgnoresMatcher(skipAdditionalLibraryMatcher));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb58976873752f8b868542c22dc25b67912a4b55"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzEzNTU1Mg==", "bodyText": "\ud83d\udc4d removed", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r547135552", "createdAt": "2020-12-22T08:25:15Z", "author": {"login": "trask"}, "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/AgentInstaller.java", "diffHunk": "@@ -109,7 +115,9 @@ public static ResettableClassFileTransformer installBytebuddyAgent(\n             .ignore(any(), skipClassLoader());\n \n     ignoredAgentBuilder =\n-        ignoredAgentBuilder.or(globalIgnoresMatcher(skipAdditionalLibraryMatcher));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzEwODU4MA=="}, "originalCommit": {"oid": "eb58976873752f8b868542c22dc25b67912a4b55"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzOTg1OTYwOnYy", "diffSide": "RIGHT", "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/AgentInstaller.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwNzoxNzo0N1rOIJw4HA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwNzo1NTo1M1rOIJxwVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzEwODg5Mg==", "bodyText": "What is this? :)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r547108892", "createdAt": "2020-12-22T07:17:47Z", "author": {"login": "iNikem"}, "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/AgentInstaller.java", "diffHunk": "@@ -143,6 +147,11 @@ public static ResettableClassFileTransformer installBytebuddyAgent(\n     agentBuilder = customizeByteBuddyAgent(agentBuilder);\n     log.debug(\"Installed {} instrumenter(s)\", numInstrumenters);\n     ResettableClassFileTransformer resettableClassFileTransformer = agentBuilder.installOn(inst);\n+    try {\n+      Class.forName(\"io.opentelemetry.javaagent.instrumentation.api.concurrent.RunnableWrapper\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb58976873752f8b868542c22dc25b67912a4b55"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzEyMzI4NQ==", "bodyText": "that was part of today's deadlock work, it's gone now", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r547123285", "createdAt": "2020-12-22T07:55:53Z", "author": {"login": "trask"}, "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/AgentInstaller.java", "diffHunk": "@@ -143,6 +147,11 @@ public static ResettableClassFileTransformer installBytebuddyAgent(\n     agentBuilder = customizeByteBuddyAgent(agentBuilder);\n     log.debug(\"Installed {} instrumenter(s)\", numInstrumenters);\n     ResettableClassFileTransformer resettableClassFileTransformer = agentBuilder.installOn(inst);\n+    try {\n+      Class.forName(\"io.opentelemetry.javaagent.instrumentation.api.concurrent.RunnableWrapper\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzEwODg5Mg=="}, "originalCommit": {"oid": "eb58976873752f8b868542c22dc25b67912a4b55"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzOTg2NTc2OnYy", "diffSide": "LEFT", "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/AgentInstaller.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwNzoyMDoyNVrOIJw7pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwODozMTo0OFrOIJyr8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzEwOTc5OQ==", "bodyText": "Is this not needed anymore?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r547109799", "createdAt": "2020-12-22T07:20:25Z", "author": {"login": "iNikem"}, "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/AgentInstaller.java", "diffHunk": "@@ -123,10 +131,6 @@ public static ResettableClassFileTransformer installBytebuddyAgent(\n               .with(new TransformLoggingListener());\n     }\n \n-    for (AgentBuilder.Listener listener : listeners) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb58976873752f8b868542c22dc25b67912a4b55"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzEzODU0NQ==", "bodyText": "this was only used for tests, now there's TestAgentListenerAccess", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r547138545", "createdAt": "2020-12-22T08:31:48Z", "author": {"login": "trask"}, "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/AgentInstaller.java", "diffHunk": "@@ -123,10 +131,6 @@ public static ResettableClassFileTransformer installBytebuddyAgent(\n               .with(new TransformLoggingListener());\n     }\n \n-    for (AgentBuilder.Listener listener : listeners) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzEwOTc5OQ=="}, "originalCommit": {"oid": "eb58976873752f8b868542c22dc25b67912a4b55"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzOTg2NjU5OnYy", "diffSide": "LEFT", "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/matcher/AdditionalLibraryIgnoresMatcher.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwNzoyMDo1NFrOIJw8Lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwNzo1NTozM1rOIJxvxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzEwOTkzNQ==", "bodyText": "why?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r547109935", "createdAt": "2020-12-22T07:20:54Z", "author": {"login": "iNikem"}, "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/matcher/AdditionalLibraryIgnoresMatcher.java", "diffHunk": "@@ -42,7 +42,6 @@ public boolean matches(T target) {\n         || name.startsWith(\"com.jayway.jsonpath.\")\n         || name.startsWith(\"com.lightbend.lagom.\")\n         || name.startsWith(\"javax.el.\")\n-        || name.startsWith(\"net.sf.cglib.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb58976873752f8b868542c22dc25b67912a4b55"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzEyMzE0MA==", "bodyText": "this was a mistake, just pushed it back \ud83d\udc4d", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r547123140", "createdAt": "2020-12-22T07:55:33Z", "author": {"login": "trask"}, "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/matcher/AdditionalLibraryIgnoresMatcher.java", "diffHunk": "@@ -42,7 +42,6 @@ public boolean matches(T target) {\n         || name.startsWith(\"com.jayway.jsonpath.\")\n         || name.startsWith(\"com.lightbend.lagom.\")\n         || name.startsWith(\"javax.el.\")\n-        || name.startsWith(\"net.sf.cglib.\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzEwOTkzNQ=="}, "originalCommit": {"oid": "eb58976873752f8b868542c22dc25b67912a4b55"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzOTg3NDc2OnYy", "diffSide": "LEFT", "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/matcher/GlobalIgnoresMatcher.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwNzoyNDoxMVrOIJxAzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwNzoyNDoxMVrOIJxAzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzExMTExOA==", "bodyText": "This seems like a reasonable addition even if it doesn't solve our deadlock. If nothing else, it could speed up the build a bit by having less to run instrumentation on?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r547111118", "createdAt": "2020-12-22T07:24:11Z", "author": {"login": "anuraaga"}, "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/matcher/GlobalIgnoresMatcher.java", "diffHunk": "@@ -57,8 +57,7 @@ public boolean matches(T target) {\n       return false;\n     }\n \n-    if (name.startsWith(\"org.gradle.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1efdffe3e98d795531f4dcac25efd87b3a7e4a37"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzOTkyMjczOnYy", "diffSide": "LEFT", "path": "testing-common/src/main/java/io/opentelemetry/instrumentation/test/InMemoryExporter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwNzo0MjozMVrOIJxb-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwODozNjoxN1rOIJyzoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzExODA3Mw==", "bodyText": "Who does this now?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r547118073", "createdAt": "2020-12-22T07:42:31Z", "author": {"login": "iNikem"}, "path": "testing-common/src/main/java/io/opentelemetry/instrumentation/test/InMemoryExporter.java", "diffHunk": "@@ -5,240 +5,93 @@\n \n package io.opentelemetry.instrumentation.test;\n \n-import com.google.common.base.Predicate;\n-import com.google.common.base.Predicates;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static java.util.stream.Collectors.toList;\n+\n import com.google.common.base.Stopwatch;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.TreeTraverser;\n-import com.google.common.primitives.Ints;\n-import com.google.common.primitives.Longs;\n import io.opentelemetry.api.trace.SpanId;\n-import io.opentelemetry.context.Context;\n-import io.opentelemetry.sdk.common.CompletableResultCode;\n-import io.opentelemetry.sdk.trace.ReadWriteSpan;\n-import io.opentelemetry.sdk.trace.ReadableSpan;\n-import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.javaagent.testing.common.AgentTestingExporterAccess;\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n import io.opentelemetry.sdk.trace.data.SpanData;\n import java.util.ArrayList;\n-import java.util.Collections;\n import java.util.Comparator;\n import java.util.HashMap;\n-import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.CopyOnWriteArrayList;\n-import java.util.concurrent.TimeUnit;\n import java.util.concurrent.TimeoutException;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-public class InMemoryExporter implements SpanProcessor {\n-\n-  private static final Logger log = LoggerFactory.getLogger(InMemoryExporter.class);\n-\n-  private final List<List<SpanData>> traces = new ArrayList<>(); // guarded by tracesLock\n-\n-  private boolean needsTraceSorting; // guarded by tracesLock\n-  private final Set<String> needsSpanSorting = new HashSet<>(); // guarded by tracesLock\n-\n-  private final Object tracesLock = new Object();\n-\n-  // not using span startEpochNanos since that is not strictly increasing so can lead to ties\n-  private final Map<String, Integer> spanOrders = new ConcurrentHashMap<>();\n-  private final AtomicInteger nextSpanOrder = new AtomicInteger();\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n \n-  private volatile boolean forceFlushCalled;\n+public class InMemoryExporter {\n \n-  @Override\n-  public void onStart(Context context, ReadWriteSpan readWriteSpan) {\n-    SpanData sd = readWriteSpan.toSpanData();\n-    log.debug(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c684902cd11b0101dd5defd4d6540877c7775938"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzE0MDUxMw==", "bodyText": "OtlpInMemorySpanExporter", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r547140513", "createdAt": "2020-12-22T08:36:17Z", "author": {"login": "trask"}, "path": "testing-common/src/main/java/io/opentelemetry/instrumentation/test/InMemoryExporter.java", "diffHunk": "@@ -5,240 +5,93 @@\n \n package io.opentelemetry.instrumentation.test;\n \n-import com.google.common.base.Predicate;\n-import com.google.common.base.Predicates;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static java.util.stream.Collectors.toList;\n+\n import com.google.common.base.Stopwatch;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.TreeTraverser;\n-import com.google.common.primitives.Ints;\n-import com.google.common.primitives.Longs;\n import io.opentelemetry.api.trace.SpanId;\n-import io.opentelemetry.context.Context;\n-import io.opentelemetry.sdk.common.CompletableResultCode;\n-import io.opentelemetry.sdk.trace.ReadWriteSpan;\n-import io.opentelemetry.sdk.trace.ReadableSpan;\n-import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.javaagent.testing.common.AgentTestingExporterAccess;\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n import io.opentelemetry.sdk.trace.data.SpanData;\n import java.util.ArrayList;\n-import java.util.Collections;\n import java.util.Comparator;\n import java.util.HashMap;\n-import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.CopyOnWriteArrayList;\n-import java.util.concurrent.TimeUnit;\n import java.util.concurrent.TimeoutException;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-public class InMemoryExporter implements SpanProcessor {\n-\n-  private static final Logger log = LoggerFactory.getLogger(InMemoryExporter.class);\n-\n-  private final List<List<SpanData>> traces = new ArrayList<>(); // guarded by tracesLock\n-\n-  private boolean needsTraceSorting; // guarded by tracesLock\n-  private final Set<String> needsSpanSorting = new HashSet<>(); // guarded by tracesLock\n-\n-  private final Object tracesLock = new Object();\n-\n-  // not using span startEpochNanos since that is not strictly increasing so can lead to ties\n-  private final Map<String, Integer> spanOrders = new ConcurrentHashMap<>();\n-  private final AtomicInteger nextSpanOrder = new AtomicInteger();\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n \n-  private volatile boolean forceFlushCalled;\n+public class InMemoryExporter {\n \n-  @Override\n-  public void onStart(Context context, ReadWriteSpan readWriteSpan) {\n-    SpanData sd = readWriteSpan.toSpanData();\n-    log.debug(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzExODA3Mw=="}, "originalCommit": {"oid": "c684902cd11b0101dd5defd4d6540877c7775938"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MDgxOTgxOnYy", "diffSide": "RIGHT", "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/AgentInstaller.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMjozNTowOFrOIJ5q4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNFQxMjozNzoyNlrOILG6Sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI1Mjk2Mg==", "bodyText": "The PR does not change this API, however could we keep it to make sure the existing tests in vendor distributions work?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r547252962", "createdAt": "2020-12-22T12:35:08Z", "author": {"login": "pavolloffay"}, "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/AgentInstaller.java", "diffHunk": "@@ -81,10 +87,7 @@ public static void installBytebuddyAgent(Instrumentation inst) {\n    * @return the agent's class transformer\n    */\n   public static ResettableClassFileTransformer installBytebuddyAgent(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac643e67508e0c52902f68aea600608f67acba49"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzY1NDI4Mg==", "bodyText": "hey @pavolloffay, can you add some tests to the example distro? that will help clear up what impact this change has on them", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r547654282", "createdAt": "2020-12-23T05:19:49Z", "author": {"login": "trask"}, "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/AgentInstaller.java", "diffHunk": "@@ -81,10 +87,7 @@ public static void installBytebuddyAgent(Instrumentation inst) {\n    * @return the agent's class transformer\n    */\n   public static ResettableClassFileTransformer installBytebuddyAgent(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI1Mjk2Mg=="}, "originalCommit": {"oid": "ac643e67508e0c52902f68aea600608f67acba49"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODUxODQ3NA==", "bodyText": "to do this I will have to copy some classes from the main project. Here is an example of what I use in the Hypertrace agent https://github.com/hypertrace/javaagent/blob/main/testing-common/src/main/java/org/hypertrace/agent/testing/AbstractInstrumenterTest.java#L83. We are not publishing the testing artifact #1644", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r548518474", "createdAt": "2020-12-24T12:37:26Z", "author": {"login": "pavolloffay"}, "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/AgentInstaller.java", "diffHunk": "@@ -81,10 +87,7 @@ public static void installBytebuddyAgent(Instrumentation inst) {\n    * @return the agent's class transformer\n    */\n   public static ResettableClassFileTransformer installBytebuddyAgent(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI1Mjk2Mg=="}, "originalCommit": {"oid": "ac643e67508e0c52902f68aea600608f67acba49"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0NDk5OTk4OnYy", "diffSide": "RIGHT", "path": ".github/workflows/pr.yaml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QxMTowMzoyNFrOIKhVsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QxMToyMTowMlrOIKhxCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkwMjg5Nw==", "bodyText": "why no retry?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r547902897", "createdAt": "2020-12-23T11:03:24Z", "author": {"login": "iNikem"}, "path": ".github/workflows/pr.yaml", "diffHunk": "@@ -19,11 +19,7 @@ jobs:\n           job-id: jdk11\n \n       - name: Build\n-        uses: nick-invision/retry@v2.2.0\n-        with:\n-          command: ./gradlew check --stacktrace -x :smoke-tests:test\n-          timeout_minutes: 90\n-          max_attempts: 3\n+        run: ./gradlew check --stacktrace -x :smoke-tests:test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "473acce59118b1fc776578ee3c94136b88f15d4a"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkwOTg5OA==", "bodyText": "A, no I see your comment \ud83d\udc4d", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r547909898", "createdAt": "2020-12-23T11:21:02Z", "author": {"login": "iNikem"}, "path": ".github/workflows/pr.yaml", "diffHunk": "@@ -19,11 +19,7 @@ jobs:\n           job-id: jdk11\n \n       - name: Build\n-        uses: nick-invision/retry@v2.2.0\n-        with:\n-          command: ./gradlew check --stacktrace -x :smoke-tests:test\n-          timeout_minutes: 90\n-          max_attempts: 3\n+        run: ./gradlew check --stacktrace -x :smoke-tests:test", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkwMjg5Nw=="}, "originalCommit": {"oid": "473acce59118b1fc776578ee3c94136b88f15d4a"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0NTAwNDI1OnYy", "diffSide": "RIGHT", "path": "docs/contributing/writing-instrumentation.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QxMTowNTowMFrOIKhYJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QyMzo0OToyM1rOIK6-0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkwMzUyNA==", "bodyText": "Does word shaded here mean anything? I mean, is this agent used for tests somehow different from the \"usual\" agent that we release?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r547903524", "createdAt": "2020-12-23T11:05:00Z", "author": {"login": "iNikem"}, "path": "docs/contributing/writing-instrumentation.md", "diffHunk": "@@ -113,6 +113,34 @@ the base class you wrote earlier, but in this, create a client using none of the\n only the ones offered by the library. Implement the `AgentTestRunner` trait for common setup logic,\n and try running. All the tests should pass for agent instrumentation too.\n \n+Note that all the tests inside the `javaagent` module will be run using the shaded `-javaagent`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "473acce59118b1fc776578ee3c94136b88f15d4a"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMyMzAyNg==", "bodyText": "I updated it to \"fully shaded\", just want to be clear that shading takes place, since that is an extra layer of safety that this approach brings", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r548323026", "createdAt": "2020-12-23T23:49:23Z", "author": {"login": "trask"}, "path": "docs/contributing/writing-instrumentation.md", "diffHunk": "@@ -113,6 +113,34 @@ the base class you wrote earlier, but in this, create a client using none of the\n only the ones offered by the library. Implement the `AgentTestRunner` trait for common setup logic,\n and try running. All the tests should pass for agent instrumentation too.\n \n+Note that all the tests inside the `javaagent` module will be run using the shaded `-javaagent`", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkwMzUyNA=="}, "originalCommit": {"oid": "473acce59118b1fc776578ee3c94136b88f15d4a"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0NTAxNTYyOnYy", "diffSide": "RIGHT", "path": "gradle/instrumentation.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QxMTowODozOVrOIKhemA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QyMzo0NzozMFrOIK69Tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkwNTE3Ng==", "bodyText": "Does it make sense to change FieldBackedProvider logging to TRACE?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r547905176", "createdAt": "2020-12-23T11:08:39Z", "author": {"login": "iNikem"}, "path": "gradle/instrumentation.gradle", "diffHunk": "@@ -55,3 +51,68 @@ afterEvaluate {\n     project(':javaagent-tooling').configurations.instrumentationMuzzle + configurations.runtimeClasspath\n   ).configure()\n }\n+\n+configurations {\n+  testInstrumentation\n+}\n+\n+shadowJar {\n+  configurations = [project.configurations.runtimeClasspath, project.configurations.testInstrumentation]\n+  mergeServiceFiles()\n+\n+  archiveFileName = 'agent-testing.jar'\n+\n+  // rewrite library instrumentation dependencies\n+  relocate \"io.opentelemetry.instrumentation\", \"io.opentelemetry.javaagent.shaded.instrumentation\"\n+\n+  // Prevents conflict with other SLF4J instances. Important for premain.\n+  relocate 'org.slf4j', 'io.opentelemetry.javaagent.slf4j'\n+  // rewrite dependencies calling Logger.getLogger\n+  relocate 'java.util.logging.Logger', 'io.opentelemetry.javaagent.bootstrap.PatchLogger'\n+\n+  // prevents conflict with library instrumentation\n+  relocate 'io.opentelemetry.instrumentation.api', 'io.opentelemetry.javaagent.shaded.instrumentation.api'\n+\n+  // relocate OpenTelemetry API usage\n+  relocate \"io.opentelemetry.api\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.api\"\n+  relocate \"io.opentelemetry.spi\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.spi\"\n+  relocate \"io.opentelemetry.context\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.context\"\n+\n+  // relocate OpenTelemetry extensions\n+  relocate \"io.opentelemetry.extension.kotlin\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.extension.kotlin\"\n+  relocate \"io.opentelemetry.extension.trace.propagation\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.extension.trace.propagation\"\n+\n+  // this is for instrumentation on opentelemetry-api itself\n+  relocate \"application.io.opentelemetry\", \"io.opentelemetry\"\n+}\n+\n+tasks.withType(Test).configureEach {\n+  jvmArgs \"-Dotel.javaagent.debug=true\"\n+  // the debug level logging in this class occurs frequently (and under class file transform),\n+  // which can lead gradle to deadlock sporadically when it triggers a class to load while holding\n+  // a lock, and then (because gradle hijacks System.out), it gets called from inside of the class\n+  // file transform, and then tries to grab a different lock\n+  jvmArgs \"-Dio.opentelemetry.javaagent.slf4j.simpleLogger.log.io.opentelemetry.javaagent.tooling.context.FieldBackedProvider=info\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "473acce59118b1fc776578ee3c94136b88f15d4a"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMyMjYzOQ==", "bodyText": "that approach feels a little more hidden, which is both good and bad. since it has to be multiplied across three gradle files though, that seems a good reason to take the approach you suggest \ud83d\udc4d", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1643#discussion_r548322639", "createdAt": "2020-12-23T23:47:30Z", "author": {"login": "trask"}, "path": "gradle/instrumentation.gradle", "diffHunk": "@@ -55,3 +51,68 @@ afterEvaluate {\n     project(':javaagent-tooling').configurations.instrumentationMuzzle + configurations.runtimeClasspath\n   ).configure()\n }\n+\n+configurations {\n+  testInstrumentation\n+}\n+\n+shadowJar {\n+  configurations = [project.configurations.runtimeClasspath, project.configurations.testInstrumentation]\n+  mergeServiceFiles()\n+\n+  archiveFileName = 'agent-testing.jar'\n+\n+  // rewrite library instrumentation dependencies\n+  relocate \"io.opentelemetry.instrumentation\", \"io.opentelemetry.javaagent.shaded.instrumentation\"\n+\n+  // Prevents conflict with other SLF4J instances. Important for premain.\n+  relocate 'org.slf4j', 'io.opentelemetry.javaagent.slf4j'\n+  // rewrite dependencies calling Logger.getLogger\n+  relocate 'java.util.logging.Logger', 'io.opentelemetry.javaagent.bootstrap.PatchLogger'\n+\n+  // prevents conflict with library instrumentation\n+  relocate 'io.opentelemetry.instrumentation.api', 'io.opentelemetry.javaagent.shaded.instrumentation.api'\n+\n+  // relocate OpenTelemetry API usage\n+  relocate \"io.opentelemetry.api\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.api\"\n+  relocate \"io.opentelemetry.spi\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.spi\"\n+  relocate \"io.opentelemetry.context\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.context\"\n+\n+  // relocate OpenTelemetry extensions\n+  relocate \"io.opentelemetry.extension.kotlin\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.extension.kotlin\"\n+  relocate \"io.opentelemetry.extension.trace.propagation\", \"io.opentelemetry.javaagent.shaded.io.opentelemetry.extension.trace.propagation\"\n+\n+  // this is for instrumentation on opentelemetry-api itself\n+  relocate \"application.io.opentelemetry\", \"io.opentelemetry\"\n+}\n+\n+tasks.withType(Test).configureEach {\n+  jvmArgs \"-Dotel.javaagent.debug=true\"\n+  // the debug level logging in this class occurs frequently (and under class file transform),\n+  // which can lead gradle to deadlock sporadically when it triggers a class to load while holding\n+  // a lock, and then (because gradle hijacks System.out), it gets called from inside of the class\n+  // file transform, and then tries to grab a different lock\n+  jvmArgs \"-Dio.opentelemetry.javaagent.slf4j.simpleLogger.log.io.opentelemetry.javaagent.tooling.context.FieldBackedProvider=info\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkwNTE3Ng=="}, "originalCommit": {"oid": "473acce59118b1fc776578ee3c94136b88f15d4a"}, "originalPosition": 95}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4584, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}