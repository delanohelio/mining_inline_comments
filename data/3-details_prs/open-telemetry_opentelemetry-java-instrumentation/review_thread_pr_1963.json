{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQ1MDA0NTcz", "number": 1963, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QyMzo1ODoyOFrOFIy5aA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNFQwMDowMToxM1rOFIy6yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0NzY2ODI0OnYy", "diffSide": "RIGHT", "path": "instrumentation/jetty-8.0/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/jetty/JettyQueuedThreadPoolModule.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QyMzo1ODoyOFrOIK7FWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMzo0MzozNFrOIOrj8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMyNDY5OQ==", "bodyText": "I don't think this needs to be a separate InstrumentationModule, and can glob onto the existing jetty InstrumentationModule", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1963#discussion_r548324699", "createdAt": "2020-12-23T23:58:28Z", "author": {"login": "trask"}, "path": "instrumentation/jetty-8.0/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/jetty/JettyQueuedThreadPoolModule.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.jetty;\n+\n+import static java.util.Collections.singletonList;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.any;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.javaagent.instrumentation.api.ContextStore;\n+import io.opentelemetry.javaagent.instrumentation.api.InstrumentationContext;\n+import io.opentelemetry.javaagent.instrumentation.api.Java8BytecodeBridge;\n+import io.opentelemetry.javaagent.instrumentation.api.concurrent.ExecutorInstrumentationUtils;\n+import io.opentelemetry.javaagent.instrumentation.api.concurrent.RunnableWrapper;\n+import io.opentelemetry.javaagent.instrumentation.api.concurrent.State;\n+import io.opentelemetry.javaagent.tooling.InstrumentationModule;\n+import io.opentelemetry.javaagent.tooling.TypeInstrumentation;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(InstrumentationModule.class)\n+public class JettyQueuedThreadPoolModule extends InstrumentationModule {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13d9029464b97335c110c6a923c00408be913f41"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ2MzY2Nw==", "bodyText": "Why not keep them separate?  Is it a problem to do that?  If we do combine them, we'll want to rename the existing module then probably from JettyHandlerInstrumentationModule to just JettyInstrumentationModule or something because it will no longer be handler specific.\nI can make that change, just not clear on the advantage.  I'm also uncertain about bringing over the contextStore() override since it doesn't necessarily seem to apply to jetty handlers.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1963#discussion_r551463667", "createdAt": "2021-01-04T17:37:39Z", "author": {"login": "breedx-splk"}, "path": "instrumentation/jetty-8.0/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/jetty/JettyQueuedThreadPoolModule.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.jetty;\n+\n+import static java.util.Collections.singletonList;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.any;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.javaagent.instrumentation.api.ContextStore;\n+import io.opentelemetry.javaagent.instrumentation.api.InstrumentationContext;\n+import io.opentelemetry.javaagent.instrumentation.api.Java8BytecodeBridge;\n+import io.opentelemetry.javaagent.instrumentation.api.concurrent.ExecutorInstrumentationUtils;\n+import io.opentelemetry.javaagent.instrumentation.api.concurrent.RunnableWrapper;\n+import io.opentelemetry.javaagent.instrumentation.api.concurrent.State;\n+import io.opentelemetry.javaagent.tooling.InstrumentationModule;\n+import io.opentelemetry.javaagent.tooling.TypeInstrumentation;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(InstrumentationModule.class)\n+public class JettyQueuedThreadPoolModule extends InstrumentationModule {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMyNDY5OQ=="}, "originalCommit": {"oid": "13d9029464b97335c110c6a923c00408be913f41"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI2NDY4OQ==", "bodyText": "the advantage of having a single InstrumentationModule is that we know either all or none of the instrumentation will be applied (not muzzled), which reduces the number of states we have to think about when developing or troubleshooting\nthe contextStore() is ok, at the InstrumentationModule level it's just a combination of all context stores needed for instrumentation in the module", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1963#discussion_r552264689", "createdAt": "2021-01-05T23:43:34Z", "author": {"login": "trask"}, "path": "instrumentation/jetty-8.0/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/jetty/JettyQueuedThreadPoolModule.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.jetty;\n+\n+import static java.util.Collections.singletonList;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.any;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.javaagent.instrumentation.api.ContextStore;\n+import io.opentelemetry.javaagent.instrumentation.api.InstrumentationContext;\n+import io.opentelemetry.javaagent.instrumentation.api.Java8BytecodeBridge;\n+import io.opentelemetry.javaagent.instrumentation.api.concurrent.ExecutorInstrumentationUtils;\n+import io.opentelemetry.javaagent.instrumentation.api.concurrent.RunnableWrapper;\n+import io.opentelemetry.javaagent.instrumentation.api.concurrent.State;\n+import io.opentelemetry.javaagent.tooling.InstrumentationModule;\n+import io.opentelemetry.javaagent.tooling.TypeInstrumentation;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(InstrumentationModule.class)\n+public class JettyQueuedThreadPoolModule extends InstrumentationModule {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMyNDY5OQ=="}, "originalCommit": {"oid": "13d9029464b97335c110c6a923c00408be913f41"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0NzY2OTIyOnYy", "diffSide": "RIGHT", "path": "instrumentation/jetty-8.0/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/jetty/JettyQueuedThreadPoolModule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QyMzo1OTowOFrOIK7F5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QyMzo1OTowOFrOIK7F5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMyNDgzNw==", "bodyText": "should be able to leave this out\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Override\n          \n          \n            \n                public ElementMatcher<ClassLoader> classLoaderOptimization() {\n          \n          \n            \n                  return any();\n          \n          \n            \n                }", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1963#discussion_r548324837", "createdAt": "2020-12-23T23:59:08Z", "author": {"login": "trask"}, "path": "instrumentation/jetty-8.0/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/jetty/JettyQueuedThreadPoolModule.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.jetty;\n+\n+import static java.util.Collections.singletonList;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.any;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.javaagent.instrumentation.api.ContextStore;\n+import io.opentelemetry.javaagent.instrumentation.api.InstrumentationContext;\n+import io.opentelemetry.javaagent.instrumentation.api.Java8BytecodeBridge;\n+import io.opentelemetry.javaagent.instrumentation.api.concurrent.ExecutorInstrumentationUtils;\n+import io.opentelemetry.javaagent.instrumentation.api.concurrent.RunnableWrapper;\n+import io.opentelemetry.javaagent.instrumentation.api.concurrent.State;\n+import io.opentelemetry.javaagent.tooling.InstrumentationModule;\n+import io.opentelemetry.javaagent.tooling.TypeInstrumentation;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(InstrumentationModule.class)\n+public class JettyQueuedThreadPoolModule extends InstrumentationModule {\n+\n+  public JettyQueuedThreadPoolModule() {\n+    super(\"executor\", \"non-standard-executor\");\n+  }\n+\n+  @Override\n+  public List<TypeInstrumentation> typeInstrumentations() {\n+    return singletonList(new JettyQueuedThreadPoolInstrumentation());\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(Runnable.class.getName(), State.class.getName());\n+  }\n+\n+  public static class JettyQueuedThreadPoolInstrumentation implements TypeInstrumentation {\n+\n+    @Override\n+    public ElementMatcher<ClassLoader> classLoaderOptimization() {\n+      return any();\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13d9029464b97335c110c6a923c00408be913f41"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0NzY3MDA2OnYy", "diffSide": "RIGHT", "path": "instrumentation/jetty-8.0/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/jetty/JettyQueuedThreadPoolModule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QyMzo1OTo0M1rOIK7GWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QyMzo1OTo0M1rOIK7GWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMyNDk1Mg==", "bodyText": "I think this is clear enough from typeMatcher\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      // org.eclipse.jetty.util.thread.QueuedThreadPool", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1963#discussion_r548324952", "createdAt": "2020-12-23T23:59:43Z", "author": {"login": "trask"}, "path": "instrumentation/jetty-8.0/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/jetty/JettyQueuedThreadPoolModule.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.jetty;\n+\n+import static java.util.Collections.singletonList;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.any;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.javaagent.instrumentation.api.ContextStore;\n+import io.opentelemetry.javaagent.instrumentation.api.InstrumentationContext;\n+import io.opentelemetry.javaagent.instrumentation.api.Java8BytecodeBridge;\n+import io.opentelemetry.javaagent.instrumentation.api.concurrent.ExecutorInstrumentationUtils;\n+import io.opentelemetry.javaagent.instrumentation.api.concurrent.RunnableWrapper;\n+import io.opentelemetry.javaagent.instrumentation.api.concurrent.State;\n+import io.opentelemetry.javaagent.tooling.InstrumentationModule;\n+import io.opentelemetry.javaagent.tooling.TypeInstrumentation;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(InstrumentationModule.class)\n+public class JettyQueuedThreadPoolModule extends InstrumentationModule {\n+\n+  public JettyQueuedThreadPoolModule() {\n+    super(\"executor\", \"non-standard-executor\");\n+  }\n+\n+  @Override\n+  public List<TypeInstrumentation> typeInstrumentations() {\n+    return singletonList(new JettyQueuedThreadPoolInstrumentation());\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(Runnable.class.getName(), State.class.getName());\n+  }\n+\n+  public static class JettyQueuedThreadPoolInstrumentation implements TypeInstrumentation {\n+\n+    @Override\n+    public ElementMatcher<ClassLoader> classLoaderOptimization() {\n+      return any();\n+    }\n+\n+    @Override\n+    public ElementMatcher<TypeDescription> typeMatcher() {\n+      return named(\"org.eclipse.jetty.util.thread.QueuedThreadPool\");\n+    }\n+\n+    @Override\n+    public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+      Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+\n+      transformers.put(\n+          // org.eclipse.jetty.util.thread.QueuedThreadPool", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13d9029464b97335c110c6a923c00408be913f41"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0NzY3MTc5OnYy", "diffSide": "RIGHT", "path": "instrumentation/jetty-8.0/javaagent/src/test/groovy/QueuedThreadPoolTest.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNFQwMDowMToxM1rOIK7HWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNFQwMDowMToxM1rOIK7HWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMyNTIxMQ==", "bodyText": "nice", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1963#discussion_r548325211", "createdAt": "2020-12-24T00:01:13Z", "author": {"login": "trask"}, "path": "instrumentation/jetty-8.0/javaagent/src/test/groovy/QueuedThreadPoolTest.groovy", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import io.opentelemetry.instrumentation.test.AgentTestRunner\n+import io.opentelemetry.javaagent.instrumentation.jetty.JavaLambdaMaker\n+import io.opentelemetry.sdk.trace.data.SpanData\n+import org.eclipse.jetty.util.thread.QueuedThreadPool\n+\n+import static io.opentelemetry.instrumentation.test.utils.TraceUtils.runUnderTrace\n+\n+class QueuedThreadPoolTest extends AgentTestRunner {\n+\n+  def \"QueueThreadPool 'dispatch' propagates\"() {\n+    setup:\n+    def pool = new QueuedThreadPool()\n+    pool.start()\n+\n+    new Runnable() {\n+      @Override\n+      void run() {\n+        runUnderTrace(\"parent\") {\n+          // this child will have a span\n+          def child1 = new JavaAsyncChild()\n+          // this child won't\n+          def child2 = new JavaAsyncChild(false, false)\n+          pool.dispatch(child1)\n+          pool.dispatch(child2)\n+          child1.waitForCompletion()\n+          child2.waitForCompletion()\n+        }\n+      }\n+    }.run()\n+\n+    TEST_WRITER.waitForTraces(1)\n+    List<SpanData> trace = TEST_WRITER.traces[0]\n+\n+    expect:\n+    TEST_WRITER.traces.size() == 1\n+    trace.size() == 2\n+    trace.get(0).traceId == trace.get(1).traceId\n+    trace.get(0).name == \"parent\"\n+    trace.get(1).name == \"asyncChild\"\n+    trace.get(1).parentSpanId == trace.get(0).spanId\n+\n+    cleanup:\n+    pool.stop()\n+  }\n+\n+  def \"QueueThreadPool 'dispatch' propagates lambda\"() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13d9029464b97335c110c6a923c00408be913f41"}, "originalPosition": 51}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4408, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}