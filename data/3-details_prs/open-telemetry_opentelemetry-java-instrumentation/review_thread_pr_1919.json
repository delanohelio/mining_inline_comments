{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQxMTg0OTg0", "number": 1919, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNTozNjoxM1rOFGiKqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNTozNjoxM1rOFGiKqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMzk1NTYyOnYy", "diffSide": "RIGHT", "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/AgentInstaller.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNTozNjoxM1rOIHld9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMDoyNTowNlrOIIxsTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDgyNDgyMw==", "bodyText": "Removing this would remove the question @mateuszrzeszutek raised about RunnableWrapper.\nInjected classes can't be instrumented since they are injected themselves during ClassFileTransformer.transform(), so those are safe to skip, and sounds like are the culprit of the log spamming?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1919#discussion_r544824823", "createdAt": "2020-12-17T05:36:13Z", "author": {"login": "trask"}, "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/AgentInstaller.java", "diffHunk": "@@ -378,5 +380,37 @@ public void onComplete(\n     }\n   }\n \n+  private static class RedefinitionDiscoveryStrategy\n+      implements AgentBuilder.RedefinitionStrategy.DiscoveryStrategy {\n+    private static final AgentBuilder.RedefinitionStrategy.DiscoveryStrategy delegate =\n+        AgentBuilder.RedefinitionStrategy.DiscoveryStrategy.Reiterating.INSTANCE;\n+\n+    @Override\n+    public Iterable<Iterable<Class<?>>> resolve(Instrumentation instrumentation) {\n+      // filter out our agent classes and injected helper classes\n+      return Iterables.transform(\n+          delegate.resolve(instrumentation), i -> Iterables.filter(i, c -> !isIgnored(c)));\n+    }\n+\n+    private static boolean isIgnored(Class<?> c) {\n+      ClassLoader cl = c.getClassLoader();\n+      if (cl != null && cl.getClass() == AgentClassLoader.class) {\n+        return true;\n+      }\n+\n+      if (HelperInjector.isInjectedClass(c)) {\n+        return true;\n+      }\n+\n+      if (cl == null) {\n+        String name = c.getName();\n+        List<String> prefixes = BootstrapPackagePrefixesHolder.getBoostrapPackagePrefixes();\n+        return prefixes.stream().anyMatch(prefix -> name.startsWith(prefix));\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd1f698dc08d2a0bc205c6ace2633d82aae9b69f"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDkyNjg4Mg==", "bodyText": "Yes, injected classes are the main problem.\nI can remove this block but I suspect that it really doesn't exclude anything that should not be excluded. Here is the list of excluded classes from this block from startup with -javaagent\nio.opentelemetry.javaagent.shaded.instrumentation.api.config.Config$$Lambda$55/0x0000000800147440\nio.opentelemetry.javaagent.shaded.io.opentelemetry.api.common.ArrayBackedAttributesBuilder$$Lambda$29/0x00000008000ab440\nio.opentelemetry.javaagent.shaded.instrumentation.api.config.Config$$Lambda$27/0x00000008000ae440\nio.opentelemetry.javaagent.shaded.io.opentelemetry.api.trace.Span\nio.opentelemetry.javaagent.shaded.io.opentelemetry.context.ImplicitContextKeyed\nio.opentelemetry.javaagent.shaded.io.opentelemetry.context.Context\nio.opentelemetry.javaagent.instrumentation.api.concurrent.State\nio.opentelemetry.javaagent.instrumentation.api.Pair\nio.opentelemetry.javaagent.bootstrap.ExceptionLogger\nio.opentelemetry.javaagent.shaded.instrumentation.api.config.MethodsConfigurationParser\nio.opentelemetry.javaagent.shaded.instrumentation.api.config.CollectionParsers\nio.opentelemetry.javaagent.instrumentation.api.ContextStore$Factory\nio.opentelemetry.javaagent.instrumentation.api.ContextStore\nio.opentelemetry.javaagent.instrumentation.api.InstrumentationContext\nio.opentelemetry.javaagent.bootstrap.FieldBackedContextStoreAppliedMarker\nio.opentelemetry.javaagent.instrumentation.api.OpenTelemetrySdkAccess\nio.opentelemetry.javaagent.instrumentation.api.OpenTelemetrySdkAccess$ForceFlusher\nio.opentelemetry.javaagent.shaded.io.opentelemetry.api.internal.Obfuscated\nio.opentelemetry.javaagent.shaded.instrumentation.api.InstrumentationVersion\nio.opentelemetry.javaagent.shaded.io.opentelemetry.api.internal.StringUtils\nio.opentelemetry.javaagent.shaded.io.opentelemetry.api.common.AutoValue_AttributeKeyImpl\nio.opentelemetry.javaagent.shaded.io.opentelemetry.api.common.AttributeKeyImpl\nio.opentelemetry.javaagent.shaded.io.opentelemetry.api.common.AttributeType\nio.opentelemetry.javaagent.shaded.io.opentelemetry.api.common.AttributeKey\nio.opentelemetry.javaagent.shaded.io.opentelemetry.api.internal.Utils\nio.opentelemetry.javaagent.shaded.io.opentelemetry.api.common.AutoValue_ArrayBackedAttributes\nio.opentelemetry.javaagent.shaded.io.opentelemetry.api.common.ArrayBackedAttributesBuilder\nio.opentelemetry.javaagent.shaded.io.opentelemetry.api.common.AttributesBuilder\nio.opentelemetry.javaagent.shaded.io.opentelemetry.api.common.ArrayBackedAttributes\nio.opentelemetry.javaagent.shaded.io.opentelemetry.api.internal.ImmutableKeyValuePairs\nio.opentelemetry.javaagent.shaded.io.opentelemetry.api.common.Attributes\nio.opentelemetry.javaagent.shaded.io.opentelemetry.api.metrics.Meter\nio.opentelemetry.javaagent.shaded.io.opentelemetry.context.propagation.NoopTextMapPropagator\nio.opentelemetry.javaagent.shaded.io.opentelemetry.context.propagation.TextMapPropagator\nio.opentelemetry.javaagent.shaded.io.opentelemetry.context.propagation.DefaultContextPropagators\nio.opentelemetry.javaagent.shaded.io.opentelemetry.context.propagation.ContextPropagators\nio.opentelemetry.javaagent.shaded.io.opentelemetry.api.metrics.MeterProvider\nio.opentelemetry.javaagent.shaded.io.opentelemetry.api.trace.TracerProvider\nio.opentelemetry.javaagent.shaded.io.opentelemetry.api.DefaultOpenTelemetry$Builder\nio.opentelemetry.javaagent.shaded.io.opentelemetry.api.OpenTelemetryBuilder\nio.opentelemetry.javaagent.shaded.io.opentelemetry.spi.OpenTelemetryFactory\nio.opentelemetry.javaagent.shaded.io.opentelemetry.api.DefaultOpenTelemetry\nio.opentelemetry.javaagent.shaded.io.opentelemetry.api.OpenTelemetry\nio.opentelemetry.javaagent.shaded.instrumentation.api.config.AutoValue_Config\nio.opentelemetry.javaagent.shaded.instrumentation.api.config.Config\nio.opentelemetry.javaagent.shaded.instrumentation.api.config.NamingConvention$2\nio.opentelemetry.javaagent.shaded.instrumentation.api.config.NamingConvention$1\nio.opentelemetry.javaagent.shaded.instrumentation.api.config.NamingConvention\nio.opentelemetry.javaagent.shaded.instrumentation.api.config.ConfigBuilder\nio.opentelemetry.javaagent.bootstrap.PatchLogger\nio.opentelemetry.javaagent.bootstrap.WeakCache\nio.opentelemetry.javaagent.bootstrap.WeakCache$Provider\nio.opentelemetry.javaagent.instrumentation.api.WeakMap\nio.opentelemetry.javaagent.instrumentation.api.WeakMap$Implementation$Default\nio.opentelemetry.javaagent.instrumentation.api.WeakMap$Provider\nio.opentelemetry.javaagent.instrumentation.api.WeakMap$Implementation\nio.opentelemetry.javaagent.shaded.instrumentation.api.internal.BootstrapPackagePrefixesHolder\nio.opentelemetry.javaagent.instrumentation.api.SafeServiceLoader\nio.opentelemetry.javaagent.bootstrap.InternalJarUrlHandler$InternalJarUrlConnection\nio.opentelemetry.javaagent.bootstrap.InternalJarUrlHandler$ResolvedJarEntry\nio.opentelemetry.javaagent.bootstrap.InternalJarUrlHandler$FileNotInInternalJar\nio.opentelemetry.javaagent.bootstrap.InternalJarUrlHandler\nio.opentelemetry.javaagent.bootstrap.AgentClassLoader$BootstrapClassLoaderProxy\nio.opentelemetry.javaagent.bootstrap.AgentClassLoader\nio.opentelemetry.javaagent.slf4j.impl.OutputChoice$OutputChoiceType\nio.opentelemetry.javaagent.slf4j.impl.OutputChoice\nio.opentelemetry.javaagent.slf4j.impl.SimpleLoggerConfiguration$1\nio.opentelemetry.javaagent.slf4j.impl.SimpleLoggerConfiguration\nio.opentelemetry.javaagent.slf4j.impl.SimpleLogger\nio.opentelemetry.javaagent.slf4j.helpers.MarkerIgnoringBase\nio.opentelemetry.javaagent.slf4j.helpers.NamedLoggerBase\nio.opentelemetry.javaagent.slf4j.Logger\nio.opentelemetry.javaagent.slf4j.impl.SimpleLoggerFactory\nio.opentelemetry.javaagent.slf4j.impl.StaticLoggerBinder\nio.opentelemetry.javaagent.slf4j.spi.LoggerFactoryBinder\nio.opentelemetry.javaagent.slf4j.helpers.Util\nio.opentelemetry.javaagent.slf4j.helpers.NOPLoggerFactory\nio.opentelemetry.javaagent.slf4j.helpers.SubstituteLoggerFactory\nio.opentelemetry.javaagent.slf4j.ILoggerFactory\nio.opentelemetry.javaagent.slf4j.LoggerFactory\nio.opentelemetry.javaagent.bootstrap.AgentInitializer\nio.opentelemetry.javaagent.shaded.io.opentelemetry.context.propagation.TextMapPropagator$Setter\nio.opentelemetry.javaagent.shaded.instrumentation.api.tracer.HttpClientTracer\nio.opentelemetry.javaagent.shaded.instrumentation.api.tracer.BaseTracer\n\nAnd from starting a test from ide\nio.opentelemetry.javaagent.instrumentation.api.concurrent.State\nio.opentelemetry.javaagent.bootstrap.ExceptionLogger\nio.opentelemetry.javaagent.bootstrap.AgentClassLoader\nio.opentelemetry.javaagent.instrumentation.api.ContextStore$Factory\nio.opentelemetry.javaagent.instrumentation.api.ContextStore\nio.opentelemetry.javaagent.instrumentation.api.InstrumentationContext\nio.opentelemetry.javaagent.bootstrap.FieldBackedContextStoreAppliedMarker\nio.opentelemetry.javaagent.instrumentation.api.OpenTelemetrySdkAccess\nio.opentelemetry.javaagent.instrumentation.api.OpenTelemetrySdkAccess$ForceFlusher\nio.opentelemetry.javaagent.bootstrap.AgentClassLoader$BootstrapClassLoaderProxy\nio.opentelemetry.javaagent.bootstrap.WeakCache\nio.opentelemetry.javaagent.bootstrap.WeakCache$Provider\nio.opentelemetry.javaagent.instrumentation.api.WeakMap\nio.opentelemetry.javaagent.instrumentation.api.WeakMap$Implementation$Default\nio.opentelemetry.javaagent.instrumentation.api.WeakMap$Provider\nio.opentelemetry.javaagent.instrumentation.api.WeakMap$Implementation\nio.opentelemetry.javaagent.instrumentation.api.SafeServiceLoader\n\nIf you believe that this block should be removed then let me know.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1919#discussion_r544926882", "createdAt": "2020-12-17T09:12:01Z", "author": {"login": "laurit"}, "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/AgentInstaller.java", "diffHunk": "@@ -378,5 +380,37 @@ public void onComplete(\n     }\n   }\n \n+  private static class RedefinitionDiscoveryStrategy\n+      implements AgentBuilder.RedefinitionStrategy.DiscoveryStrategy {\n+    private static final AgentBuilder.RedefinitionStrategy.DiscoveryStrategy delegate =\n+        AgentBuilder.RedefinitionStrategy.DiscoveryStrategy.Reiterating.INSTANCE;\n+\n+    @Override\n+    public Iterable<Iterable<Class<?>>> resolve(Instrumentation instrumentation) {\n+      // filter out our agent classes and injected helper classes\n+      return Iterables.transform(\n+          delegate.resolve(instrumentation), i -> Iterables.filter(i, c -> !isIgnored(c)));\n+    }\n+\n+    private static boolean isIgnored(Class<?> c) {\n+      ClassLoader cl = c.getClassLoader();\n+      if (cl != null && cl.getClass() == AgentClassLoader.class) {\n+        return true;\n+      }\n+\n+      if (HelperInjector.isInjectedClass(c)) {\n+        return true;\n+      }\n+\n+      if (cl == null) {\n+        String name = c.getName();\n+        List<String> prefixes = BootstrapPackagePrefixesHolder.getBoostrapPackagePrefixes();\n+        return prefixes.stream().anyMatch(prefix -> name.startsWith(prefix));\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDgyNDgyMw=="}, "originalCommit": {"oid": "dd1f698dc08d2a0bc205c6ace2633d82aae9b69f"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQwMTExMQ==", "bodyText": "@trask is any action needed here?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1919#discussion_r545401111", "createdAt": "2020-12-17T21:01:33Z", "author": {"login": "iNikem"}, "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/AgentInstaller.java", "diffHunk": "@@ -378,5 +380,37 @@ public void onComplete(\n     }\n   }\n \n+  private static class RedefinitionDiscoveryStrategy\n+      implements AgentBuilder.RedefinitionStrategy.DiscoveryStrategy {\n+    private static final AgentBuilder.RedefinitionStrategy.DiscoveryStrategy delegate =\n+        AgentBuilder.RedefinitionStrategy.DiscoveryStrategy.Reiterating.INSTANCE;\n+\n+    @Override\n+    public Iterable<Iterable<Class<?>>> resolve(Instrumentation instrumentation) {\n+      // filter out our agent classes and injected helper classes\n+      return Iterables.transform(\n+          delegate.resolve(instrumentation), i -> Iterables.filter(i, c -> !isIgnored(c)));\n+    }\n+\n+    private static boolean isIgnored(Class<?> c) {\n+      ClassLoader cl = c.getClassLoader();\n+      if (cl != null && cl.getClass() == AgentClassLoader.class) {\n+        return true;\n+      }\n+\n+      if (HelperInjector.isInjectedClass(c)) {\n+        return true;\n+      }\n+\n+      if (cl == null) {\n+        String name = c.getName();\n+        List<String> prefixes = BootstrapPackagePrefixesHolder.getBoostrapPackagePrefixes();\n+        return prefixes.stream().anyMatch(prefix -> name.startsWith(prefix));\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDgyNDgyMw=="}, "originalCommit": {"oid": "dd1f698dc08d2a0bc205c6ace2633d82aae9b69f"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ3NjkwNw==", "bodyText": "I think ideally we wouldn't skip any classes during retransform that we don't also skip during normal transform (though I agree it doesn't appear to have any impact currently, it feels like it might lead to a hard-to-find bug down the road).\nI'd suggest one of these:\n\nadd the same filter to GlobalIgnoresMatcher, explicitly excluding RunnableWrapper (and see if this is the only weird example like that)\nremove this block for now and we can revisit another time (I think it's potentially a nice startup time optimization not to send these classes to retransform)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1919#discussion_r545476907", "createdAt": "2020-12-17T23:39:55Z", "author": {"login": "trask"}, "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/AgentInstaller.java", "diffHunk": "@@ -378,5 +380,37 @@ public void onComplete(\n     }\n   }\n \n+  private static class RedefinitionDiscoveryStrategy\n+      implements AgentBuilder.RedefinitionStrategy.DiscoveryStrategy {\n+    private static final AgentBuilder.RedefinitionStrategy.DiscoveryStrategy delegate =\n+        AgentBuilder.RedefinitionStrategy.DiscoveryStrategy.Reiterating.INSTANCE;\n+\n+    @Override\n+    public Iterable<Iterable<Class<?>>> resolve(Instrumentation instrumentation) {\n+      // filter out our agent classes and injected helper classes\n+      return Iterables.transform(\n+          delegate.resolve(instrumentation), i -> Iterables.filter(i, c -> !isIgnored(c)));\n+    }\n+\n+    private static boolean isIgnored(Class<?> c) {\n+      ClassLoader cl = c.getClassLoader();\n+      if (cl != null && cl.getClass() == AgentClassLoader.class) {\n+        return true;\n+      }\n+\n+      if (HelperInjector.isInjectedClass(c)) {\n+        return true;\n+      }\n+\n+      if (cl == null) {\n+        String name = c.getName();\n+        List<String> prefixes = BootstrapPackagePrefixesHolder.getBoostrapPackagePrefixes();\n+        return prefixes.stream().anyMatch(prefix -> name.startsWith(prefix));\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDgyNDgyMw=="}, "originalCommit": {"oid": "dd1f698dc08d2a0bc205c6ace2633d82aae9b69f"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg2MTU0Mw==", "bodyText": "I removed it.\nIn GlobalIgnoresMatcher there is\n    if (name.startsWith(\"io.opentelemetry.auto.\")) {\n      // FIXME: We should remove this once\n      // https://github.com/raphw/byte-buddy/issues/558 is fixed\n      if (name.equals(\"io.opentelemetry.javaagent.instrumentation.api.concurrent.RunnableWrapper\")\n          || name.equals(\n              \"io.opentelemetry.javaagent.instrumentation.api.concurrent.CallableWrapper\")) {\n        return false;\n      }\n      return true;\n    }\n\nI assume \"io.opentelemetry.auto.\" is a remnant from a package rename. Changing auto -> javaagent isn't enough because io.opentelemetry.javaagent.instrumentation.awslambda.v1_0.AwsLambdaSqsHandlerTest$TestRequestHandler will be skipped and this causes test failures.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1919#discussion_r545861543", "createdAt": "2020-12-18T14:23:16Z", "author": {"login": "laurit"}, "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/AgentInstaller.java", "diffHunk": "@@ -378,5 +380,37 @@ public void onComplete(\n     }\n   }\n \n+  private static class RedefinitionDiscoveryStrategy\n+      implements AgentBuilder.RedefinitionStrategy.DiscoveryStrategy {\n+    private static final AgentBuilder.RedefinitionStrategy.DiscoveryStrategy delegate =\n+        AgentBuilder.RedefinitionStrategy.DiscoveryStrategy.Reiterating.INSTANCE;\n+\n+    @Override\n+    public Iterable<Iterable<Class<?>>> resolve(Instrumentation instrumentation) {\n+      // filter out our agent classes and injected helper classes\n+      return Iterables.transform(\n+          delegate.resolve(instrumentation), i -> Iterables.filter(i, c -> !isIgnored(c)));\n+    }\n+\n+    private static boolean isIgnored(Class<?> c) {\n+      ClassLoader cl = c.getClassLoader();\n+      if (cl != null && cl.getClass() == AgentClassLoader.class) {\n+        return true;\n+      }\n+\n+      if (HelperInjector.isInjectedClass(c)) {\n+        return true;\n+      }\n+\n+      if (cl == null) {\n+        String name = c.getName();\n+        List<String> prefixes = BootstrapPackagePrefixesHolder.getBoostrapPackagePrefixes();\n+        return prefixes.stream().anyMatch(prefix -> name.startsWith(prefix));\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDgyNDgyMw=="}, "originalCommit": {"oid": "dd1f698dc08d2a0bc205c6ace2633d82aae9b69f"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA3MzY3OQ==", "bodyText": "oh, nice find! I'll create an issue to track this", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1919#discussion_r546073679", "createdAt": "2020-12-18T20:25:06Z", "author": {"login": "trask"}, "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/AgentInstaller.java", "diffHunk": "@@ -378,5 +380,37 @@ public void onComplete(\n     }\n   }\n \n+  private static class RedefinitionDiscoveryStrategy\n+      implements AgentBuilder.RedefinitionStrategy.DiscoveryStrategy {\n+    private static final AgentBuilder.RedefinitionStrategy.DiscoveryStrategy delegate =\n+        AgentBuilder.RedefinitionStrategy.DiscoveryStrategy.Reiterating.INSTANCE;\n+\n+    @Override\n+    public Iterable<Iterable<Class<?>>> resolve(Instrumentation instrumentation) {\n+      // filter out our agent classes and injected helper classes\n+      return Iterables.transform(\n+          delegate.resolve(instrumentation), i -> Iterables.filter(i, c -> !isIgnored(c)));\n+    }\n+\n+    private static boolean isIgnored(Class<?> c) {\n+      ClassLoader cl = c.getClassLoader();\n+      if (cl != null && cl.getClass() == AgentClassLoader.class) {\n+        return true;\n+      }\n+\n+      if (HelperInjector.isInjectedClass(c)) {\n+        return true;\n+      }\n+\n+      if (cl == null) {\n+        String name = c.getName();\n+        List<String> prefixes = BootstrapPackagePrefixesHolder.getBoostrapPackagePrefixes();\n+        return prefixes.stream().anyMatch(prefix -> name.startsWith(prefix));\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDgyNDgyMw=="}, "originalCommit": {"oid": "dd1f698dc08d2a0bc205c6ace2633d82aae9b69f"}, "originalPosition": 60}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4384, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}