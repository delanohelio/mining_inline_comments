{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc1Mjc3MDA2", "number": 1121, "reviewThreads": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwMzo0OToxOFrOEfz35Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQyMToxMjoxMlrOEh3E1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNzkxMjA1OnYy", "diffSide": "RIGHT", "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpClientInstrumentation.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwMzo0OToxOFrOHMU2Dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMzoxMTozOVrOHMl49Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY4NjQ3OQ==", "bodyText": "@malafeev Have you tried running with debug logs? I'm guessing this instrumentation is \"getting muzzled\". Lambdas create additional anonymous classes, so I believe you need to add something like `packageName + HttpClientInstrumentation$1\" to the helper classes list.\nBecause this is a bit magical I tend to avoid lambdas in instrumentation, and instead define a class that implements the interface (effectively same bytecode). Though I've found that even that doesn't always work...\nhttps://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1153/files#r481762196", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r482686479", "createdAt": "2020-09-03T03:49:18Z", "author": {"login": "anuraaga"}, "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpClientInstrumentation.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import static io.opentelemetry.instrumentation.auto.httpclient.JdkHttpClientTracer.TRACER;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.instrumentation.auto.api.CallDepthThreadLocalMap.Depth;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import io.opentelemetry.trace.Span;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandler;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.implementation.bytecode.assign.Assigner.Typing;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+@AutoService(Instrumenter.class)\n+public class HttpClientInstrumentation extends Instrumenter.Default {\n+\n+  public HttpClientInstrumentation() {\n+    super(\"httpclient\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"java.net.http.HttpRequest\", Context.class.getName());\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return nameStartsWith(\"java.net.\")\n+        .or(ElementMatchers.<TypeDescription>nameStartsWith(\"jdk.internal.\"))\n+        .and(not(named(\"jdk.internal.net.http.HttpClientFacade\")))\n+        .and(extendsClass(named(\"java.net.http.HttpClient\")));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".HttpHeadersInjectAdapter\",\n+      packageName + \".JdkHttpClientTracer\",\n+      packageName + \".TracingBodyHandler\"\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+\n+    transformers.put(\n+        isMethod()\n+            .and(named(\"send\"))\n+            .and(isPublic())\n+            .and(takesArguments(2))\n+            .and(takesArgument(0, named(\"java.net.http.HttpRequest\"))),\n+        HttpClientInstrumentation.class.getName() + \"$SendAdvice\");\n+\n+    transformers.put(\n+        isMethod()\n+            .and(named(\"sendAsync\"))\n+            .and(isPublic())\n+            .and(takesArgument(0, named(\"java.net.http.HttpRequest\")))\n+            .and(takesArgument(1, named(\"java.net.http.HttpResponse$BodyHandler\"))),\n+        HttpClientInstrumentation.class.getName() + \"$SendAsyncAdvice\");\n+\n+    return transformers;\n+  }\n+\n+  public static class SendAdvice {\n+\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void methodEnter(\n+        @Advice.Argument(value = 0) HttpRequest httpRequest,\n+        @Advice.Local(\"otelSpan\") Span span,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") Depth callDepth) {\n+\n+      callDepth = TRACER.getCallDepth();\n+      if (callDepth.getAndIncrement() == 0) {\n+        span = TRACER.startSpan(httpRequest);\n+        if (span.getContext().isValid()) {\n+          scope = TRACER.startScope(span, httpRequest);\n+        }\n+      }\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void methodExit(\n+        @Advice.Return HttpResponse result,\n+        @Advice.Thrown Throwable throwable,\n+        @Advice.Local(\"otelSpan\") Span span,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") Depth callDepth) {\n+\n+      if (callDepth.decrementAndGet() == 0 && scope != null) {\n+        scope.close();\n+        if (throwable == null) {\n+          TRACER.end(span, result);\n+        } else {\n+          TRACER.endExceptionally(span, result, throwable);\n+        }\n+      }\n+    }\n+  }\n+\n+  public static class SendAsyncAdvice {\n+\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void methodEnter(\n+        @Advice.Argument(value = 0) HttpRequest httpRequest,\n+        @Advice.Argument(value = 1, readOnly = false) BodyHandler<?> bodyHandler,\n+        @Advice.Local(\"otelSpan\") Span span,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") Depth callDepth) {\n+\n+      callDepth = TRACER.getCallDepth();\n+      if (callDepth.getAndIncrement() == 0) {\n+        span = TRACER.startSpan(httpRequest);\n+        bodyHandler = new TracingBodyHandler<>(bodyHandler, span);\n+        if (span.getContext().isValid()) {\n+          scope = TRACER.startScope(span, httpRequest);\n+        }\n+      }\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void methodExit(\n+        @Advice.Return(readOnly = false, typing = Typing.DYNAMIC) CompletableFuture<?> future,\n+        @Advice.Thrown Throwable throwable,\n+        @Advice.Local(\"otelSpan\") Span span,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") Depth callDepth) {\n+\n+      if (callDepth.decrementAndGet() == 0 && scope != null) {\n+        scope.close();\n+        if (throwable != null) {\n+          TRACER.endExceptionally(span, null, throwable);\n+        } else {\n+          // FIXME: next lines breaks interception\n+          future =\n+              future.whenComplete(\n+                  (o, t) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36ae437db8598ba66e79390567e937704201768d"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjcwNDM2OA==", "bodyText": "thanks @anuraaga, let me try", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r482704368", "createdAt": "2020-09-03T04:58:05Z", "author": {"login": "malafeev"}, "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpClientInstrumentation.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import static io.opentelemetry.instrumentation.auto.httpclient.JdkHttpClientTracer.TRACER;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.instrumentation.auto.api.CallDepthThreadLocalMap.Depth;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import io.opentelemetry.trace.Span;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandler;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.implementation.bytecode.assign.Assigner.Typing;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+@AutoService(Instrumenter.class)\n+public class HttpClientInstrumentation extends Instrumenter.Default {\n+\n+  public HttpClientInstrumentation() {\n+    super(\"httpclient\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"java.net.http.HttpRequest\", Context.class.getName());\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return nameStartsWith(\"java.net.\")\n+        .or(ElementMatchers.<TypeDescription>nameStartsWith(\"jdk.internal.\"))\n+        .and(not(named(\"jdk.internal.net.http.HttpClientFacade\")))\n+        .and(extendsClass(named(\"java.net.http.HttpClient\")));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".HttpHeadersInjectAdapter\",\n+      packageName + \".JdkHttpClientTracer\",\n+      packageName + \".TracingBodyHandler\"\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+\n+    transformers.put(\n+        isMethod()\n+            .and(named(\"send\"))\n+            .and(isPublic())\n+            .and(takesArguments(2))\n+            .and(takesArgument(0, named(\"java.net.http.HttpRequest\"))),\n+        HttpClientInstrumentation.class.getName() + \"$SendAdvice\");\n+\n+    transformers.put(\n+        isMethod()\n+            .and(named(\"sendAsync\"))\n+            .and(isPublic())\n+            .and(takesArgument(0, named(\"java.net.http.HttpRequest\")))\n+            .and(takesArgument(1, named(\"java.net.http.HttpResponse$BodyHandler\"))),\n+        HttpClientInstrumentation.class.getName() + \"$SendAsyncAdvice\");\n+\n+    return transformers;\n+  }\n+\n+  public static class SendAdvice {\n+\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void methodEnter(\n+        @Advice.Argument(value = 0) HttpRequest httpRequest,\n+        @Advice.Local(\"otelSpan\") Span span,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") Depth callDepth) {\n+\n+      callDepth = TRACER.getCallDepth();\n+      if (callDepth.getAndIncrement() == 0) {\n+        span = TRACER.startSpan(httpRequest);\n+        if (span.getContext().isValid()) {\n+          scope = TRACER.startScope(span, httpRequest);\n+        }\n+      }\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void methodExit(\n+        @Advice.Return HttpResponse result,\n+        @Advice.Thrown Throwable throwable,\n+        @Advice.Local(\"otelSpan\") Span span,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") Depth callDepth) {\n+\n+      if (callDepth.decrementAndGet() == 0 && scope != null) {\n+        scope.close();\n+        if (throwable == null) {\n+          TRACER.end(span, result);\n+        } else {\n+          TRACER.endExceptionally(span, result, throwable);\n+        }\n+      }\n+    }\n+  }\n+\n+  public static class SendAsyncAdvice {\n+\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void methodEnter(\n+        @Advice.Argument(value = 0) HttpRequest httpRequest,\n+        @Advice.Argument(value = 1, readOnly = false) BodyHandler<?> bodyHandler,\n+        @Advice.Local(\"otelSpan\") Span span,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") Depth callDepth) {\n+\n+      callDepth = TRACER.getCallDepth();\n+      if (callDepth.getAndIncrement() == 0) {\n+        span = TRACER.startSpan(httpRequest);\n+        bodyHandler = new TracingBodyHandler<>(bodyHandler, span);\n+        if (span.getContext().isValid()) {\n+          scope = TRACER.startScope(span, httpRequest);\n+        }\n+      }\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void methodExit(\n+        @Advice.Return(readOnly = false, typing = Typing.DYNAMIC) CompletableFuture<?> future,\n+        @Advice.Thrown Throwable throwable,\n+        @Advice.Local(\"otelSpan\") Span span,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") Depth callDepth) {\n+\n+      if (callDepth.decrementAndGet() == 0 && scope != null) {\n+        scope.close();\n+        if (throwable != null) {\n+          TRACER.endExceptionally(span, null, throwable);\n+        } else {\n+          // FIXME: next lines breaks interception\n+          future =\n+              future.whenComplete(\n+                  (o, t) -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY4NjQ3OQ=="}, "originalCommit": {"oid": "36ae437db8598ba66e79390567e937704201768d"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk2NTc0OQ==", "bodyText": "it works !!!", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r482965749", "createdAt": "2020-09-03T13:11:39Z", "author": {"login": "malafeev"}, "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpClientInstrumentation.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import static io.opentelemetry.instrumentation.auto.httpclient.JdkHttpClientTracer.TRACER;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.instrumentation.auto.api.CallDepthThreadLocalMap.Depth;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import io.opentelemetry.trace.Span;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandler;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.implementation.bytecode.assign.Assigner.Typing;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+@AutoService(Instrumenter.class)\n+public class HttpClientInstrumentation extends Instrumenter.Default {\n+\n+  public HttpClientInstrumentation() {\n+    super(\"httpclient\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"java.net.http.HttpRequest\", Context.class.getName());\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return nameStartsWith(\"java.net.\")\n+        .or(ElementMatchers.<TypeDescription>nameStartsWith(\"jdk.internal.\"))\n+        .and(not(named(\"jdk.internal.net.http.HttpClientFacade\")))\n+        .and(extendsClass(named(\"java.net.http.HttpClient\")));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".HttpHeadersInjectAdapter\",\n+      packageName + \".JdkHttpClientTracer\",\n+      packageName + \".TracingBodyHandler\"\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+\n+    transformers.put(\n+        isMethod()\n+            .and(named(\"send\"))\n+            .and(isPublic())\n+            .and(takesArguments(2))\n+            .and(takesArgument(0, named(\"java.net.http.HttpRequest\"))),\n+        HttpClientInstrumentation.class.getName() + \"$SendAdvice\");\n+\n+    transformers.put(\n+        isMethod()\n+            .and(named(\"sendAsync\"))\n+            .and(isPublic())\n+            .and(takesArgument(0, named(\"java.net.http.HttpRequest\")))\n+            .and(takesArgument(1, named(\"java.net.http.HttpResponse$BodyHandler\"))),\n+        HttpClientInstrumentation.class.getName() + \"$SendAsyncAdvice\");\n+\n+    return transformers;\n+  }\n+\n+  public static class SendAdvice {\n+\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void methodEnter(\n+        @Advice.Argument(value = 0) HttpRequest httpRequest,\n+        @Advice.Local(\"otelSpan\") Span span,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") Depth callDepth) {\n+\n+      callDepth = TRACER.getCallDepth();\n+      if (callDepth.getAndIncrement() == 0) {\n+        span = TRACER.startSpan(httpRequest);\n+        if (span.getContext().isValid()) {\n+          scope = TRACER.startScope(span, httpRequest);\n+        }\n+      }\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void methodExit(\n+        @Advice.Return HttpResponse result,\n+        @Advice.Thrown Throwable throwable,\n+        @Advice.Local(\"otelSpan\") Span span,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") Depth callDepth) {\n+\n+      if (callDepth.decrementAndGet() == 0 && scope != null) {\n+        scope.close();\n+        if (throwable == null) {\n+          TRACER.end(span, result);\n+        } else {\n+          TRACER.endExceptionally(span, result, throwable);\n+        }\n+      }\n+    }\n+  }\n+\n+  public static class SendAsyncAdvice {\n+\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void methodEnter(\n+        @Advice.Argument(value = 0) HttpRequest httpRequest,\n+        @Advice.Argument(value = 1, readOnly = false) BodyHandler<?> bodyHandler,\n+        @Advice.Local(\"otelSpan\") Span span,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") Depth callDepth) {\n+\n+      callDepth = TRACER.getCallDepth();\n+      if (callDepth.getAndIncrement() == 0) {\n+        span = TRACER.startSpan(httpRequest);\n+        bodyHandler = new TracingBodyHandler<>(bodyHandler, span);\n+        if (span.getContext().isValid()) {\n+          scope = TRACER.startScope(span, httpRequest);\n+        }\n+      }\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void methodExit(\n+        @Advice.Return(readOnly = false, typing = Typing.DYNAMIC) CompletableFuture<?> future,\n+        @Advice.Thrown Throwable throwable,\n+        @Advice.Local(\"otelSpan\") Span span,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") Depth callDepth) {\n+\n+      if (callDepth.decrementAndGet() == 0 && scope != null) {\n+        scope.close();\n+        if (throwable != null) {\n+          TRACER.endExceptionally(span, null, throwable);\n+        } else {\n+          // FIXME: next lines breaks interception\n+          future =\n+              future.whenComplete(\n+                  (o, t) -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY4NjQ3OQ=="}, "originalCommit": {"oid": "36ae437db8598ba66e79390567e937704201768d"}, "originalPosition": 174}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNTk3NTc0OnYy", "diffSide": "RIGHT", "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpClientInstrumentation.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNjo1ODoyM1rOHO5Ubw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxMzowMDozNlrOHPGKQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MTIzMQ==", "bodyText": "Can you add classloader matcher as well? It usually gives a significant performance boost.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485381231", "createdAt": "2020-09-09T06:58:23Z", "author": {"login": "iNikem"}, "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpClientInstrumentation.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import static io.opentelemetry.instrumentation.auto.httpclient.JdkHttpClientTracer.TRACER;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.instrumentation.auto.api.CallDepthThreadLocalMap.Depth;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import io.opentelemetry.trace.Span;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.implementation.bytecode.assign.Assigner.Typing;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+@AutoService(Instrumenter.class)\n+public class HttpClientInstrumentation extends Instrumenter.Default {\n+\n+  public HttpClientInstrumentation() {\n+    super(\"httpclient\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"java.net.http.HttpRequest\", Context.class.getName());\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c34ca7dd15fe37592edb1f4d0813fea7cc38697b"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MTYxOQ==", "bodyText": "added", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485591619", "createdAt": "2020-09-09T13:00:36Z", "author": {"login": "malafeev"}, "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpClientInstrumentation.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import static io.opentelemetry.instrumentation.auto.httpclient.JdkHttpClientTracer.TRACER;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.instrumentation.auto.api.CallDepthThreadLocalMap.Depth;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import io.opentelemetry.trace.Span;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.implementation.bytecode.assign.Assigner.Typing;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+@AutoService(Instrumenter.class)\n+public class HttpClientInstrumentation extends Instrumenter.Default {\n+\n+  public HttpClientInstrumentation() {\n+    super(\"httpclient\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"java.net.http.HttpRequest\", Context.class.getName());\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MTIzMQ=="}, "originalCommit": {"oid": "c34ca7dd15fe37592edb1f4d0813fea7cc38697b"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNTk3NjY1OnYy", "diffSide": "RIGHT", "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpClientInstrumentation.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNjo1ODo0M1rOHO5VAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxMzowMDo0M1rOHPGKjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MTM3OA==", "bodyText": "Why two nameStartsWith are used differently?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485381378", "createdAt": "2020-09-09T06:58:43Z", "author": {"login": "iNikem"}, "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpClientInstrumentation.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import static io.opentelemetry.instrumentation.auto.httpclient.JdkHttpClientTracer.TRACER;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.instrumentation.auto.api.CallDepthThreadLocalMap.Depth;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import io.opentelemetry.trace.Span;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.implementation.bytecode.assign.Assigner.Typing;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+@AutoService(Instrumenter.class)\n+public class HttpClientInstrumentation extends Instrumenter.Default {\n+\n+  public HttpClientInstrumentation() {\n+    super(\"httpclient\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"java.net.http.HttpRequest\", Context.class.getName());\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return nameStartsWith(\"java.net.\")\n+        .or(ElementMatchers.<TypeDescription>nameStartsWith(\"jdk.internal.\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c34ca7dd15fe37592edb1f4d0813fea7cc38697b"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MTY5NQ==", "bodyText": "fixed", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485591695", "createdAt": "2020-09-09T13:00:43Z", "author": {"login": "malafeev"}, "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpClientInstrumentation.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import static io.opentelemetry.instrumentation.auto.httpclient.JdkHttpClientTracer.TRACER;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.instrumentation.auto.api.CallDepthThreadLocalMap.Depth;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import io.opentelemetry.trace.Span;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.implementation.bytecode.assign.Assigner.Typing;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+@AutoService(Instrumenter.class)\n+public class HttpClientInstrumentation extends Instrumenter.Default {\n+\n+  public HttpClientInstrumentation() {\n+    super(\"httpclient\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"java.net.http.HttpRequest\", Context.class.getName());\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return nameStartsWith(\"java.net.\")\n+        .or(ElementMatchers.<TypeDescription>nameStartsWith(\"jdk.internal.\"))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MTM3OA=="}, "originalCommit": {"oid": "c34ca7dd15fe37592edb1f4d0813fea7cc38697b"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNTk4MTE5OnYy", "diffSide": "RIGHT", "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpHeadersInjectAdapter.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNzowMDoxMVrOHO5X1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxMzowMTowMlrOHPGLTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MjEwMg==", "bodyText": "So we don't support context propagation via this http client?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485382102", "createdAt": "2020-09-09T07:00:11Z", "author": {"login": "iNikem"}, "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpHeadersInjectAdapter.java", "diffHunk": "@@ -0,0 +1,29 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import io.opentelemetry.context.propagation.TextMapPropagator;\n+import java.net.http.HttpRequest;\n+\n+public class HttpHeadersInjectAdapter implements TextMapPropagator.Setter<HttpRequest> {\n+  public static final HttpHeadersInjectAdapter SETTER = new HttpHeadersInjectAdapter();\n+\n+  @Override\n+  public void set(HttpRequest carrier, String key, String value) {\n+    // Don't do anything because headers are immutable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c34ca7dd15fe37592edb1f4d0813fea7cc38697b"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU4NDY1Mg==", "bodyText": "context propagation is implemented via HttpHeadersInstrumentation.java otherwise tests would fail.\nthis class is a stub because I have to provide implementation to HttpClientTracer#getSetter()", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485584652", "createdAt": "2020-09-09T12:50:08Z", "author": {"login": "malafeev"}, "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpHeadersInjectAdapter.java", "diffHunk": "@@ -0,0 +1,29 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import io.opentelemetry.context.propagation.TextMapPropagator;\n+import java.net.http.HttpRequest;\n+\n+public class HttpHeadersInjectAdapter implements TextMapPropagator.Setter<HttpRequest> {\n+  public static final HttpHeadersInjectAdapter SETTER = new HttpHeadersInjectAdapter();\n+\n+  @Override\n+  public void set(HttpRequest carrier, String key, String value) {\n+    // Don't do anything because headers are immutable", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MjEwMg=="}, "originalCommit": {"oid": "c34ca7dd15fe37592edb1f4d0813fea7cc38697b"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MTg4NQ==", "bodyText": "added javadoc", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485591885", "createdAt": "2020-09-09T13:01:02Z", "author": {"login": "malafeev"}, "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpHeadersInjectAdapter.java", "diffHunk": "@@ -0,0 +1,29 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import io.opentelemetry.context.propagation.TextMapPropagator;\n+import java.net.http.HttpRequest;\n+\n+public class HttpHeadersInjectAdapter implements TextMapPropagator.Setter<HttpRequest> {\n+  public static final HttpHeadersInjectAdapter SETTER = new HttpHeadersInjectAdapter();\n+\n+  @Override\n+  public void set(HttpRequest carrier, String key, String value) {\n+    // Don't do anything because headers are immutable", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MjEwMg=="}, "originalCommit": {"oid": "c34ca7dd15fe37592edb1f4d0813fea7cc38697b"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNTk4MjE1OnYy", "diffSide": "RIGHT", "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpHeadersInstrumentation.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNzowMDozMlrOHO5YeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxMzowMToxMVrOHPGLtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MjI2NA==", "bodyText": "Remove commented code?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485382264", "createdAt": "2020-09-09T07:00:32Z", "author": {"login": "iNikem"}, "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpHeadersInstrumentation.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import static io.opentelemetry.instrumentation.auto.httpclient.JdkHttpClientTracer.TRACER;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.instrumentation.auto.api.concurrent.State;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpHeaders;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+@AutoService(Instrumenter.class)\n+public class HttpHeadersInstrumentation extends Instrumenter.Default {\n+\n+  public HttpHeadersInstrumentation() {\n+    super(\"httpclient\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(HttpClient.class.getName(), State.class.getName());\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return nameStartsWith(\"java.net.\")\n+        .or(ElementMatchers.<TypeDescription>nameStartsWith(\"jdk.internal.\"))\n+        // .and(not(named(\"jdk.internal.net.http.ImmutableHttpRequest\")))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c34ca7dd15fe37592edb1f4d0813fea7cc38697b"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MTk5MA==", "bodyText": "removed", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485591990", "createdAt": "2020-09-09T13:01:11Z", "author": {"login": "malafeev"}, "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpHeadersInstrumentation.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import static io.opentelemetry.instrumentation.auto.httpclient.JdkHttpClientTracer.TRACER;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.instrumentation.auto.api.concurrent.State;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpHeaders;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+@AutoService(Instrumenter.class)\n+public class HttpHeadersInstrumentation extends Instrumenter.Default {\n+\n+  public HttpHeadersInstrumentation() {\n+    super(\"httpclient\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(HttpClient.class.getName(), State.class.getName());\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return nameStartsWith(\"java.net.\")\n+        .or(ElementMatchers.<TypeDescription>nameStartsWith(\"jdk.internal.\"))\n+        // .and(not(named(\"jdk.internal.net.http.ImmutableHttpRequest\")))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MjI2NA=="}, "originalCommit": {"oid": "c34ca7dd15fe37592edb1f4d0813fea7cc38697b"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNTk4ODg5OnYy", "diffSide": "RIGHT", "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/ResponseConsumer.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNzowMjo0OVrOHO5cwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxMzowMToyM1rOHPGMOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MzM2MA==", "bodyText": "Why taking cause? Also I recommend overriding io.opentelemetry.instrumentation.api.tracer.BaseTracer#unwrapThrowable in JdkHttpClientTracer", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485383360", "createdAt": "2020-09-09T07:02:49Z", "author": {"login": "iNikem"}, "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/ResponseConsumer.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import static io.opentelemetry.instrumentation.auto.httpclient.JdkHttpClientTracer.TRACER;\n+\n+import io.opentelemetry.trace.Span;\n+import java.net.http.HttpResponse;\n+import java.util.Objects;\n+import java.util.function.BiConsumer;\n+\n+public class ResponseConsumer implements BiConsumer<HttpResponse<?>, Throwable> {\n+  private final Span span;\n+\n+  public ResponseConsumer(Span span) {\n+    this.span = span;\n+  }\n+\n+  @Override\n+  public void accept(HttpResponse<?> httpResponse, Throwable throwable) {\n+    if (throwable == null) {\n+      TRACER.end(span, httpResponse);\n+    } else {\n+      final Throwable cause = throwable.getCause();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c34ca7dd15fe37592edb1f4d0813fea7cc38697b"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU4ODY0Mw==", "bodyText": "because throwable here is java.util.concurrent.CompletionException.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485588643", "createdAt": "2020-09-09T12:56:03Z", "author": {"login": "malafeev"}, "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/ResponseConsumer.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import static io.opentelemetry.instrumentation.auto.httpclient.JdkHttpClientTracer.TRACER;\n+\n+import io.opentelemetry.trace.Span;\n+import java.net.http.HttpResponse;\n+import java.util.Objects;\n+import java.util.function.BiConsumer;\n+\n+public class ResponseConsumer implements BiConsumer<HttpResponse<?>, Throwable> {\n+  private final Span span;\n+\n+  public ResponseConsumer(Span span) {\n+    this.span = span;\n+  }\n+\n+  @Override\n+  public void accept(HttpResponse<?> httpResponse, Throwable throwable) {\n+    if (throwable == null) {\n+      TRACER.end(span, httpResponse);\n+    } else {\n+      final Throwable cause = throwable.getCause();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MzM2MA=="}, "originalCommit": {"oid": "c34ca7dd15fe37592edb1f4d0813fea7cc38697b"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MjEyMw==", "bodyText": "overrided", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485592123", "createdAt": "2020-09-09T13:01:23Z", "author": {"login": "malafeev"}, "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/ResponseConsumer.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import static io.opentelemetry.instrumentation.auto.httpclient.JdkHttpClientTracer.TRACER;\n+\n+import io.opentelemetry.trace.Span;\n+import java.net.http.HttpResponse;\n+import java.util.Objects;\n+import java.util.function.BiConsumer;\n+\n+public class ResponseConsumer implements BiConsumer<HttpResponse<?>, Throwable> {\n+  private final Span span;\n+\n+  public ResponseConsumer(Span span) {\n+    this.span = span;\n+  }\n+\n+  @Override\n+  public void accept(HttpResponse<?> httpResponse, Throwable throwable) {\n+    if (throwable == null) {\n+      TRACER.end(span, httpResponse);\n+    } else {\n+      final Throwable cause = throwable.getCause();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MzM2MA=="}, "originalCommit": {"oid": "c34ca7dd15fe37592edb1f4d0813fea7cc38697b"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNTk5MzI2OnYy", "diffSide": "RIGHT", "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/matcher/GlobalIgnoresMatcher.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNzowNDoyOFrOHO5few==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxMjo0Njo1MVrOHPFmRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4NDA1OQ==", "bodyText": "Move this near the check for java please.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485384059", "createdAt": "2020-09-09T07:04:28Z", "author": {"login": "iNikem"}, "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/matcher/GlobalIgnoresMatcher.java", "diffHunk": "@@ -64,6 +64,10 @@ private GlobalIgnoresMatcher(boolean skipAdditionalLibraryMatcher) {\n   public boolean matches(T target) {\n     String name = target.getActualName();\n \n+    if (name.startsWith(\"jdk.internal.net.http.\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c34ca7dd15fe37592edb1f4d0813fea7cc38697b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU4MjQwNw==", "bodyText": "next if checks for name.startsWith(\"jdk.\"):\nif (name.startsWith(\"net.bytebuddy.\")\n        || name.startsWith(\"jdk.\")\n        || name.startsWith(\"org.aspectj.\")\n        || name.startsWith(\"com.intellij.rt.debugger.\")\n        || name.startsWith(\"com.p6spy.\")\n        || name.startsWith(\"com.dynatrace.\")\n        || name.startsWith(\"com.jloadtrace.\")\n        || name.startsWith(\"com.appdynamics.\")\n        || name.startsWith(\"com.singularity.\")\n        || name.startsWith(\"com.jinspired.\")\n        || name.startsWith(\"org.jinspired.\")) {\n      return true;\n    }\n\nThat's why I put it before this if", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485582407", "createdAt": "2020-09-09T12:46:51Z", "author": {"login": "malafeev"}, "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/matcher/GlobalIgnoresMatcher.java", "diffHunk": "@@ -64,6 +64,10 @@ private GlobalIgnoresMatcher(boolean skipAdditionalLibraryMatcher) {\n   public boolean matches(T target) {\n     String name = target.getActualName();\n \n+    if (name.startsWith(\"jdk.internal.net.http.\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4NDA1OQ=="}, "originalCommit": {"oid": "c34ca7dd15fe37592edb1f4d0813fea7cc38697b"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNjQyMzU5OnYy", "diffSide": "RIGHT", "path": "instrumentation/httpclient/httpclient.gradle", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwODo1NzozM1rOHO9nQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxMzowMTo0MFrOHPGM8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ1MTU4Ng==", "bodyText": "@malafeev Go ahead and restore this after merging master :)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485451586", "createdAt": "2020-09-09T08:57:33Z", "author": {"login": "anuraaga"}, "path": "instrumentation/httpclient/httpclient.gradle", "diffHunk": "@@ -0,0 +1,12 @@\n+ext {\n+  minJavaVersionForTests = JavaVersion.VERSION_11\n+}\n+\n+apply from: \"$rootDir/gradle/instrumentation.gradle\"\n+\n+// FIXME: how to pass muzzle (only for jdk 11+)\n+//muzzle {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c34ca7dd15fe37592edb1f4d0813fea7cc38697b"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MjMwNw==", "bodyText": "done", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485592307", "createdAt": "2020-09-09T13:01:40Z", "author": {"login": "malafeev"}, "path": "instrumentation/httpclient/httpclient.gradle", "diffHunk": "@@ -0,0 +1,12 @@\n+ext {\n+  minJavaVersionForTests = JavaVersion.VERSION_11\n+}\n+\n+apply from: \"$rootDir/gradle/instrumentation.gradle\"\n+\n+// FIXME: how to pass muzzle (only for jdk 11+)\n+//muzzle {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ1MTU4Ng=="}, "originalCommit": {"oid": "c34ca7dd15fe37592edb1f4d0813fea7cc38697b"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzOTMyMDQ3OnYy", "diffSide": "RIGHT", "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpClientInstrumentation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQyMDo0NDo1NVrOHPZqXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNjoxODo0NVrOHPkoHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkxMTEzNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    @Advice.Return(readOnly = false, typing = Typing.DYNAMIC)\n          \n          \n            \n                        CompletableFuture<HttpResponse<?>> future,\n          \n          \n            \n                    @Advice.Return(readOnly = false) CompletableFuture<HttpResponse<?>> future,", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485911134", "createdAt": "2020-09-09T20:44:55Z", "author": {"login": "trask"}, "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpClientInstrumentation.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import static io.opentelemetry.instrumentation.auto.httpclient.JdkHttpClientTracer.TRACER;\n+import static io.opentelemetry.javaagent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.instrumentation.auto.api.CallDepthThreadLocalMap.Depth;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import io.opentelemetry.trace.Span;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.implementation.bytecode.assign.Assigner.Typing;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class HttpClientInstrumentation extends Instrumenter.Default {\n+\n+  public HttpClientInstrumentation() {\n+    super(\"httpclient\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\"java.net.http.HttpClient\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"java.net.http.HttpRequest\", Context.class.getName());\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return nameStartsWith(\"java.net.\")\n+        .or(nameStartsWith(\"jdk.internal.\"))\n+        .and(not(named(\"jdk.internal.net.http.HttpClientFacade\")))\n+        .and(extendsClass(named(\"java.net.http.HttpClient\")));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".HttpHeadersInjectAdapter\",\n+      packageName + \".JdkHttpClientTracer\",\n+      packageName + \".ResponseConsumer\"\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+\n+    transformers.put(\n+        isMethod()\n+            .and(named(\"send\"))\n+            .and(isPublic())\n+            .and(takesArguments(2))\n+            .and(takesArgument(0, named(\"java.net.http.HttpRequest\"))),\n+        HttpClientInstrumentation.class.getName() + \"$SendAdvice\");\n+\n+    transformers.put(\n+        isMethod()\n+            .and(named(\"sendAsync\"))\n+            .and(isPublic())\n+            .and(takesArgument(0, named(\"java.net.http.HttpRequest\"))),\n+        HttpClientInstrumentation.class.getName() + \"$SendAsyncAdvice\");\n+\n+    return transformers;\n+  }\n+\n+  public static class SendAdvice {\n+\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void methodEnter(\n+        @Advice.Argument(value = 0) HttpRequest httpRequest,\n+        @Advice.Local(\"otelSpan\") Span span,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") Depth callDepth) {\n+\n+      callDepth = TRACER.getCallDepth();\n+      if (callDepth.getAndIncrement() == 0) {\n+        span = TRACER.startSpan(httpRequest);\n+        if (span.getContext().isValid()) {\n+          scope = TRACER.startScope(span, httpRequest);\n+        }\n+      }\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void methodExit(\n+        @Advice.Return HttpResponse result,\n+        @Advice.Thrown Throwable throwable,\n+        @Advice.Local(\"otelSpan\") Span span,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") Depth callDepth) {\n+\n+      if (callDepth.decrementAndGet() == 0 && scope != null) {\n+        scope.close();\n+        if (throwable == null) {\n+          TRACER.end(span, result);\n+        } else {\n+          TRACER.endExceptionally(span, result, throwable);\n+        }\n+      }\n+    }\n+  }\n+\n+  public static class SendAsyncAdvice {\n+\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void methodEnter(\n+        @Advice.Argument(value = 0) HttpRequest httpRequest,\n+        @Advice.Local(\"otelSpan\") Span span,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") Depth callDepth) {\n+\n+      callDepth = TRACER.getCallDepth();\n+      if (callDepth.getAndIncrement() == 0) {\n+        span = TRACER.startSpan(httpRequest);\n+        if (span.getContext().isValid()) {\n+          scope = TRACER.startScope(span, httpRequest);\n+        }\n+      }\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void methodExit(\n+        @Advice.Return(readOnly = false, typing = Typing.DYNAMIC)\n+            CompletableFuture<HttpResponse<?>> future,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "106aa5d6ace77810e69b2349b9824a8ae23deb25"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA5MDc4Mw==", "bodyText": "done", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r486090783", "createdAt": "2020-09-10T06:18:45Z", "author": {"login": "malafeev"}, "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpClientInstrumentation.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import static io.opentelemetry.instrumentation.auto.httpclient.JdkHttpClientTracer.TRACER;\n+import static io.opentelemetry.javaagent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.instrumentation.auto.api.CallDepthThreadLocalMap.Depth;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import io.opentelemetry.trace.Span;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.implementation.bytecode.assign.Assigner.Typing;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class HttpClientInstrumentation extends Instrumenter.Default {\n+\n+  public HttpClientInstrumentation() {\n+    super(\"httpclient\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\"java.net.http.HttpClient\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"java.net.http.HttpRequest\", Context.class.getName());\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return nameStartsWith(\"java.net.\")\n+        .or(nameStartsWith(\"jdk.internal.\"))\n+        .and(not(named(\"jdk.internal.net.http.HttpClientFacade\")))\n+        .and(extendsClass(named(\"java.net.http.HttpClient\")));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".HttpHeadersInjectAdapter\",\n+      packageName + \".JdkHttpClientTracer\",\n+      packageName + \".ResponseConsumer\"\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+\n+    transformers.put(\n+        isMethod()\n+            .and(named(\"send\"))\n+            .and(isPublic())\n+            .and(takesArguments(2))\n+            .and(takesArgument(0, named(\"java.net.http.HttpRequest\"))),\n+        HttpClientInstrumentation.class.getName() + \"$SendAdvice\");\n+\n+    transformers.put(\n+        isMethod()\n+            .and(named(\"sendAsync\"))\n+            .and(isPublic())\n+            .and(takesArgument(0, named(\"java.net.http.HttpRequest\"))),\n+        HttpClientInstrumentation.class.getName() + \"$SendAsyncAdvice\");\n+\n+    return transformers;\n+  }\n+\n+  public static class SendAdvice {\n+\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void methodEnter(\n+        @Advice.Argument(value = 0) HttpRequest httpRequest,\n+        @Advice.Local(\"otelSpan\") Span span,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") Depth callDepth) {\n+\n+      callDepth = TRACER.getCallDepth();\n+      if (callDepth.getAndIncrement() == 0) {\n+        span = TRACER.startSpan(httpRequest);\n+        if (span.getContext().isValid()) {\n+          scope = TRACER.startScope(span, httpRequest);\n+        }\n+      }\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void methodExit(\n+        @Advice.Return HttpResponse result,\n+        @Advice.Thrown Throwable throwable,\n+        @Advice.Local(\"otelSpan\") Span span,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") Depth callDepth) {\n+\n+      if (callDepth.decrementAndGet() == 0 && scope != null) {\n+        scope.close();\n+        if (throwable == null) {\n+          TRACER.end(span, result);\n+        } else {\n+          TRACER.endExceptionally(span, result, throwable);\n+        }\n+      }\n+    }\n+  }\n+\n+  public static class SendAsyncAdvice {\n+\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void methodEnter(\n+        @Advice.Argument(value = 0) HttpRequest httpRequest,\n+        @Advice.Local(\"otelSpan\") Span span,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") Depth callDepth) {\n+\n+      callDepth = TRACER.getCallDepth();\n+      if (callDepth.getAndIncrement() == 0) {\n+        span = TRACER.startSpan(httpRequest);\n+        if (span.getContext().isValid()) {\n+          scope = TRACER.startScope(span, httpRequest);\n+        }\n+      }\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void methodExit(\n+        @Advice.Return(readOnly = false, typing = Typing.DYNAMIC)\n+            CompletableFuture<HttpResponse<?>> future,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkxMTEzNA=="}, "originalCommit": {"oid": "106aa5d6ace77810e69b2349b9824a8ae23deb25"}, "originalPosition": 163}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzOTMzMzMwOnYy", "diffSide": "RIGHT", "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpHeadersInstrumentation.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQyMDo0ODozOVrOHPZx9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNjoxNzo1N1rOHPknGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkxMzA3OQ==", "bodyText": "this looks unused\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n              @Override\n          \n          \n            \n              public Map<String, String> contextStore() {\n          \n          \n            \n                return singletonMap(HttpClient.class.getName(), State.class.getName());\n          \n          \n            \n              }", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485913079", "createdAt": "2020-09-09T20:48:39Z", "author": {"login": "trask"}, "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpHeadersInstrumentation.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import static io.opentelemetry.instrumentation.auto.httpclient.JdkHttpClientTracer.TRACER;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.instrumentation.auto.api.concurrent.State;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpHeaders;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class HttpHeadersInstrumentation extends Instrumenter.Default {\n+\n+  public HttpHeadersInstrumentation() {\n+    super(\"httpclient\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(HttpClient.class.getName(), State.class.getName());\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "106aa5d6ace77810e69b2349b9824a8ae23deb25"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA5MDUyMA==", "bodyText": "removed", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r486090520", "createdAt": "2020-09-10T06:17:57Z", "author": {"login": "malafeev"}, "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpHeadersInstrumentation.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import static io.opentelemetry.instrumentation.auto.httpclient.JdkHttpClientTracer.TRACER;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.instrumentation.auto.api.concurrent.State;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpHeaders;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class HttpHeadersInstrumentation extends Instrumenter.Default {\n+\n+  public HttpHeadersInstrumentation() {\n+    super(\"httpclient\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(HttpClient.class.getName(), State.class.getName());\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkxMzA3OQ=="}, "originalCommit": {"oid": "106aa5d6ace77810e69b2349b9824a8ae23deb25"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzOTMzMzg3OnYy", "diffSide": "RIGHT", "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpClientInstrumentation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQyMDo0ODo1MFrOHPZyUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNjoxOTowM1rOHPkohg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkxMzE3MQ==", "bodyText": "this looks unused\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n              @Override\n          \n          \n            \n              public Map<String, String> contextStore() {\n          \n          \n            \n                return singletonMap(\"java.net.http.HttpRequest\", Context.class.getName());\n          \n          \n            \n              }", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485913171", "createdAt": "2020-09-09T20:48:50Z", "author": {"login": "trask"}, "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpClientInstrumentation.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import static io.opentelemetry.instrumentation.auto.httpclient.JdkHttpClientTracer.TRACER;\n+import static io.opentelemetry.javaagent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.instrumentation.auto.api.CallDepthThreadLocalMap.Depth;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import io.opentelemetry.trace.Span;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.implementation.bytecode.assign.Assigner.Typing;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class HttpClientInstrumentation extends Instrumenter.Default {\n+\n+  public HttpClientInstrumentation() {\n+    super(\"httpclient\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\"java.net.http.HttpClient\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"java.net.http.HttpRequest\", Context.class.getName());\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "106aa5d6ace77810e69b2349b9824a8ae23deb25"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA5MDg4Ng==", "bodyText": "removed", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r486090886", "createdAt": "2020-09-10T06:19:03Z", "author": {"login": "malafeev"}, "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpClientInstrumentation.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import static io.opentelemetry.instrumentation.auto.httpclient.JdkHttpClientTracer.TRACER;\n+import static io.opentelemetry.javaagent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.instrumentation.auto.api.CallDepthThreadLocalMap.Depth;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import io.opentelemetry.trace.Span;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.implementation.bytecode.assign.Assigner.Typing;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class HttpClientInstrumentation extends Instrumenter.Default {\n+\n+  public HttpClientInstrumentation() {\n+    super(\"httpclient\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\"java.net.http.HttpClient\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"java.net.http.HttpRequest\", Context.class.getName());\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkxMzE3MQ=="}, "originalCommit": {"oid": "106aa5d6ace77810e69b2349b9824a8ae23deb25"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzOTMzODEyOnYy", "diffSide": "RIGHT", "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpHeadersInstrumentation.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQyMDo1MDowOFrOHPZ07A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNjoxNjoyNlrOHPkk5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkxMzgzNg==", "bodyText": "good to add same classLoaderMatcher() here also from HttpClientInstrumentation", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485913836", "createdAt": "2020-09-09T20:50:08Z", "author": {"login": "trask"}, "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpHeadersInstrumentation.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import static io.opentelemetry.instrumentation.auto.httpclient.JdkHttpClientTracer.TRACER;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.instrumentation.auto.api.concurrent.State;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpHeaders;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class HttpHeadersInstrumentation extends Instrumenter.Default {\n+\n+  public HttpHeadersInstrumentation() {\n+    super(\"httpclient\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(HttpClient.class.getName(), State.class.getName());\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "106aa5d6ace77810e69b2349b9824a8ae23deb25"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA4OTk1Ng==", "bodyText": "added", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r486089956", "createdAt": "2020-09-10T06:16:26Z", "author": {"login": "malafeev"}, "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpHeadersInstrumentation.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import static io.opentelemetry.instrumentation.auto.httpclient.JdkHttpClientTracer.TRACER;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.instrumentation.auto.api.concurrent.State;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpHeaders;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class HttpHeadersInstrumentation extends Instrumenter.Default {\n+\n+  public HttpHeadersInstrumentation() {\n+    super(\"httpclient\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(HttpClient.class.getName(), State.class.getName());\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkxMzgzNg=="}, "originalCommit": {"oid": "106aa5d6ace77810e69b2349b9824a8ae23deb25"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzOTM0OTIwOnYy", "diffSide": "RIGHT", "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/JdkHttpClientTracer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQyMDo1MzozMFrOHPZ7rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNjoxNjowNVrOHPkkWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkxNTU2Ng==", "bodyText": "this seems maybe too generic, same for the module name, maybe \"java-httpclient\"?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485915566", "createdAt": "2020-09-09T20:53:30Z", "author": {"login": "trask"}, "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/JdkHttpClientTracer.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.context.propagation.TextMapPropagator.Setter;\n+import io.opentelemetry.instrumentation.api.tracer.HttpClientTracer;\n+import io.opentelemetry.instrumentation.auto.api.CallDepthThreadLocalMap;\n+import io.opentelemetry.instrumentation.auto.api.CallDepthThreadLocalMap.Depth;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpHeaders;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletionException;\n+\n+public class JdkHttpClientTracer extends HttpClientTracer<HttpRequest, HttpRequest, HttpResponse> {\n+  public static final JdkHttpClientTracer TRACER = new JdkHttpClientTracer();\n+\n+  public Depth getCallDepth() {\n+    return CallDepthThreadLocalMap.getCallDepth(HttpClient.class);\n+  }\n+\n+  @Override\n+  protected String getInstrumentationName() {\n+    return \"io.opentelemetry.auto.httpclient\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "106aa5d6ace77810e69b2349b9824a8ae23deb25"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA4OTgxOA==", "bodyText": "renamed", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r486089818", "createdAt": "2020-09-10T06:16:05Z", "author": {"login": "malafeev"}, "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/JdkHttpClientTracer.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.context.propagation.TextMapPropagator.Setter;\n+import io.opentelemetry.instrumentation.api.tracer.HttpClientTracer;\n+import io.opentelemetry.instrumentation.auto.api.CallDepthThreadLocalMap;\n+import io.opentelemetry.instrumentation.auto.api.CallDepthThreadLocalMap.Depth;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpHeaders;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletionException;\n+\n+public class JdkHttpClientTracer extends HttpClientTracer<HttpRequest, HttpRequest, HttpResponse> {\n+  public static final JdkHttpClientTracer TRACER = new JdkHttpClientTracer();\n+\n+  public Depth getCallDepth() {\n+    return CallDepthThreadLocalMap.getCallDepth(HttpClient.class);\n+  }\n+\n+  @Override\n+  protected String getInstrumentationName() {\n+    return \"io.opentelemetry.auto.httpclient\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkxNTU2Ng=="}, "originalCommit": {"oid": "106aa5d6ace77810e69b2349b9824a8ae23deb25"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzOTM5MDA3OnYy", "diffSide": "RIGHT", "path": "instrumentation/httpclient/src/test/groovy/JdkHttpClientTest.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQyMTowNjowN1rOHPaUaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNjoyMzoyNFrOHPkvbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkyMTg5Nw==", "bodyText": "and add followRedirects(HttpClient.Redirect.NORMAL) to http client configuration above\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              boolean testRedirects() {\n          \n          \n            \n                // Generates 4 spans\n          \n          \n            \n              boolean testCircularRedirects() {", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485921897", "createdAt": "2020-09-09T21:06:07Z", "author": {"login": "trask"}, "path": "instrumentation/httpclient/src/test/groovy/JdkHttpClientTest.groovy", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import io.opentelemetry.auto.test.base.HttpClientTest\n+import spock.lang.Shared\n+import spock.lang.Timeout\n+\n+import java.net.http.HttpClient\n+import java.net.http.HttpRequest\n+import java.net.http.HttpResponse\n+import java.time.Duration\n+import java.time.temporal.ChronoUnit\n+\n+@Timeout(5)\n+abstract class JdkHttpClientTest extends HttpClientTest {\n+\n+  @Shared\n+  def client = HttpClient.newBuilder().connectTimeout(Duration.of(CONNECT_TIMEOUT_MS,\n+    ChronoUnit.MILLIS)).build()\n+\n+  @Override\n+  int doRequest(String method, URI uri, Map<String, String> headers, Closure callback) {\n+\n+    def builder = HttpRequest.newBuilder().uri(uri).method(method, HttpRequest.BodyPublishers.noBody())\n+\n+    headers.entrySet().each {\n+      builder.header(it.key, it.value)\n+    }\n+    def request = builder.build()\n+\n+    def resp = send(request)\n+    callback?.call()\n+    return resp.statusCode()\n+  }\n+\n+  abstract HttpResponse send(HttpRequest request)\n+\n+  @Override\n+  boolean testRedirects() {\n+    // Generates 4 spans", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "106aa5d6ace77810e69b2349b9824a8ae23deb25"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA5MjY1NA==", "bodyText": "added", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r486092654", "createdAt": "2020-09-10T06:23:24Z", "author": {"login": "malafeev"}, "path": "instrumentation/httpclient/src/test/groovy/JdkHttpClientTest.groovy", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import io.opentelemetry.auto.test.base.HttpClientTest\n+import spock.lang.Shared\n+import spock.lang.Timeout\n+\n+import java.net.http.HttpClient\n+import java.net.http.HttpRequest\n+import java.net.http.HttpResponse\n+import java.time.Duration\n+import java.time.temporal.ChronoUnit\n+\n+@Timeout(5)\n+abstract class JdkHttpClientTest extends HttpClientTest {\n+\n+  @Shared\n+  def client = HttpClient.newBuilder().connectTimeout(Duration.of(CONNECT_TIMEOUT_MS,\n+    ChronoUnit.MILLIS)).build()\n+\n+  @Override\n+  int doRequest(String method, URI uri, Map<String, String> headers, Closure callback) {\n+\n+    def builder = HttpRequest.newBuilder().uri(uri).method(method, HttpRequest.BodyPublishers.noBody())\n+\n+    headers.entrySet().each {\n+      builder.header(it.key, it.value)\n+    }\n+    def request = builder.build()\n+\n+    def resp = send(request)\n+    callback?.call()\n+    return resp.statusCode()\n+  }\n+\n+  abstract HttpResponse send(HttpRequest request)\n+\n+  @Override\n+  boolean testRedirects() {\n+    // Generates 4 spans", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkyMTg5Nw=="}, "originalCommit": {"oid": "106aa5d6ace77810e69b2349b9824a8ae23deb25"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzOTQwODIyOnYy", "diffSide": "RIGHT", "path": "settings.gradle", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQyMToxMjoxMlrOHPaflg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNjoxNjoxMlrOHPkkmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkyNDc1OA==", "bodyText": "i think this name is too generic, since there are many httpclient instrumentations, i think my suggestion would be java-httpclient", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485924758", "createdAt": "2020-09-09T21:12:12Z", "author": {"login": "trask"}, "path": "settings.gradle", "diffHunk": "@@ -91,6 +91,7 @@ include ':instrumentation:hibernate:hibernate-4.0'\n include ':instrumentation:hibernate:hibernate-4.3'\n include ':instrumentation:hibernate:hibernate-common'\n include ':instrumentation:http-url-connection'\n+include ':instrumentation:httpclient'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "106aa5d6ace77810e69b2349b9824a8ae23deb25"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA4OTg4MA==", "bodyText": "renamed", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r486089880", "createdAt": "2020-09-10T06:16:12Z", "author": {"login": "malafeev"}, "path": "settings.gradle", "diffHunk": "@@ -91,6 +91,7 @@ include ':instrumentation:hibernate:hibernate-4.0'\n include ':instrumentation:hibernate:hibernate-4.3'\n include ':instrumentation:hibernate:hibernate-common'\n include ':instrumentation:http-url-connection'\n+include ':instrumentation:httpclient'", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkyNDc1OA=="}, "originalCommit": {"oid": "106aa5d6ace77810e69b2349b9824a8ae23deb25"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4840, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}