{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEwNTMzNjQ0", "number": 1493, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwNDoyNDo1MFrOEypQLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQwNToxNTo1NFrOEzIVqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNTQwMTQwOnYy", "diffSide": "RIGHT", "path": "instrumentation/opentelemetry-api-beta/src/main/java/io/opentelemetry/javaagent/instrumentation/opentelemetryapi/ContextInstrumentation.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwNDoyNDo1MFrOHpZkgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwNDoyNDo1MFrOHpZkgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE3MjYxMQ==", "bodyText": "We used to instrument all the methods of the package-private class TracingContextUtils, now we do still end up with one instrumentation of DefaultContext along with the reflective access to the context key.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1493#discussion_r513172611", "createdAt": "2020-10-28T04:24:50Z", "author": {"login": "anuraaga"}, "path": "instrumentation/opentelemetry-api-beta/src/main/java/io/opentelemetry/javaagent/instrumentation/opentelemetryapi/ContextInstrumentation.java", "diffHunk": "@@ -6,65 +6,48 @@\n package io.opentelemetry.javaagent.instrumentation.opentelemetryapi;\n \n import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n-import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n import static net.bytebuddy.matcher.ElementMatchers.isStatic;\n import static net.bytebuddy.matcher.ElementMatchers.named;\n-import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n \n import application.io.opentelemetry.context.Context;\n-import application.io.opentelemetry.context.Scope;\n+import application.io.opentelemetry.context.ContextStorage;\n import com.google.auto.service.AutoService;\n-import io.opentelemetry.javaagent.instrumentation.api.ContextStore;\n-import io.opentelemetry.javaagent.instrumentation.api.InstrumentationContext;\n+import io.opentelemetry.javaagent.instrumentation.opentelemetryapi.context.AgentContextStorage;\n import io.opentelemetry.javaagent.tooling.Instrumenter;\n-import java.util.HashMap;\n+import java.util.Collections;\n import java.util.Map;\n import net.bytebuddy.asm.Advice;\n import net.bytebuddy.description.method.MethodDescription;\n import net.bytebuddy.description.type.TypeDescription;\n import net.bytebuddy.matcher.ElementMatcher;\n \n+/**\n+ * Returns {@link AgentContextStorage} as the implementation of {@link ContextStorage} in the\n+ * application classpath. We do this instead of using the normal service loader mechanism to make\n+ * sure there is no dependency on a system property or possibility of a user overriding this since\n+ * it's required for instrumentation in the agent to work properly.\n+ */\n @AutoService(Instrumenter.class)\n public class ContextInstrumentation extends AbstractInstrumentation {\n \n   @Override\n   public ElementMatcher<? super TypeDescription> typeMatcher() {\n-    return named(\"application.io.opentelemetry.context.Context\");\n+    return named(\"application.io.opentelemetry.context.DefaultContext\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60644edbe70da71eaea0ac32bd1c46711a2b1ea7"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNTQwMjE5OnYy", "diffSide": "RIGHT", "path": "instrumentation/opentelemetry-api-beta/src/main/java/io/opentelemetry/javaagent/instrumentation/opentelemetryapi/context/AgentContextStorage.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwNDoyNToxMVrOHpZk5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQwNDo1Njo1M1rOHqKNrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE3MjcxMQ==", "bodyText": "Since an agent can take over apps, I'm assuming this is allowed? Not sure", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1493#discussion_r513172711", "createdAt": "2020-10-28T04:25:11Z", "author": {"login": "anuraaga"}, "path": "instrumentation/opentelemetry-api-beta/src/main/java/io/opentelemetry/javaagent/instrumentation/opentelemetryapi/context/AgentContextStorage.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.opentelemetryapi.context;\n+\n+import application.io.opentelemetry.context.Context;\n+import application.io.opentelemetry.context.ContextKey;\n+import application.io.opentelemetry.context.ContextStorage;\n+import application.io.opentelemetry.context.Scope;\n+import application.io.opentelemetry.trace.Span;\n+import io.opentelemetry.javaagent.instrumentation.opentelemetryapi.trace.Bridging;\n+import java.lang.reflect.Field;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link ContextStorage} which stores the {@link Context} in the user's application inside the\n+ * {@link Context} in the agent. This allows for context interaction to be maintained between the\n+ * app and agent.\n+ *\n+ * <p>This storage allows for implicit parenting of context to exist between the agent and\n+ * application by storing the concrete application context in the agent context and returning a\n+ * wrapper which accesses into this stored concrete context.\n+ *\n+ * <p>This storage also makes sure that OpenTelemetry objects are shared within the context. To do\n+ * this, it recognizes the keys for OpenTelemetry objects (e.g, {@link Span}, Baggage (WIP)) and\n+ * always stores and retrieves them from the agent context, even when accessed from the application.\n+ * All other accesses are to the concrete application context.\n+ */\n+public class AgentContextStorage implements ContextStorage {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(AgentContextStorage.class);\n+\n+  public static final AgentContextStorage INSTANCE = new AgentContextStorage();\n+\n+  public static io.opentelemetry.context.Context getAgentContext(Context applicationContext) {\n+    if (applicationContext instanceof AgentContextWrapper) {\n+      return ((AgentContextWrapper) applicationContext).toAgentContext();\n+    }\n+    if (logger.isDebugEnabled()) {\n+      logger.debug(\n+          \"unexpected context: {}\", applicationContext, new Exception(\"unexpected context\"));\n+    }\n+    return io.opentelemetry.context.Context.root();\n+  }\n+\n+  static final io.opentelemetry.context.ContextKey<Context> APPLICATION_CONTEXT =\n+      io.opentelemetry.context.ContextKey.named(\"otel-context\");\n+\n+  static final io.opentelemetry.context.ContextKey<io.opentelemetry.trace.Span>\n+      AGENT_SPAN_CONTEXT_KEY;\n+  static final ContextKey<Span> APPLICATION_SPAN_CONTEXT_KEY;\n+\n+  static {\n+    io.opentelemetry.context.ContextKey<io.opentelemetry.trace.Span> agentSpanContextKey;\n+    try {\n+      Class<?> tracingContextUtils = Class.forName(\"io.opentelemetry.trace.TracingContextUtils\");\n+      Field contextSpanKeyField = tracingContextUtils.getDeclaredField(\"CONTEXT_SPAN_KEY\");\n+      contextSpanKeyField.setAccessible(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60644edbe70da71eaea0ac32bd1c46711a2b1ea7"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzk2OTU4Mg==", "bodyText": "let's figure this out later \ud83d\ude04 created #1520 and referenced this comment to track", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1493#discussion_r513969582", "createdAt": "2020-10-29T04:56:53Z", "author": {"login": "trask"}, "path": "instrumentation/opentelemetry-api-beta/src/main/java/io/opentelemetry/javaagent/instrumentation/opentelemetryapi/context/AgentContextStorage.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.opentelemetryapi.context;\n+\n+import application.io.opentelemetry.context.Context;\n+import application.io.opentelemetry.context.ContextKey;\n+import application.io.opentelemetry.context.ContextStorage;\n+import application.io.opentelemetry.context.Scope;\n+import application.io.opentelemetry.trace.Span;\n+import io.opentelemetry.javaagent.instrumentation.opentelemetryapi.trace.Bridging;\n+import java.lang.reflect.Field;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link ContextStorage} which stores the {@link Context} in the user's application inside the\n+ * {@link Context} in the agent. This allows for context interaction to be maintained between the\n+ * app and agent.\n+ *\n+ * <p>This storage allows for implicit parenting of context to exist between the agent and\n+ * application by storing the concrete application context in the agent context and returning a\n+ * wrapper which accesses into this stored concrete context.\n+ *\n+ * <p>This storage also makes sure that OpenTelemetry objects are shared within the context. To do\n+ * this, it recognizes the keys for OpenTelemetry objects (e.g, {@link Span}, Baggage (WIP)) and\n+ * always stores and retrieves them from the agent context, even when accessed from the application.\n+ * All other accesses are to the concrete application context.\n+ */\n+public class AgentContextStorage implements ContextStorage {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(AgentContextStorage.class);\n+\n+  public static final AgentContextStorage INSTANCE = new AgentContextStorage();\n+\n+  public static io.opentelemetry.context.Context getAgentContext(Context applicationContext) {\n+    if (applicationContext instanceof AgentContextWrapper) {\n+      return ((AgentContextWrapper) applicationContext).toAgentContext();\n+    }\n+    if (logger.isDebugEnabled()) {\n+      logger.debug(\n+          \"unexpected context: {}\", applicationContext, new Exception(\"unexpected context\"));\n+    }\n+    return io.opentelemetry.context.Context.root();\n+  }\n+\n+  static final io.opentelemetry.context.ContextKey<Context> APPLICATION_CONTEXT =\n+      io.opentelemetry.context.ContextKey.named(\"otel-context\");\n+\n+  static final io.opentelemetry.context.ContextKey<io.opentelemetry.trace.Span>\n+      AGENT_SPAN_CONTEXT_KEY;\n+  static final ContextKey<Span> APPLICATION_SPAN_CONTEXT_KEY;\n+\n+  static {\n+    io.opentelemetry.context.ContextKey<io.opentelemetry.trace.Span> agentSpanContextKey;\n+    try {\n+      Class<?> tracingContextUtils = Class.forName(\"io.opentelemetry.trace.TracingContextUtils\");\n+      Field contextSpanKeyField = tracingContextUtils.getDeclaredField(\"CONTEXT_SPAN_KEY\");\n+      contextSpanKeyField.setAccessible(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE3MjcxMQ=="}, "originalCommit": {"oid": "60644edbe70da71eaea0ac32bd1c46711a2b1ea7"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyMDQ3MDU0OnYy", "diffSide": "RIGHT", "path": "instrumentation/opentelemetry-api-beta/src/test/groovy/ContextBridgeTest.groovy", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQwNTowNzozMlrOHqKgvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQwNjoyODo1OVrOHqNIxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzk3NDQ2Mg==", "bodyText": "does this test show interop, or just side-by-side, since everything is in the same thread?\nwould it be better to Context.root().makeCurrent().withCloseable {} (for both agent and non-agent) around each existing makeCurrent().withCloseable {} (except for the first) below?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1493#discussion_r513974462", "createdAt": "2020-10-29T05:07:32Z", "author": {"login": "trask"}, "path": "instrumentation/opentelemetry-api-beta/src/test/groovy/ContextBridgeTest.groovy", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import application.io.opentelemetry.OpenTelemetry\n+import application.io.opentelemetry.context.Context\n+import application.io.opentelemetry.context.ContextKey\n+import application.io.opentelemetry.trace.Span\n+import io.opentelemetry.instrumentation.test.AgentTestRunner\n+import java.util.concurrent.ExecutorService\n+import java.util.concurrent.Executors\n+import java.util.concurrent.atomic.AtomicReference\n+import spock.lang.Shared\n+\n+class ContextBridgeTest extends AgentTestRunner {\n+\n+  private static final ContextKey<String> ANIMAL = ContextKey.named(\"animal\")\n+\n+  private static final io.opentelemetry.context.ContextKey<String> FOOD =\n+    io.opentelemetry.context.ContextKey.named(\"food\")\n+  private static final io.opentelemetry.context.ContextKey<String> COUNTRY =\n+    io.opentelemetry.context.ContextKey.named(\"country\")\n+\n+  @Shared\n+  ExecutorService otherThread\n+\n+  def setupSpec() {\n+    otherThread = Executors.newSingleThreadExecutor()\n+  }\n+\n+  def cleanupSpec() {\n+    otherThread.shutdown()\n+  }\n+\n+  def \"agent and application mix\"() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee5c35eef7c745c79e98bc28e475f8ecdaef0355"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDAwODU3OQ==", "bodyText": "I don't think this one shows interop indeed, just the context parenting. The below tests have \"another thread\" for propagation test.\nNot sure I understand would it be better to Context.root().makeCurrent().withCloseable {} - if we mount root in the middle of the tree it's like resetting context, right?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1493#discussion_r514008579", "createdAt": "2020-10-29T06:15:21Z", "author": {"login": "anuraaga"}, "path": "instrumentation/opentelemetry-api-beta/src/test/groovy/ContextBridgeTest.groovy", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import application.io.opentelemetry.OpenTelemetry\n+import application.io.opentelemetry.context.Context\n+import application.io.opentelemetry.context.ContextKey\n+import application.io.opentelemetry.trace.Span\n+import io.opentelemetry.instrumentation.test.AgentTestRunner\n+import java.util.concurrent.ExecutorService\n+import java.util.concurrent.Executors\n+import java.util.concurrent.atomic.AtomicReference\n+import spock.lang.Shared\n+\n+class ContextBridgeTest extends AgentTestRunner {\n+\n+  private static final ContextKey<String> ANIMAL = ContextKey.named(\"animal\")\n+\n+  private static final io.opentelemetry.context.ContextKey<String> FOOD =\n+    io.opentelemetry.context.ContextKey.named(\"food\")\n+  private static final io.opentelemetry.context.ContextKey<String> COUNTRY =\n+    io.opentelemetry.context.ContextKey.named(\"country\")\n+\n+  @Shared\n+  ExecutorService otherThread\n+\n+  def setupSpec() {\n+    otherThread = Executors.newSingleThreadExecutor()\n+  }\n+\n+  def cleanupSpec() {\n+    otherThread.shutdown()\n+  }\n+\n+  def \"agent and application mix\"() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzk3NDQ2Mg=="}, "originalCommit": {"oid": "ee5c35eef7c745c79e98bc28e475f8ecdaef0355"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDAxNzQ3Ng==", "bodyText": "ya, you're right, the test below addresses propagating across threads, so no need for that in this test", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1493#discussion_r514017476", "createdAt": "2020-10-29T06:28:59Z", "author": {"login": "trask"}, "path": "instrumentation/opentelemetry-api-beta/src/test/groovy/ContextBridgeTest.groovy", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import application.io.opentelemetry.OpenTelemetry\n+import application.io.opentelemetry.context.Context\n+import application.io.opentelemetry.context.ContextKey\n+import application.io.opentelemetry.trace.Span\n+import io.opentelemetry.instrumentation.test.AgentTestRunner\n+import java.util.concurrent.ExecutorService\n+import java.util.concurrent.Executors\n+import java.util.concurrent.atomic.AtomicReference\n+import spock.lang.Shared\n+\n+class ContextBridgeTest extends AgentTestRunner {\n+\n+  private static final ContextKey<String> ANIMAL = ContextKey.named(\"animal\")\n+\n+  private static final io.opentelemetry.context.ContextKey<String> FOOD =\n+    io.opentelemetry.context.ContextKey.named(\"food\")\n+  private static final io.opentelemetry.context.ContextKey<String> COUNTRY =\n+    io.opentelemetry.context.ContextKey.named(\"country\")\n+\n+  @Shared\n+  ExecutorService otherThread\n+\n+  def setupSpec() {\n+    otherThread = Executors.newSingleThreadExecutor()\n+  }\n+\n+  def cleanupSpec() {\n+    otherThread.shutdown()\n+  }\n+\n+  def \"agent and application mix\"() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzk3NDQ2Mg=="}, "originalCommit": {"oid": "ee5c35eef7c745c79e98bc28e475f8ecdaef0355"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyMDQ5NDUxOnYy", "diffSide": "RIGHT", "path": "instrumentation/opentelemetry-api-beta/src/test/groovy/ContextBridgeTest.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQwNToxNTo1NFrOHqKwjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQwNjoxODoxOFrOHqMr4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzk3ODUxMQ==", "bodyText": "these tests run with our java-concurrent, so I think that will auto-propagate agentContext(?) which makes it hard to reason about this test\nmaybe cleaner to do the Context.root().makeCurrent().withScoped {} on both, then call context.wrap(runnable).run() inside of that, and not mess with threads?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1493#discussion_r513978511", "createdAt": "2020-10-29T05:15:54Z", "author": {"login": "trask"}, "path": "instrumentation/opentelemetry-api-beta/src/test/groovy/ContextBridgeTest.groovy", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import application.io.opentelemetry.OpenTelemetry\n+import application.io.opentelemetry.context.Context\n+import application.io.opentelemetry.context.ContextKey\n+import application.io.opentelemetry.trace.Span\n+import io.opentelemetry.instrumentation.test.AgentTestRunner\n+import java.util.concurrent.ExecutorService\n+import java.util.concurrent.Executors\n+import java.util.concurrent.atomic.AtomicReference\n+import spock.lang.Shared\n+\n+class ContextBridgeTest extends AgentTestRunner {\n+\n+  private static final ContextKey<String> ANIMAL = ContextKey.named(\"animal\")\n+\n+  private static final io.opentelemetry.context.ContextKey<String> FOOD =\n+    io.opentelemetry.context.ContextKey.named(\"food\")\n+  private static final io.opentelemetry.context.ContextKey<String> COUNTRY =\n+    io.opentelemetry.context.ContextKey.named(\"country\")\n+\n+  @Shared\n+  ExecutorService otherThread\n+\n+  def setupSpec() {\n+    otherThread = Executors.newSingleThreadExecutor()\n+  }\n+\n+  def cleanupSpec() {\n+    otherThread.shutdown()\n+  }\n+\n+  def \"agent and application mix\"() {\n+    expect:\n+    def agentContext = io.opentelemetry.context.Context.current().with(COUNTRY, \"japan\")\n+    io.opentelemetry.context.Context.current().get(COUNTRY) == null\n+    agentContext.makeCurrent().withCloseable {\n+      io.opentelemetry.context.Context.current().get(COUNTRY) == \"japan\"\n+      Context.current().with(ANIMAL, \"cat\").makeCurrent().withCloseable {\n+        Context.current().get(ANIMAL) == \"cat\"\n+        io.opentelemetry.context.Context.current().get(COUNTRY) == \"japan\"\n+\n+        def agentContext2 = io.opentelemetry.context.Context.current().with(FOOD, \"cheese\")\n+        io.opentelemetry.context.Context.current().get(FOOD) == null\n+        agentContext2.makeCurrent().withCloseable {\n+          io.opentelemetry.context.Context.current().get(FOOD) == \"cheese\"\n+          io.opentelemetry.context.Context.current().get(COUNTRY) == \"japan\"\n+          Context.current().get(ANIMAL) == \"cat\"\n+        }\n+      }\n+    }\n+  }\n+\n+  // The difference between \"standard\" context interop and our bridge is that with normal interop,\n+  // keys are still isolated completely. We have special logic to share the same data for our known\n+  // types like span.\n+  def \"agent and application share span\"() {\n+    when:\n+    def applicationTracer = OpenTelemetry.getGlobalTracer(\"test\")\n+    def agentTracer = io.opentelemetry.OpenTelemetry.getGlobalTracer(\"test\")\n+\n+    then:\n+    !Span.current().spanContext.isValid()\n+    !io.opentelemetry.trace.Span.current().spanContext.isValid()\n+\n+    def applicationSpan = applicationTracer.spanBuilder(\"test1\").startSpan()\n+    applicationSpan.spanContext.isValid()\n+    applicationSpan.makeCurrent().withCloseable {\n+      Span.current().spanContext.spanIdAsHexString == applicationSpan.spanContext.spanIdAsHexString\n+      io.opentelemetry.trace.Span.current().spanContext.spanIdAsHexString == applicationSpan.spanContext.spanIdAsHexString\n+\n+      def agentSpan = agentTracer.spanBuilder(\"test2\").startSpan()\n+      agentSpan.makeCurrent().withCloseable {\n+        Span.current().spanContext.spanIdAsHexString == agentSpan.spanContext.spanIdAsHexString\n+        Span.current().spanContext.traceIdAsHexString == agentSpan.spanContext.spanIdAsHexString\n+        Span.current().spanContext.traceIdAsHexString == applicationSpan.spanContext.spanIdAsHexString\n+        io.opentelemetry.trace.Span.current().spanContext.spanIdAsHexString == agentSpan.spanContext.spanIdAsHexString\n+        io.opentelemetry.trace.Span.current().spanContext.traceIdAsHexString == agentSpan.spanContext.traceIdAsHexString\n+        io.opentelemetry.trace.Span.current().spanContext.traceIdAsHexString == applicationSpan.spanContext.traceIdAsHexString\n+\n+        def applicationSpan2 = applicationTracer.spanBuilder(\"test3\").startSpan()\n+        applicationSpan2.makeCurrent().withCloseable {\n+          Span.current().spanContext.spanIdAsHexString == applicationSpan2.spanContext.spanIdAsHexString\n+          Span.current().spanContext.traceIdAsHexString == applicationSpan2.spanContext.spanIdAsHexString\n+          Span.current().spanContext.traceIdAsHexString == applicationSpan.spanContext.spanIdAsHexString\n+          io.opentelemetry.trace.Span.current().spanContext.spanIdAsHexString == applicationSpan2.spanContext.spanIdAsHexString\n+          io.opentelemetry.trace.Span.current().spanContext.traceIdAsHexString == applicationSpan2.spanContext.traceIdAsHexString\n+          io.opentelemetry.trace.Span.current().spanContext.traceIdAsHexString == applicationSpan.spanContext.traceIdAsHexString\n+        }\n+      }\n+    }\n+  }\n+\n+  def \"agent wraps\"() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee5c35eef7c745c79e98bc28e475f8ecdaef0355"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDAxMDA4MA==", "bodyText": "Heh forgot about that. Yeah that seems like it will test it well.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1493#discussion_r514010080", "createdAt": "2020-10-29T06:18:18Z", "author": {"login": "anuraaga"}, "path": "instrumentation/opentelemetry-api-beta/src/test/groovy/ContextBridgeTest.groovy", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import application.io.opentelemetry.OpenTelemetry\n+import application.io.opentelemetry.context.Context\n+import application.io.opentelemetry.context.ContextKey\n+import application.io.opentelemetry.trace.Span\n+import io.opentelemetry.instrumentation.test.AgentTestRunner\n+import java.util.concurrent.ExecutorService\n+import java.util.concurrent.Executors\n+import java.util.concurrent.atomic.AtomicReference\n+import spock.lang.Shared\n+\n+class ContextBridgeTest extends AgentTestRunner {\n+\n+  private static final ContextKey<String> ANIMAL = ContextKey.named(\"animal\")\n+\n+  private static final io.opentelemetry.context.ContextKey<String> FOOD =\n+    io.opentelemetry.context.ContextKey.named(\"food\")\n+  private static final io.opentelemetry.context.ContextKey<String> COUNTRY =\n+    io.opentelemetry.context.ContextKey.named(\"country\")\n+\n+  @Shared\n+  ExecutorService otherThread\n+\n+  def setupSpec() {\n+    otherThread = Executors.newSingleThreadExecutor()\n+  }\n+\n+  def cleanupSpec() {\n+    otherThread.shutdown()\n+  }\n+\n+  def \"agent and application mix\"() {\n+    expect:\n+    def agentContext = io.opentelemetry.context.Context.current().with(COUNTRY, \"japan\")\n+    io.opentelemetry.context.Context.current().get(COUNTRY) == null\n+    agentContext.makeCurrent().withCloseable {\n+      io.opentelemetry.context.Context.current().get(COUNTRY) == \"japan\"\n+      Context.current().with(ANIMAL, \"cat\").makeCurrent().withCloseable {\n+        Context.current().get(ANIMAL) == \"cat\"\n+        io.opentelemetry.context.Context.current().get(COUNTRY) == \"japan\"\n+\n+        def agentContext2 = io.opentelemetry.context.Context.current().with(FOOD, \"cheese\")\n+        io.opentelemetry.context.Context.current().get(FOOD) == null\n+        agentContext2.makeCurrent().withCloseable {\n+          io.opentelemetry.context.Context.current().get(FOOD) == \"cheese\"\n+          io.opentelemetry.context.Context.current().get(COUNTRY) == \"japan\"\n+          Context.current().get(ANIMAL) == \"cat\"\n+        }\n+      }\n+    }\n+  }\n+\n+  // The difference between \"standard\" context interop and our bridge is that with normal interop,\n+  // keys are still isolated completely. We have special logic to share the same data for our known\n+  // types like span.\n+  def \"agent and application share span\"() {\n+    when:\n+    def applicationTracer = OpenTelemetry.getGlobalTracer(\"test\")\n+    def agentTracer = io.opentelemetry.OpenTelemetry.getGlobalTracer(\"test\")\n+\n+    then:\n+    !Span.current().spanContext.isValid()\n+    !io.opentelemetry.trace.Span.current().spanContext.isValid()\n+\n+    def applicationSpan = applicationTracer.spanBuilder(\"test1\").startSpan()\n+    applicationSpan.spanContext.isValid()\n+    applicationSpan.makeCurrent().withCloseable {\n+      Span.current().spanContext.spanIdAsHexString == applicationSpan.spanContext.spanIdAsHexString\n+      io.opentelemetry.trace.Span.current().spanContext.spanIdAsHexString == applicationSpan.spanContext.spanIdAsHexString\n+\n+      def agentSpan = agentTracer.spanBuilder(\"test2\").startSpan()\n+      agentSpan.makeCurrent().withCloseable {\n+        Span.current().spanContext.spanIdAsHexString == agentSpan.spanContext.spanIdAsHexString\n+        Span.current().spanContext.traceIdAsHexString == agentSpan.spanContext.spanIdAsHexString\n+        Span.current().spanContext.traceIdAsHexString == applicationSpan.spanContext.spanIdAsHexString\n+        io.opentelemetry.trace.Span.current().spanContext.spanIdAsHexString == agentSpan.spanContext.spanIdAsHexString\n+        io.opentelemetry.trace.Span.current().spanContext.traceIdAsHexString == agentSpan.spanContext.traceIdAsHexString\n+        io.opentelemetry.trace.Span.current().spanContext.traceIdAsHexString == applicationSpan.spanContext.traceIdAsHexString\n+\n+        def applicationSpan2 = applicationTracer.spanBuilder(\"test3\").startSpan()\n+        applicationSpan2.makeCurrent().withCloseable {\n+          Span.current().spanContext.spanIdAsHexString == applicationSpan2.spanContext.spanIdAsHexString\n+          Span.current().spanContext.traceIdAsHexString == applicationSpan2.spanContext.spanIdAsHexString\n+          Span.current().spanContext.traceIdAsHexString == applicationSpan.spanContext.spanIdAsHexString\n+          io.opentelemetry.trace.Span.current().spanContext.spanIdAsHexString == applicationSpan2.spanContext.spanIdAsHexString\n+          io.opentelemetry.trace.Span.current().spanContext.traceIdAsHexString == applicationSpan2.spanContext.traceIdAsHexString\n+          io.opentelemetry.trace.Span.current().spanContext.traceIdAsHexString == applicationSpan.spanContext.traceIdAsHexString\n+        }\n+      }\n+    }\n+  }\n+\n+  def \"agent wraps\"() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzk3ODUxMQ=="}, "originalCommit": {"oid": "ee5c35eef7c745c79e98bc28e475f8ecdaef0355"}, "originalPosition": 97}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4746, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}