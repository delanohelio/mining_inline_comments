{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk2ODg2NzQ3", "number": 1309, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxNjowNToyMlrOEvZAUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMDo1MTo0NFrOEyFSnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MTI4MjA4OnYy", "diffSide": "RIGHT", "path": "system-metrics/system-metrics.gradle", "isResolved": false, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxNjowNToyMlrOHkWJxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxMzoxMDoxNVrOHlrABw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg3MzczMg==", "bodyText": "3.4MB with transitive dependencies", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1309#discussion_r507873732", "createdAt": "2020-10-19T16:05:22Z", "author": {"login": "malafeev"}, "path": "system-metrics/system-metrics.gradle", "diffHunk": "@@ -0,0 +1,11 @@\n+apply from: \"$rootDir/gradle/java.gradle\"\n+apply from: \"$rootDir/gradle/publish.gradle\"\n+\n+\n+dependencies {\n+  implementation deps.opentelemetryApi\n+  implementation \"com.github.oshi:oshi-core:5.2.5\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a1888132c045349cd053eefd687c14884f5ef2f"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA2MzIyOA==", "bodyText": "An alternative to this would be to add this but:\n\nDisable it by default AND\nMake oshi a compile dependency.\n\nThis way, if users want to leverage it, they'd need to explicitly enable this instrumentation part, AND provide the Oshi dependency themselves.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1309#discussion_r508063228", "createdAt": "2020-10-19T21:08:19Z", "author": {"login": "carlosalberto"}, "path": "system-metrics/system-metrics.gradle", "diffHunk": "@@ -0,0 +1,11 @@\n+apply from: \"$rootDir/gradle/java.gradle\"\n+apply from: \"$rootDir/gradle/publish.gradle\"\n+\n+\n+dependencies {\n+  implementation deps.opentelemetryApi\n+  implementation \"com.github.oshi:oshi-core:5.2.5\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg3MzczMg=="}, "originalCommit": {"oid": "9a1888132c045349cd053eefd687c14884f5ef2f"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODEzNjQ1NA==", "bodyText": "I think it's a good idea to make oshi a compile dependency. How about we model this change exactly like any instrumentation, instrumentation/oshi/{library,javaagent} for example. This code goes in library, giving user a manual way of instrumenting (calling the static method) similar to our other library instrumentations, and auto can call it automatically if oshi is found on the classpath (not sure if we have a pattern for this yet but figure it's possible right @trask?). We can start with just moving this into library and add javaagent later.\nFor reference, https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/master/instrumentation/grpc-1.5/library/grpc-1.5-library.gradle", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1309#discussion_r508136454", "createdAt": "2020-10-20T00:23:43Z", "author": {"login": "anuraaga"}, "path": "system-metrics/system-metrics.gradle", "diffHunk": "@@ -0,0 +1,11 @@\n+apply from: \"$rootDir/gradle/java.gradle\"\n+apply from: \"$rootDir/gradle/publish.gradle\"\n+\n+\n+dependencies {\n+  implementation deps.opentelemetryApi\n+  implementation \"com.github.oshi:oshi-core:5.2.5\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg3MzczMg=="}, "originalCommit": {"oid": "9a1888132c045349cd053eefd687c14884f5ef2f"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODEzNjYwMg==", "bodyText": "In which case we should split out the JVM metrics into a separate instrumentation/jvm/library too", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1309#discussion_r508136602", "createdAt": "2020-10-20T00:24:16Z", "author": {"login": "anuraaga"}, "path": "system-metrics/system-metrics.gradle", "diffHunk": "@@ -0,0 +1,11 @@\n+apply from: \"$rootDir/gradle/java.gradle\"\n+apply from: \"$rootDir/gradle/publish.gradle\"\n+\n+\n+dependencies {\n+  implementation deps.opentelemetryApi\n+  implementation \"com.github.oshi:oshi-core:5.2.5\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg3MzczMg=="}, "originalCommit": {"oid": "9a1888132c045349cd053eefd687c14884f5ef2f"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU3NDgyMQ==", "bodyText": "This code goes in library, giving user a manual way of instrumenting (calling the static method) similar to our other library instrumentations\n\nSounds good to me.\n\nIn which case we should split out the JVM metrics into a separate instrumentation/jvm/library too\n\nSame.\n@malafeev any opinion on this? ;)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1309#discussion_r508574821", "createdAt": "2020-10-20T14:48:40Z", "author": {"login": "carlosalberto"}, "path": "system-metrics/system-metrics.gradle", "diffHunk": "@@ -0,0 +1,11 @@\n+apply from: \"$rootDir/gradle/java.gradle\"\n+apply from: \"$rootDir/gradle/publish.gradle\"\n+\n+\n+dependencies {\n+  implementation deps.opentelemetryApi\n+  implementation \"com.github.oshi:oshi-core:5.2.5\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg3MzczMg=="}, "originalCommit": {"oid": "9a1888132c045349cd053eefd687c14884f5ef2f"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU5NzA0Mg==", "bodyText": "I'm fine with it. any other opinions?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1309#discussion_r508597042", "createdAt": "2020-10-20T15:15:41Z", "author": {"login": "malafeev"}, "path": "system-metrics/system-metrics.gradle", "diffHunk": "@@ -0,0 +1,11 @@\n+apply from: \"$rootDir/gradle/java.gradle\"\n+apply from: \"$rootDir/gradle/publish.gradle\"\n+\n+\n+dependencies {\n+  implementation deps.opentelemetryApi\n+  implementation \"com.github.oshi:oshi-core:5.2.5\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg3MzczMg=="}, "originalCommit": {"oid": "9a1888132c045349cd053eefd687c14884f5ef2f"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAwODY3Mw==", "bodyText": "I like the idea of adding just library instrumentation in the first PR, and then work on how to integrate it into javaagent after that", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1309#discussion_r509008673", "createdAt": "2020-10-21T06:00:04Z", "author": {"login": "trask"}, "path": "system-metrics/system-metrics.gradle", "diffHunk": "@@ -0,0 +1,11 @@\n+apply from: \"$rootDir/gradle/java.gradle\"\n+apply from: \"$rootDir/gradle/publish.gradle\"\n+\n+\n+dependencies {\n+  implementation deps.opentelemetryApi\n+  implementation \"com.github.oshi:oshi-core:5.2.5\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg3MzczMg=="}, "originalCommit": {"oid": "9a1888132c045349cd053eefd687c14884f5ef2f"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTI2Mzg3OQ==", "bodyText": "I moved code to instrumentation/oshi/library because both jvm and system metrics depend on oshi", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1309#discussion_r509263879", "createdAt": "2020-10-21T13:10:15Z", "author": {"login": "malafeev"}, "path": "system-metrics/system-metrics.gradle", "diffHunk": "@@ -0,0 +1,11 @@\n+apply from: \"$rootDir/gradle/java.gradle\"\n+apply from: \"$rootDir/gradle/publish.gradle\"\n+\n+\n+dependencies {\n+  implementation deps.opentelemetryApi\n+  implementation \"com.github.oshi:oshi-core:5.2.5\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg3MzczMg=="}, "originalCommit": {"oid": "9a1888132c045349cd053eefd687c14884f5ef2f"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwOTUwNTEyOnYy", "diffSide": "RIGHT", "path": "instrumentation/oshi/library/src/main/java/io/opentelemetry/instrumentation/oshi/JavaMetrics.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMDo1MDozOFrOHoh2Dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QwMjozOToyMFrOHopU_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI1OTU5OQ==", "bodyText": "maybe rename to ProcessMetrics to make clear these are not just standard Java-provided metrics?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1309#discussion_r512259599", "createdAt": "2020-10-26T20:50:38Z", "author": {"login": "trask"}, "path": "instrumentation/oshi/library/src/main/java/io/opentelemetry/instrumentation/oshi/JavaMetrics.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.oshi;\n+\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.common.Labels;\n+import io.opentelemetry.metrics.AsynchronousInstrument.Callback;\n+import io.opentelemetry.metrics.AsynchronousInstrument.DoubleResult;\n+import io.opentelemetry.metrics.AsynchronousInstrument.LongResult;\n+import io.opentelemetry.metrics.Meter;\n+import java.lang.management.GarbageCollectorMXBean;\n+import java.lang.management.ManagementFactory;\n+import oshi.SystemInfo;\n+import oshi.software.os.OSProcess;\n+import oshi.software.os.OperatingSystem;\n+\n+/** Java Runtime Metrics Utility */\n+public class JavaMetrics {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e520f46e75b1ec50e8c90b21f2841c1e021a942"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjM4MjIwNg==", "bodyText": "renamed", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1309#discussion_r512382206", "createdAt": "2020-10-27T02:39:20Z", "author": {"login": "malafeev"}, "path": "instrumentation/oshi/library/src/main/java/io/opentelemetry/instrumentation/oshi/JavaMetrics.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.oshi;\n+\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.common.Labels;\n+import io.opentelemetry.metrics.AsynchronousInstrument.Callback;\n+import io.opentelemetry.metrics.AsynchronousInstrument.DoubleResult;\n+import io.opentelemetry.metrics.AsynchronousInstrument.LongResult;\n+import io.opentelemetry.metrics.Meter;\n+import java.lang.management.GarbageCollectorMXBean;\n+import java.lang.management.ManagementFactory;\n+import oshi.SystemInfo;\n+import oshi.software.os.OSProcess;\n+import oshi.software.os.OperatingSystem;\n+\n+/** Java Runtime Metrics Utility */\n+public class JavaMetrics {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI1OTU5OQ=="}, "originalCommit": {"oid": "5e520f46e75b1ec50e8c90b21f2841c1e021a942"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwOTUwOTQxOnYy", "diffSide": "RIGHT", "path": "instrumentation/oshi/library/src/main/java/io/opentelemetry/instrumentation/oshi/JavaMetrics.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMDo1MTo0NFrOHoh4qA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QwMjo1MzoyOVrOHopkBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2MDI2NA==", "bodyText": "can this be part of the other (future) module that only depends on JVM-provided metrics?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1309#discussion_r512260264", "createdAt": "2020-10-26T20:51:44Z", "author": {"login": "trask"}, "path": "instrumentation/oshi/library/src/main/java/io/opentelemetry/instrumentation/oshi/JavaMetrics.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.oshi;\n+\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.common.Labels;\n+import io.opentelemetry.metrics.AsynchronousInstrument.Callback;\n+import io.opentelemetry.metrics.AsynchronousInstrument.DoubleResult;\n+import io.opentelemetry.metrics.AsynchronousInstrument.LongResult;\n+import io.opentelemetry.metrics.Meter;\n+import java.lang.management.GarbageCollectorMXBean;\n+import java.lang.management.ManagementFactory;\n+import oshi.SystemInfo;\n+import oshi.software.os.OSProcess;\n+import oshi.software.os.OperatingSystem;\n+\n+/** Java Runtime Metrics Utility */\n+public class JavaMetrics {\n+  private static final String TYPE_LABEL_KEY = \"type\";\n+\n+  private JavaMetrics() {}\n+\n+  /** Register observers for java runtime metrics */\n+  public static void registerObservers() {\n+    Meter meter = OpenTelemetry.getMeterProvider().get(JavaMetrics.class.getName());\n+    SystemInfo systemInfo = new SystemInfo();\n+    OperatingSystem osInfo = systemInfo.getOperatingSystem();\n+    OSProcess processInfo = osInfo.getProcess(osInfo.getProcessId());\n+\n+    meter\n+        .longUpDownSumObserverBuilder(\"runtime.java.memory\")\n+        .setDescription(\"Runtime Java memory\")\n+        .setUnit(\"bytes\")\n+        .build()\n+        .setCallback(\n+            new Callback<LongResult>() {\n+              @Override\n+              public void update(LongResult r) {\n+                processInfo.updateAttributes();\n+                r.observe(processInfo.getResidentSetSize(), Labels.of(TYPE_LABEL_KEY, \"rss\"));\n+                r.observe(processInfo.getVirtualSize(), Labels.of(TYPE_LABEL_KEY, \"vms\"));\n+              }\n+            });\n+\n+    meter\n+        .doubleValueObserverBuilder(\"runtime.java.cpu_time\")\n+        .setDescription(\"Runtime Java CPU time\")\n+        .setUnit(\"seconds\")\n+        .build()\n+        .setCallback(\n+            new Callback<DoubleResult>() {\n+              @Override\n+              public void update(DoubleResult r) {\n+                processInfo.updateAttributes();\n+                r.observe(processInfo.getUserTime() * 1000, Labels.of(TYPE_LABEL_KEY, \"user\"));\n+                r.observe(processInfo.getKernelTime() * 1000, Labels.of(TYPE_LABEL_KEY, \"system\"));\n+              }\n+            });\n+\n+    meter\n+        .longValueObserverBuilder(\"runtime.java.gc_count\")\n+        .setDescription(\"Runtime Java GC count\")\n+        .setUnit(\"counts\")\n+        .build()\n+        .setCallback(\n+            new Callback<LongResult>() {\n+              @Override\n+              public void update(LongResult r) {\n+                long gcCount = 0;\n+                for (final GarbageCollectorMXBean gcBean :\n+                    ManagementFactory.getGarbageCollectorMXBeans()) {\n+                  gcCount += gcBean.getCollectionCount();\n+                }\n+\n+                r.observe(gcCount, Labels.of(TYPE_LABEL_KEY, \"count\"));\n+              }\n+            });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e520f46e75b1ec50e8c90b21f2841c1e021a942"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjM4MTYzOQ==", "bodyText": "It depends on oshi.\nIf I will move it to separate module it will have the same dependency on oshi as system metrics.\nActivation will be the same: presence of oshi dependency.\nTherefore I doubt to split it to two modules.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1309#discussion_r512381639", "createdAt": "2020-10-27T02:37:13Z", "author": {"login": "malafeev"}, "path": "instrumentation/oshi/library/src/main/java/io/opentelemetry/instrumentation/oshi/JavaMetrics.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.oshi;\n+\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.common.Labels;\n+import io.opentelemetry.metrics.AsynchronousInstrument.Callback;\n+import io.opentelemetry.metrics.AsynchronousInstrument.DoubleResult;\n+import io.opentelemetry.metrics.AsynchronousInstrument.LongResult;\n+import io.opentelemetry.metrics.Meter;\n+import java.lang.management.GarbageCollectorMXBean;\n+import java.lang.management.ManagementFactory;\n+import oshi.SystemInfo;\n+import oshi.software.os.OSProcess;\n+import oshi.software.os.OperatingSystem;\n+\n+/** Java Runtime Metrics Utility */\n+public class JavaMetrics {\n+  private static final String TYPE_LABEL_KEY = \"type\";\n+\n+  private JavaMetrics() {}\n+\n+  /** Register observers for java runtime metrics */\n+  public static void registerObservers() {\n+    Meter meter = OpenTelemetry.getMeterProvider().get(JavaMetrics.class.getName());\n+    SystemInfo systemInfo = new SystemInfo();\n+    OperatingSystem osInfo = systemInfo.getOperatingSystem();\n+    OSProcess processInfo = osInfo.getProcess(osInfo.getProcessId());\n+\n+    meter\n+        .longUpDownSumObserverBuilder(\"runtime.java.memory\")\n+        .setDescription(\"Runtime Java memory\")\n+        .setUnit(\"bytes\")\n+        .build()\n+        .setCallback(\n+            new Callback<LongResult>() {\n+              @Override\n+              public void update(LongResult r) {\n+                processInfo.updateAttributes();\n+                r.observe(processInfo.getResidentSetSize(), Labels.of(TYPE_LABEL_KEY, \"rss\"));\n+                r.observe(processInfo.getVirtualSize(), Labels.of(TYPE_LABEL_KEY, \"vms\"));\n+              }\n+            });\n+\n+    meter\n+        .doubleValueObserverBuilder(\"runtime.java.cpu_time\")\n+        .setDescription(\"Runtime Java CPU time\")\n+        .setUnit(\"seconds\")\n+        .build()\n+        .setCallback(\n+            new Callback<DoubleResult>() {\n+              @Override\n+              public void update(DoubleResult r) {\n+                processInfo.updateAttributes();\n+                r.observe(processInfo.getUserTime() * 1000, Labels.of(TYPE_LABEL_KEY, \"user\"));\n+                r.observe(processInfo.getKernelTime() * 1000, Labels.of(TYPE_LABEL_KEY, \"system\"));\n+              }\n+            });\n+\n+    meter\n+        .longValueObserverBuilder(\"runtime.java.gc_count\")\n+        .setDescription(\"Runtime Java GC count\")\n+        .setUnit(\"counts\")\n+        .build()\n+        .setCallback(\n+            new Callback<LongResult>() {\n+              @Override\n+              public void update(LongResult r) {\n+                long gcCount = 0;\n+                for (final GarbageCollectorMXBean gcBean :\n+                    ManagementFactory.getGarbageCollectorMXBeans()) {\n+                  gcCount += gcBean.getCollectionCount();\n+                }\n+\n+                r.observe(gcCount, Labels.of(TYPE_LABEL_KEY, \"count\"));\n+              }\n+            });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2MDI2NA=="}, "originalCommit": {"oid": "5e520f46e75b1ec50e8c90b21f2841c1e021a942"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjM4MjU4NA==", "bodyText": "runtime.java.gc_count metric has dependency on oshi?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1309#discussion_r512382584", "createdAt": "2020-10-27T02:40:28Z", "author": {"login": "trask"}, "path": "instrumentation/oshi/library/src/main/java/io/opentelemetry/instrumentation/oshi/JavaMetrics.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.oshi;\n+\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.common.Labels;\n+import io.opentelemetry.metrics.AsynchronousInstrument.Callback;\n+import io.opentelemetry.metrics.AsynchronousInstrument.DoubleResult;\n+import io.opentelemetry.metrics.AsynchronousInstrument.LongResult;\n+import io.opentelemetry.metrics.Meter;\n+import java.lang.management.GarbageCollectorMXBean;\n+import java.lang.management.ManagementFactory;\n+import oshi.SystemInfo;\n+import oshi.software.os.OSProcess;\n+import oshi.software.os.OperatingSystem;\n+\n+/** Java Runtime Metrics Utility */\n+public class JavaMetrics {\n+  private static final String TYPE_LABEL_KEY = \"type\";\n+\n+  private JavaMetrics() {}\n+\n+  /** Register observers for java runtime metrics */\n+  public static void registerObservers() {\n+    Meter meter = OpenTelemetry.getMeterProvider().get(JavaMetrics.class.getName());\n+    SystemInfo systemInfo = new SystemInfo();\n+    OperatingSystem osInfo = systemInfo.getOperatingSystem();\n+    OSProcess processInfo = osInfo.getProcess(osInfo.getProcessId());\n+\n+    meter\n+        .longUpDownSumObserverBuilder(\"runtime.java.memory\")\n+        .setDescription(\"Runtime Java memory\")\n+        .setUnit(\"bytes\")\n+        .build()\n+        .setCallback(\n+            new Callback<LongResult>() {\n+              @Override\n+              public void update(LongResult r) {\n+                processInfo.updateAttributes();\n+                r.observe(processInfo.getResidentSetSize(), Labels.of(TYPE_LABEL_KEY, \"rss\"));\n+                r.observe(processInfo.getVirtualSize(), Labels.of(TYPE_LABEL_KEY, \"vms\"));\n+              }\n+            });\n+\n+    meter\n+        .doubleValueObserverBuilder(\"runtime.java.cpu_time\")\n+        .setDescription(\"Runtime Java CPU time\")\n+        .setUnit(\"seconds\")\n+        .build()\n+        .setCallback(\n+            new Callback<DoubleResult>() {\n+              @Override\n+              public void update(DoubleResult r) {\n+                processInfo.updateAttributes();\n+                r.observe(processInfo.getUserTime() * 1000, Labels.of(TYPE_LABEL_KEY, \"user\"));\n+                r.observe(processInfo.getKernelTime() * 1000, Labels.of(TYPE_LABEL_KEY, \"system\"));\n+              }\n+            });\n+\n+    meter\n+        .longValueObserverBuilder(\"runtime.java.gc_count\")\n+        .setDescription(\"Runtime Java GC count\")\n+        .setUnit(\"counts\")\n+        .build()\n+        .setCallback(\n+            new Callback<LongResult>() {\n+              @Override\n+              public void update(LongResult r) {\n+                long gcCount = 0;\n+                for (final GarbageCollectorMXBean gcBean :\n+                    ManagementFactory.getGarbageCollectorMXBeans()) {\n+                  gcCount += gcBean.getCollectionCount();\n+                }\n+\n+                r.observe(gcCount, Labels.of(TYPE_LABEL_KEY, \"count\"));\n+              }\n+            });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2MDI2NA=="}, "originalCommit": {"oid": "5e520f46e75b1ec50e8c90b21f2841c1e021a942"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjM4MzA3OA==", "bodyText": "oh, you mean only this specific metric, I thought you are talking about all jvm metrics here.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1309#discussion_r512383078", "createdAt": "2020-10-27T02:42:09Z", "author": {"login": "malafeev"}, "path": "instrumentation/oshi/library/src/main/java/io/opentelemetry/instrumentation/oshi/JavaMetrics.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.oshi;\n+\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.common.Labels;\n+import io.opentelemetry.metrics.AsynchronousInstrument.Callback;\n+import io.opentelemetry.metrics.AsynchronousInstrument.DoubleResult;\n+import io.opentelemetry.metrics.AsynchronousInstrument.LongResult;\n+import io.opentelemetry.metrics.Meter;\n+import java.lang.management.GarbageCollectorMXBean;\n+import java.lang.management.ManagementFactory;\n+import oshi.SystemInfo;\n+import oshi.software.os.OSProcess;\n+import oshi.software.os.OperatingSystem;\n+\n+/** Java Runtime Metrics Utility */\n+public class JavaMetrics {\n+  private static final String TYPE_LABEL_KEY = \"type\";\n+\n+  private JavaMetrics() {}\n+\n+  /** Register observers for java runtime metrics */\n+  public static void registerObservers() {\n+    Meter meter = OpenTelemetry.getMeterProvider().get(JavaMetrics.class.getName());\n+    SystemInfo systemInfo = new SystemInfo();\n+    OperatingSystem osInfo = systemInfo.getOperatingSystem();\n+    OSProcess processInfo = osInfo.getProcess(osInfo.getProcessId());\n+\n+    meter\n+        .longUpDownSumObserverBuilder(\"runtime.java.memory\")\n+        .setDescription(\"Runtime Java memory\")\n+        .setUnit(\"bytes\")\n+        .build()\n+        .setCallback(\n+            new Callback<LongResult>() {\n+              @Override\n+              public void update(LongResult r) {\n+                processInfo.updateAttributes();\n+                r.observe(processInfo.getResidentSetSize(), Labels.of(TYPE_LABEL_KEY, \"rss\"));\n+                r.observe(processInfo.getVirtualSize(), Labels.of(TYPE_LABEL_KEY, \"vms\"));\n+              }\n+            });\n+\n+    meter\n+        .doubleValueObserverBuilder(\"runtime.java.cpu_time\")\n+        .setDescription(\"Runtime Java CPU time\")\n+        .setUnit(\"seconds\")\n+        .build()\n+        .setCallback(\n+            new Callback<DoubleResult>() {\n+              @Override\n+              public void update(DoubleResult r) {\n+                processInfo.updateAttributes();\n+                r.observe(processInfo.getUserTime() * 1000, Labels.of(TYPE_LABEL_KEY, \"user\"));\n+                r.observe(processInfo.getKernelTime() * 1000, Labels.of(TYPE_LABEL_KEY, \"system\"));\n+              }\n+            });\n+\n+    meter\n+        .longValueObserverBuilder(\"runtime.java.gc_count\")\n+        .setDescription(\"Runtime Java GC count\")\n+        .setUnit(\"counts\")\n+        .build()\n+        .setCallback(\n+            new Callback<LongResult>() {\n+              @Override\n+              public void update(LongResult r) {\n+                long gcCount = 0;\n+                for (final GarbageCollectorMXBean gcBean :\n+                    ManagementFactory.getGarbageCollectorMXBeans()) {\n+                  gcCount += gcBean.getCollectionCount();\n+                }\n+\n+                r.observe(gcCount, Labels.of(TYPE_LABEL_KEY, \"count\"));\n+              }\n+            });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2MDI2NA=="}, "originalCommit": {"oid": "5e520f46e75b1ec50e8c90b21f2841c1e021a942"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjM4MzYzNQ==", "bodyText": "I can create separate instrumentation/jvm/libarary with only this metric.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1309#discussion_r512383635", "createdAt": "2020-10-27T02:44:28Z", "author": {"login": "malafeev"}, "path": "instrumentation/oshi/library/src/main/java/io/opentelemetry/instrumentation/oshi/JavaMetrics.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.oshi;\n+\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.common.Labels;\n+import io.opentelemetry.metrics.AsynchronousInstrument.Callback;\n+import io.opentelemetry.metrics.AsynchronousInstrument.DoubleResult;\n+import io.opentelemetry.metrics.AsynchronousInstrument.LongResult;\n+import io.opentelemetry.metrics.Meter;\n+import java.lang.management.GarbageCollectorMXBean;\n+import java.lang.management.ManagementFactory;\n+import oshi.SystemInfo;\n+import oshi.software.os.OSProcess;\n+import oshi.software.os.OperatingSystem;\n+\n+/** Java Runtime Metrics Utility */\n+public class JavaMetrics {\n+  private static final String TYPE_LABEL_KEY = \"type\";\n+\n+  private JavaMetrics() {}\n+\n+  /** Register observers for java runtime metrics */\n+  public static void registerObservers() {\n+    Meter meter = OpenTelemetry.getMeterProvider().get(JavaMetrics.class.getName());\n+    SystemInfo systemInfo = new SystemInfo();\n+    OperatingSystem osInfo = systemInfo.getOperatingSystem();\n+    OSProcess processInfo = osInfo.getProcess(osInfo.getProcessId());\n+\n+    meter\n+        .longUpDownSumObserverBuilder(\"runtime.java.memory\")\n+        .setDescription(\"Runtime Java memory\")\n+        .setUnit(\"bytes\")\n+        .build()\n+        .setCallback(\n+            new Callback<LongResult>() {\n+              @Override\n+              public void update(LongResult r) {\n+                processInfo.updateAttributes();\n+                r.observe(processInfo.getResidentSetSize(), Labels.of(TYPE_LABEL_KEY, \"rss\"));\n+                r.observe(processInfo.getVirtualSize(), Labels.of(TYPE_LABEL_KEY, \"vms\"));\n+              }\n+            });\n+\n+    meter\n+        .doubleValueObserverBuilder(\"runtime.java.cpu_time\")\n+        .setDescription(\"Runtime Java CPU time\")\n+        .setUnit(\"seconds\")\n+        .build()\n+        .setCallback(\n+            new Callback<DoubleResult>() {\n+              @Override\n+              public void update(DoubleResult r) {\n+                processInfo.updateAttributes();\n+                r.observe(processInfo.getUserTime() * 1000, Labels.of(TYPE_LABEL_KEY, \"user\"));\n+                r.observe(processInfo.getKernelTime() * 1000, Labels.of(TYPE_LABEL_KEY, \"system\"));\n+              }\n+            });\n+\n+    meter\n+        .longValueObserverBuilder(\"runtime.java.gc_count\")\n+        .setDescription(\"Runtime Java GC count\")\n+        .setUnit(\"counts\")\n+        .build()\n+        .setCallback(\n+            new Callback<LongResult>() {\n+              @Override\n+              public void update(LongResult r) {\n+                long gcCount = 0;\n+                for (final GarbageCollectorMXBean gcBean :\n+                    ManagementFactory.getGarbageCollectorMXBeans()) {\n+                  gcCount += gcBean.getCollectionCount();\n+                }\n+\n+                r.observe(gcCount, Labels.of(TYPE_LABEL_KEY, \"count\"));\n+              }\n+            });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2MDI2NA=="}, "originalCommit": {"oid": "5e520f46e75b1ec50e8c90b21f2841c1e021a942"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjM4NTExNg==", "bodyText": "\ud83d\udc4d how about removing runtime.java.gc_count from this PR and then we'll merge this (sorry again it took so long!), and u can send separate PR with instrumentation/jvm/library?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1309#discussion_r512385116", "createdAt": "2020-10-27T02:49:49Z", "author": {"login": "trask"}, "path": "instrumentation/oshi/library/src/main/java/io/opentelemetry/instrumentation/oshi/JavaMetrics.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.oshi;\n+\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.common.Labels;\n+import io.opentelemetry.metrics.AsynchronousInstrument.Callback;\n+import io.opentelemetry.metrics.AsynchronousInstrument.DoubleResult;\n+import io.opentelemetry.metrics.AsynchronousInstrument.LongResult;\n+import io.opentelemetry.metrics.Meter;\n+import java.lang.management.GarbageCollectorMXBean;\n+import java.lang.management.ManagementFactory;\n+import oshi.SystemInfo;\n+import oshi.software.os.OSProcess;\n+import oshi.software.os.OperatingSystem;\n+\n+/** Java Runtime Metrics Utility */\n+public class JavaMetrics {\n+  private static final String TYPE_LABEL_KEY = \"type\";\n+\n+  private JavaMetrics() {}\n+\n+  /** Register observers for java runtime metrics */\n+  public static void registerObservers() {\n+    Meter meter = OpenTelemetry.getMeterProvider().get(JavaMetrics.class.getName());\n+    SystemInfo systemInfo = new SystemInfo();\n+    OperatingSystem osInfo = systemInfo.getOperatingSystem();\n+    OSProcess processInfo = osInfo.getProcess(osInfo.getProcessId());\n+\n+    meter\n+        .longUpDownSumObserverBuilder(\"runtime.java.memory\")\n+        .setDescription(\"Runtime Java memory\")\n+        .setUnit(\"bytes\")\n+        .build()\n+        .setCallback(\n+            new Callback<LongResult>() {\n+              @Override\n+              public void update(LongResult r) {\n+                processInfo.updateAttributes();\n+                r.observe(processInfo.getResidentSetSize(), Labels.of(TYPE_LABEL_KEY, \"rss\"));\n+                r.observe(processInfo.getVirtualSize(), Labels.of(TYPE_LABEL_KEY, \"vms\"));\n+              }\n+            });\n+\n+    meter\n+        .doubleValueObserverBuilder(\"runtime.java.cpu_time\")\n+        .setDescription(\"Runtime Java CPU time\")\n+        .setUnit(\"seconds\")\n+        .build()\n+        .setCallback(\n+            new Callback<DoubleResult>() {\n+              @Override\n+              public void update(DoubleResult r) {\n+                processInfo.updateAttributes();\n+                r.observe(processInfo.getUserTime() * 1000, Labels.of(TYPE_LABEL_KEY, \"user\"));\n+                r.observe(processInfo.getKernelTime() * 1000, Labels.of(TYPE_LABEL_KEY, \"system\"));\n+              }\n+            });\n+\n+    meter\n+        .longValueObserverBuilder(\"runtime.java.gc_count\")\n+        .setDescription(\"Runtime Java GC count\")\n+        .setUnit(\"counts\")\n+        .build()\n+        .setCallback(\n+            new Callback<LongResult>() {\n+              @Override\n+              public void update(LongResult r) {\n+                long gcCount = 0;\n+                for (final GarbageCollectorMXBean gcBean :\n+                    ManagementFactory.getGarbageCollectorMXBeans()) {\n+                  gcCount += gcBean.getCollectionCount();\n+                }\n+\n+                r.observe(gcCount, Labels.of(TYPE_LABEL_KEY, \"count\"));\n+              }\n+            });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2MDI2NA=="}, "originalCommit": {"oid": "5e520f46e75b1ec50e8c90b21f2841c1e021a942"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjM4NjA1NA==", "bodyText": "removed", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1309#discussion_r512386054", "createdAt": "2020-10-27T02:53:29Z", "author": {"login": "malafeev"}, "path": "instrumentation/oshi/library/src/main/java/io/opentelemetry/instrumentation/oshi/JavaMetrics.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.oshi;\n+\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.common.Labels;\n+import io.opentelemetry.metrics.AsynchronousInstrument.Callback;\n+import io.opentelemetry.metrics.AsynchronousInstrument.DoubleResult;\n+import io.opentelemetry.metrics.AsynchronousInstrument.LongResult;\n+import io.opentelemetry.metrics.Meter;\n+import java.lang.management.GarbageCollectorMXBean;\n+import java.lang.management.ManagementFactory;\n+import oshi.SystemInfo;\n+import oshi.software.os.OSProcess;\n+import oshi.software.os.OperatingSystem;\n+\n+/** Java Runtime Metrics Utility */\n+public class JavaMetrics {\n+  private static final String TYPE_LABEL_KEY = \"type\";\n+\n+  private JavaMetrics() {}\n+\n+  /** Register observers for java runtime metrics */\n+  public static void registerObservers() {\n+    Meter meter = OpenTelemetry.getMeterProvider().get(JavaMetrics.class.getName());\n+    SystemInfo systemInfo = new SystemInfo();\n+    OperatingSystem osInfo = systemInfo.getOperatingSystem();\n+    OSProcess processInfo = osInfo.getProcess(osInfo.getProcessId());\n+\n+    meter\n+        .longUpDownSumObserverBuilder(\"runtime.java.memory\")\n+        .setDescription(\"Runtime Java memory\")\n+        .setUnit(\"bytes\")\n+        .build()\n+        .setCallback(\n+            new Callback<LongResult>() {\n+              @Override\n+              public void update(LongResult r) {\n+                processInfo.updateAttributes();\n+                r.observe(processInfo.getResidentSetSize(), Labels.of(TYPE_LABEL_KEY, \"rss\"));\n+                r.observe(processInfo.getVirtualSize(), Labels.of(TYPE_LABEL_KEY, \"vms\"));\n+              }\n+            });\n+\n+    meter\n+        .doubleValueObserverBuilder(\"runtime.java.cpu_time\")\n+        .setDescription(\"Runtime Java CPU time\")\n+        .setUnit(\"seconds\")\n+        .build()\n+        .setCallback(\n+            new Callback<DoubleResult>() {\n+              @Override\n+              public void update(DoubleResult r) {\n+                processInfo.updateAttributes();\n+                r.observe(processInfo.getUserTime() * 1000, Labels.of(TYPE_LABEL_KEY, \"user\"));\n+                r.observe(processInfo.getKernelTime() * 1000, Labels.of(TYPE_LABEL_KEY, \"system\"));\n+              }\n+            });\n+\n+    meter\n+        .longValueObserverBuilder(\"runtime.java.gc_count\")\n+        .setDescription(\"Runtime Java GC count\")\n+        .setUnit(\"counts\")\n+        .build()\n+        .setCallback(\n+            new Callback<LongResult>() {\n+              @Override\n+              public void update(LongResult r) {\n+                long gcCount = 0;\n+                for (final GarbageCollectorMXBean gcBean :\n+                    ManagementFactory.getGarbageCollectorMXBeans()) {\n+                  gcCount += gcBean.getCollectionCount();\n+                }\n+\n+                r.observe(gcCount, Labels.of(TYPE_LABEL_KEY, \"count\"));\n+              }\n+            });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2MDI2NA=="}, "originalCommit": {"oid": "5e520f46e75b1ec50e8c90b21f2841c1e021a942"}, "originalPosition": 80}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4789, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}