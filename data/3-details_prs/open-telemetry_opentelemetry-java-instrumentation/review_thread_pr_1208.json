{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg3NDUxNDgx", "number": 1208, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxNzozODowMlrOEjsz4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNDo0NToxNlrOEj4oLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1ODY5Nzk1OnYy", "diffSide": "RIGHT", "path": "instrumentation/logback/logback-1.0.0/auto/src/main/java/io/opentelemetry/instrumentation/auto/logback/v1_0_0/LoggingEventInstrumentation.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxNzozODowMlrOHSM9KA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxNzozODowMlrOHSM9KA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg0ODY4MA==", "bodyText": "I'll replace \"traceId\" and others either here or in #1200 - depending on which one gets merged first.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1208#discussion_r488848680", "createdAt": "2020-09-15T17:38:02Z", "author": {"login": "mateuszrzeszutek"}, "path": "instrumentation/logback/logback-1.0.0/auto/src/main/java/io/opentelemetry/instrumentation/auto/logback/v1_0_0/LoggingEventInstrumentation.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.logback.v1_0_0;\n+\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.implementsInterface;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import ch.qos.logback.classic.spi.ILoggingEvent;\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.instrumentation.auto.api.InstrumentationContext;\n+import io.opentelemetry.instrumentation.logback.v1_0_0.UnionMap;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.implementation.bytecode.assign.Assigner.Typing;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class LoggingEventInstrumentation extends Instrumenter.Default {\n+  public LoggingEventInstrumentation() {\n+    super(\"logback\");\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      \"io.opentelemetry.instrumentation.logback.v1_0_0.UnionMap\",\n+      \"io.opentelemetry.instrumentation.logback.v1_0_0.UnionMap$ConcatenatedSet\",\n+      \"io.opentelemetry.instrumentation.logback.v1_0_0.UnionMap$ConcatenatedSet$ConcatenatedSetIterator\"\n+    };\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return implementsInterface(named(\"ch.qos.logback.classic.spi.ILoggingEvent\"));\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"ch.qos.logback.classic.spi.ILoggingEvent\", Span.class.getName());\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(\n+        isMethod()\n+            .and(isPublic())\n+            .and(named(\"getMDCPropertyMap\").or(named(\"getMdc\")))\n+            .and(takesArguments(0)),\n+        LoggingEventInstrumentation.class.getName() + \"$GetMdcAdvice\");\n+  }\n+\n+  public static class GetMdcAdvice {\n+    @Advice.OnMethodExit(suppress = Throwable.class)\n+    public static void onExit(\n+        @Advice.This ILoggingEvent event,\n+        @Advice.Return(typing = Typing.DYNAMIC, readOnly = false) Map<String, String> contextData) {\n+      if (contextData != null && contextData.containsKey(\"traceId\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae73a1b81b32b102d0d1e43e17fd3b45b0716255"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MDQ0NTIyOnYy", "diffSide": "RIGHT", "path": "instrumentation/logback/logback-1.0.0/auto/src/main/java/io/opentelemetry/instrumentation/auto/logback/v1_0_0/LoggingEventInstrumentation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwMjo1NToxMlrOHSeL9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwODoxOToxNlrOHSlkJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEzMDk5Nw==", "bodyText": "I think this:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (currentSpan != null && !currentSpan.getContext().isValid()) {\n          \n          \n            \n                  if (currentSpan == null || !currentSpan.getContext().isValid()) {", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1208#discussion_r489130997", "createdAt": "2020-09-16T02:55:12Z", "author": {"login": "trask"}, "path": "instrumentation/logback/logback-1.0.0/auto/src/main/java/io/opentelemetry/instrumentation/auto/logback/v1_0_0/LoggingEventInstrumentation.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.logback.v1_0_0;\n+\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.implementsInterface;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import ch.qos.logback.classic.spi.ILoggingEvent;\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.instrumentation.auto.api.InstrumentationContext;\n+import io.opentelemetry.instrumentation.logback.v1_0_0.UnionMap;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.implementation.bytecode.assign.Assigner.Typing;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class LoggingEventInstrumentation extends Instrumenter.Default {\n+  public LoggingEventInstrumentation() {\n+    super(\"logback\");\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      \"io.opentelemetry.instrumentation.logback.v1_0_0.UnionMap\",\n+      \"io.opentelemetry.instrumentation.logback.v1_0_0.UnionMap$ConcatenatedSet\",\n+      \"io.opentelemetry.instrumentation.logback.v1_0_0.UnionMap$ConcatenatedSet$ConcatenatedSetIterator\"\n+    };\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return implementsInterface(named(\"ch.qos.logback.classic.spi.ILoggingEvent\"));\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"ch.qos.logback.classic.spi.ILoggingEvent\", Span.class.getName());\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(\n+        isMethod()\n+            .and(isPublic())\n+            .and(named(\"getMDCPropertyMap\").or(named(\"getMdc\")))\n+            .and(takesArguments(0)),\n+        LoggingEventInstrumentation.class.getName() + \"$GetMdcAdvice\");\n+  }\n+\n+  public static class GetMdcAdvice {\n+    @Advice.OnMethodExit(suppress = Throwable.class)\n+    public static void onExit(\n+        @Advice.This ILoggingEvent event,\n+        @Advice.Return(typing = Typing.DYNAMIC, readOnly = false) Map<String, String> contextData) {\n+      if (contextData != null && contextData.containsKey(\"traceId\")) {\n+        // Assume already instrumented event if traceId is present.\n+        return;\n+      }\n+\n+      Span currentSpan = InstrumentationContext.get(ILoggingEvent.class, Span.class).get(event);\n+      if (currentSpan != null && !currentSpan.getContext().isValid()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae73a1b81b32b102d0d1e43e17fd3b45b0716255"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI1MTg3OA==", "bodyText": "\ud83e\udd26  - that's correct, that was a stupid mistake on my side.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1208#discussion_r489251878", "createdAt": "2020-09-16T08:19:16Z", "author": {"login": "mateuszrzeszutek"}, "path": "instrumentation/logback/logback-1.0.0/auto/src/main/java/io/opentelemetry/instrumentation/auto/logback/v1_0_0/LoggingEventInstrumentation.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.logback.v1_0_0;\n+\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.implementsInterface;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import ch.qos.logback.classic.spi.ILoggingEvent;\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.instrumentation.auto.api.InstrumentationContext;\n+import io.opentelemetry.instrumentation.logback.v1_0_0.UnionMap;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.implementation.bytecode.assign.Assigner.Typing;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class LoggingEventInstrumentation extends Instrumenter.Default {\n+  public LoggingEventInstrumentation() {\n+    super(\"logback\");\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      \"io.opentelemetry.instrumentation.logback.v1_0_0.UnionMap\",\n+      \"io.opentelemetry.instrumentation.logback.v1_0_0.UnionMap$ConcatenatedSet\",\n+      \"io.opentelemetry.instrumentation.logback.v1_0_0.UnionMap$ConcatenatedSet$ConcatenatedSetIterator\"\n+    };\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return implementsInterface(named(\"ch.qos.logback.classic.spi.ILoggingEvent\"));\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"ch.qos.logback.classic.spi.ILoggingEvent\", Span.class.getName());\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(\n+        isMethod()\n+            .and(isPublic())\n+            .and(named(\"getMDCPropertyMap\").or(named(\"getMdc\")))\n+            .and(takesArguments(0)),\n+        LoggingEventInstrumentation.class.getName() + \"$GetMdcAdvice\");\n+  }\n+\n+  public static class GetMdcAdvice {\n+    @Advice.OnMethodExit(suppress = Throwable.class)\n+    public static void onExit(\n+        @Advice.This ILoggingEvent event,\n+        @Advice.Return(typing = Typing.DYNAMIC, readOnly = false) Map<String, String> contextData) {\n+      if (contextData != null && contextData.containsKey(\"traceId\")) {\n+        // Assume already instrumented event if traceId is present.\n+        return;\n+      }\n+\n+      Span currentSpan = InstrumentationContext.get(ILoggingEvent.class, Span.class).get(event);\n+      if (currentSpan != null && !currentSpan.getContext().isValid()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEzMDk5Nw=="}, "originalCommit": {"oid": "ae73a1b81b32b102d0d1e43e17fd3b45b0716255"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MDYzNDA1OnYy", "diffSide": "RIGHT", "path": "instrumentation/logback/logback-1.0.0/library/src/main/java/io/opentelemetry/instrumentation/logback/v1_0_0/UnionMap.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNDo0NToxNlrOHSf3Ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwODoyMzoyM1rOHSluMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE1ODQ5MQ==", "bodyText": "Can you move this into a subpackage internal? We shouldn't add this to our public API", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1208#discussion_r489158491", "createdAt": "2020-09-16T04:45:16Z", "author": {"login": "anuraaga"}, "path": "instrumentation/logback/logback-1.0.0/library/src/main/java/io/opentelemetry/instrumentation/logback/v1_0_0/UnionMap.java", "diffHunk": "@@ -29,14 +29,14 @@\n  * An immutable view over two maps, with keys resolving from the first map first, or otherwise the\n  * second if not present in the first.\n  */\n-final class UnionMap<K, V> extends AbstractMap<K, V> {\n+public final class UnionMap<K, V> extends AbstractMap<K, V> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae73a1b81b32b102d0d1e43e17fd3b45b0716255"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI1NDQ1MA==", "bodyText": "Done, thanks!", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1208#discussion_r489254450", "createdAt": "2020-09-16T08:23:23Z", "author": {"login": "mateuszrzeszutek"}, "path": "instrumentation/logback/logback-1.0.0/library/src/main/java/io/opentelemetry/instrumentation/logback/v1_0_0/UnionMap.java", "diffHunk": "@@ -29,14 +29,14 @@\n  * An immutable view over two maps, with keys resolving from the first map first, or otherwise the\n  * second if not present in the first.\n  */\n-final class UnionMap<K, V> extends AbstractMap<K, V> {\n+public final class UnionMap<K, V> extends AbstractMap<K, V> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE1ODQ5MQ=="}, "originalCommit": {"oid": "ae73a1b81b32b102d0d1e43e17fd3b45b0716255"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4925, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}