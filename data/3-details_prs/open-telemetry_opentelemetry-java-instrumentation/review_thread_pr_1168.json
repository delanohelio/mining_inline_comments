{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc4NzQwNzkz", "number": 1168, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxOToxOTo0OVrOEgH-vA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwNjo0Mzo1N1rOEhGm_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMTIwNjM2OnYy", "diffSide": "RIGHT", "path": "instrumentation/java-concurrent/kotlin-testing/src/test/kotlin/KotlinCoroutineTests.kt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxOToxOTo0OVrOHM0UsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMzozMDozMFrOHM6ohw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwMjIyNQ==", "bodyText": "You may want to use runBlocking: https://kotlinlang.org/docs/reference/coroutines/basics.html#structured-concurrency", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483202225", "createdAt": "2020-09-03T19:19:49Z", "author": {"login": "iNikem"}, "path": "instrumentation/java-concurrent/kotlin-testing/src/test/kotlin/KotlinCoroutineTests.kt", "diffHunk": "@@ -138,6 +140,55 @@ class KotlinCoroutineTests(private val dispatcher: CoroutineDispatcher) {\n     }\n   }\n \n+  fun launchConcurrentSuspendFunctions(numIters: Int) {\n+    for (i in 0 until numIters) {\n+      GlobalScope.launch {\n+        a(i.toLong())\n+      }\n+      GlobalScope.launch {\n+        b(i.toLong())\n+      }\n+    }\n+    // A simple and generous timeout (as opposed to joining on all the generated Jobs) also helps\n+    // fail the test if our overhead throws the cost of context switching 100s of times way out of normal\n+    Thread.sleep(4000)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db0a92514191069119bc380a788165909a4b4c97"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMwNTYwNw==", "bodyText": "Yes, thanks!", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483305607", "createdAt": "2020-09-03T23:30:30Z", "author": {"login": "johnbley"}, "path": "instrumentation/java-concurrent/kotlin-testing/src/test/kotlin/KotlinCoroutineTests.kt", "diffHunk": "@@ -138,6 +140,55 @@ class KotlinCoroutineTests(private val dispatcher: CoroutineDispatcher) {\n     }\n   }\n \n+  fun launchConcurrentSuspendFunctions(numIters: Int) {\n+    for (i in 0 until numIters) {\n+      GlobalScope.launch {\n+        a(i.toLong())\n+      }\n+      GlobalScope.launch {\n+        b(i.toLong())\n+      }\n+    }\n+    // A simple and generous timeout (as opposed to joining on all the generated Jobs) also helps\n+    // fail the test if our overhead throws the cost of context switching 100s of times way out of normal\n+    Thread.sleep(4000)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwMjIyNQ=="}, "originalCommit": {"oid": "db0a92514191069119bc380a788165909a4b4c97"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMjY3ODQ0OnYy", "diffSide": "RIGHT", "path": "instrumentation/java-concurrent/src/main/java/io/opentelemetry/instrumentation/auto/javaconcurrent/KotlinProbeInstrumentation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwNjo1Nzo0MVrOHNB7Yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxNDoxNToyM1rOHNPN_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNTEyMw==", "bodyText": "Could you add a bit more about why exactly it gets lost? Is it because with low concurrency, suspend functions are effectively executed in order on a single thread?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483425123", "createdAt": "2020-09-04T06:57:41Z", "author": {"login": "anuraaga"}, "path": "instrumentation/java-concurrent/src/main/java/io/opentelemetry/instrumentation/auto/javaconcurrent/KotlinProbeInstrumentation.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.javaconcurrent;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import kotlin.coroutines.Continuation;\n+import kotlin.coroutines.CoroutineContext;\n+import kotlin.jvm.functions.Function2;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+@AutoService(Instrumenter.class)\n+public class KotlinProbeInstrumentation extends Instrumenter.Default {\n+  /*\n+  Kotlin coroutines with suspend functions are a form of cooperative \"userland\" threading\n+  (you might also know this pattern as \"fibers\" or \"green threading\", where the OS/kernel-level thread\n+  has no idea of switching between tasks.  Fortunately kotlin exposes hooks for the key events: knowing when\n+  coroutines are being created, when they are suspended (swapped out/inactive), and when they are resumed (about to\n+  run again).\n+\n+  Without this instrumentation, heavy concurrency and usage of kotlin suspend functions will break causality", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7aae4c4cfe714961f27d62287bbb9134921f51e3"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY0Mjg3OQ==", "bodyText": "Will do.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483642879", "createdAt": "2020-09-04T14:15:23Z", "author": {"login": "johnbley"}, "path": "instrumentation/java-concurrent/src/main/java/io/opentelemetry/instrumentation/auto/javaconcurrent/KotlinProbeInstrumentation.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.javaconcurrent;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import kotlin.coroutines.Continuation;\n+import kotlin.coroutines.CoroutineContext;\n+import kotlin.jvm.functions.Function2;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+@AutoService(Instrumenter.class)\n+public class KotlinProbeInstrumentation extends Instrumenter.Default {\n+  /*\n+  Kotlin coroutines with suspend functions are a form of cooperative \"userland\" threading\n+  (you might also know this pattern as \"fibers\" or \"green threading\", where the OS/kernel-level thread\n+  has no idea of switching between tasks.  Fortunately kotlin exposes hooks for the key events: knowing when\n+  coroutines are being created, when they are suspended (swapped out/inactive), and when they are resumed (about to\n+  run again).\n+\n+  Without this instrumentation, heavy concurrency and usage of kotlin suspend functions will break causality", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNTEyMw=="}, "originalCommit": {"oid": "7aae4c4cfe714961f27d62287bbb9134921f51e3"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMjY3OTI2OnYy", "diffSide": "RIGHT", "path": "instrumentation/java-concurrent/src/main/java/io/opentelemetry/instrumentation/auto/javaconcurrent/KotlinProbeInstrumentation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwNjo1ODowMFrOHNB76Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxNDoxNTo0MVrOHNPOmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNTI1Nw==", "bodyText": "I think the above context is great for this class, this one we can just keep in PR comments :)", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483425257", "createdAt": "2020-09-04T06:58:00Z", "author": {"login": "anuraaga"}, "path": "instrumentation/java-concurrent/src/main/java/io/opentelemetry/instrumentation/auto/javaconcurrent/KotlinProbeInstrumentation.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.javaconcurrent;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import kotlin.coroutines.Continuation;\n+import kotlin.coroutines.CoroutineContext;\n+import kotlin.jvm.functions.Function2;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+@AutoService(Instrumenter.class)\n+public class KotlinProbeInstrumentation extends Instrumenter.Default {\n+  /*\n+  Kotlin coroutines with suspend functions are a form of cooperative \"userland\" threading\n+  (you might also know this pattern as \"fibers\" or \"green threading\", where the OS/kernel-level thread\n+  has no idea of switching between tasks.  Fortunately kotlin exposes hooks for the key events: knowing when\n+  coroutines are being created, when they are suspended (swapped out/inactive), and when they are resumed (about to\n+  run again).\n+\n+  Without this instrumentation, heavy concurrency and usage of kotlin suspend functions will break causality\n+  and cause nonsensical span parents/context propagation.\n+\n+  The basic strategy here is:\n+  1) Use the DebugProbes callbacks to learn about coroutine create, resume, and suspend operations\n+  2) Wrap the creation Coroutine and its Context and use that wrapping to add an extra Context \"key\"\n+  3) Use the callback for resume and suspend to manipulate our context \"key\" whereby an appropriate state\n+     object can be found (tied to the chain of Continutations in the Coroutine).\n+  4) Do our swapping-context dance with that appropriate state\n+  5) Test with highly concurrent well-known span causality and ensure everything looks right.\n+     Without this instrumentation, this test fails with concurrency=2; with this instrumentation,\n+     it passes with concurrency=200.\n+\n+  I've run the basic shape of this by an expert in kotlin coroutines (Roman Elizarov) and he agreed that the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7aae4c4cfe714961f27d62287bbb9134921f51e3"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY0MzAzMg==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483643032", "createdAt": "2020-09-04T14:15:41Z", "author": {"login": "johnbley"}, "path": "instrumentation/java-concurrent/src/main/java/io/opentelemetry/instrumentation/auto/javaconcurrent/KotlinProbeInstrumentation.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.javaconcurrent;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import kotlin.coroutines.Continuation;\n+import kotlin.coroutines.CoroutineContext;\n+import kotlin.jvm.functions.Function2;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+@AutoService(Instrumenter.class)\n+public class KotlinProbeInstrumentation extends Instrumenter.Default {\n+  /*\n+  Kotlin coroutines with suspend functions are a form of cooperative \"userland\" threading\n+  (you might also know this pattern as \"fibers\" or \"green threading\", where the OS/kernel-level thread\n+  has no idea of switching between tasks.  Fortunately kotlin exposes hooks for the key events: knowing when\n+  coroutines are being created, when they are suspended (swapped out/inactive), and when they are resumed (about to\n+  run again).\n+\n+  Without this instrumentation, heavy concurrency and usage of kotlin suspend functions will break causality\n+  and cause nonsensical span parents/context propagation.\n+\n+  The basic strategy here is:\n+  1) Use the DebugProbes callbacks to learn about coroutine create, resume, and suspend operations\n+  2) Wrap the creation Coroutine and its Context and use that wrapping to add an extra Context \"key\"\n+  3) Use the callback for resume and suspend to manipulate our context \"key\" whereby an appropriate state\n+     object can be found (tied to the chain of Continutations in the Coroutine).\n+  4) Do our swapping-context dance with that appropriate state\n+  5) Test with highly concurrent well-known span causality and ensure everything looks right.\n+     Without this instrumentation, this test fails with concurrency=2; with this instrumentation,\n+     it passes with concurrency=200.\n+\n+  I've run the basic shape of this by an expert in kotlin coroutines (Roman Elizarov) and he agreed that the", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNTI1Nw=="}, "originalCommit": {"oid": "7aae4c4cfe714961f27d62287bbb9134921f51e3"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMjY4NTIzOnYy", "diffSide": "RIGHT", "path": "instrumentation/java-concurrent/src/main/java/io/opentelemetry/instrumentation/auto/javaconcurrent/KotlinProbeInstrumentation.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwNzowMDowOVrOHNB_gQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxNDoyNzo0MVrOHNPqOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNjE3Nw==", "bodyText": "I think it'd make sense for us to rename kotlin-testing to kotlin-coroutines and add this instrumentation there too since this isn't instrumenting the JDK itself. It removes that corner case of muzzle you found too I believe.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483426177", "createdAt": "2020-09-04T07:00:09Z", "author": {"login": "anuraaga"}, "path": "instrumentation/java-concurrent/src/main/java/io/opentelemetry/instrumentation/auto/javaconcurrent/KotlinProbeInstrumentation.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.javaconcurrent;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import kotlin.coroutines.Continuation;\n+import kotlin.coroutines.CoroutineContext;\n+import kotlin.jvm.functions.Function2;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+@AutoService(Instrumenter.class)\n+public class KotlinProbeInstrumentation extends Instrumenter.Default {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7aae4c4cfe714961f27d62287bbb9134921f51e3"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY0NDMxNg==", "bodyText": "Are you proposing to move this instrumentation and test to a new <root>/instrumentation/kotlin-coroutines module?  That makes sense to me.  Please confirm my understanding and I'll work on that refactoring.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483644316", "createdAt": "2020-09-04T14:17:54Z", "author": {"login": "johnbley"}, "path": "instrumentation/java-concurrent/src/main/java/io/opentelemetry/instrumentation/auto/javaconcurrent/KotlinProbeInstrumentation.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.javaconcurrent;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import kotlin.coroutines.Continuation;\n+import kotlin.coroutines.CoroutineContext;\n+import kotlin.jvm.functions.Function2;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+@AutoService(Instrumenter.class)\n+public class KotlinProbeInstrumentation extends Instrumenter.Default {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNjE3Nw=="}, "originalCommit": {"oid": "7aae4c4cfe714961f27d62287bbb9134921f51e3"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY0OTQzOQ==", "bodyText": "Yup that's what I'm thinking", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483649439", "createdAt": "2020-09-04T14:26:33Z", "author": {"login": "anuraaga"}, "path": "instrumentation/java-concurrent/src/main/java/io/opentelemetry/instrumentation/auto/javaconcurrent/KotlinProbeInstrumentation.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.javaconcurrent;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import kotlin.coroutines.Continuation;\n+import kotlin.coroutines.CoroutineContext;\n+import kotlin.jvm.functions.Function2;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+@AutoService(Instrumenter.class)\n+public class KotlinProbeInstrumentation extends Instrumenter.Default {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNjE3Nw=="}, "originalCommit": {"oid": "7aae4c4cfe714961f27d62287bbb9134921f51e3"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY1MDEwNg==", "bodyText": "OK, I'll work on that today.  Thanks!", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483650106", "createdAt": "2020-09-04T14:27:41Z", "author": {"login": "johnbley"}, "path": "instrumentation/java-concurrent/src/main/java/io/opentelemetry/instrumentation/auto/javaconcurrent/KotlinProbeInstrumentation.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.javaconcurrent;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import kotlin.coroutines.Continuation;\n+import kotlin.coroutines.CoroutineContext;\n+import kotlin.jvm.functions.Function2;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+@AutoService(Instrumenter.class)\n+public class KotlinProbeInstrumentation extends Instrumenter.Default {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNjE3Nw=="}, "originalCommit": {"oid": "7aae4c4cfe714961f27d62287bbb9134921f51e3"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMjY5NDE2OnYy", "diffSide": "RIGHT", "path": "instrumentation/java-concurrent/src/main/java/io/opentelemetry/instrumentation/auto/javaconcurrent/KotlinProbeInstrumentation.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwNzowMzozM1rOHNCFAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxNDozMjowN1rOHNP0gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNzU4Nw==", "bodyText": "Is it possible to use ThreadContextElement instead of hooking into the lifecycle ourselves? If not, can we add some docs on why that doesn't work? I haven't used kotlin much TBH, but my understanding is that's the standard way of syncing a threadlocal with coroutines, which is what we want to achieve here.\nhttps://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-thread-context-element/", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483427587", "createdAt": "2020-09-04T07:03:33Z", "author": {"login": "anuraaga"}, "path": "instrumentation/java-concurrent/src/main/java/io/opentelemetry/instrumentation/auto/javaconcurrent/KotlinProbeInstrumentation.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.javaconcurrent;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import kotlin.coroutines.Continuation;\n+import kotlin.coroutines.CoroutineContext;\n+import kotlin.jvm.functions.Function2;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+@AutoService(Instrumenter.class)\n+public class KotlinProbeInstrumentation extends Instrumenter.Default {\n+  /*\n+  Kotlin coroutines with suspend functions are a form of cooperative \"userland\" threading\n+  (you might also know this pattern as \"fibers\" or \"green threading\", where the OS/kernel-level thread\n+  has no idea of switching between tasks.  Fortunately kotlin exposes hooks for the key events: knowing when\n+  coroutines are being created, when they are suspended (swapped out/inactive), and when they are resumed (about to\n+  run again).\n+\n+  Without this instrumentation, heavy concurrency and usage of kotlin suspend functions will break causality\n+  and cause nonsensical span parents/context propagation.\n+\n+  The basic strategy here is:\n+  1) Use the DebugProbes callbacks to learn about coroutine create, resume, and suspend operations\n+  2) Wrap the creation Coroutine and its Context and use that wrapping to add an extra Context \"key\"\n+  3) Use the callback for resume and suspend to manipulate our context \"key\" whereby an appropriate state\n+     object can be found (tied to the chain of Continutations in the Coroutine).\n+  4) Do our swapping-context dance with that appropriate state\n+  5) Test with highly concurrent well-known span causality and ensure everything looks right.\n+     Without this instrumentation, this test fails with concurrency=2; with this instrumentation,\n+     it passes with concurrency=200.\n+\n+  I've run the basic shape of this by an expert in kotlin coroutines (Roman Elizarov) and he agreed that the\n+  overhead should be fine for production usage.\n+  */\n+\n+  public KotlinProbeInstrumentation() {\n+    super(\"kotlin-coroutines\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"kotlin.coroutines.jvm.internal.DebugProbesKt\");\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        named(\"probeCoroutineCreated\").and(takesArguments(1)),\n+        CoroutineCreatedAdvice.class.getName());\n+    transformers.put(\n+        named(\"probeCoroutineResumed\").and(takesArguments(1)),\n+        CoroutineResumedAdvice.class.getName());\n+    transformers.put(\n+        named(\"probeCoroutineSuspended\").and(takesArguments(1)),\n+        CoroutineSuspendedAdvice.class.getName());\n+    return transformers;\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      \"io.opentelemetry.instrumentation.auto.javaconcurrent.KotlinProbeInstrumentation$CoroutineWrapper\",\n+      \"io.opentelemetry.instrumentation.auto.javaconcurrent.KotlinProbeInstrumentation$TraceScopeKey\",\n+      \"io.opentelemetry.instrumentation.auto.javaconcurrent.KotlinProbeInstrumentation$CoroutineContextWrapper\",\n+    };\n+  }\n+\n+  public static class CoroutineCreatedAdvice {\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void exit(\n+        @Advice.Return(readOnly = false) kotlin.coroutines.Continuation retVal) {\n+      if (!(retVal instanceof CoroutineWrapper)) {\n+        retVal = new CoroutineWrapper(retVal);\n+      }\n+    }\n+  }\n+\n+  public static class CoroutineResumedAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void enter(\n+        @Advice.Argument(0) final kotlin.coroutines.Continuation continuation) {\n+      continuation.getContext().get(TraceScopeKey.INSTANCE);\n+    }\n+  }\n+\n+  public static class CoroutineSuspendedAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void enter(\n+        @Advice.Argument(0) final kotlin.coroutines.Continuation continuation) {\n+      continuation.getContext().minusKey(TraceScopeKey.INSTANCE);\n+    }\n+  }\n+\n+  public static class TraceScopeKey implements CoroutineContext.Key {\n+    public static final TraceScopeKey INSTANCE = new TraceScopeKey();\n+  }\n+\n+  public static class CoroutineWrapper implements kotlin.coroutines.Continuation {\n+    private final Continuation proxy;\n+    private final CoroutineContextWrapper contextWrapper;\n+\n+    public CoroutineWrapper(Continuation proxy) {\n+      this.proxy = proxy;\n+      this.contextWrapper = new CoroutineContextWrapper(proxy.getContext());\n+    }\n+\n+    public String toString() {\n+      return proxy.toString();\n+    }\n+\n+    @NotNull\n+    @Override\n+    public CoroutineContext getContext() {\n+      return contextWrapper;\n+    }\n+\n+    @Override\n+    public void resumeWith(@NotNull Object o) {\n+      proxy.resumeWith(o);\n+    }\n+  }\n+\n+  public static class CoroutineContextWrapper implements CoroutineContext {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7aae4c4cfe714961f27d62287bbb9134921f51e3"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyODQ1Mw==", "bodyText": "Also, just brainstorming, but is there an approach that wraps dispatchers using something like https://grpc.github.io/grpc-java/javadoc/io/grpc/Context.html#currentContextExecutor-java.util.concurrent.Executor- ? I have no idea the pros/cons for kotlin :) But in Java, my goto for context propagation is usually a wrapped Executor so it just came to mind. I've used this approach in some of the only kotlin I've ever written outside of build scripts.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483428453", "createdAt": "2020-09-04T07:05:34Z", "author": {"login": "anuraaga"}, "path": "instrumentation/java-concurrent/src/main/java/io/opentelemetry/instrumentation/auto/javaconcurrent/KotlinProbeInstrumentation.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.javaconcurrent;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import kotlin.coroutines.Continuation;\n+import kotlin.coroutines.CoroutineContext;\n+import kotlin.jvm.functions.Function2;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+@AutoService(Instrumenter.class)\n+public class KotlinProbeInstrumentation extends Instrumenter.Default {\n+  /*\n+  Kotlin coroutines with suspend functions are a form of cooperative \"userland\" threading\n+  (you might also know this pattern as \"fibers\" or \"green threading\", where the OS/kernel-level thread\n+  has no idea of switching between tasks.  Fortunately kotlin exposes hooks for the key events: knowing when\n+  coroutines are being created, when they are suspended (swapped out/inactive), and when they are resumed (about to\n+  run again).\n+\n+  Without this instrumentation, heavy concurrency and usage of kotlin suspend functions will break causality\n+  and cause nonsensical span parents/context propagation.\n+\n+  The basic strategy here is:\n+  1) Use the DebugProbes callbacks to learn about coroutine create, resume, and suspend operations\n+  2) Wrap the creation Coroutine and its Context and use that wrapping to add an extra Context \"key\"\n+  3) Use the callback for resume and suspend to manipulate our context \"key\" whereby an appropriate state\n+     object can be found (tied to the chain of Continutations in the Coroutine).\n+  4) Do our swapping-context dance with that appropriate state\n+  5) Test with highly concurrent well-known span causality and ensure everything looks right.\n+     Without this instrumentation, this test fails with concurrency=2; with this instrumentation,\n+     it passes with concurrency=200.\n+\n+  I've run the basic shape of this by an expert in kotlin coroutines (Roman Elizarov) and he agreed that the\n+  overhead should be fine for production usage.\n+  */\n+\n+  public KotlinProbeInstrumentation() {\n+    super(\"kotlin-coroutines\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"kotlin.coroutines.jvm.internal.DebugProbesKt\");\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        named(\"probeCoroutineCreated\").and(takesArguments(1)),\n+        CoroutineCreatedAdvice.class.getName());\n+    transformers.put(\n+        named(\"probeCoroutineResumed\").and(takesArguments(1)),\n+        CoroutineResumedAdvice.class.getName());\n+    transformers.put(\n+        named(\"probeCoroutineSuspended\").and(takesArguments(1)),\n+        CoroutineSuspendedAdvice.class.getName());\n+    return transformers;\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      \"io.opentelemetry.instrumentation.auto.javaconcurrent.KotlinProbeInstrumentation$CoroutineWrapper\",\n+      \"io.opentelemetry.instrumentation.auto.javaconcurrent.KotlinProbeInstrumentation$TraceScopeKey\",\n+      \"io.opentelemetry.instrumentation.auto.javaconcurrent.KotlinProbeInstrumentation$CoroutineContextWrapper\",\n+    };\n+  }\n+\n+  public static class CoroutineCreatedAdvice {\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void exit(\n+        @Advice.Return(readOnly = false) kotlin.coroutines.Continuation retVal) {\n+      if (!(retVal instanceof CoroutineWrapper)) {\n+        retVal = new CoroutineWrapper(retVal);\n+      }\n+    }\n+  }\n+\n+  public static class CoroutineResumedAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void enter(\n+        @Advice.Argument(0) final kotlin.coroutines.Continuation continuation) {\n+      continuation.getContext().get(TraceScopeKey.INSTANCE);\n+    }\n+  }\n+\n+  public static class CoroutineSuspendedAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void enter(\n+        @Advice.Argument(0) final kotlin.coroutines.Continuation continuation) {\n+      continuation.getContext().minusKey(TraceScopeKey.INSTANCE);\n+    }\n+  }\n+\n+  public static class TraceScopeKey implements CoroutineContext.Key {\n+    public static final TraceScopeKey INSTANCE = new TraceScopeKey();\n+  }\n+\n+  public static class CoroutineWrapper implements kotlin.coroutines.Continuation {\n+    private final Continuation proxy;\n+    private final CoroutineContextWrapper contextWrapper;\n+\n+    public CoroutineWrapper(Continuation proxy) {\n+      this.proxy = proxy;\n+      this.contextWrapper = new CoroutineContextWrapper(proxy.getContext());\n+    }\n+\n+    public String toString() {\n+      return proxy.toString();\n+    }\n+\n+    @NotNull\n+    @Override\n+    public CoroutineContext getContext() {\n+      return contextWrapper;\n+    }\n+\n+    @Override\n+    public void resumeWith(@NotNull Object o) {\n+      proxy.resumeWith(o);\n+    }\n+  }\n+\n+  public static class CoroutineContextWrapper implements CoroutineContext {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNzU4Nw=="}, "originalCommit": {"oid": "7aae4c4cfe714961f27d62287bbb9134921f51e3"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY0NzIzNw==", "bodyText": "So, yes, I have experimented with more \"public\" ways of doing this.  I had a version with the ThreadContextElement approach and it passed the tests, but it exposes the attached CoroutineContext in a way that is visible (and modifiable) to the app (in addition to being a bit more awkward to implement owing to the larger implementation surface of CoroutineContext.Element and writing this in Java rather than Kotlin).  I got worried about app code clearing or resetting context and accidentally dropping our bits.  I am not a Kotlin expert at all though, so perhaps there's a cleaner/more elegant way to use the ThreadContextElement approach that I'm not seeing.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483647237", "createdAt": "2020-09-04T14:22:57Z", "author": {"login": "johnbley"}, "path": "instrumentation/java-concurrent/src/main/java/io/opentelemetry/instrumentation/auto/javaconcurrent/KotlinProbeInstrumentation.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.javaconcurrent;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import kotlin.coroutines.Continuation;\n+import kotlin.coroutines.CoroutineContext;\n+import kotlin.jvm.functions.Function2;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+@AutoService(Instrumenter.class)\n+public class KotlinProbeInstrumentation extends Instrumenter.Default {\n+  /*\n+  Kotlin coroutines with suspend functions are a form of cooperative \"userland\" threading\n+  (you might also know this pattern as \"fibers\" or \"green threading\", where the OS/kernel-level thread\n+  has no idea of switching between tasks.  Fortunately kotlin exposes hooks for the key events: knowing when\n+  coroutines are being created, when they are suspended (swapped out/inactive), and when they are resumed (about to\n+  run again).\n+\n+  Without this instrumentation, heavy concurrency and usage of kotlin suspend functions will break causality\n+  and cause nonsensical span parents/context propagation.\n+\n+  The basic strategy here is:\n+  1) Use the DebugProbes callbacks to learn about coroutine create, resume, and suspend operations\n+  2) Wrap the creation Coroutine and its Context and use that wrapping to add an extra Context \"key\"\n+  3) Use the callback for resume and suspend to manipulate our context \"key\" whereby an appropriate state\n+     object can be found (tied to the chain of Continutations in the Coroutine).\n+  4) Do our swapping-context dance with that appropriate state\n+  5) Test with highly concurrent well-known span causality and ensure everything looks right.\n+     Without this instrumentation, this test fails with concurrency=2; with this instrumentation,\n+     it passes with concurrency=200.\n+\n+  I've run the basic shape of this by an expert in kotlin coroutines (Roman Elizarov) and he agreed that the\n+  overhead should be fine for production usage.\n+  */\n+\n+  public KotlinProbeInstrumentation() {\n+    super(\"kotlin-coroutines\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"kotlin.coroutines.jvm.internal.DebugProbesKt\");\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        named(\"probeCoroutineCreated\").and(takesArguments(1)),\n+        CoroutineCreatedAdvice.class.getName());\n+    transformers.put(\n+        named(\"probeCoroutineResumed\").and(takesArguments(1)),\n+        CoroutineResumedAdvice.class.getName());\n+    transformers.put(\n+        named(\"probeCoroutineSuspended\").and(takesArguments(1)),\n+        CoroutineSuspendedAdvice.class.getName());\n+    return transformers;\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      \"io.opentelemetry.instrumentation.auto.javaconcurrent.KotlinProbeInstrumentation$CoroutineWrapper\",\n+      \"io.opentelemetry.instrumentation.auto.javaconcurrent.KotlinProbeInstrumentation$TraceScopeKey\",\n+      \"io.opentelemetry.instrumentation.auto.javaconcurrent.KotlinProbeInstrumentation$CoroutineContextWrapper\",\n+    };\n+  }\n+\n+  public static class CoroutineCreatedAdvice {\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void exit(\n+        @Advice.Return(readOnly = false) kotlin.coroutines.Continuation retVal) {\n+      if (!(retVal instanceof CoroutineWrapper)) {\n+        retVal = new CoroutineWrapper(retVal);\n+      }\n+    }\n+  }\n+\n+  public static class CoroutineResumedAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void enter(\n+        @Advice.Argument(0) final kotlin.coroutines.Continuation continuation) {\n+      continuation.getContext().get(TraceScopeKey.INSTANCE);\n+    }\n+  }\n+\n+  public static class CoroutineSuspendedAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void enter(\n+        @Advice.Argument(0) final kotlin.coroutines.Continuation continuation) {\n+      continuation.getContext().minusKey(TraceScopeKey.INSTANCE);\n+    }\n+  }\n+\n+  public static class TraceScopeKey implements CoroutineContext.Key {\n+    public static final TraceScopeKey INSTANCE = new TraceScopeKey();\n+  }\n+\n+  public static class CoroutineWrapper implements kotlin.coroutines.Continuation {\n+    private final Continuation proxy;\n+    private final CoroutineContextWrapper contextWrapper;\n+\n+    public CoroutineWrapper(Continuation proxy) {\n+      this.proxy = proxy;\n+      this.contextWrapper = new CoroutineContextWrapper(proxy.getContext());\n+    }\n+\n+    public String toString() {\n+      return proxy.toString();\n+    }\n+\n+    @NotNull\n+    @Override\n+    public CoroutineContext getContext() {\n+      return contextWrapper;\n+    }\n+\n+    @Override\n+    public void resumeWith(@NotNull Object o) {\n+      proxy.resumeWith(o);\n+    }\n+  }\n+\n+  public static class CoroutineContextWrapper implements CoroutineContext {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNzU4Nw=="}, "originalCommit": {"oid": "7aae4c4cfe714961f27d62287bbb9134921f51e3"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY1MjczOQ==", "bodyText": "FWIW, if it helps, I don't see a reason to avoid writing the instrumentation in kotlin for kotlin if it helps - main overhead of kotlin is usually the size of the runtime which is no an issue when the instrumentation already requires it.\nBut given it seems we can expect relative stability from the debug probes API, I wouldn't worry too much either, it's a point in case anything was obvious. We can always investigate more if something breaks in the future instead of now.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483652739", "createdAt": "2020-09-04T14:32:07Z", "author": {"login": "anuraaga"}, "path": "instrumentation/java-concurrent/src/main/java/io/opentelemetry/instrumentation/auto/javaconcurrent/KotlinProbeInstrumentation.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.javaconcurrent;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import kotlin.coroutines.Continuation;\n+import kotlin.coroutines.CoroutineContext;\n+import kotlin.jvm.functions.Function2;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+@AutoService(Instrumenter.class)\n+public class KotlinProbeInstrumentation extends Instrumenter.Default {\n+  /*\n+  Kotlin coroutines with suspend functions are a form of cooperative \"userland\" threading\n+  (you might also know this pattern as \"fibers\" or \"green threading\", where the OS/kernel-level thread\n+  has no idea of switching between tasks.  Fortunately kotlin exposes hooks for the key events: knowing when\n+  coroutines are being created, when they are suspended (swapped out/inactive), and when they are resumed (about to\n+  run again).\n+\n+  Without this instrumentation, heavy concurrency and usage of kotlin suspend functions will break causality\n+  and cause nonsensical span parents/context propagation.\n+\n+  The basic strategy here is:\n+  1) Use the DebugProbes callbacks to learn about coroutine create, resume, and suspend operations\n+  2) Wrap the creation Coroutine and its Context and use that wrapping to add an extra Context \"key\"\n+  3) Use the callback for resume and suspend to manipulate our context \"key\" whereby an appropriate state\n+     object can be found (tied to the chain of Continutations in the Coroutine).\n+  4) Do our swapping-context dance with that appropriate state\n+  5) Test with highly concurrent well-known span causality and ensure everything looks right.\n+     Without this instrumentation, this test fails with concurrency=2; with this instrumentation,\n+     it passes with concurrency=200.\n+\n+  I've run the basic shape of this by an expert in kotlin coroutines (Roman Elizarov) and he agreed that the\n+  overhead should be fine for production usage.\n+  */\n+\n+  public KotlinProbeInstrumentation() {\n+    super(\"kotlin-coroutines\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"kotlin.coroutines.jvm.internal.DebugProbesKt\");\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        named(\"probeCoroutineCreated\").and(takesArguments(1)),\n+        CoroutineCreatedAdvice.class.getName());\n+    transformers.put(\n+        named(\"probeCoroutineResumed\").and(takesArguments(1)),\n+        CoroutineResumedAdvice.class.getName());\n+    transformers.put(\n+        named(\"probeCoroutineSuspended\").and(takesArguments(1)),\n+        CoroutineSuspendedAdvice.class.getName());\n+    return transformers;\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      \"io.opentelemetry.instrumentation.auto.javaconcurrent.KotlinProbeInstrumentation$CoroutineWrapper\",\n+      \"io.opentelemetry.instrumentation.auto.javaconcurrent.KotlinProbeInstrumentation$TraceScopeKey\",\n+      \"io.opentelemetry.instrumentation.auto.javaconcurrent.KotlinProbeInstrumentation$CoroutineContextWrapper\",\n+    };\n+  }\n+\n+  public static class CoroutineCreatedAdvice {\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void exit(\n+        @Advice.Return(readOnly = false) kotlin.coroutines.Continuation retVal) {\n+      if (!(retVal instanceof CoroutineWrapper)) {\n+        retVal = new CoroutineWrapper(retVal);\n+      }\n+    }\n+  }\n+\n+  public static class CoroutineResumedAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void enter(\n+        @Advice.Argument(0) final kotlin.coroutines.Continuation continuation) {\n+      continuation.getContext().get(TraceScopeKey.INSTANCE);\n+    }\n+  }\n+\n+  public static class CoroutineSuspendedAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void enter(\n+        @Advice.Argument(0) final kotlin.coroutines.Continuation continuation) {\n+      continuation.getContext().minusKey(TraceScopeKey.INSTANCE);\n+    }\n+  }\n+\n+  public static class TraceScopeKey implements CoroutineContext.Key {\n+    public static final TraceScopeKey INSTANCE = new TraceScopeKey();\n+  }\n+\n+  public static class CoroutineWrapper implements kotlin.coroutines.Continuation {\n+    private final Continuation proxy;\n+    private final CoroutineContextWrapper contextWrapper;\n+\n+    public CoroutineWrapper(Continuation proxy) {\n+      this.proxy = proxy;\n+      this.contextWrapper = new CoroutineContextWrapper(proxy.getContext());\n+    }\n+\n+    public String toString() {\n+      return proxy.toString();\n+    }\n+\n+    @NotNull\n+    @Override\n+    public CoroutineContext getContext() {\n+      return contextWrapper;\n+    }\n+\n+    @Override\n+    public void resumeWith(@NotNull Object o) {\n+      proxy.resumeWith(o);\n+    }\n+  }\n+\n+  public static class CoroutineContextWrapper implements CoroutineContext {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNzU4Nw=="}, "originalCommit": {"oid": "7aae4c4cfe714961f27d62287bbb9134921f51e3"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMjcwOTY0OnYy", "diffSide": "RIGHT", "path": "instrumentation/java-concurrent/src/main/java/io/opentelemetry/instrumentation/auto/javaconcurrent/KotlinProbeInstrumentation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwNzowODo0OFrOHNCN7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxNDoyNToxM1rOHNPkVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyOTg2OA==", "bodyText": "Just to confirm, I guess there's no public entrypoint that is similar to this one? For example, we won't have any breakage across kotlin version if we can stick to public APIs than internal ones. One API that comes to mind is startCoroutine\nhttps://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/start-coroutine.html\nPerhaps my other suggestions can bring to light an idea that can keep interception to the public API. But if not, it's ok too we have other instrumentation reliant on private APIs and use muzzle to bite us when something breaks.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483429868", "createdAt": "2020-09-04T07:08:48Z", "author": {"login": "anuraaga"}, "path": "instrumentation/java-concurrent/src/main/java/io/opentelemetry/instrumentation/auto/javaconcurrent/KotlinProbeInstrumentation.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.javaconcurrent;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import kotlin.coroutines.Continuation;\n+import kotlin.coroutines.CoroutineContext;\n+import kotlin.jvm.functions.Function2;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+@AutoService(Instrumenter.class)\n+public class KotlinProbeInstrumentation extends Instrumenter.Default {\n+  /*\n+  Kotlin coroutines with suspend functions are a form of cooperative \"userland\" threading\n+  (you might also know this pattern as \"fibers\" or \"green threading\", where the OS/kernel-level thread\n+  has no idea of switching between tasks.  Fortunately kotlin exposes hooks for the key events: knowing when\n+  coroutines are being created, when they are suspended (swapped out/inactive), and when they are resumed (about to\n+  run again).\n+\n+  Without this instrumentation, heavy concurrency and usage of kotlin suspend functions will break causality\n+  and cause nonsensical span parents/context propagation.\n+\n+  The basic strategy here is:\n+  1) Use the DebugProbes callbacks to learn about coroutine create, resume, and suspend operations\n+  2) Wrap the creation Coroutine and its Context and use that wrapping to add an extra Context \"key\"\n+  3) Use the callback for resume and suspend to manipulate our context \"key\" whereby an appropriate state\n+     object can be found (tied to the chain of Continutations in the Coroutine).\n+  4) Do our swapping-context dance with that appropriate state\n+  5) Test with highly concurrent well-known span causality and ensure everything looks right.\n+     Without this instrumentation, this test fails with concurrency=2; with this instrumentation,\n+     it passes with concurrency=200.\n+\n+  I've run the basic shape of this by an expert in kotlin coroutines (Roman Elizarov) and he agreed that the\n+  overhead should be fine for production usage.\n+  */\n+\n+  public KotlinProbeInstrumentation() {\n+    super(\"kotlin-coroutines\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"kotlin.coroutines.jvm.internal.DebugProbesKt\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7aae4c4cfe714961f27d62287bbb9134921f51e3"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY0ODU5Nw==", "bodyText": "You raise some good points.  Yes, we're helped by muzzle here.  We're also helped in that kotlin has a debugging extension using this code (hence the name DebugProbes) for tracking coroutine causality, and that their implementation also uses bytecode instrumentation to swap in the debugging version.  Because of the friction introduced by that design, it's unlikely that they'll change this interface frequently \ud83d\ude04", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483648597", "createdAt": "2020-09-04T14:25:13Z", "author": {"login": "johnbley"}, "path": "instrumentation/java-concurrent/src/main/java/io/opentelemetry/instrumentation/auto/javaconcurrent/KotlinProbeInstrumentation.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.javaconcurrent;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import kotlin.coroutines.Continuation;\n+import kotlin.coroutines.CoroutineContext;\n+import kotlin.jvm.functions.Function2;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+@AutoService(Instrumenter.class)\n+public class KotlinProbeInstrumentation extends Instrumenter.Default {\n+  /*\n+  Kotlin coroutines with suspend functions are a form of cooperative \"userland\" threading\n+  (you might also know this pattern as \"fibers\" or \"green threading\", where the OS/kernel-level thread\n+  has no idea of switching between tasks.  Fortunately kotlin exposes hooks for the key events: knowing when\n+  coroutines are being created, when they are suspended (swapped out/inactive), and when they are resumed (about to\n+  run again).\n+\n+  Without this instrumentation, heavy concurrency and usage of kotlin suspend functions will break causality\n+  and cause nonsensical span parents/context propagation.\n+\n+  The basic strategy here is:\n+  1) Use the DebugProbes callbacks to learn about coroutine create, resume, and suspend operations\n+  2) Wrap the creation Coroutine and its Context and use that wrapping to add an extra Context \"key\"\n+  3) Use the callback for resume and suspend to manipulate our context \"key\" whereby an appropriate state\n+     object can be found (tied to the chain of Continutations in the Coroutine).\n+  4) Do our swapping-context dance with that appropriate state\n+  5) Test with highly concurrent well-known span causality and ensure everything looks right.\n+     Without this instrumentation, this test fails with concurrency=2; with this instrumentation,\n+     it passes with concurrency=200.\n+\n+  I've run the basic shape of this by an expert in kotlin coroutines (Roman Elizarov) and he agreed that the\n+  overhead should be fine for production usage.\n+  */\n+\n+  public KotlinProbeInstrumentation() {\n+    super(\"kotlin-coroutines\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"kotlin.coroutines.jvm.internal.DebugProbesKt\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyOTg2OA=="}, "originalCommit": {"oid": "7aae4c4cfe714961f27d62287bbb9134921f51e3"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNTc2NzY4OnYy", "diffSide": "RIGHT", "path": "instrumentation/kotlin-coroutines/kotlin-testing/kotlin-testing.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQwMjowMzoyMFrOHNey3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxODozMTo0OVrOHOGE4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg5ODA3OA==", "bodyText": "Do we need a separate testing project? Can we just merge this into kotlin-coroutines since these are tests for that instrumentation?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483898078", "createdAt": "2020-09-05T02:03:20Z", "author": {"login": "anuraaga"}, "path": "instrumentation/kotlin-coroutines/kotlin-testing/kotlin-testing.gradle", "diffHunk": "@@ -3,6 +3,8 @@ apply from: \"$rootDir/gradle/instrumentation.gradle\"\n apply from: \"$rootDir/gradle/test-with-kotlin.gradle\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b8346dc04e3b8d9070aa57b066b396b1a772bc4"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU0MTY2NA==", "bodyText": "Good call, this was just an artifact of how things were when this lived in java-concurrent.  Fixed and simplified.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r484541664", "createdAt": "2020-09-07T18:31:49Z", "author": {"login": "johnbley"}, "path": "instrumentation/kotlin-coroutines/kotlin-testing/kotlin-testing.gradle", "diffHunk": "@@ -3,6 +3,8 @@ apply from: \"$rootDir/gradle/instrumentation.gradle\"\n apply from: \"$rootDir/gradle/test-with-kotlin.gradle\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg5ODA3OA=="}, "originalCommit": {"oid": "9b8346dc04e3b8d9070aa57b066b396b1a772bc4"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNTc3Mjc4OnYy", "diffSide": "RIGHT", "path": "instrumentation/kotlin-coroutines/kotlin-coroutines.gradle", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQwMjowOToxN1rOHNe1Lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QyMDozMjozMVrOHOHS2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg5ODY3MA==", "bodyText": "Since we're not instrumenting the JDK we shouldn't need this. We want muzzle to run against kotlin-coroutines versions so that also should be the target rather than an extra dependency. The normal muzzle pattern looks something like this, which is verifying the implementation applies to the range of versions of the library (we're interested in kotlin-coroutine-core).\nhttps://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/master/instrumentation/jetty-8.0/jetty-8.0.gradle#L5", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483898670", "createdAt": "2020-09-05T02:09:17Z", "author": {"login": "anuraaga"}, "path": "instrumentation/kotlin-coroutines/kotlin-coroutines.gradle", "diffHunk": "@@ -0,0 +1,21 @@\n+ext {\n+  // TODO (trask) currently this is only needed for LambdaGen\n+  //  revisit if we don't end up dropping Java 7\n+  minJavaVersionForTests = JavaVersion.VERSION_1_8\n+}\n+\n+apply from: \"$rootDir/gradle/instrumentation.gradle\"\n+\n+muzzle {\n+  pass {\n+    extraDependency('org.jetbrains.kotlin:kotlin-stdlib-common:1.3.72')\n+    extraDependency('org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.7')\n+    coreJdk()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b8346dc04e3b8d9070aa57b066b396b1a772bc4"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU0MDc1MQ==", "bodyText": "I took a first pass at this; I'd appreciate feedback on how far back to go in the testing - I set it as [1.0.0,) since that's what made sense to me.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r484540751", "createdAt": "2020-09-07T18:26:24Z", "author": {"login": "johnbley"}, "path": "instrumentation/kotlin-coroutines/kotlin-coroutines.gradle", "diffHunk": "@@ -0,0 +1,21 @@\n+ext {\n+  // TODO (trask) currently this is only needed for LambdaGen\n+  //  revisit if we don't end up dropping Java 7\n+  minJavaVersionForTests = JavaVersion.VERSION_1_8\n+}\n+\n+apply from: \"$rootDir/gradle/instrumentation.gradle\"\n+\n+muzzle {\n+  pass {\n+    extraDependency('org.jetbrains.kotlin:kotlin-stdlib-common:1.3.72')\n+    extraDependency('org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.7')\n+    coreJdk()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg5ODY3MA=="}, "originalCommit": {"oid": "9b8346dc04e3b8d9070aa57b066b396b1a772bc4"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU2MTYyNQ==", "bodyText": "Looking into muzzle failures here it appears that recent versions of kotlin-core offer a large number of variants.  I can't figure out how to get variant selection to work with muzzle; I've tried adding attributes to the DefaultArtifact's Properties-based constructor, but that didn't seem to help.  To unblock the build I'm adding a range limit that doesn't include latest (1.3.9) and will circle back to this later.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r484561625", "createdAt": "2020-09-07T20:32:31Z", "author": {"login": "johnbley"}, "path": "instrumentation/kotlin-coroutines/kotlin-coroutines.gradle", "diffHunk": "@@ -0,0 +1,21 @@\n+ext {\n+  // TODO (trask) currently this is only needed for LambdaGen\n+  //  revisit if we don't end up dropping Java 7\n+  minJavaVersionForTests = JavaVersion.VERSION_1_8\n+}\n+\n+apply from: \"$rootDir/gradle/instrumentation.gradle\"\n+\n+muzzle {\n+  pass {\n+    extraDependency('org.jetbrains.kotlin:kotlin-stdlib-common:1.3.72')\n+    extraDependency('org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.7')\n+    coreJdk()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg5ODY3MA=="}, "originalCommit": {"oid": "9b8346dc04e3b8d9070aa57b066b396b1a772bc4"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMTQzNTYwOnYy", "diffSide": "RIGHT", "path": "instrumentation/kotlin-coroutines/kotlin-coroutines.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwNjozMjoyNVrOHOOjFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNzozMDozOFrOHOnOtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY4MDQ2OA==", "bodyText": "1.4 is not supported?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r484680468", "createdAt": "2020-09-08T06:32:25Z", "author": {"login": "iNikem"}, "path": "instrumentation/kotlin-coroutines/kotlin-coroutines.gradle", "diffHunk": "@@ -0,0 +1,25 @@\n+ext {\n+  // TODO (trask) currently this is only needed for LambdaGen\n+  //  revisit if we don't end up dropping Java 7\n+  minJavaVersionForTests = JavaVersion.VERSION_1_8\n+}\n+\n+apply from: \"$rootDir/gradle/instrumentation.gradle\"\n+apply from: \"$rootDir/gradle/test-with-kotlin.gradle\"\n+muzzle {\n+  pass {\n+    group = 'org.jetbrains.kotlinx'\n+    module = 'kotlinx-coroutines-core'\n+    versions = \"[1.0.0,1.3.8)\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b9c1ea6b96204892332d3a88836e26bd70c581c"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA4NDg1Mw==", "bodyText": "I can't get muzzle to work properly with variants:\nExecution failed for task ':instrumentation:kotlin-coroutines:muzzle-AssertPass-org.jetbrains.kotlinx-kotlinx-coroutines-core-1.3.9'.\n> Could not resolve all files for configuration ':instrumentation:kotlin-coroutines:muzzle-AssertPass-org.jetbrains.kotlinx-kotlinx-coroutines-core-1.3.9'.\n   > Could not resolve org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.9.\n     Required by:\n         project :instrumentation:kotlin-coroutines\n      > Cannot choose between the following variants of org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.9:\n\nI've tried diving into the muzzle plugin and playing with setting various properties on the DefaultArtifact constructor to have it select the right one, but nothing has worked so far...", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r485084853", "createdAt": "2020-09-08T17:30:38Z", "author": {"login": "johnbley"}, "path": "instrumentation/kotlin-coroutines/kotlin-coroutines.gradle", "diffHunk": "@@ -0,0 +1,25 @@\n+ext {\n+  // TODO (trask) currently this is only needed for LambdaGen\n+  //  revisit if we don't end up dropping Java 7\n+  minJavaVersionForTests = JavaVersion.VERSION_1_8\n+}\n+\n+apply from: \"$rootDir/gradle/instrumentation.gradle\"\n+apply from: \"$rootDir/gradle/test-with-kotlin.gradle\"\n+muzzle {\n+  pass {\n+    group = 'org.jetbrains.kotlinx'\n+    module = 'kotlinx-coroutines-core'\n+    versions = \"[1.0.0,1.3.8)\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY4MDQ2OA=="}, "originalCommit": {"oid": "0b9c1ea6b96204892332d3a88836e26bd70c581c"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMTQ0NjcwOnYy", "diffSide": "RIGHT", "path": "instrumentation/kotlin-coroutines/src/main/java/io/opentelemetry/instrumentation/auto/kotlincoroutines/KotlinProbeInstrumentation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwNjozNjoyNVrOHOOp0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwNjozNjoyNVrOHOOp0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY4MjE5Mw==", "bodyText": "As there are a lot of contexts flying around here, I think it would decrease confusion, if these names somehow referenced \"tracing\" or similar context. To distinguish them from coroutine context.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r484682193", "createdAt": "2020-09-08T06:36:25Z", "author": {"login": "iNikem"}, "path": "instrumentation/kotlin-coroutines/src/main/java/io/opentelemetry/instrumentation/auto/kotlincoroutines/KotlinProbeInstrumentation.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.kotlincoroutines;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import kotlin.coroutines.Continuation;\n+import kotlin.coroutines.CoroutineContext;\n+import kotlin.jvm.functions.Function2;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+@AutoService(Instrumenter.class)\n+public class KotlinProbeInstrumentation extends Instrumenter.Default {\n+  /*\n+  Kotlin coroutines with suspend functions are a form of cooperative \"userland\" threading\n+  (you might also know this pattern as \"fibers\" or \"green threading\", where the OS/kernel-level thread\n+  has no idea of switching between tasks.  Fortunately kotlin exposes hooks for the key events: knowing when\n+  coroutines are being created, when they are suspended (swapped out/inactive), and when they are resumed (about to\n+  run again).\n+\n+  Without this instrumentation, heavy concurrency and usage of kotlin suspend functions will break causality\n+  and cause nonsensical span parents/context propagation.  This is because a single JVM thread will run a series of\n+  coroutines in an \"arbitrary\" order, and a context set by coroutine A (which then gets suspended) will be picked up\n+  by completely-unrelated coroutine B.\n+\n+  The basic strategy here is:\n+  1) Use the DebugProbes callbacks to learn about coroutine create, resume, and suspend operations\n+  2) Wrap the creation Coroutine and its Context and use that wrapping to add an extra Context \"key\"\n+  3) Use the callback for resume and suspend to manipulate our context \"key\" whereby an appropriate state\n+     object can be found (tied to the chain of Continutations in the Coroutine).\n+  4) Do our swapping-context dance with that appropriate state\n+  5) Test with highly concurrent well-known span causality and ensure everything looks right.\n+     Without this instrumentation, this test fails with concurrency=2; with this instrumentation,\n+     it passes with concurrency=200.\n+  */\n+\n+  public KotlinProbeInstrumentation() {\n+    super(\"kotlin-coroutines\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"kotlin.coroutines.jvm.internal.DebugProbesKt\");\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        named(\"probeCoroutineCreated\").and(takesArguments(1)),\n+        CoroutineCreatedAdvice.class.getName());\n+    transformers.put(\n+        named(\"probeCoroutineResumed\").and(takesArguments(1)),\n+        CoroutineResumedAdvice.class.getName());\n+    transformers.put(\n+        named(\"probeCoroutineSuspended\").and(takesArguments(1)),\n+        CoroutineSuspendedAdvice.class.getName());\n+    return transformers;\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      \"io.opentelemetry.instrumentation.auto.kotlincoroutines.KotlinProbeInstrumentation$CoroutineWrapper\",\n+      \"io.opentelemetry.instrumentation.auto.kotlincoroutines.KotlinProbeInstrumentation$TraceScopeKey\",\n+      \"io.opentelemetry.instrumentation.auto.kotlincoroutines.KotlinProbeInstrumentation$CoroutineContextWrapper\",\n+    };\n+  }\n+\n+  public static class CoroutineCreatedAdvice {\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void exit(\n+        @Advice.Return(readOnly = false) kotlin.coroutines.Continuation retVal) {\n+      if (!(retVal instanceof CoroutineWrapper)) {\n+        retVal = new CoroutineWrapper(retVal);\n+      }\n+    }\n+  }\n+\n+  public static class CoroutineResumedAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void enter(\n+        @Advice.Argument(0) final kotlin.coroutines.Continuation continuation) {\n+      continuation.getContext().get(TraceScopeKey.INSTANCE);\n+    }\n+  }\n+\n+  public static class CoroutineSuspendedAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void enter(\n+        @Advice.Argument(0) final kotlin.coroutines.Continuation continuation) {\n+      continuation.getContext().minusKey(TraceScopeKey.INSTANCE);\n+    }\n+  }\n+\n+  public static class TraceScopeKey implements CoroutineContext.Key {\n+    public static final TraceScopeKey INSTANCE = new TraceScopeKey();\n+  }\n+\n+  public static class CoroutineWrapper implements kotlin.coroutines.Continuation {\n+    private final Continuation proxy;\n+    private final CoroutineContextWrapper contextWrapper;\n+\n+    public CoroutineWrapper(Continuation proxy) {\n+      this.proxy = proxy;\n+      this.contextWrapper = new CoroutineContextWrapper(proxy.getContext());\n+    }\n+\n+    public String toString() {\n+      return proxy.toString();\n+    }\n+\n+    @NotNull\n+    @Override\n+    public CoroutineContext getContext() {\n+      return contextWrapper;\n+    }\n+\n+    @Override\n+    public void resumeWith(@NotNull Object o) {\n+      proxy.resumeWith(o);\n+    }\n+  }\n+\n+  public static class CoroutineContextWrapper implements CoroutineContext {\n+    private final CoroutineContext proxy;\n+    private Context myContext;\n+    private Context prevContext;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b9c1ea6b96204892332d3a88836e26bd70c581c"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMTQ1MjUyOnYy", "diffSide": "RIGHT", "path": "instrumentation/kotlin-coroutines/src/main/java/io/opentelemetry/instrumentation/auto/kotlincoroutines/KotlinProbeInstrumentation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwNjozODo0M1rOHOOtTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwNjozODo0M1rOHOOtTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY4MzA4Nw==", "bodyText": "Reading javadoc for io.grpc.Context#attach, I think you better doing myContext.detach(prevContext) here. Otherwise you just piling contexts on top of each other...", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r484683087", "createdAt": "2020-09-08T06:38:43Z", "author": {"login": "iNikem"}, "path": "instrumentation/kotlin-coroutines/src/main/java/io/opentelemetry/instrumentation/auto/kotlincoroutines/KotlinProbeInstrumentation.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.kotlincoroutines;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import kotlin.coroutines.Continuation;\n+import kotlin.coroutines.CoroutineContext;\n+import kotlin.jvm.functions.Function2;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+@AutoService(Instrumenter.class)\n+public class KotlinProbeInstrumentation extends Instrumenter.Default {\n+  /*\n+  Kotlin coroutines with suspend functions are a form of cooperative \"userland\" threading\n+  (you might also know this pattern as \"fibers\" or \"green threading\", where the OS/kernel-level thread\n+  has no idea of switching between tasks.  Fortunately kotlin exposes hooks for the key events: knowing when\n+  coroutines are being created, when they are suspended (swapped out/inactive), and when they are resumed (about to\n+  run again).\n+\n+  Without this instrumentation, heavy concurrency and usage of kotlin suspend functions will break causality\n+  and cause nonsensical span parents/context propagation.  This is because a single JVM thread will run a series of\n+  coroutines in an \"arbitrary\" order, and a context set by coroutine A (which then gets suspended) will be picked up\n+  by completely-unrelated coroutine B.\n+\n+  The basic strategy here is:\n+  1) Use the DebugProbes callbacks to learn about coroutine create, resume, and suspend operations\n+  2) Wrap the creation Coroutine and its Context and use that wrapping to add an extra Context \"key\"\n+  3) Use the callback for resume and suspend to manipulate our context \"key\" whereby an appropriate state\n+     object can be found (tied to the chain of Continutations in the Coroutine).\n+  4) Do our swapping-context dance with that appropriate state\n+  5) Test with highly concurrent well-known span causality and ensure everything looks right.\n+     Without this instrumentation, this test fails with concurrency=2; with this instrumentation,\n+     it passes with concurrency=200.\n+  */\n+\n+  public KotlinProbeInstrumentation() {\n+    super(\"kotlin-coroutines\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"kotlin.coroutines.jvm.internal.DebugProbesKt\");\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        named(\"probeCoroutineCreated\").and(takesArguments(1)),\n+        CoroutineCreatedAdvice.class.getName());\n+    transformers.put(\n+        named(\"probeCoroutineResumed\").and(takesArguments(1)),\n+        CoroutineResumedAdvice.class.getName());\n+    transformers.put(\n+        named(\"probeCoroutineSuspended\").and(takesArguments(1)),\n+        CoroutineSuspendedAdvice.class.getName());\n+    return transformers;\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      \"io.opentelemetry.instrumentation.auto.kotlincoroutines.KotlinProbeInstrumentation$CoroutineWrapper\",\n+      \"io.opentelemetry.instrumentation.auto.kotlincoroutines.KotlinProbeInstrumentation$TraceScopeKey\",\n+      \"io.opentelemetry.instrumentation.auto.kotlincoroutines.KotlinProbeInstrumentation$CoroutineContextWrapper\",\n+    };\n+  }\n+\n+  public static class CoroutineCreatedAdvice {\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void exit(\n+        @Advice.Return(readOnly = false) kotlin.coroutines.Continuation retVal) {\n+      if (!(retVal instanceof CoroutineWrapper)) {\n+        retVal = new CoroutineWrapper(retVal);\n+      }\n+    }\n+  }\n+\n+  public static class CoroutineResumedAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void enter(\n+        @Advice.Argument(0) final kotlin.coroutines.Continuation continuation) {\n+      continuation.getContext().get(TraceScopeKey.INSTANCE);\n+    }\n+  }\n+\n+  public static class CoroutineSuspendedAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void enter(\n+        @Advice.Argument(0) final kotlin.coroutines.Continuation continuation) {\n+      continuation.getContext().minusKey(TraceScopeKey.INSTANCE);\n+    }\n+  }\n+\n+  public static class TraceScopeKey implements CoroutineContext.Key {\n+    public static final TraceScopeKey INSTANCE = new TraceScopeKey();\n+  }\n+\n+  public static class CoroutineWrapper implements kotlin.coroutines.Continuation {\n+    private final Continuation proxy;\n+    private final CoroutineContextWrapper contextWrapper;\n+\n+    public CoroutineWrapper(Continuation proxy) {\n+      this.proxy = proxy;\n+      this.contextWrapper = new CoroutineContextWrapper(proxy.getContext());\n+    }\n+\n+    public String toString() {\n+      return proxy.toString();\n+    }\n+\n+    @NotNull\n+    @Override\n+    public CoroutineContext getContext() {\n+      return contextWrapper;\n+    }\n+\n+    @Override\n+    public void resumeWith(@NotNull Object o) {\n+      proxy.resumeWith(o);\n+    }\n+  }\n+\n+  public static class CoroutineContextWrapper implements CoroutineContext {\n+    private final CoroutineContext proxy;\n+    private Context myContext;\n+    private Context prevContext;\n+\n+    public CoroutineContextWrapper(CoroutineContext proxy) {\n+      this.proxy = proxy;\n+      this.myContext = Context.current();\n+    }\n+\n+    @Override\n+    public <R> R fold(R r, @NotNull Function2<? super R, ? super Element, ? extends R> function2) {\n+      return proxy.fold(r, function2);\n+    }\n+\n+    @Nullable\n+    @Override\n+    public <E extends Element> E get(@NotNull Key<E> key) {\n+      if (key == TraceScopeKey.INSTANCE) {\n+        prevContext = myContext.attach();\n+      }\n+      return proxy.get(key);\n+    }\n+\n+    @NotNull\n+    @Override\n+    public CoroutineContext minusKey(@NotNull Key<?> key) {\n+      if (key == TraceScopeKey.INSTANCE) {\n+        myContext = prevContext.attach();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b9c1ea6b96204892332d3a88836e26bd70c581c"}, "originalPosition": 178}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMTQ2MDUzOnYy", "diffSide": "RIGHT", "path": "instrumentation/kotlin-coroutines/src/main/java/io/opentelemetry/instrumentation/auto/kotlincoroutines/KotlinProbeInstrumentation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwNjo0MTozM1rOHOOx7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNjoyMTowOFrOHOkybw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY4NDI3MA==", "bodyText": "Are you sure that get with side effect is a good idea? CoroutineResumedAdvice.enter looks strange as well, when you get a value and then ignore it. May be you can extract context manipulation from get and minusKey and do that directly in advice methods?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r484684270", "createdAt": "2020-09-08T06:41:33Z", "author": {"login": "iNikem"}, "path": "instrumentation/kotlin-coroutines/src/main/java/io/opentelemetry/instrumentation/auto/kotlincoroutines/KotlinProbeInstrumentation.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.kotlincoroutines;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import kotlin.coroutines.Continuation;\n+import kotlin.coroutines.CoroutineContext;\n+import kotlin.jvm.functions.Function2;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+@AutoService(Instrumenter.class)\n+public class KotlinProbeInstrumentation extends Instrumenter.Default {\n+  /*\n+  Kotlin coroutines with suspend functions are a form of cooperative \"userland\" threading\n+  (you might also know this pattern as \"fibers\" or \"green threading\", where the OS/kernel-level thread\n+  has no idea of switching between tasks.  Fortunately kotlin exposes hooks for the key events: knowing when\n+  coroutines are being created, when they are suspended (swapped out/inactive), and when they are resumed (about to\n+  run again).\n+\n+  Without this instrumentation, heavy concurrency and usage of kotlin suspend functions will break causality\n+  and cause nonsensical span parents/context propagation.  This is because a single JVM thread will run a series of\n+  coroutines in an \"arbitrary\" order, and a context set by coroutine A (which then gets suspended) will be picked up\n+  by completely-unrelated coroutine B.\n+\n+  The basic strategy here is:\n+  1) Use the DebugProbes callbacks to learn about coroutine create, resume, and suspend operations\n+  2) Wrap the creation Coroutine and its Context and use that wrapping to add an extra Context \"key\"\n+  3) Use the callback for resume and suspend to manipulate our context \"key\" whereby an appropriate state\n+     object can be found (tied to the chain of Continutations in the Coroutine).\n+  4) Do our swapping-context dance with that appropriate state\n+  5) Test with highly concurrent well-known span causality and ensure everything looks right.\n+     Without this instrumentation, this test fails with concurrency=2; with this instrumentation,\n+     it passes with concurrency=200.\n+  */\n+\n+  public KotlinProbeInstrumentation() {\n+    super(\"kotlin-coroutines\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"kotlin.coroutines.jvm.internal.DebugProbesKt\");\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        named(\"probeCoroutineCreated\").and(takesArguments(1)),\n+        CoroutineCreatedAdvice.class.getName());\n+    transformers.put(\n+        named(\"probeCoroutineResumed\").and(takesArguments(1)),\n+        CoroutineResumedAdvice.class.getName());\n+    transformers.put(\n+        named(\"probeCoroutineSuspended\").and(takesArguments(1)),\n+        CoroutineSuspendedAdvice.class.getName());\n+    return transformers;\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      \"io.opentelemetry.instrumentation.auto.kotlincoroutines.KotlinProbeInstrumentation$CoroutineWrapper\",\n+      \"io.opentelemetry.instrumentation.auto.kotlincoroutines.KotlinProbeInstrumentation$TraceScopeKey\",\n+      \"io.opentelemetry.instrumentation.auto.kotlincoroutines.KotlinProbeInstrumentation$CoroutineContextWrapper\",\n+    };\n+  }\n+\n+  public static class CoroutineCreatedAdvice {\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void exit(\n+        @Advice.Return(readOnly = false) kotlin.coroutines.Continuation retVal) {\n+      if (!(retVal instanceof CoroutineWrapper)) {\n+        retVal = new CoroutineWrapper(retVal);\n+      }\n+    }\n+  }\n+\n+  public static class CoroutineResumedAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void enter(\n+        @Advice.Argument(0) final kotlin.coroutines.Continuation continuation) {\n+      continuation.getContext().get(TraceScopeKey.INSTANCE);\n+    }\n+  }\n+\n+  public static class CoroutineSuspendedAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void enter(\n+        @Advice.Argument(0) final kotlin.coroutines.Continuation continuation) {\n+      continuation.getContext().minusKey(TraceScopeKey.INSTANCE);\n+    }\n+  }\n+\n+  public static class TraceScopeKey implements CoroutineContext.Key {\n+    public static final TraceScopeKey INSTANCE = new TraceScopeKey();\n+  }\n+\n+  public static class CoroutineWrapper implements kotlin.coroutines.Continuation {\n+    private final Continuation proxy;\n+    private final CoroutineContextWrapper contextWrapper;\n+\n+    public CoroutineWrapper(Continuation proxy) {\n+      this.proxy = proxy;\n+      this.contextWrapper = new CoroutineContextWrapper(proxy.getContext());\n+    }\n+\n+    public String toString() {\n+      return proxy.toString();\n+    }\n+\n+    @NotNull\n+    @Override\n+    public CoroutineContext getContext() {\n+      return contextWrapper;\n+    }\n+\n+    @Override\n+    public void resumeWith(@NotNull Object o) {\n+      proxy.resumeWith(o);\n+    }\n+  }\n+\n+  public static class CoroutineContextWrapper implements CoroutineContext {\n+    private final CoroutineContext proxy;\n+    private Context myContext;\n+    private Context prevContext;\n+\n+    public CoroutineContextWrapper(CoroutineContext proxy) {\n+      this.proxy = proxy;\n+      this.myContext = Context.current();\n+    }\n+\n+    @Override\n+    public <R> R fold(R r, @NotNull Function2<? super R, ? super Element, ? extends R> function2) {\n+      return proxy.fold(r, function2);\n+    }\n+\n+    @Nullable\n+    @Override\n+    public <E extends Element> E get(@NotNull Key<E> key) {\n+      if (key == TraceScopeKey.INSTANCE) {\n+        prevContext = myContext.attach();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b9c1ea6b96204892332d3a88836e26bd70c581c"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA0NDg0Nw==", "bodyText": "Good call; I found a cleaner way to do this (get() the context holder as its own value and call tracingSuspend/tracingResume) in a way that keeps the kotlin types happy.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r485044847", "createdAt": "2020-09-08T16:21:08Z", "author": {"login": "johnbley"}, "path": "instrumentation/kotlin-coroutines/src/main/java/io/opentelemetry/instrumentation/auto/kotlincoroutines/KotlinProbeInstrumentation.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.kotlincoroutines;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import kotlin.coroutines.Continuation;\n+import kotlin.coroutines.CoroutineContext;\n+import kotlin.jvm.functions.Function2;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+@AutoService(Instrumenter.class)\n+public class KotlinProbeInstrumentation extends Instrumenter.Default {\n+  /*\n+  Kotlin coroutines with suspend functions are a form of cooperative \"userland\" threading\n+  (you might also know this pattern as \"fibers\" or \"green threading\", where the OS/kernel-level thread\n+  has no idea of switching between tasks.  Fortunately kotlin exposes hooks for the key events: knowing when\n+  coroutines are being created, when they are suspended (swapped out/inactive), and when they are resumed (about to\n+  run again).\n+\n+  Without this instrumentation, heavy concurrency and usage of kotlin suspend functions will break causality\n+  and cause nonsensical span parents/context propagation.  This is because a single JVM thread will run a series of\n+  coroutines in an \"arbitrary\" order, and a context set by coroutine A (which then gets suspended) will be picked up\n+  by completely-unrelated coroutine B.\n+\n+  The basic strategy here is:\n+  1) Use the DebugProbes callbacks to learn about coroutine create, resume, and suspend operations\n+  2) Wrap the creation Coroutine and its Context and use that wrapping to add an extra Context \"key\"\n+  3) Use the callback for resume and suspend to manipulate our context \"key\" whereby an appropriate state\n+     object can be found (tied to the chain of Continutations in the Coroutine).\n+  4) Do our swapping-context dance with that appropriate state\n+  5) Test with highly concurrent well-known span causality and ensure everything looks right.\n+     Without this instrumentation, this test fails with concurrency=2; with this instrumentation,\n+     it passes with concurrency=200.\n+  */\n+\n+  public KotlinProbeInstrumentation() {\n+    super(\"kotlin-coroutines\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"kotlin.coroutines.jvm.internal.DebugProbesKt\");\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        named(\"probeCoroutineCreated\").and(takesArguments(1)),\n+        CoroutineCreatedAdvice.class.getName());\n+    transformers.put(\n+        named(\"probeCoroutineResumed\").and(takesArguments(1)),\n+        CoroutineResumedAdvice.class.getName());\n+    transformers.put(\n+        named(\"probeCoroutineSuspended\").and(takesArguments(1)),\n+        CoroutineSuspendedAdvice.class.getName());\n+    return transformers;\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      \"io.opentelemetry.instrumentation.auto.kotlincoroutines.KotlinProbeInstrumentation$CoroutineWrapper\",\n+      \"io.opentelemetry.instrumentation.auto.kotlincoroutines.KotlinProbeInstrumentation$TraceScopeKey\",\n+      \"io.opentelemetry.instrumentation.auto.kotlincoroutines.KotlinProbeInstrumentation$CoroutineContextWrapper\",\n+    };\n+  }\n+\n+  public static class CoroutineCreatedAdvice {\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void exit(\n+        @Advice.Return(readOnly = false) kotlin.coroutines.Continuation retVal) {\n+      if (!(retVal instanceof CoroutineWrapper)) {\n+        retVal = new CoroutineWrapper(retVal);\n+      }\n+    }\n+  }\n+\n+  public static class CoroutineResumedAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void enter(\n+        @Advice.Argument(0) final kotlin.coroutines.Continuation continuation) {\n+      continuation.getContext().get(TraceScopeKey.INSTANCE);\n+    }\n+  }\n+\n+  public static class CoroutineSuspendedAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void enter(\n+        @Advice.Argument(0) final kotlin.coroutines.Continuation continuation) {\n+      continuation.getContext().minusKey(TraceScopeKey.INSTANCE);\n+    }\n+  }\n+\n+  public static class TraceScopeKey implements CoroutineContext.Key {\n+    public static final TraceScopeKey INSTANCE = new TraceScopeKey();\n+  }\n+\n+  public static class CoroutineWrapper implements kotlin.coroutines.Continuation {\n+    private final Continuation proxy;\n+    private final CoroutineContextWrapper contextWrapper;\n+\n+    public CoroutineWrapper(Continuation proxy) {\n+      this.proxy = proxy;\n+      this.contextWrapper = new CoroutineContextWrapper(proxy.getContext());\n+    }\n+\n+    public String toString() {\n+      return proxy.toString();\n+    }\n+\n+    @NotNull\n+    @Override\n+    public CoroutineContext getContext() {\n+      return contextWrapper;\n+    }\n+\n+    @Override\n+    public void resumeWith(@NotNull Object o) {\n+      proxy.resumeWith(o);\n+    }\n+  }\n+\n+  public static class CoroutineContextWrapper implements CoroutineContext {\n+    private final CoroutineContext proxy;\n+    private Context myContext;\n+    private Context prevContext;\n+\n+    public CoroutineContextWrapper(CoroutineContext proxy) {\n+      this.proxy = proxy;\n+      this.myContext = Context.current();\n+    }\n+\n+    @Override\n+    public <R> R fold(R r, @NotNull Function2<? super R, ? super Element, ? extends R> function2) {\n+      return proxy.fold(r, function2);\n+    }\n+\n+    @Nullable\n+    @Override\n+    public <E extends Element> E get(@NotNull Key<E> key) {\n+      if (key == TraceScopeKey.INSTANCE) {\n+        prevContext = myContext.attach();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY4NDI3MA=="}, "originalCommit": {"oid": "0b9c1ea6b96204892332d3a88836e26bd70c581c"}, "originalPosition": 169}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMTQ2NzQ4OnYy", "diffSide": "RIGHT", "path": "instrumentation/kotlin-coroutines/src/test/kotlin/KotlinCoroutineTests.kt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwNjo0Mzo1N1rOHOO18A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNjowNTowNlrOHOkLDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY4NTI5Ng==", "bodyText": "Why do you need scope and delay here?", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r484685296", "createdAt": "2020-09-08T06:43:57Z", "author": {"login": "iNikem"}, "path": "instrumentation/kotlin-coroutines/src/test/kotlin/KotlinCoroutineTests.kt", "diffHunk": "@@ -138,6 +140,54 @@ class KotlinCoroutineTests(private val dispatcher: CoroutineDispatcher) {\n     }\n   }\n \n+  fun launchConcurrentSuspendFunctions(numIters: Int) {\n+    runBlocking {\n+      for (i in 0 until numIters) {\n+        GlobalScope.launch {\n+          a(i.toLong())\n+        }\n+        GlobalScope.launch {\n+          b(i.toLong())\n+        }\n+      }\n+    }\n+  }\n+\n+  suspend fun a(iter: Long) {\n+    var span = tracer.spanBuilder(\"a\").startSpan()\n+    span.setAttribute(\"iter\", iter)\n+    var scope = currentContextWith(span)\n+    delay(10)\n+    a2(iter)\n+    scope.close()\n+    span.end()\n+  }\n+  suspend fun a2(iter: Long) {\n+    var span = tracer.spanBuilder(\"a2\").startSpan()\n+    span.setAttribute(\"iter\", iter)\n+    var scope = currentContextWith(span)\n+    delay(10)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b9c1ea6b96204892332d3a88836e26bd70c581c"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAzNDc2Ng==", "bodyText": "The delay is what forces the coroutine concurrency to be \"pessimal\" from a tracing perspective, switching frequently on the same Java thread among multiple coroutines and/or passing coroutines to other threads.  The scopes around delay are also there to stress test the system - before this instrumentation, we could easily see nonsensical traces like a2->b.", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r485034766", "createdAt": "2020-09-08T16:05:06Z", "author": {"login": "johnbley"}, "path": "instrumentation/kotlin-coroutines/src/test/kotlin/KotlinCoroutineTests.kt", "diffHunk": "@@ -138,6 +140,54 @@ class KotlinCoroutineTests(private val dispatcher: CoroutineDispatcher) {\n     }\n   }\n \n+  fun launchConcurrentSuspendFunctions(numIters: Int) {\n+    runBlocking {\n+      for (i in 0 until numIters) {\n+        GlobalScope.launch {\n+          a(i.toLong())\n+        }\n+        GlobalScope.launch {\n+          b(i.toLong())\n+        }\n+      }\n+    }\n+  }\n+\n+  suspend fun a(iter: Long) {\n+    var span = tracer.spanBuilder(\"a\").startSpan()\n+    span.setAttribute(\"iter\", iter)\n+    var scope = currentContextWith(span)\n+    delay(10)\n+    a2(iter)\n+    scope.close()\n+    span.end()\n+  }\n+  suspend fun a2(iter: Long) {\n+    var span = tracer.spanBuilder(\"a2\").startSpan()\n+    span.setAttribute(\"iter\", iter)\n+    var scope = currentContextWith(span)\n+    delay(10)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY4NTI5Ng=="}, "originalCommit": {"oid": "0b9c1ea6b96204892332d3a88836e26bd70c581c"}, "originalPosition": 45}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4878, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}