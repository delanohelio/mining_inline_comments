{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxMzk0NTc1", "number": 2545, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMjozOTo0NFrODwYz0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMlQxMzo0MTozNlrODxDcvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMDY0NzIwOnYy", "diffSide": "RIGHT", "path": "modules/r2dbc/src/main/java/org/testcontainers/r2dbc/ConnectionPublisher.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMjozOTo0NFrOGDW7FA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMzowMTowN1rOGDXpjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3NDQ4NA==", "bodyText": "might be a case when\nfuture just completed ->\nvoid enter() { publisher.subscribe(this); } executed but subscription may be delivered later (See https://github.com/reactive-streams/reactive-streams-jvm/issues/486 for the clarification)\nso the next cancel which is waiting on the synchronized block will end-up with NPE.\n\nThe simples solution for that is to add flag and synchronization between request cancel and onsubscriber to ensure we are not ending up with NPE if the subscription has not arrived yet", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r406174484", "createdAt": "2020-04-09T12:39:44Z", "author": {"login": "OlegDokuka"}, "path": "modules/r2dbc/src/main/java/org/testcontainers/r2dbc/ConnectionPublisher.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package org.testcontainers.r2dbc;\n+\n+import io.r2dbc.spi.Connection;\n+import io.r2dbc.spi.ConnectionFactory;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Supplier;\n+\n+class ConnectionPublisher implements Publisher<Connection> {\n+\n+    private final Supplier<CompletableFuture<ConnectionFactory>> futureSupplier;\n+\n+    ConnectionPublisher(Supplier<CompletableFuture<ConnectionFactory>> futureSupplier) {\n+        this.futureSupplier = futureSupplier;\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super Connection> actual) {\n+        actual.onSubscribe(new StateMachineSubscription(actual));\n+    }\n+\n+    /**\n+     * Design notes:\n+     * - ConnectionPublisher is Mono-like (0..1), the request amount is ignored\n+     * - given the testing nature, the performance requirements are less strict\n+     * - \"synchronized\" is used to avoid races\n+     * - Reactive Streams spec violations are not checked (e.g. non-positive request)\n+     */\n+    private class StateMachineSubscription implements Subscription {\n+\n+        private final Subscriber<? super Connection> actual;\n+\n+        Subscription subscriptionState;\n+\n+        StateMachineSubscription(Subscriber<? super Connection> actual) {\n+            this.actual = actual;\n+            subscriptionState = new WaitRequestSubscriptionState();\n+        }\n+\n+        @Override\n+        public synchronized void request(long n) {\n+            subscriptionState.request(n);\n+        }\n+\n+        @Override\n+        public synchronized void cancel() {\n+            subscriptionState.cancel();\n+        }\n+\n+        synchronized void transitionTo(SubscriptionState newState) {\n+            subscriptionState = newState;\n+            newState.enter();\n+        }\n+\n+        abstract class SubscriptionState implements Subscription {\n+            void enter() {\n+            }\n+        }\n+\n+        class WaitRequestSubscriptionState extends SubscriptionState {\n+\n+            @Override\n+            public void request(long n) {\n+                transitionTo(new WaitFutureCompletionSubscriptionState());\n+            }\n+\n+            @Override\n+            public void cancel() {\n+            }\n+        }\n+\n+        class WaitFutureCompletionSubscriptionState extends SubscriptionState {\n+\n+            private CompletableFuture<ConnectionFactory> future;\n+\n+            @Override\n+            void enter() {\n+                this.future = futureSupplier.get();\n+\n+                future.whenComplete((connectionFactory, e) -> {\n+                    if (e != null) {\n+                        actual.onSubscribe(EmptySubscription.INSTANCE);\n+                        actual.onError(e);\n+                        return;\n+                    }\n+\n+                    Publisher<? extends Connection> publisher = connectionFactory.create();\n+                    transitionTo(new ProxySubscriptionState(publisher));\n+                });\n+            }\n+\n+            @Override\n+            public void request(long n) {\n+            }\n+\n+            @Override\n+            public void cancel() {\n+                future.cancel(true);\n+            }\n+        }\n+\n+        class ProxySubscriptionState extends SubscriptionState implements Subscriber<Connection> {\n+\n+            private final Publisher<? extends Connection> publisher;\n+\n+            private Subscription s;\n+\n+            ProxySubscriptionState(Publisher<? extends Connection> publisher) {\n+                this.publisher = publisher;\n+            }\n+\n+            @Override\n+            void enter() {\n+                publisher.subscribe(this);\n+            }\n+\n+            @Override\n+            public void request(long n) {\n+                // Ignore\n+            }\n+\n+            @Override\n+            public void cancel() {\n+                s.cancel();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98515fc93fbfc6292bf224d0640fe7fe61e6041e"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE4NjM4Mw==", "bodyText": "good catch", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r406186383", "createdAt": "2020-04-09T13:01:07Z", "author": {"login": "simonbasle"}, "path": "modules/r2dbc/src/main/java/org/testcontainers/r2dbc/ConnectionPublisher.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package org.testcontainers.r2dbc;\n+\n+import io.r2dbc.spi.Connection;\n+import io.r2dbc.spi.ConnectionFactory;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Supplier;\n+\n+class ConnectionPublisher implements Publisher<Connection> {\n+\n+    private final Supplier<CompletableFuture<ConnectionFactory>> futureSupplier;\n+\n+    ConnectionPublisher(Supplier<CompletableFuture<ConnectionFactory>> futureSupplier) {\n+        this.futureSupplier = futureSupplier;\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super Connection> actual) {\n+        actual.onSubscribe(new StateMachineSubscription(actual));\n+    }\n+\n+    /**\n+     * Design notes:\n+     * - ConnectionPublisher is Mono-like (0..1), the request amount is ignored\n+     * - given the testing nature, the performance requirements are less strict\n+     * - \"synchronized\" is used to avoid races\n+     * - Reactive Streams spec violations are not checked (e.g. non-positive request)\n+     */\n+    private class StateMachineSubscription implements Subscription {\n+\n+        private final Subscriber<? super Connection> actual;\n+\n+        Subscription subscriptionState;\n+\n+        StateMachineSubscription(Subscriber<? super Connection> actual) {\n+            this.actual = actual;\n+            subscriptionState = new WaitRequestSubscriptionState();\n+        }\n+\n+        @Override\n+        public synchronized void request(long n) {\n+            subscriptionState.request(n);\n+        }\n+\n+        @Override\n+        public synchronized void cancel() {\n+            subscriptionState.cancel();\n+        }\n+\n+        synchronized void transitionTo(SubscriptionState newState) {\n+            subscriptionState = newState;\n+            newState.enter();\n+        }\n+\n+        abstract class SubscriptionState implements Subscription {\n+            void enter() {\n+            }\n+        }\n+\n+        class WaitRequestSubscriptionState extends SubscriptionState {\n+\n+            @Override\n+            public void request(long n) {\n+                transitionTo(new WaitFutureCompletionSubscriptionState());\n+            }\n+\n+            @Override\n+            public void cancel() {\n+            }\n+        }\n+\n+        class WaitFutureCompletionSubscriptionState extends SubscriptionState {\n+\n+            private CompletableFuture<ConnectionFactory> future;\n+\n+            @Override\n+            void enter() {\n+                this.future = futureSupplier.get();\n+\n+                future.whenComplete((connectionFactory, e) -> {\n+                    if (e != null) {\n+                        actual.onSubscribe(EmptySubscription.INSTANCE);\n+                        actual.onError(e);\n+                        return;\n+                    }\n+\n+                    Publisher<? extends Connection> publisher = connectionFactory.create();\n+                    transitionTo(new ProxySubscriptionState(publisher));\n+                });\n+            }\n+\n+            @Override\n+            public void request(long n) {\n+            }\n+\n+            @Override\n+            public void cancel() {\n+                future.cancel(true);\n+            }\n+        }\n+\n+        class ProxySubscriptionState extends SubscriptionState implements Subscriber<Connection> {\n+\n+            private final Publisher<? extends Connection> publisher;\n+\n+            private Subscription s;\n+\n+            ProxySubscriptionState(Publisher<? extends Connection> publisher) {\n+                this.publisher = publisher;\n+            }\n+\n+            @Override\n+            void enter() {\n+                publisher.subscribe(this);\n+            }\n+\n+            @Override\n+            public void request(long n) {\n+                // Ignore\n+            }\n+\n+            @Override\n+            public void cancel() {\n+                s.cancel();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3NDQ4NA=="}, "originalCommit": {"oid": "98515fc93fbfc6292bf224d0640fe7fe61e6041e"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMDY1MTIzOnYy", "diffSide": "RIGHT", "path": "modules/r2dbc/src/main/java/org/testcontainers/r2dbc/ConnectionPublisher.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMjo0MDo1NFrOGDW9hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMzo1NDoxOFrOGDZx-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3NTExMQ==", "bodyText": "@mp911de does the connection factory absolutely guarantees a Publisher with at most one onNext(Connection)? if not, @bsideup it might be worth it to consider guarding against flux-like publishers by adding a boolean guard in onNext (doesn't even have to be a volatile, since only onNext would read/write it)", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r406175111", "createdAt": "2020-04-09T12:40:54Z", "author": {"login": "simonbasle"}, "path": "modules/r2dbc/src/main/java/org/testcontainers/r2dbc/ConnectionPublisher.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package org.testcontainers.r2dbc;\n+\n+import io.r2dbc.spi.Connection;\n+import io.r2dbc.spi.ConnectionFactory;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Supplier;\n+\n+class ConnectionPublisher implements Publisher<Connection> {\n+\n+    private final Supplier<CompletableFuture<ConnectionFactory>> futureSupplier;\n+\n+    ConnectionPublisher(Supplier<CompletableFuture<ConnectionFactory>> futureSupplier) {\n+        this.futureSupplier = futureSupplier;\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super Connection> actual) {\n+        actual.onSubscribe(new StateMachineSubscription(actual));\n+    }\n+\n+    /**\n+     * Design notes:\n+     * - ConnectionPublisher is Mono-like (0..1), the request amount is ignored\n+     * - given the testing nature, the performance requirements are less strict\n+     * - \"synchronized\" is used to avoid races\n+     * - Reactive Streams spec violations are not checked (e.g. non-positive request)\n+     */\n+    private class StateMachineSubscription implements Subscription {\n+\n+        private final Subscriber<? super Connection> actual;\n+\n+        Subscription subscriptionState;\n+\n+        StateMachineSubscription(Subscriber<? super Connection> actual) {\n+            this.actual = actual;\n+            subscriptionState = new WaitRequestSubscriptionState();\n+        }\n+\n+        @Override\n+        public synchronized void request(long n) {\n+            subscriptionState.request(n);\n+        }\n+\n+        @Override\n+        public synchronized void cancel() {\n+            subscriptionState.cancel();\n+        }\n+\n+        synchronized void transitionTo(SubscriptionState newState) {\n+            subscriptionState = newState;\n+            newState.enter();\n+        }\n+\n+        abstract class SubscriptionState implements Subscription {\n+            void enter() {\n+            }\n+        }\n+\n+        class WaitRequestSubscriptionState extends SubscriptionState {\n+\n+            @Override\n+            public void request(long n) {\n+                transitionTo(new WaitFutureCompletionSubscriptionState());\n+            }\n+\n+            @Override\n+            public void cancel() {\n+            }\n+        }\n+\n+        class WaitFutureCompletionSubscriptionState extends SubscriptionState {\n+\n+            private CompletableFuture<ConnectionFactory> future;\n+\n+            @Override\n+            void enter() {\n+                this.future = futureSupplier.get();\n+\n+                future.whenComplete((connectionFactory, e) -> {\n+                    if (e != null) {\n+                        actual.onSubscribe(EmptySubscription.INSTANCE);\n+                        actual.onError(e);\n+                        return;\n+                    }\n+\n+                    Publisher<? extends Connection> publisher = connectionFactory.create();\n+                    transitionTo(new ProxySubscriptionState(publisher));\n+                });\n+            }\n+\n+            @Override\n+            public void request(long n) {\n+            }\n+\n+            @Override\n+            public void cancel() {\n+                future.cancel(true);\n+            }\n+        }\n+\n+        class ProxySubscriptionState extends SubscriptionState implements Subscriber<Connection> {\n+\n+            private final Publisher<? extends Connection> publisher;\n+\n+            private Subscription s;\n+\n+            ProxySubscriptionState(Publisher<? extends Connection> publisher) {\n+                this.publisher = publisher;\n+            }\n+\n+            @Override\n+            void enter() {\n+                publisher.subscribe(this);\n+            }\n+\n+            @Override\n+            public void request(long n) {\n+                // Ignore\n+            }\n+\n+            @Override\n+            public void cancel() {\n+                s.cancel();\n+            }\n+\n+            @Override\n+            public void onSubscribe(Subscription s) {\n+                this.s = s;\n+                s.request(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98515fc93fbfc6292bf224d0640fe7fe61e6041e"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE4NTUyMw==", "bodyText": "it does (checked with Mark), yes. See the design notes in the Javadoc", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r406185523", "createdAt": "2020-04-09T12:59:38Z", "author": {"login": "bsideup"}, "path": "modules/r2dbc/src/main/java/org/testcontainers/r2dbc/ConnectionPublisher.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package org.testcontainers.r2dbc;\n+\n+import io.r2dbc.spi.Connection;\n+import io.r2dbc.spi.ConnectionFactory;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Supplier;\n+\n+class ConnectionPublisher implements Publisher<Connection> {\n+\n+    private final Supplier<CompletableFuture<ConnectionFactory>> futureSupplier;\n+\n+    ConnectionPublisher(Supplier<CompletableFuture<ConnectionFactory>> futureSupplier) {\n+        this.futureSupplier = futureSupplier;\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super Connection> actual) {\n+        actual.onSubscribe(new StateMachineSubscription(actual));\n+    }\n+\n+    /**\n+     * Design notes:\n+     * - ConnectionPublisher is Mono-like (0..1), the request amount is ignored\n+     * - given the testing nature, the performance requirements are less strict\n+     * - \"synchronized\" is used to avoid races\n+     * - Reactive Streams spec violations are not checked (e.g. non-positive request)\n+     */\n+    private class StateMachineSubscription implements Subscription {\n+\n+        private final Subscriber<? super Connection> actual;\n+\n+        Subscription subscriptionState;\n+\n+        StateMachineSubscription(Subscriber<? super Connection> actual) {\n+            this.actual = actual;\n+            subscriptionState = new WaitRequestSubscriptionState();\n+        }\n+\n+        @Override\n+        public synchronized void request(long n) {\n+            subscriptionState.request(n);\n+        }\n+\n+        @Override\n+        public synchronized void cancel() {\n+            subscriptionState.cancel();\n+        }\n+\n+        synchronized void transitionTo(SubscriptionState newState) {\n+            subscriptionState = newState;\n+            newState.enter();\n+        }\n+\n+        abstract class SubscriptionState implements Subscription {\n+            void enter() {\n+            }\n+        }\n+\n+        class WaitRequestSubscriptionState extends SubscriptionState {\n+\n+            @Override\n+            public void request(long n) {\n+                transitionTo(new WaitFutureCompletionSubscriptionState());\n+            }\n+\n+            @Override\n+            public void cancel() {\n+            }\n+        }\n+\n+        class WaitFutureCompletionSubscriptionState extends SubscriptionState {\n+\n+            private CompletableFuture<ConnectionFactory> future;\n+\n+            @Override\n+            void enter() {\n+                this.future = futureSupplier.get();\n+\n+                future.whenComplete((connectionFactory, e) -> {\n+                    if (e != null) {\n+                        actual.onSubscribe(EmptySubscription.INSTANCE);\n+                        actual.onError(e);\n+                        return;\n+                    }\n+\n+                    Publisher<? extends Connection> publisher = connectionFactory.create();\n+                    transitionTo(new ProxySubscriptionState(publisher));\n+                });\n+            }\n+\n+            @Override\n+            public void request(long n) {\n+            }\n+\n+            @Override\n+            public void cancel() {\n+                future.cancel(true);\n+            }\n+        }\n+\n+        class ProxySubscriptionState extends SubscriptionState implements Subscriber<Connection> {\n+\n+            private final Publisher<? extends Connection> publisher;\n+\n+            private Subscription s;\n+\n+            ProxySubscriptionState(Publisher<? extends Connection> publisher) {\n+                this.publisher = publisher;\n+            }\n+\n+            @Override\n+            void enter() {\n+                publisher.subscribe(this);\n+            }\n+\n+            @Override\n+            public void request(long n) {\n+                // Ignore\n+            }\n+\n+            @Override\n+            public void cancel() {\n+                s.cancel();\n+            }\n+\n+            @Override\n+            public void onSubscribe(Subscription s) {\n+                this.s = s;\n+                s.request(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3NTExMQ=="}, "originalCommit": {"oid": "98515fc93fbfc6292bf224d0640fe7fe61e6041e"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE4NzM3Mg==", "bodyText": "it was unclear to me that comment was about the factory, since it mentions ConnectionPublisher (the current class). I would instead phrase it as Publisher<Connection> provided by R2DBC / the connectionFactory is guaranteed to emit at most one item", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r406187372", "createdAt": "2020-04-09T13:02:57Z", "author": {"login": "simonbasle"}, "path": "modules/r2dbc/src/main/java/org/testcontainers/r2dbc/ConnectionPublisher.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package org.testcontainers.r2dbc;\n+\n+import io.r2dbc.spi.Connection;\n+import io.r2dbc.spi.ConnectionFactory;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Supplier;\n+\n+class ConnectionPublisher implements Publisher<Connection> {\n+\n+    private final Supplier<CompletableFuture<ConnectionFactory>> futureSupplier;\n+\n+    ConnectionPublisher(Supplier<CompletableFuture<ConnectionFactory>> futureSupplier) {\n+        this.futureSupplier = futureSupplier;\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super Connection> actual) {\n+        actual.onSubscribe(new StateMachineSubscription(actual));\n+    }\n+\n+    /**\n+     * Design notes:\n+     * - ConnectionPublisher is Mono-like (0..1), the request amount is ignored\n+     * - given the testing nature, the performance requirements are less strict\n+     * - \"synchronized\" is used to avoid races\n+     * - Reactive Streams spec violations are not checked (e.g. non-positive request)\n+     */\n+    private class StateMachineSubscription implements Subscription {\n+\n+        private final Subscriber<? super Connection> actual;\n+\n+        Subscription subscriptionState;\n+\n+        StateMachineSubscription(Subscriber<? super Connection> actual) {\n+            this.actual = actual;\n+            subscriptionState = new WaitRequestSubscriptionState();\n+        }\n+\n+        @Override\n+        public synchronized void request(long n) {\n+            subscriptionState.request(n);\n+        }\n+\n+        @Override\n+        public synchronized void cancel() {\n+            subscriptionState.cancel();\n+        }\n+\n+        synchronized void transitionTo(SubscriptionState newState) {\n+            subscriptionState = newState;\n+            newState.enter();\n+        }\n+\n+        abstract class SubscriptionState implements Subscription {\n+            void enter() {\n+            }\n+        }\n+\n+        class WaitRequestSubscriptionState extends SubscriptionState {\n+\n+            @Override\n+            public void request(long n) {\n+                transitionTo(new WaitFutureCompletionSubscriptionState());\n+            }\n+\n+            @Override\n+            public void cancel() {\n+            }\n+        }\n+\n+        class WaitFutureCompletionSubscriptionState extends SubscriptionState {\n+\n+            private CompletableFuture<ConnectionFactory> future;\n+\n+            @Override\n+            void enter() {\n+                this.future = futureSupplier.get();\n+\n+                future.whenComplete((connectionFactory, e) -> {\n+                    if (e != null) {\n+                        actual.onSubscribe(EmptySubscription.INSTANCE);\n+                        actual.onError(e);\n+                        return;\n+                    }\n+\n+                    Publisher<? extends Connection> publisher = connectionFactory.create();\n+                    transitionTo(new ProxySubscriptionState(publisher));\n+                });\n+            }\n+\n+            @Override\n+            public void request(long n) {\n+            }\n+\n+            @Override\n+            public void cancel() {\n+                future.cancel(true);\n+            }\n+        }\n+\n+        class ProxySubscriptionState extends SubscriptionState implements Subscriber<Connection> {\n+\n+            private final Publisher<? extends Connection> publisher;\n+\n+            private Subscription s;\n+\n+            ProxySubscriptionState(Publisher<? extends Connection> publisher) {\n+                this.publisher = publisher;\n+            }\n+\n+            @Override\n+            void enter() {\n+                publisher.subscribe(this);\n+            }\n+\n+            @Override\n+            public void request(long n) {\n+                // Ignore\n+            }\n+\n+            @Override\n+            public void cancel() {\n+                s.cancel();\n+            }\n+\n+            @Override\n+            public void onSubscribe(Subscription s) {\n+                this.s = s;\n+                s.request(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3NTExMQ=="}, "originalCommit": {"oid": "98515fc93fbfc6292bf224d0640fe7fe61e6041e"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIyMTMwNA==", "bodyText": "connectionFactory implements single element or failure semantics. Completion without an element or emitting multiple items violates the spec. It's a cold publisher that should allow multiple subscriptions.", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r406221304", "createdAt": "2020-04-09T13:54:18Z", "author": {"login": "mp911de"}, "path": "modules/r2dbc/src/main/java/org/testcontainers/r2dbc/ConnectionPublisher.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package org.testcontainers.r2dbc;\n+\n+import io.r2dbc.spi.Connection;\n+import io.r2dbc.spi.ConnectionFactory;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Supplier;\n+\n+class ConnectionPublisher implements Publisher<Connection> {\n+\n+    private final Supplier<CompletableFuture<ConnectionFactory>> futureSupplier;\n+\n+    ConnectionPublisher(Supplier<CompletableFuture<ConnectionFactory>> futureSupplier) {\n+        this.futureSupplier = futureSupplier;\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super Connection> actual) {\n+        actual.onSubscribe(new StateMachineSubscription(actual));\n+    }\n+\n+    /**\n+     * Design notes:\n+     * - ConnectionPublisher is Mono-like (0..1), the request amount is ignored\n+     * - given the testing nature, the performance requirements are less strict\n+     * - \"synchronized\" is used to avoid races\n+     * - Reactive Streams spec violations are not checked (e.g. non-positive request)\n+     */\n+    private class StateMachineSubscription implements Subscription {\n+\n+        private final Subscriber<? super Connection> actual;\n+\n+        Subscription subscriptionState;\n+\n+        StateMachineSubscription(Subscriber<? super Connection> actual) {\n+            this.actual = actual;\n+            subscriptionState = new WaitRequestSubscriptionState();\n+        }\n+\n+        @Override\n+        public synchronized void request(long n) {\n+            subscriptionState.request(n);\n+        }\n+\n+        @Override\n+        public synchronized void cancel() {\n+            subscriptionState.cancel();\n+        }\n+\n+        synchronized void transitionTo(SubscriptionState newState) {\n+            subscriptionState = newState;\n+            newState.enter();\n+        }\n+\n+        abstract class SubscriptionState implements Subscription {\n+            void enter() {\n+            }\n+        }\n+\n+        class WaitRequestSubscriptionState extends SubscriptionState {\n+\n+            @Override\n+            public void request(long n) {\n+                transitionTo(new WaitFutureCompletionSubscriptionState());\n+            }\n+\n+            @Override\n+            public void cancel() {\n+            }\n+        }\n+\n+        class WaitFutureCompletionSubscriptionState extends SubscriptionState {\n+\n+            private CompletableFuture<ConnectionFactory> future;\n+\n+            @Override\n+            void enter() {\n+                this.future = futureSupplier.get();\n+\n+                future.whenComplete((connectionFactory, e) -> {\n+                    if (e != null) {\n+                        actual.onSubscribe(EmptySubscription.INSTANCE);\n+                        actual.onError(e);\n+                        return;\n+                    }\n+\n+                    Publisher<? extends Connection> publisher = connectionFactory.create();\n+                    transitionTo(new ProxySubscriptionState(publisher));\n+                });\n+            }\n+\n+            @Override\n+            public void request(long n) {\n+            }\n+\n+            @Override\n+            public void cancel() {\n+                future.cancel(true);\n+            }\n+        }\n+\n+        class ProxySubscriptionState extends SubscriptionState implements Subscriber<Connection> {\n+\n+            private final Publisher<? extends Connection> publisher;\n+\n+            private Subscription s;\n+\n+            ProxySubscriptionState(Publisher<? extends Connection> publisher) {\n+                this.publisher = publisher;\n+            }\n+\n+            @Override\n+            void enter() {\n+                publisher.subscribe(this);\n+            }\n+\n+            @Override\n+            public void request(long n) {\n+                // Ignore\n+            }\n+\n+            @Override\n+            public void cancel() {\n+                s.cancel();\n+            }\n+\n+            @Override\n+            public void onSubscribe(Subscription s) {\n+                this.s = s;\n+                s.request(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3NTExMQ=="}, "originalCommit": {"oid": "98515fc93fbfc6292bf224d0640fe7fe61e6041e"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMDY1MjE0OnYy", "diffSide": "RIGHT", "path": "modules/r2dbc/src/main/java/org/testcontainers/r2dbc/ConnectionPublisher.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMjo0MToxM1rOGDW-IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMjo0MToxM1rOGDW-IQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3NTI2NQ==", "bodyText": "here we have to have a flag, e.g (canceled) and if so, immediately call s.cancel on the given one", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r406175265", "createdAt": "2020-04-09T12:41:13Z", "author": {"login": "OlegDokuka"}, "path": "modules/r2dbc/src/main/java/org/testcontainers/r2dbc/ConnectionPublisher.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package org.testcontainers.r2dbc;\n+\n+import io.r2dbc.spi.Connection;\n+import io.r2dbc.spi.ConnectionFactory;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Supplier;\n+\n+class ConnectionPublisher implements Publisher<Connection> {\n+\n+    private final Supplier<CompletableFuture<ConnectionFactory>> futureSupplier;\n+\n+    ConnectionPublisher(Supplier<CompletableFuture<ConnectionFactory>> futureSupplier) {\n+        this.futureSupplier = futureSupplier;\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super Connection> actual) {\n+        actual.onSubscribe(new StateMachineSubscription(actual));\n+    }\n+\n+    /**\n+     * Design notes:\n+     * - ConnectionPublisher is Mono-like (0..1), the request amount is ignored\n+     * - given the testing nature, the performance requirements are less strict\n+     * - \"synchronized\" is used to avoid races\n+     * - Reactive Streams spec violations are not checked (e.g. non-positive request)\n+     */\n+    private class StateMachineSubscription implements Subscription {\n+\n+        private final Subscriber<? super Connection> actual;\n+\n+        Subscription subscriptionState;\n+\n+        StateMachineSubscription(Subscriber<? super Connection> actual) {\n+            this.actual = actual;\n+            subscriptionState = new WaitRequestSubscriptionState();\n+        }\n+\n+        @Override\n+        public synchronized void request(long n) {\n+            subscriptionState.request(n);\n+        }\n+\n+        @Override\n+        public synchronized void cancel() {\n+            subscriptionState.cancel();\n+        }\n+\n+        synchronized void transitionTo(SubscriptionState newState) {\n+            subscriptionState = newState;\n+            newState.enter();\n+        }\n+\n+        abstract class SubscriptionState implements Subscription {\n+            void enter() {\n+            }\n+        }\n+\n+        class WaitRequestSubscriptionState extends SubscriptionState {\n+\n+            @Override\n+            public void request(long n) {\n+                transitionTo(new WaitFutureCompletionSubscriptionState());\n+            }\n+\n+            @Override\n+            public void cancel() {\n+            }\n+        }\n+\n+        class WaitFutureCompletionSubscriptionState extends SubscriptionState {\n+\n+            private CompletableFuture<ConnectionFactory> future;\n+\n+            @Override\n+            void enter() {\n+                this.future = futureSupplier.get();\n+\n+                future.whenComplete((connectionFactory, e) -> {\n+                    if (e != null) {\n+                        actual.onSubscribe(EmptySubscription.INSTANCE);\n+                        actual.onError(e);\n+                        return;\n+                    }\n+\n+                    Publisher<? extends Connection> publisher = connectionFactory.create();\n+                    transitionTo(new ProxySubscriptionState(publisher));\n+                });\n+            }\n+\n+            @Override\n+            public void request(long n) {\n+            }\n+\n+            @Override\n+            public void cancel() {\n+                future.cancel(true);\n+            }\n+        }\n+\n+        class ProxySubscriptionState extends SubscriptionState implements Subscriber<Connection> {\n+\n+            private final Publisher<? extends Connection> publisher;\n+\n+            private Subscription s;\n+\n+            ProxySubscriptionState(Publisher<? extends Connection> publisher) {\n+                this.publisher = publisher;\n+            }\n+\n+            @Override\n+            void enter() {\n+                publisher.subscribe(this);\n+            }\n+\n+            @Override\n+            public void request(long n) {\n+                // Ignore\n+            }\n+\n+            @Override\n+            public void cancel() {\n+                s.cancel();\n+            }\n+\n+            @Override\n+            public void onSubscribe(Subscription s) {\n+                this.s = s;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98515fc93fbfc6292bf224d0640fe7fe61e6041e"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMDY5MDI5OnYy", "diffSide": "RIGHT", "path": "modules/r2dbc/src/main/java/org/testcontainers/r2dbc/ConnectionPublisher.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMjo1MjoxOVrOGDXV2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMzowMToyMlrOGDXqDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE4MTMzNg==", "bodyText": "that pattern was a bit harder for me to follow because of the habit of seeing Subscription as self-sufficient and thus aggressively guarded, but after review it looks correct. I feel it wouldn't be too hard to collapse the various SubscriptionState into the StateMachineSubscription itself and deal with int/enum based states for transitions, but eh as long as it is correct...", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r406181336", "createdAt": "2020-04-09T12:52:19Z", "author": {"login": "simonbasle"}, "path": "modules/r2dbc/src/main/java/org/testcontainers/r2dbc/ConnectionPublisher.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package org.testcontainers.r2dbc;\n+\n+import io.r2dbc.spi.Connection;\n+import io.r2dbc.spi.ConnectionFactory;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Supplier;\n+\n+class ConnectionPublisher implements Publisher<Connection> {\n+\n+    private final Supplier<CompletableFuture<ConnectionFactory>> futureSupplier;\n+\n+    ConnectionPublisher(Supplier<CompletableFuture<ConnectionFactory>> futureSupplier) {\n+        this.futureSupplier = futureSupplier;\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super Connection> actual) {\n+        actual.onSubscribe(new StateMachineSubscription(actual));\n+    }\n+\n+    /**\n+     * Design notes:\n+     * - ConnectionPublisher is Mono-like (0..1), the request amount is ignored\n+     * - given the testing nature, the performance requirements are less strict\n+     * - \"synchronized\" is used to avoid races\n+     * - Reactive Streams spec violations are not checked (e.g. non-positive request)\n+     */\n+    private class StateMachineSubscription implements Subscription {\n+\n+        private final Subscriber<? super Connection> actual;\n+\n+        Subscription subscriptionState;\n+\n+        StateMachineSubscription(Subscriber<? super Connection> actual) {\n+            this.actual = actual;\n+            subscriptionState = new WaitRequestSubscriptionState();\n+        }\n+\n+        @Override\n+        public synchronized void request(long n) {\n+            subscriptionState.request(n);\n+        }\n+\n+        @Override\n+        public synchronized void cancel() {\n+            subscriptionState.cancel();\n+        }\n+\n+        synchronized void transitionTo(SubscriptionState newState) {\n+            subscriptionState = newState;\n+            newState.enter();\n+        }\n+\n+        abstract class SubscriptionState implements Subscription {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98515fc93fbfc6292bf224d0640fe7fe61e6041e"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE4NjUwOA==", "bodyText": "Thanks for looking at it! FYI I just fixed a race reported by @OlegDokuka:\nd3409df", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r406186508", "createdAt": "2020-04-09T13:01:22Z", "author": {"login": "bsideup"}, "path": "modules/r2dbc/src/main/java/org/testcontainers/r2dbc/ConnectionPublisher.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package org.testcontainers.r2dbc;\n+\n+import io.r2dbc.spi.Connection;\n+import io.r2dbc.spi.ConnectionFactory;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Supplier;\n+\n+class ConnectionPublisher implements Publisher<Connection> {\n+\n+    private final Supplier<CompletableFuture<ConnectionFactory>> futureSupplier;\n+\n+    ConnectionPublisher(Supplier<CompletableFuture<ConnectionFactory>> futureSupplier) {\n+        this.futureSupplier = futureSupplier;\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super Connection> actual) {\n+        actual.onSubscribe(new StateMachineSubscription(actual));\n+    }\n+\n+    /**\n+     * Design notes:\n+     * - ConnectionPublisher is Mono-like (0..1), the request amount is ignored\n+     * - given the testing nature, the performance requirements are less strict\n+     * - \"synchronized\" is used to avoid races\n+     * - Reactive Streams spec violations are not checked (e.g. non-positive request)\n+     */\n+    private class StateMachineSubscription implements Subscription {\n+\n+        private final Subscriber<? super Connection> actual;\n+\n+        Subscription subscriptionState;\n+\n+        StateMachineSubscription(Subscriber<? super Connection> actual) {\n+            this.actual = actual;\n+            subscriptionState = new WaitRequestSubscriptionState();\n+        }\n+\n+        @Override\n+        public synchronized void request(long n) {\n+            subscriptionState.request(n);\n+        }\n+\n+        @Override\n+        public synchronized void cancel() {\n+            subscriptionState.cancel();\n+        }\n+\n+        synchronized void transitionTo(SubscriptionState newState) {\n+            subscriptionState = newState;\n+            newState.enter();\n+        }\n+\n+        abstract class SubscriptionState implements Subscription {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE4MTMzNg=="}, "originalCommit": {"oid": "98515fc93fbfc6292bf224d0640fe7fe61e6041e"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNjM0OTc3OnYy", "diffSide": "RIGHT", "path": "modules/mariadb/src/main/java/org/testcontainers/containers/MariaDBR2DBCDatabaseContainerProvider.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQwOTo0NTo1NlrOGEL6xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQwOTo0NTo1NlrOGEL6xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA0Mjc1OA==", "bodyText": "Woah, TIL about @AutoService. I like it.\nFor the sake of consistency, we should probably propagate this out to everywhere else where we've currently hand-written a service descriptor file. This could be a subsequent PR, though.", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r407042758", "createdAt": "2020-04-11T09:45:56Z", "author": {"login": "rnorth"}, "path": "modules/mariadb/src/main/java/org/testcontainers/containers/MariaDBR2DBCDatabaseContainerProvider.java", "diffHunk": "@@ -0,0 +1,29 @@\n+package org.testcontainers.containers;\n+\n+import com.google.auto.service.AutoService;\n+import io.r2dbc.spi.ConnectionFactoryOptions;\n+import org.mariadb.r2dbc.MariadbConnectionFactoryProvider;\n+import org.testcontainers.r2dbc.R2DBCDatabaseContainer;\n+import org.testcontainers.r2dbc.R2DBCDatabaseContainerProvider;\n+\n+@AutoService(R2DBCDatabaseContainerProvider.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3a5c5a21a9c17b8933e92fd9e1b554e3fc965a5"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNjM3MTQ2OnYy", "diffSide": "RIGHT", "path": "modules/mariadb/src/test/java/org/testcontainers/containers/MariaDBR2DBCDatabaseContainerTest.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQxMDoxNDozMlrOGEMFJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQxMzozODo0NVrOGENSUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA0NTQxMg==", "bodyText": "Just wondering if we should prefer an approach similar to our jdbc-test module, that runs the same test in a parameterized way?", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r407045412", "createdAt": "2020-04-11T10:14:32Z", "author": {"login": "kiview"}, "path": "modules/mariadb/src/test/java/org/testcontainers/containers/MariaDBR2DBCDatabaseContainerTest.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package org.testcontainers.containers;\n+\n+import io.r2dbc.spi.Closeable;\n+import io.r2dbc.spi.Connection;\n+import io.r2dbc.spi.ConnectionFactories;\n+import io.r2dbc.spi.ConnectionFactory;\n+import io.r2dbc.spi.Result;\n+import org.junit.Test;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import static org.junit.Assert.*;\n+\n+public class MariaDBR2DBCDatabaseContainerTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3a5c5a21a9c17b8933e92fd9e1b554e3fc965a5"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA0NzQzMg==", "bodyText": "@rnorth wanted to change it to \"per module\" for better parallelization, see #2520", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r407047432", "createdAt": "2020-04-11T10:35:06Z", "author": {"login": "bsideup"}, "path": "modules/mariadb/src/test/java/org/testcontainers/containers/MariaDBR2DBCDatabaseContainerTest.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package org.testcontainers.containers;\n+\n+import io.r2dbc.spi.Closeable;\n+import io.r2dbc.spi.Connection;\n+import io.r2dbc.spi.ConnectionFactories;\n+import io.r2dbc.spi.ConnectionFactory;\n+import io.r2dbc.spi.Result;\n+import org.junit.Test;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import static org.junit.Assert.*;\n+\n+public class MariaDBR2DBCDatabaseContainerTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA0NTQxMg=="}, "originalCommit": {"oid": "a3a5c5a21a9c17b8933e92fd9e1b554e3fc965a5"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA0ODQyMg==", "bodyText": "Ah yes, I was assuming something like this actually \ud83d\ude2c\nStill, we could maybe extract an abstract base test class or something similar in a later change, to reduced code duplication.", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r407048422", "createdAt": "2020-04-11T10:46:01Z", "author": {"login": "kiview"}, "path": "modules/mariadb/src/test/java/org/testcontainers/containers/MariaDBR2DBCDatabaseContainerTest.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package org.testcontainers.containers;\n+\n+import io.r2dbc.spi.Closeable;\n+import io.r2dbc.spi.Connection;\n+import io.r2dbc.spi.ConnectionFactories;\n+import io.r2dbc.spi.ConnectionFactory;\n+import io.r2dbc.spi.Result;\n+import org.junit.Test;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import static org.junit.Assert.*;\n+\n+public class MariaDBR2DBCDatabaseContainerTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA0NTQxMg=="}, "originalCommit": {"oid": "a3a5c5a21a9c17b8933e92fd9e1b554e3fc965a5"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA2NTE2OQ==", "bodyText": "Yep, we can split it per-module and have some common base test classes to keep things neat. That's how I'd started with my draft splitting of jdbc-test, and works nicely.", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r407065169", "createdAt": "2020-04-11T13:38:45Z", "author": {"login": "rnorth"}, "path": "modules/mariadb/src/test/java/org/testcontainers/containers/MariaDBR2DBCDatabaseContainerTest.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package org.testcontainers.containers;\n+\n+import io.r2dbc.spi.Closeable;\n+import io.r2dbc.spi.Connection;\n+import io.r2dbc.spi.ConnectionFactories;\n+import io.r2dbc.spi.ConnectionFactory;\n+import io.r2dbc.spi.Result;\n+import org.junit.Test;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import static org.junit.Assert.*;\n+\n+public class MariaDBR2DBCDatabaseContainerTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA0NTQxMg=="}, "originalCommit": {"oid": "a3a5c5a21a9c17b8933e92fd9e1b554e3fc965a5"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNjM4NDc5OnYy", "diffSide": "RIGHT", "path": "modules/r2dbc/src/main/resources/META-INF/services/io.r2dbc.spi.ConnectionFactoryProvider", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQxMDozMDo1OFrOGEMLgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQxMDozNDozMVrOGEMM2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA0NzA0Mg==", "bodyText": "We can't use @AutoService here?", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r407047042", "createdAt": "2020-04-11T10:30:58Z", "author": {"login": "kiview"}, "path": "modules/r2dbc/src/main/resources/META-INF/services/io.r2dbc.spi.ConnectionFactoryProvider", "diffHunk": "@@ -0,0 +1 @@\n+org.testcontainers.r2dbc.Hidden$TestcontainersR2DBCConnectionFactoryProvider", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3a5c5a21a9c17b8933e92fd9e1b554e3fc965a5"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA0NzM4NA==", "bodyText": "good catch, we should \ud83d\udc4d", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r407047384", "createdAt": "2020-04-11T10:34:31Z", "author": {"login": "bsideup"}, "path": "modules/r2dbc/src/main/resources/META-INF/services/io.r2dbc.spi.ConnectionFactoryProvider", "diffHunk": "@@ -0,0 +1 @@\n+org.testcontainers.r2dbc.Hidden$TestcontainersR2DBCConnectionFactoryProvider", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA0NzA0Mg=="}, "originalCommit": {"oid": "a3a5c5a21a9c17b8933e92fd9e1b554e3fc965a5"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNzYyOTUyOnYy", "diffSide": "RIGHT", "path": "docs/modules/databases/r2dbc.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMlQxMzozNzo0NFrOGEVe9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMlQxMzozNzo0NFrOGEVe9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE5OTQ3Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                both the database module like `org.testcontainers:mysql` **and** `org.testcontainers:r2dbc` need to be on your application's classpath at runtime for this to work.\n          \n          \n            \n                Both the database module (e.g. `org.testcontainers:mysql`) **and** `org.testcontainers:r2dbc` need to be on your application's classpath at runtime.", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r407199477", "createdAt": "2020-04-12T13:37:44Z", "author": {"login": "rnorth"}, "path": "docs/modules/databases/r2dbc.md", "diffHunk": "@@ -0,0 +1,55 @@\n+# R2DBC support\n+\n+You can obtain a temporary database in one of two ways:\n+\n+ * **Using a specially modified R2DBC URL**: after making a very simple modification to your system's R2DBC URL string, Testcontainers will provide a disposable stand-in database that can be used without requiring modification to your application code.\n+ * **JUnit @Rule/@ClassRule**: this mode starts a database inside a container before your tests and tears it down afterwards.\n+\n+## Database containers launched via R2DBC URL scheme\n+\n+As long as you have Testcontainers and the appropriate R2DBC driver on your classpath, you can simply modify regular R2DBC connection URLs to get a fresh containerized instance of the database each time your application starts up.\n+\n+Started container will be terminated when the `ConnectionFactory` is closed.\n+\n+!!! warning\n+    both the database module like `org.testcontainers:mysql` **and** `org.testcontainers:r2dbc` need to be on your application's classpath at runtime for this to work.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e145cc1b4bd088b9bc87ba562206938587133715"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNzYzMDA2OnYy", "diffSide": "RIGHT", "path": "docs/modules/databases/r2dbc.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMlQxMzozODoyMlrOGEVfPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMlQxMzozOTowNVrOGEVfxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE5OTU0OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Started container will be terminated when the `ConnectionFactory` is closed.\n          \n          \n            \n            The started container will be terminated when the `ConnectionFactory` is closed.", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r407199548", "createdAt": "2020-04-12T13:38:22Z", "author": {"login": "rnorth"}, "path": "docs/modules/databases/r2dbc.md", "diffHunk": "@@ -0,0 +1,55 @@\n+# R2DBC support\n+\n+You can obtain a temporary database in one of two ways:\n+\n+ * **Using a specially modified R2DBC URL**: after making a very simple modification to your system's R2DBC URL string, Testcontainers will provide a disposable stand-in database that can be used without requiring modification to your application code.\n+ * **JUnit @Rule/@ClassRule**: this mode starts a database inside a container before your tests and tears it down afterwards.\n+\n+## Database containers launched via R2DBC URL scheme\n+\n+As long as you have Testcontainers and the appropriate R2DBC driver on your classpath, you can simply modify regular R2DBC connection URLs to get a fresh containerized instance of the database each time your application starts up.\n+\n+Started container will be terminated when the `ConnectionFactory` is closed.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e145cc1b4bd088b9bc87ba562206938587133715"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE5OTY4NQ==", "bodyText": "I knew it! I freaking knew it!! \ud83d\ude02", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r407199685", "createdAt": "2020-04-12T13:39:05Z", "author": {"login": "bsideup"}, "path": "docs/modules/databases/r2dbc.md", "diffHunk": "@@ -0,0 +1,55 @@\n+# R2DBC support\n+\n+You can obtain a temporary database in one of two ways:\n+\n+ * **Using a specially modified R2DBC URL**: after making a very simple modification to your system's R2DBC URL string, Testcontainers will provide a disposable stand-in database that can be used without requiring modification to your application code.\n+ * **JUnit @Rule/@ClassRule**: this mode starts a database inside a container before your tests and tears it down afterwards.\n+\n+## Database containers launched via R2DBC URL scheme\n+\n+As long as you have Testcontainers and the appropriate R2DBC driver on your classpath, you can simply modify regular R2DBC connection URLs to get a fresh containerized instance of the database each time your application starts up.\n+\n+Started container will be terminated when the `ConnectionFactory` is closed.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE5OTU0OA=="}, "originalCommit": {"oid": "e145cc1b4bd088b9bc87ba562206938587133715"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNzYzMzI2OnYy", "diffSide": "RIGHT", "path": "docs/modules/databases/r2dbc.md", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMlQxMzo0MTozNlrOGEVg0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMlQxNDoxOTowM1rOGEVzdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE5OTk1Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            1. Specify the mandatory Docker tag of database's official image that you want to use as `TC_IMAGE_TAG`\n          \n          \n            \n            1. Specify the mandatory Docker tag of the database's official image that you want using a `TC_IMAGE_TAG` query parameter.\n          \n          \n            \n            \n          \n          \n            \n            **Note that, unlike Testcontainers' JDBC URL support, it is not possible to specify an image tag in the 'scheme' part of the URL, and it is always necessary to specify a tag using `TC_IMAGE_TAG`.**", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r407199953", "createdAt": "2020-04-12T13:41:36Z", "author": {"login": "rnorth"}, "path": "docs/modules/databases/r2dbc.md", "diffHunk": "@@ -0,0 +1,55 @@\n+# R2DBC support\n+\n+You can obtain a temporary database in one of two ways:\n+\n+ * **Using a specially modified R2DBC URL**: after making a very simple modification to your system's R2DBC URL string, Testcontainers will provide a disposable stand-in database that can be used without requiring modification to your application code.\n+ * **JUnit @Rule/@ClassRule**: this mode starts a database inside a container before your tests and tears it down afterwards.\n+\n+## Database containers launched via R2DBC URL scheme\n+\n+As long as you have Testcontainers and the appropriate R2DBC driver on your classpath, you can simply modify regular R2DBC connection URLs to get a fresh containerized instance of the database each time your application starts up.\n+\n+Started container will be terminated when the `ConnectionFactory` is closed.\n+\n+!!! warning\n+    both the database module like `org.testcontainers:mysql` **and** `org.testcontainers:r2dbc` need to be on your application's classpath at runtime for this to work.\n+\n+**Original URL**: `r2dbc:mysql://localhost:3306/databasename`\n+\n+1. Insert `tc:` after `r2dbc:` as follows. Note that the hostname, port and database name will be ignored; you can leave these as-is or set them to any value.\n+1. Specify the mandatory Docker tag of database's official image that you want to use as `TC_IMAGE_TAG`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e145cc1b4bd088b9bc87ba562206938587133715"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIwMDI1MA==", "bodyText": "want to using a\n\nit feels that a word missing between to and using. Don't we miss something here?", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r407200250", "createdAt": "2020-04-12T13:43:35Z", "author": {"login": "bsideup"}, "path": "docs/modules/databases/r2dbc.md", "diffHunk": "@@ -0,0 +1,55 @@\n+# R2DBC support\n+\n+You can obtain a temporary database in one of two ways:\n+\n+ * **Using a specially modified R2DBC URL**: after making a very simple modification to your system's R2DBC URL string, Testcontainers will provide a disposable stand-in database that can be used without requiring modification to your application code.\n+ * **JUnit @Rule/@ClassRule**: this mode starts a database inside a container before your tests and tears it down afterwards.\n+\n+## Database containers launched via R2DBC URL scheme\n+\n+As long as you have Testcontainers and the appropriate R2DBC driver on your classpath, you can simply modify regular R2DBC connection URLs to get a fresh containerized instance of the database each time your application starts up.\n+\n+Started container will be terminated when the `ConnectionFactory` is closed.\n+\n+!!! warning\n+    both the database module like `org.testcontainers:mysql` **and** `org.testcontainers:r2dbc` need to be on your application's classpath at runtime for this to work.\n+\n+**Original URL**: `r2dbc:mysql://localhost:3306/databasename`\n+\n+1. Insert `tc:` after `r2dbc:` as follows. Note that the hostname, port and database name will be ignored; you can leave these as-is or set them to any value.\n+1. Specify the mandatory Docker tag of database's official image that you want to use as `TC_IMAGE_TAG`", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE5OTk1Mw=="}, "originalCommit": {"oid": "e145cc1b4bd088b9bc87ba562206938587133715"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIwNDA2Ng==", "bodyText": "Oops!", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r407204066", "createdAt": "2020-04-12T14:13:36Z", "author": {"login": "rnorth"}, "path": "docs/modules/databases/r2dbc.md", "diffHunk": "@@ -0,0 +1,55 @@\n+# R2DBC support\n+\n+You can obtain a temporary database in one of two ways:\n+\n+ * **Using a specially modified R2DBC URL**: after making a very simple modification to your system's R2DBC URL string, Testcontainers will provide a disposable stand-in database that can be used without requiring modification to your application code.\n+ * **JUnit @Rule/@ClassRule**: this mode starts a database inside a container before your tests and tears it down afterwards.\n+\n+## Database containers launched via R2DBC URL scheme\n+\n+As long as you have Testcontainers and the appropriate R2DBC driver on your classpath, you can simply modify regular R2DBC connection URLs to get a fresh containerized instance of the database each time your application starts up.\n+\n+Started container will be terminated when the `ConnectionFactory` is closed.\n+\n+!!! warning\n+    both the database module like `org.testcontainers:mysql` **and** `org.testcontainers:r2dbc` need to be on your application's classpath at runtime for this to work.\n+\n+**Original URL**: `r2dbc:mysql://localhost:3306/databasename`\n+\n+1. Insert `tc:` after `r2dbc:` as follows. Note that the hostname, port and database name will be ignored; you can leave these as-is or set them to any value.\n+1. Specify the mandatory Docker tag of database's official image that you want to use as `TC_IMAGE_TAG`", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE5OTk1Mw=="}, "originalCommit": {"oid": "e145cc1b4bd088b9bc87ba562206938587133715"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIwNDcyNw==", "bodyText": "Fixed my suggestion.", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r407204727", "createdAt": "2020-04-12T14:19:03Z", "author": {"login": "rnorth"}, "path": "docs/modules/databases/r2dbc.md", "diffHunk": "@@ -0,0 +1,55 @@\n+# R2DBC support\n+\n+You can obtain a temporary database in one of two ways:\n+\n+ * **Using a specially modified R2DBC URL**: after making a very simple modification to your system's R2DBC URL string, Testcontainers will provide a disposable stand-in database that can be used without requiring modification to your application code.\n+ * **JUnit @Rule/@ClassRule**: this mode starts a database inside a container before your tests and tears it down afterwards.\n+\n+## Database containers launched via R2DBC URL scheme\n+\n+As long as you have Testcontainers and the appropriate R2DBC driver on your classpath, you can simply modify regular R2DBC connection URLs to get a fresh containerized instance of the database each time your application starts up.\n+\n+Started container will be terminated when the `ConnectionFactory` is closed.\n+\n+!!! warning\n+    both the database module like `org.testcontainers:mysql` **and** `org.testcontainers:r2dbc` need to be on your application's classpath at runtime for this to work.\n+\n+**Original URL**: `r2dbc:mysql://localhost:3306/databasename`\n+\n+1. Insert `tc:` after `r2dbc:` as follows. Note that the hostname, port and database name will be ignored; you can leave these as-is or set them to any value.\n+1. Specify the mandatory Docker tag of database's official image that you want to use as `TC_IMAGE_TAG`", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE5OTk1Mw=="}, "originalCommit": {"oid": "e145cc1b4bd088b9bc87ba562206938587133715"}, "originalPosition": 20}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1541, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}