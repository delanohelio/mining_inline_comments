{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxMzk0NTc1", "number": 2545, "title": "Add R2DBC support", "bodyText": "This PR adds support for R2DBC.\nURL support\nThe URL support is similar to the JDBC's, but:\n\nDoes not reuse containers by URL - it is unclear how to \"hash\" ConnectionFactoryOptions\nThe image tag must be explicitly provided via TC_IMAGE_TAG r2dbc option\nTODO: daemon mode\nTODO: alias support (see #4)\n\nExample usage\nThe user must add the org.testcontainers:r2dbc module - unlike JDBC, we use compileOnly dependency on R2DBC, since it is a 3rd party dependency.\nOnce both the r2dbc and database's module are added, one can use:\nString url = \"r2dbc:tc:postgresql:///db?TC_IMAGE_TAG=10-alpine\";\nConnectionFactory connectionFactory = ConnectionFactories.get(url);\nProgrammatic access\nFor those who start containers manually and want to obtain ConnectionFactoryOptions for already started containers, we can provide a helper static method:\ntry (PostgreSQLContainer<?> container = new PostgreSQLContainer<>()) {\n    container.start();\n\n    ConnectionFactory connectionFactory = ConnectionFactories.get(\n        PostgreSQLR2DBCDatabaseContainer.getOptions(container)\n    );\n}\nI decided to leave some generic way (e.g. R2dbcContainers.getOptions(container);) for future considerations because:\n\nwe will need to apply instanceof checks (or expose getR2dbcDriverType()-like method) on DatabaseContainer\nwe need some sort of a sorting to avoid postgres taking precedence before postgis and returning wrong factory\nprobably more :D\n\n\n/cc @mp911de", "createdAt": "2020-04-09T12:27:08Z", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545", "merged": true, "mergeCommit": {"oid": "6c45a20892d837ac736dd293abfe458f96be74fc"}, "closed": true, "closedAt": "2020-04-12T17:27:50Z", "author": {"login": "bsideup"}, "timelineItems": {"totalCount": 27, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcV7fC4AH2gAyNDAxMzk0NTc1Ojk4NTE1ZmM5M2ZiZmM2MjkyYmYyMjRkMDY0MGZlN2ZlNjFlNjA0MWU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcW8hpIAH2gAyNDAxMzk0NTc1OmIyOGZiNjVhZDcxOGZjNDczMDlhNzg5YmE3MjZiODI5NzMyN2ZiNjc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "98515fc93fbfc6292bf224d0640fe7fe61e6041e", "author": {"user": {"login": "bsideup", "name": "Sergei Egorov"}}, "url": "https://github.com/testcontainers/testcontainers-java/commit/98515fc93fbfc6292bf224d0640fe7fe61e6041e", "committedDate": "2020-04-09T12:16:48Z", "message": "Add R2DBC URL support"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwNzU0MDM4", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#pullrequestreview-390754038", "createdAt": "2020-04-09T12:39:44Z", "commit": {"oid": "98515fc93fbfc6292bf224d0640fe7fe61e6041e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMjozOTo0NFrOGDW7FA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMjozOTo0NFrOGDW7FA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3NDQ4NA==", "bodyText": "might be a case when\nfuture just completed ->\nvoid enter() { publisher.subscribe(this); } executed but subscription may be delivered later (See https://github.com/reactive-streams/reactive-streams-jvm/issues/486 for the clarification)\nso the next cancel which is waiting on the synchronized block will end-up with NPE.\n\nThe simples solution for that is to add flag and synchronization between request cancel and onsubscriber to ensure we are not ending up with NPE if the subscription has not arrived yet", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r406174484", "createdAt": "2020-04-09T12:39:44Z", "author": {"login": "OlegDokuka"}, "path": "modules/r2dbc/src/main/java/org/testcontainers/r2dbc/ConnectionPublisher.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package org.testcontainers.r2dbc;\n+\n+import io.r2dbc.spi.Connection;\n+import io.r2dbc.spi.ConnectionFactory;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Supplier;\n+\n+class ConnectionPublisher implements Publisher<Connection> {\n+\n+    private final Supplier<CompletableFuture<ConnectionFactory>> futureSupplier;\n+\n+    ConnectionPublisher(Supplier<CompletableFuture<ConnectionFactory>> futureSupplier) {\n+        this.futureSupplier = futureSupplier;\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super Connection> actual) {\n+        actual.onSubscribe(new StateMachineSubscription(actual));\n+    }\n+\n+    /**\n+     * Design notes:\n+     * - ConnectionPublisher is Mono-like (0..1), the request amount is ignored\n+     * - given the testing nature, the performance requirements are less strict\n+     * - \"synchronized\" is used to avoid races\n+     * - Reactive Streams spec violations are not checked (e.g. non-positive request)\n+     */\n+    private class StateMachineSubscription implements Subscription {\n+\n+        private final Subscriber<? super Connection> actual;\n+\n+        Subscription subscriptionState;\n+\n+        StateMachineSubscription(Subscriber<? super Connection> actual) {\n+            this.actual = actual;\n+            subscriptionState = new WaitRequestSubscriptionState();\n+        }\n+\n+        @Override\n+        public synchronized void request(long n) {\n+            subscriptionState.request(n);\n+        }\n+\n+        @Override\n+        public synchronized void cancel() {\n+            subscriptionState.cancel();\n+        }\n+\n+        synchronized void transitionTo(SubscriptionState newState) {\n+            subscriptionState = newState;\n+            newState.enter();\n+        }\n+\n+        abstract class SubscriptionState implements Subscription {\n+            void enter() {\n+            }\n+        }\n+\n+        class WaitRequestSubscriptionState extends SubscriptionState {\n+\n+            @Override\n+            public void request(long n) {\n+                transitionTo(new WaitFutureCompletionSubscriptionState());\n+            }\n+\n+            @Override\n+            public void cancel() {\n+            }\n+        }\n+\n+        class WaitFutureCompletionSubscriptionState extends SubscriptionState {\n+\n+            private CompletableFuture<ConnectionFactory> future;\n+\n+            @Override\n+            void enter() {\n+                this.future = futureSupplier.get();\n+\n+                future.whenComplete((connectionFactory, e) -> {\n+                    if (e != null) {\n+                        actual.onSubscribe(EmptySubscription.INSTANCE);\n+                        actual.onError(e);\n+                        return;\n+                    }\n+\n+                    Publisher<? extends Connection> publisher = connectionFactory.create();\n+                    transitionTo(new ProxySubscriptionState(publisher));\n+                });\n+            }\n+\n+            @Override\n+            public void request(long n) {\n+            }\n+\n+            @Override\n+            public void cancel() {\n+                future.cancel(true);\n+            }\n+        }\n+\n+        class ProxySubscriptionState extends SubscriptionState implements Subscriber<Connection> {\n+\n+            private final Publisher<? extends Connection> publisher;\n+\n+            private Subscription s;\n+\n+            ProxySubscriptionState(Publisher<? extends Connection> publisher) {\n+                this.publisher = publisher;\n+            }\n+\n+            @Override\n+            void enter() {\n+                publisher.subscribe(this);\n+            }\n+\n+            @Override\n+            public void request(long n) {\n+                // Ignore\n+            }\n+\n+            @Override\n+            public void cancel() {\n+                s.cancel();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98515fc93fbfc6292bf224d0640fe7fe61e6041e"}, "originalPosition": 127}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwNzU1MDIw", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#pullrequestreview-390755020", "createdAt": "2020-04-09T12:41:13Z", "commit": {"oid": "98515fc93fbfc6292bf224d0640fe7fe61e6041e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMjo0MToxM1rOGDW-IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMjo0MToxM1rOGDW-IQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3NTI2NQ==", "bodyText": "here we have to have a flag, e.g (canceled) and if so, immediately call s.cancel on the given one", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r406175265", "createdAt": "2020-04-09T12:41:13Z", "author": {"login": "OlegDokuka"}, "path": "modules/r2dbc/src/main/java/org/testcontainers/r2dbc/ConnectionPublisher.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package org.testcontainers.r2dbc;\n+\n+import io.r2dbc.spi.Connection;\n+import io.r2dbc.spi.ConnectionFactory;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Supplier;\n+\n+class ConnectionPublisher implements Publisher<Connection> {\n+\n+    private final Supplier<CompletableFuture<ConnectionFactory>> futureSupplier;\n+\n+    ConnectionPublisher(Supplier<CompletableFuture<ConnectionFactory>> futureSupplier) {\n+        this.futureSupplier = futureSupplier;\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super Connection> actual) {\n+        actual.onSubscribe(new StateMachineSubscription(actual));\n+    }\n+\n+    /**\n+     * Design notes:\n+     * - ConnectionPublisher is Mono-like (0..1), the request amount is ignored\n+     * - given the testing nature, the performance requirements are less strict\n+     * - \"synchronized\" is used to avoid races\n+     * - Reactive Streams spec violations are not checked (e.g. non-positive request)\n+     */\n+    private class StateMachineSubscription implements Subscription {\n+\n+        private final Subscriber<? super Connection> actual;\n+\n+        Subscription subscriptionState;\n+\n+        StateMachineSubscription(Subscriber<? super Connection> actual) {\n+            this.actual = actual;\n+            subscriptionState = new WaitRequestSubscriptionState();\n+        }\n+\n+        @Override\n+        public synchronized void request(long n) {\n+            subscriptionState.request(n);\n+        }\n+\n+        @Override\n+        public synchronized void cancel() {\n+            subscriptionState.cancel();\n+        }\n+\n+        synchronized void transitionTo(SubscriptionState newState) {\n+            subscriptionState = newState;\n+            newState.enter();\n+        }\n+\n+        abstract class SubscriptionState implements Subscription {\n+            void enter() {\n+            }\n+        }\n+\n+        class WaitRequestSubscriptionState extends SubscriptionState {\n+\n+            @Override\n+            public void request(long n) {\n+                transitionTo(new WaitFutureCompletionSubscriptionState());\n+            }\n+\n+            @Override\n+            public void cancel() {\n+            }\n+        }\n+\n+        class WaitFutureCompletionSubscriptionState extends SubscriptionState {\n+\n+            private CompletableFuture<ConnectionFactory> future;\n+\n+            @Override\n+            void enter() {\n+                this.future = futureSupplier.get();\n+\n+                future.whenComplete((connectionFactory, e) -> {\n+                    if (e != null) {\n+                        actual.onSubscribe(EmptySubscription.INSTANCE);\n+                        actual.onError(e);\n+                        return;\n+                    }\n+\n+                    Publisher<? extends Connection> publisher = connectionFactory.create();\n+                    transitionTo(new ProxySubscriptionState(publisher));\n+                });\n+            }\n+\n+            @Override\n+            public void request(long n) {\n+            }\n+\n+            @Override\n+            public void cancel() {\n+                future.cancel(true);\n+            }\n+        }\n+\n+        class ProxySubscriptionState extends SubscriptionState implements Subscriber<Connection> {\n+\n+            private final Publisher<? extends Connection> publisher;\n+\n+            private Subscription s;\n+\n+            ProxySubscriptionState(Publisher<? extends Connection> publisher) {\n+                this.publisher = publisher;\n+            }\n+\n+            @Override\n+            void enter() {\n+                publisher.subscribe(this);\n+            }\n+\n+            @Override\n+            public void request(long n) {\n+                // Ignore\n+            }\n+\n+            @Override\n+            public void cancel() {\n+                s.cancel();\n+            }\n+\n+            @Override\n+            public void onSubscribe(Subscription s) {\n+                this.s = s;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98515fc93fbfc6292bf224d0640fe7fe61e6041e"}, "originalPosition": 132}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwNzU0ODEy", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#pullrequestreview-390754812", "createdAt": "2020-04-09T12:40:54Z", "commit": {"oid": "98515fc93fbfc6292bf224d0640fe7fe61e6041e"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMjo0MDo1NFrOGDW9hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMjo1MjoxOVrOGDXV2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3NTExMQ==", "bodyText": "@mp911de does the connection factory absolutely guarantees a Publisher with at most one onNext(Connection)? if not, @bsideup it might be worth it to consider guarding against flux-like publishers by adding a boolean guard in onNext (doesn't even have to be a volatile, since only onNext would read/write it)", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r406175111", "createdAt": "2020-04-09T12:40:54Z", "author": {"login": "simonbasle"}, "path": "modules/r2dbc/src/main/java/org/testcontainers/r2dbc/ConnectionPublisher.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package org.testcontainers.r2dbc;\n+\n+import io.r2dbc.spi.Connection;\n+import io.r2dbc.spi.ConnectionFactory;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Supplier;\n+\n+class ConnectionPublisher implements Publisher<Connection> {\n+\n+    private final Supplier<CompletableFuture<ConnectionFactory>> futureSupplier;\n+\n+    ConnectionPublisher(Supplier<CompletableFuture<ConnectionFactory>> futureSupplier) {\n+        this.futureSupplier = futureSupplier;\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super Connection> actual) {\n+        actual.onSubscribe(new StateMachineSubscription(actual));\n+    }\n+\n+    /**\n+     * Design notes:\n+     * - ConnectionPublisher is Mono-like (0..1), the request amount is ignored\n+     * - given the testing nature, the performance requirements are less strict\n+     * - \"synchronized\" is used to avoid races\n+     * - Reactive Streams spec violations are not checked (e.g. non-positive request)\n+     */\n+    private class StateMachineSubscription implements Subscription {\n+\n+        private final Subscriber<? super Connection> actual;\n+\n+        Subscription subscriptionState;\n+\n+        StateMachineSubscription(Subscriber<? super Connection> actual) {\n+            this.actual = actual;\n+            subscriptionState = new WaitRequestSubscriptionState();\n+        }\n+\n+        @Override\n+        public synchronized void request(long n) {\n+            subscriptionState.request(n);\n+        }\n+\n+        @Override\n+        public synchronized void cancel() {\n+            subscriptionState.cancel();\n+        }\n+\n+        synchronized void transitionTo(SubscriptionState newState) {\n+            subscriptionState = newState;\n+            newState.enter();\n+        }\n+\n+        abstract class SubscriptionState implements Subscription {\n+            void enter() {\n+            }\n+        }\n+\n+        class WaitRequestSubscriptionState extends SubscriptionState {\n+\n+            @Override\n+            public void request(long n) {\n+                transitionTo(new WaitFutureCompletionSubscriptionState());\n+            }\n+\n+            @Override\n+            public void cancel() {\n+            }\n+        }\n+\n+        class WaitFutureCompletionSubscriptionState extends SubscriptionState {\n+\n+            private CompletableFuture<ConnectionFactory> future;\n+\n+            @Override\n+            void enter() {\n+                this.future = futureSupplier.get();\n+\n+                future.whenComplete((connectionFactory, e) -> {\n+                    if (e != null) {\n+                        actual.onSubscribe(EmptySubscription.INSTANCE);\n+                        actual.onError(e);\n+                        return;\n+                    }\n+\n+                    Publisher<? extends Connection> publisher = connectionFactory.create();\n+                    transitionTo(new ProxySubscriptionState(publisher));\n+                });\n+            }\n+\n+            @Override\n+            public void request(long n) {\n+            }\n+\n+            @Override\n+            public void cancel() {\n+                future.cancel(true);\n+            }\n+        }\n+\n+        class ProxySubscriptionState extends SubscriptionState implements Subscriber<Connection> {\n+\n+            private final Publisher<? extends Connection> publisher;\n+\n+            private Subscription s;\n+\n+            ProxySubscriptionState(Publisher<? extends Connection> publisher) {\n+                this.publisher = publisher;\n+            }\n+\n+            @Override\n+            void enter() {\n+                publisher.subscribe(this);\n+            }\n+\n+            @Override\n+            public void request(long n) {\n+                // Ignore\n+            }\n+\n+            @Override\n+            public void cancel() {\n+                s.cancel();\n+            }\n+\n+            @Override\n+            public void onSubscribe(Subscription s) {\n+                this.s = s;\n+                s.request(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98515fc93fbfc6292bf224d0640fe7fe61e6041e"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE4MTMzNg==", "bodyText": "that pattern was a bit harder for me to follow because of the habit of seeing Subscription as self-sufficient and thus aggressively guarded, but after review it looks correct. I feel it wouldn't be too hard to collapse the various SubscriptionState into the StateMachineSubscription itself and deal with int/enum based states for transitions, but eh as long as it is correct...", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r406181336", "createdAt": "2020-04-09T12:52:19Z", "author": {"login": "simonbasle"}, "path": "modules/r2dbc/src/main/java/org/testcontainers/r2dbc/ConnectionPublisher.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package org.testcontainers.r2dbc;\n+\n+import io.r2dbc.spi.Connection;\n+import io.r2dbc.spi.ConnectionFactory;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Supplier;\n+\n+class ConnectionPublisher implements Publisher<Connection> {\n+\n+    private final Supplier<CompletableFuture<ConnectionFactory>> futureSupplier;\n+\n+    ConnectionPublisher(Supplier<CompletableFuture<ConnectionFactory>> futureSupplier) {\n+        this.futureSupplier = futureSupplier;\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super Connection> actual) {\n+        actual.onSubscribe(new StateMachineSubscription(actual));\n+    }\n+\n+    /**\n+     * Design notes:\n+     * - ConnectionPublisher is Mono-like (0..1), the request amount is ignored\n+     * - given the testing nature, the performance requirements are less strict\n+     * - \"synchronized\" is used to avoid races\n+     * - Reactive Streams spec violations are not checked (e.g. non-positive request)\n+     */\n+    private class StateMachineSubscription implements Subscription {\n+\n+        private final Subscriber<? super Connection> actual;\n+\n+        Subscription subscriptionState;\n+\n+        StateMachineSubscription(Subscriber<? super Connection> actual) {\n+            this.actual = actual;\n+            subscriptionState = new WaitRequestSubscriptionState();\n+        }\n+\n+        @Override\n+        public synchronized void request(long n) {\n+            subscriptionState.request(n);\n+        }\n+\n+        @Override\n+        public synchronized void cancel() {\n+            subscriptionState.cancel();\n+        }\n+\n+        synchronized void transitionTo(SubscriptionState newState) {\n+            subscriptionState = newState;\n+            newState.enter();\n+        }\n+\n+        abstract class SubscriptionState implements Subscription {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98515fc93fbfc6292bf224d0640fe7fe61e6041e"}, "originalPosition": 58}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d3409df8e09c28f0f3531d9f2918e55ebd37eebb", "author": {"user": {"login": "bsideup", "name": "Sergei Egorov"}}, "url": "https://github.com/testcontainers/testcontainers-java/commit/d3409df8e09c28f0f3531d9f2918e55ebd37eebb", "committedDate": "2020-04-09T13:00:24Z", "message": "fix a race"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e2b34b15aa06c385a793f1b50e076a32c4fb8d6", "author": {"user": {"login": "bsideup", "name": "Sergei Egorov"}}, "url": "https://github.com/testcontainers/testcontainers-java/commit/3e2b34b15aa06c385a793f1b50e076a32c4fb8d6", "committedDate": "2020-04-09T13:14:01Z", "message": "move javadoc to the top class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "84ce94d515d83704969dae75e502f27228c6ac04", "author": {"user": {"login": "bsideup", "name": "Sergei Egorov"}}, "url": "https://github.com/testcontainers/testcontainers-java/commit/84ce94d515d83704969dae75e502f27228c6ac04", "committedDate": "2020-04-09T14:30:34Z", "message": "use `auto-service`, add `testUrlSupport` test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b4a8c668aa6e6ef881fe64a8c4cd1d9b2380366", "author": {"user": {"login": "bsideup", "name": "Sergei Egorov"}}, "url": "https://github.com/testcontainers/testcontainers-java/commit/7b4a8c668aa6e6ef881fe64a8c4cd1d9b2380366", "committedDate": "2020-04-09T14:31:30Z", "message": "Add MSSQL R2DBC support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8903ed8523dc21c5ce2decb53917baba6273508f", "author": {"user": {"login": "bsideup", "name": "Sergei Egorov"}}, "url": "https://github.com/testcontainers/testcontainers-java/commit/8903ed8523dc21c5ce2decb53917baba6273508f", "committedDate": "2020-04-09T14:51:29Z", "message": "Add MySQL"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3a5c5a21a9c17b8933e92fd9e1b554e3fc965a5", "author": {"user": {"login": "bsideup", "name": "Sergei Egorov"}}, "url": "https://github.com/testcontainers/testcontainers-java/commit/a3a5c5a21a9c17b8933e92fd9e1b554e3fc965a5", "committedDate": "2020-04-09T15:08:01Z", "message": "Add MariaDB"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNzUyMzQ5", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#pullrequestreview-391752349", "createdAt": "2020-04-11T09:45:56Z", "commit": {"oid": "a3a5c5a21a9c17b8933e92fd9e1b554e3fc965a5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQwOTo0NTo1NlrOGEL6xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQwOTo0NTo1NlrOGEL6xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA0Mjc1OA==", "bodyText": "Woah, TIL about @AutoService. I like it.\nFor the sake of consistency, we should probably propagate this out to everywhere else where we've currently hand-written a service descriptor file. This could be a subsequent PR, though.", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r407042758", "createdAt": "2020-04-11T09:45:56Z", "author": {"login": "rnorth"}, "path": "modules/mariadb/src/main/java/org/testcontainers/containers/MariaDBR2DBCDatabaseContainerProvider.java", "diffHunk": "@@ -0,0 +1,29 @@\n+package org.testcontainers.containers;\n+\n+import com.google.auto.service.AutoService;\n+import io.r2dbc.spi.ConnectionFactoryOptions;\n+import org.mariadb.r2dbc.MariadbConnectionFactoryProvider;\n+import org.testcontainers.r2dbc.R2DBCDatabaseContainer;\n+import org.testcontainers.r2dbc.R2DBCDatabaseContainerProvider;\n+\n+@AutoService(R2DBCDatabaseContainerProvider.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3a5c5a21a9c17b8933e92fd9e1b554e3fc965a5"}, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNzU0MTI2", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#pullrequestreview-391754126", "createdAt": "2020-04-11T10:14:32Z", "commit": {"oid": "a3a5c5a21a9c17b8933e92fd9e1b554e3fc965a5"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQxMDoxNDozMlrOGEMFJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQxMDozMDo1OFrOGEMLgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA0NTQxMg==", "bodyText": "Just wondering if we should prefer an approach similar to our jdbc-test module, that runs the same test in a parameterized way?", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r407045412", "createdAt": "2020-04-11T10:14:32Z", "author": {"login": "kiview"}, "path": "modules/mariadb/src/test/java/org/testcontainers/containers/MariaDBR2DBCDatabaseContainerTest.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package org.testcontainers.containers;\n+\n+import io.r2dbc.spi.Closeable;\n+import io.r2dbc.spi.Connection;\n+import io.r2dbc.spi.ConnectionFactories;\n+import io.r2dbc.spi.ConnectionFactory;\n+import io.r2dbc.spi.Result;\n+import org.junit.Test;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import static org.junit.Assert.*;\n+\n+public class MariaDBR2DBCDatabaseContainerTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3a5c5a21a9c17b8933e92fd9e1b554e3fc965a5"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA0NzA0Mg==", "bodyText": "We can't use @AutoService here?", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r407047042", "createdAt": "2020-04-11T10:30:58Z", "author": {"login": "kiview"}, "path": "modules/r2dbc/src/main/resources/META-INF/services/io.r2dbc.spi.ConnectionFactoryProvider", "diffHunk": "@@ -0,0 +1 @@\n+org.testcontainers.r2dbc.Hidden$TestcontainersR2DBCConnectionFactoryProvider", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3a5c5a21a9c17b8933e92fd9e1b554e3fc965a5"}, "originalPosition": 1}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "886c9e725befd219c1906fc2ddda2338061c945a", "author": {"user": {"login": "bsideup", "name": "Sergei Egorov"}}, "url": "https://github.com/testcontainers/testcontainers-java/commit/886c9e725befd219c1906fc2ddda2338061c945a", "committedDate": "2020-04-11T10:39:48Z", "message": "Use `@AutoService` on `TestcontainersR2DBCConnectionFactoryProvider`"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "184da8843372599724bcce6fda7ac2d558ad8ae9", "author": {"user": {"login": "bsideup", "name": "Sergei Egorov"}}, "url": "https://github.com/testcontainers/testcontainers-java/commit/184da8843372599724bcce6fda7ac2d558ad8ae9", "committedDate": "2020-04-11T18:08:42Z", "message": "Merge branch 'master' into r2dbc_support\n\n# Conflicts:\n#\tmodules/mariadb/build.gradle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "834dae85d7df4032b4a378afc8ba3b90221d2833", "author": {"user": {"login": "bsideup", "name": "Sergei Egorov"}}, "url": "https://github.com/testcontainers/testcontainers-java/commit/834dae85d7df4032b4a378afc8ba3b90221d2833", "committedDate": "2020-04-12T10:26:05Z", "message": "add `AbstractR2DBCDatabaseContainerTest`"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "937fe9603dd55912051f44910b5ecd75be6a2a59", "author": {"user": {"login": "bsideup", "name": "Sergei Egorov"}}, "url": "https://github.com/testcontainers/testcontainers-java/commit/937fe9603dd55912051f44910b5ecd75be6a2a59", "committedDate": "2020-04-12T10:43:15Z", "message": "`TC_IMAGE` -> `TC_IMAGE_TAG`"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "574df74f73adc52999558c70a0186c2f3f12955e", "author": {"user": {"login": "bsideup", "name": "Sergei Egorov"}}, "url": "https://github.com/testcontainers/testcontainers-java/commit/574df74f73adc52999558c70a0186c2f3f12955e", "committedDate": "2020-04-12T10:57:26Z", "message": "fix `reusesUntilConnectionFactoryIsClosed`"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa6a715732188a8ef146abb449a2368e2e11898c", "author": {"user": {"login": "bsideup", "name": "Sergei Egorov"}}, "url": "https://github.com/testcontainers/testcontainers-java/commit/fa6a715732188a8ef146abb449a2368e2e11898c", "committedDate": "2020-04-12T11:26:22Z", "message": "Merge branch 'master' into r2dbc_support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e145cc1b4bd088b9bc87ba562206938587133715", "author": {"user": {"login": "bsideup", "name": "Sergei Egorov"}}, "url": "https://github.com/testcontainers/testcontainers-java/commit/e145cc1b4bd088b9bc87ba562206938587133715", "committedDate": "2020-04-12T11:33:51Z", "message": "add docs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxODU4MjI0", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#pullrequestreview-391858224", "createdAt": "2020-04-12T13:37:43Z", "commit": {"oid": "e145cc1b4bd088b9bc87ba562206938587133715"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMlQxMzozNzo0NFrOGEVe9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMlQxMzozNzo0NFrOGEVe9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE5OTQ3Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                both the database module like `org.testcontainers:mysql` **and** `org.testcontainers:r2dbc` need to be on your application's classpath at runtime for this to work.\n          \n          \n            \n                Both the database module (e.g. `org.testcontainers:mysql`) **and** `org.testcontainers:r2dbc` need to be on your application's classpath at runtime.", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r407199477", "createdAt": "2020-04-12T13:37:44Z", "author": {"login": "rnorth"}, "path": "docs/modules/databases/r2dbc.md", "diffHunk": "@@ -0,0 +1,55 @@\n+# R2DBC support\n+\n+You can obtain a temporary database in one of two ways:\n+\n+ * **Using a specially modified R2DBC URL**: after making a very simple modification to your system's R2DBC URL string, Testcontainers will provide a disposable stand-in database that can be used without requiring modification to your application code.\n+ * **JUnit @Rule/@ClassRule**: this mode starts a database inside a container before your tests and tears it down afterwards.\n+\n+## Database containers launched via R2DBC URL scheme\n+\n+As long as you have Testcontainers and the appropriate R2DBC driver on your classpath, you can simply modify regular R2DBC connection URLs to get a fresh containerized instance of the database each time your application starts up.\n+\n+Started container will be terminated when the `ConnectionFactory` is closed.\n+\n+!!! warning\n+    both the database module like `org.testcontainers:mysql` **and** `org.testcontainers:r2dbc` need to be on your application's classpath at runtime for this to work.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e145cc1b4bd088b9bc87ba562206938587133715"}, "originalPosition": 15}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "830f483fc8f7aff05bb3b7e6a5831a89e25fdbc6", "author": {"user": {"login": "bsideup", "name": "Sergei Egorov"}}, "url": "https://github.com/testcontainers/testcontainers-java/commit/830f483fc8f7aff05bb3b7e6a5831a89e25fdbc6", "committedDate": "2020-04-12T13:38:05Z", "message": "Update docs/modules/databases/r2dbc.md\n\nCo-Authored-By: Richard North <rich.north@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxODU4Mjc0", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#pullrequestreview-391858274", "createdAt": "2020-04-12T13:38:22Z", "commit": {"oid": "e145cc1b4bd088b9bc87ba562206938587133715"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMlQxMzozODoyMlrOGEVfPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMlQxMzozODoyMlrOGEVfPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE5OTU0OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Started container will be terminated when the `ConnectionFactory` is closed.\n          \n          \n            \n            The started container will be terminated when the `ConnectionFactory` is closed.", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r407199548", "createdAt": "2020-04-12T13:38:22Z", "author": {"login": "rnorth"}, "path": "docs/modules/databases/r2dbc.md", "diffHunk": "@@ -0,0 +1,55 @@\n+# R2DBC support\n+\n+You can obtain a temporary database in one of two ways:\n+\n+ * **Using a specially modified R2DBC URL**: after making a very simple modification to your system's R2DBC URL string, Testcontainers will provide a disposable stand-in database that can be used without requiring modification to your application code.\n+ * **JUnit @Rule/@ClassRule**: this mode starts a database inside a container before your tests and tears it down afterwards.\n+\n+## Database containers launched via R2DBC URL scheme\n+\n+As long as you have Testcontainers and the appropriate R2DBC driver on your classpath, you can simply modify regular R2DBC connection URLs to get a fresh containerized instance of the database each time your application starts up.\n+\n+Started container will be terminated when the `ConnectionFactory` is closed.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e145cc1b4bd088b9bc87ba562206938587133715"}, "originalPosition": 12}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3db13dc3c22f1a0a009a1552704abda074ec498f", "author": {"user": {"login": "bsideup", "name": "Sergei Egorov"}}, "url": "https://github.com/testcontainers/testcontainers-java/commit/3db13dc3c22f1a0a009a1552704abda074ec498f", "committedDate": "2020-04-12T13:39:09Z", "message": "Update docs/modules/databases/r2dbc.md\n\nCo-Authored-By: Richard North <rich.north@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxODU4NTY5", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#pullrequestreview-391858569", "createdAt": "2020-04-12T13:41:36Z", "commit": {"oid": "e145cc1b4bd088b9bc87ba562206938587133715"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMlQxMzo0MTozNlrOGEVg0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMlQxMzo0MTozNlrOGEVg0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE5OTk1Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            1. Specify the mandatory Docker tag of database's official image that you want to use as `TC_IMAGE_TAG`\n          \n          \n            \n            1. Specify the mandatory Docker tag of the database's official image that you want using a `TC_IMAGE_TAG` query parameter.\n          \n          \n            \n            \n          \n          \n            \n            **Note that, unlike Testcontainers' JDBC URL support, it is not possible to specify an image tag in the 'scheme' part of the URL, and it is always necessary to specify a tag using `TC_IMAGE_TAG`.**", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#discussion_r407199953", "createdAt": "2020-04-12T13:41:36Z", "author": {"login": "rnorth"}, "path": "docs/modules/databases/r2dbc.md", "diffHunk": "@@ -0,0 +1,55 @@\n+# R2DBC support\n+\n+You can obtain a temporary database in one of two ways:\n+\n+ * **Using a specially modified R2DBC URL**: after making a very simple modification to your system's R2DBC URL string, Testcontainers will provide a disposable stand-in database that can be used without requiring modification to your application code.\n+ * **JUnit @Rule/@ClassRule**: this mode starts a database inside a container before your tests and tears it down afterwards.\n+\n+## Database containers launched via R2DBC URL scheme\n+\n+As long as you have Testcontainers and the appropriate R2DBC driver on your classpath, you can simply modify regular R2DBC connection URLs to get a fresh containerized instance of the database each time your application starts up.\n+\n+Started container will be terminated when the `ConnectionFactory` is closed.\n+\n+!!! warning\n+    both the database module like `org.testcontainers:mysql` **and** `org.testcontainers:r2dbc` need to be on your application's classpath at runtime for this to work.\n+\n+**Original URL**: `r2dbc:mysql://localhost:3306/databasename`\n+\n+1. Insert `tc:` after `r2dbc:` as follows. Note that the hostname, port and database name will be ignored; you can leave these as-is or set them to any value.\n+1. Specify the mandatory Docker tag of database's official image that you want to use as `TC_IMAGE_TAG`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e145cc1b4bd088b9bc87ba562206938587133715"}, "originalPosition": 20}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38e81dc1c6a23a90432cb9b2da50c07e2f609e80", "author": {"user": {"login": "bsideup", "name": "Sergei Egorov"}}, "url": "https://github.com/testcontainers/testcontainers-java/commit/38e81dc1c6a23a90432cb9b2da50c07e2f609e80", "committedDate": "2020-04-12T14:20:48Z", "message": "Update docs/modules/databases/r2dbc.md\n\nCo-Authored-By: Richard North <rich.north@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxODYzMTQ2", "url": "https://github.com/testcontainers/testcontainers-java/pull/2545#pullrequestreview-391863146", "createdAt": "2020-04-12T14:29:15Z", "commit": {"oid": "38e81dc1c6a23a90432cb9b2da50c07e2f609e80"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b28fb65ad718fc47309a789ba726b8297327fb67", "author": {"user": {"login": "rnorth", "name": "Richard North"}}, "url": "https://github.com/testcontainers/testcontainers-java/commit/b28fb65ad718fc47309a789ba726b8297327fb67", "committedDate": "2020-04-12T16:03:28Z", "message": "Merge branch 'master' into r2dbc_support"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3389, "cost": 1, "resetAt": "2021-11-02T12:20:56Z"}}}