{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk1MjgzOTI5", "number": 2491, "title": "Rewrite Couchbase module. closes #2447", "bodyText": "Closes #2486.", "createdAt": "2020-03-29T17:00:26Z", "url": "https://github.com/testcontainers/testcontainers-java/pull/2491", "merged": true, "mergeCommit": {"oid": "c6e0cd9faf83a160bf1cb4b3f0b6b7b9535daad2"}, "closed": true, "closedAt": "2020-04-12T18:23:52Z", "author": {"login": "bsideup"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcRyH4BgH2gAyMzk1MjgzOTI5OjA1OWQ5YjU4MDdmYjBhOWQ1Zjc4NGU0NGQ0ZGVmZWI3YjZmMDNmMDY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcW-hVAAFqTM5MTg4MzMwMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "059d9b5807fb0a9d5f784e44d4defeb7b6f03f06", "author": {"user": {"login": "daschl", "name": "Michael Nitschinger"}}, "url": "https://github.com/testcontainers/testcontainers-java/commit/059d9b5807fb0a9d5f784e44d4defeb7b6f03f06", "committedDate": "2020-03-27T15:06:39Z", "message": "Rewrite couchbase module. closes #2447\n\nThis changeset completely reworks the couchbase module and hopefully\ngreatly improve the out-of-the-box experience. Note that this is a\nbreaking change over the previous code because by intention it does\nNOT depend on SDK 2 so you can test SDK 2 and 3 with it at the same\ntime.\n\nHighlights:\n\n - Removed the need for a SDK, so both 2 and 3 can be used with it.\n - Updated to 6.5.0 baseline and using alternate addresses for\n   \"proper\" port exposure without having to rely on the socat\n   proxy container like the previous version had to.\n - Allows to define which services should be exposed and handles\n   states automatically (i.e. will not try to create the primary\n   index if the query service is not enabled).\n\nNote that a bunch of tests have been removed since they are not\nadequate anymore. A side effect of the alternate address change\nis that older servers cannot be used. 6.5.0 is available in both\nCE and EE, and Couchbase in general allows EE versions to be used\nin development and testing so we should use it if we can."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7613933e1de58dac954677387299820e3353f8cc", "author": {"user": {"login": "daschl", "name": "Michael Nitschinger"}}, "url": "https://github.com/testcontainers/testcontainers-java/commit/7613933e1de58dac954677387299820e3353f8cc", "committedDate": "2020-03-27T15:31:11Z", "message": "Wait until query respsonds with 200"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e02eab968ac95b949f39c079cab0783ad9f30d80", "author": {"user": {"login": "bsideup", "name": "Sergei Egorov"}}, "url": "https://github.com/testcontainers/testcontainers-java/commit/e02eab968ac95b949f39c079cab0783ad9f30d80", "committedDate": "2020-03-29T16:52:16Z", "message": "fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzNDM3ODQw", "url": "https://github.com/testcontainers/testcontainers-java/pull/2491#pullrequestreview-383437840", "createdAt": "2020-03-29T17:58:20Z", "commit": {"oid": "e02eab968ac95b949f39c079cab0783ad9f30d80"}, "state": "APPROVED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNzo1ODoyMVrOF9TyGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxODo0NDowNlrOF9UGUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgzMTU3Nw==", "bodyText": "Ideally, we add the original source of this file, for future reference.", "url": "https://github.com/testcontainers/testcontainers-java/pull/2491#discussion_r399831577", "createdAt": "2020-03-29T17:58:21Z", "author": {"login": "kiview"}, "path": "modules/couchbase/src/main/java/org/testcontainers/couchbase/BucketDefinition.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright (c) 2020 Couchbase, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e02eab968ac95b949f39c079cab0783ad9f30d80"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgzMjcyMA==", "bodyText": "I know this is a big breaking change after all, but in other modules, we sometimes also have image name and tag public.", "url": "https://github.com/testcontainers/testcontainers-java/pull/2491#discussion_r399832720", "createdAt": "2020-03-29T18:08:52Z", "author": {"login": "kiview"}, "path": "modules/couchbase/src/main/java/org/testcontainers/couchbase/CouchbaseContainer.java", "diffHunk": "@@ -15,447 +15,423 @@\n  */\n package org.testcontainers.couchbase;\n \n-import com.couchbase.client.core.utils.Base64;\n-import com.couchbase.client.java.Bucket;\n-import com.couchbase.client.java.CouchbaseCluster;\n-import com.couchbase.client.java.cluster.*;\n-import com.couchbase.client.java.env.CouchbaseEnvironment;\n-import com.couchbase.client.java.env.DefaultCouchbaseEnvironment;\n-import com.couchbase.client.java.query.Index;\n import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.github.dockerjava.api.command.ExecCreateCmdResponse;\n import com.github.dockerjava.api.command.InspectContainerResponse;\n-import com.google.common.collect.Lists;\n-import lombok.*;\n-import org.apache.commons.compress.utils.Sets;\n-import org.apache.commons.io.IOUtils;\n-import org.jetbrains.annotations.NotNull;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import okhttp3.Credentials;\n+import okhttp3.FormBody;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n import org.testcontainers.containers.GenericContainer;\n-import org.testcontainers.containers.Network;\n-import org.testcontainers.containers.SocatContainer;\n import org.testcontainers.containers.wait.strategy.HttpWaitStrategy;\n-import org.testcontainers.images.builder.Transferable;\n-import org.testcontainers.utility.ThrowingFunction;\n+import org.testcontainers.containers.wait.strategy.WaitAllStrategy;\n \n-import java.io.DataOutputStream;\n import java.io.IOException;\n-import java.net.HttpURLConnection;\n-import java.net.URL;\n-import java.net.URLEncoder;\n-import java.nio.charset.StandardCharsets;\n-import java.util.*;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import static java.net.HttpURLConnection.HTTP_OK;\n-import static org.testcontainers.couchbase.CouchbaseContainer.CouchbasePort.*;\n \n /**\n- * Based on Laurent Doguin version,\n+ * The couchbase container initializes and configures a Couchbase Server single node cluster.\n  * <p>\n- * optimized by Tayeb Chlyah\n+ * Note that it does not depend on a specific couchbase SDK, so it can be used with both the Java SDK 2 and 3 as well\n+ * as the Scala SDK 1 or newer. We recommend using the latest and greatest SDKs for the best experience.\n  */\n-@AllArgsConstructor\n public class CouchbaseContainer extends GenericContainer<CouchbaseContainer> {\n \n-    public static final String VERSION = \"5.5.1\";\n-    public static final String DOCKER_IMAGE_NAME = \"couchbase/server:\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e02eab968ac95b949f39c079cab0783ad9f30d80"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgzMjgwMQ==", "bodyText": "Big timeout necessary for startup?", "url": "https://github.com/testcontainers/testcontainers-java/pull/2491#discussion_r399832801", "createdAt": "2020-03-29T18:09:30Z", "author": {"login": "kiview"}, "path": "modules/couchbase/src/main/java/org/testcontainers/couchbase/CouchbaseContainer.java", "diffHunk": "@@ -15,447 +15,423 @@\n  */\n package org.testcontainers.couchbase;\n \n-import com.couchbase.client.core.utils.Base64;\n-import com.couchbase.client.java.Bucket;\n-import com.couchbase.client.java.CouchbaseCluster;\n-import com.couchbase.client.java.cluster.*;\n-import com.couchbase.client.java.env.CouchbaseEnvironment;\n-import com.couchbase.client.java.env.DefaultCouchbaseEnvironment;\n-import com.couchbase.client.java.query.Index;\n import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.github.dockerjava.api.command.ExecCreateCmdResponse;\n import com.github.dockerjava.api.command.InspectContainerResponse;\n-import com.google.common.collect.Lists;\n-import lombok.*;\n-import org.apache.commons.compress.utils.Sets;\n-import org.apache.commons.io.IOUtils;\n-import org.jetbrains.annotations.NotNull;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import okhttp3.Credentials;\n+import okhttp3.FormBody;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n import org.testcontainers.containers.GenericContainer;\n-import org.testcontainers.containers.Network;\n-import org.testcontainers.containers.SocatContainer;\n import org.testcontainers.containers.wait.strategy.HttpWaitStrategy;\n-import org.testcontainers.images.builder.Transferable;\n-import org.testcontainers.utility.ThrowingFunction;\n+import org.testcontainers.containers.wait.strategy.WaitAllStrategy;\n \n-import java.io.DataOutputStream;\n import java.io.IOException;\n-import java.net.HttpURLConnection;\n-import java.net.URL;\n-import java.net.URLEncoder;\n-import java.nio.charset.StandardCharsets;\n-import java.util.*;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import static java.net.HttpURLConnection.HTTP_OK;\n-import static org.testcontainers.couchbase.CouchbaseContainer.CouchbasePort.*;\n \n /**\n- * Based on Laurent Doguin version,\n+ * The couchbase container initializes and configures a Couchbase Server single node cluster.\n  * <p>\n- * optimized by Tayeb Chlyah\n+ * Note that it does not depend on a specific couchbase SDK, so it can be used with both the Java SDK 2 and 3 as well\n+ * as the Scala SDK 1 or newer. We recommend using the latest and greatest SDKs for the best experience.\n  */\n-@AllArgsConstructor\n public class CouchbaseContainer extends GenericContainer<CouchbaseContainer> {\n \n-    public static final String VERSION = \"5.5.1\";\n-    public static final String DOCKER_IMAGE_NAME = \"couchbase/server:\";\n-    public static final ObjectMapper MAPPER = new ObjectMapper();\n-    public static final String STATIC_CONFIG = \"/opt/couchbase/etc/couchbase/static_config\";\n-    public static final String CAPI_CONFIG = \"/opt/couchbase/etc/couchdb/default.d/capi.ini\";\n+    private static final int MGMT_PORT = 8091;\n+\n+    private static final int MGMT_SSL_PORT = 18091;\n+\n+    private static final int VIEW_PORT = 8092;\n \n-    private static final int REQUIRED_DEFAULT_PASSWORD_LENGTH = 6;\n+    private static final int VIEW_SSL_PORT = 18092;\n \n-    private String memoryQuota = \"300\";\n+    private static final int QUERY_PORT = 8093;\n \n-    private String indexMemoryQuota = \"300\";\n+    private static final int QUERY_SSL_PORT = 18093;\n \n-    private String clusterUsername = \"Administrator\";\n+    private static final int SEARCH_PORT = 8094;\n \n-    private String clusterPassword = \"password\";\n+    private static final int SEARCH_SSL_PORT = 18094;\n \n-    private boolean keyValue = true;\n+    private static final int KV_PORT = 11210;\n \n-    @Getter\n-    private boolean query = true;\n+    private static final int KV_SSL_PORT = 11207;\n \n-    @Getter\n-    private boolean index = true;\n+    private static final String DOCKER_IMAGE_NAME = \"couchbase/server\";\n \n-    @Getter\n-    private boolean primaryIndex = true;\n+    private static final String VERSION = \"6.5.0\";\n \n-    @Getter\n-    private boolean fts = false;\n+    private static final ObjectMapper MAPPER = new ObjectMapper();\n \n-    @Getter(lazy = true)\n-    private final CouchbaseEnvironment couchbaseEnvironment = createCouchbaseEnvironment();\n+    private static final OkHttpClient HTTP_CLIENT = new OkHttpClient()\n+        .newBuilder()\n+        .readTimeout(Duration.ofMinutes(1))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e02eab968ac95b949f39c079cab0783ad9f30d80"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgzMjkyNA==", "bodyText": "ok, old code was awkward here \ud83d\ude06", "url": "https://github.com/testcontainers/testcontainers-java/pull/2491#discussion_r399832924", "createdAt": "2020-03-29T18:10:35Z", "author": {"login": "kiview"}, "path": "modules/couchbase/src/main/java/org/testcontainers/couchbase/CouchbaseContainer.java", "diffHunk": "@@ -15,447 +15,423 @@\n  */\n package org.testcontainers.couchbase;\n \n-import com.couchbase.client.core.utils.Base64;\n-import com.couchbase.client.java.Bucket;\n-import com.couchbase.client.java.CouchbaseCluster;\n-import com.couchbase.client.java.cluster.*;\n-import com.couchbase.client.java.env.CouchbaseEnvironment;\n-import com.couchbase.client.java.env.DefaultCouchbaseEnvironment;\n-import com.couchbase.client.java.query.Index;\n import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.github.dockerjava.api.command.ExecCreateCmdResponse;\n import com.github.dockerjava.api.command.InspectContainerResponse;\n-import com.google.common.collect.Lists;\n-import lombok.*;\n-import org.apache.commons.compress.utils.Sets;\n-import org.apache.commons.io.IOUtils;\n-import org.jetbrains.annotations.NotNull;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import okhttp3.Credentials;\n+import okhttp3.FormBody;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n import org.testcontainers.containers.GenericContainer;\n-import org.testcontainers.containers.Network;\n-import org.testcontainers.containers.SocatContainer;\n import org.testcontainers.containers.wait.strategy.HttpWaitStrategy;\n-import org.testcontainers.images.builder.Transferable;\n-import org.testcontainers.utility.ThrowingFunction;\n+import org.testcontainers.containers.wait.strategy.WaitAllStrategy;\n \n-import java.io.DataOutputStream;\n import java.io.IOException;\n-import java.net.HttpURLConnection;\n-import java.net.URL;\n-import java.net.URLEncoder;\n-import java.nio.charset.StandardCharsets;\n-import java.util.*;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import static java.net.HttpURLConnection.HTTP_OK;\n-import static org.testcontainers.couchbase.CouchbaseContainer.CouchbasePort.*;\n \n /**\n- * Based on Laurent Doguin version,\n+ * The couchbase container initializes and configures a Couchbase Server single node cluster.\n  * <p>\n- * optimized by Tayeb Chlyah\n+ * Note that it does not depend on a specific couchbase SDK, so it can be used with both the Java SDK 2 and 3 as well\n+ * as the Scala SDK 1 or newer. We recommend using the latest and greatest SDKs for the best experience.\n  */\n-@AllArgsConstructor\n public class CouchbaseContainer extends GenericContainer<CouchbaseContainer> {\n \n-    public static final String VERSION = \"5.5.1\";\n-    public static final String DOCKER_IMAGE_NAME = \"couchbase/server:\";\n-    public static final ObjectMapper MAPPER = new ObjectMapper();\n-    public static final String STATIC_CONFIG = \"/opt/couchbase/etc/couchbase/static_config\";\n-    public static final String CAPI_CONFIG = \"/opt/couchbase/etc/couchdb/default.d/capi.ini\";\n+    private static final int MGMT_PORT = 8091;\n+\n+    private static final int MGMT_SSL_PORT = 18091;\n+\n+    private static final int VIEW_PORT = 8092;\n \n-    private static final int REQUIRED_DEFAULT_PASSWORD_LENGTH = 6;\n+    private static final int VIEW_SSL_PORT = 18092;\n \n-    private String memoryQuota = \"300\";\n+    private static final int QUERY_PORT = 8093;\n \n-    private String indexMemoryQuota = \"300\";\n+    private static final int QUERY_SSL_PORT = 18093;\n \n-    private String clusterUsername = \"Administrator\";\n+    private static final int SEARCH_PORT = 8094;\n \n-    private String clusterPassword = \"password\";\n+    private static final int SEARCH_SSL_PORT = 18094;\n \n-    private boolean keyValue = true;\n+    private static final int KV_PORT = 11210;\n \n-    @Getter\n-    private boolean query = true;\n+    private static final int KV_SSL_PORT = 11207;\n \n-    @Getter\n-    private boolean index = true;\n+    private static final String DOCKER_IMAGE_NAME = \"couchbase/server\";\n \n-    @Getter\n-    private boolean primaryIndex = true;\n+    private static final String VERSION = \"6.5.0\";\n \n-    @Getter\n-    private boolean fts = false;\n+    private static final ObjectMapper MAPPER = new ObjectMapper();\n \n-    @Getter(lazy = true)\n-    private final CouchbaseEnvironment couchbaseEnvironment = createCouchbaseEnvironment();\n+    private static final OkHttpClient HTTP_CLIENT = new OkHttpClient()\n+        .newBuilder()\n+        .readTimeout(Duration.ofMinutes(1))\n+        .build();\n \n-    @Getter(lazy = true)\n-    private final CouchbaseCluster couchbaseCluster = createCouchbaseCluster();\n+    private String username = \"Administrator\";\n \n-    private List<BucketAndUserSettings> newBuckets = new ArrayList<>();\n+    private String password = \"password\";\n \n-    private String urlBase;\n+    private Set<CouchbaseService> enabledServices = EnumSet.allOf(CouchbaseService.class);\n \n-    private SocatContainer proxy;\n+    private final List<BucketDefinition> buckets = new ArrayList<>();\n \n+    /**\n+     * Creates a new couchbase container with the default image and version.\n+     */\n     public CouchbaseContainer() {\n-        this(DOCKER_IMAGE_NAME + VERSION);\n+        this(DOCKER_IMAGE_NAME + \":\" + VERSION);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e02eab968ac95b949f39c079cab0783ad9f30d80"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgzMzExOA==", "bodyText": "Nice idea from a user perspective, but this behaves very different (better?) than other TC modules.", "url": "https://github.com/testcontainers/testcontainers-java/pull/2491#discussion_r399833118", "createdAt": "2020-03-29T18:12:41Z", "author": {"login": "kiview"}, "path": "modules/couchbase/src/main/java/org/testcontainers/couchbase/CouchbaseContainer.java", "diffHunk": "@@ -15,447 +15,423 @@\n  */\n package org.testcontainers.couchbase;\n \n-import com.couchbase.client.core.utils.Base64;\n-import com.couchbase.client.java.Bucket;\n-import com.couchbase.client.java.CouchbaseCluster;\n-import com.couchbase.client.java.cluster.*;\n-import com.couchbase.client.java.env.CouchbaseEnvironment;\n-import com.couchbase.client.java.env.DefaultCouchbaseEnvironment;\n-import com.couchbase.client.java.query.Index;\n import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.github.dockerjava.api.command.ExecCreateCmdResponse;\n import com.github.dockerjava.api.command.InspectContainerResponse;\n-import com.google.common.collect.Lists;\n-import lombok.*;\n-import org.apache.commons.compress.utils.Sets;\n-import org.apache.commons.io.IOUtils;\n-import org.jetbrains.annotations.NotNull;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import okhttp3.Credentials;\n+import okhttp3.FormBody;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n import org.testcontainers.containers.GenericContainer;\n-import org.testcontainers.containers.Network;\n-import org.testcontainers.containers.SocatContainer;\n import org.testcontainers.containers.wait.strategy.HttpWaitStrategy;\n-import org.testcontainers.images.builder.Transferable;\n-import org.testcontainers.utility.ThrowingFunction;\n+import org.testcontainers.containers.wait.strategy.WaitAllStrategy;\n \n-import java.io.DataOutputStream;\n import java.io.IOException;\n-import java.net.HttpURLConnection;\n-import java.net.URL;\n-import java.net.URLEncoder;\n-import java.nio.charset.StandardCharsets;\n-import java.util.*;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import static java.net.HttpURLConnection.HTTP_OK;\n-import static org.testcontainers.couchbase.CouchbaseContainer.CouchbasePort.*;\n \n /**\n- * Based on Laurent Doguin version,\n+ * The couchbase container initializes and configures a Couchbase Server single node cluster.\n  * <p>\n- * optimized by Tayeb Chlyah\n+ * Note that it does not depend on a specific couchbase SDK, so it can be used with both the Java SDK 2 and 3 as well\n+ * as the Scala SDK 1 or newer. We recommend using the latest and greatest SDKs for the best experience.\n  */\n-@AllArgsConstructor\n public class CouchbaseContainer extends GenericContainer<CouchbaseContainer> {\n \n-    public static final String VERSION = \"5.5.1\";\n-    public static final String DOCKER_IMAGE_NAME = \"couchbase/server:\";\n-    public static final ObjectMapper MAPPER = new ObjectMapper();\n-    public static final String STATIC_CONFIG = \"/opt/couchbase/etc/couchbase/static_config\";\n-    public static final String CAPI_CONFIG = \"/opt/couchbase/etc/couchdb/default.d/capi.ini\";\n+    private static final int MGMT_PORT = 8091;\n+\n+    private static final int MGMT_SSL_PORT = 18091;\n+\n+    private static final int VIEW_PORT = 8092;\n \n-    private static final int REQUIRED_DEFAULT_PASSWORD_LENGTH = 6;\n+    private static final int VIEW_SSL_PORT = 18092;\n \n-    private String memoryQuota = \"300\";\n+    private static final int QUERY_PORT = 8093;\n \n-    private String indexMemoryQuota = \"300\";\n+    private static final int QUERY_SSL_PORT = 18093;\n \n-    private String clusterUsername = \"Administrator\";\n+    private static final int SEARCH_PORT = 8094;\n \n-    private String clusterPassword = \"password\";\n+    private static final int SEARCH_SSL_PORT = 18094;\n \n-    private boolean keyValue = true;\n+    private static final int KV_PORT = 11210;\n \n-    @Getter\n-    private boolean query = true;\n+    private static final int KV_SSL_PORT = 11207;\n \n-    @Getter\n-    private boolean index = true;\n+    private static final String DOCKER_IMAGE_NAME = \"couchbase/server\";\n \n-    @Getter\n-    private boolean primaryIndex = true;\n+    private static final String VERSION = \"6.5.0\";\n \n-    @Getter\n-    private boolean fts = false;\n+    private static final ObjectMapper MAPPER = new ObjectMapper();\n \n-    @Getter(lazy = true)\n-    private final CouchbaseEnvironment couchbaseEnvironment = createCouchbaseEnvironment();\n+    private static final OkHttpClient HTTP_CLIENT = new OkHttpClient()\n+        .newBuilder()\n+        .readTimeout(Duration.ofMinutes(1))\n+        .build();\n \n-    @Getter(lazy = true)\n-    private final CouchbaseCluster couchbaseCluster = createCouchbaseCluster();\n+    private String username = \"Administrator\";\n \n-    private List<BucketAndUserSettings> newBuckets = new ArrayList<>();\n+    private String password = \"password\";\n \n-    private String urlBase;\n+    private Set<CouchbaseService> enabledServices = EnumSet.allOf(CouchbaseService.class);\n \n-    private SocatContainer proxy;\n+    private final List<BucketDefinition> buckets = new ArrayList<>();\n \n+    /**\n+     * Creates a new couchbase container with the default image and version.\n+     */\n     public CouchbaseContainer() {\n-        this(DOCKER_IMAGE_NAME + VERSION);\n+        this(DOCKER_IMAGE_NAME + \":\" + VERSION);\n     }\n \n-    public CouchbaseContainer(String imageName) {\n+    /**\n+     * Creates a new couchbase container with a custom image name.\n+     *\n+     * @param imageName the image name that should be used.\n+     */\n+    public CouchbaseContainer(final String imageName) {\n         super(imageName);\n-\n-        withNetwork(Network.SHARED);\n-        setWaitStrategy(new HttpWaitStrategy().forPath(\"/ui/index.html\"));\n     }\n \n-    @Override\n-    public Set<Integer> getLivenessCheckPortNumbers() {\n-        return Sets.newHashSet(getMappedPort(REST));\n+    /**\n+     * Set custom username and password for the admin user.\n+     *\n+     * @param username the admin username to use.\n+     * @param password the password for the admin user.\n+     * @return this {@link CouchbaseContainer} for chaining purposes.\n+     */\n+    public CouchbaseContainer withCredentials(final String username, final String password) {\n+        checkNotRunning();\n+        this.username = username;\n+        this.password = password;\n+        return this;\n     }\n \n-    @Override\n-    protected void configure() {\n-        if (clusterPassword.length() < REQUIRED_DEFAULT_PASSWORD_LENGTH) {\n-            logger().warn(\"The provided cluster admin password length is less then the default password policy length. \" +\n-                \"Cluster start will fail if configured password requirements are not met.\");\n-        }\n+    public CouchbaseContainer withBucket(final BucketDefinition bucketDefinition) {\n+        checkNotRunning();\n+        this.buckets.add(bucketDefinition);\n+        return this;\n     }\n \n-    @Override\n-    @SneakyThrows\n-    protected void doStart() {\n-        startProxy(getNetworkAliases().get(0));\n-        try {\n-            super.doStart();\n-        } catch (Throwable e) {\n-            proxy.stop();\n-            throw e;\n-        }\n+    public CouchbaseContainer withEnabledServices(final CouchbaseService... enabled) {\n+        checkNotRunning();\n+        this.enabledServices = EnumSet.copyOf(Arrays.asList(enabled));\n+        return this;\n     }\n \n-    @SneakyThrows\n-    private void startProxy(String networkAlias) {\n-        proxy = new SocatContainer().withNetwork(getNetwork());\n-\n-        for (CouchbasePort port : CouchbasePort.values()) {\n-            if (port.isDynamic()) {\n-                proxy.withTarget(port.getOriginalPort(), networkAlias);\n-            } else {\n-                proxy.addExposedPort(port.getOriginalPort());\n-            }\n-        }\n-\n-        proxy.setWaitStrategy(null);\n-        proxy.start();\n-\n-        ExecCreateCmdResponse createCmdResponse = dockerClient\n-            .execCreateCmd(proxy.getContainerId())\n-            .withCmd(\n-                \"sh\",\n-                \"-c\",\n-                Stream.of(CouchbasePort.values())\n-                    .map(port -> {\n-                        return \"/usr/bin/socat \" +\n-                            \"TCP-LISTEN:\" + port.getOriginalPort() + \",fork,reuseaddr \" +\n-                            \"TCP:\" + networkAlias + \":\" + getMappedPort(port);\n-                    })\n-                    .collect(Collectors.joining(\" & \", \"true\", \"\"))\n-            )\n-            .exec();\n-\n-        dockerClient.execStartCmd(createCmdResponse.getId())\n-            .start()\n-            .awaitCompletion(10, TimeUnit.SECONDS);\n+    public final String getUsername() {\n+        return username;\n     }\n \n-    @Override\n-    public List<Integer> getExposedPorts() {\n-        return proxy.getExposedPorts();\n+    public final String getPassword() {\n+        return password;\n     }\n \n-    @Override\n-    public String getContainerIpAddress() {\n-        return proxy.getContainerIpAddress();\n+    public String getConnectionString() {\n+        return String.format(\"couchbase://%s:%d\", getContainerIpAddress(), getMappedPort(KV_PORT));\n     }\n \n     @Override\n-    public Integer getMappedPort(int originalPort) {\n-        return proxy.getMappedPort(originalPort);\n-    }\n+    protected void configure() {\n+        super.configure();\n+\n+        WaitAllStrategy waitStrategy = new WaitAllStrategy();\n+\n+        // Makes sure that all nodes in the cluster are healthy.\n+        waitStrategy = waitStrategy.withStrategy(\n+            new HttpWaitStrategy()\n+                .forPath(\"/pools/default\")\n+                .forPort(MGMT_PORT)\n+                .withBasicCredentials(username, password)\n+                .forStatusCode(200)\n+                .forResponsePredicate(response -> {\n+                    try {\n+                        return Optional.of(MAPPER.readTree(response))\n+                            .map(n -> n.at(\"/nodes/0/status\"))\n+                            .map(JsonNode::asText)\n+                            .map(\"healthy\"::equals)\n+                            .orElse(false);\n+                    } catch (IOException e) {\n+                        logger().error(\"Unable to parse response {}\", response);\n+                        return false;\n+                    }\n+                })\n+        );\n+\n+        if (enabledServices.contains(CouchbaseService.QUERY)) {\n+            waitStrategy = waitStrategy.withStrategy(\n+                new HttpWaitStrategy()\n+                    .forPath(\"/admin/ping\")\n+                    .forPort(QUERY_PORT)\n+                    .withBasicCredentials(username, password)\n+                    .forStatusCode(200)\n+            );\n+        }\n \n-    protected Integer getMappedPort(CouchbasePort port) {\n-        return getMappedPort(port.getOriginalPort());\n+        waitingFor(waitStrategy);\n     }\n \n     @Override\n-    public List<Integer> getBoundPortNumbers() {\n-        return proxy.getBoundPortNumbers();\n+    protected void containerIsStarting(final InspectContainerResponse containerInfo) {\n+        logger().debug(\"Couchbase container is starting, performing configuration.\");\n+\n+        waitUntilNodeIsOnline();\n+        renameNode();\n+        initializeServices();\n+        configureAdminUser();\n+        configureExternalPorts();\n+        if (enabledServices.contains(CouchbaseService.INDEX)) {\n+            configureIndexer();\n+        }\n     }\n \n     @Override\n-    @SuppressWarnings({\"unchecked\", \"ConstantConditions\"})\n-    public void stop() {\n-        try {\n-            stopCluster();\n-            ((AtomicReference<Object>) (Object) couchbaseEnvironment).set(null);\n-            ((AtomicReference<Object>) (Object) couchbaseCluster).set(null);\n-        } finally {\n-            Stream.<Runnable>of(super::stop, proxy::stop).parallel().forEach(Runnable::run);\n+    protected void containerIsStarted(InspectContainerResponse containerInfo) {\n+        createBuckets();\n+        logger().info(\"Couchbase container is ready! UI available at http://{}:{}\", getContainerIpAddress(), getMappedPort(MGMT_PORT));\n+    }\n+\n+    /**\n+     * Before we can start configuring the host, we need to wait until the cluster manager is listening.\n+     */\n+    private void waitUntilNodeIsOnline() {\n+        new HttpWaitStrategy()\n+            .forPort(MGMT_PORT)\n+            .forPath(\"/pools\")\n+            .forStatusCode(200)\n+            .waitUntilReady(this);\n+    }\n+\n+    /**\n+     * Rebinds/renames the internal hostname.\n+     * <p>\n+     * To make sure the internal hostname is different from the external (alternate) address and the SDK can pick it\n+     * up automatically, we bind the internal hostname to the internal IP address.\n+     */\n+    private void renameNode() {\n+        logger().debug(\"Renaming Couchbase Node from localhost to \" + getContainerIpAddress());\n+\n+        Response response = doHttpRequest(MGMT_PORT, \"/node/controller/rename\", \"POST\", new FormBody.Builder()\n+            .add(\"hostname\", getInternalIpAddress())\n+            .build(), false\n+        );\n+\n+        checkSuccessfulResponse(response, \"Could not rename couchbase node\");\n+    }\n+\n+    /**\n+     * Initializes services based on the configured enabled services.\n+     */\n+    private void initializeServices() {\n+        logger().debug(\"Initializing couchbase services on host: \" + enabledServices);\n+\n+        final String services = enabledServices.stream().map(s -> {\n+            switch (s) {\n+                case KV: return \"kv\";\n+                case QUERY: return \"n1ql\";\n+                case INDEX: return \"index\";\n+                case SEARCH: return \"fts\";\n+                default: throw new IllegalStateException(\"Unknown service!\");\n+            }\n+        }).collect(Collectors.joining(\",\"));\n+\n+        Response response = doHttpRequest(MGMT_PORT, \"/node/controller/setupServices\", \"POST\", new FormBody.Builder()\n+            .add(\"services\", services)\n+            .build(), false\n+        );\n+\n+        checkSuccessfulResponse(response, \"Could not enable couchbase services\");\n+    }\n+\n+    /**\n+     * Configures the admin user on the couchbase node.\n+     * <p>\n+     * After this stage, all subsequent API calls need to have the basic auth header set.\n+     */\n+    private void configureAdminUser() {\n+        logger().debug(\"Configuring couchbase admin user with username: \\\"\" + username + \"\\\"\");\n+\n+        Response response = doHttpRequest(MGMT_PORT, \"/settings/web\", \"POST\", new FormBody.Builder()\n+            .add(\"username\", username)\n+            .add(\"password\", password)\n+            .add(\"port\", Integer.toString(MGMT_PORT))\n+            .build(), false);\n+\n+        checkSuccessfulResponse(response, \"Could not configure couchbase admin user\");\n+    }\n+\n+    /**\n+     * Configures the external ports for SDK access.\n+     * <p>\n+     * Since the internal ports are not accessible from outside the container, this code configures the \"external\"\n+     * hostname and services to align with the mapped ports. The SDK will pick it up and then automatically connect\n+     * to those ports. Note that for all services non-ssl and ssl ports are configured.\n+     */\n+    private void configureExternalPorts() {\n+        logger().debug(\"Mapping external ports to the alternate address configuration\");\n+\n+        final FormBody.Builder builder = new FormBody.Builder();\n+        builder.add(\"hostname\", getContainerIpAddress());\n+        builder.add(\"mgmt\", Integer.toString(getMappedPort(MGMT_PORT)));\n+        builder.add(\"mgmtSSL\", Integer.toString(getMappedPort(MGMT_SSL_PORT)));\n+\n+        if (enabledServices.contains(CouchbaseService.KV)) {\n+            builder.add(\"kv\", Integer.toString(getMappedPort(KV_PORT)));\n+            builder.add(\"kvSSL\", Integer.toString(getMappedPort(KV_SSL_PORT)));\n+            builder.add(\"capi\", Integer.toString(getMappedPort(VIEW_PORT)));\n+            builder.add(\"capiSSL\", Integer.toString(getMappedPort(VIEW_SSL_PORT)));\n         }\n-    }\n \n-    private void stopCluster() {\n-        getCouchbaseCluster().disconnect();\n-        getCouchbaseEnvironment().shutdown();\n-    }\n-\n-    public CouchbaseContainer withNewBucket(BucketSettings bucketSettings) {\n-        newBuckets.add(new BucketAndUserSettings(bucketSettings));\n-        return self();\n-    }\n-\n-    public CouchbaseContainer withNewBucket(BucketSettings bucketSettings, UserSettings userSettings) {\n-        newBuckets.add(new BucketAndUserSettings(bucketSettings, userSettings));\n-        return self();\n-    }\n-\n-    @SneakyThrows\n-    public void initCluster() {\n-        urlBase = String.format(\"http://%s:%s\", getContainerIpAddress(), getMappedPort(REST));\n-        String poolURL = \"/pools/default\";\n-        String poolPayload = \"memoryQuota=\" + URLEncoder.encode(memoryQuota, \"UTF-8\") + \"&indexMemoryQuota=\" + URLEncoder.encode(indexMemoryQuota, \"UTF-8\");\n-\n-        String setupServicesURL = \"/node/controller/setupServices\";\n-        StringBuilder servicePayloadBuilder = new StringBuilder();\n-        if (keyValue) {\n-            servicePayloadBuilder.append(\"kv,\");\n-        }\n-        if (query) {\n-            servicePayloadBuilder.append(\"n1ql,\");\n-        }\n-        if (index) {\n-            servicePayloadBuilder.append(\"index,\");\n-        }\n-        if (fts) {\n-            servicePayloadBuilder.append(\"fts,\");\n+        if (enabledServices.contains(CouchbaseService.QUERY)) {\n+            builder.add(\"n1ql\", Integer.toString(getMappedPort(QUERY_PORT)));\n+            builder.add(\"n1qlSSL\", Integer.toString(getMappedPort(QUERY_SSL_PORT)));\n         }\n-        String setupServiceContent = \"services=\" + URLEncoder.encode(servicePayloadBuilder.toString(), \"UTF-8\");\n \n-        String webSettingsURL = \"/settings/web\";\n-        String webSettingsContent = \"username=\" + URLEncoder.encode(clusterUsername, \"UTF-8\") + \"&password=\" + URLEncoder.encode(clusterPassword, \"UTF-8\") + \"&port=8091\";\n-\n-        callCouchbaseRestAPI(poolURL, poolPayload);\n-        callCouchbaseRestAPI(setupServicesURL, setupServiceContent);\n-        callCouchbaseRestAPI(webSettingsURL, webSettingsContent);\n-\n-        createNodeWaitStrategy().waitUntilReady(this);\n-        callCouchbaseRestAPI(\"/settings/indexes\", \"indexerThreads=0&logLevel=info&maxRollbackPoints=5&storageMode=memory_optimized\");\n-    }\n-\n-    @NotNull\n-    private HttpWaitStrategy createNodeWaitStrategy() {\n-        return new HttpWaitStrategy()\n-            .forPath(\"/pools/default/\")\n-            .withBasicCredentials(clusterUsername, clusterPassword)\n-            .forStatusCode(HTTP_OK)\n-            .forResponsePredicate(response -> {\n-                try {\n-                    return Optional.of(MAPPER.readTree(response))\n-                        .map(n -> n.at(\"/nodes/0/status\"))\n-                        .map(JsonNode::asText)\n-                        .map(\"healthy\"::equals)\n-                        .orElse(false);\n-                } catch (IOException e) {\n-                    logger().error(\"Unable to parse response {}\", response);\n-                    return false;\n-                }\n-            });\n-    }\n-\n-    public void createBucket(BucketSettings bucketSetting, UserSettings userSettings, boolean primaryIndex) {\n-        ClusterManager clusterManager = getCouchbaseCluster().clusterManager(clusterUsername, clusterPassword);\n-        // Insert Bucket\n-        BucketSettings bucketSettings = clusterManager.insertBucket(bucketSetting);\n-        try {\n-            // Insert Bucket user\n-            clusterManager.upsertUser(AuthDomain.LOCAL, bucketSetting.name(), userSettings);\n-        } catch (Exception e) {\n-            logger().warn(\"Unable to insert user '\" + bucketSetting.name() + \"', maybe you are using older version\");\n+        if (enabledServices.contains(CouchbaseService.SEARCH)) {\n+            builder.add(\"fts\", Integer.toString(getMappedPort(SEARCH_PORT)));\n+            builder.add(\"ftsSSL\", Integer.toString(getMappedPort(SEARCH_SSL_PORT)));\n         }\n-        if (index) {\n-            Bucket bucket = getCouchbaseCluster().openBucket(bucketSettings.name(), bucketSettings.password());\n-            new CouchbaseQueryServiceWaitStrategy(bucket).waitUntilReady(this);\n-            if (primaryIndex) {\n-                bucket.query(Index.createPrimaryIndex().on(bucketSetting.name()));\n-            }\n-        }\n-    }\n \n-    public void callCouchbaseRestAPI(String url, String payload) throws IOException {\n-        String fullUrl = urlBase + url;\n-        @Cleanup(\"disconnect\")\n-        HttpURLConnection httpConnection = (HttpURLConnection) ((new URL(fullUrl).openConnection()));\n-        httpConnection.setDoOutput(true);\n-        httpConnection.setRequestMethod(\"POST\");\n-        httpConnection.setRequestProperty(\"Content-Type\",\n-            \"application/x-www-form-urlencoded\");\n-        String encoded = Base64.encode((clusterUsername + \":\" + clusterPassword).getBytes(\"UTF-8\"));\n-        httpConnection.setRequestProperty(\"Authorization\", \"Basic \" + encoded);\n-        @Cleanup\n-        DataOutputStream out = new DataOutputStream(httpConnection.getOutputStream());\n-        out.writeBytes(payload);\n-        out.flush();\n-        httpConnection.getResponseCode();\n-    }\n+        final Response response = doHttpRequest(\n+            MGMT_PORT,\n+            \"/node/controller/setupAlternateAddresses/external\",\n+            \"PUT\",\n+            builder.build(),\n+            true\n+        );\n \n-    @Override\n-    protected void containerIsCreated(String containerId) {\n-        patchConfig(STATIC_CONFIG, this::addMappedPorts);\n-        // capi needs a special configuration, see https://developer.couchbase.com/documentation/server/current/install/install-ports.html\n-        patchConfig(CAPI_CONFIG, this::replaceCapiPort);\n+        checkSuccessfulResponse(response, \"Could not configure external ports\");\n     }\n \n-    private void patchConfig(String configLocation, ThrowingFunction<String, String> patchFunction) {\n-        String patchedConfig = copyFileFromContainer(configLocation,\n-            inputStream -> patchFunction.apply(IOUtils.toString(inputStream, StandardCharsets.UTF_8)));\n-        copyFileToContainer(Transferable.of(patchedConfig.getBytes(StandardCharsets.UTF_8)), configLocation);\n-    }\n+    /**\n+     * Configures the indexer service so that indexes can be created later on the bucket.\n+     */\n+    private void configureIndexer() {\n+        logger().debug(\"Configuring the indexer service\");\n \n-    private String addMappedPorts(String originalConfig) {\n-        String portConfig = Stream.of(CouchbasePort.values())\n-            .filter(port -> !port.isDynamic())\n-            .map(port -> String.format(\"{%s, %d}.\", port.name, getMappedPort(port)))\n-            .collect(Collectors.joining(\"\\n\"));\n-        return String.format(\"%s\\n%s\", originalConfig, portConfig);\n-    }\n+        Response response = doHttpRequest(MGMT_PORT, \"/settings/indexes\", \"POST\", new FormBody.Builder()\n+            .add(\"storageMode\", \"memory_optimized\")\n+            .build(), true\n+        );\n \n-    private String replaceCapiPort(String originalConfig) {\n-        return Arrays.stream(originalConfig.split(\"\\n\"))\n-            .map(s -> (s.matches(\"port\\\\s*=\\\\s*\" + CAPI.getOriginalPort())) ? \"port = \" + getMappedPort(CAPI) : s)\n-            .collect(Collectors.joining(\"\\n\"));\n+        checkSuccessfulResponse(response, \"Could not configure the indexing service\");\n     }\n \n-    @Override\n-    protected void containerIsStarted(InspectContainerResponse containerInfo) {\n-        if (!newBuckets.isEmpty()) {\n-            for (BucketAndUserSettings bucket : newBuckets) {\n-                createBucket(bucket.getBucketSettings(), bucket.getUserSettings(), primaryIndex);\n-            }\n-        }\n-    }\n-\n-    private CouchbaseCluster createCouchbaseCluster() {\n-        return CouchbaseCluster.create(getCouchbaseEnvironment(), getContainerIpAddress());\n-    }\n+    /**\n+     * Based on the user-configured bucket definitions, creating buckets and corresponding indexes if needed.\n+     */\n+    private void createBuckets() {\n+        logger().debug(\"Creating \" + buckets.size() + \" buckets (and corresponding indexes).\");\n \n-    private DefaultCouchbaseEnvironment createCouchbaseEnvironment() {\n-        initCluster();\n-        return DefaultCouchbaseEnvironment.builder()\n-            .kvTimeout(10000)\n-            .bootstrapCarrierDirectPort(getMappedPort(MEMCACHED))\n-            .bootstrapCarrierSslPort(getMappedPort(MEMCACHED_SSL))\n-            .bootstrapHttpDirectPort(getMappedPort(REST))\n-            .bootstrapHttpSslPort(getMappedPort(REST_SSL))\n-            .build();\n-    }\n+        for (BucketDefinition bucket : buckets) {\n+            logger().debug(\"Creating bucket \\\"\" + bucket.getName() + \"\\\"\");\n \n-    public CouchbaseContainer withMemoryQuota(String memoryQuota) {\n-        this.memoryQuota = memoryQuota;\n-        return self();\n-    }\n-\n-    public CouchbaseContainer withIndexMemoryQuota(String indexMemoryQuota) {\n-        this.indexMemoryQuota = indexMemoryQuota;\n-        return self();\n-    }\n+            Response response = doHttpRequest(MGMT_PORT, \"/pools/default/buckets\", \"POST\", new FormBody.Builder()\n+                .add(\"name\", bucket.getName())\n+                .add(\"ramQuotaMB\", Integer.toString(bucket.getQuota()))\n+                .build(), true);\n \n-    public CouchbaseContainer withClusterAdmin(String username, String password) {\n-        this.clusterUsername = username;\n-        this.clusterPassword = password;\n-        return self();\n-    }\n+            checkSuccessfulResponse(response, \"Could not create bucket \" + bucket.getName());\n \n-    public CouchbaseContainer withKeyValue(boolean keyValue) {\n-        this.keyValue = keyValue;\n-        return self();\n-    }\n+            new HttpWaitStrategy()\n+                .forPath(\"/pools/default/buckets/\" + bucket.getName())\n+                .forPort(MGMT_PORT)\n+                .withBasicCredentials(username, password)\n+                .forStatusCode(200)\n+                .waitUntilReady(this);\n \n-    public CouchbaseContainer withQuery(boolean query) {\n-        this.query = query;\n-        return self();\n-    }\n+            if (bucket.hasPrimaryIndex()) {\n+                if (enabledServices.contains(CouchbaseService.QUERY)) {\n+                    Response queryResponse = doHttpRequest(QUERY_PORT, \"/query/service\", \"POST\", new FormBody.Builder()\n+                        .add(\"statement\", \"CREATE PRIMARY INDEX on `\" + bucket.getName() + \"`\")\n+                        .build(), true);\n \n-    public CouchbaseContainer withIndex(boolean index) {\n-        this.index = index;\n-        return self();\n+                    checkSuccessfulResponse(queryResponse, \"Could not create primary index for bucket \" + bucket.getName());\n+                } else {\n+                    logger().info(\"Primary index creation for bucket \" + bucket.getName() + \" ignored, since QUERY service is not present.\");\n+                }\n+            }\n+        }\n     }\n \n-    public CouchbaseContainer withPrimaryIndex(boolean primaryIndex) {\n-        this.primaryIndex = primaryIndex;\n-        return self();\n+    /**\n+     * Helper method to extract the internal IP address based on the network configuration.\n+     */\n+    private String getInternalIpAddress() {\n+        final Map<String, ContainerNetwork> networks = getContainerInfo().getNetworkSettings().getNetworks();\n+        for (ContainerNetwork network : networks.values()) {\n+            return network.getIpAddress();\n+        }\n+        throw new IllegalStateException(\"No network available to extract the internal IP from!\");\n     }\n \n-    public CouchbaseContainer withFts(boolean fts) {\n-        this.fts = fts;\n-        return self();\n+    /**\n+     * Helper method to check if the response is successful and release the body if needed.\n+     *\n+     * @param response the response to check.\n+     * @param message the message that should be part of the exception of not successful.\n+     */\n+    private void checkSuccessfulResponse(final Response response, final String message) {\n+        try {\n+            if (!response.isSuccessful()) {\n+                throw new IllegalStateException(message + \": \" + response.toString());\n+            }\n+        } finally {\n+            if (response.body() != null) {\n+                response.body().close();\n+            }\n+        }\n     }\n \n-    @Getter\n-    @RequiredArgsConstructor\n-    protected enum CouchbasePort {\n-        REST(\"rest_port\", 8091, true),\n-        CAPI(\"capi_port\", 8092, false),\n-        QUERY(\"query_port\", 8093, false),\n-        FTS(\"fts_http_port\", 8094, false),\n-        CBAS(\"cbas_http_port\", 8095, false),\n-        EVENTING(\"eventing_http_port\", 8096, false),\n-        MEMCACHED_SSL(\"memcached_ssl_port\", 11207, false),\n-        MEMCACHED(\"memcached_port\", 11210, false),\n-        REST_SSL(\"ssl_rest_port\", 18091, true),\n-        CAPI_SSL(\"ssl_capi_port\", 18092, false),\n-        QUERY_SSL(\"ssl_query_port\", 18093, false),\n-        FTS_SSL(\"fts_ssl_port\", 18094, false),\n-        CBAS_SSL(\"cbas_ssl_port\", 18095, false),\n-        EVENTING_SSL(\"eventing_ssl_port\", 18096, false);\n-\n-        final String name;\n-\n-        final int originalPort;\n-\n-        final boolean dynamic;\n+    /**\n+     * Checks if already running and if so raises an exception to prevent too-late setters.\n+     */\n+    private void checkNotRunning() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e02eab968ac95b949f39c079cab0783ad9f30d80"}, "originalPosition": 725}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgzMzYyMw==", "bodyText": "Just a general thing with our APIs, sometimes with will be a plain setter, sometimes add something to a collection. This depends on the context, but might not always be obvious to the user. Sometimes we also use add to indicate this.", "url": "https://github.com/testcontainers/testcontainers-java/pull/2491#discussion_r399833623", "createdAt": "2020-03-29T18:17:05Z", "author": {"login": "kiview"}, "path": "modules/couchbase/src/main/java/org/testcontainers/couchbase/CouchbaseContainer.java", "diffHunk": "@@ -15,447 +15,423 @@\n  */\n package org.testcontainers.couchbase;\n \n-import com.couchbase.client.core.utils.Base64;\n-import com.couchbase.client.java.Bucket;\n-import com.couchbase.client.java.CouchbaseCluster;\n-import com.couchbase.client.java.cluster.*;\n-import com.couchbase.client.java.env.CouchbaseEnvironment;\n-import com.couchbase.client.java.env.DefaultCouchbaseEnvironment;\n-import com.couchbase.client.java.query.Index;\n import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.github.dockerjava.api.command.ExecCreateCmdResponse;\n import com.github.dockerjava.api.command.InspectContainerResponse;\n-import com.google.common.collect.Lists;\n-import lombok.*;\n-import org.apache.commons.compress.utils.Sets;\n-import org.apache.commons.io.IOUtils;\n-import org.jetbrains.annotations.NotNull;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import okhttp3.Credentials;\n+import okhttp3.FormBody;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n import org.testcontainers.containers.GenericContainer;\n-import org.testcontainers.containers.Network;\n-import org.testcontainers.containers.SocatContainer;\n import org.testcontainers.containers.wait.strategy.HttpWaitStrategy;\n-import org.testcontainers.images.builder.Transferable;\n-import org.testcontainers.utility.ThrowingFunction;\n+import org.testcontainers.containers.wait.strategy.WaitAllStrategy;\n \n-import java.io.DataOutputStream;\n import java.io.IOException;\n-import java.net.HttpURLConnection;\n-import java.net.URL;\n-import java.net.URLEncoder;\n-import java.nio.charset.StandardCharsets;\n-import java.util.*;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import static java.net.HttpURLConnection.HTTP_OK;\n-import static org.testcontainers.couchbase.CouchbaseContainer.CouchbasePort.*;\n \n /**\n- * Based on Laurent Doguin version,\n+ * The couchbase container initializes and configures a Couchbase Server single node cluster.\n  * <p>\n- * optimized by Tayeb Chlyah\n+ * Note that it does not depend on a specific couchbase SDK, so it can be used with both the Java SDK 2 and 3 as well\n+ * as the Scala SDK 1 or newer. We recommend using the latest and greatest SDKs for the best experience.\n  */\n-@AllArgsConstructor\n public class CouchbaseContainer extends GenericContainer<CouchbaseContainer> {\n \n-    public static final String VERSION = \"5.5.1\";\n-    public static final String DOCKER_IMAGE_NAME = \"couchbase/server:\";\n-    public static final ObjectMapper MAPPER = new ObjectMapper();\n-    public static final String STATIC_CONFIG = \"/opt/couchbase/etc/couchbase/static_config\";\n-    public static final String CAPI_CONFIG = \"/opt/couchbase/etc/couchdb/default.d/capi.ini\";\n+    private static final int MGMT_PORT = 8091;\n+\n+    private static final int MGMT_SSL_PORT = 18091;\n+\n+    private static final int VIEW_PORT = 8092;\n \n-    private static final int REQUIRED_DEFAULT_PASSWORD_LENGTH = 6;\n+    private static final int VIEW_SSL_PORT = 18092;\n \n-    private String memoryQuota = \"300\";\n+    private static final int QUERY_PORT = 8093;\n \n-    private String indexMemoryQuota = \"300\";\n+    private static final int QUERY_SSL_PORT = 18093;\n \n-    private String clusterUsername = \"Administrator\";\n+    private static final int SEARCH_PORT = 8094;\n \n-    private String clusterPassword = \"password\";\n+    private static final int SEARCH_SSL_PORT = 18094;\n \n-    private boolean keyValue = true;\n+    private static final int KV_PORT = 11210;\n \n-    @Getter\n-    private boolean query = true;\n+    private static final int KV_SSL_PORT = 11207;\n \n-    @Getter\n-    private boolean index = true;\n+    private static final String DOCKER_IMAGE_NAME = \"couchbase/server\";\n \n-    @Getter\n-    private boolean primaryIndex = true;\n+    private static final String VERSION = \"6.5.0\";\n \n-    @Getter\n-    private boolean fts = false;\n+    private static final ObjectMapper MAPPER = new ObjectMapper();\n \n-    @Getter(lazy = true)\n-    private final CouchbaseEnvironment couchbaseEnvironment = createCouchbaseEnvironment();\n+    private static final OkHttpClient HTTP_CLIENT = new OkHttpClient()\n+        .newBuilder()\n+        .readTimeout(Duration.ofMinutes(1))\n+        .build();\n \n-    @Getter(lazy = true)\n-    private final CouchbaseCluster couchbaseCluster = createCouchbaseCluster();\n+    private String username = \"Administrator\";\n \n-    private List<BucketAndUserSettings> newBuckets = new ArrayList<>();\n+    private String password = \"password\";\n \n-    private String urlBase;\n+    private Set<CouchbaseService> enabledServices = EnumSet.allOf(CouchbaseService.class);\n \n-    private SocatContainer proxy;\n+    private final List<BucketDefinition> buckets = new ArrayList<>();\n \n+    /**\n+     * Creates a new couchbase container with the default image and version.\n+     */\n     public CouchbaseContainer() {\n-        this(DOCKER_IMAGE_NAME + VERSION);\n+        this(DOCKER_IMAGE_NAME + \":\" + VERSION);\n     }\n \n-    public CouchbaseContainer(String imageName) {\n+    /**\n+     * Creates a new couchbase container with a custom image name.\n+     *\n+     * @param imageName the image name that should be used.\n+     */\n+    public CouchbaseContainer(final String imageName) {\n         super(imageName);\n-\n-        withNetwork(Network.SHARED);\n-        setWaitStrategy(new HttpWaitStrategy().forPath(\"/ui/index.html\"));\n     }\n \n-    @Override\n-    public Set<Integer> getLivenessCheckPortNumbers() {\n-        return Sets.newHashSet(getMappedPort(REST));\n+    /**\n+     * Set custom username and password for the admin user.\n+     *\n+     * @param username the admin username to use.\n+     * @param password the password for the admin user.\n+     * @return this {@link CouchbaseContainer} for chaining purposes.\n+     */\n+    public CouchbaseContainer withCredentials(final String username, final String password) {\n+        checkNotRunning();\n+        this.username = username;\n+        this.password = password;\n+        return this;\n     }\n \n-    @Override\n-    protected void configure() {\n-        if (clusterPassword.length() < REQUIRED_DEFAULT_PASSWORD_LENGTH) {\n-            logger().warn(\"The provided cluster admin password length is less then the default password policy length. \" +\n-                \"Cluster start will fail if configured password requirements are not met.\");\n-        }\n+    public CouchbaseContainer withBucket(final BucketDefinition bucketDefinition) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e02eab968ac95b949f39c079cab0783ad9f30d80"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgzNDQ4NA==", "bodyText": "private method ?\nboolean checkResponseForAllNodesHealthy(Response r)", "url": "https://github.com/testcontainers/testcontainers-java/pull/2491#discussion_r399834484", "createdAt": "2020-03-29T18:24:31Z", "author": {"login": "kiview"}, "path": "modules/couchbase/src/main/java/org/testcontainers/couchbase/CouchbaseContainer.java", "diffHunk": "@@ -15,447 +15,423 @@\n  */\n package org.testcontainers.couchbase;\n \n-import com.couchbase.client.core.utils.Base64;\n-import com.couchbase.client.java.Bucket;\n-import com.couchbase.client.java.CouchbaseCluster;\n-import com.couchbase.client.java.cluster.*;\n-import com.couchbase.client.java.env.CouchbaseEnvironment;\n-import com.couchbase.client.java.env.DefaultCouchbaseEnvironment;\n-import com.couchbase.client.java.query.Index;\n import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.github.dockerjava.api.command.ExecCreateCmdResponse;\n import com.github.dockerjava.api.command.InspectContainerResponse;\n-import com.google.common.collect.Lists;\n-import lombok.*;\n-import org.apache.commons.compress.utils.Sets;\n-import org.apache.commons.io.IOUtils;\n-import org.jetbrains.annotations.NotNull;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import okhttp3.Credentials;\n+import okhttp3.FormBody;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n import org.testcontainers.containers.GenericContainer;\n-import org.testcontainers.containers.Network;\n-import org.testcontainers.containers.SocatContainer;\n import org.testcontainers.containers.wait.strategy.HttpWaitStrategy;\n-import org.testcontainers.images.builder.Transferable;\n-import org.testcontainers.utility.ThrowingFunction;\n+import org.testcontainers.containers.wait.strategy.WaitAllStrategy;\n \n-import java.io.DataOutputStream;\n import java.io.IOException;\n-import java.net.HttpURLConnection;\n-import java.net.URL;\n-import java.net.URLEncoder;\n-import java.nio.charset.StandardCharsets;\n-import java.util.*;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import static java.net.HttpURLConnection.HTTP_OK;\n-import static org.testcontainers.couchbase.CouchbaseContainer.CouchbasePort.*;\n \n /**\n- * Based on Laurent Doguin version,\n+ * The couchbase container initializes and configures a Couchbase Server single node cluster.\n  * <p>\n- * optimized by Tayeb Chlyah\n+ * Note that it does not depend on a specific couchbase SDK, so it can be used with both the Java SDK 2 and 3 as well\n+ * as the Scala SDK 1 or newer. We recommend using the latest and greatest SDKs for the best experience.\n  */\n-@AllArgsConstructor\n public class CouchbaseContainer extends GenericContainer<CouchbaseContainer> {\n \n-    public static final String VERSION = \"5.5.1\";\n-    public static final String DOCKER_IMAGE_NAME = \"couchbase/server:\";\n-    public static final ObjectMapper MAPPER = new ObjectMapper();\n-    public static final String STATIC_CONFIG = \"/opt/couchbase/etc/couchbase/static_config\";\n-    public static final String CAPI_CONFIG = \"/opt/couchbase/etc/couchdb/default.d/capi.ini\";\n+    private static final int MGMT_PORT = 8091;\n+\n+    private static final int MGMT_SSL_PORT = 18091;\n+\n+    private static final int VIEW_PORT = 8092;\n \n-    private static final int REQUIRED_DEFAULT_PASSWORD_LENGTH = 6;\n+    private static final int VIEW_SSL_PORT = 18092;\n \n-    private String memoryQuota = \"300\";\n+    private static final int QUERY_PORT = 8093;\n \n-    private String indexMemoryQuota = \"300\";\n+    private static final int QUERY_SSL_PORT = 18093;\n \n-    private String clusterUsername = \"Administrator\";\n+    private static final int SEARCH_PORT = 8094;\n \n-    private String clusterPassword = \"password\";\n+    private static final int SEARCH_SSL_PORT = 18094;\n \n-    private boolean keyValue = true;\n+    private static final int KV_PORT = 11210;\n \n-    @Getter\n-    private boolean query = true;\n+    private static final int KV_SSL_PORT = 11207;\n \n-    @Getter\n-    private boolean index = true;\n+    private static final String DOCKER_IMAGE_NAME = \"couchbase/server\";\n \n-    @Getter\n-    private boolean primaryIndex = true;\n+    private static final String VERSION = \"6.5.0\";\n \n-    @Getter\n-    private boolean fts = false;\n+    private static final ObjectMapper MAPPER = new ObjectMapper();\n \n-    @Getter(lazy = true)\n-    private final CouchbaseEnvironment couchbaseEnvironment = createCouchbaseEnvironment();\n+    private static final OkHttpClient HTTP_CLIENT = new OkHttpClient()\n+        .newBuilder()\n+        .readTimeout(Duration.ofMinutes(1))\n+        .build();\n \n-    @Getter(lazy = true)\n-    private final CouchbaseCluster couchbaseCluster = createCouchbaseCluster();\n+    private String username = \"Administrator\";\n \n-    private List<BucketAndUserSettings> newBuckets = new ArrayList<>();\n+    private String password = \"password\";\n \n-    private String urlBase;\n+    private Set<CouchbaseService> enabledServices = EnumSet.allOf(CouchbaseService.class);\n \n-    private SocatContainer proxy;\n+    private final List<BucketDefinition> buckets = new ArrayList<>();\n \n+    /**\n+     * Creates a new couchbase container with the default image and version.\n+     */\n     public CouchbaseContainer() {\n-        this(DOCKER_IMAGE_NAME + VERSION);\n+        this(DOCKER_IMAGE_NAME + \":\" + VERSION);\n     }\n \n-    public CouchbaseContainer(String imageName) {\n+    /**\n+     * Creates a new couchbase container with a custom image name.\n+     *\n+     * @param imageName the image name that should be used.\n+     */\n+    public CouchbaseContainer(final String imageName) {\n         super(imageName);\n-\n-        withNetwork(Network.SHARED);\n-        setWaitStrategy(new HttpWaitStrategy().forPath(\"/ui/index.html\"));\n     }\n \n-    @Override\n-    public Set<Integer> getLivenessCheckPortNumbers() {\n-        return Sets.newHashSet(getMappedPort(REST));\n+    /**\n+     * Set custom username and password for the admin user.\n+     *\n+     * @param username the admin username to use.\n+     * @param password the password for the admin user.\n+     * @return this {@link CouchbaseContainer} for chaining purposes.\n+     */\n+    public CouchbaseContainer withCredentials(final String username, final String password) {\n+        checkNotRunning();\n+        this.username = username;\n+        this.password = password;\n+        return this;\n     }\n \n-    @Override\n-    protected void configure() {\n-        if (clusterPassword.length() < REQUIRED_DEFAULT_PASSWORD_LENGTH) {\n-            logger().warn(\"The provided cluster admin password length is less then the default password policy length. \" +\n-                \"Cluster start will fail if configured password requirements are not met.\");\n-        }\n+    public CouchbaseContainer withBucket(final BucketDefinition bucketDefinition) {\n+        checkNotRunning();\n+        this.buckets.add(bucketDefinition);\n+        return this;\n     }\n \n-    @Override\n-    @SneakyThrows\n-    protected void doStart() {\n-        startProxy(getNetworkAliases().get(0));\n-        try {\n-            super.doStart();\n-        } catch (Throwable e) {\n-            proxy.stop();\n-            throw e;\n-        }\n+    public CouchbaseContainer withEnabledServices(final CouchbaseService... enabled) {\n+        checkNotRunning();\n+        this.enabledServices = EnumSet.copyOf(Arrays.asList(enabled));\n+        return this;\n     }\n \n-    @SneakyThrows\n-    private void startProxy(String networkAlias) {\n-        proxy = new SocatContainer().withNetwork(getNetwork());\n-\n-        for (CouchbasePort port : CouchbasePort.values()) {\n-            if (port.isDynamic()) {\n-                proxy.withTarget(port.getOriginalPort(), networkAlias);\n-            } else {\n-                proxy.addExposedPort(port.getOriginalPort());\n-            }\n-        }\n-\n-        proxy.setWaitStrategy(null);\n-        proxy.start();\n-\n-        ExecCreateCmdResponse createCmdResponse = dockerClient\n-            .execCreateCmd(proxy.getContainerId())\n-            .withCmd(\n-                \"sh\",\n-                \"-c\",\n-                Stream.of(CouchbasePort.values())\n-                    .map(port -> {\n-                        return \"/usr/bin/socat \" +\n-                            \"TCP-LISTEN:\" + port.getOriginalPort() + \",fork,reuseaddr \" +\n-                            \"TCP:\" + networkAlias + \":\" + getMappedPort(port);\n-                    })\n-                    .collect(Collectors.joining(\" & \", \"true\", \"\"))\n-            )\n-            .exec();\n-\n-        dockerClient.execStartCmd(createCmdResponse.getId())\n-            .start()\n-            .awaitCompletion(10, TimeUnit.SECONDS);\n+    public final String getUsername() {\n+        return username;\n     }\n \n-    @Override\n-    public List<Integer> getExposedPorts() {\n-        return proxy.getExposedPorts();\n+    public final String getPassword() {\n+        return password;\n     }\n \n-    @Override\n-    public String getContainerIpAddress() {\n-        return proxy.getContainerIpAddress();\n+    public String getConnectionString() {\n+        return String.format(\"couchbase://%s:%d\", getContainerIpAddress(), getMappedPort(KV_PORT));\n     }\n \n     @Override\n-    public Integer getMappedPort(int originalPort) {\n-        return proxy.getMappedPort(originalPort);\n-    }\n+    protected void configure() {\n+        super.configure();\n+\n+        WaitAllStrategy waitStrategy = new WaitAllStrategy();\n+\n+        // Makes sure that all nodes in the cluster are healthy.\n+        waitStrategy = waitStrategy.withStrategy(\n+            new HttpWaitStrategy()\n+                .forPath(\"/pools/default\")\n+                .forPort(MGMT_PORT)\n+                .withBasicCredentials(username, password)\n+                .forStatusCode(200)\n+                .forResponsePredicate(response -> {\n+                    try {\n+                        return Optional.of(MAPPER.readTree(response))\n+                            .map(n -> n.at(\"/nodes/0/status\"))\n+                            .map(JsonNode::asText)\n+                            .map(\"healthy\"::equals)\n+                            .orElse(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e02eab968ac95b949f39c079cab0783ad9f30d80"}, "originalPosition": 280}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgzNTAzMg==", "bodyText": "see above", "url": "https://github.com/testcontainers/testcontainers-java/pull/2491#discussion_r399835032", "createdAt": "2020-03-29T18:29:02Z", "author": {"login": "kiview"}, "path": "modules/couchbase/src/main/java/org/testcontainers/couchbase/CouchbaseContainer.java", "diffHunk": "@@ -15,447 +15,423 @@\n  */\n package org.testcontainers.couchbase;\n \n-import com.couchbase.client.core.utils.Base64;\n-import com.couchbase.client.java.Bucket;\n-import com.couchbase.client.java.CouchbaseCluster;\n-import com.couchbase.client.java.cluster.*;\n-import com.couchbase.client.java.env.CouchbaseEnvironment;\n-import com.couchbase.client.java.env.DefaultCouchbaseEnvironment;\n-import com.couchbase.client.java.query.Index;\n import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.github.dockerjava.api.command.ExecCreateCmdResponse;\n import com.github.dockerjava.api.command.InspectContainerResponse;\n-import com.google.common.collect.Lists;\n-import lombok.*;\n-import org.apache.commons.compress.utils.Sets;\n-import org.apache.commons.io.IOUtils;\n-import org.jetbrains.annotations.NotNull;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import okhttp3.Credentials;\n+import okhttp3.FormBody;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n import org.testcontainers.containers.GenericContainer;\n-import org.testcontainers.containers.Network;\n-import org.testcontainers.containers.SocatContainer;\n import org.testcontainers.containers.wait.strategy.HttpWaitStrategy;\n-import org.testcontainers.images.builder.Transferable;\n-import org.testcontainers.utility.ThrowingFunction;\n+import org.testcontainers.containers.wait.strategy.WaitAllStrategy;\n \n-import java.io.DataOutputStream;\n import java.io.IOException;\n-import java.net.HttpURLConnection;\n-import java.net.URL;\n-import java.net.URLEncoder;\n-import java.nio.charset.StandardCharsets;\n-import java.util.*;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import static java.net.HttpURLConnection.HTTP_OK;\n-import static org.testcontainers.couchbase.CouchbaseContainer.CouchbasePort.*;\n \n /**\n- * Based on Laurent Doguin version,\n+ * The couchbase container initializes and configures a Couchbase Server single node cluster.\n  * <p>\n- * optimized by Tayeb Chlyah\n+ * Note that it does not depend on a specific couchbase SDK, so it can be used with both the Java SDK 2 and 3 as well\n+ * as the Scala SDK 1 or newer. We recommend using the latest and greatest SDKs for the best experience.\n  */\n-@AllArgsConstructor\n public class CouchbaseContainer extends GenericContainer<CouchbaseContainer> {\n \n-    public static final String VERSION = \"5.5.1\";\n-    public static final String DOCKER_IMAGE_NAME = \"couchbase/server:\";\n-    public static final ObjectMapper MAPPER = new ObjectMapper();\n-    public static final String STATIC_CONFIG = \"/opt/couchbase/etc/couchbase/static_config\";\n-    public static final String CAPI_CONFIG = \"/opt/couchbase/etc/couchdb/default.d/capi.ini\";\n+    private static final int MGMT_PORT = 8091;\n+\n+    private static final int MGMT_SSL_PORT = 18091;\n+\n+    private static final int VIEW_PORT = 8092;\n \n-    private static final int REQUIRED_DEFAULT_PASSWORD_LENGTH = 6;\n+    private static final int VIEW_SSL_PORT = 18092;\n \n-    private String memoryQuota = \"300\";\n+    private static final int QUERY_PORT = 8093;\n \n-    private String indexMemoryQuota = \"300\";\n+    private static final int QUERY_SSL_PORT = 18093;\n \n-    private String clusterUsername = \"Administrator\";\n+    private static final int SEARCH_PORT = 8094;\n \n-    private String clusterPassword = \"password\";\n+    private static final int SEARCH_SSL_PORT = 18094;\n \n-    private boolean keyValue = true;\n+    private static final int KV_PORT = 11210;\n \n-    @Getter\n-    private boolean query = true;\n+    private static final int KV_SSL_PORT = 11207;\n \n-    @Getter\n-    private boolean index = true;\n+    private static final String DOCKER_IMAGE_NAME = \"couchbase/server\";\n \n-    @Getter\n-    private boolean primaryIndex = true;\n+    private static final String VERSION = \"6.5.0\";\n \n-    @Getter\n-    private boolean fts = false;\n+    private static final ObjectMapper MAPPER = new ObjectMapper();\n \n-    @Getter(lazy = true)\n-    private final CouchbaseEnvironment couchbaseEnvironment = createCouchbaseEnvironment();\n+    private static final OkHttpClient HTTP_CLIENT = new OkHttpClient()\n+        .newBuilder()\n+        .readTimeout(Duration.ofMinutes(1))\n+        .build();\n \n-    @Getter(lazy = true)\n-    private final CouchbaseCluster couchbaseCluster = createCouchbaseCluster();\n+    private String username = \"Administrator\";\n \n-    private List<BucketAndUserSettings> newBuckets = new ArrayList<>();\n+    private String password = \"password\";\n \n-    private String urlBase;\n+    private Set<CouchbaseService> enabledServices = EnumSet.allOf(CouchbaseService.class);\n \n-    private SocatContainer proxy;\n+    private final List<BucketDefinition> buckets = new ArrayList<>();\n \n+    /**\n+     * Creates a new couchbase container with the default image and version.\n+     */\n     public CouchbaseContainer() {\n-        this(DOCKER_IMAGE_NAME + VERSION);\n+        this(DOCKER_IMAGE_NAME + \":\" + VERSION);\n     }\n \n-    public CouchbaseContainer(String imageName) {\n+    /**\n+     * Creates a new couchbase container with a custom image name.\n+     *\n+     * @param imageName the image name that should be used.\n+     */\n+    public CouchbaseContainer(final String imageName) {\n         super(imageName);\n-\n-        withNetwork(Network.SHARED);\n-        setWaitStrategy(new HttpWaitStrategy().forPath(\"/ui/index.html\"));\n     }\n \n-    @Override\n-    public Set<Integer> getLivenessCheckPortNumbers() {\n-        return Sets.newHashSet(getMappedPort(REST));\n+    /**\n+     * Set custom username and password for the admin user.\n+     *\n+     * @param username the admin username to use.\n+     * @param password the password for the admin user.\n+     * @return this {@link CouchbaseContainer} for chaining purposes.\n+     */\n+    public CouchbaseContainer withCredentials(final String username, final String password) {\n+        checkNotRunning();\n+        this.username = username;\n+        this.password = password;\n+        return this;\n     }\n \n-    @Override\n-    protected void configure() {\n-        if (clusterPassword.length() < REQUIRED_DEFAULT_PASSWORD_LENGTH) {\n-            logger().warn(\"The provided cluster admin password length is less then the default password policy length. \" +\n-                \"Cluster start will fail if configured password requirements are not met.\");\n-        }\n+    public CouchbaseContainer withBucket(final BucketDefinition bucketDefinition) {\n+        checkNotRunning();\n+        this.buckets.add(bucketDefinition);\n+        return this;\n     }\n \n-    @Override\n-    @SneakyThrows\n-    protected void doStart() {\n-        startProxy(getNetworkAliases().get(0));\n-        try {\n-            super.doStart();\n-        } catch (Throwable e) {\n-            proxy.stop();\n-            throw e;\n-        }\n+    public CouchbaseContainer withEnabledServices(final CouchbaseService... enabled) {\n+        checkNotRunning();\n+        this.enabledServices = EnumSet.copyOf(Arrays.asList(enabled));\n+        return this;\n     }\n \n-    @SneakyThrows\n-    private void startProxy(String networkAlias) {\n-        proxy = new SocatContainer().withNetwork(getNetwork());\n-\n-        for (CouchbasePort port : CouchbasePort.values()) {\n-            if (port.isDynamic()) {\n-                proxy.withTarget(port.getOriginalPort(), networkAlias);\n-            } else {\n-                proxy.addExposedPort(port.getOriginalPort());\n-            }\n-        }\n-\n-        proxy.setWaitStrategy(null);\n-        proxy.start();\n-\n-        ExecCreateCmdResponse createCmdResponse = dockerClient\n-            .execCreateCmd(proxy.getContainerId())\n-            .withCmd(\n-                \"sh\",\n-                \"-c\",\n-                Stream.of(CouchbasePort.values())\n-                    .map(port -> {\n-                        return \"/usr/bin/socat \" +\n-                            \"TCP-LISTEN:\" + port.getOriginalPort() + \",fork,reuseaddr \" +\n-                            \"TCP:\" + networkAlias + \":\" + getMappedPort(port);\n-                    })\n-                    .collect(Collectors.joining(\" & \", \"true\", \"\"))\n-            )\n-            .exec();\n-\n-        dockerClient.execStartCmd(createCmdResponse.getId())\n-            .start()\n-            .awaitCompletion(10, TimeUnit.SECONDS);\n+    public final String getUsername() {\n+        return username;\n     }\n \n-    @Override\n-    public List<Integer> getExposedPorts() {\n-        return proxy.getExposedPorts();\n+    public final String getPassword() {\n+        return password;\n     }\n \n-    @Override\n-    public String getContainerIpAddress() {\n-        return proxy.getContainerIpAddress();\n+    public String getConnectionString() {\n+        return String.format(\"couchbase://%s:%d\", getContainerIpAddress(), getMappedPort(KV_PORT));\n     }\n \n     @Override\n-    public Integer getMappedPort(int originalPort) {\n-        return proxy.getMappedPort(originalPort);\n-    }\n+    protected void configure() {\n+        super.configure();\n+\n+        WaitAllStrategy waitStrategy = new WaitAllStrategy();\n+\n+        // Makes sure that all nodes in the cluster are healthy.\n+        waitStrategy = waitStrategy.withStrategy(\n+            new HttpWaitStrategy()\n+                .forPath(\"/pools/default\")\n+                .forPort(MGMT_PORT)\n+                .withBasicCredentials(username, password)\n+                .forStatusCode(200)\n+                .forResponsePredicate(response -> {\n+                    try {\n+                        return Optional.of(MAPPER.readTree(response))\n+                            .map(n -> n.at(\"/nodes/0/status\"))\n+                            .map(JsonNode::asText)\n+                            .map(\"healthy\"::equals)\n+                            .orElse(false);\n+                    } catch (IOException e) {\n+                        logger().error(\"Unable to parse response {}\", response);\n+                        return false;\n+                    }\n+                })\n+        );\n+\n+        if (enabledServices.contains(CouchbaseService.QUERY)) {\n+            waitStrategy = waitStrategy.withStrategy(\n+                new HttpWaitStrategy()\n+                    .forPath(\"/admin/ping\")\n+                    .forPort(QUERY_PORT)\n+                    .withBasicCredentials(username, password)\n+                    .forStatusCode(200)\n+            );\n+        }\n \n-    protected Integer getMappedPort(CouchbasePort port) {\n-        return getMappedPort(port.getOriginalPort());\n+        waitingFor(waitStrategy);\n     }\n \n     @Override\n-    public List<Integer> getBoundPortNumbers() {\n-        return proxy.getBoundPortNumbers();\n+    protected void containerIsStarting(final InspectContainerResponse containerInfo) {\n+        logger().debug(\"Couchbase container is starting, performing configuration.\");\n+\n+        waitUntilNodeIsOnline();\n+        renameNode();\n+        initializeServices();\n+        configureAdminUser();\n+        configureExternalPorts();\n+        if (enabledServices.contains(CouchbaseService.INDEX)) {\n+            configureIndexer();\n+        }\n     }\n \n     @Override\n-    @SuppressWarnings({\"unchecked\", \"ConstantConditions\"})\n-    public void stop() {\n-        try {\n-            stopCluster();\n-            ((AtomicReference<Object>) (Object) couchbaseEnvironment).set(null);\n-            ((AtomicReference<Object>) (Object) couchbaseCluster).set(null);\n-        } finally {\n-            Stream.<Runnable>of(super::stop, proxy::stop).parallel().forEach(Runnable::run);\n+    protected void containerIsStarted(InspectContainerResponse containerInfo) {\n+        createBuckets();\n+        logger().info(\"Couchbase container is ready! UI available at http://{}:{}\", getContainerIpAddress(), getMappedPort(MGMT_PORT));\n+    }\n+\n+    /**\n+     * Before we can start configuring the host, we need to wait until the cluster manager is listening.\n+     */\n+    private void waitUntilNodeIsOnline() {\n+        new HttpWaitStrategy()\n+            .forPort(MGMT_PORT)\n+            .forPath(\"/pools\")\n+            .forStatusCode(200)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e02eab968ac95b949f39c079cab0783ad9f30d80"}, "originalPosition": 340}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgzNTA3MA==", "bodyText": "could be omitted, we use 200 as default", "url": "https://github.com/testcontainers/testcontainers-java/pull/2491#discussion_r399835070", "createdAt": "2020-03-29T18:29:18Z", "author": {"login": "kiview"}, "path": "modules/couchbase/src/main/java/org/testcontainers/couchbase/CouchbaseContainer.java", "diffHunk": "@@ -15,447 +15,423 @@\n  */\n package org.testcontainers.couchbase;\n \n-import com.couchbase.client.core.utils.Base64;\n-import com.couchbase.client.java.Bucket;\n-import com.couchbase.client.java.CouchbaseCluster;\n-import com.couchbase.client.java.cluster.*;\n-import com.couchbase.client.java.env.CouchbaseEnvironment;\n-import com.couchbase.client.java.env.DefaultCouchbaseEnvironment;\n-import com.couchbase.client.java.query.Index;\n import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.github.dockerjava.api.command.ExecCreateCmdResponse;\n import com.github.dockerjava.api.command.InspectContainerResponse;\n-import com.google.common.collect.Lists;\n-import lombok.*;\n-import org.apache.commons.compress.utils.Sets;\n-import org.apache.commons.io.IOUtils;\n-import org.jetbrains.annotations.NotNull;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import okhttp3.Credentials;\n+import okhttp3.FormBody;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n import org.testcontainers.containers.GenericContainer;\n-import org.testcontainers.containers.Network;\n-import org.testcontainers.containers.SocatContainer;\n import org.testcontainers.containers.wait.strategy.HttpWaitStrategy;\n-import org.testcontainers.images.builder.Transferable;\n-import org.testcontainers.utility.ThrowingFunction;\n+import org.testcontainers.containers.wait.strategy.WaitAllStrategy;\n \n-import java.io.DataOutputStream;\n import java.io.IOException;\n-import java.net.HttpURLConnection;\n-import java.net.URL;\n-import java.net.URLEncoder;\n-import java.nio.charset.StandardCharsets;\n-import java.util.*;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import static java.net.HttpURLConnection.HTTP_OK;\n-import static org.testcontainers.couchbase.CouchbaseContainer.CouchbasePort.*;\n \n /**\n- * Based on Laurent Doguin version,\n+ * The couchbase container initializes and configures a Couchbase Server single node cluster.\n  * <p>\n- * optimized by Tayeb Chlyah\n+ * Note that it does not depend on a specific couchbase SDK, so it can be used with both the Java SDK 2 and 3 as well\n+ * as the Scala SDK 1 or newer. We recommend using the latest and greatest SDKs for the best experience.\n  */\n-@AllArgsConstructor\n public class CouchbaseContainer extends GenericContainer<CouchbaseContainer> {\n \n-    public static final String VERSION = \"5.5.1\";\n-    public static final String DOCKER_IMAGE_NAME = \"couchbase/server:\";\n-    public static final ObjectMapper MAPPER = new ObjectMapper();\n-    public static final String STATIC_CONFIG = \"/opt/couchbase/etc/couchbase/static_config\";\n-    public static final String CAPI_CONFIG = \"/opt/couchbase/etc/couchdb/default.d/capi.ini\";\n+    private static final int MGMT_PORT = 8091;\n+\n+    private static final int MGMT_SSL_PORT = 18091;\n+\n+    private static final int VIEW_PORT = 8092;\n \n-    private static final int REQUIRED_DEFAULT_PASSWORD_LENGTH = 6;\n+    private static final int VIEW_SSL_PORT = 18092;\n \n-    private String memoryQuota = \"300\";\n+    private static final int QUERY_PORT = 8093;\n \n-    private String indexMemoryQuota = \"300\";\n+    private static final int QUERY_SSL_PORT = 18093;\n \n-    private String clusterUsername = \"Administrator\";\n+    private static final int SEARCH_PORT = 8094;\n \n-    private String clusterPassword = \"password\";\n+    private static final int SEARCH_SSL_PORT = 18094;\n \n-    private boolean keyValue = true;\n+    private static final int KV_PORT = 11210;\n \n-    @Getter\n-    private boolean query = true;\n+    private static final int KV_SSL_PORT = 11207;\n \n-    @Getter\n-    private boolean index = true;\n+    private static final String DOCKER_IMAGE_NAME = \"couchbase/server\";\n \n-    @Getter\n-    private boolean primaryIndex = true;\n+    private static final String VERSION = \"6.5.0\";\n \n-    @Getter\n-    private boolean fts = false;\n+    private static final ObjectMapper MAPPER = new ObjectMapper();\n \n-    @Getter(lazy = true)\n-    private final CouchbaseEnvironment couchbaseEnvironment = createCouchbaseEnvironment();\n+    private static final OkHttpClient HTTP_CLIENT = new OkHttpClient()\n+        .newBuilder()\n+        .readTimeout(Duration.ofMinutes(1))\n+        .build();\n \n-    @Getter(lazy = true)\n-    private final CouchbaseCluster couchbaseCluster = createCouchbaseCluster();\n+    private String username = \"Administrator\";\n \n-    private List<BucketAndUserSettings> newBuckets = new ArrayList<>();\n+    private String password = \"password\";\n \n-    private String urlBase;\n+    private Set<CouchbaseService> enabledServices = EnumSet.allOf(CouchbaseService.class);\n \n-    private SocatContainer proxy;\n+    private final List<BucketDefinition> buckets = new ArrayList<>();\n \n+    /**\n+     * Creates a new couchbase container with the default image and version.\n+     */\n     public CouchbaseContainer() {\n-        this(DOCKER_IMAGE_NAME + VERSION);\n+        this(DOCKER_IMAGE_NAME + \":\" + VERSION);\n     }\n \n-    public CouchbaseContainer(String imageName) {\n+    /**\n+     * Creates a new couchbase container with a custom image name.\n+     *\n+     * @param imageName the image name that should be used.\n+     */\n+    public CouchbaseContainer(final String imageName) {\n         super(imageName);\n-\n-        withNetwork(Network.SHARED);\n-        setWaitStrategy(new HttpWaitStrategy().forPath(\"/ui/index.html\"));\n     }\n \n-    @Override\n-    public Set<Integer> getLivenessCheckPortNumbers() {\n-        return Sets.newHashSet(getMappedPort(REST));\n+    /**\n+     * Set custom username and password for the admin user.\n+     *\n+     * @param username the admin username to use.\n+     * @param password the password for the admin user.\n+     * @return this {@link CouchbaseContainer} for chaining purposes.\n+     */\n+    public CouchbaseContainer withCredentials(final String username, final String password) {\n+        checkNotRunning();\n+        this.username = username;\n+        this.password = password;\n+        return this;\n     }\n \n-    @Override\n-    protected void configure() {\n-        if (clusterPassword.length() < REQUIRED_DEFAULT_PASSWORD_LENGTH) {\n-            logger().warn(\"The provided cluster admin password length is less then the default password policy length. \" +\n-                \"Cluster start will fail if configured password requirements are not met.\");\n-        }\n+    public CouchbaseContainer withBucket(final BucketDefinition bucketDefinition) {\n+        checkNotRunning();\n+        this.buckets.add(bucketDefinition);\n+        return this;\n     }\n \n-    @Override\n-    @SneakyThrows\n-    protected void doStart() {\n-        startProxy(getNetworkAliases().get(0));\n-        try {\n-            super.doStart();\n-        } catch (Throwable e) {\n-            proxy.stop();\n-            throw e;\n-        }\n+    public CouchbaseContainer withEnabledServices(final CouchbaseService... enabled) {\n+        checkNotRunning();\n+        this.enabledServices = EnumSet.copyOf(Arrays.asList(enabled));\n+        return this;\n     }\n \n-    @SneakyThrows\n-    private void startProxy(String networkAlias) {\n-        proxy = new SocatContainer().withNetwork(getNetwork());\n-\n-        for (CouchbasePort port : CouchbasePort.values()) {\n-            if (port.isDynamic()) {\n-                proxy.withTarget(port.getOriginalPort(), networkAlias);\n-            } else {\n-                proxy.addExposedPort(port.getOriginalPort());\n-            }\n-        }\n-\n-        proxy.setWaitStrategy(null);\n-        proxy.start();\n-\n-        ExecCreateCmdResponse createCmdResponse = dockerClient\n-            .execCreateCmd(proxy.getContainerId())\n-            .withCmd(\n-                \"sh\",\n-                \"-c\",\n-                Stream.of(CouchbasePort.values())\n-                    .map(port -> {\n-                        return \"/usr/bin/socat \" +\n-                            \"TCP-LISTEN:\" + port.getOriginalPort() + \",fork,reuseaddr \" +\n-                            \"TCP:\" + networkAlias + \":\" + getMappedPort(port);\n-                    })\n-                    .collect(Collectors.joining(\" & \", \"true\", \"\"))\n-            )\n-            .exec();\n-\n-        dockerClient.execStartCmd(createCmdResponse.getId())\n-            .start()\n-            .awaitCompletion(10, TimeUnit.SECONDS);\n+    public final String getUsername() {\n+        return username;\n     }\n \n-    @Override\n-    public List<Integer> getExposedPorts() {\n-        return proxy.getExposedPorts();\n+    public final String getPassword() {\n+        return password;\n     }\n \n-    @Override\n-    public String getContainerIpAddress() {\n-        return proxy.getContainerIpAddress();\n+    public String getConnectionString() {\n+        return String.format(\"couchbase://%s:%d\", getContainerIpAddress(), getMappedPort(KV_PORT));\n     }\n \n     @Override\n-    public Integer getMappedPort(int originalPort) {\n-        return proxy.getMappedPort(originalPort);\n-    }\n+    protected void configure() {\n+        super.configure();\n+\n+        WaitAllStrategy waitStrategy = new WaitAllStrategy();\n+\n+        // Makes sure that all nodes in the cluster are healthy.\n+        waitStrategy = waitStrategy.withStrategy(\n+            new HttpWaitStrategy()\n+                .forPath(\"/pools/default\")\n+                .forPort(MGMT_PORT)\n+                .withBasicCredentials(username, password)\n+                .forStatusCode(200)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e02eab968ac95b949f39c079cab0783ad9f30d80"}, "originalPosition": 273}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgzNTA4MQ==", "bodyText": "see above", "url": "https://github.com/testcontainers/testcontainers-java/pull/2491#discussion_r399835081", "createdAt": "2020-03-29T18:29:27Z", "author": {"login": "kiview"}, "path": "modules/couchbase/src/main/java/org/testcontainers/couchbase/CouchbaseContainer.java", "diffHunk": "@@ -15,447 +15,423 @@\n  */\n package org.testcontainers.couchbase;\n \n-import com.couchbase.client.core.utils.Base64;\n-import com.couchbase.client.java.Bucket;\n-import com.couchbase.client.java.CouchbaseCluster;\n-import com.couchbase.client.java.cluster.*;\n-import com.couchbase.client.java.env.CouchbaseEnvironment;\n-import com.couchbase.client.java.env.DefaultCouchbaseEnvironment;\n-import com.couchbase.client.java.query.Index;\n import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.github.dockerjava.api.command.ExecCreateCmdResponse;\n import com.github.dockerjava.api.command.InspectContainerResponse;\n-import com.google.common.collect.Lists;\n-import lombok.*;\n-import org.apache.commons.compress.utils.Sets;\n-import org.apache.commons.io.IOUtils;\n-import org.jetbrains.annotations.NotNull;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import okhttp3.Credentials;\n+import okhttp3.FormBody;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n import org.testcontainers.containers.GenericContainer;\n-import org.testcontainers.containers.Network;\n-import org.testcontainers.containers.SocatContainer;\n import org.testcontainers.containers.wait.strategy.HttpWaitStrategy;\n-import org.testcontainers.images.builder.Transferable;\n-import org.testcontainers.utility.ThrowingFunction;\n+import org.testcontainers.containers.wait.strategy.WaitAllStrategy;\n \n-import java.io.DataOutputStream;\n import java.io.IOException;\n-import java.net.HttpURLConnection;\n-import java.net.URL;\n-import java.net.URLEncoder;\n-import java.nio.charset.StandardCharsets;\n-import java.util.*;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import static java.net.HttpURLConnection.HTTP_OK;\n-import static org.testcontainers.couchbase.CouchbaseContainer.CouchbasePort.*;\n \n /**\n- * Based on Laurent Doguin version,\n+ * The couchbase container initializes and configures a Couchbase Server single node cluster.\n  * <p>\n- * optimized by Tayeb Chlyah\n+ * Note that it does not depend on a specific couchbase SDK, so it can be used with both the Java SDK 2 and 3 as well\n+ * as the Scala SDK 1 or newer. We recommend using the latest and greatest SDKs for the best experience.\n  */\n-@AllArgsConstructor\n public class CouchbaseContainer extends GenericContainer<CouchbaseContainer> {\n \n-    public static final String VERSION = \"5.5.1\";\n-    public static final String DOCKER_IMAGE_NAME = \"couchbase/server:\";\n-    public static final ObjectMapper MAPPER = new ObjectMapper();\n-    public static final String STATIC_CONFIG = \"/opt/couchbase/etc/couchbase/static_config\";\n-    public static final String CAPI_CONFIG = \"/opt/couchbase/etc/couchdb/default.d/capi.ini\";\n+    private static final int MGMT_PORT = 8091;\n+\n+    private static final int MGMT_SSL_PORT = 18091;\n+\n+    private static final int VIEW_PORT = 8092;\n \n-    private static final int REQUIRED_DEFAULT_PASSWORD_LENGTH = 6;\n+    private static final int VIEW_SSL_PORT = 18092;\n \n-    private String memoryQuota = \"300\";\n+    private static final int QUERY_PORT = 8093;\n \n-    private String indexMemoryQuota = \"300\";\n+    private static final int QUERY_SSL_PORT = 18093;\n \n-    private String clusterUsername = \"Administrator\";\n+    private static final int SEARCH_PORT = 8094;\n \n-    private String clusterPassword = \"password\";\n+    private static final int SEARCH_SSL_PORT = 18094;\n \n-    private boolean keyValue = true;\n+    private static final int KV_PORT = 11210;\n \n-    @Getter\n-    private boolean query = true;\n+    private static final int KV_SSL_PORT = 11207;\n \n-    @Getter\n-    private boolean index = true;\n+    private static final String DOCKER_IMAGE_NAME = \"couchbase/server\";\n \n-    @Getter\n-    private boolean primaryIndex = true;\n+    private static final String VERSION = \"6.5.0\";\n \n-    @Getter\n-    private boolean fts = false;\n+    private static final ObjectMapper MAPPER = new ObjectMapper();\n \n-    @Getter(lazy = true)\n-    private final CouchbaseEnvironment couchbaseEnvironment = createCouchbaseEnvironment();\n+    private static final OkHttpClient HTTP_CLIENT = new OkHttpClient()\n+        .newBuilder()\n+        .readTimeout(Duration.ofMinutes(1))\n+        .build();\n \n-    @Getter(lazy = true)\n-    private final CouchbaseCluster couchbaseCluster = createCouchbaseCluster();\n+    private String username = \"Administrator\";\n \n-    private List<BucketAndUserSettings> newBuckets = new ArrayList<>();\n+    private String password = \"password\";\n \n-    private String urlBase;\n+    private Set<CouchbaseService> enabledServices = EnumSet.allOf(CouchbaseService.class);\n \n-    private SocatContainer proxy;\n+    private final List<BucketDefinition> buckets = new ArrayList<>();\n \n+    /**\n+     * Creates a new couchbase container with the default image and version.\n+     */\n     public CouchbaseContainer() {\n-        this(DOCKER_IMAGE_NAME + VERSION);\n+        this(DOCKER_IMAGE_NAME + \":\" + VERSION);\n     }\n \n-    public CouchbaseContainer(String imageName) {\n+    /**\n+     * Creates a new couchbase container with a custom image name.\n+     *\n+     * @param imageName the image name that should be used.\n+     */\n+    public CouchbaseContainer(final String imageName) {\n         super(imageName);\n-\n-        withNetwork(Network.SHARED);\n-        setWaitStrategy(new HttpWaitStrategy().forPath(\"/ui/index.html\"));\n     }\n \n-    @Override\n-    public Set<Integer> getLivenessCheckPortNumbers() {\n-        return Sets.newHashSet(getMappedPort(REST));\n+    /**\n+     * Set custom username and password for the admin user.\n+     *\n+     * @param username the admin username to use.\n+     * @param password the password for the admin user.\n+     * @return this {@link CouchbaseContainer} for chaining purposes.\n+     */\n+    public CouchbaseContainer withCredentials(final String username, final String password) {\n+        checkNotRunning();\n+        this.username = username;\n+        this.password = password;\n+        return this;\n     }\n \n-    @Override\n-    protected void configure() {\n-        if (clusterPassword.length() < REQUIRED_DEFAULT_PASSWORD_LENGTH) {\n-            logger().warn(\"The provided cluster admin password length is less then the default password policy length. \" +\n-                \"Cluster start will fail if configured password requirements are not met.\");\n-        }\n+    public CouchbaseContainer withBucket(final BucketDefinition bucketDefinition) {\n+        checkNotRunning();\n+        this.buckets.add(bucketDefinition);\n+        return this;\n     }\n \n-    @Override\n-    @SneakyThrows\n-    protected void doStart() {\n-        startProxy(getNetworkAliases().get(0));\n-        try {\n-            super.doStart();\n-        } catch (Throwable e) {\n-            proxy.stop();\n-            throw e;\n-        }\n+    public CouchbaseContainer withEnabledServices(final CouchbaseService... enabled) {\n+        checkNotRunning();\n+        this.enabledServices = EnumSet.copyOf(Arrays.asList(enabled));\n+        return this;\n     }\n \n-    @SneakyThrows\n-    private void startProxy(String networkAlias) {\n-        proxy = new SocatContainer().withNetwork(getNetwork());\n-\n-        for (CouchbasePort port : CouchbasePort.values()) {\n-            if (port.isDynamic()) {\n-                proxy.withTarget(port.getOriginalPort(), networkAlias);\n-            } else {\n-                proxy.addExposedPort(port.getOriginalPort());\n-            }\n-        }\n-\n-        proxy.setWaitStrategy(null);\n-        proxy.start();\n-\n-        ExecCreateCmdResponse createCmdResponse = dockerClient\n-            .execCreateCmd(proxy.getContainerId())\n-            .withCmd(\n-                \"sh\",\n-                \"-c\",\n-                Stream.of(CouchbasePort.values())\n-                    .map(port -> {\n-                        return \"/usr/bin/socat \" +\n-                            \"TCP-LISTEN:\" + port.getOriginalPort() + \",fork,reuseaddr \" +\n-                            \"TCP:\" + networkAlias + \":\" + getMappedPort(port);\n-                    })\n-                    .collect(Collectors.joining(\" & \", \"true\", \"\"))\n-            )\n-            .exec();\n-\n-        dockerClient.execStartCmd(createCmdResponse.getId())\n-            .start()\n-            .awaitCompletion(10, TimeUnit.SECONDS);\n+    public final String getUsername() {\n+        return username;\n     }\n \n-    @Override\n-    public List<Integer> getExposedPorts() {\n-        return proxy.getExposedPorts();\n+    public final String getPassword() {\n+        return password;\n     }\n \n-    @Override\n-    public String getContainerIpAddress() {\n-        return proxy.getContainerIpAddress();\n+    public String getConnectionString() {\n+        return String.format(\"couchbase://%s:%d\", getContainerIpAddress(), getMappedPort(KV_PORT));\n     }\n \n     @Override\n-    public Integer getMappedPort(int originalPort) {\n-        return proxy.getMappedPort(originalPort);\n-    }\n+    protected void configure() {\n+        super.configure();\n+\n+        WaitAllStrategy waitStrategy = new WaitAllStrategy();\n+\n+        // Makes sure that all nodes in the cluster are healthy.\n+        waitStrategy = waitStrategy.withStrategy(\n+            new HttpWaitStrategy()\n+                .forPath(\"/pools/default\")\n+                .forPort(MGMT_PORT)\n+                .withBasicCredentials(username, password)\n+                .forStatusCode(200)\n+                .forResponsePredicate(response -> {\n+                    try {\n+                        return Optional.of(MAPPER.readTree(response))\n+                            .map(n -> n.at(\"/nodes/0/status\"))\n+                            .map(JsonNode::asText)\n+                            .map(\"healthy\"::equals)\n+                            .orElse(false);\n+                    } catch (IOException e) {\n+                        logger().error(\"Unable to parse response {}\", response);\n+                        return false;\n+                    }\n+                })\n+        );\n+\n+        if (enabledServices.contains(CouchbaseService.QUERY)) {\n+            waitStrategy = waitStrategy.withStrategy(\n+                new HttpWaitStrategy()\n+                    .forPath(\"/admin/ping\")\n+                    .forPort(QUERY_PORT)\n+                    .withBasicCredentials(username, password)\n+                    .forStatusCode(200)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e02eab968ac95b949f39c079cab0783ad9f30d80"}, "originalPosition": 294}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgzNTI2OA==", "bodyText": "see above", "url": "https://github.com/testcontainers/testcontainers-java/pull/2491#discussion_r399835268", "createdAt": "2020-03-29T18:31:11Z", "author": {"login": "kiview"}, "path": "modules/couchbase/src/main/java/org/testcontainers/couchbase/CouchbaseContainer.java", "diffHunk": "@@ -15,447 +15,423 @@\n  */\n package org.testcontainers.couchbase;\n \n-import com.couchbase.client.core.utils.Base64;\n-import com.couchbase.client.java.Bucket;\n-import com.couchbase.client.java.CouchbaseCluster;\n-import com.couchbase.client.java.cluster.*;\n-import com.couchbase.client.java.env.CouchbaseEnvironment;\n-import com.couchbase.client.java.env.DefaultCouchbaseEnvironment;\n-import com.couchbase.client.java.query.Index;\n import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.github.dockerjava.api.command.ExecCreateCmdResponse;\n import com.github.dockerjava.api.command.InspectContainerResponse;\n-import com.google.common.collect.Lists;\n-import lombok.*;\n-import org.apache.commons.compress.utils.Sets;\n-import org.apache.commons.io.IOUtils;\n-import org.jetbrains.annotations.NotNull;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import okhttp3.Credentials;\n+import okhttp3.FormBody;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n import org.testcontainers.containers.GenericContainer;\n-import org.testcontainers.containers.Network;\n-import org.testcontainers.containers.SocatContainer;\n import org.testcontainers.containers.wait.strategy.HttpWaitStrategy;\n-import org.testcontainers.images.builder.Transferable;\n-import org.testcontainers.utility.ThrowingFunction;\n+import org.testcontainers.containers.wait.strategy.WaitAllStrategy;\n \n-import java.io.DataOutputStream;\n import java.io.IOException;\n-import java.net.HttpURLConnection;\n-import java.net.URL;\n-import java.net.URLEncoder;\n-import java.nio.charset.StandardCharsets;\n-import java.util.*;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import static java.net.HttpURLConnection.HTTP_OK;\n-import static org.testcontainers.couchbase.CouchbaseContainer.CouchbasePort.*;\n \n /**\n- * Based on Laurent Doguin version,\n+ * The couchbase container initializes and configures a Couchbase Server single node cluster.\n  * <p>\n- * optimized by Tayeb Chlyah\n+ * Note that it does not depend on a specific couchbase SDK, so it can be used with both the Java SDK 2 and 3 as well\n+ * as the Scala SDK 1 or newer. We recommend using the latest and greatest SDKs for the best experience.\n  */\n-@AllArgsConstructor\n public class CouchbaseContainer extends GenericContainer<CouchbaseContainer> {\n \n-    public static final String VERSION = \"5.5.1\";\n-    public static final String DOCKER_IMAGE_NAME = \"couchbase/server:\";\n-    public static final ObjectMapper MAPPER = new ObjectMapper();\n-    public static final String STATIC_CONFIG = \"/opt/couchbase/etc/couchbase/static_config\";\n-    public static final String CAPI_CONFIG = \"/opt/couchbase/etc/couchdb/default.d/capi.ini\";\n+    private static final int MGMT_PORT = 8091;\n+\n+    private static final int MGMT_SSL_PORT = 18091;\n+\n+    private static final int VIEW_PORT = 8092;\n \n-    private static final int REQUIRED_DEFAULT_PASSWORD_LENGTH = 6;\n+    private static final int VIEW_SSL_PORT = 18092;\n \n-    private String memoryQuota = \"300\";\n+    private static final int QUERY_PORT = 8093;\n \n-    private String indexMemoryQuota = \"300\";\n+    private static final int QUERY_SSL_PORT = 18093;\n \n-    private String clusterUsername = \"Administrator\";\n+    private static final int SEARCH_PORT = 8094;\n \n-    private String clusterPassword = \"password\";\n+    private static final int SEARCH_SSL_PORT = 18094;\n \n-    private boolean keyValue = true;\n+    private static final int KV_PORT = 11210;\n \n-    @Getter\n-    private boolean query = true;\n+    private static final int KV_SSL_PORT = 11207;\n \n-    @Getter\n-    private boolean index = true;\n+    private static final String DOCKER_IMAGE_NAME = \"couchbase/server\";\n \n-    @Getter\n-    private boolean primaryIndex = true;\n+    private static final String VERSION = \"6.5.0\";\n \n-    @Getter\n-    private boolean fts = false;\n+    private static final ObjectMapper MAPPER = new ObjectMapper();\n \n-    @Getter(lazy = true)\n-    private final CouchbaseEnvironment couchbaseEnvironment = createCouchbaseEnvironment();\n+    private static final OkHttpClient HTTP_CLIENT = new OkHttpClient()\n+        .newBuilder()\n+        .readTimeout(Duration.ofMinutes(1))\n+        .build();\n \n-    @Getter(lazy = true)\n-    private final CouchbaseCluster couchbaseCluster = createCouchbaseCluster();\n+    private String username = \"Administrator\";\n \n-    private List<BucketAndUserSettings> newBuckets = new ArrayList<>();\n+    private String password = \"password\";\n \n-    private String urlBase;\n+    private Set<CouchbaseService> enabledServices = EnumSet.allOf(CouchbaseService.class);\n \n-    private SocatContainer proxy;\n+    private final List<BucketDefinition> buckets = new ArrayList<>();\n \n+    /**\n+     * Creates a new couchbase container with the default image and version.\n+     */\n     public CouchbaseContainer() {\n-        this(DOCKER_IMAGE_NAME + VERSION);\n+        this(DOCKER_IMAGE_NAME + \":\" + VERSION);\n     }\n \n-    public CouchbaseContainer(String imageName) {\n+    /**\n+     * Creates a new couchbase container with a custom image name.\n+     *\n+     * @param imageName the image name that should be used.\n+     */\n+    public CouchbaseContainer(final String imageName) {\n         super(imageName);\n-\n-        withNetwork(Network.SHARED);\n-        setWaitStrategy(new HttpWaitStrategy().forPath(\"/ui/index.html\"));\n     }\n \n-    @Override\n-    public Set<Integer> getLivenessCheckPortNumbers() {\n-        return Sets.newHashSet(getMappedPort(REST));\n+    /**\n+     * Set custom username and password for the admin user.\n+     *\n+     * @param username the admin username to use.\n+     * @param password the password for the admin user.\n+     * @return this {@link CouchbaseContainer} for chaining purposes.\n+     */\n+    public CouchbaseContainer withCredentials(final String username, final String password) {\n+        checkNotRunning();\n+        this.username = username;\n+        this.password = password;\n+        return this;\n     }\n \n-    @Override\n-    protected void configure() {\n-        if (clusterPassword.length() < REQUIRED_DEFAULT_PASSWORD_LENGTH) {\n-            logger().warn(\"The provided cluster admin password length is less then the default password policy length. \" +\n-                \"Cluster start will fail if configured password requirements are not met.\");\n-        }\n+    public CouchbaseContainer withBucket(final BucketDefinition bucketDefinition) {\n+        checkNotRunning();\n+        this.buckets.add(bucketDefinition);\n+        return this;\n     }\n \n-    @Override\n-    @SneakyThrows\n-    protected void doStart() {\n-        startProxy(getNetworkAliases().get(0));\n-        try {\n-            super.doStart();\n-        } catch (Throwable e) {\n-            proxy.stop();\n-            throw e;\n-        }\n+    public CouchbaseContainer withEnabledServices(final CouchbaseService... enabled) {\n+        checkNotRunning();\n+        this.enabledServices = EnumSet.copyOf(Arrays.asList(enabled));\n+        return this;\n     }\n \n-    @SneakyThrows\n-    private void startProxy(String networkAlias) {\n-        proxy = new SocatContainer().withNetwork(getNetwork());\n-\n-        for (CouchbasePort port : CouchbasePort.values()) {\n-            if (port.isDynamic()) {\n-                proxy.withTarget(port.getOriginalPort(), networkAlias);\n-            } else {\n-                proxy.addExposedPort(port.getOriginalPort());\n-            }\n-        }\n-\n-        proxy.setWaitStrategy(null);\n-        proxy.start();\n-\n-        ExecCreateCmdResponse createCmdResponse = dockerClient\n-            .execCreateCmd(proxy.getContainerId())\n-            .withCmd(\n-                \"sh\",\n-                \"-c\",\n-                Stream.of(CouchbasePort.values())\n-                    .map(port -> {\n-                        return \"/usr/bin/socat \" +\n-                            \"TCP-LISTEN:\" + port.getOriginalPort() + \",fork,reuseaddr \" +\n-                            \"TCP:\" + networkAlias + \":\" + getMappedPort(port);\n-                    })\n-                    .collect(Collectors.joining(\" & \", \"true\", \"\"))\n-            )\n-            .exec();\n-\n-        dockerClient.execStartCmd(createCmdResponse.getId())\n-            .start()\n-            .awaitCompletion(10, TimeUnit.SECONDS);\n+    public final String getUsername() {\n+        return username;\n     }\n \n-    @Override\n-    public List<Integer> getExposedPorts() {\n-        return proxy.getExposedPorts();\n+    public final String getPassword() {\n+        return password;\n     }\n \n-    @Override\n-    public String getContainerIpAddress() {\n-        return proxy.getContainerIpAddress();\n+    public String getConnectionString() {\n+        return String.format(\"couchbase://%s:%d\", getContainerIpAddress(), getMappedPort(KV_PORT));\n     }\n \n     @Override\n-    public Integer getMappedPort(int originalPort) {\n-        return proxy.getMappedPort(originalPort);\n-    }\n+    protected void configure() {\n+        super.configure();\n+\n+        WaitAllStrategy waitStrategy = new WaitAllStrategy();\n+\n+        // Makes sure that all nodes in the cluster are healthy.\n+        waitStrategy = waitStrategy.withStrategy(\n+            new HttpWaitStrategy()\n+                .forPath(\"/pools/default\")\n+                .forPort(MGMT_PORT)\n+                .withBasicCredentials(username, password)\n+                .forStatusCode(200)\n+                .forResponsePredicate(response -> {\n+                    try {\n+                        return Optional.of(MAPPER.readTree(response))\n+                            .map(n -> n.at(\"/nodes/0/status\"))\n+                            .map(JsonNode::asText)\n+                            .map(\"healthy\"::equals)\n+                            .orElse(false);\n+                    } catch (IOException e) {\n+                        logger().error(\"Unable to parse response {}\", response);\n+                        return false;\n+                    }\n+                })\n+        );\n+\n+        if (enabledServices.contains(CouchbaseService.QUERY)) {\n+            waitStrategy = waitStrategy.withStrategy(\n+                new HttpWaitStrategy()\n+                    .forPath(\"/admin/ping\")\n+                    .forPort(QUERY_PORT)\n+                    .withBasicCredentials(username, password)\n+                    .forStatusCode(200)\n+            );\n+        }\n \n-    protected Integer getMappedPort(CouchbasePort port) {\n-        return getMappedPort(port.getOriginalPort());\n+        waitingFor(waitStrategy);\n     }\n \n     @Override\n-    public List<Integer> getBoundPortNumbers() {\n-        return proxy.getBoundPortNumbers();\n+    protected void containerIsStarting(final InspectContainerResponse containerInfo) {\n+        logger().debug(\"Couchbase container is starting, performing configuration.\");\n+\n+        waitUntilNodeIsOnline();\n+        renameNode();\n+        initializeServices();\n+        configureAdminUser();\n+        configureExternalPorts();\n+        if (enabledServices.contains(CouchbaseService.INDEX)) {\n+            configureIndexer();\n+        }\n     }\n \n     @Override\n-    @SuppressWarnings({\"unchecked\", \"ConstantConditions\"})\n-    public void stop() {\n-        try {\n-            stopCluster();\n-            ((AtomicReference<Object>) (Object) couchbaseEnvironment).set(null);\n-            ((AtomicReference<Object>) (Object) couchbaseCluster).set(null);\n-        } finally {\n-            Stream.<Runnable>of(super::stop, proxy::stop).parallel().forEach(Runnable::run);\n+    protected void containerIsStarted(InspectContainerResponse containerInfo) {\n+        createBuckets();\n+        logger().info(\"Couchbase container is ready! UI available at http://{}:{}\", getContainerIpAddress(), getMappedPort(MGMT_PORT));\n+    }\n+\n+    /**\n+     * Before we can start configuring the host, we need to wait until the cluster manager is listening.\n+     */\n+    private void waitUntilNodeIsOnline() {\n+        new HttpWaitStrategy()\n+            .forPort(MGMT_PORT)\n+            .forPath(\"/pools\")\n+            .forStatusCode(200)\n+            .waitUntilReady(this);\n+    }\n+\n+    /**\n+     * Rebinds/renames the internal hostname.\n+     * <p>\n+     * To make sure the internal hostname is different from the external (alternate) address and the SDK can pick it\n+     * up automatically, we bind the internal hostname to the internal IP address.\n+     */\n+    private void renameNode() {\n+        logger().debug(\"Renaming Couchbase Node from localhost to \" + getContainerIpAddress());\n+\n+        Response response = doHttpRequest(MGMT_PORT, \"/node/controller/rename\", \"POST\", new FormBody.Builder()\n+            .add(\"hostname\", getInternalIpAddress())\n+            .build(), false\n+        );\n+\n+        checkSuccessfulResponse(response, \"Could not rename couchbase node\");\n+    }\n+\n+    /**\n+     * Initializes services based on the configured enabled services.\n+     */\n+    private void initializeServices() {\n+        logger().debug(\"Initializing couchbase services on host: \" + enabledServices);\n+\n+        final String services = enabledServices.stream().map(s -> {\n+            switch (s) {\n+                case KV: return \"kv\";\n+                case QUERY: return \"n1ql\";\n+                case INDEX: return \"index\";\n+                case SEARCH: return \"fts\";\n+                default: throw new IllegalStateException(\"Unknown service!\");\n+            }\n+        }).collect(Collectors.joining(\",\"));\n+\n+        Response response = doHttpRequest(MGMT_PORT, \"/node/controller/setupServices\", \"POST\", new FormBody.Builder()\n+            .add(\"services\", services)\n+            .build(), false\n+        );\n+\n+        checkSuccessfulResponse(response, \"Could not enable couchbase services\");\n+    }\n+\n+    /**\n+     * Configures the admin user on the couchbase node.\n+     * <p>\n+     * After this stage, all subsequent API calls need to have the basic auth header set.\n+     */\n+    private void configureAdminUser() {\n+        logger().debug(\"Configuring couchbase admin user with username: \\\"\" + username + \"\\\"\");\n+\n+        Response response = doHttpRequest(MGMT_PORT, \"/settings/web\", \"POST\", new FormBody.Builder()\n+            .add(\"username\", username)\n+            .add(\"password\", password)\n+            .add(\"port\", Integer.toString(MGMT_PORT))\n+            .build(), false);\n+\n+        checkSuccessfulResponse(response, \"Could not configure couchbase admin user\");\n+    }\n+\n+    /**\n+     * Configures the external ports for SDK access.\n+     * <p>\n+     * Since the internal ports are not accessible from outside the container, this code configures the \"external\"\n+     * hostname and services to align with the mapped ports. The SDK will pick it up and then automatically connect\n+     * to those ports. Note that for all services non-ssl and ssl ports are configured.\n+     */\n+    private void configureExternalPorts() {\n+        logger().debug(\"Mapping external ports to the alternate address configuration\");\n+\n+        final FormBody.Builder builder = new FormBody.Builder();\n+        builder.add(\"hostname\", getContainerIpAddress());\n+        builder.add(\"mgmt\", Integer.toString(getMappedPort(MGMT_PORT)));\n+        builder.add(\"mgmtSSL\", Integer.toString(getMappedPort(MGMT_SSL_PORT)));\n+\n+        if (enabledServices.contains(CouchbaseService.KV)) {\n+            builder.add(\"kv\", Integer.toString(getMappedPort(KV_PORT)));\n+            builder.add(\"kvSSL\", Integer.toString(getMappedPort(KV_SSL_PORT)));\n+            builder.add(\"capi\", Integer.toString(getMappedPort(VIEW_PORT)));\n+            builder.add(\"capiSSL\", Integer.toString(getMappedPort(VIEW_SSL_PORT)));\n         }\n-    }\n \n-    private void stopCluster() {\n-        getCouchbaseCluster().disconnect();\n-        getCouchbaseEnvironment().shutdown();\n-    }\n-\n-    public CouchbaseContainer withNewBucket(BucketSettings bucketSettings) {\n-        newBuckets.add(new BucketAndUserSettings(bucketSettings));\n-        return self();\n-    }\n-\n-    public CouchbaseContainer withNewBucket(BucketSettings bucketSettings, UserSettings userSettings) {\n-        newBuckets.add(new BucketAndUserSettings(bucketSettings, userSettings));\n-        return self();\n-    }\n-\n-    @SneakyThrows\n-    public void initCluster() {\n-        urlBase = String.format(\"http://%s:%s\", getContainerIpAddress(), getMappedPort(REST));\n-        String poolURL = \"/pools/default\";\n-        String poolPayload = \"memoryQuota=\" + URLEncoder.encode(memoryQuota, \"UTF-8\") + \"&indexMemoryQuota=\" + URLEncoder.encode(indexMemoryQuota, \"UTF-8\");\n-\n-        String setupServicesURL = \"/node/controller/setupServices\";\n-        StringBuilder servicePayloadBuilder = new StringBuilder();\n-        if (keyValue) {\n-            servicePayloadBuilder.append(\"kv,\");\n-        }\n-        if (query) {\n-            servicePayloadBuilder.append(\"n1ql,\");\n-        }\n-        if (index) {\n-            servicePayloadBuilder.append(\"index,\");\n-        }\n-        if (fts) {\n-            servicePayloadBuilder.append(\"fts,\");\n+        if (enabledServices.contains(CouchbaseService.QUERY)) {\n+            builder.add(\"n1ql\", Integer.toString(getMappedPort(QUERY_PORT)));\n+            builder.add(\"n1qlSSL\", Integer.toString(getMappedPort(QUERY_SSL_PORT)));\n         }\n-        String setupServiceContent = \"services=\" + URLEncoder.encode(servicePayloadBuilder.toString(), \"UTF-8\");\n \n-        String webSettingsURL = \"/settings/web\";\n-        String webSettingsContent = \"username=\" + URLEncoder.encode(clusterUsername, \"UTF-8\") + \"&password=\" + URLEncoder.encode(clusterPassword, \"UTF-8\") + \"&port=8091\";\n-\n-        callCouchbaseRestAPI(poolURL, poolPayload);\n-        callCouchbaseRestAPI(setupServicesURL, setupServiceContent);\n-        callCouchbaseRestAPI(webSettingsURL, webSettingsContent);\n-\n-        createNodeWaitStrategy().waitUntilReady(this);\n-        callCouchbaseRestAPI(\"/settings/indexes\", \"indexerThreads=0&logLevel=info&maxRollbackPoints=5&storageMode=memory_optimized\");\n-    }\n-\n-    @NotNull\n-    private HttpWaitStrategy createNodeWaitStrategy() {\n-        return new HttpWaitStrategy()\n-            .forPath(\"/pools/default/\")\n-            .withBasicCredentials(clusterUsername, clusterPassword)\n-            .forStatusCode(HTTP_OK)\n-            .forResponsePredicate(response -> {\n-                try {\n-                    return Optional.of(MAPPER.readTree(response))\n-                        .map(n -> n.at(\"/nodes/0/status\"))\n-                        .map(JsonNode::asText)\n-                        .map(\"healthy\"::equals)\n-                        .orElse(false);\n-                } catch (IOException e) {\n-                    logger().error(\"Unable to parse response {}\", response);\n-                    return false;\n-                }\n-            });\n-    }\n-\n-    public void createBucket(BucketSettings bucketSetting, UserSettings userSettings, boolean primaryIndex) {\n-        ClusterManager clusterManager = getCouchbaseCluster().clusterManager(clusterUsername, clusterPassword);\n-        // Insert Bucket\n-        BucketSettings bucketSettings = clusterManager.insertBucket(bucketSetting);\n-        try {\n-            // Insert Bucket user\n-            clusterManager.upsertUser(AuthDomain.LOCAL, bucketSetting.name(), userSettings);\n-        } catch (Exception e) {\n-            logger().warn(\"Unable to insert user '\" + bucketSetting.name() + \"', maybe you are using older version\");\n+        if (enabledServices.contains(CouchbaseService.SEARCH)) {\n+            builder.add(\"fts\", Integer.toString(getMappedPort(SEARCH_PORT)));\n+            builder.add(\"ftsSSL\", Integer.toString(getMappedPort(SEARCH_SSL_PORT)));\n         }\n-        if (index) {\n-            Bucket bucket = getCouchbaseCluster().openBucket(bucketSettings.name(), bucketSettings.password());\n-            new CouchbaseQueryServiceWaitStrategy(bucket).waitUntilReady(this);\n-            if (primaryIndex) {\n-                bucket.query(Index.createPrimaryIndex().on(bucketSetting.name()));\n-            }\n-        }\n-    }\n \n-    public void callCouchbaseRestAPI(String url, String payload) throws IOException {\n-        String fullUrl = urlBase + url;\n-        @Cleanup(\"disconnect\")\n-        HttpURLConnection httpConnection = (HttpURLConnection) ((new URL(fullUrl).openConnection()));\n-        httpConnection.setDoOutput(true);\n-        httpConnection.setRequestMethod(\"POST\");\n-        httpConnection.setRequestProperty(\"Content-Type\",\n-            \"application/x-www-form-urlencoded\");\n-        String encoded = Base64.encode((clusterUsername + \":\" + clusterPassword).getBytes(\"UTF-8\"));\n-        httpConnection.setRequestProperty(\"Authorization\", \"Basic \" + encoded);\n-        @Cleanup\n-        DataOutputStream out = new DataOutputStream(httpConnection.getOutputStream());\n-        out.writeBytes(payload);\n-        out.flush();\n-        httpConnection.getResponseCode();\n-    }\n+        final Response response = doHttpRequest(\n+            MGMT_PORT,\n+            \"/node/controller/setupAlternateAddresses/external\",\n+            \"PUT\",\n+            builder.build(),\n+            true\n+        );\n \n-    @Override\n-    protected void containerIsCreated(String containerId) {\n-        patchConfig(STATIC_CONFIG, this::addMappedPorts);\n-        // capi needs a special configuration, see https://developer.couchbase.com/documentation/server/current/install/install-ports.html\n-        patchConfig(CAPI_CONFIG, this::replaceCapiPort);\n+        checkSuccessfulResponse(response, \"Could not configure external ports\");\n     }\n \n-    private void patchConfig(String configLocation, ThrowingFunction<String, String> patchFunction) {\n-        String patchedConfig = copyFileFromContainer(configLocation,\n-            inputStream -> patchFunction.apply(IOUtils.toString(inputStream, StandardCharsets.UTF_8)));\n-        copyFileToContainer(Transferable.of(patchedConfig.getBytes(StandardCharsets.UTF_8)), configLocation);\n-    }\n+    /**\n+     * Configures the indexer service so that indexes can be created later on the bucket.\n+     */\n+    private void configureIndexer() {\n+        logger().debug(\"Configuring the indexer service\");\n \n-    private String addMappedPorts(String originalConfig) {\n-        String portConfig = Stream.of(CouchbasePort.values())\n-            .filter(port -> !port.isDynamic())\n-            .map(port -> String.format(\"{%s, %d}.\", port.name, getMappedPort(port)))\n-            .collect(Collectors.joining(\"\\n\"));\n-        return String.format(\"%s\\n%s\", originalConfig, portConfig);\n-    }\n+        Response response = doHttpRequest(MGMT_PORT, \"/settings/indexes\", \"POST\", new FormBody.Builder()\n+            .add(\"storageMode\", \"memory_optimized\")\n+            .build(), true\n+        );\n \n-    private String replaceCapiPort(String originalConfig) {\n-        return Arrays.stream(originalConfig.split(\"\\n\"))\n-            .map(s -> (s.matches(\"port\\\\s*=\\\\s*\" + CAPI.getOriginalPort())) ? \"port = \" + getMappedPort(CAPI) : s)\n-            .collect(Collectors.joining(\"\\n\"));\n+        checkSuccessfulResponse(response, \"Could not configure the indexing service\");\n     }\n \n-    @Override\n-    protected void containerIsStarted(InspectContainerResponse containerInfo) {\n-        if (!newBuckets.isEmpty()) {\n-            for (BucketAndUserSettings bucket : newBuckets) {\n-                createBucket(bucket.getBucketSettings(), bucket.getUserSettings(), primaryIndex);\n-            }\n-        }\n-    }\n-\n-    private CouchbaseCluster createCouchbaseCluster() {\n-        return CouchbaseCluster.create(getCouchbaseEnvironment(), getContainerIpAddress());\n-    }\n+    /**\n+     * Based on the user-configured bucket definitions, creating buckets and corresponding indexes if needed.\n+     */\n+    private void createBuckets() {\n+        logger().debug(\"Creating \" + buckets.size() + \" buckets (and corresponding indexes).\");\n \n-    private DefaultCouchbaseEnvironment createCouchbaseEnvironment() {\n-        initCluster();\n-        return DefaultCouchbaseEnvironment.builder()\n-            .kvTimeout(10000)\n-            .bootstrapCarrierDirectPort(getMappedPort(MEMCACHED))\n-            .bootstrapCarrierSslPort(getMappedPort(MEMCACHED_SSL))\n-            .bootstrapHttpDirectPort(getMappedPort(REST))\n-            .bootstrapHttpSslPort(getMappedPort(REST_SSL))\n-            .build();\n-    }\n+        for (BucketDefinition bucket : buckets) {\n+            logger().debug(\"Creating bucket \\\"\" + bucket.getName() + \"\\\"\");\n \n-    public CouchbaseContainer withMemoryQuota(String memoryQuota) {\n-        this.memoryQuota = memoryQuota;\n-        return self();\n-    }\n-\n-    public CouchbaseContainer withIndexMemoryQuota(String indexMemoryQuota) {\n-        this.indexMemoryQuota = indexMemoryQuota;\n-        return self();\n-    }\n+            Response response = doHttpRequest(MGMT_PORT, \"/pools/default/buckets\", \"POST\", new FormBody.Builder()\n+                .add(\"name\", bucket.getName())\n+                .add(\"ramQuotaMB\", Integer.toString(bucket.getQuota()))\n+                .build(), true);\n \n-    public CouchbaseContainer withClusterAdmin(String username, String password) {\n-        this.clusterUsername = username;\n-        this.clusterPassword = password;\n-        return self();\n-    }\n+            checkSuccessfulResponse(response, \"Could not create bucket \" + bucket.getName());\n \n-    public CouchbaseContainer withKeyValue(boolean keyValue) {\n-        this.keyValue = keyValue;\n-        return self();\n-    }\n+            new HttpWaitStrategy()\n+                .forPath(\"/pools/default/buckets/\" + bucket.getName())\n+                .forPort(MGMT_PORT)\n+                .withBasicCredentials(username, password)\n+                .forStatusCode(200)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e02eab968ac95b949f39c079cab0783ad9f30d80"}, "originalPosition": 640}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgzNjI2NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final Map<String, ContainerNetwork> networks = getContainerInfo().getNetworkSettings().getNetworks();\n          \n          \n            \n                    for (ContainerNetwork network : networks.values()) {\n          \n          \n            \n                        return network.getIpAddress();\n          \n          \n            \n                    }\n          \n          \n            \n                    throw new IllegalStateException(\"No network available to extract the internal IP from!\");\n          \n          \n            \n                    return getContainerInfo().getNetworkSettings().getNetworks().values().stream()\n          \n          \n            \n                        .map(ContainerNetwork::getIpAddress)\n          \n          \n            \n                        .findFirst()\n          \n          \n            \n                        .orElseThrow(() -> new IllegalStateException(\"No network available to extract the internal IP from!\"));\n          \n      \n    \n    \n  \n\nNot sure if better, but on first reading, I stumbled upon the for-loop for getting the first element.", "url": "https://github.com/testcontainers/testcontainers-java/pull/2491#discussion_r399836265", "createdAt": "2020-03-29T18:39:54Z", "author": {"login": "kiview"}, "path": "modules/couchbase/src/main/java/org/testcontainers/couchbase/CouchbaseContainer.java", "diffHunk": "@@ -15,447 +15,423 @@\n  */\n package org.testcontainers.couchbase;\n \n-import com.couchbase.client.core.utils.Base64;\n-import com.couchbase.client.java.Bucket;\n-import com.couchbase.client.java.CouchbaseCluster;\n-import com.couchbase.client.java.cluster.*;\n-import com.couchbase.client.java.env.CouchbaseEnvironment;\n-import com.couchbase.client.java.env.DefaultCouchbaseEnvironment;\n-import com.couchbase.client.java.query.Index;\n import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.github.dockerjava.api.command.ExecCreateCmdResponse;\n import com.github.dockerjava.api.command.InspectContainerResponse;\n-import com.google.common.collect.Lists;\n-import lombok.*;\n-import org.apache.commons.compress.utils.Sets;\n-import org.apache.commons.io.IOUtils;\n-import org.jetbrains.annotations.NotNull;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import okhttp3.Credentials;\n+import okhttp3.FormBody;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n import org.testcontainers.containers.GenericContainer;\n-import org.testcontainers.containers.Network;\n-import org.testcontainers.containers.SocatContainer;\n import org.testcontainers.containers.wait.strategy.HttpWaitStrategy;\n-import org.testcontainers.images.builder.Transferable;\n-import org.testcontainers.utility.ThrowingFunction;\n+import org.testcontainers.containers.wait.strategy.WaitAllStrategy;\n \n-import java.io.DataOutputStream;\n import java.io.IOException;\n-import java.net.HttpURLConnection;\n-import java.net.URL;\n-import java.net.URLEncoder;\n-import java.nio.charset.StandardCharsets;\n-import java.util.*;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import static java.net.HttpURLConnection.HTTP_OK;\n-import static org.testcontainers.couchbase.CouchbaseContainer.CouchbasePort.*;\n \n /**\n- * Based on Laurent Doguin version,\n+ * The couchbase container initializes and configures a Couchbase Server single node cluster.\n  * <p>\n- * optimized by Tayeb Chlyah\n+ * Note that it does not depend on a specific couchbase SDK, so it can be used with both the Java SDK 2 and 3 as well\n+ * as the Scala SDK 1 or newer. We recommend using the latest and greatest SDKs for the best experience.\n  */\n-@AllArgsConstructor\n public class CouchbaseContainer extends GenericContainer<CouchbaseContainer> {\n \n-    public static final String VERSION = \"5.5.1\";\n-    public static final String DOCKER_IMAGE_NAME = \"couchbase/server:\";\n-    public static final ObjectMapper MAPPER = new ObjectMapper();\n-    public static final String STATIC_CONFIG = \"/opt/couchbase/etc/couchbase/static_config\";\n-    public static final String CAPI_CONFIG = \"/opt/couchbase/etc/couchdb/default.d/capi.ini\";\n+    private static final int MGMT_PORT = 8091;\n+\n+    private static final int MGMT_SSL_PORT = 18091;\n+\n+    private static final int VIEW_PORT = 8092;\n \n-    private static final int REQUIRED_DEFAULT_PASSWORD_LENGTH = 6;\n+    private static final int VIEW_SSL_PORT = 18092;\n \n-    private String memoryQuota = \"300\";\n+    private static final int QUERY_PORT = 8093;\n \n-    private String indexMemoryQuota = \"300\";\n+    private static final int QUERY_SSL_PORT = 18093;\n \n-    private String clusterUsername = \"Administrator\";\n+    private static final int SEARCH_PORT = 8094;\n \n-    private String clusterPassword = \"password\";\n+    private static final int SEARCH_SSL_PORT = 18094;\n \n-    private boolean keyValue = true;\n+    private static final int KV_PORT = 11210;\n \n-    @Getter\n-    private boolean query = true;\n+    private static final int KV_SSL_PORT = 11207;\n \n-    @Getter\n-    private boolean index = true;\n+    private static final String DOCKER_IMAGE_NAME = \"couchbase/server\";\n \n-    @Getter\n-    private boolean primaryIndex = true;\n+    private static final String VERSION = \"6.5.0\";\n \n-    @Getter\n-    private boolean fts = false;\n+    private static final ObjectMapper MAPPER = new ObjectMapper();\n \n-    @Getter(lazy = true)\n-    private final CouchbaseEnvironment couchbaseEnvironment = createCouchbaseEnvironment();\n+    private static final OkHttpClient HTTP_CLIENT = new OkHttpClient()\n+        .newBuilder()\n+        .readTimeout(Duration.ofMinutes(1))\n+        .build();\n \n-    @Getter(lazy = true)\n-    private final CouchbaseCluster couchbaseCluster = createCouchbaseCluster();\n+    private String username = \"Administrator\";\n \n-    private List<BucketAndUserSettings> newBuckets = new ArrayList<>();\n+    private String password = \"password\";\n \n-    private String urlBase;\n+    private Set<CouchbaseService> enabledServices = EnumSet.allOf(CouchbaseService.class);\n \n-    private SocatContainer proxy;\n+    private final List<BucketDefinition> buckets = new ArrayList<>();\n \n+    /**\n+     * Creates a new couchbase container with the default image and version.\n+     */\n     public CouchbaseContainer() {\n-        this(DOCKER_IMAGE_NAME + VERSION);\n+        this(DOCKER_IMAGE_NAME + \":\" + VERSION);\n     }\n \n-    public CouchbaseContainer(String imageName) {\n+    /**\n+     * Creates a new couchbase container with a custom image name.\n+     *\n+     * @param imageName the image name that should be used.\n+     */\n+    public CouchbaseContainer(final String imageName) {\n         super(imageName);\n-\n-        withNetwork(Network.SHARED);\n-        setWaitStrategy(new HttpWaitStrategy().forPath(\"/ui/index.html\"));\n     }\n \n-    @Override\n-    public Set<Integer> getLivenessCheckPortNumbers() {\n-        return Sets.newHashSet(getMappedPort(REST));\n+    /**\n+     * Set custom username and password for the admin user.\n+     *\n+     * @param username the admin username to use.\n+     * @param password the password for the admin user.\n+     * @return this {@link CouchbaseContainer} for chaining purposes.\n+     */\n+    public CouchbaseContainer withCredentials(final String username, final String password) {\n+        checkNotRunning();\n+        this.username = username;\n+        this.password = password;\n+        return this;\n     }\n \n-    @Override\n-    protected void configure() {\n-        if (clusterPassword.length() < REQUIRED_DEFAULT_PASSWORD_LENGTH) {\n-            logger().warn(\"The provided cluster admin password length is less then the default password policy length. \" +\n-                \"Cluster start will fail if configured password requirements are not met.\");\n-        }\n+    public CouchbaseContainer withBucket(final BucketDefinition bucketDefinition) {\n+        checkNotRunning();\n+        this.buckets.add(bucketDefinition);\n+        return this;\n     }\n \n-    @Override\n-    @SneakyThrows\n-    protected void doStart() {\n-        startProxy(getNetworkAliases().get(0));\n-        try {\n-            super.doStart();\n-        } catch (Throwable e) {\n-            proxy.stop();\n-            throw e;\n-        }\n+    public CouchbaseContainer withEnabledServices(final CouchbaseService... enabled) {\n+        checkNotRunning();\n+        this.enabledServices = EnumSet.copyOf(Arrays.asList(enabled));\n+        return this;\n     }\n \n-    @SneakyThrows\n-    private void startProxy(String networkAlias) {\n-        proxy = new SocatContainer().withNetwork(getNetwork());\n-\n-        for (CouchbasePort port : CouchbasePort.values()) {\n-            if (port.isDynamic()) {\n-                proxy.withTarget(port.getOriginalPort(), networkAlias);\n-            } else {\n-                proxy.addExposedPort(port.getOriginalPort());\n-            }\n-        }\n-\n-        proxy.setWaitStrategy(null);\n-        proxy.start();\n-\n-        ExecCreateCmdResponse createCmdResponse = dockerClient\n-            .execCreateCmd(proxy.getContainerId())\n-            .withCmd(\n-                \"sh\",\n-                \"-c\",\n-                Stream.of(CouchbasePort.values())\n-                    .map(port -> {\n-                        return \"/usr/bin/socat \" +\n-                            \"TCP-LISTEN:\" + port.getOriginalPort() + \",fork,reuseaddr \" +\n-                            \"TCP:\" + networkAlias + \":\" + getMappedPort(port);\n-                    })\n-                    .collect(Collectors.joining(\" & \", \"true\", \"\"))\n-            )\n-            .exec();\n-\n-        dockerClient.execStartCmd(createCmdResponse.getId())\n-            .start()\n-            .awaitCompletion(10, TimeUnit.SECONDS);\n+    public final String getUsername() {\n+        return username;\n     }\n \n-    @Override\n-    public List<Integer> getExposedPorts() {\n-        return proxy.getExposedPorts();\n+    public final String getPassword() {\n+        return password;\n     }\n \n-    @Override\n-    public String getContainerIpAddress() {\n-        return proxy.getContainerIpAddress();\n+    public String getConnectionString() {\n+        return String.format(\"couchbase://%s:%d\", getContainerIpAddress(), getMappedPort(KV_PORT));\n     }\n \n     @Override\n-    public Integer getMappedPort(int originalPort) {\n-        return proxy.getMappedPort(originalPort);\n-    }\n+    protected void configure() {\n+        super.configure();\n+\n+        WaitAllStrategy waitStrategy = new WaitAllStrategy();\n+\n+        // Makes sure that all nodes in the cluster are healthy.\n+        waitStrategy = waitStrategy.withStrategy(\n+            new HttpWaitStrategy()\n+                .forPath(\"/pools/default\")\n+                .forPort(MGMT_PORT)\n+                .withBasicCredentials(username, password)\n+                .forStatusCode(200)\n+                .forResponsePredicate(response -> {\n+                    try {\n+                        return Optional.of(MAPPER.readTree(response))\n+                            .map(n -> n.at(\"/nodes/0/status\"))\n+                            .map(JsonNode::asText)\n+                            .map(\"healthy\"::equals)\n+                            .orElse(false);\n+                    } catch (IOException e) {\n+                        logger().error(\"Unable to parse response {}\", response);\n+                        return false;\n+                    }\n+                })\n+        );\n+\n+        if (enabledServices.contains(CouchbaseService.QUERY)) {\n+            waitStrategy = waitStrategy.withStrategy(\n+                new HttpWaitStrategy()\n+                    .forPath(\"/admin/ping\")\n+                    .forPort(QUERY_PORT)\n+                    .withBasicCredentials(username, password)\n+                    .forStatusCode(200)\n+            );\n+        }\n \n-    protected Integer getMappedPort(CouchbasePort port) {\n-        return getMappedPort(port.getOriginalPort());\n+        waitingFor(waitStrategy);\n     }\n \n     @Override\n-    public List<Integer> getBoundPortNumbers() {\n-        return proxy.getBoundPortNumbers();\n+    protected void containerIsStarting(final InspectContainerResponse containerInfo) {\n+        logger().debug(\"Couchbase container is starting, performing configuration.\");\n+\n+        waitUntilNodeIsOnline();\n+        renameNode();\n+        initializeServices();\n+        configureAdminUser();\n+        configureExternalPorts();\n+        if (enabledServices.contains(CouchbaseService.INDEX)) {\n+            configureIndexer();\n+        }\n     }\n \n     @Override\n-    @SuppressWarnings({\"unchecked\", \"ConstantConditions\"})\n-    public void stop() {\n-        try {\n-            stopCluster();\n-            ((AtomicReference<Object>) (Object) couchbaseEnvironment).set(null);\n-            ((AtomicReference<Object>) (Object) couchbaseCluster).set(null);\n-        } finally {\n-            Stream.<Runnable>of(super::stop, proxy::stop).parallel().forEach(Runnable::run);\n+    protected void containerIsStarted(InspectContainerResponse containerInfo) {\n+        createBuckets();\n+        logger().info(\"Couchbase container is ready! UI available at http://{}:{}\", getContainerIpAddress(), getMappedPort(MGMT_PORT));\n+    }\n+\n+    /**\n+     * Before we can start configuring the host, we need to wait until the cluster manager is listening.\n+     */\n+    private void waitUntilNodeIsOnline() {\n+        new HttpWaitStrategy()\n+            .forPort(MGMT_PORT)\n+            .forPath(\"/pools\")\n+            .forStatusCode(200)\n+            .waitUntilReady(this);\n+    }\n+\n+    /**\n+     * Rebinds/renames the internal hostname.\n+     * <p>\n+     * To make sure the internal hostname is different from the external (alternate) address and the SDK can pick it\n+     * up automatically, we bind the internal hostname to the internal IP address.\n+     */\n+    private void renameNode() {\n+        logger().debug(\"Renaming Couchbase Node from localhost to \" + getContainerIpAddress());\n+\n+        Response response = doHttpRequest(MGMT_PORT, \"/node/controller/rename\", \"POST\", new FormBody.Builder()\n+            .add(\"hostname\", getInternalIpAddress())\n+            .build(), false\n+        );\n+\n+        checkSuccessfulResponse(response, \"Could not rename couchbase node\");\n+    }\n+\n+    /**\n+     * Initializes services based on the configured enabled services.\n+     */\n+    private void initializeServices() {\n+        logger().debug(\"Initializing couchbase services on host: \" + enabledServices);\n+\n+        final String services = enabledServices.stream().map(s -> {\n+            switch (s) {\n+                case KV: return \"kv\";\n+                case QUERY: return \"n1ql\";\n+                case INDEX: return \"index\";\n+                case SEARCH: return \"fts\";\n+                default: throw new IllegalStateException(\"Unknown service!\");\n+            }\n+        }).collect(Collectors.joining(\",\"));\n+\n+        Response response = doHttpRequest(MGMT_PORT, \"/node/controller/setupServices\", \"POST\", new FormBody.Builder()\n+            .add(\"services\", services)\n+            .build(), false\n+        );\n+\n+        checkSuccessfulResponse(response, \"Could not enable couchbase services\");\n+    }\n+\n+    /**\n+     * Configures the admin user on the couchbase node.\n+     * <p>\n+     * After this stage, all subsequent API calls need to have the basic auth header set.\n+     */\n+    private void configureAdminUser() {\n+        logger().debug(\"Configuring couchbase admin user with username: \\\"\" + username + \"\\\"\");\n+\n+        Response response = doHttpRequest(MGMT_PORT, \"/settings/web\", \"POST\", new FormBody.Builder()\n+            .add(\"username\", username)\n+            .add(\"password\", password)\n+            .add(\"port\", Integer.toString(MGMT_PORT))\n+            .build(), false);\n+\n+        checkSuccessfulResponse(response, \"Could not configure couchbase admin user\");\n+    }\n+\n+    /**\n+     * Configures the external ports for SDK access.\n+     * <p>\n+     * Since the internal ports are not accessible from outside the container, this code configures the \"external\"\n+     * hostname and services to align with the mapped ports. The SDK will pick it up and then automatically connect\n+     * to those ports. Note that for all services non-ssl and ssl ports are configured.\n+     */\n+    private void configureExternalPorts() {\n+        logger().debug(\"Mapping external ports to the alternate address configuration\");\n+\n+        final FormBody.Builder builder = new FormBody.Builder();\n+        builder.add(\"hostname\", getContainerIpAddress());\n+        builder.add(\"mgmt\", Integer.toString(getMappedPort(MGMT_PORT)));\n+        builder.add(\"mgmtSSL\", Integer.toString(getMappedPort(MGMT_SSL_PORT)));\n+\n+        if (enabledServices.contains(CouchbaseService.KV)) {\n+            builder.add(\"kv\", Integer.toString(getMappedPort(KV_PORT)));\n+            builder.add(\"kvSSL\", Integer.toString(getMappedPort(KV_SSL_PORT)));\n+            builder.add(\"capi\", Integer.toString(getMappedPort(VIEW_PORT)));\n+            builder.add(\"capiSSL\", Integer.toString(getMappedPort(VIEW_SSL_PORT)));\n         }\n-    }\n \n-    private void stopCluster() {\n-        getCouchbaseCluster().disconnect();\n-        getCouchbaseEnvironment().shutdown();\n-    }\n-\n-    public CouchbaseContainer withNewBucket(BucketSettings bucketSettings) {\n-        newBuckets.add(new BucketAndUserSettings(bucketSettings));\n-        return self();\n-    }\n-\n-    public CouchbaseContainer withNewBucket(BucketSettings bucketSettings, UserSettings userSettings) {\n-        newBuckets.add(new BucketAndUserSettings(bucketSettings, userSettings));\n-        return self();\n-    }\n-\n-    @SneakyThrows\n-    public void initCluster() {\n-        urlBase = String.format(\"http://%s:%s\", getContainerIpAddress(), getMappedPort(REST));\n-        String poolURL = \"/pools/default\";\n-        String poolPayload = \"memoryQuota=\" + URLEncoder.encode(memoryQuota, \"UTF-8\") + \"&indexMemoryQuota=\" + URLEncoder.encode(indexMemoryQuota, \"UTF-8\");\n-\n-        String setupServicesURL = \"/node/controller/setupServices\";\n-        StringBuilder servicePayloadBuilder = new StringBuilder();\n-        if (keyValue) {\n-            servicePayloadBuilder.append(\"kv,\");\n-        }\n-        if (query) {\n-            servicePayloadBuilder.append(\"n1ql,\");\n-        }\n-        if (index) {\n-            servicePayloadBuilder.append(\"index,\");\n-        }\n-        if (fts) {\n-            servicePayloadBuilder.append(\"fts,\");\n+        if (enabledServices.contains(CouchbaseService.QUERY)) {\n+            builder.add(\"n1ql\", Integer.toString(getMappedPort(QUERY_PORT)));\n+            builder.add(\"n1qlSSL\", Integer.toString(getMappedPort(QUERY_SSL_PORT)));\n         }\n-        String setupServiceContent = \"services=\" + URLEncoder.encode(servicePayloadBuilder.toString(), \"UTF-8\");\n \n-        String webSettingsURL = \"/settings/web\";\n-        String webSettingsContent = \"username=\" + URLEncoder.encode(clusterUsername, \"UTF-8\") + \"&password=\" + URLEncoder.encode(clusterPassword, \"UTF-8\") + \"&port=8091\";\n-\n-        callCouchbaseRestAPI(poolURL, poolPayload);\n-        callCouchbaseRestAPI(setupServicesURL, setupServiceContent);\n-        callCouchbaseRestAPI(webSettingsURL, webSettingsContent);\n-\n-        createNodeWaitStrategy().waitUntilReady(this);\n-        callCouchbaseRestAPI(\"/settings/indexes\", \"indexerThreads=0&logLevel=info&maxRollbackPoints=5&storageMode=memory_optimized\");\n-    }\n-\n-    @NotNull\n-    private HttpWaitStrategy createNodeWaitStrategy() {\n-        return new HttpWaitStrategy()\n-            .forPath(\"/pools/default/\")\n-            .withBasicCredentials(clusterUsername, clusterPassword)\n-            .forStatusCode(HTTP_OK)\n-            .forResponsePredicate(response -> {\n-                try {\n-                    return Optional.of(MAPPER.readTree(response))\n-                        .map(n -> n.at(\"/nodes/0/status\"))\n-                        .map(JsonNode::asText)\n-                        .map(\"healthy\"::equals)\n-                        .orElse(false);\n-                } catch (IOException e) {\n-                    logger().error(\"Unable to parse response {}\", response);\n-                    return false;\n-                }\n-            });\n-    }\n-\n-    public void createBucket(BucketSettings bucketSetting, UserSettings userSettings, boolean primaryIndex) {\n-        ClusterManager clusterManager = getCouchbaseCluster().clusterManager(clusterUsername, clusterPassword);\n-        // Insert Bucket\n-        BucketSettings bucketSettings = clusterManager.insertBucket(bucketSetting);\n-        try {\n-            // Insert Bucket user\n-            clusterManager.upsertUser(AuthDomain.LOCAL, bucketSetting.name(), userSettings);\n-        } catch (Exception e) {\n-            logger().warn(\"Unable to insert user '\" + bucketSetting.name() + \"', maybe you are using older version\");\n+        if (enabledServices.contains(CouchbaseService.SEARCH)) {\n+            builder.add(\"fts\", Integer.toString(getMappedPort(SEARCH_PORT)));\n+            builder.add(\"ftsSSL\", Integer.toString(getMappedPort(SEARCH_SSL_PORT)));\n         }\n-        if (index) {\n-            Bucket bucket = getCouchbaseCluster().openBucket(bucketSettings.name(), bucketSettings.password());\n-            new CouchbaseQueryServiceWaitStrategy(bucket).waitUntilReady(this);\n-            if (primaryIndex) {\n-                bucket.query(Index.createPrimaryIndex().on(bucketSetting.name()));\n-            }\n-        }\n-    }\n \n-    public void callCouchbaseRestAPI(String url, String payload) throws IOException {\n-        String fullUrl = urlBase + url;\n-        @Cleanup(\"disconnect\")\n-        HttpURLConnection httpConnection = (HttpURLConnection) ((new URL(fullUrl).openConnection()));\n-        httpConnection.setDoOutput(true);\n-        httpConnection.setRequestMethod(\"POST\");\n-        httpConnection.setRequestProperty(\"Content-Type\",\n-            \"application/x-www-form-urlencoded\");\n-        String encoded = Base64.encode((clusterUsername + \":\" + clusterPassword).getBytes(\"UTF-8\"));\n-        httpConnection.setRequestProperty(\"Authorization\", \"Basic \" + encoded);\n-        @Cleanup\n-        DataOutputStream out = new DataOutputStream(httpConnection.getOutputStream());\n-        out.writeBytes(payload);\n-        out.flush();\n-        httpConnection.getResponseCode();\n-    }\n+        final Response response = doHttpRequest(\n+            MGMT_PORT,\n+            \"/node/controller/setupAlternateAddresses/external\",\n+            \"PUT\",\n+            builder.build(),\n+            true\n+        );\n \n-    @Override\n-    protected void containerIsCreated(String containerId) {\n-        patchConfig(STATIC_CONFIG, this::addMappedPorts);\n-        // capi needs a special configuration, see https://developer.couchbase.com/documentation/server/current/install/install-ports.html\n-        patchConfig(CAPI_CONFIG, this::replaceCapiPort);\n+        checkSuccessfulResponse(response, \"Could not configure external ports\");\n     }\n \n-    private void patchConfig(String configLocation, ThrowingFunction<String, String> patchFunction) {\n-        String patchedConfig = copyFileFromContainer(configLocation,\n-            inputStream -> patchFunction.apply(IOUtils.toString(inputStream, StandardCharsets.UTF_8)));\n-        copyFileToContainer(Transferable.of(patchedConfig.getBytes(StandardCharsets.UTF_8)), configLocation);\n-    }\n+    /**\n+     * Configures the indexer service so that indexes can be created later on the bucket.\n+     */\n+    private void configureIndexer() {\n+        logger().debug(\"Configuring the indexer service\");\n \n-    private String addMappedPorts(String originalConfig) {\n-        String portConfig = Stream.of(CouchbasePort.values())\n-            .filter(port -> !port.isDynamic())\n-            .map(port -> String.format(\"{%s, %d}.\", port.name, getMappedPort(port)))\n-            .collect(Collectors.joining(\"\\n\"));\n-        return String.format(\"%s\\n%s\", originalConfig, portConfig);\n-    }\n+        Response response = doHttpRequest(MGMT_PORT, \"/settings/indexes\", \"POST\", new FormBody.Builder()\n+            .add(\"storageMode\", \"memory_optimized\")\n+            .build(), true\n+        );\n \n-    private String replaceCapiPort(String originalConfig) {\n-        return Arrays.stream(originalConfig.split(\"\\n\"))\n-            .map(s -> (s.matches(\"port\\\\s*=\\\\s*\" + CAPI.getOriginalPort())) ? \"port = \" + getMappedPort(CAPI) : s)\n-            .collect(Collectors.joining(\"\\n\"));\n+        checkSuccessfulResponse(response, \"Could not configure the indexing service\");\n     }\n \n-    @Override\n-    protected void containerIsStarted(InspectContainerResponse containerInfo) {\n-        if (!newBuckets.isEmpty()) {\n-            for (BucketAndUserSettings bucket : newBuckets) {\n-                createBucket(bucket.getBucketSettings(), bucket.getUserSettings(), primaryIndex);\n-            }\n-        }\n-    }\n-\n-    private CouchbaseCluster createCouchbaseCluster() {\n-        return CouchbaseCluster.create(getCouchbaseEnvironment(), getContainerIpAddress());\n-    }\n+    /**\n+     * Based on the user-configured bucket definitions, creating buckets and corresponding indexes if needed.\n+     */\n+    private void createBuckets() {\n+        logger().debug(\"Creating \" + buckets.size() + \" buckets (and corresponding indexes).\");\n \n-    private DefaultCouchbaseEnvironment createCouchbaseEnvironment() {\n-        initCluster();\n-        return DefaultCouchbaseEnvironment.builder()\n-            .kvTimeout(10000)\n-            .bootstrapCarrierDirectPort(getMappedPort(MEMCACHED))\n-            .bootstrapCarrierSslPort(getMappedPort(MEMCACHED_SSL))\n-            .bootstrapHttpDirectPort(getMappedPort(REST))\n-            .bootstrapHttpSslPort(getMappedPort(REST_SSL))\n-            .build();\n-    }\n+        for (BucketDefinition bucket : buckets) {\n+            logger().debug(\"Creating bucket \\\"\" + bucket.getName() + \"\\\"\");\n \n-    public CouchbaseContainer withMemoryQuota(String memoryQuota) {\n-        this.memoryQuota = memoryQuota;\n-        return self();\n-    }\n-\n-    public CouchbaseContainer withIndexMemoryQuota(String indexMemoryQuota) {\n-        this.indexMemoryQuota = indexMemoryQuota;\n-        return self();\n-    }\n+            Response response = doHttpRequest(MGMT_PORT, \"/pools/default/buckets\", \"POST\", new FormBody.Builder()\n+                .add(\"name\", bucket.getName())\n+                .add(\"ramQuotaMB\", Integer.toString(bucket.getQuota()))\n+                .build(), true);\n \n-    public CouchbaseContainer withClusterAdmin(String username, String password) {\n-        this.clusterUsername = username;\n-        this.clusterPassword = password;\n-        return self();\n-    }\n+            checkSuccessfulResponse(response, \"Could not create bucket \" + bucket.getName());\n \n-    public CouchbaseContainer withKeyValue(boolean keyValue) {\n-        this.keyValue = keyValue;\n-        return self();\n-    }\n+            new HttpWaitStrategy()\n+                .forPath(\"/pools/default/buckets/\" + bucket.getName())\n+                .forPort(MGMT_PORT)\n+                .withBasicCredentials(username, password)\n+                .forStatusCode(200)\n+                .waitUntilReady(this);\n \n-    public CouchbaseContainer withQuery(boolean query) {\n-        this.query = query;\n-        return self();\n-    }\n+            if (bucket.hasPrimaryIndex()) {\n+                if (enabledServices.contains(CouchbaseService.QUERY)) {\n+                    Response queryResponse = doHttpRequest(QUERY_PORT, \"/query/service\", \"POST\", new FormBody.Builder()\n+                        .add(\"statement\", \"CREATE PRIMARY INDEX on `\" + bucket.getName() + \"`\")\n+                        .build(), true);\n \n-    public CouchbaseContainer withIndex(boolean index) {\n-        this.index = index;\n-        return self();\n+                    checkSuccessfulResponse(queryResponse, \"Could not create primary index for bucket \" + bucket.getName());\n+                } else {\n+                    logger().info(\"Primary index creation for bucket \" + bucket.getName() + \" ignored, since QUERY service is not present.\");\n+                }\n+            }\n+        }\n     }\n \n-    public CouchbaseContainer withPrimaryIndex(boolean primaryIndex) {\n-        this.primaryIndex = primaryIndex;\n-        return self();\n+    /**\n+     * Helper method to extract the internal IP address based on the network configuration.\n+     */\n+    private String getInternalIpAddress() {\n+        final Map<String, ContainerNetwork> networks = getContainerInfo().getNetworkSettings().getNetworks();\n+        for (ContainerNetwork network : networks.values()) {\n+            return network.getIpAddress();\n+        }\n+        throw new IllegalStateException(\"No network available to extract the internal IP from!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e02eab968ac95b949f39c079cab0783ad9f30d80"}, "originalPosition": 675}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgzNjc1NQ==", "bodyText": "Here I was wondering if it wouldn't be nicer to make those default ports public constants in the container class?", "url": "https://github.com/testcontainers/testcontainers-java/pull/2491#discussion_r399836755", "createdAt": "2020-03-29T18:44:06Z", "author": {"login": "kiview"}, "path": "modules/couchbase/src/test/java/org/testcontainers/couchbase/CouchbaseContainerTest.java", "diffHunk": "@@ -1,22 +1,64 @@\n+/*\n+ * Copyright (c) 2020 Couchbase, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n package org.testcontainers.couchbase;\n \n-import org.junit.Assert;\n+import com.couchbase.client.java.Bucket;\n+import com.couchbase.client.java.Cluster;\n+import com.couchbase.client.java.CouchbaseCluster;\n+import com.couchbase.client.java.document.JsonDocument;\n+import com.couchbase.client.java.document.json.JsonObject;\n+import com.couchbase.client.java.env.CouchbaseEnvironment;\n+import com.couchbase.client.java.env.DefaultCouchbaseEnvironment;\n import org.junit.Test;\n \n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n public class CouchbaseContainerTest {\n \n     @Test\n-    public void shouldUseCorrectDockerImage() {\n-        CouchbaseContainer couchbaseContainer = new CouchbaseContainer().withClusterAdmin(\"admin\", \"foobar\");\n+    public void testBasicContainerUsage() {\n+        BucketDefinition bucketDefinition = new BucketDefinition(\"mybucket\");\n \n-        Assert.assertEquals(CouchbaseContainer.DOCKER_IMAGE_NAME + CouchbaseContainer.VERSION,\n-            couchbaseContainer.getDockerImageName());\n-    }\n+        try (CouchbaseContainer container = new CouchbaseContainer().withBucket(bucketDefinition)) {\n+            container.start();\n \n-    @Test\n-    public void shouldStopWithoutThrowingException() {\n-        CouchbaseContainer couchbaseContainer = new CouchbaseContainer();\n-        couchbaseContainer.start();\n-        couchbaseContainer.stop();\n+            CouchbaseEnvironment environment = DefaultCouchbaseEnvironment\n+                .builder()\n+                .bootstrapCarrierDirectPort(container.getMappedPort(11210))\n+                .bootstrapHttpDirectPort(container.getMappedPort(8091))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e02eab968ac95b949f39c079cab0783ad9f30d80"}, "originalPosition": 54}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c81e7bfce219d7ff43666f378e8f22b2aaf33f6f", "author": {"user": {"login": "bsideup", "name": "Sergei Egorov"}}, "url": "https://github.com/testcontainers/testcontainers-java/commit/c81e7bfce219d7ff43666f378e8f22b2aaf33f6f", "committedDate": "2020-04-12T13:19:13Z", "message": "add `getBootstrap*DirectPort()` methods, review fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1e2273c6667b6ba8f818f2332b5ebaa0d2c15a3", "author": {"user": {"login": "bsideup", "name": "Sergei Egorov"}}, "url": "https://github.com/testcontainers/testcontainers-java/commit/c1e2273c6667b6ba8f818f2332b5ebaa0d2c15a3", "committedDate": "2020-04-12T13:19:24Z", "message": "Merge branch 'master' into daschl/couchbase-rewrite"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d1cf174c1e86e0991f0199e99079e9ab0d4b33c", "author": {"user": {"login": "bsideup", "name": "Sergei Egorov"}}, "url": "https://github.com/testcontainers/testcontainers-java/commit/8d1cf174c1e86e0991f0199e99079e9ab0d4b33c", "committedDate": "2020-04-12T17:02:11Z", "message": "Restore `getConnectionString()`"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxODc5MDMw", "url": "https://github.com/testcontainers/testcontainers-java/pull/2491#pullrequestreview-391879030", "createdAt": "2020-04-12T17:28:43Z", "commit": {"oid": "8d1cf174c1e86e0991f0199e99079e9ab0d4b33c"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMlQxNzoyODo0M1rOGEXQpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMlQxNzo1MTo0OVrOGEXbSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIyODU4MQ==", "bodyText": "Why does knowing about status code 200 help?", "url": "https://github.com/testcontainers/testcontainers-java/pull/2491#discussion_r407228581", "createdAt": "2020-04-12T17:28:43Z", "author": {"login": "kiview"}, "path": "modules/couchbase/src/main/java/org/testcontainers/couchbase/CouchbaseContainer.java", "diffHunk": "@@ -15,447 +15,423 @@\n  */\n package org.testcontainers.couchbase;\n \n-import com.couchbase.client.core.utils.Base64;\n-import com.couchbase.client.java.Bucket;\n-import com.couchbase.client.java.CouchbaseCluster;\n-import com.couchbase.client.java.cluster.*;\n-import com.couchbase.client.java.env.CouchbaseEnvironment;\n-import com.couchbase.client.java.env.DefaultCouchbaseEnvironment;\n-import com.couchbase.client.java.query.Index;\n import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.github.dockerjava.api.command.ExecCreateCmdResponse;\n import com.github.dockerjava.api.command.InspectContainerResponse;\n-import com.google.common.collect.Lists;\n-import lombok.*;\n-import org.apache.commons.compress.utils.Sets;\n-import org.apache.commons.io.IOUtils;\n-import org.jetbrains.annotations.NotNull;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import okhttp3.Credentials;\n+import okhttp3.FormBody;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n import org.testcontainers.containers.GenericContainer;\n-import org.testcontainers.containers.Network;\n-import org.testcontainers.containers.SocatContainer;\n import org.testcontainers.containers.wait.strategy.HttpWaitStrategy;\n-import org.testcontainers.images.builder.Transferable;\n-import org.testcontainers.utility.ThrowingFunction;\n+import org.testcontainers.containers.wait.strategy.WaitAllStrategy;\n \n-import java.io.DataOutputStream;\n import java.io.IOException;\n-import java.net.HttpURLConnection;\n-import java.net.URL;\n-import java.net.URLEncoder;\n-import java.nio.charset.StandardCharsets;\n-import java.util.*;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import static java.net.HttpURLConnection.HTTP_OK;\n-import static org.testcontainers.couchbase.CouchbaseContainer.CouchbasePort.*;\n \n /**\n- * Based on Laurent Doguin version,\n+ * The couchbase container initializes and configures a Couchbase Server single node cluster.\n  * <p>\n- * optimized by Tayeb Chlyah\n+ * Note that it does not depend on a specific couchbase SDK, so it can be used with both the Java SDK 2 and 3 as well\n+ * as the Scala SDK 1 or newer. We recommend using the latest and greatest SDKs for the best experience.\n  */\n-@AllArgsConstructor\n public class CouchbaseContainer extends GenericContainer<CouchbaseContainer> {\n \n-    public static final String VERSION = \"5.5.1\";\n-    public static final String DOCKER_IMAGE_NAME = \"couchbase/server:\";\n-    public static final ObjectMapper MAPPER = new ObjectMapper();\n-    public static final String STATIC_CONFIG = \"/opt/couchbase/etc/couchbase/static_config\";\n-    public static final String CAPI_CONFIG = \"/opt/couchbase/etc/couchdb/default.d/capi.ini\";\n+    private static final int MGMT_PORT = 8091;\n+\n+    private static final int MGMT_SSL_PORT = 18091;\n+\n+    private static final int VIEW_PORT = 8092;\n \n-    private static final int REQUIRED_DEFAULT_PASSWORD_LENGTH = 6;\n+    private static final int VIEW_SSL_PORT = 18092;\n \n-    private String memoryQuota = \"300\";\n+    private static final int QUERY_PORT = 8093;\n \n-    private String indexMemoryQuota = \"300\";\n+    private static final int QUERY_SSL_PORT = 18093;\n \n-    private String clusterUsername = \"Administrator\";\n+    private static final int SEARCH_PORT = 8094;\n \n-    private String clusterPassword = \"password\";\n+    private static final int SEARCH_SSL_PORT = 18094;\n \n-    private boolean keyValue = true;\n+    private static final int KV_PORT = 11210;\n \n-    @Getter\n-    private boolean query = true;\n+    private static final int KV_SSL_PORT = 11207;\n \n-    @Getter\n-    private boolean index = true;\n+    private static final String DOCKER_IMAGE_NAME = \"couchbase/server\";\n \n-    @Getter\n-    private boolean primaryIndex = true;\n+    private static final String VERSION = \"6.5.0\";\n \n-    @Getter\n-    private boolean fts = false;\n+    private static final ObjectMapper MAPPER = new ObjectMapper();\n \n-    @Getter(lazy = true)\n-    private final CouchbaseEnvironment couchbaseEnvironment = createCouchbaseEnvironment();\n+    private static final OkHttpClient HTTP_CLIENT = new OkHttpClient()\n+        .newBuilder()\n+        .readTimeout(Duration.ofMinutes(1))\n+        .build();\n \n-    @Getter(lazy = true)\n-    private final CouchbaseCluster couchbaseCluster = createCouchbaseCluster();\n+    private String username = \"Administrator\";\n \n-    private List<BucketAndUserSettings> newBuckets = new ArrayList<>();\n+    private String password = \"password\";\n \n-    private String urlBase;\n+    private Set<CouchbaseService> enabledServices = EnumSet.allOf(CouchbaseService.class);\n \n-    private SocatContainer proxy;\n+    private final List<BucketDefinition> buckets = new ArrayList<>();\n \n+    /**\n+     * Creates a new couchbase container with the default image and version.\n+     */\n     public CouchbaseContainer() {\n-        this(DOCKER_IMAGE_NAME + VERSION);\n+        this(DOCKER_IMAGE_NAME + \":\" + VERSION);\n     }\n \n-    public CouchbaseContainer(String imageName) {\n+    /**\n+     * Creates a new couchbase container with a custom image name.\n+     *\n+     * @param imageName the image name that should be used.\n+     */\n+    public CouchbaseContainer(final String imageName) {\n         super(imageName);\n-\n-        withNetwork(Network.SHARED);\n-        setWaitStrategy(new HttpWaitStrategy().forPath(\"/ui/index.html\"));\n     }\n \n-    @Override\n-    public Set<Integer> getLivenessCheckPortNumbers() {\n-        return Sets.newHashSet(getMappedPort(REST));\n+    /**\n+     * Set custom username and password for the admin user.\n+     *\n+     * @param username the admin username to use.\n+     * @param password the password for the admin user.\n+     * @return this {@link CouchbaseContainer} for chaining purposes.\n+     */\n+    public CouchbaseContainer withCredentials(final String username, final String password) {\n+        checkNotRunning();\n+        this.username = username;\n+        this.password = password;\n+        return this;\n     }\n \n-    @Override\n-    protected void configure() {\n-        if (clusterPassword.length() < REQUIRED_DEFAULT_PASSWORD_LENGTH) {\n-            logger().warn(\"The provided cluster admin password length is less then the default password policy length. \" +\n-                \"Cluster start will fail if configured password requirements are not met.\");\n-        }\n+    public CouchbaseContainer withBucket(final BucketDefinition bucketDefinition) {\n+        checkNotRunning();\n+        this.buckets.add(bucketDefinition);\n+        return this;\n     }\n \n-    @Override\n-    @SneakyThrows\n-    protected void doStart() {\n-        startProxy(getNetworkAliases().get(0));\n-        try {\n-            super.doStart();\n-        } catch (Throwable e) {\n-            proxy.stop();\n-            throw e;\n-        }\n+    public CouchbaseContainer withEnabledServices(final CouchbaseService... enabled) {\n+        checkNotRunning();\n+        this.enabledServices = EnumSet.copyOf(Arrays.asList(enabled));\n+        return this;\n     }\n \n-    @SneakyThrows\n-    private void startProxy(String networkAlias) {\n-        proxy = new SocatContainer().withNetwork(getNetwork());\n-\n-        for (CouchbasePort port : CouchbasePort.values()) {\n-            if (port.isDynamic()) {\n-                proxy.withTarget(port.getOriginalPort(), networkAlias);\n-            } else {\n-                proxy.addExposedPort(port.getOriginalPort());\n-            }\n-        }\n-\n-        proxy.setWaitStrategy(null);\n-        proxy.start();\n-\n-        ExecCreateCmdResponse createCmdResponse = dockerClient\n-            .execCreateCmd(proxy.getContainerId())\n-            .withCmd(\n-                \"sh\",\n-                \"-c\",\n-                Stream.of(CouchbasePort.values())\n-                    .map(port -> {\n-                        return \"/usr/bin/socat \" +\n-                            \"TCP-LISTEN:\" + port.getOriginalPort() + \",fork,reuseaddr \" +\n-                            \"TCP:\" + networkAlias + \":\" + getMappedPort(port);\n-                    })\n-                    .collect(Collectors.joining(\" & \", \"true\", \"\"))\n-            )\n-            .exec();\n-\n-        dockerClient.execStartCmd(createCmdResponse.getId())\n-            .start()\n-            .awaitCompletion(10, TimeUnit.SECONDS);\n+    public final String getUsername() {\n+        return username;\n     }\n \n-    @Override\n-    public List<Integer> getExposedPorts() {\n-        return proxy.getExposedPorts();\n+    public final String getPassword() {\n+        return password;\n     }\n \n-    @Override\n-    public String getContainerIpAddress() {\n-        return proxy.getContainerIpAddress();\n+    public String getConnectionString() {\n+        return String.format(\"couchbase://%s:%d\", getContainerIpAddress(), getMappedPort(KV_PORT));\n     }\n \n     @Override\n-    public Integer getMappedPort(int originalPort) {\n-        return proxy.getMappedPort(originalPort);\n-    }\n+    protected void configure() {\n+        super.configure();\n+\n+        WaitAllStrategy waitStrategy = new WaitAllStrategy();\n+\n+        // Makes sure that all nodes in the cluster are healthy.\n+        waitStrategy = waitStrategy.withStrategy(\n+            new HttpWaitStrategy()\n+                .forPath(\"/pools/default\")\n+                .forPort(MGMT_PORT)\n+                .withBasicCredentials(username, password)\n+                .forStatusCode(200)\n+                .forResponsePredicate(response -> {\n+                    try {\n+                        return Optional.of(MAPPER.readTree(response))\n+                            .map(n -> n.at(\"/nodes/0/status\"))\n+                            .map(JsonNode::asText)\n+                            .map(\"healthy\"::equals)\n+                            .orElse(false);\n+                    } catch (IOException e) {\n+                        logger().error(\"Unable to parse response {}\", response);\n+                        return false;\n+                    }\n+                })\n+        );\n+\n+        if (enabledServices.contains(CouchbaseService.QUERY)) {\n+            waitStrategy = waitStrategy.withStrategy(\n+                new HttpWaitStrategy()\n+                    .forPath(\"/admin/ping\")\n+                    .forPort(QUERY_PORT)\n+                    .withBasicCredentials(username, password)\n+                    .forStatusCode(200)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgzNTA4MQ=="}, "originalCommit": {"oid": "e02eab968ac95b949f39c079cab0783ad9f30d80"}, "originalPosition": 294}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIyODk5NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger().debug(\"Renaming Couchbase Node from localhost to \" + getContainerIpAddress());\n          \n          \n            \n                    logger().debug(\"Renaming Couchbase Node from localhost to {}\", getContainerIpAddress());", "url": "https://github.com/testcontainers/testcontainers-java/pull/2491#discussion_r407228995", "createdAt": "2020-04-12T17:32:00Z", "author": {"login": "kiview"}, "path": "modules/couchbase/src/main/java/org/testcontainers/couchbase/CouchbaseContainer.java", "diffHunk": "@@ -15,447 +15,424 @@\n  */\n package org.testcontainers.couchbase;\n \n-import com.couchbase.client.core.utils.Base64;\n-import com.couchbase.client.java.Bucket;\n-import com.couchbase.client.java.CouchbaseCluster;\n-import com.couchbase.client.java.cluster.*;\n-import com.couchbase.client.java.env.CouchbaseEnvironment;\n-import com.couchbase.client.java.env.DefaultCouchbaseEnvironment;\n-import com.couchbase.client.java.query.Index;\n import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.github.dockerjava.api.command.ExecCreateCmdResponse;\n import com.github.dockerjava.api.command.InspectContainerResponse;\n-import com.google.common.collect.Lists;\n-import lombok.*;\n-import org.apache.commons.compress.utils.Sets;\n-import org.apache.commons.io.IOUtils;\n-import org.jetbrains.annotations.NotNull;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import okhttp3.Credentials;\n+import okhttp3.FormBody;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n import org.testcontainers.containers.GenericContainer;\n-import org.testcontainers.containers.Network;\n-import org.testcontainers.containers.SocatContainer;\n import org.testcontainers.containers.wait.strategy.HttpWaitStrategy;\n-import org.testcontainers.images.builder.Transferable;\n-import org.testcontainers.utility.ThrowingFunction;\n+import org.testcontainers.containers.wait.strategy.WaitAllStrategy;\n \n-import java.io.DataOutputStream;\n import java.io.IOException;\n-import java.net.HttpURLConnection;\n-import java.net.URL;\n-import java.net.URLEncoder;\n-import java.nio.charset.StandardCharsets;\n-import java.util.*;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import static java.net.HttpURLConnection.HTTP_OK;\n-import static org.testcontainers.couchbase.CouchbaseContainer.CouchbasePort.*;\n \n /**\n- * Based on Laurent Doguin version,\n+ * The couchbase container initializes and configures a Couchbase Server single node cluster.\n  * <p>\n- * optimized by Tayeb Chlyah\n+ * Note that it does not depend on a specific couchbase SDK, so it can be used with both the Java SDK 2 and 3 as well\n+ * as the Scala SDK 1 or newer. We recommend using the latest and greatest SDKs for the best experience.\n  */\n-@AllArgsConstructor\n public class CouchbaseContainer extends GenericContainer<CouchbaseContainer> {\n \n-    public static final String VERSION = \"5.5.1\";\n-    public static final String DOCKER_IMAGE_NAME = \"couchbase/server:\";\n-    public static final ObjectMapper MAPPER = new ObjectMapper();\n-    public static final String STATIC_CONFIG = \"/opt/couchbase/etc/couchbase/static_config\";\n-    public static final String CAPI_CONFIG = \"/opt/couchbase/etc/couchdb/default.d/capi.ini\";\n+    private static final int MGMT_PORT = 8091;\n+\n+    private static final int MGMT_SSL_PORT = 18091;\n+\n+    private static final int VIEW_PORT = 8092;\n \n-    private static final int REQUIRED_DEFAULT_PASSWORD_LENGTH = 6;\n+    private static final int VIEW_SSL_PORT = 18092;\n \n-    private String memoryQuota = \"300\";\n+    private static final int QUERY_PORT = 8093;\n \n-    private String indexMemoryQuota = \"300\";\n+    private static final int QUERY_SSL_PORT = 18093;\n \n-    private String clusterUsername = \"Administrator\";\n+    private static final int SEARCH_PORT = 8094;\n \n-    private String clusterPassword = \"password\";\n+    private static final int SEARCH_SSL_PORT = 18094;\n \n-    private boolean keyValue = true;\n+    private static final int KV_PORT = 11210;\n \n-    @Getter\n-    private boolean query = true;\n+    private static final int KV_SSL_PORT = 11207;\n \n-    @Getter\n-    private boolean index = true;\n+    private static final String DOCKER_IMAGE_NAME = \"couchbase/server\";\n \n-    @Getter\n-    private boolean primaryIndex = true;\n+    private static final String VERSION = \"6.5.0\";\n \n-    @Getter\n-    private boolean fts = false;\n+    private static final ObjectMapper MAPPER = new ObjectMapper();\n \n-    @Getter(lazy = true)\n-    private final CouchbaseEnvironment couchbaseEnvironment = createCouchbaseEnvironment();\n+    private static final OkHttpClient HTTP_CLIENT = new OkHttpClient();\n \n-    @Getter(lazy = true)\n-    private final CouchbaseCluster couchbaseCluster = createCouchbaseCluster();\n+    private String username = \"Administrator\";\n \n-    private List<BucketAndUserSettings> newBuckets = new ArrayList<>();\n+    private String password = \"password\";\n \n-    private String urlBase;\n+    private Set<CouchbaseService> enabledServices = EnumSet.allOf(CouchbaseService.class);\n \n-    private SocatContainer proxy;\n+    private final List<BucketDefinition> buckets = new ArrayList<>();\n \n+    /**\n+     * Creates a new couchbase container with the default image and version.\n+     */\n     public CouchbaseContainer() {\n-        this(DOCKER_IMAGE_NAME + VERSION);\n+        this(DOCKER_IMAGE_NAME + \":\" + VERSION);\n     }\n \n-    public CouchbaseContainer(String imageName) {\n+    /**\n+     * Creates a new couchbase container with a custom image name.\n+     *\n+     * @param imageName the image name that should be used.\n+     */\n+    public CouchbaseContainer(final String imageName) {\n         super(imageName);\n-\n-        withNetwork(Network.SHARED);\n-        setWaitStrategy(new HttpWaitStrategy().forPath(\"/ui/index.html\"));\n     }\n \n-    @Override\n-    public Set<Integer> getLivenessCheckPortNumbers() {\n-        return Sets.newHashSet(getMappedPort(REST));\n+    /**\n+     * Set custom username and password for the admin user.\n+     *\n+     * @param username the admin username to use.\n+     * @param password the password for the admin user.\n+     * @return this {@link CouchbaseContainer} for chaining purposes.\n+     */\n+    public CouchbaseContainer withCredentials(final String username, final String password) {\n+        checkNotRunning();\n+        this.username = username;\n+        this.password = password;\n+        return this;\n     }\n \n-    @Override\n-    protected void configure() {\n-        if (clusterPassword.length() < REQUIRED_DEFAULT_PASSWORD_LENGTH) {\n-            logger().warn(\"The provided cluster admin password length is less then the default password policy length. \" +\n-                \"Cluster start will fail if configured password requirements are not met.\");\n-        }\n+    public CouchbaseContainer withBucket(final BucketDefinition bucketDefinition) {\n+        checkNotRunning();\n+        this.buckets.add(bucketDefinition);\n+        return this;\n     }\n \n-    @Override\n-    @SneakyThrows\n-    protected void doStart() {\n-        startProxy(getNetworkAliases().get(0));\n-        try {\n-            super.doStart();\n-        } catch (Throwable e) {\n-            proxy.stop();\n-            throw e;\n-        }\n+    public CouchbaseContainer withEnabledServices(final CouchbaseService... enabled) {\n+        checkNotRunning();\n+        this.enabledServices = EnumSet.copyOf(Arrays.asList(enabled));\n+        return this;\n     }\n \n-    @SneakyThrows\n-    private void startProxy(String networkAlias) {\n-        proxy = new SocatContainer().withNetwork(getNetwork());\n-\n-        for (CouchbasePort port : CouchbasePort.values()) {\n-            if (port.isDynamic()) {\n-                proxy.withTarget(port.getOriginalPort(), networkAlias);\n-            } else {\n-                proxy.addExposedPort(port.getOriginalPort());\n-            }\n-        }\n-\n-        proxy.setWaitStrategy(null);\n-        proxy.start();\n-\n-        ExecCreateCmdResponse createCmdResponse = dockerClient\n-            .execCreateCmd(proxy.getContainerId())\n-            .withCmd(\n-                \"sh\",\n-                \"-c\",\n-                Stream.of(CouchbasePort.values())\n-                    .map(port -> {\n-                        return \"/usr/bin/socat \" +\n-                            \"TCP-LISTEN:\" + port.getOriginalPort() + \",fork,reuseaddr \" +\n-                            \"TCP:\" + networkAlias + \":\" + getMappedPort(port);\n-                    })\n-                    .collect(Collectors.joining(\" & \", \"true\", \"\"))\n-            )\n-            .exec();\n-\n-        dockerClient.execStartCmd(createCmdResponse.getId())\n-            .start()\n-            .awaitCompletion(10, TimeUnit.SECONDS);\n+    public final String getUsername() {\n+        return username;\n     }\n \n-    @Override\n-    public List<Integer> getExposedPorts() {\n-        return proxy.getExposedPorts();\n+    public final String getPassword() {\n+        return password;\n     }\n \n-    @Override\n-    public String getContainerIpAddress() {\n-        return proxy.getContainerIpAddress();\n+    public int getBootstrapCarrierDirectPort() {\n+        return getMappedPort(KV_PORT);\n     }\n \n-    @Override\n-    public Integer getMappedPort(int originalPort) {\n-        return proxy.getMappedPort(originalPort);\n+    public int getBootstrapHttpDirectPort() {\n+        return getMappedPort(MGMT_PORT);\n     }\n \n-    protected Integer getMappedPort(CouchbasePort port) {\n-        return getMappedPort(port.getOriginalPort());\n+    public String getConnectionString() {\n+        return String.format(\"couchbase://%s:%d\", getContainerIpAddress(), getBootstrapCarrierDirectPort());\n     }\n \n     @Override\n-    public List<Integer> getBoundPortNumbers() {\n-        return proxy.getBoundPortNumbers();\n-    }\n-\n-    @Override\n-    @SuppressWarnings({\"unchecked\", \"ConstantConditions\"})\n-    public void stop() {\n-        try {\n-            stopCluster();\n-            ((AtomicReference<Object>) (Object) couchbaseEnvironment).set(null);\n-            ((AtomicReference<Object>) (Object) couchbaseCluster).set(null);\n-        } finally {\n-            Stream.<Runnable>of(super::stop, proxy::stop).parallel().forEach(Runnable::run);\n+    protected void configure() {\n+        super.configure();\n+\n+        WaitAllStrategy waitStrategy = new WaitAllStrategy();\n+\n+        // Makes sure that all nodes in the cluster are healthy.\n+        waitStrategy = waitStrategy.withStrategy(\n+            new HttpWaitStrategy()\n+                .forPath(\"/pools/default\")\n+                .forPort(MGMT_PORT)\n+                .withBasicCredentials(username, password)\n+                .forStatusCode(200)\n+                .forResponsePredicate(response -> {\n+                    try {\n+                        return Optional.of(MAPPER.readTree(response))\n+                            .map(n -> n.at(\"/nodes/0/status\"))\n+                            .map(JsonNode::asText)\n+                            .map(\"healthy\"::equals)\n+                            .orElse(false);\n+                    } catch (IOException e) {\n+                        logger().error(\"Unable to parse response {}\", response);\n+                        return false;\n+                    }\n+                })\n+        );\n+\n+        if (enabledServices.contains(CouchbaseService.QUERY)) {\n+            waitStrategy = waitStrategy.withStrategy(\n+                new HttpWaitStrategy()\n+                    .forPath(\"/admin/ping\")\n+                    .forPort(QUERY_PORT)\n+                    .withBasicCredentials(username, password)\n+                    .forStatusCode(200)\n+            );\n         }\n-    }\n-\n-    private void stopCluster() {\n-        getCouchbaseCluster().disconnect();\n-        getCouchbaseEnvironment().shutdown();\n-    }\n-\n-    public CouchbaseContainer withNewBucket(BucketSettings bucketSettings) {\n-        newBuckets.add(new BucketAndUserSettings(bucketSettings));\n-        return self();\n-    }\n \n-    public CouchbaseContainer withNewBucket(BucketSettings bucketSettings, UserSettings userSettings) {\n-        newBuckets.add(new BucketAndUserSettings(bucketSettings, userSettings));\n-        return self();\n+        waitingFor(waitStrategy);\n     }\n \n-    @SneakyThrows\n-    public void initCluster() {\n-        urlBase = String.format(\"http://%s:%s\", getContainerIpAddress(), getMappedPort(REST));\n-        String poolURL = \"/pools/default\";\n-        String poolPayload = \"memoryQuota=\" + URLEncoder.encode(memoryQuota, \"UTF-8\") + \"&indexMemoryQuota=\" + URLEncoder.encode(indexMemoryQuota, \"UTF-8\");\n-\n-        String setupServicesURL = \"/node/controller/setupServices\";\n-        StringBuilder servicePayloadBuilder = new StringBuilder();\n-        if (keyValue) {\n-            servicePayloadBuilder.append(\"kv,\");\n-        }\n-        if (query) {\n-            servicePayloadBuilder.append(\"n1ql,\");\n-        }\n-        if (index) {\n-            servicePayloadBuilder.append(\"index,\");\n-        }\n-        if (fts) {\n-            servicePayloadBuilder.append(\"fts,\");\n+    @Override\n+    protected void containerIsStarting(final InspectContainerResponse containerInfo) {\n+        logger().debug(\"Couchbase container is starting, performing configuration.\");\n+\n+        waitUntilNodeIsOnline();\n+        renameNode();\n+        initializeServices();\n+        configureAdminUser();\n+        configureExternalPorts();\n+        if (enabledServices.contains(CouchbaseService.INDEX)) {\n+            configureIndexer();\n         }\n-        String setupServiceContent = \"services=\" + URLEncoder.encode(servicePayloadBuilder.toString(), \"UTF-8\");\n-\n-        String webSettingsURL = \"/settings/web\";\n-        String webSettingsContent = \"username=\" + URLEncoder.encode(clusterUsername, \"UTF-8\") + \"&password=\" + URLEncoder.encode(clusterPassword, \"UTF-8\") + \"&port=8091\";\n-\n-        callCouchbaseRestAPI(poolURL, poolPayload);\n-        callCouchbaseRestAPI(setupServicesURL, setupServiceContent);\n-        callCouchbaseRestAPI(webSettingsURL, webSettingsContent);\n-\n-        createNodeWaitStrategy().waitUntilReady(this);\n-        callCouchbaseRestAPI(\"/settings/indexes\", \"indexerThreads=0&logLevel=info&maxRollbackPoints=5&storageMode=memory_optimized\");\n     }\n \n-    @NotNull\n-    private HttpWaitStrategy createNodeWaitStrategy() {\n-        return new HttpWaitStrategy()\n-            .forPath(\"/pools/default/\")\n-            .withBasicCredentials(clusterUsername, clusterPassword)\n-            .forStatusCode(HTTP_OK)\n-            .forResponsePredicate(response -> {\n-                try {\n-                    return Optional.of(MAPPER.readTree(response))\n-                        .map(n -> n.at(\"/nodes/0/status\"))\n-                        .map(JsonNode::asText)\n-                        .map(\"healthy\"::equals)\n-                        .orElse(false);\n-                } catch (IOException e) {\n-                    logger().error(\"Unable to parse response {}\", response);\n-                    return false;\n-                }\n-            });\n-    }\n-\n-    public void createBucket(BucketSettings bucketSetting, UserSettings userSettings, boolean primaryIndex) {\n-        ClusterManager clusterManager = getCouchbaseCluster().clusterManager(clusterUsername, clusterPassword);\n-        // Insert Bucket\n-        BucketSettings bucketSettings = clusterManager.insertBucket(bucketSetting);\n-        try {\n-            // Insert Bucket user\n-            clusterManager.upsertUser(AuthDomain.LOCAL, bucketSetting.name(), userSettings);\n-        } catch (Exception e) {\n-            logger().warn(\"Unable to insert user '\" + bucketSetting.name() + \"', maybe you are using older version\");\n-        }\n-        if (index) {\n-            Bucket bucket = getCouchbaseCluster().openBucket(bucketSettings.name(), bucketSettings.password());\n-            new CouchbaseQueryServiceWaitStrategy(bucket).waitUntilReady(this);\n-            if (primaryIndex) {\n-                bucket.query(Index.createPrimaryIndex().on(bucketSetting.name()));\n+    @Override\n+    protected void containerIsStarted(InspectContainerResponse containerInfo) {\n+        createBuckets();\n+        logger().info(\"Couchbase container is ready! UI available at http://{}:{}\", getContainerIpAddress(), getMappedPort(MGMT_PORT));\n+    }\n+\n+    /**\n+     * Before we can start configuring the host, we need to wait until the cluster manager is listening.\n+     */\n+    private void waitUntilNodeIsOnline() {\n+        new HttpWaitStrategy()\n+            .forPort(MGMT_PORT)\n+            .forPath(\"/pools\")\n+            .forStatusCode(200)\n+            .waitUntilReady(this);\n+    }\n+\n+    /**\n+     * Rebinds/renames the internal hostname.\n+     * <p>\n+     * To make sure the internal hostname is different from the external (alternate) address and the SDK can pick it\n+     * up automatically, we bind the internal hostname to the internal IP address.\n+     */\n+    private void renameNode() {\n+        logger().debug(\"Renaming Couchbase Node from localhost to \" + getContainerIpAddress());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d1cf174c1e86e0991f0199e99079e9ab0d4b33c"}, "originalPosition": 436}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIyOTA1OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger().debug(\"Initializing couchbase services on host: \" + enabledServices);\n          \n          \n            \n                    logger().debug(\"Initializing couchbase services on host: {}\", enabledServices);", "url": "https://github.com/testcontainers/testcontainers-java/pull/2491#discussion_r407229059", "createdAt": "2020-04-12T17:32:26Z", "author": {"login": "kiview"}, "path": "modules/couchbase/src/main/java/org/testcontainers/couchbase/CouchbaseContainer.java", "diffHunk": "@@ -15,447 +15,424 @@\n  */\n package org.testcontainers.couchbase;\n \n-import com.couchbase.client.core.utils.Base64;\n-import com.couchbase.client.java.Bucket;\n-import com.couchbase.client.java.CouchbaseCluster;\n-import com.couchbase.client.java.cluster.*;\n-import com.couchbase.client.java.env.CouchbaseEnvironment;\n-import com.couchbase.client.java.env.DefaultCouchbaseEnvironment;\n-import com.couchbase.client.java.query.Index;\n import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.github.dockerjava.api.command.ExecCreateCmdResponse;\n import com.github.dockerjava.api.command.InspectContainerResponse;\n-import com.google.common.collect.Lists;\n-import lombok.*;\n-import org.apache.commons.compress.utils.Sets;\n-import org.apache.commons.io.IOUtils;\n-import org.jetbrains.annotations.NotNull;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import okhttp3.Credentials;\n+import okhttp3.FormBody;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n import org.testcontainers.containers.GenericContainer;\n-import org.testcontainers.containers.Network;\n-import org.testcontainers.containers.SocatContainer;\n import org.testcontainers.containers.wait.strategy.HttpWaitStrategy;\n-import org.testcontainers.images.builder.Transferable;\n-import org.testcontainers.utility.ThrowingFunction;\n+import org.testcontainers.containers.wait.strategy.WaitAllStrategy;\n \n-import java.io.DataOutputStream;\n import java.io.IOException;\n-import java.net.HttpURLConnection;\n-import java.net.URL;\n-import java.net.URLEncoder;\n-import java.nio.charset.StandardCharsets;\n-import java.util.*;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import static java.net.HttpURLConnection.HTTP_OK;\n-import static org.testcontainers.couchbase.CouchbaseContainer.CouchbasePort.*;\n \n /**\n- * Based on Laurent Doguin version,\n+ * The couchbase container initializes and configures a Couchbase Server single node cluster.\n  * <p>\n- * optimized by Tayeb Chlyah\n+ * Note that it does not depend on a specific couchbase SDK, so it can be used with both the Java SDK 2 and 3 as well\n+ * as the Scala SDK 1 or newer. We recommend using the latest and greatest SDKs for the best experience.\n  */\n-@AllArgsConstructor\n public class CouchbaseContainer extends GenericContainer<CouchbaseContainer> {\n \n-    public static final String VERSION = \"5.5.1\";\n-    public static final String DOCKER_IMAGE_NAME = \"couchbase/server:\";\n-    public static final ObjectMapper MAPPER = new ObjectMapper();\n-    public static final String STATIC_CONFIG = \"/opt/couchbase/etc/couchbase/static_config\";\n-    public static final String CAPI_CONFIG = \"/opt/couchbase/etc/couchdb/default.d/capi.ini\";\n+    private static final int MGMT_PORT = 8091;\n+\n+    private static final int MGMT_SSL_PORT = 18091;\n+\n+    private static final int VIEW_PORT = 8092;\n \n-    private static final int REQUIRED_DEFAULT_PASSWORD_LENGTH = 6;\n+    private static final int VIEW_SSL_PORT = 18092;\n \n-    private String memoryQuota = \"300\";\n+    private static final int QUERY_PORT = 8093;\n \n-    private String indexMemoryQuota = \"300\";\n+    private static final int QUERY_SSL_PORT = 18093;\n \n-    private String clusterUsername = \"Administrator\";\n+    private static final int SEARCH_PORT = 8094;\n \n-    private String clusterPassword = \"password\";\n+    private static final int SEARCH_SSL_PORT = 18094;\n \n-    private boolean keyValue = true;\n+    private static final int KV_PORT = 11210;\n \n-    @Getter\n-    private boolean query = true;\n+    private static final int KV_SSL_PORT = 11207;\n \n-    @Getter\n-    private boolean index = true;\n+    private static final String DOCKER_IMAGE_NAME = \"couchbase/server\";\n \n-    @Getter\n-    private boolean primaryIndex = true;\n+    private static final String VERSION = \"6.5.0\";\n \n-    @Getter\n-    private boolean fts = false;\n+    private static final ObjectMapper MAPPER = new ObjectMapper();\n \n-    @Getter(lazy = true)\n-    private final CouchbaseEnvironment couchbaseEnvironment = createCouchbaseEnvironment();\n+    private static final OkHttpClient HTTP_CLIENT = new OkHttpClient();\n \n-    @Getter(lazy = true)\n-    private final CouchbaseCluster couchbaseCluster = createCouchbaseCluster();\n+    private String username = \"Administrator\";\n \n-    private List<BucketAndUserSettings> newBuckets = new ArrayList<>();\n+    private String password = \"password\";\n \n-    private String urlBase;\n+    private Set<CouchbaseService> enabledServices = EnumSet.allOf(CouchbaseService.class);\n \n-    private SocatContainer proxy;\n+    private final List<BucketDefinition> buckets = new ArrayList<>();\n \n+    /**\n+     * Creates a new couchbase container with the default image and version.\n+     */\n     public CouchbaseContainer() {\n-        this(DOCKER_IMAGE_NAME + VERSION);\n+        this(DOCKER_IMAGE_NAME + \":\" + VERSION);\n     }\n \n-    public CouchbaseContainer(String imageName) {\n+    /**\n+     * Creates a new couchbase container with a custom image name.\n+     *\n+     * @param imageName the image name that should be used.\n+     */\n+    public CouchbaseContainer(final String imageName) {\n         super(imageName);\n-\n-        withNetwork(Network.SHARED);\n-        setWaitStrategy(new HttpWaitStrategy().forPath(\"/ui/index.html\"));\n     }\n \n-    @Override\n-    public Set<Integer> getLivenessCheckPortNumbers() {\n-        return Sets.newHashSet(getMappedPort(REST));\n+    /**\n+     * Set custom username and password for the admin user.\n+     *\n+     * @param username the admin username to use.\n+     * @param password the password for the admin user.\n+     * @return this {@link CouchbaseContainer} for chaining purposes.\n+     */\n+    public CouchbaseContainer withCredentials(final String username, final String password) {\n+        checkNotRunning();\n+        this.username = username;\n+        this.password = password;\n+        return this;\n     }\n \n-    @Override\n-    protected void configure() {\n-        if (clusterPassword.length() < REQUIRED_DEFAULT_PASSWORD_LENGTH) {\n-            logger().warn(\"The provided cluster admin password length is less then the default password policy length. \" +\n-                \"Cluster start will fail if configured password requirements are not met.\");\n-        }\n+    public CouchbaseContainer withBucket(final BucketDefinition bucketDefinition) {\n+        checkNotRunning();\n+        this.buckets.add(bucketDefinition);\n+        return this;\n     }\n \n-    @Override\n-    @SneakyThrows\n-    protected void doStart() {\n-        startProxy(getNetworkAliases().get(0));\n-        try {\n-            super.doStart();\n-        } catch (Throwable e) {\n-            proxy.stop();\n-            throw e;\n-        }\n+    public CouchbaseContainer withEnabledServices(final CouchbaseService... enabled) {\n+        checkNotRunning();\n+        this.enabledServices = EnumSet.copyOf(Arrays.asList(enabled));\n+        return this;\n     }\n \n-    @SneakyThrows\n-    private void startProxy(String networkAlias) {\n-        proxy = new SocatContainer().withNetwork(getNetwork());\n-\n-        for (CouchbasePort port : CouchbasePort.values()) {\n-            if (port.isDynamic()) {\n-                proxy.withTarget(port.getOriginalPort(), networkAlias);\n-            } else {\n-                proxy.addExposedPort(port.getOriginalPort());\n-            }\n-        }\n-\n-        proxy.setWaitStrategy(null);\n-        proxy.start();\n-\n-        ExecCreateCmdResponse createCmdResponse = dockerClient\n-            .execCreateCmd(proxy.getContainerId())\n-            .withCmd(\n-                \"sh\",\n-                \"-c\",\n-                Stream.of(CouchbasePort.values())\n-                    .map(port -> {\n-                        return \"/usr/bin/socat \" +\n-                            \"TCP-LISTEN:\" + port.getOriginalPort() + \",fork,reuseaddr \" +\n-                            \"TCP:\" + networkAlias + \":\" + getMappedPort(port);\n-                    })\n-                    .collect(Collectors.joining(\" & \", \"true\", \"\"))\n-            )\n-            .exec();\n-\n-        dockerClient.execStartCmd(createCmdResponse.getId())\n-            .start()\n-            .awaitCompletion(10, TimeUnit.SECONDS);\n+    public final String getUsername() {\n+        return username;\n     }\n \n-    @Override\n-    public List<Integer> getExposedPorts() {\n-        return proxy.getExposedPorts();\n+    public final String getPassword() {\n+        return password;\n     }\n \n-    @Override\n-    public String getContainerIpAddress() {\n-        return proxy.getContainerIpAddress();\n+    public int getBootstrapCarrierDirectPort() {\n+        return getMappedPort(KV_PORT);\n     }\n \n-    @Override\n-    public Integer getMappedPort(int originalPort) {\n-        return proxy.getMappedPort(originalPort);\n+    public int getBootstrapHttpDirectPort() {\n+        return getMappedPort(MGMT_PORT);\n     }\n \n-    protected Integer getMappedPort(CouchbasePort port) {\n-        return getMappedPort(port.getOriginalPort());\n+    public String getConnectionString() {\n+        return String.format(\"couchbase://%s:%d\", getContainerIpAddress(), getBootstrapCarrierDirectPort());\n     }\n \n     @Override\n-    public List<Integer> getBoundPortNumbers() {\n-        return proxy.getBoundPortNumbers();\n-    }\n-\n-    @Override\n-    @SuppressWarnings({\"unchecked\", \"ConstantConditions\"})\n-    public void stop() {\n-        try {\n-            stopCluster();\n-            ((AtomicReference<Object>) (Object) couchbaseEnvironment).set(null);\n-            ((AtomicReference<Object>) (Object) couchbaseCluster).set(null);\n-        } finally {\n-            Stream.<Runnable>of(super::stop, proxy::stop).parallel().forEach(Runnable::run);\n+    protected void configure() {\n+        super.configure();\n+\n+        WaitAllStrategy waitStrategy = new WaitAllStrategy();\n+\n+        // Makes sure that all nodes in the cluster are healthy.\n+        waitStrategy = waitStrategy.withStrategy(\n+            new HttpWaitStrategy()\n+                .forPath(\"/pools/default\")\n+                .forPort(MGMT_PORT)\n+                .withBasicCredentials(username, password)\n+                .forStatusCode(200)\n+                .forResponsePredicate(response -> {\n+                    try {\n+                        return Optional.of(MAPPER.readTree(response))\n+                            .map(n -> n.at(\"/nodes/0/status\"))\n+                            .map(JsonNode::asText)\n+                            .map(\"healthy\"::equals)\n+                            .orElse(false);\n+                    } catch (IOException e) {\n+                        logger().error(\"Unable to parse response {}\", response);\n+                        return false;\n+                    }\n+                })\n+        );\n+\n+        if (enabledServices.contains(CouchbaseService.QUERY)) {\n+            waitStrategy = waitStrategy.withStrategy(\n+                new HttpWaitStrategy()\n+                    .forPath(\"/admin/ping\")\n+                    .forPort(QUERY_PORT)\n+                    .withBasicCredentials(username, password)\n+                    .forStatusCode(200)\n+            );\n         }\n-    }\n-\n-    private void stopCluster() {\n-        getCouchbaseCluster().disconnect();\n-        getCouchbaseEnvironment().shutdown();\n-    }\n-\n-    public CouchbaseContainer withNewBucket(BucketSettings bucketSettings) {\n-        newBuckets.add(new BucketAndUserSettings(bucketSettings));\n-        return self();\n-    }\n \n-    public CouchbaseContainer withNewBucket(BucketSettings bucketSettings, UserSettings userSettings) {\n-        newBuckets.add(new BucketAndUserSettings(bucketSettings, userSettings));\n-        return self();\n+        waitingFor(waitStrategy);\n     }\n \n-    @SneakyThrows\n-    public void initCluster() {\n-        urlBase = String.format(\"http://%s:%s\", getContainerIpAddress(), getMappedPort(REST));\n-        String poolURL = \"/pools/default\";\n-        String poolPayload = \"memoryQuota=\" + URLEncoder.encode(memoryQuota, \"UTF-8\") + \"&indexMemoryQuota=\" + URLEncoder.encode(indexMemoryQuota, \"UTF-8\");\n-\n-        String setupServicesURL = \"/node/controller/setupServices\";\n-        StringBuilder servicePayloadBuilder = new StringBuilder();\n-        if (keyValue) {\n-            servicePayloadBuilder.append(\"kv,\");\n-        }\n-        if (query) {\n-            servicePayloadBuilder.append(\"n1ql,\");\n-        }\n-        if (index) {\n-            servicePayloadBuilder.append(\"index,\");\n-        }\n-        if (fts) {\n-            servicePayloadBuilder.append(\"fts,\");\n+    @Override\n+    protected void containerIsStarting(final InspectContainerResponse containerInfo) {\n+        logger().debug(\"Couchbase container is starting, performing configuration.\");\n+\n+        waitUntilNodeIsOnline();\n+        renameNode();\n+        initializeServices();\n+        configureAdminUser();\n+        configureExternalPorts();\n+        if (enabledServices.contains(CouchbaseService.INDEX)) {\n+            configureIndexer();\n         }\n-        String setupServiceContent = \"services=\" + URLEncoder.encode(servicePayloadBuilder.toString(), \"UTF-8\");\n-\n-        String webSettingsURL = \"/settings/web\";\n-        String webSettingsContent = \"username=\" + URLEncoder.encode(clusterUsername, \"UTF-8\") + \"&password=\" + URLEncoder.encode(clusterPassword, \"UTF-8\") + \"&port=8091\";\n-\n-        callCouchbaseRestAPI(poolURL, poolPayload);\n-        callCouchbaseRestAPI(setupServicesURL, setupServiceContent);\n-        callCouchbaseRestAPI(webSettingsURL, webSettingsContent);\n-\n-        createNodeWaitStrategy().waitUntilReady(this);\n-        callCouchbaseRestAPI(\"/settings/indexes\", \"indexerThreads=0&logLevel=info&maxRollbackPoints=5&storageMode=memory_optimized\");\n     }\n \n-    @NotNull\n-    private HttpWaitStrategy createNodeWaitStrategy() {\n-        return new HttpWaitStrategy()\n-            .forPath(\"/pools/default/\")\n-            .withBasicCredentials(clusterUsername, clusterPassword)\n-            .forStatusCode(HTTP_OK)\n-            .forResponsePredicate(response -> {\n-                try {\n-                    return Optional.of(MAPPER.readTree(response))\n-                        .map(n -> n.at(\"/nodes/0/status\"))\n-                        .map(JsonNode::asText)\n-                        .map(\"healthy\"::equals)\n-                        .orElse(false);\n-                } catch (IOException e) {\n-                    logger().error(\"Unable to parse response {}\", response);\n-                    return false;\n-                }\n-            });\n-    }\n-\n-    public void createBucket(BucketSettings bucketSetting, UserSettings userSettings, boolean primaryIndex) {\n-        ClusterManager clusterManager = getCouchbaseCluster().clusterManager(clusterUsername, clusterPassword);\n-        // Insert Bucket\n-        BucketSettings bucketSettings = clusterManager.insertBucket(bucketSetting);\n-        try {\n-            // Insert Bucket user\n-            clusterManager.upsertUser(AuthDomain.LOCAL, bucketSetting.name(), userSettings);\n-        } catch (Exception e) {\n-            logger().warn(\"Unable to insert user '\" + bucketSetting.name() + \"', maybe you are using older version\");\n-        }\n-        if (index) {\n-            Bucket bucket = getCouchbaseCluster().openBucket(bucketSettings.name(), bucketSettings.password());\n-            new CouchbaseQueryServiceWaitStrategy(bucket).waitUntilReady(this);\n-            if (primaryIndex) {\n-                bucket.query(Index.createPrimaryIndex().on(bucketSetting.name()));\n+    @Override\n+    protected void containerIsStarted(InspectContainerResponse containerInfo) {\n+        createBuckets();\n+        logger().info(\"Couchbase container is ready! UI available at http://{}:{}\", getContainerIpAddress(), getMappedPort(MGMT_PORT));\n+    }\n+\n+    /**\n+     * Before we can start configuring the host, we need to wait until the cluster manager is listening.\n+     */\n+    private void waitUntilNodeIsOnline() {\n+        new HttpWaitStrategy()\n+            .forPort(MGMT_PORT)\n+            .forPath(\"/pools\")\n+            .forStatusCode(200)\n+            .waitUntilReady(this);\n+    }\n+\n+    /**\n+     * Rebinds/renames the internal hostname.\n+     * <p>\n+     * To make sure the internal hostname is different from the external (alternate) address and the SDK can pick it\n+     * up automatically, we bind the internal hostname to the internal IP address.\n+     */\n+    private void renameNode() {\n+        logger().debug(\"Renaming Couchbase Node from localhost to \" + getContainerIpAddress());\n+\n+        Response response = doHttpRequest(MGMT_PORT, \"/node/controller/rename\", \"POST\", new FormBody.Builder()\n+            .add(\"hostname\", getInternalIpAddress())\n+            .build(), false\n+        );\n+\n+        checkSuccessfulResponse(response, \"Could not rename couchbase node\");\n+    }\n+\n+    /**\n+     * Initializes services based on the configured enabled services.\n+     */\n+    private void initializeServices() {\n+        logger().debug(\"Initializing couchbase services on host: \" + enabledServices);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d1cf174c1e86e0991f0199e99079e9ab0d4b33c"}, "originalPosition": 450}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIzMTMwNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger().debug(\"Configuring couchbase admin user with username: \\\"\" + username + \"\\\"\");\n          \n          \n            \n                    logger().debug(\"Configuring couchbase admin user with username: \\\"{}\\\"\", username);", "url": "https://github.com/testcontainers/testcontainers-java/pull/2491#discussion_r407231306", "createdAt": "2020-04-12T17:51:49Z", "author": {"login": "kiview"}, "path": "modules/couchbase/src/main/java/org/testcontainers/couchbase/CouchbaseContainer.java", "diffHunk": "@@ -15,447 +15,424 @@\n  */\n package org.testcontainers.couchbase;\n \n-import com.couchbase.client.core.utils.Base64;\n-import com.couchbase.client.java.Bucket;\n-import com.couchbase.client.java.CouchbaseCluster;\n-import com.couchbase.client.java.cluster.*;\n-import com.couchbase.client.java.env.CouchbaseEnvironment;\n-import com.couchbase.client.java.env.DefaultCouchbaseEnvironment;\n-import com.couchbase.client.java.query.Index;\n import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.github.dockerjava.api.command.ExecCreateCmdResponse;\n import com.github.dockerjava.api.command.InspectContainerResponse;\n-import com.google.common.collect.Lists;\n-import lombok.*;\n-import org.apache.commons.compress.utils.Sets;\n-import org.apache.commons.io.IOUtils;\n-import org.jetbrains.annotations.NotNull;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import okhttp3.Credentials;\n+import okhttp3.FormBody;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n import org.testcontainers.containers.GenericContainer;\n-import org.testcontainers.containers.Network;\n-import org.testcontainers.containers.SocatContainer;\n import org.testcontainers.containers.wait.strategy.HttpWaitStrategy;\n-import org.testcontainers.images.builder.Transferable;\n-import org.testcontainers.utility.ThrowingFunction;\n+import org.testcontainers.containers.wait.strategy.WaitAllStrategy;\n \n-import java.io.DataOutputStream;\n import java.io.IOException;\n-import java.net.HttpURLConnection;\n-import java.net.URL;\n-import java.net.URLEncoder;\n-import java.nio.charset.StandardCharsets;\n-import java.util.*;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import static java.net.HttpURLConnection.HTTP_OK;\n-import static org.testcontainers.couchbase.CouchbaseContainer.CouchbasePort.*;\n \n /**\n- * Based on Laurent Doguin version,\n+ * The couchbase container initializes and configures a Couchbase Server single node cluster.\n  * <p>\n- * optimized by Tayeb Chlyah\n+ * Note that it does not depend on a specific couchbase SDK, so it can be used with both the Java SDK 2 and 3 as well\n+ * as the Scala SDK 1 or newer. We recommend using the latest and greatest SDKs for the best experience.\n  */\n-@AllArgsConstructor\n public class CouchbaseContainer extends GenericContainer<CouchbaseContainer> {\n \n-    public static final String VERSION = \"5.5.1\";\n-    public static final String DOCKER_IMAGE_NAME = \"couchbase/server:\";\n-    public static final ObjectMapper MAPPER = new ObjectMapper();\n-    public static final String STATIC_CONFIG = \"/opt/couchbase/etc/couchbase/static_config\";\n-    public static final String CAPI_CONFIG = \"/opt/couchbase/etc/couchdb/default.d/capi.ini\";\n+    private static final int MGMT_PORT = 8091;\n+\n+    private static final int MGMT_SSL_PORT = 18091;\n+\n+    private static final int VIEW_PORT = 8092;\n \n-    private static final int REQUIRED_DEFAULT_PASSWORD_LENGTH = 6;\n+    private static final int VIEW_SSL_PORT = 18092;\n \n-    private String memoryQuota = \"300\";\n+    private static final int QUERY_PORT = 8093;\n \n-    private String indexMemoryQuota = \"300\";\n+    private static final int QUERY_SSL_PORT = 18093;\n \n-    private String clusterUsername = \"Administrator\";\n+    private static final int SEARCH_PORT = 8094;\n \n-    private String clusterPassword = \"password\";\n+    private static final int SEARCH_SSL_PORT = 18094;\n \n-    private boolean keyValue = true;\n+    private static final int KV_PORT = 11210;\n \n-    @Getter\n-    private boolean query = true;\n+    private static final int KV_SSL_PORT = 11207;\n \n-    @Getter\n-    private boolean index = true;\n+    private static final String DOCKER_IMAGE_NAME = \"couchbase/server\";\n \n-    @Getter\n-    private boolean primaryIndex = true;\n+    private static final String VERSION = \"6.5.0\";\n \n-    @Getter\n-    private boolean fts = false;\n+    private static final ObjectMapper MAPPER = new ObjectMapper();\n \n-    @Getter(lazy = true)\n-    private final CouchbaseEnvironment couchbaseEnvironment = createCouchbaseEnvironment();\n+    private static final OkHttpClient HTTP_CLIENT = new OkHttpClient();\n \n-    @Getter(lazy = true)\n-    private final CouchbaseCluster couchbaseCluster = createCouchbaseCluster();\n+    private String username = \"Administrator\";\n \n-    private List<BucketAndUserSettings> newBuckets = new ArrayList<>();\n+    private String password = \"password\";\n \n-    private String urlBase;\n+    private Set<CouchbaseService> enabledServices = EnumSet.allOf(CouchbaseService.class);\n \n-    private SocatContainer proxy;\n+    private final List<BucketDefinition> buckets = new ArrayList<>();\n \n+    /**\n+     * Creates a new couchbase container with the default image and version.\n+     */\n     public CouchbaseContainer() {\n-        this(DOCKER_IMAGE_NAME + VERSION);\n+        this(DOCKER_IMAGE_NAME + \":\" + VERSION);\n     }\n \n-    public CouchbaseContainer(String imageName) {\n+    /**\n+     * Creates a new couchbase container with a custom image name.\n+     *\n+     * @param imageName the image name that should be used.\n+     */\n+    public CouchbaseContainer(final String imageName) {\n         super(imageName);\n-\n-        withNetwork(Network.SHARED);\n-        setWaitStrategy(new HttpWaitStrategy().forPath(\"/ui/index.html\"));\n     }\n \n-    @Override\n-    public Set<Integer> getLivenessCheckPortNumbers() {\n-        return Sets.newHashSet(getMappedPort(REST));\n+    /**\n+     * Set custom username and password for the admin user.\n+     *\n+     * @param username the admin username to use.\n+     * @param password the password for the admin user.\n+     * @return this {@link CouchbaseContainer} for chaining purposes.\n+     */\n+    public CouchbaseContainer withCredentials(final String username, final String password) {\n+        checkNotRunning();\n+        this.username = username;\n+        this.password = password;\n+        return this;\n     }\n \n-    @Override\n-    protected void configure() {\n-        if (clusterPassword.length() < REQUIRED_DEFAULT_PASSWORD_LENGTH) {\n-            logger().warn(\"The provided cluster admin password length is less then the default password policy length. \" +\n-                \"Cluster start will fail if configured password requirements are not met.\");\n-        }\n+    public CouchbaseContainer withBucket(final BucketDefinition bucketDefinition) {\n+        checkNotRunning();\n+        this.buckets.add(bucketDefinition);\n+        return this;\n     }\n \n-    @Override\n-    @SneakyThrows\n-    protected void doStart() {\n-        startProxy(getNetworkAliases().get(0));\n-        try {\n-            super.doStart();\n-        } catch (Throwable e) {\n-            proxy.stop();\n-            throw e;\n-        }\n+    public CouchbaseContainer withEnabledServices(final CouchbaseService... enabled) {\n+        checkNotRunning();\n+        this.enabledServices = EnumSet.copyOf(Arrays.asList(enabled));\n+        return this;\n     }\n \n-    @SneakyThrows\n-    private void startProxy(String networkAlias) {\n-        proxy = new SocatContainer().withNetwork(getNetwork());\n-\n-        for (CouchbasePort port : CouchbasePort.values()) {\n-            if (port.isDynamic()) {\n-                proxy.withTarget(port.getOriginalPort(), networkAlias);\n-            } else {\n-                proxy.addExposedPort(port.getOriginalPort());\n-            }\n-        }\n-\n-        proxy.setWaitStrategy(null);\n-        proxy.start();\n-\n-        ExecCreateCmdResponse createCmdResponse = dockerClient\n-            .execCreateCmd(proxy.getContainerId())\n-            .withCmd(\n-                \"sh\",\n-                \"-c\",\n-                Stream.of(CouchbasePort.values())\n-                    .map(port -> {\n-                        return \"/usr/bin/socat \" +\n-                            \"TCP-LISTEN:\" + port.getOriginalPort() + \",fork,reuseaddr \" +\n-                            \"TCP:\" + networkAlias + \":\" + getMappedPort(port);\n-                    })\n-                    .collect(Collectors.joining(\" & \", \"true\", \"\"))\n-            )\n-            .exec();\n-\n-        dockerClient.execStartCmd(createCmdResponse.getId())\n-            .start()\n-            .awaitCompletion(10, TimeUnit.SECONDS);\n+    public final String getUsername() {\n+        return username;\n     }\n \n-    @Override\n-    public List<Integer> getExposedPorts() {\n-        return proxy.getExposedPorts();\n+    public final String getPassword() {\n+        return password;\n     }\n \n-    @Override\n-    public String getContainerIpAddress() {\n-        return proxy.getContainerIpAddress();\n+    public int getBootstrapCarrierDirectPort() {\n+        return getMappedPort(KV_PORT);\n     }\n \n-    @Override\n-    public Integer getMappedPort(int originalPort) {\n-        return proxy.getMappedPort(originalPort);\n+    public int getBootstrapHttpDirectPort() {\n+        return getMappedPort(MGMT_PORT);\n     }\n \n-    protected Integer getMappedPort(CouchbasePort port) {\n-        return getMappedPort(port.getOriginalPort());\n+    public String getConnectionString() {\n+        return String.format(\"couchbase://%s:%d\", getContainerIpAddress(), getBootstrapCarrierDirectPort());\n     }\n \n     @Override\n-    public List<Integer> getBoundPortNumbers() {\n-        return proxy.getBoundPortNumbers();\n-    }\n-\n-    @Override\n-    @SuppressWarnings({\"unchecked\", \"ConstantConditions\"})\n-    public void stop() {\n-        try {\n-            stopCluster();\n-            ((AtomicReference<Object>) (Object) couchbaseEnvironment).set(null);\n-            ((AtomicReference<Object>) (Object) couchbaseCluster).set(null);\n-        } finally {\n-            Stream.<Runnable>of(super::stop, proxy::stop).parallel().forEach(Runnable::run);\n+    protected void configure() {\n+        super.configure();\n+\n+        WaitAllStrategy waitStrategy = new WaitAllStrategy();\n+\n+        // Makes sure that all nodes in the cluster are healthy.\n+        waitStrategy = waitStrategy.withStrategy(\n+            new HttpWaitStrategy()\n+                .forPath(\"/pools/default\")\n+                .forPort(MGMT_PORT)\n+                .withBasicCredentials(username, password)\n+                .forStatusCode(200)\n+                .forResponsePredicate(response -> {\n+                    try {\n+                        return Optional.of(MAPPER.readTree(response))\n+                            .map(n -> n.at(\"/nodes/0/status\"))\n+                            .map(JsonNode::asText)\n+                            .map(\"healthy\"::equals)\n+                            .orElse(false);\n+                    } catch (IOException e) {\n+                        logger().error(\"Unable to parse response {}\", response);\n+                        return false;\n+                    }\n+                })\n+        );\n+\n+        if (enabledServices.contains(CouchbaseService.QUERY)) {\n+            waitStrategy = waitStrategy.withStrategy(\n+                new HttpWaitStrategy()\n+                    .forPath(\"/admin/ping\")\n+                    .forPort(QUERY_PORT)\n+                    .withBasicCredentials(username, password)\n+                    .forStatusCode(200)\n+            );\n         }\n-    }\n-\n-    private void stopCluster() {\n-        getCouchbaseCluster().disconnect();\n-        getCouchbaseEnvironment().shutdown();\n-    }\n-\n-    public CouchbaseContainer withNewBucket(BucketSettings bucketSettings) {\n-        newBuckets.add(new BucketAndUserSettings(bucketSettings));\n-        return self();\n-    }\n \n-    public CouchbaseContainer withNewBucket(BucketSettings bucketSettings, UserSettings userSettings) {\n-        newBuckets.add(new BucketAndUserSettings(bucketSettings, userSettings));\n-        return self();\n+        waitingFor(waitStrategy);\n     }\n \n-    @SneakyThrows\n-    public void initCluster() {\n-        urlBase = String.format(\"http://%s:%s\", getContainerIpAddress(), getMappedPort(REST));\n-        String poolURL = \"/pools/default\";\n-        String poolPayload = \"memoryQuota=\" + URLEncoder.encode(memoryQuota, \"UTF-8\") + \"&indexMemoryQuota=\" + URLEncoder.encode(indexMemoryQuota, \"UTF-8\");\n-\n-        String setupServicesURL = \"/node/controller/setupServices\";\n-        StringBuilder servicePayloadBuilder = new StringBuilder();\n-        if (keyValue) {\n-            servicePayloadBuilder.append(\"kv,\");\n-        }\n-        if (query) {\n-            servicePayloadBuilder.append(\"n1ql,\");\n-        }\n-        if (index) {\n-            servicePayloadBuilder.append(\"index,\");\n-        }\n-        if (fts) {\n-            servicePayloadBuilder.append(\"fts,\");\n+    @Override\n+    protected void containerIsStarting(final InspectContainerResponse containerInfo) {\n+        logger().debug(\"Couchbase container is starting, performing configuration.\");\n+\n+        waitUntilNodeIsOnline();\n+        renameNode();\n+        initializeServices();\n+        configureAdminUser();\n+        configureExternalPorts();\n+        if (enabledServices.contains(CouchbaseService.INDEX)) {\n+            configureIndexer();\n         }\n-        String setupServiceContent = \"services=\" + URLEncoder.encode(servicePayloadBuilder.toString(), \"UTF-8\");\n-\n-        String webSettingsURL = \"/settings/web\";\n-        String webSettingsContent = \"username=\" + URLEncoder.encode(clusterUsername, \"UTF-8\") + \"&password=\" + URLEncoder.encode(clusterPassword, \"UTF-8\") + \"&port=8091\";\n-\n-        callCouchbaseRestAPI(poolURL, poolPayload);\n-        callCouchbaseRestAPI(setupServicesURL, setupServiceContent);\n-        callCouchbaseRestAPI(webSettingsURL, webSettingsContent);\n-\n-        createNodeWaitStrategy().waitUntilReady(this);\n-        callCouchbaseRestAPI(\"/settings/indexes\", \"indexerThreads=0&logLevel=info&maxRollbackPoints=5&storageMode=memory_optimized\");\n     }\n \n-    @NotNull\n-    private HttpWaitStrategy createNodeWaitStrategy() {\n-        return new HttpWaitStrategy()\n-            .forPath(\"/pools/default/\")\n-            .withBasicCredentials(clusterUsername, clusterPassword)\n-            .forStatusCode(HTTP_OK)\n-            .forResponsePredicate(response -> {\n-                try {\n-                    return Optional.of(MAPPER.readTree(response))\n-                        .map(n -> n.at(\"/nodes/0/status\"))\n-                        .map(JsonNode::asText)\n-                        .map(\"healthy\"::equals)\n-                        .orElse(false);\n-                } catch (IOException e) {\n-                    logger().error(\"Unable to parse response {}\", response);\n-                    return false;\n-                }\n-            });\n-    }\n-\n-    public void createBucket(BucketSettings bucketSetting, UserSettings userSettings, boolean primaryIndex) {\n-        ClusterManager clusterManager = getCouchbaseCluster().clusterManager(clusterUsername, clusterPassword);\n-        // Insert Bucket\n-        BucketSettings bucketSettings = clusterManager.insertBucket(bucketSetting);\n-        try {\n-            // Insert Bucket user\n-            clusterManager.upsertUser(AuthDomain.LOCAL, bucketSetting.name(), userSettings);\n-        } catch (Exception e) {\n-            logger().warn(\"Unable to insert user '\" + bucketSetting.name() + \"', maybe you are using older version\");\n-        }\n-        if (index) {\n-            Bucket bucket = getCouchbaseCluster().openBucket(bucketSettings.name(), bucketSettings.password());\n-            new CouchbaseQueryServiceWaitStrategy(bucket).waitUntilReady(this);\n-            if (primaryIndex) {\n-                bucket.query(Index.createPrimaryIndex().on(bucketSetting.name()));\n+    @Override\n+    protected void containerIsStarted(InspectContainerResponse containerInfo) {\n+        createBuckets();\n+        logger().info(\"Couchbase container is ready! UI available at http://{}:{}\", getContainerIpAddress(), getMappedPort(MGMT_PORT));\n+    }\n+\n+    /**\n+     * Before we can start configuring the host, we need to wait until the cluster manager is listening.\n+     */\n+    private void waitUntilNodeIsOnline() {\n+        new HttpWaitStrategy()\n+            .forPort(MGMT_PORT)\n+            .forPath(\"/pools\")\n+            .forStatusCode(200)\n+            .waitUntilReady(this);\n+    }\n+\n+    /**\n+     * Rebinds/renames the internal hostname.\n+     * <p>\n+     * To make sure the internal hostname is different from the external (alternate) address and the SDK can pick it\n+     * up automatically, we bind the internal hostname to the internal IP address.\n+     */\n+    private void renameNode() {\n+        logger().debug(\"Renaming Couchbase Node from localhost to \" + getContainerIpAddress());\n+\n+        Response response = doHttpRequest(MGMT_PORT, \"/node/controller/rename\", \"POST\", new FormBody.Builder()\n+            .add(\"hostname\", getInternalIpAddress())\n+            .build(), false\n+        );\n+\n+        checkSuccessfulResponse(response, \"Could not rename couchbase node\");\n+    }\n+\n+    /**\n+     * Initializes services based on the configured enabled services.\n+     */\n+    private void initializeServices() {\n+        logger().debug(\"Initializing couchbase services on host: \" + enabledServices);\n+\n+        final String services = enabledServices.stream().map(s -> {\n+            switch (s) {\n+                case KV: return \"kv\";\n+                case QUERY: return \"n1ql\";\n+                case INDEX: return \"index\";\n+                case SEARCH: return \"fts\";\n+                default: throw new IllegalStateException(\"Unknown service!\");\n             }\n+        }).collect(Collectors.joining(\",\"));\n+\n+        Response response = doHttpRequest(MGMT_PORT, \"/node/controller/setupServices\", \"POST\", new FormBody.Builder()\n+            .add(\"services\", services)\n+            .build(), false\n+        );\n+\n+        checkSuccessfulResponse(response, \"Could not enable couchbase services\");\n+    }\n+\n+    /**\n+     * Configures the admin user on the couchbase node.\n+     * <p>\n+     * After this stage, all subsequent API calls need to have the basic auth header set.\n+     */\n+    private void configureAdminUser() {\n+        logger().debug(\"Configuring couchbase admin user with username: \\\"\" + username + \"\\\"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d1cf174c1e86e0991f0199e99079e9ab0d4b33c"}, "originalPosition": 476}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "81def1d3a4b759111e61b9870de3655350e363f8", "author": {"user": {"login": "bsideup", "name": "Sergei Egorov"}}, "url": "https://github.com/testcontainers/testcontainers-java/commit/81def1d3a4b759111e61b9870de3655350e363f8", "committedDate": "2020-04-12T17:58:02Z", "message": "Apply suggestions from code review\n\nCo-Authored-By: Kevin Wittek <kiview@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "10f9e9d081dfee81e855cb15232ba76fa925a31f", "author": {"user": {"login": "bsideup", "name": "Sergei Egorov"}}, "url": "https://github.com/testcontainers/testcontainers-java/commit/10f9e9d081dfee81e855cb15232ba76fa925a31f", "committedDate": "2020-04-12T18:12:42Z", "message": "Update docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "067f4d8abf78b8c862be985287f573debafbe7b0", "author": {"user": {"login": "bsideup", "name": "Sergei Egorov"}}, "url": "https://github.com/testcontainers/testcontainers-java/commit/067f4d8abf78b8c862be985287f573debafbe7b0", "committedDate": "2020-04-12T18:20:13Z", "message": "Update docs (2)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxODgzMzAz", "url": "https://github.com/testcontainers/testcontainers-java/pull/2491#pullrequestreview-391883303", "createdAt": "2020-04-12T18:22:56Z", "commit": {"oid": "067f4d8abf78b8c862be985287f573debafbe7b0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3381, "cost": 1, "resetAt": "2021-11-02T12:20:56Z"}}}