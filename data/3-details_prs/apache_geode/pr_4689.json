{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzczOTYxMTYy", "number": 4689, "title": "GEODE-7684: Create messaging for PR Clear", "bodyText": "Thank you for submitting a contribution to Apache Geode.\nIn order to streamline the review of the contribution we ask you\nto ensure the following steps have been taken:\nFor all changes:\n\n\n Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?\n\n\n Has your PR been rebased against the latest commit within the target branch (typically develop)?\n\n\n Is your initial contribution a single, squashed commit?\n\n\n Does gradlew build run cleanly?\n\n\n Have you written or updated unit tests to verify your changes?\n\n\n If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under ASF 2.0?\n\n\nNote:\nPlease ensure that once the PR is submitted, check Concourse for build issues and\nsubmit an update to your PR as soon as possible. If you need help, please send an\nemail to dev@geode.apache.org.", "createdAt": "2020-02-11T23:12:57Z", "url": "https://github.com/apache/geode/pull/4689", "merged": true, "mergeCommit": {"oid": "dbe59ece4749d07cdb65d7878a1472703e81c68c"}, "closed": true, "closedAt": "2020-02-13T22:40:43Z", "author": {"login": "BenjaminPerryRoss"}, "timelineItems": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcDa0bRgBqjMwMjg3NDQ1NjY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcECvtXAFqTM1ODYwMDg5OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0ff472d95d7f8d5b1ef3f8d56d034ce7f8dd4cfc", "author": {"user": {"login": "BenjaminPerryRoss", "name": null}}, "url": "https://github.com/apache/geode/commit/0ff472d95d7f8d5b1ef3f8d56d034ce7f8dd4cfc", "committedDate": "2020-02-11T23:11:41Z", "message": "Disabled transactions for PR Clear Message\n\nCo-authored-by: Benjamin Ross <bross@pivotal.io>\nCo-authored-by: Donal Evans <doevans@pivotal.io>"}, "afterCommit": {"oid": "31f29ae77edaab636b0f57129c6ebce2c6b38e1a", "author": {"user": {"login": "BenjaminPerryRoss", "name": null}}, "url": "https://github.com/apache/geode/commit/31f29ae77edaab636b0f57129c6ebce2c6b38e1a", "committedDate": "2020-02-12T00:02:03Z", "message": "Made correct cmnClearRegion method public\n\nCo-authored-by: Benjamin Ross <bross@pivotal.io>\nCo-authored-by: Donal Evans <doevans@pivotal.io>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3MTE4Njcx", "url": "https://github.com/apache/geode/pull/4689#pullrequestreview-357118671", "createdAt": "2020-02-12T00:35:45Z", "commit": {"oid": "31f29ae77edaab636b0f57129c6ebce2c6b38e1a"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwMDozNTo0NlrOFoeLRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwMToyMjo0M1rOFoe72Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk4MTc2NQ==", "bodyText": "This is currently never used, so unless it's going to be needed for the API story, it should probably be removed.", "url": "https://github.com/apache/geode/pull/4689#discussion_r377981765", "createdAt": "2020-02-12T00:35:46Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/partitioned/ClearPRMessage.java", "diffHunk": "@@ -0,0 +1,405 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.cache.partitioned;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.Logger;\n+\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.cache.CacheException;\n+import org.apache.geode.cache.EntryExistsException;\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DirectReplyProcessor;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplyMessage;\n+import org.apache.geode.distributed.internal.ReplyProcessor21;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.Assert;\n+import org.apache.geode.internal.InternalDataSerializer;\n+import org.apache.geode.internal.NanoTimer;\n+import org.apache.geode.internal.cache.BucketRegion;\n+import org.apache.geode.internal.cache.DataLocationException;\n+import org.apache.geode.internal.cache.EventID;\n+import org.apache.geode.internal.cache.ForceReattemptException;\n+import org.apache.geode.internal.cache.PartitionedRegion;\n+import org.apache.geode.internal.cache.PartitionedRegionException;\n+import org.apache.geode.internal.cache.PartitionedRegionHelper;\n+import org.apache.geode.internal.cache.RegionEventImpl;\n+import org.apache.geode.internal.logging.log4j.LogMarker;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class ClearPRMessage extends PartitionMessageWithDirectReply {\n+  private static final Logger logger = LogService.getLogger();\n+\n+  private RegionEventImpl regionEvent;\n+\n+  private Integer bucketId;\n+\n+  private Object callbackArg;\n+\n+  /** The time in ms to wait for a lock to be obtained during doLocalClear() */\n+  public static final int LOCK_WAIT_TIMEOUT_MS = 100;\n+  public static final String BUCKET_NON_PRIMARY_MESSAGE =\n+      \"The bucket region on target member is no longer primary\";\n+  public static final String BUCKET_REGION_LOCK_UNAVAILABLE_MESSAGE =\n+      \"A lock for the bucket region could not be obtained.\";\n+\n+  protected static final short HAS_BRIDGE_CONTEXT = UNRESERVED_FLAGS_START;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31f29ae77edaab636b0f57129c6ebce2c6b38e1a"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk4MjE3Mw==", "bodyText": "This is set in the constructor and used in toData() and fromData() but other than that it's never accessed or modified, so it can probably be removed.", "url": "https://github.com/apache/geode/pull/4689#discussion_r377982173", "createdAt": "2020-02-12T00:37:12Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/partitioned/ClearPRMessage.java", "diffHunk": "@@ -0,0 +1,405 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.cache.partitioned;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.Logger;\n+\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.cache.CacheException;\n+import org.apache.geode.cache.EntryExistsException;\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DirectReplyProcessor;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplyMessage;\n+import org.apache.geode.distributed.internal.ReplyProcessor21;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.Assert;\n+import org.apache.geode.internal.InternalDataSerializer;\n+import org.apache.geode.internal.NanoTimer;\n+import org.apache.geode.internal.cache.BucketRegion;\n+import org.apache.geode.internal.cache.DataLocationException;\n+import org.apache.geode.internal.cache.EventID;\n+import org.apache.geode.internal.cache.ForceReattemptException;\n+import org.apache.geode.internal.cache.PartitionedRegion;\n+import org.apache.geode.internal.cache.PartitionedRegionException;\n+import org.apache.geode.internal.cache.PartitionedRegionHelper;\n+import org.apache.geode.internal.cache.RegionEventImpl;\n+import org.apache.geode.internal.logging.log4j.LogMarker;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class ClearPRMessage extends PartitionMessageWithDirectReply {\n+  private static final Logger logger = LogService.getLogger();\n+\n+  private RegionEventImpl regionEvent;\n+\n+  private Integer bucketId;\n+\n+  private Object callbackArg;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31f29ae77edaab636b0f57129c6ebce2c6b38e1a"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk4MzEwNw==", "bodyText": "This value is never used or modified by this class, so it can probably be removed.", "url": "https://github.com/apache/geode/pull/4689#discussion_r377983107", "createdAt": "2020-02-12T00:40:36Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/partitioned/ClearPRMessage.java", "diffHunk": "@@ -0,0 +1,405 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.cache.partitioned;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.Logger;\n+\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.cache.CacheException;\n+import org.apache.geode.cache.EntryExistsException;\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DirectReplyProcessor;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplyMessage;\n+import org.apache.geode.distributed.internal.ReplyProcessor21;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.Assert;\n+import org.apache.geode.internal.InternalDataSerializer;\n+import org.apache.geode.internal.NanoTimer;\n+import org.apache.geode.internal.cache.BucketRegion;\n+import org.apache.geode.internal.cache.DataLocationException;\n+import org.apache.geode.internal.cache.EventID;\n+import org.apache.geode.internal.cache.ForceReattemptException;\n+import org.apache.geode.internal.cache.PartitionedRegion;\n+import org.apache.geode.internal.cache.PartitionedRegionException;\n+import org.apache.geode.internal.cache.PartitionedRegionHelper;\n+import org.apache.geode.internal.cache.RegionEventImpl;\n+import org.apache.geode.internal.logging.log4j.LogMarker;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class ClearPRMessage extends PartitionMessageWithDirectReply {\n+  private static final Logger logger = LogService.getLogger();\n+\n+  private RegionEventImpl regionEvent;\n+\n+  private Integer bucketId;\n+\n+  private Object callbackArg;\n+\n+  /** The time in ms to wait for a lock to be obtained during doLocalClear() */\n+  public static final int LOCK_WAIT_TIMEOUT_MS = 100;\n+  public static final String BUCKET_NON_PRIMARY_MESSAGE =\n+      \"The bucket region on target member is no longer primary\";\n+  public static final String BUCKET_REGION_LOCK_UNAVAILABLE_MESSAGE =\n+      \"A lock for the bucket region could not be obtained.\";\n+\n+  protected static final short HAS_BRIDGE_CONTEXT = UNRESERVED_FLAGS_START;\n+\n+  /**\n+   * state from operateOnRegion that must be preserved for transmission from the waiting pool\n+   */\n+  transient boolean result = false;\n+\n+  /**\n+   * Empty constructor to satisfy {@link DataSerializer}requirements\n+   */\n+  public ClearPRMessage() {}\n+\n+  public ClearPRMessage(int bucketId, boolean notificationOnly, boolean posDup,\n+      Object callbackArg) {\n+    this.bucketId = bucketId;\n+    this.notificationOnly = notificationOnly;\n+    this.posDup = posDup;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31f29ae77edaab636b0f57129c6ebce2c6b38e1a"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk4NDQ2NA==", "bodyText": "We set this value in the constructor and in the initMessage() method, but it's never used in this class, so it can probably be removed.", "url": "https://github.com/apache/geode/pull/4689#discussion_r377984464", "createdAt": "2020-02-12T00:45:15Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/partitioned/ClearPRMessage.java", "diffHunk": "@@ -0,0 +1,405 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.cache.partitioned;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.Logger;\n+\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.cache.CacheException;\n+import org.apache.geode.cache.EntryExistsException;\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DirectReplyProcessor;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplyMessage;\n+import org.apache.geode.distributed.internal.ReplyProcessor21;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.Assert;\n+import org.apache.geode.internal.InternalDataSerializer;\n+import org.apache.geode.internal.NanoTimer;\n+import org.apache.geode.internal.cache.BucketRegion;\n+import org.apache.geode.internal.cache.DataLocationException;\n+import org.apache.geode.internal.cache.EventID;\n+import org.apache.geode.internal.cache.ForceReattemptException;\n+import org.apache.geode.internal.cache.PartitionedRegion;\n+import org.apache.geode.internal.cache.PartitionedRegionException;\n+import org.apache.geode.internal.cache.PartitionedRegionHelper;\n+import org.apache.geode.internal.cache.RegionEventImpl;\n+import org.apache.geode.internal.logging.log4j.LogMarker;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class ClearPRMessage extends PartitionMessageWithDirectReply {\n+  private static final Logger logger = LogService.getLogger();\n+\n+  private RegionEventImpl regionEvent;\n+\n+  private Integer bucketId;\n+\n+  private Object callbackArg;\n+\n+  /** The time in ms to wait for a lock to be obtained during doLocalClear() */\n+  public static final int LOCK_WAIT_TIMEOUT_MS = 100;\n+  public static final String BUCKET_NON_PRIMARY_MESSAGE =\n+      \"The bucket region on target member is no longer primary\";\n+  public static final String BUCKET_REGION_LOCK_UNAVAILABLE_MESSAGE =\n+      \"A lock for the bucket region could not be obtained.\";\n+\n+  protected static final short HAS_BRIDGE_CONTEXT = UNRESERVED_FLAGS_START;\n+\n+  /**\n+   * state from operateOnRegion that must be preserved for transmission from the waiting pool\n+   */\n+  transient boolean result = false;\n+\n+  /**\n+   * Empty constructor to satisfy {@link DataSerializer}requirements\n+   */\n+  public ClearPRMessage() {}\n+\n+  public ClearPRMessage(int bucketId, boolean notificationOnly, boolean posDup,\n+      Object callbackArg) {\n+    this.bucketId = bucketId;\n+    this.notificationOnly = notificationOnly;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31f29ae77edaab636b0f57129c6ebce2c6b38e1a"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk4NDgxMg==", "bodyText": "This method is never used, and neither is posDup in this class, so it can probably be removed.", "url": "https://github.com/apache/geode/pull/4689#discussion_r377984812", "createdAt": "2020-02-12T00:46:24Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/partitioned/ClearPRMessage.java", "diffHunk": "@@ -0,0 +1,405 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.cache.partitioned;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.Logger;\n+\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.cache.CacheException;\n+import org.apache.geode.cache.EntryExistsException;\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DirectReplyProcessor;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplyMessage;\n+import org.apache.geode.distributed.internal.ReplyProcessor21;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.Assert;\n+import org.apache.geode.internal.InternalDataSerializer;\n+import org.apache.geode.internal.NanoTimer;\n+import org.apache.geode.internal.cache.BucketRegion;\n+import org.apache.geode.internal.cache.DataLocationException;\n+import org.apache.geode.internal.cache.EventID;\n+import org.apache.geode.internal.cache.ForceReattemptException;\n+import org.apache.geode.internal.cache.PartitionedRegion;\n+import org.apache.geode.internal.cache.PartitionedRegionException;\n+import org.apache.geode.internal.cache.PartitionedRegionHelper;\n+import org.apache.geode.internal.cache.RegionEventImpl;\n+import org.apache.geode.internal.logging.log4j.LogMarker;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class ClearPRMessage extends PartitionMessageWithDirectReply {\n+  private static final Logger logger = LogService.getLogger();\n+\n+  private RegionEventImpl regionEvent;\n+\n+  private Integer bucketId;\n+\n+  private Object callbackArg;\n+\n+  /** The time in ms to wait for a lock to be obtained during doLocalClear() */\n+  public static final int LOCK_WAIT_TIMEOUT_MS = 100;\n+  public static final String BUCKET_NON_PRIMARY_MESSAGE =\n+      \"The bucket region on target member is no longer primary\";\n+  public static final String BUCKET_REGION_LOCK_UNAVAILABLE_MESSAGE =\n+      \"A lock for the bucket region could not be obtained.\";\n+\n+  protected static final short HAS_BRIDGE_CONTEXT = UNRESERVED_FLAGS_START;\n+\n+  /**\n+   * state from operateOnRegion that must be preserved for transmission from the waiting pool\n+   */\n+  transient boolean result = false;\n+\n+  /**\n+   * Empty constructor to satisfy {@link DataSerializer}requirements\n+   */\n+  public ClearPRMessage() {}\n+\n+  public ClearPRMessage(int bucketId, boolean notificationOnly, boolean posDup,\n+      Object callbackArg) {\n+    this.bucketId = bucketId;\n+    this.notificationOnly = notificationOnly;\n+    this.posDup = posDup;\n+    this.callbackArg = callbackArg;\n+    initTxMemberId();\n+  }\n+\n+  public void setEventId(RegionEventImpl event) {\n+    regionEvent = event;\n+  }\n+\n+  public void initMessage(PartitionedRegion region, Set<InternalDistributedMember> recipients,\n+      boolean notifyOnly, DirectReplyProcessor replyProcessor) {\n+    this.resetRecipients();\n+    if (recipients != null) {\n+      setRecipients(recipients);\n+    }\n+    this.regionId = region.getPRId();\n+    this.processor = replyProcessor;\n+    this.processorId = replyProcessor == null ? 0 : replyProcessor.getProcessorId();\n+    if (replyProcessor != null && this.isSevereAlertCompatible()) {\n+      replyProcessor.enableSevereAlertProcessing();\n+    }\n+    this.notificationOnly = notifyOnly;\n+  }\n+\n+  @Override\n+  public boolean isSevereAlertCompatible() {\n+    // allow forced-disconnect processing for all cache op messages\n+    return true;\n+  }\n+\n+  public void setPossibleDuplicate(boolean posDup) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31f29ae77edaab636b0f57129c6ebce2c6b38e1a"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk4NTQ4MQ==", "bodyText": "Remove comment.", "url": "https://github.com/apache/geode/pull/4689#discussion_r377985481", "createdAt": "2020-02-12T00:48:46Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/partitioned/ClearPRMessage.java", "diffHunk": "@@ -0,0 +1,405 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.cache.partitioned;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.Logger;\n+\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.cache.CacheException;\n+import org.apache.geode.cache.EntryExistsException;\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DirectReplyProcessor;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplyMessage;\n+import org.apache.geode.distributed.internal.ReplyProcessor21;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.Assert;\n+import org.apache.geode.internal.InternalDataSerializer;\n+import org.apache.geode.internal.NanoTimer;\n+import org.apache.geode.internal.cache.BucketRegion;\n+import org.apache.geode.internal.cache.DataLocationException;\n+import org.apache.geode.internal.cache.EventID;\n+import org.apache.geode.internal.cache.ForceReattemptException;\n+import org.apache.geode.internal.cache.PartitionedRegion;\n+import org.apache.geode.internal.cache.PartitionedRegionException;\n+import org.apache.geode.internal.cache.PartitionedRegionHelper;\n+import org.apache.geode.internal.cache.RegionEventImpl;\n+import org.apache.geode.internal.logging.log4j.LogMarker;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class ClearPRMessage extends PartitionMessageWithDirectReply {\n+  private static final Logger logger = LogService.getLogger();\n+\n+  private RegionEventImpl regionEvent;\n+\n+  private Integer bucketId;\n+\n+  private Object callbackArg;\n+\n+  /** The time in ms to wait for a lock to be obtained during doLocalClear() */\n+  public static final int LOCK_WAIT_TIMEOUT_MS = 100;\n+  public static final String BUCKET_NON_PRIMARY_MESSAGE =\n+      \"The bucket region on target member is no longer primary\";\n+  public static final String BUCKET_REGION_LOCK_UNAVAILABLE_MESSAGE =\n+      \"A lock for the bucket region could not be obtained.\";\n+\n+  protected static final short HAS_BRIDGE_CONTEXT = UNRESERVED_FLAGS_START;\n+\n+  /**\n+   * state from operateOnRegion that must be preserved for transmission from the waiting pool\n+   */\n+  transient boolean result = false;\n+\n+  /**\n+   * Empty constructor to satisfy {@link DataSerializer}requirements\n+   */\n+  public ClearPRMessage() {}\n+\n+  public ClearPRMessage(int bucketId, boolean notificationOnly, boolean posDup,\n+      Object callbackArg) {\n+    this.bucketId = bucketId;\n+    this.notificationOnly = notificationOnly;\n+    this.posDup = posDup;\n+    this.callbackArg = callbackArg;\n+    initTxMemberId();\n+  }\n+\n+  public void setEventId(RegionEventImpl event) {\n+    regionEvent = event;\n+  }\n+\n+  public void initMessage(PartitionedRegion region, Set<InternalDistributedMember> recipients,\n+      boolean notifyOnly, DirectReplyProcessor replyProcessor) {\n+    this.resetRecipients();\n+    if (recipients != null) {\n+      setRecipients(recipients);\n+    }\n+    this.regionId = region.getPRId();\n+    this.processor = replyProcessor;\n+    this.processorId = replyProcessor == null ? 0 : replyProcessor.getProcessorId();\n+    if (replyProcessor != null && this.isSevereAlertCompatible()) {\n+      replyProcessor.enableSevereAlertProcessing();\n+    }\n+    this.notificationOnly = notifyOnly;\n+  }\n+\n+  @Override\n+  public boolean isSevereAlertCompatible() {\n+    // allow forced-disconnect processing for all cache op messages\n+    return true;\n+  }\n+\n+  public void setPossibleDuplicate(boolean posDup) {\n+    this.posDup = posDup;\n+  }\n+\n+  public RegionEventImpl getRegionEvent() {\n+    return regionEvent;\n+  }\n+\n+  public ClearResponse send(DistributedMember recipient, PartitionedRegion region)\n+      throws ForceReattemptException {\n+    Set<InternalDistributedMember> recipients =\n+        Collections.singleton((InternalDistributedMember) recipient);\n+    ClearResponse clearResponse = new ClearResponse(region.getSystem(), recipients);\n+    initMessage(region, recipients, false, clearResponse);\n+    setTransactionDistributed(region.getCache().getTxManager().isDistributed());\n+    if (logger.isDebugEnabled()) {\n+      logger.debug(\"ClearPRMessage.send: recipient is {}, msg is {}\", recipient, this);\n+    }\n+\n+    Set<InternalDistributedMember> failures = region.getDistributionManager().putOutgoing(this);\n+    if (failures != null && failures.size() > 0) {\n+      throw new ForceReattemptException(\"Failed sending <\" + this + \">\");\n+    }\n+    return clearResponse;\n+  }\n+\n+  @Override\n+  public int getDSFID() {\n+    return PR_CLEAR_MESSAGE;\n+  }\n+\n+  @Override\n+  public void toData(DataOutput out, SerializationContext context) throws IOException {\n+    super.toData(out, context);\n+    if (bucketId == null) {\n+      InternalDataSerializer.writeSignedVL(-1, out);\n+    } else {\n+      InternalDataSerializer.writeSignedVL(bucketId, out);\n+    }\n+    DataSerializer.writeObject(this.callbackArg, out);\n+    // BR: This may not work properly", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31f29ae77edaab636b0f57129c6ebce2c6b38e1a"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk5MTg3MA==", "bodyText": "This method always returns false. Is that intentional? Also, I'm not sure if this method can actually throw any exceptions, since we catch the ForceReattemptException from doLocalClear() and the other two don't seem to be thrown by anything we're calling here.", "url": "https://github.com/apache/geode/pull/4689#discussion_r377991870", "createdAt": "2020-02-12T01:13:12Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/partitioned/ClearPRMessage.java", "diffHunk": "@@ -0,0 +1,405 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.cache.partitioned;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.Logger;\n+\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.cache.CacheException;\n+import org.apache.geode.cache.EntryExistsException;\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DirectReplyProcessor;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplyMessage;\n+import org.apache.geode.distributed.internal.ReplyProcessor21;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.Assert;\n+import org.apache.geode.internal.InternalDataSerializer;\n+import org.apache.geode.internal.NanoTimer;\n+import org.apache.geode.internal.cache.BucketRegion;\n+import org.apache.geode.internal.cache.DataLocationException;\n+import org.apache.geode.internal.cache.EventID;\n+import org.apache.geode.internal.cache.ForceReattemptException;\n+import org.apache.geode.internal.cache.PartitionedRegion;\n+import org.apache.geode.internal.cache.PartitionedRegionException;\n+import org.apache.geode.internal.cache.PartitionedRegionHelper;\n+import org.apache.geode.internal.cache.RegionEventImpl;\n+import org.apache.geode.internal.logging.log4j.LogMarker;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class ClearPRMessage extends PartitionMessageWithDirectReply {\n+  private static final Logger logger = LogService.getLogger();\n+\n+  private RegionEventImpl regionEvent;\n+\n+  private Integer bucketId;\n+\n+  private Object callbackArg;\n+\n+  /** The time in ms to wait for a lock to be obtained during doLocalClear() */\n+  public static final int LOCK_WAIT_TIMEOUT_MS = 100;\n+  public static final String BUCKET_NON_PRIMARY_MESSAGE =\n+      \"The bucket region on target member is no longer primary\";\n+  public static final String BUCKET_REGION_LOCK_UNAVAILABLE_MESSAGE =\n+      \"A lock for the bucket region could not be obtained.\";\n+\n+  protected static final short HAS_BRIDGE_CONTEXT = UNRESERVED_FLAGS_START;\n+\n+  /**\n+   * state from operateOnRegion that must be preserved for transmission from the waiting pool\n+   */\n+  transient boolean result = false;\n+\n+  /**\n+   * Empty constructor to satisfy {@link DataSerializer}requirements\n+   */\n+  public ClearPRMessage() {}\n+\n+  public ClearPRMessage(int bucketId, boolean notificationOnly, boolean posDup,\n+      Object callbackArg) {\n+    this.bucketId = bucketId;\n+    this.notificationOnly = notificationOnly;\n+    this.posDup = posDup;\n+    this.callbackArg = callbackArg;\n+    initTxMemberId();\n+  }\n+\n+  public void setEventId(RegionEventImpl event) {\n+    regionEvent = event;\n+  }\n+\n+  public void initMessage(PartitionedRegion region, Set<InternalDistributedMember> recipients,\n+      boolean notifyOnly, DirectReplyProcessor replyProcessor) {\n+    this.resetRecipients();\n+    if (recipients != null) {\n+      setRecipients(recipients);\n+    }\n+    this.regionId = region.getPRId();\n+    this.processor = replyProcessor;\n+    this.processorId = replyProcessor == null ? 0 : replyProcessor.getProcessorId();\n+    if (replyProcessor != null && this.isSevereAlertCompatible()) {\n+      replyProcessor.enableSevereAlertProcessing();\n+    }\n+    this.notificationOnly = notifyOnly;\n+  }\n+\n+  @Override\n+  public boolean isSevereAlertCompatible() {\n+    // allow forced-disconnect processing for all cache op messages\n+    return true;\n+  }\n+\n+  public void setPossibleDuplicate(boolean posDup) {\n+    this.posDup = posDup;\n+  }\n+\n+  public RegionEventImpl getRegionEvent() {\n+    return regionEvent;\n+  }\n+\n+  public ClearResponse send(DistributedMember recipient, PartitionedRegion region)\n+      throws ForceReattemptException {\n+    Set<InternalDistributedMember> recipients =\n+        Collections.singleton((InternalDistributedMember) recipient);\n+    ClearResponse clearResponse = new ClearResponse(region.getSystem(), recipients);\n+    initMessage(region, recipients, false, clearResponse);\n+    setTransactionDistributed(region.getCache().getTxManager().isDistributed());\n+    if (logger.isDebugEnabled()) {\n+      logger.debug(\"ClearPRMessage.send: recipient is {}, msg is {}\", recipient, this);\n+    }\n+\n+    Set<InternalDistributedMember> failures = region.getDistributionManager().putOutgoing(this);\n+    if (failures != null && failures.size() > 0) {\n+      throw new ForceReattemptException(\"Failed sending <\" + this + \">\");\n+    }\n+    return clearResponse;\n+  }\n+\n+  @Override\n+  public int getDSFID() {\n+    return PR_CLEAR_MESSAGE;\n+  }\n+\n+  @Override\n+  public void toData(DataOutput out, SerializationContext context) throws IOException {\n+    super.toData(out, context);\n+    if (bucketId == null) {\n+      InternalDataSerializer.writeSignedVL(-1, out);\n+    } else {\n+      InternalDataSerializer.writeSignedVL(bucketId, out);\n+    }\n+    DataSerializer.writeObject(this.callbackArg, out);\n+    // BR: This may not work properly\n+    DataSerializer.writeObject(regionEvent, out);\n+  }\n+\n+  @Override\n+  public void fromData(DataInput in, DeserializationContext context)\n+      throws IOException, ClassNotFoundException {\n+    super.fromData(in, context);\n+    this.bucketId = (int) InternalDataSerializer.readSignedVL(in);\n+    this.callbackArg = DataSerializer.readObject(in);\n+    this.regionEvent = DataSerializer.readObject(in);\n+  }\n+\n+  @Override\n+  public EventID getEventID() {\n+    return regionEvent.getEventId();\n+  }\n+\n+  /**\n+   * This method is called upon receipt and make the desired changes to the PartitionedRegion Note:\n+   * It is very important that this message does NOT cause any deadlocks as the sender will wait\n+   * indefinitely for the acknowledgement\n+   */\n+  @Override\n+  protected boolean operateOnPartitionedRegion(ClusterDistributionManager distributionManager,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31f29ae77edaab636b0f57129c6ebce2c6b38e1a"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk5MjIyMg==", "bodyText": "this.isSevereAlertCompatible() is always true for this class, so it can probably be removed from this if statement.", "url": "https://github.com/apache/geode/pull/4689#discussion_r377992222", "createdAt": "2020-02-12T01:14:43Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/partitioned/ClearPRMessage.java", "diffHunk": "@@ -0,0 +1,405 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.cache.partitioned;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.Logger;\n+\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.cache.CacheException;\n+import org.apache.geode.cache.EntryExistsException;\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DirectReplyProcessor;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplyMessage;\n+import org.apache.geode.distributed.internal.ReplyProcessor21;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.Assert;\n+import org.apache.geode.internal.InternalDataSerializer;\n+import org.apache.geode.internal.NanoTimer;\n+import org.apache.geode.internal.cache.BucketRegion;\n+import org.apache.geode.internal.cache.DataLocationException;\n+import org.apache.geode.internal.cache.EventID;\n+import org.apache.geode.internal.cache.ForceReattemptException;\n+import org.apache.geode.internal.cache.PartitionedRegion;\n+import org.apache.geode.internal.cache.PartitionedRegionException;\n+import org.apache.geode.internal.cache.PartitionedRegionHelper;\n+import org.apache.geode.internal.cache.RegionEventImpl;\n+import org.apache.geode.internal.logging.log4j.LogMarker;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class ClearPRMessage extends PartitionMessageWithDirectReply {\n+  private static final Logger logger = LogService.getLogger();\n+\n+  private RegionEventImpl regionEvent;\n+\n+  private Integer bucketId;\n+\n+  private Object callbackArg;\n+\n+  /** The time in ms to wait for a lock to be obtained during doLocalClear() */\n+  public static final int LOCK_WAIT_TIMEOUT_MS = 100;\n+  public static final String BUCKET_NON_PRIMARY_MESSAGE =\n+      \"The bucket region on target member is no longer primary\";\n+  public static final String BUCKET_REGION_LOCK_UNAVAILABLE_MESSAGE =\n+      \"A lock for the bucket region could not be obtained.\";\n+\n+  protected static final short HAS_BRIDGE_CONTEXT = UNRESERVED_FLAGS_START;\n+\n+  /**\n+   * state from operateOnRegion that must be preserved for transmission from the waiting pool\n+   */\n+  transient boolean result = false;\n+\n+  /**\n+   * Empty constructor to satisfy {@link DataSerializer}requirements\n+   */\n+  public ClearPRMessage() {}\n+\n+  public ClearPRMessage(int bucketId, boolean notificationOnly, boolean posDup,\n+      Object callbackArg) {\n+    this.bucketId = bucketId;\n+    this.notificationOnly = notificationOnly;\n+    this.posDup = posDup;\n+    this.callbackArg = callbackArg;\n+    initTxMemberId();\n+  }\n+\n+  public void setEventId(RegionEventImpl event) {\n+    regionEvent = event;\n+  }\n+\n+  public void initMessage(PartitionedRegion region, Set<InternalDistributedMember> recipients,\n+      boolean notifyOnly, DirectReplyProcessor replyProcessor) {\n+    this.resetRecipients();\n+    if (recipients != null) {\n+      setRecipients(recipients);\n+    }\n+    this.regionId = region.getPRId();\n+    this.processor = replyProcessor;\n+    this.processorId = replyProcessor == null ? 0 : replyProcessor.getProcessorId();\n+    if (replyProcessor != null && this.isSevereAlertCompatible()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31f29ae77edaab636b0f57129c6ebce2c6b38e1a"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk5NDIwMQ==", "bodyText": "It might be worth including tests to confirm that initMessage() correctly sets the processorId and doesn't call enableSevereAlertProcessing() on the ReplyProcessor if the processor is null, a test to confirm that send() throws an exception if putOutgoing(this) returns a non-null set, a test to confirm that operateOnPartitionedRegion() calls sendReply() with the correct arguments if a ForceReattemptException is thrown during doLocalClear(), a test to confirm that we call endPartitionMessagesProcessing() in sendReply() when appropriate and a test to confirm that we only call replyProcessor.process() in ClearReplyMessage.process() when the replyProcessor is not null.", "url": "https://github.com/apache/geode/pull/4689#discussion_r377994201", "createdAt": "2020-02-12T01:22:43Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/partitioned/ClearPRMessageTest.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.partitioned;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.internal.cache.BucketRegion;\n+import org.apache.geode.internal.cache.ForceReattemptException;\n+import org.apache.geode.internal.cache.PartitionedRegion;\n+import org.apache.geode.internal.cache.PartitionedRegionDataStore;\n+import org.apache.geode.internal.cache.PartitionedRegionException;\n+\n+public class ClearPRMessageTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31f29ae77edaab636b0f57129c6ebce2c6b38e1a"}, "originalPosition": 40}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "768be1301cce7d7ef095b7a9cb6be6ed2482e9e0", "author": {"user": {"login": "BenjaminPerryRoss", "name": null}}, "url": "https://github.com/apache/geode/commit/768be1301cce7d7ef095b7a9cb6be6ed2482e9e0", "committedDate": "2020-02-12T23:51:20Z", "message": "Added new message class and test\n\nCo-authored-by: Benjamin Ross <bross@pivotal.io>\nCo-authored-by: Donal Evans <doevans@pivotal.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "33b148f69ff632da44f925af713cd7b21d21e748", "author": {"user": {"login": "DonalEvans", "name": "Donal Evans"}}, "url": "https://github.com/apache/geode/commit/33b148f69ff632da44f925af713cd7b21d21e748", "committedDate": "2020-02-12T23:51:20Z", "message": "Connected feature to bucket clear functionality\n\nCo-authored-by: Benjamin Ross <bross@pivotal.io>\nCo-authored-by: Donal Evans <doevans@pivotal.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef12570f190c3575d1368a2549e73f9e4e9b3e7e", "author": {"user": {"login": "BenjaminPerryRoss", "name": null}}, "url": "https://github.com/apache/geode/commit/ef12570f190c3575d1368a2549e73f9e4e9b3e7e", "committedDate": "2020-02-12T23:51:20Z", "message": "Removed unnessessary changes\n\nCo-authored-by: Benjamin Ross <bross@pivotal.io>\nCo-authored-by: Donal Evans <doevans@pivotal.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5d123434deaef7633e4a2f147e10fa8481ff9129", "author": {"user": {"login": "DonalEvans", "name": "Donal Evans"}}, "url": "https://github.com/apache/geode/commit/5d123434deaef7633e4a2f147e10fa8481ff9129", "committedDate": "2020-02-12T23:51:20Z", "message": "Fixed spacing issue with reverted code\n\nCo-authored-by: Benjamin Ross <bross@pivotal.io>\nCo-authored-by: Donal Evans <doevans@pivotal.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "63193bbaad24bddbebd977b9343615b82619dc99", "author": {"user": {"login": "BenjaminPerryRoss", "name": null}}, "url": "https://github.com/apache/geode/commit/63193bbaad24bddbebd977b9343615b82619dc99", "committedDate": "2020-02-12T23:51:20Z", "message": "Disabled transactions for PR Clear Message\n\nCo-authored-by: Benjamin Ross <bross@pivotal.io>\nCo-authored-by: Donal Evans <doevans@pivotal.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "512992de0192fa690e0673c5d7dfced4d594270a", "author": {"user": {"login": "BenjaminPerryRoss", "name": null}}, "url": "https://github.com/apache/geode/commit/512992de0192fa690e0673c5d7dfced4d594270a", "committedDate": "2020-02-12T23:51:20Z", "message": "Made correct cmnClearRegion method public\n\nCo-authored-by: Benjamin Ross <bross@pivotal.io>\nCo-authored-by: Donal Evans <doevans@pivotal.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "70e62b1dd219e8ccb6a9a2928c844090ea04a4da", "author": {"user": {"login": "DonalEvans", "name": "Donal Evans"}}, "url": "https://github.com/apache/geode/commit/70e62b1dd219e8ccb6a9a2928c844090ea04a4da", "committedDate": "2020-02-12T23:51:20Z", "message": "Addressing initial PR feedback\n\nCo-authored-by: Benjamin Ross <bross@pivotal.io>\nCo-authored-by: Donal Evans <doevans@pivotal.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b0288c39b64558a1ce413f6774e6a13340e562b0", "author": {"user": {"login": "BenjaminPerryRoss", "name": null}}, "url": "https://github.com/apache/geode/commit/b0288c39b64558a1ce413f6774e6a13340e562b0", "committedDate": "2020-02-12T23:51:20Z", "message": "Added new unit tests recommended in PR feedback\n\nCo-authored-by: Benjamin Ross <bross@pivotal.io>\nCo-authored-by: Donal Evans <doevans@pivotal.io>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "95abb470aecabd29402987315437def06946bb17", "author": {"user": {"login": "BenjaminPerryRoss", "name": null}}, "url": "https://github.com/apache/geode/commit/95abb470aecabd29402987315437def06946bb17", "committedDate": "2020-02-12T23:38:30Z", "message": "Added new unit tests recommended in PR feedback\n\nCo-authored-by: Benjamin Ross <bross@pivotal.io>\nCo-authored-by: Donal Evans <doevans@pivotal.io>"}, "afterCommit": {"oid": "b0288c39b64558a1ce413f6774e6a13340e562b0", "author": {"user": {"login": "BenjaminPerryRoss", "name": null}}, "url": "https://github.com/apache/geode/commit/b0288c39b64558a1ce413f6774e6a13340e562b0", "committedDate": "2020-02-12T23:51:20Z", "message": "Added new unit tests recommended in PR feedback\n\nCo-authored-by: Benjamin Ross <bross@pivotal.io>\nCo-authored-by: Donal Evans <doevans@pivotal.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9270048956e58bb4f12acc99799daaa64b496bf", "author": {"user": {"login": "DonalEvans", "name": "Donal Evans"}}, "url": "https://github.com/apache/geode/commit/f9270048956e58bb4f12acc99799daaa64b496bf", "committedDate": "2020-02-13T17:24:03Z", "message": "Fix serializable errors\n\nCo-authored-by: Benjamin Ross <bross@pivotal.io>\nCo-authored-by: Donal Evans <doevans@pivotal.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "11d8a40a2e491d15001136cfbc6f4f76cd531321", "author": {"user": {"login": "BenjaminPerryRoss", "name": null}}, "url": "https://github.com/apache/geode/commit/11d8a40a2e491d15001136cfbc6f4f76cd531321", "committedDate": "2020-02-13T19:06:28Z", "message": "Made additional improvements based on PR review\n\nCo-authored-by: Benjamin Ross <bross@pivotal.io>\nCo-authored-by: Donal Evans <doevans@pivotal.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ab174e346e1841d5bc6b0987c0941b22e10d8f9", "author": {"user": {"login": "DonalEvans", "name": "Donal Evans"}}, "url": "https://github.com/apache/geode/commit/1ab174e346e1841d5bc6b0987c0941b22e10d8f9", "committedDate": "2020-02-13T19:12:19Z", "message": "Removed extra serialization code\n\nCo-authored-by: Benjamin Ross <bross@pivotal.io>\nCo-authored-by: Donal Evans <doevans@pivotal.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5bc8f18743d3d02306d31f2ceadd231f51666344", "author": {"user": {"login": "BenjaminPerryRoss", "name": null}}, "url": "https://github.com/apache/geode/commit/5bc8f18743d3d02306d31f2ceadd231f51666344", "committedDate": "2020-02-13T19:44:37Z", "message": "Additional review changes\n\nCo-authored-by: Benjamin Ross <bross@pivotal.io>\nCo-authored-by: Donal Evans <doevans@pivotal.io>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NTEwMzE5", "url": "https://github.com/apache/geode/pull/4689#pullrequestreview-358510319", "createdAt": "2020-02-13T19:58:49Z", "commit": {"oid": "5bc8f18743d3d02306d31f2ceadd231f51666344"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxOTo1ODo0OVrOFphpTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMDoxMjozNVrOFpiCBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA4NzE4MQ==", "bodyText": "This exception is never thrown from this method, so can be safely removed.", "url": "https://github.com/apache/geode/pull/4689#discussion_r379087181", "createdAt": "2020-02-13T19:58:49Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/partitioned/ClearPRMessageTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.partitioned;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.notNull;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DMStats;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.BucketRegion;\n+import org.apache.geode.internal.cache.ForceReattemptException;\n+import org.apache.geode.internal.cache.PartitionedRegion;\n+import org.apache.geode.internal.cache.PartitionedRegionDataStore;\n+import org.apache.geode.internal.cache.PartitionedRegionStats;\n+\n+public class ClearPRMessageTest {\n+\n+  ClearPRMessage message;\n+  PartitionedRegion region;\n+  PartitionedRegionDataStore dataStore;\n+  BucketRegion bucketRegion;\n+\n+  @Before\n+  public void setup() throws ForceReattemptException {\n+    message = spy(new ClearPRMessage());\n+    region = mock(PartitionedRegion.class, RETURNS_DEEP_STUBS);\n+    dataStore = mock(PartitionedRegionDataStore.class);\n+    when(region.getDataStore()).thenReturn(dataStore);\n+    bucketRegion = mock(BucketRegion.class);\n+    when(dataStore.getInitializedBucketForId(any(), any())).thenReturn(bucketRegion);\n+  }\n+\n+  @Test\n+  public void doLocalClearThrowsExceptionWhenBucketIsNotPrimaryAtFirstCheck() {\n+    when(bucketRegion.isPrimary()).thenReturn(false);\n+\n+    assertThatThrownBy(() -> message.doLocalClear(region))\n+        .isInstanceOf(ForceReattemptException.class)\n+        .hasMessageContaining(ClearPRMessage.BUCKET_NON_PRIMARY_MESSAGE);\n+  }\n+\n+  @Test\n+  public void doLocalClearThrowsExceptionWhenLockCannotBeObtained() {\n+    DistributedLockService mockLockService = mock(DistributedLockService.class);\n+    doReturn(mockLockService).when(message).getPartitionRegionLockService();\n+\n+    when(mockLockService.lock(anyString(), anyLong(), anyLong())).thenReturn(false);\n+    when(bucketRegion.isPrimary()).thenReturn(true);\n+\n+    assertThatThrownBy(() -> message.doLocalClear(region))\n+        .isInstanceOf(ForceReattemptException.class)\n+        .hasMessageContaining(ClearPRMessage.BUCKET_REGION_LOCK_UNAVAILABLE_MESSAGE);\n+  }\n+\n+  @Test\n+  public void doLocalClearThrowsExceptionWhenBucketIsNotPrimaryAfterObtainingLock() {\n+    DistributedLockService mockLockService = mock(DistributedLockService.class);\n+    doReturn(mockLockService).when(message).getPartitionRegionLockService();\n+\n+    // Be primary on the first check, then be not primary on the second check\n+    when(bucketRegion.isPrimary()).thenReturn(true).thenReturn(false);\n+    when(mockLockService.lock(any(), anyLong(), anyLong())).thenReturn(true);\n+\n+    assertThatThrownBy(() -> message.doLocalClear(region))\n+        .isInstanceOf(ForceReattemptException.class)\n+        .hasMessageContaining(ClearPRMessage.BUCKET_NON_PRIMARY_MESSAGE);\n+    // Confirm that we actually obtained and released the lock\n+    verify(mockLockService, times(1)).lock(any(), anyLong(), anyLong());\n+    verify(mockLockService, times(1)).unlock(any());\n+  }\n+\n+  @Test\n+  public void doLocalClearThrowsForceReattemptExceptionWhenAnExceptionIsThrownDuringClearOperation()\n+      throws ForceReattemptException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bc8f18743d3d02306d31f2ceadd231f51666344"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA4Nzg1Nw==", "bodyText": "This test isn't trying to verify anything about whether we do or don't obtain locks, just the behaviour when we get an exception from cmnClearRegion(), so these last couple of verifies aren't needed.", "url": "https://github.com/apache/geode/pull/4689#discussion_r379087857", "createdAt": "2020-02-13T20:00:11Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/partitioned/ClearPRMessageTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.partitioned;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.notNull;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DMStats;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.BucketRegion;\n+import org.apache.geode.internal.cache.ForceReattemptException;\n+import org.apache.geode.internal.cache.PartitionedRegion;\n+import org.apache.geode.internal.cache.PartitionedRegionDataStore;\n+import org.apache.geode.internal.cache.PartitionedRegionStats;\n+\n+public class ClearPRMessageTest {\n+\n+  ClearPRMessage message;\n+  PartitionedRegion region;\n+  PartitionedRegionDataStore dataStore;\n+  BucketRegion bucketRegion;\n+\n+  @Before\n+  public void setup() throws ForceReattemptException {\n+    message = spy(new ClearPRMessage());\n+    region = mock(PartitionedRegion.class, RETURNS_DEEP_STUBS);\n+    dataStore = mock(PartitionedRegionDataStore.class);\n+    when(region.getDataStore()).thenReturn(dataStore);\n+    bucketRegion = mock(BucketRegion.class);\n+    when(dataStore.getInitializedBucketForId(any(), any())).thenReturn(bucketRegion);\n+  }\n+\n+  @Test\n+  public void doLocalClearThrowsExceptionWhenBucketIsNotPrimaryAtFirstCheck() {\n+    when(bucketRegion.isPrimary()).thenReturn(false);\n+\n+    assertThatThrownBy(() -> message.doLocalClear(region))\n+        .isInstanceOf(ForceReattemptException.class)\n+        .hasMessageContaining(ClearPRMessage.BUCKET_NON_PRIMARY_MESSAGE);\n+  }\n+\n+  @Test\n+  public void doLocalClearThrowsExceptionWhenLockCannotBeObtained() {\n+    DistributedLockService mockLockService = mock(DistributedLockService.class);\n+    doReturn(mockLockService).when(message).getPartitionRegionLockService();\n+\n+    when(mockLockService.lock(anyString(), anyLong(), anyLong())).thenReturn(false);\n+    when(bucketRegion.isPrimary()).thenReturn(true);\n+\n+    assertThatThrownBy(() -> message.doLocalClear(region))\n+        .isInstanceOf(ForceReattemptException.class)\n+        .hasMessageContaining(ClearPRMessage.BUCKET_REGION_LOCK_UNAVAILABLE_MESSAGE);\n+  }\n+\n+  @Test\n+  public void doLocalClearThrowsExceptionWhenBucketIsNotPrimaryAfterObtainingLock() {\n+    DistributedLockService mockLockService = mock(DistributedLockService.class);\n+    doReturn(mockLockService).when(message).getPartitionRegionLockService();\n+\n+    // Be primary on the first check, then be not primary on the second check\n+    when(bucketRegion.isPrimary()).thenReturn(true).thenReturn(false);\n+    when(mockLockService.lock(any(), anyLong(), anyLong())).thenReturn(true);\n+\n+    assertThatThrownBy(() -> message.doLocalClear(region))\n+        .isInstanceOf(ForceReattemptException.class)\n+        .hasMessageContaining(ClearPRMessage.BUCKET_NON_PRIMARY_MESSAGE);\n+    // Confirm that we actually obtained and released the lock\n+    verify(mockLockService, times(1)).lock(any(), anyLong(), anyLong());\n+    verify(mockLockService, times(1)).unlock(any());\n+  }\n+\n+  @Test\n+  public void doLocalClearThrowsForceReattemptExceptionWhenAnExceptionIsThrownDuringClearOperation()\n+      throws ForceReattemptException {\n+    DistributedLockService mockLockService = mock(DistributedLockService.class);\n+    doReturn(mockLockService).when(message).getPartitionRegionLockService();\n+    NullPointerException exception = new NullPointerException(\"Error encountered\");\n+    doThrow(exception).when(bucketRegion).cmnClearRegion(any(), anyBoolean(), anyBoolean());\n+\n+    // Be primary on the first check, then be not primary on the second check\n+    when(bucketRegion.isPrimary()).thenReturn(true);\n+    when(mockLockService.lock(any(), anyLong(), anyLong())).thenReturn(true);\n+\n+    assertThatThrownBy(() -> message.doLocalClear(region))\n+        .isInstanceOf(ForceReattemptException.class)\n+        .hasMessageContaining(ClearPRMessage.EXCEPTION_THROWN_DURING_CLEAR_OPERATION);\n+\n+    // Confirm that cmnClearRegion was called\n+    verify(bucketRegion, times(1)).cmnClearRegion(any(), anyBoolean(), anyBoolean());\n+\n+    // Confirm that we actually obtained and released the lock\n+    verify(mockLockService, times(1)).lock(any(), anyLong(), anyLong());\n+    verify(mockLockService, times(1)).unlock(any());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bc8f18743d3d02306d31f2ceadd231f51666344"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA4ODM1Mw==", "bodyText": "There's an extra line here that could be tidied up.", "url": "https://github.com/apache/geode/pull/4689#discussion_r379088353", "createdAt": "2020-02-13T20:01:12Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/partitioned/ClearPRMessageTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.partitioned;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.notNull;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DMStats;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.BucketRegion;\n+import org.apache.geode.internal.cache.ForceReattemptException;\n+import org.apache.geode.internal.cache.PartitionedRegion;\n+import org.apache.geode.internal.cache.PartitionedRegionDataStore;\n+import org.apache.geode.internal.cache.PartitionedRegionStats;\n+\n+public class ClearPRMessageTest {\n+\n+  ClearPRMessage message;\n+  PartitionedRegion region;\n+  PartitionedRegionDataStore dataStore;\n+  BucketRegion bucketRegion;\n+\n+  @Before\n+  public void setup() throws ForceReattemptException {\n+    message = spy(new ClearPRMessage());\n+    region = mock(PartitionedRegion.class, RETURNS_DEEP_STUBS);\n+    dataStore = mock(PartitionedRegionDataStore.class);\n+    when(region.getDataStore()).thenReturn(dataStore);\n+    bucketRegion = mock(BucketRegion.class);\n+    when(dataStore.getInitializedBucketForId(any(), any())).thenReturn(bucketRegion);\n+  }\n+\n+  @Test\n+  public void doLocalClearThrowsExceptionWhenBucketIsNotPrimaryAtFirstCheck() {\n+    when(bucketRegion.isPrimary()).thenReturn(false);\n+\n+    assertThatThrownBy(() -> message.doLocalClear(region))\n+        .isInstanceOf(ForceReattemptException.class)\n+        .hasMessageContaining(ClearPRMessage.BUCKET_NON_PRIMARY_MESSAGE);\n+  }\n+\n+  @Test\n+  public void doLocalClearThrowsExceptionWhenLockCannotBeObtained() {\n+    DistributedLockService mockLockService = mock(DistributedLockService.class);\n+    doReturn(mockLockService).when(message).getPartitionRegionLockService();\n+\n+    when(mockLockService.lock(anyString(), anyLong(), anyLong())).thenReturn(false);\n+    when(bucketRegion.isPrimary()).thenReturn(true);\n+\n+    assertThatThrownBy(() -> message.doLocalClear(region))\n+        .isInstanceOf(ForceReattemptException.class)\n+        .hasMessageContaining(ClearPRMessage.BUCKET_REGION_LOCK_UNAVAILABLE_MESSAGE);\n+  }\n+\n+  @Test\n+  public void doLocalClearThrowsExceptionWhenBucketIsNotPrimaryAfterObtainingLock() {\n+    DistributedLockService mockLockService = mock(DistributedLockService.class);\n+    doReturn(mockLockService).when(message).getPartitionRegionLockService();\n+\n+    // Be primary on the first check, then be not primary on the second check\n+    when(bucketRegion.isPrimary()).thenReturn(true).thenReturn(false);\n+    when(mockLockService.lock(any(), anyLong(), anyLong())).thenReturn(true);\n+\n+    assertThatThrownBy(() -> message.doLocalClear(region))\n+        .isInstanceOf(ForceReattemptException.class)\n+        .hasMessageContaining(ClearPRMessage.BUCKET_NON_PRIMARY_MESSAGE);\n+    // Confirm that we actually obtained and released the lock\n+    verify(mockLockService, times(1)).lock(any(), anyLong(), anyLong());\n+    verify(mockLockService, times(1)).unlock(any());\n+  }\n+\n+  @Test\n+  public void doLocalClearThrowsForceReattemptExceptionWhenAnExceptionIsThrownDuringClearOperation()\n+      throws ForceReattemptException {\n+    DistributedLockService mockLockService = mock(DistributedLockService.class);\n+    doReturn(mockLockService).when(message).getPartitionRegionLockService();\n+    NullPointerException exception = new NullPointerException(\"Error encountered\");\n+    doThrow(exception).when(bucketRegion).cmnClearRegion(any(), anyBoolean(), anyBoolean());\n+\n+    // Be primary on the first check, then be not primary on the second check\n+    when(bucketRegion.isPrimary()).thenReturn(true);\n+    when(mockLockService.lock(any(), anyLong(), anyLong())).thenReturn(true);\n+\n+    assertThatThrownBy(() -> message.doLocalClear(region))\n+        .isInstanceOf(ForceReattemptException.class)\n+        .hasMessageContaining(ClearPRMessage.EXCEPTION_THROWN_DURING_CLEAR_OPERATION);\n+\n+    // Confirm that cmnClearRegion was called\n+    verify(bucketRegion, times(1)).cmnClearRegion(any(), anyBoolean(), anyBoolean());\n+\n+    // Confirm that we actually obtained and released the lock\n+    verify(mockLockService, times(1)).lock(any(), anyLong(), anyLong());\n+    verify(mockLockService, times(1)).unlock(any());\n+  }\n+\n+  @Test\n+  public void doLocalClearInvokesCmnClearRegionWhenBucketIsPrimaryAndLockIsObtained()\n+      throws ForceReattemptException {\n+    DistributedLockService mockLockService = mock(DistributedLockService.class);\n+    doReturn(mockLockService).when(message).getPartitionRegionLockService();\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bc8f18743d3d02306d31f2ceadd231f51666344"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA5MzUxMA==", "bodyText": "I think this comment is probably no longer needed, as it was originally just a placeholder and the thing it's describing is very self-explanatory.", "url": "https://github.com/apache/geode/pull/4689#discussion_r379093510", "createdAt": "2020-02-13T20:12:35Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/partitioned/ClearPRMessage.java", "diffHunk": "@@ -0,0 +1,389 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.cache.partitioned;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.Logger;\n+\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.annotations.VisibleForTesting;\n+import org.apache.geode.cache.CacheException;\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DirectReplyProcessor;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplyMessage;\n+import org.apache.geode.distributed.internal.ReplyProcessor21;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.Assert;\n+import org.apache.geode.internal.InternalDataSerializer;\n+import org.apache.geode.internal.NanoTimer;\n+import org.apache.geode.internal.cache.BucketRegion;\n+import org.apache.geode.internal.cache.EventID;\n+import org.apache.geode.internal.cache.ForceReattemptException;\n+import org.apache.geode.internal.cache.PartitionedRegion;\n+import org.apache.geode.internal.cache.PartitionedRegionHelper;\n+import org.apache.geode.internal.cache.RegionEventImpl;\n+import org.apache.geode.internal.logging.log4j.LogMarker;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class ClearPRMessage extends PartitionMessageWithDirectReply {\n+  private static final Logger logger = LogService.getLogger();\n+\n+  private RegionEventImpl regionEvent;\n+\n+  private Integer bucketId;\n+\n+  /** The time in ms to wait for a lock to be obtained during doLocalClear() */\n+  public static final int LOCK_WAIT_TIMEOUT_MS = 1000;\n+  public static final String BUCKET_NON_PRIMARY_MESSAGE =\n+      \"The bucket region on target member is no longer primary\";\n+  public static final String BUCKET_REGION_LOCK_UNAVAILABLE_MESSAGE =\n+      \"A lock for the bucket region could not be obtained.\";\n+  public static final String EXCEPTION_THROWN_DURING_CLEAR_OPERATION =\n+      \"An exception was thrown during the local clear operation: \";\n+\n+  /**\n+   * state from operateOnRegion that must be preserved for transmission from the waiting pool\n+   */\n+  transient boolean result = false;\n+\n+  /**\n+   * Empty constructor to satisfy {@link DataSerializer}requirements\n+   */\n+  public ClearPRMessage() {}\n+\n+  public ClearPRMessage(int bucketId) {\n+    this.bucketId = bucketId;\n+\n+    // These are both used by the parent class, but don't apply to this message type\n+    this.notificationOnly = false;\n+    this.posDup = false;\n+  }\n+\n+  public void setRegionEvent(RegionEventImpl event) {\n+    regionEvent = event;\n+  }\n+\n+  public void initMessage(PartitionedRegion region, Set<InternalDistributedMember> recipients,\n+      DirectReplyProcessor replyProcessor) {\n+    this.resetRecipients();\n+    if (recipients != null) {\n+      setRecipients(recipients);\n+    }\n+    this.regionId = region.getPRId();\n+    this.processor = replyProcessor;\n+    this.processorId = replyProcessor == null ? 0 : replyProcessor.getProcessorId();\n+    if (replyProcessor != null) {\n+      replyProcessor.enableSevereAlertProcessing();\n+    }\n+  }\n+\n+  @Override\n+  public boolean isSevereAlertCompatible() {\n+    // allow forced-disconnect processing for all cache op messages\n+    return true;\n+  }\n+\n+  public RegionEventImpl getRegionEvent() {\n+    return regionEvent;\n+  }\n+\n+  public ClearResponse send(DistributedMember recipient, PartitionedRegion region)\n+      throws ForceReattemptException {\n+    Set<InternalDistributedMember> recipients =\n+        Collections.singleton((InternalDistributedMember) recipient);\n+    ClearResponse clearResponse = new ClearResponse(region.getSystem(), recipients);\n+    initMessage(region, recipients, clearResponse);\n+    if (logger.isDebugEnabled()) {\n+      logger.debug(\"ClearPRMessage.send: recipient is {}, msg is {}\", recipient, this);\n+    }\n+\n+    Set<InternalDistributedMember> failures = region.getDistributionManager().putOutgoing(this);\n+    if (failures != null && failures.size() > 0) {\n+      throw new ForceReattemptException(\"Failed sending <\" + this + \">\");\n+    }\n+    return clearResponse;\n+  }\n+\n+  @Override\n+  public int getDSFID() {\n+    return PR_CLEAR_MESSAGE;\n+  }\n+\n+  @Override\n+  public void toData(DataOutput out, SerializationContext context) throws IOException {\n+    super.toData(out, context);\n+    if (bucketId == null) {\n+      InternalDataSerializer.writeSignedVL(-1, out);\n+    } else {\n+      InternalDataSerializer.writeSignedVL(bucketId, out);\n+    }\n+    DataSerializer.writeObject(regionEvent, out);\n+  }\n+\n+  @Override\n+  public void fromData(DataInput in, DeserializationContext context)\n+      throws IOException, ClassNotFoundException {\n+    super.fromData(in, context);\n+    this.bucketId = (int) InternalDataSerializer.readSignedVL(in);\n+    this.regionEvent = DataSerializer.readObject(in);\n+  }\n+\n+  @Override\n+  public EventID getEventID() {\n+    return regionEvent.getEventId();\n+  }\n+\n+  /**\n+   * This method is called upon receipt and make the desired changes to the PartitionedRegion Note:\n+   * It is very important that this message does NOT cause any deadlocks as the sender will wait\n+   * indefinitely for the acknowledgement\n+   */\n+  @Override\n+  @VisibleForTesting\n+  protected boolean operateOnPartitionedRegion(ClusterDistributionManager distributionManager,\n+      PartitionedRegion region, long startTime) {\n+    try {\n+      result = doLocalClear(region);\n+    } catch (ForceReattemptException ex) {\n+      sendReply(getSender(), getProcessorId(), distributionManager, new ReplyException(ex), region,\n+          startTime);\n+      return false;\n+    }\n+    sendReply(getSender(), getProcessorId(), distributionManager, null, region, startTime);\n+    return false;\n+  }\n+\n+  public boolean doLocalClear(PartitionedRegion region) throws ForceReattemptException {\n+    // Retrieve local bucket region which matches target bucketId\n+    BucketRegion bucketRegion = region.getDataStore().getInitializedBucketForId(null, bucketId);\n+\n+    // Check if we are primary, throw exception if not\n+    if (!bucketRegion.isPrimary()) {\n+      throw new ForceReattemptException(BUCKET_NON_PRIMARY_MESSAGE);\n+    }\n+\n+    DistributedLockService lockService = getPartitionRegionLockService();\n+    String lockName = bucketRegion.getFullPath();\n+    try {\n+      boolean locked = lockService.lock(lockName, LOCK_WAIT_TIMEOUT_MS, -1);\n+\n+      if (!locked) {\n+        throw new ForceReattemptException(BUCKET_REGION_LOCK_UNAVAILABLE_MESSAGE);\n+      }\n+\n+      // Double check if we are still primary, as this could have changed between our first check\n+      // and obtaining the lock\n+      if (!bucketRegion.isPrimary()) {\n+        throw new ForceReattemptException(BUCKET_NON_PRIMARY_MESSAGE);\n+      }\n+\n+      try {\n+        // call new cmnClearRegion on the target bucket region", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bc8f18743d3d02306d31f2ceadd231f51666344"}, "originalPosition": 207}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88982af9a5e4bde9e7a5062c46d854aaf8bdf98b", "author": {"user": {"login": "DonalEvans", "name": "Donal Evans"}}, "url": "https://github.com/apache/geode/commit/88982af9a5e4bde9e7a5062c46d854aaf8bdf98b", "committedDate": "2020-02-13T22:29:12Z", "message": "Fixed minor test details\n\nCo-authored-by: Benjamin Ross <bross@pivotal.io>\nCo-authored-by: Donal Evans <doevans@pivotal.io>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NjAwNzQz", "url": "https://github.com/apache/geode/pull/4689#pullrequestreview-358600743", "createdAt": "2020-02-13T22:33:26Z", "commit": {"oid": "88982af9a5e4bde9e7a5062c46d854aaf8bdf98b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NjAwODk4", "url": "https://github.com/apache/geode/pull/4689#pullrequestreview-358600898", "createdAt": "2020-02-13T22:33:42Z", "commit": {"oid": "88982af9a5e4bde9e7a5062c46d854aaf8bdf98b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3773, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}