{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI4MTM0MTM3", "number": 5216, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMzo1MDowNlrOECxhOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxOToxMTo1NVrOEIfm6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMzQzOTI4OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMzo1MDowNlrOGfcCJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxODowMjozOVrOGf4K4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxODM0MQ==", "bodyText": "Please convert this back to SECONDS.toMillis(expirationTimeLong). It is a standard part of the jdk and makes clear what units we are converting from and to.", "url": "https://github.com/apache/geode/pull/5216#discussion_r435618341", "createdAt": "2020-06-04T23:50:06Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "diffHunk": "@@ -68,72 +75,141 @@ private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n     return new ByteArrayWrapper(value);\n   }\n \n+  private SetOptions parseOptionalParameters(List<byte[]> optionalParameterBytes)\n+      throws IllegalArgumentException {\n \n-  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {\n     boolean keepTTL = false;\n     SetOptions.Exists existsOption = SetOptions.Exists.NONE;\n     long expiration = 0L;\n \n-    for (int i = 3; i < commandElems.size(); i++) {\n-      String current_arg = Coder.bytesToString(commandElems.get(i)).toUpperCase();\n-      switch (current_arg) {\n-        case \"KEEPTTL\":\n-          keepTTL = true;\n-          break;\n-        case \"EX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          expiration = SECONDS.toMillis(expiration);\n-          break;\n-        case \"PX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          break;\n-        case \"NX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.NX;\n-          break;\n-        case \"XX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.XX;\n-          break;\n-        default:\n-          throw new IllegalArgumentException(ERROR_SYNTAX);\n+    List<String> optionalParametersStrings =\n+        optionalParameterBytes.stream()\n+            .map(item -> Coder.bytesToString(item).toUpperCase())\n+            .collect(Collectors.toList());\n+\n+    throwExceptionIfUnknownParameter(optionalParametersStrings);\n+    throwExceptionIfIncompatableParamaterOptions(optionalParametersStrings);\n+\n+    if (optionalParametersStrings.contains(\"KEEPTL\")) {\n+      keepTTL = true;\n+    }\n+\n+    if (optionalParametersStrings.contains(\"PX\")) {\n+      int index = optionalParametersStrings.indexOf(\"PX\");\n+\n+      if (optionalParametersStrings.size() <= index + 1) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+\n+      String expirationTime = optionalParametersStrings.get(index + 1);\n+      expiration = parseExpirationTime(\"PX\", expirationTime);\n+\n+    } else if (optionalParametersStrings.contains(\"EX\")) {\n+      int index = optionalParametersStrings.indexOf(\"EX\");\n+\n+      if (optionalParametersStrings.size() <= index + 1) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n       }\n+\n+      String expirationTime = optionalParametersStrings.get(index + 1);\n+      expiration = parseExpirationTime(\"EX\", expirationTime);\n+    }\n+\n+    if (optionalParametersStrings.contains(\"NX\")) {\n+      existsOption = SetOptions.Exists.NX;\n+    } else if (optionalParametersStrings.contains(\"XX\")) {\n+      existsOption = SetOptions.Exists.XX;\n     }\n \n     return new SetOptions(existsOption, expiration, keepTTL);\n   }\n \n-  private long parseExpirationTime(int index, List<byte[]> commandElems)\n-      throws IllegalArgumentException {\n-    String expirationString;\n \n-    try {\n-      expirationString = Coder.bytesToString(commandElems.get(index));\n-    } catch (IndexOutOfBoundsException e) {\n+  private void throwExceptionIfUnknownParameter(List<String> optionalParameters) {\n+    List<String> validOptionalParamaters = Arrays.asList(\"EX\", \"PX\", \"NX\", \"XX\", \"KEEPTL\");\n+\n+    List<String> parametersInQuestion =\n+        optionalParameters\n+            .stream()\n+            .filter(parameter -> (!validOptionalParamaters.contains(parameter)))\n+            .collect(Collectors.toList());\n+\n+    parametersInQuestion.forEach(parameter -> throwErrorIfNotANumberInExpectedPosition(\n+        parameter,\n+        optionalParameters));\n+  }\n+\n+\n+  private void throwErrorIfNotANumberInExpectedPosition(\n+      String parameter,\n+      List<String> optionalParameters) {\n+\n+    if (previousOptionIsValidAndExpectsANumber(parameter, optionalParameters)) {\n+      convertToLongOrThrowException(parameter);\n+    } else {\n       throw new IllegalArgumentException(ERROR_SYNTAX);\n     }\n \n+  }\n+\n+\n+  private boolean previousOptionIsValidAndExpectsANumber(String paramter,\n+      List<String> optionalParameters) {\n+    List<String> validParamaters = Arrays.asList(\"EX\", \"PX\");\n+\n+    if (optionalParameters.size() < 2) {\n+      return false;\n+    }\n+\n+    int indexOfParameter = optionalParameters.indexOf(paramter);\n+    String previousParameter = optionalParameters.get(indexOfParameter - 1);\n+\n+    return validParamaters.contains(previousParameter);\n+  }\n+\n+\n+  private void throwExceptionIfIncompatableParamaterOptions(List<String> passedParametersStrings) {\n+\n+    if (passedParametersStrings.contains(\"PX\")\n+        && passedParametersStrings.contains(\"EX\")) {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+\n+    if (passedParametersStrings.contains(\"XX\")\n+        && passedParametersStrings.contains(\"NX\")) {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+  }\n+\n+  private long parseExpirationTime(String expirationParameter, String expirationTimeString)\n+      throws IllegalArgumentException {\n+\n+    long expirationTimeLong =\n+        convertToLongOrThrowException(expirationTimeString);\n+\n+    isExpirationTimeLegal(expirationTimeLong);\n+\n+    if (expirationParameter.equals(\"EX\")) {\n+      expirationTimeLong *= 1000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d52ff497d17a27652a5bdc573b49474e446c7a92"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3OTMyOA==", "bodyText": "makes sense-  rebase oversight.  done", "url": "https://github.com/apache/geode/pull/5216#discussion_r436079328", "createdAt": "2020-06-05T18:02:39Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "diffHunk": "@@ -68,72 +75,141 @@ private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n     return new ByteArrayWrapper(value);\n   }\n \n+  private SetOptions parseOptionalParameters(List<byte[]> optionalParameterBytes)\n+      throws IllegalArgumentException {\n \n-  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {\n     boolean keepTTL = false;\n     SetOptions.Exists existsOption = SetOptions.Exists.NONE;\n     long expiration = 0L;\n \n-    for (int i = 3; i < commandElems.size(); i++) {\n-      String current_arg = Coder.bytesToString(commandElems.get(i)).toUpperCase();\n-      switch (current_arg) {\n-        case \"KEEPTTL\":\n-          keepTTL = true;\n-          break;\n-        case \"EX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          expiration = SECONDS.toMillis(expiration);\n-          break;\n-        case \"PX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          break;\n-        case \"NX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.NX;\n-          break;\n-        case \"XX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.XX;\n-          break;\n-        default:\n-          throw new IllegalArgumentException(ERROR_SYNTAX);\n+    List<String> optionalParametersStrings =\n+        optionalParameterBytes.stream()\n+            .map(item -> Coder.bytesToString(item).toUpperCase())\n+            .collect(Collectors.toList());\n+\n+    throwExceptionIfUnknownParameter(optionalParametersStrings);\n+    throwExceptionIfIncompatableParamaterOptions(optionalParametersStrings);\n+\n+    if (optionalParametersStrings.contains(\"KEEPTL\")) {\n+      keepTTL = true;\n+    }\n+\n+    if (optionalParametersStrings.contains(\"PX\")) {\n+      int index = optionalParametersStrings.indexOf(\"PX\");\n+\n+      if (optionalParametersStrings.size() <= index + 1) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+\n+      String expirationTime = optionalParametersStrings.get(index + 1);\n+      expiration = parseExpirationTime(\"PX\", expirationTime);\n+\n+    } else if (optionalParametersStrings.contains(\"EX\")) {\n+      int index = optionalParametersStrings.indexOf(\"EX\");\n+\n+      if (optionalParametersStrings.size() <= index + 1) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n       }\n+\n+      String expirationTime = optionalParametersStrings.get(index + 1);\n+      expiration = parseExpirationTime(\"EX\", expirationTime);\n+    }\n+\n+    if (optionalParametersStrings.contains(\"NX\")) {\n+      existsOption = SetOptions.Exists.NX;\n+    } else if (optionalParametersStrings.contains(\"XX\")) {\n+      existsOption = SetOptions.Exists.XX;\n     }\n \n     return new SetOptions(existsOption, expiration, keepTTL);\n   }\n \n-  private long parseExpirationTime(int index, List<byte[]> commandElems)\n-      throws IllegalArgumentException {\n-    String expirationString;\n \n-    try {\n-      expirationString = Coder.bytesToString(commandElems.get(index));\n-    } catch (IndexOutOfBoundsException e) {\n+  private void throwExceptionIfUnknownParameter(List<String> optionalParameters) {\n+    List<String> validOptionalParamaters = Arrays.asList(\"EX\", \"PX\", \"NX\", \"XX\", \"KEEPTL\");\n+\n+    List<String> parametersInQuestion =\n+        optionalParameters\n+            .stream()\n+            .filter(parameter -> (!validOptionalParamaters.contains(parameter)))\n+            .collect(Collectors.toList());\n+\n+    parametersInQuestion.forEach(parameter -> throwErrorIfNotANumberInExpectedPosition(\n+        parameter,\n+        optionalParameters));\n+  }\n+\n+\n+  private void throwErrorIfNotANumberInExpectedPosition(\n+      String parameter,\n+      List<String> optionalParameters) {\n+\n+    if (previousOptionIsValidAndExpectsANumber(parameter, optionalParameters)) {\n+      convertToLongOrThrowException(parameter);\n+    } else {\n       throw new IllegalArgumentException(ERROR_SYNTAX);\n     }\n \n+  }\n+\n+\n+  private boolean previousOptionIsValidAndExpectsANumber(String paramter,\n+      List<String> optionalParameters) {\n+    List<String> validParamaters = Arrays.asList(\"EX\", \"PX\");\n+\n+    if (optionalParameters.size() < 2) {\n+      return false;\n+    }\n+\n+    int indexOfParameter = optionalParameters.indexOf(paramter);\n+    String previousParameter = optionalParameters.get(indexOfParameter - 1);\n+\n+    return validParamaters.contains(previousParameter);\n+  }\n+\n+\n+  private void throwExceptionIfIncompatableParamaterOptions(List<String> passedParametersStrings) {\n+\n+    if (passedParametersStrings.contains(\"PX\")\n+        && passedParametersStrings.contains(\"EX\")) {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+\n+    if (passedParametersStrings.contains(\"XX\")\n+        && passedParametersStrings.contains(\"NX\")) {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+  }\n+\n+  private long parseExpirationTime(String expirationParameter, String expirationTimeString)\n+      throws IllegalArgumentException {\n+\n+    long expirationTimeLong =\n+        convertToLongOrThrowException(expirationTimeString);\n+\n+    isExpirationTimeLegal(expirationTimeLong);\n+\n+    if (expirationParameter.equals(\"EX\")) {\n+      expirationTimeLong *= 1000;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxODM0MQ=="}, "originalCommit": {"oid": "d52ff497d17a27652a5bdc573b49474e446c7a92"}, "originalPosition": 206}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMzQ0NTQ2OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMzo1Mzo1MlrOGfcF8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMjoxMjozOFrOGf-x3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxOTMxNA==", "bodyText": "This is not the correct exception here. You actually have an integer but the parameter was not one of EX or PX. I wold argue that you should not even pass expirationParameter into this method. Let the caller that knows he is EX convert the value returned from this method to milliseconds. So less responsibility for this method.", "url": "https://github.com/apache/geode/pull/5216#discussion_r435619314", "createdAt": "2020-06-04T23:53:52Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "diffHunk": "@@ -68,72 +75,141 @@ private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n     return new ByteArrayWrapper(value);\n   }\n \n+  private SetOptions parseOptionalParameters(List<byte[]> optionalParameterBytes)\n+      throws IllegalArgumentException {\n \n-  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {\n     boolean keepTTL = false;\n     SetOptions.Exists existsOption = SetOptions.Exists.NONE;\n     long expiration = 0L;\n \n-    for (int i = 3; i < commandElems.size(); i++) {\n-      String current_arg = Coder.bytesToString(commandElems.get(i)).toUpperCase();\n-      switch (current_arg) {\n-        case \"KEEPTTL\":\n-          keepTTL = true;\n-          break;\n-        case \"EX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          expiration = SECONDS.toMillis(expiration);\n-          break;\n-        case \"PX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          break;\n-        case \"NX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.NX;\n-          break;\n-        case \"XX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.XX;\n-          break;\n-        default:\n-          throw new IllegalArgumentException(ERROR_SYNTAX);\n+    List<String> optionalParametersStrings =\n+        optionalParameterBytes.stream()\n+            .map(item -> Coder.bytesToString(item).toUpperCase())\n+            .collect(Collectors.toList());\n+\n+    throwExceptionIfUnknownParameter(optionalParametersStrings);\n+    throwExceptionIfIncompatableParamaterOptions(optionalParametersStrings);\n+\n+    if (optionalParametersStrings.contains(\"KEEPTL\")) {\n+      keepTTL = true;\n+    }\n+\n+    if (optionalParametersStrings.contains(\"PX\")) {\n+      int index = optionalParametersStrings.indexOf(\"PX\");\n+\n+      if (optionalParametersStrings.size() <= index + 1) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+\n+      String expirationTime = optionalParametersStrings.get(index + 1);\n+      expiration = parseExpirationTime(\"PX\", expirationTime);\n+\n+    } else if (optionalParametersStrings.contains(\"EX\")) {\n+      int index = optionalParametersStrings.indexOf(\"EX\");\n+\n+      if (optionalParametersStrings.size() <= index + 1) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n       }\n+\n+      String expirationTime = optionalParametersStrings.get(index + 1);\n+      expiration = parseExpirationTime(\"EX\", expirationTime);\n+    }\n+\n+    if (optionalParametersStrings.contains(\"NX\")) {\n+      existsOption = SetOptions.Exists.NX;\n+    } else if (optionalParametersStrings.contains(\"XX\")) {\n+      existsOption = SetOptions.Exists.XX;\n     }\n \n     return new SetOptions(existsOption, expiration, keepTTL);\n   }\n \n-  private long parseExpirationTime(int index, List<byte[]> commandElems)\n-      throws IllegalArgumentException {\n-    String expirationString;\n \n-    try {\n-      expirationString = Coder.bytesToString(commandElems.get(index));\n-    } catch (IndexOutOfBoundsException e) {\n+  private void throwExceptionIfUnknownParameter(List<String> optionalParameters) {\n+    List<String> validOptionalParamaters = Arrays.asList(\"EX\", \"PX\", \"NX\", \"XX\", \"KEEPTL\");\n+\n+    List<String> parametersInQuestion =\n+        optionalParameters\n+            .stream()\n+            .filter(parameter -> (!validOptionalParamaters.contains(parameter)))\n+            .collect(Collectors.toList());\n+\n+    parametersInQuestion.forEach(parameter -> throwErrorIfNotANumberInExpectedPosition(\n+        parameter,\n+        optionalParameters));\n+  }\n+\n+\n+  private void throwErrorIfNotANumberInExpectedPosition(\n+      String parameter,\n+      List<String> optionalParameters) {\n+\n+    if (previousOptionIsValidAndExpectsANumber(parameter, optionalParameters)) {\n+      convertToLongOrThrowException(parameter);\n+    } else {\n       throw new IllegalArgumentException(ERROR_SYNTAX);\n     }\n \n+  }\n+\n+\n+  private boolean previousOptionIsValidAndExpectsANumber(String paramter,\n+      List<String> optionalParameters) {\n+    List<String> validParamaters = Arrays.asList(\"EX\", \"PX\");\n+\n+    if (optionalParameters.size() < 2) {\n+      return false;\n+    }\n+\n+    int indexOfParameter = optionalParameters.indexOf(paramter);\n+    String previousParameter = optionalParameters.get(indexOfParameter - 1);\n+\n+    return validParamaters.contains(previousParameter);\n+  }\n+\n+\n+  private void throwExceptionIfIncompatableParamaterOptions(List<String> passedParametersStrings) {\n+\n+    if (passedParametersStrings.contains(\"PX\")\n+        && passedParametersStrings.contains(\"EX\")) {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+\n+    if (passedParametersStrings.contains(\"XX\")\n+        && passedParametersStrings.contains(\"NX\")) {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+  }\n+\n+  private long parseExpirationTime(String expirationParameter, String expirationTimeString)\n+      throws IllegalArgumentException {\n+\n+    long expirationTimeLong =\n+        convertToLongOrThrowException(expirationTimeString);\n+\n+    isExpirationTimeLegal(expirationTimeLong);\n+\n+    if (expirationParameter.equals(\"EX\")) {\n+      expirationTimeLong *= 1000;\n+    } else if (!expirationParameter.equals(\"PX\")) {\n+      throw new IllegalArgumentException(ERROR_NOT_INTEGER);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d52ff497d17a27652a5bdc573b49474e446c7a92"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE4NzYxNA==", "bodyText": "pulled this logic apart-  thanks", "url": "https://github.com/apache/geode/pull/5216#discussion_r436187614", "createdAt": "2020-06-05T22:12:38Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "diffHunk": "@@ -68,72 +75,141 @@ private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n     return new ByteArrayWrapper(value);\n   }\n \n+  private SetOptions parseOptionalParameters(List<byte[]> optionalParameterBytes)\n+      throws IllegalArgumentException {\n \n-  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {\n     boolean keepTTL = false;\n     SetOptions.Exists existsOption = SetOptions.Exists.NONE;\n     long expiration = 0L;\n \n-    for (int i = 3; i < commandElems.size(); i++) {\n-      String current_arg = Coder.bytesToString(commandElems.get(i)).toUpperCase();\n-      switch (current_arg) {\n-        case \"KEEPTTL\":\n-          keepTTL = true;\n-          break;\n-        case \"EX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          expiration = SECONDS.toMillis(expiration);\n-          break;\n-        case \"PX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          break;\n-        case \"NX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.NX;\n-          break;\n-        case \"XX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.XX;\n-          break;\n-        default:\n-          throw new IllegalArgumentException(ERROR_SYNTAX);\n+    List<String> optionalParametersStrings =\n+        optionalParameterBytes.stream()\n+            .map(item -> Coder.bytesToString(item).toUpperCase())\n+            .collect(Collectors.toList());\n+\n+    throwExceptionIfUnknownParameter(optionalParametersStrings);\n+    throwExceptionIfIncompatableParamaterOptions(optionalParametersStrings);\n+\n+    if (optionalParametersStrings.contains(\"KEEPTL\")) {\n+      keepTTL = true;\n+    }\n+\n+    if (optionalParametersStrings.contains(\"PX\")) {\n+      int index = optionalParametersStrings.indexOf(\"PX\");\n+\n+      if (optionalParametersStrings.size() <= index + 1) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+\n+      String expirationTime = optionalParametersStrings.get(index + 1);\n+      expiration = parseExpirationTime(\"PX\", expirationTime);\n+\n+    } else if (optionalParametersStrings.contains(\"EX\")) {\n+      int index = optionalParametersStrings.indexOf(\"EX\");\n+\n+      if (optionalParametersStrings.size() <= index + 1) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n       }\n+\n+      String expirationTime = optionalParametersStrings.get(index + 1);\n+      expiration = parseExpirationTime(\"EX\", expirationTime);\n+    }\n+\n+    if (optionalParametersStrings.contains(\"NX\")) {\n+      existsOption = SetOptions.Exists.NX;\n+    } else if (optionalParametersStrings.contains(\"XX\")) {\n+      existsOption = SetOptions.Exists.XX;\n     }\n \n     return new SetOptions(existsOption, expiration, keepTTL);\n   }\n \n-  private long parseExpirationTime(int index, List<byte[]> commandElems)\n-      throws IllegalArgumentException {\n-    String expirationString;\n \n-    try {\n-      expirationString = Coder.bytesToString(commandElems.get(index));\n-    } catch (IndexOutOfBoundsException e) {\n+  private void throwExceptionIfUnknownParameter(List<String> optionalParameters) {\n+    List<String> validOptionalParamaters = Arrays.asList(\"EX\", \"PX\", \"NX\", \"XX\", \"KEEPTL\");\n+\n+    List<String> parametersInQuestion =\n+        optionalParameters\n+            .stream()\n+            .filter(parameter -> (!validOptionalParamaters.contains(parameter)))\n+            .collect(Collectors.toList());\n+\n+    parametersInQuestion.forEach(parameter -> throwErrorIfNotANumberInExpectedPosition(\n+        parameter,\n+        optionalParameters));\n+  }\n+\n+\n+  private void throwErrorIfNotANumberInExpectedPosition(\n+      String parameter,\n+      List<String> optionalParameters) {\n+\n+    if (previousOptionIsValidAndExpectsANumber(parameter, optionalParameters)) {\n+      convertToLongOrThrowException(parameter);\n+    } else {\n       throw new IllegalArgumentException(ERROR_SYNTAX);\n     }\n \n+  }\n+\n+\n+  private boolean previousOptionIsValidAndExpectsANumber(String paramter,\n+      List<String> optionalParameters) {\n+    List<String> validParamaters = Arrays.asList(\"EX\", \"PX\");\n+\n+    if (optionalParameters.size() < 2) {\n+      return false;\n+    }\n+\n+    int indexOfParameter = optionalParameters.indexOf(paramter);\n+    String previousParameter = optionalParameters.get(indexOfParameter - 1);\n+\n+    return validParamaters.contains(previousParameter);\n+  }\n+\n+\n+  private void throwExceptionIfIncompatableParamaterOptions(List<String> passedParametersStrings) {\n+\n+    if (passedParametersStrings.contains(\"PX\")\n+        && passedParametersStrings.contains(\"EX\")) {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+\n+    if (passedParametersStrings.contains(\"XX\")\n+        && passedParametersStrings.contains(\"NX\")) {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+  }\n+\n+  private long parseExpirationTime(String expirationParameter, String expirationTimeString)\n+      throws IllegalArgumentException {\n+\n+    long expirationTimeLong =\n+        convertToLongOrThrowException(expirationTimeString);\n+\n+    isExpirationTimeLegal(expirationTimeLong);\n+\n+    if (expirationParameter.equals(\"EX\")) {\n+      expirationTimeLong *= 1000;\n+    } else if (!expirationParameter.equals(\"PX\")) {\n+      throw new IllegalArgumentException(ERROR_NOT_INTEGER);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxOTMxNA=="}, "originalCommit": {"oid": "d52ff497d17a27652a5bdc573b49474e446c7a92"}, "originalPosition": 208}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMzQ2MDc0OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwMDowMjo1N1rOGfcPbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMjoxMjowNFrOGf-xSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYyMTc0Mw==", "bodyText": "consider having a method called getNextParameter(\"PX\") which would do the indexOf, the size check and the get and return it. Then this type of code could look like:\nif (optionalParametersStrings.contains(\"PX\")) {\nString expirationTime = getNextParameter(optionalParametersStrings, \"PX\");", "url": "https://github.com/apache/geode/pull/5216#discussion_r435621743", "createdAt": "2020-06-05T00:02:57Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "diffHunk": "@@ -68,72 +75,141 @@ private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n     return new ByteArrayWrapper(value);\n   }\n \n+  private SetOptions parseOptionalParameters(List<byte[]> optionalParameterBytes)\n+      throws IllegalArgumentException {\n \n-  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {\n     boolean keepTTL = false;\n     SetOptions.Exists existsOption = SetOptions.Exists.NONE;\n     long expiration = 0L;\n \n-    for (int i = 3; i < commandElems.size(); i++) {\n-      String current_arg = Coder.bytesToString(commandElems.get(i)).toUpperCase();\n-      switch (current_arg) {\n-        case \"KEEPTTL\":\n-          keepTTL = true;\n-          break;\n-        case \"EX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          expiration = SECONDS.toMillis(expiration);\n-          break;\n-        case \"PX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          break;\n-        case \"NX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.NX;\n-          break;\n-        case \"XX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.XX;\n-          break;\n-        default:\n-          throw new IllegalArgumentException(ERROR_SYNTAX);\n+    List<String> optionalParametersStrings =\n+        optionalParameterBytes.stream()\n+            .map(item -> Coder.bytesToString(item).toUpperCase())\n+            .collect(Collectors.toList());\n+\n+    throwExceptionIfUnknownParameter(optionalParametersStrings);\n+    throwExceptionIfIncompatableParamaterOptions(optionalParametersStrings);\n+\n+    if (optionalParametersStrings.contains(\"KEEPTL\")) {\n+      keepTTL = true;\n+    }\n+\n+    if (optionalParametersStrings.contains(\"PX\")) {\n+      int index = optionalParametersStrings.indexOf(\"PX\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d52ff497d17a27652a5bdc573b49474e446c7a92"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE4NzQ2Ng==", "bodyText": "done - thanks", "url": "https://github.com/apache/geode/pull/5216#discussion_r436187466", "createdAt": "2020-06-05T22:12:04Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "diffHunk": "@@ -68,72 +75,141 @@ private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n     return new ByteArrayWrapper(value);\n   }\n \n+  private SetOptions parseOptionalParameters(List<byte[]> optionalParameterBytes)\n+      throws IllegalArgumentException {\n \n-  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {\n     boolean keepTTL = false;\n     SetOptions.Exists existsOption = SetOptions.Exists.NONE;\n     long expiration = 0L;\n \n-    for (int i = 3; i < commandElems.size(); i++) {\n-      String current_arg = Coder.bytesToString(commandElems.get(i)).toUpperCase();\n-      switch (current_arg) {\n-        case \"KEEPTTL\":\n-          keepTTL = true;\n-          break;\n-        case \"EX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          expiration = SECONDS.toMillis(expiration);\n-          break;\n-        case \"PX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          break;\n-        case \"NX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.NX;\n-          break;\n-        case \"XX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.XX;\n-          break;\n-        default:\n-          throw new IllegalArgumentException(ERROR_SYNTAX);\n+    List<String> optionalParametersStrings =\n+        optionalParameterBytes.stream()\n+            .map(item -> Coder.bytesToString(item).toUpperCase())\n+            .collect(Collectors.toList());\n+\n+    throwExceptionIfUnknownParameter(optionalParametersStrings);\n+    throwExceptionIfIncompatableParamaterOptions(optionalParametersStrings);\n+\n+    if (optionalParametersStrings.contains(\"KEEPTL\")) {\n+      keepTTL = true;\n+    }\n+\n+    if (optionalParametersStrings.contains(\"PX\")) {\n+      int index = optionalParametersStrings.indexOf(\"PX\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYyMTc0Mw=="}, "originalCommit": {"oid": "d52ff497d17a27652a5bdc573b49474e446c7a92"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjE3MjE3OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNzoxODoxM1rOGf2wJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxODowMzowNVrOGf4LzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1NjEwMA==", "bodyText": "This could be simplified to:\nkeepTTL = optionalParametersStrings.contains(\"KEEPTL\");", "url": "https://github.com/apache/geode/pull/5216#discussion_r436056100", "createdAt": "2020-06-05T17:18:13Z", "author": {"login": "jdeppe-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "diffHunk": "@@ -68,72 +75,141 @@ private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n     return new ByteArrayWrapper(value);\n   }\n \n+  private SetOptions parseOptionalParameters(List<byte[]> optionalParameterBytes)\n+      throws IllegalArgumentException {\n \n-  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {\n     boolean keepTTL = false;\n     SetOptions.Exists existsOption = SetOptions.Exists.NONE;\n     long expiration = 0L;\n \n-    for (int i = 3; i < commandElems.size(); i++) {\n-      String current_arg = Coder.bytesToString(commandElems.get(i)).toUpperCase();\n-      switch (current_arg) {\n-        case \"KEEPTTL\":\n-          keepTTL = true;\n-          break;\n-        case \"EX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          expiration = SECONDS.toMillis(expiration);\n-          break;\n-        case \"PX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          break;\n-        case \"NX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.NX;\n-          break;\n-        case \"XX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.XX;\n-          break;\n-        default:\n-          throw new IllegalArgumentException(ERROR_SYNTAX);\n+    List<String> optionalParametersStrings =\n+        optionalParameterBytes.stream()\n+            .map(item -> Coder.bytesToString(item).toUpperCase())\n+            .collect(Collectors.toList());\n+\n+    throwExceptionIfUnknownParameter(optionalParametersStrings);\n+    throwExceptionIfIncompatableParamaterOptions(optionalParametersStrings);\n+\n+    if (optionalParametersStrings.contains(\"KEEPTL\")) {\n+      keepTTL = true;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d52ff497d17a27652a5bdc573b49474e446c7a92"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3OTU2NA==", "bodyText": "thanks. done", "url": "https://github.com/apache/geode/pull/5216#discussion_r436079564", "createdAt": "2020-06-05T18:03:05Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "diffHunk": "@@ -68,72 +75,141 @@ private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n     return new ByteArrayWrapper(value);\n   }\n \n+  private SetOptions parseOptionalParameters(List<byte[]> optionalParameterBytes)\n+      throws IllegalArgumentException {\n \n-  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {\n     boolean keepTTL = false;\n     SetOptions.Exists existsOption = SetOptions.Exists.NONE;\n     long expiration = 0L;\n \n-    for (int i = 3; i < commandElems.size(); i++) {\n-      String current_arg = Coder.bytesToString(commandElems.get(i)).toUpperCase();\n-      switch (current_arg) {\n-        case \"KEEPTTL\":\n-          keepTTL = true;\n-          break;\n-        case \"EX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          expiration = SECONDS.toMillis(expiration);\n-          break;\n-        case \"PX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          break;\n-        case \"NX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.NX;\n-          break;\n-        case \"XX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.XX;\n-          break;\n-        default:\n-          throw new IllegalArgumentException(ERROR_SYNTAX);\n+    List<String> optionalParametersStrings =\n+        optionalParameterBytes.stream()\n+            .map(item -> Coder.bytesToString(item).toUpperCase())\n+            .collect(Collectors.toList());\n+\n+    throwExceptionIfUnknownParameter(optionalParametersStrings);\n+    throwExceptionIfIncompatableParamaterOptions(optionalParametersStrings);\n+\n+    if (optionalParametersStrings.contains(\"KEEPTL\")) {\n+      keepTTL = true;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1NjEwMA=="}, "originalCommit": {"oid": "d52ff497d17a27652a5bdc573b49474e446c7a92"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTQxMzQ1OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzowNjo1NlrOGiJKNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMDoyNzo1MlrOGitrUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1NDgzOQ==", "bodyText": "Change \"KEEPTL\" to \"KEEPTTL\"", "url": "https://github.com/apache/geode/pull/5216#discussion_r438454839", "createdAt": "2020-06-10T23:06:56Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "diffHunk": "@@ -35,105 +37,182 @@\n   public RedisResponse executeCommandWithResponse(Command command,\n       ExecutionHandlerContext context) {\n \n-    List<byte[]> commandElems = command.getProcessedCommand();\n     ByteArrayWrapper keyToSet = command.getKey();\n-    ByteArrayWrapper valueToSet = getValueToSet(commandElems);\n-\n+    List<byte[]> commandElementsBytes = command.getProcessedCommand();\n+    List<byte[]> optionalParameterBytes = getOptionalParameters(commandElementsBytes);\n+    ByteArrayWrapper valueToSet = getValueToSet(commandElementsBytes);\n     RedisStringCommands redisStringCommands = getRedisStringCommands(context);\n     SetOptions setOptions;\n+\n     try {\n-      setOptions = parseCommandElems(commandElems);\n+      setOptions = parseOptionalParameters(optionalParameterBytes);\n     } catch (IllegalArgumentException ex) {\n       return RedisResponse.error(ex.getMessage());\n     }\n \n-    return doSet(command, context, keyToSet, valueToSet, redisStringCommands, setOptions);\n+    return doSet(keyToSet, valueToSet, redisStringCommands, setOptions);\n+  }\n+\n+  private List<byte[]> getOptionalParameters(List<byte[]> commandElementsBytes) {\n+    return commandElementsBytes.subList(3, commandElementsBytes.size());\n   }\n \n-  private RedisResponse doSet(Command command, ExecutionHandlerContext context,\n-      ByteArrayWrapper key,\n-      ByteArrayWrapper value, RedisStringCommands redisStringCommands, SetOptions setOptions) {\n+  private RedisResponse doSet(ByteArrayWrapper key,\n+      ByteArrayWrapper value,\n+      RedisStringCommands redisStringCommands,\n+      SetOptions setOptions) {\n \n-    boolean result = redisStringCommands.set(key, value, setOptions);\n+    boolean setCompletedSuccessfully = redisStringCommands.set(key, value, setOptions);\n \n-    if (result) {\n+    if (setCompletedSuccessfully) {\n       return RedisResponse.string(SUCCESS);\n+    } else {\n+      return RedisResponse.nil();\n     }\n-\n-    return RedisResponse.nil();\n   }\n \n   private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n     byte[] value = commandElems.get(2);\n     return new ByteArrayWrapper(value);\n   }\n \n+  private SetOptions parseOptionalParameters(List<byte[]> optionalParameterBytes)\n+      throws IllegalArgumentException {\n \n-  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {\n     boolean keepTTL = false;\n     SetOptions.Exists existsOption = SetOptions.Exists.NONE;\n     long expiration = 0L;\n \n-    for (int i = 3; i < commandElems.size(); i++) {\n-      String current_arg = Coder.bytesToString(commandElems.get(i)).toUpperCase();\n-      switch (current_arg) {\n-        case \"KEEPTTL\":\n-          keepTTL = true;\n-          break;\n-        case \"EX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          expiration = SECONDS.toMillis(expiration);\n-          break;\n-        case \"PX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          break;\n-        case \"NX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.NX;\n-          break;\n-        case \"XX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.XX;\n-          break;\n-        default:\n-          throw new IllegalArgumentException(ERROR_SYNTAX);\n+    List<String> optionalParametersStrings =\n+        optionalParameterBytes.stream()\n+            .map(item -> Coder.bytesToString(item).toUpperCase())\n+            .collect(Collectors.toList());\n+\n+    throwExceptionIfUnknownParameter(optionalParametersStrings);\n+    throwExceptionIfIncompatableParamaterOptions(optionalParametersStrings);\n+    keepTTL = optionalParametersStrings.contains(\"KEEPTL\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d1ac779762f879de28bbee4a8f9ad0803357b7c"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA1MzEzOA==", "bodyText": "thanks- I'll look into why no test caught this...", "url": "https://github.com/apache/geode/pull/5216#discussion_r439053138", "createdAt": "2020-06-11T20:27:52Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "diffHunk": "@@ -35,105 +37,182 @@\n   public RedisResponse executeCommandWithResponse(Command command,\n       ExecutionHandlerContext context) {\n \n-    List<byte[]> commandElems = command.getProcessedCommand();\n     ByteArrayWrapper keyToSet = command.getKey();\n-    ByteArrayWrapper valueToSet = getValueToSet(commandElems);\n-\n+    List<byte[]> commandElementsBytes = command.getProcessedCommand();\n+    List<byte[]> optionalParameterBytes = getOptionalParameters(commandElementsBytes);\n+    ByteArrayWrapper valueToSet = getValueToSet(commandElementsBytes);\n     RedisStringCommands redisStringCommands = getRedisStringCommands(context);\n     SetOptions setOptions;\n+\n     try {\n-      setOptions = parseCommandElems(commandElems);\n+      setOptions = parseOptionalParameters(optionalParameterBytes);\n     } catch (IllegalArgumentException ex) {\n       return RedisResponse.error(ex.getMessage());\n     }\n \n-    return doSet(command, context, keyToSet, valueToSet, redisStringCommands, setOptions);\n+    return doSet(keyToSet, valueToSet, redisStringCommands, setOptions);\n+  }\n+\n+  private List<byte[]> getOptionalParameters(List<byte[]> commandElementsBytes) {\n+    return commandElementsBytes.subList(3, commandElementsBytes.size());\n   }\n \n-  private RedisResponse doSet(Command command, ExecutionHandlerContext context,\n-      ByteArrayWrapper key,\n-      ByteArrayWrapper value, RedisStringCommands redisStringCommands, SetOptions setOptions) {\n+  private RedisResponse doSet(ByteArrayWrapper key,\n+      ByteArrayWrapper value,\n+      RedisStringCommands redisStringCommands,\n+      SetOptions setOptions) {\n \n-    boolean result = redisStringCommands.set(key, value, setOptions);\n+    boolean setCompletedSuccessfully = redisStringCommands.set(key, value, setOptions);\n \n-    if (result) {\n+    if (setCompletedSuccessfully) {\n       return RedisResponse.string(SUCCESS);\n+    } else {\n+      return RedisResponse.nil();\n     }\n-\n-    return RedisResponse.nil();\n   }\n \n   private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n     byte[] value = commandElems.get(2);\n     return new ByteArrayWrapper(value);\n   }\n \n+  private SetOptions parseOptionalParameters(List<byte[]> optionalParameterBytes)\n+      throws IllegalArgumentException {\n \n-  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {\n     boolean keepTTL = false;\n     SetOptions.Exists existsOption = SetOptions.Exists.NONE;\n     long expiration = 0L;\n \n-    for (int i = 3; i < commandElems.size(); i++) {\n-      String current_arg = Coder.bytesToString(commandElems.get(i)).toUpperCase();\n-      switch (current_arg) {\n-        case \"KEEPTTL\":\n-          keepTTL = true;\n-          break;\n-        case \"EX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          expiration = SECONDS.toMillis(expiration);\n-          break;\n-        case \"PX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          break;\n-        case \"NX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.NX;\n-          break;\n-        case \"XX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.XX;\n-          break;\n-        default:\n-          throw new IllegalArgumentException(ERROR_SYNTAX);\n+    List<String> optionalParametersStrings =\n+        optionalParameterBytes.stream()\n+            .map(item -> Coder.bytesToString(item).toUpperCase())\n+            .collect(Collectors.toList());\n+\n+    throwExceptionIfUnknownParameter(optionalParametersStrings);\n+    throwExceptionIfIncompatableParamaterOptions(optionalParametersStrings);\n+    keepTTL = optionalParametersStrings.contains(\"KEEPTL\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1NDgzOQ=="}, "originalCommit": {"oid": "3d1ac779762f879de28bbee4a8f9ad0803357b7c"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTQxOTY3OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzowOTo1MFrOGiJN0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMDozMjo1M1rOGit0SA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1NTc2MQ==", "bodyText": "change \"KEEPTL\" to \"KEEPTTL\"", "url": "https://github.com/apache/geode/pull/5216#discussion_r438455761", "createdAt": "2020-06-10T23:09:50Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "diffHunk": "@@ -35,105 +37,182 @@\n   public RedisResponse executeCommandWithResponse(Command command,\n       ExecutionHandlerContext context) {\n \n-    List<byte[]> commandElems = command.getProcessedCommand();\n     ByteArrayWrapper keyToSet = command.getKey();\n-    ByteArrayWrapper valueToSet = getValueToSet(commandElems);\n-\n+    List<byte[]> commandElementsBytes = command.getProcessedCommand();\n+    List<byte[]> optionalParameterBytes = getOptionalParameters(commandElementsBytes);\n+    ByteArrayWrapper valueToSet = getValueToSet(commandElementsBytes);\n     RedisStringCommands redisStringCommands = getRedisStringCommands(context);\n     SetOptions setOptions;\n+\n     try {\n-      setOptions = parseCommandElems(commandElems);\n+      setOptions = parseOptionalParameters(optionalParameterBytes);\n     } catch (IllegalArgumentException ex) {\n       return RedisResponse.error(ex.getMessage());\n     }\n \n-    return doSet(command, context, keyToSet, valueToSet, redisStringCommands, setOptions);\n+    return doSet(keyToSet, valueToSet, redisStringCommands, setOptions);\n+  }\n+\n+  private List<byte[]> getOptionalParameters(List<byte[]> commandElementsBytes) {\n+    return commandElementsBytes.subList(3, commandElementsBytes.size());\n   }\n \n-  private RedisResponse doSet(Command command, ExecutionHandlerContext context,\n-      ByteArrayWrapper key,\n-      ByteArrayWrapper value, RedisStringCommands redisStringCommands, SetOptions setOptions) {\n+  private RedisResponse doSet(ByteArrayWrapper key,\n+      ByteArrayWrapper value,\n+      RedisStringCommands redisStringCommands,\n+      SetOptions setOptions) {\n \n-    boolean result = redisStringCommands.set(key, value, setOptions);\n+    boolean setCompletedSuccessfully = redisStringCommands.set(key, value, setOptions);\n \n-    if (result) {\n+    if (setCompletedSuccessfully) {\n       return RedisResponse.string(SUCCESS);\n+    } else {\n+      return RedisResponse.nil();\n     }\n-\n-    return RedisResponse.nil();\n   }\n \n   private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n     byte[] value = commandElems.get(2);\n     return new ByteArrayWrapper(value);\n   }\n \n+  private SetOptions parseOptionalParameters(List<byte[]> optionalParameterBytes)\n+      throws IllegalArgumentException {\n \n-  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {\n     boolean keepTTL = false;\n     SetOptions.Exists existsOption = SetOptions.Exists.NONE;\n     long expiration = 0L;\n \n-    for (int i = 3; i < commandElems.size(); i++) {\n-      String current_arg = Coder.bytesToString(commandElems.get(i)).toUpperCase();\n-      switch (current_arg) {\n-        case \"KEEPTTL\":\n-          keepTTL = true;\n-          break;\n-        case \"EX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          expiration = SECONDS.toMillis(expiration);\n-          break;\n-        case \"PX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          break;\n-        case \"NX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.NX;\n-          break;\n-        case \"XX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.XX;\n-          break;\n-        default:\n-          throw new IllegalArgumentException(ERROR_SYNTAX);\n+    List<String> optionalParametersStrings =\n+        optionalParameterBytes.stream()\n+            .map(item -> Coder.bytesToString(item).toUpperCase())\n+            .collect(Collectors.toList());\n+\n+    throwExceptionIfUnknownParameter(optionalParametersStrings);\n+    throwExceptionIfIncompatableParamaterOptions(optionalParametersStrings);\n+    keepTTL = optionalParametersStrings.contains(\"KEEPTL\");\n+\n+    if (optionalParametersStrings.contains(\"PX\")) {\n+      String nextParameter =\n+          getNextParameter(\"PX\", optionalParametersStrings);\n+\n+      if (!isANumber(nextParameter)) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+\n+      expiration = parseExpirationTime(\"PX\", nextParameter);\n+      if (expiration <= 0) {\n+        throw new IllegalArgumentException(ERROR_INVALID_EXPIRE_TIME);\n+      }\n+\n+    } else if (optionalParametersStrings.contains(\"EX\")) {\n+      String nextParameter =\n+          getNextParameter(\"EX\", optionalParametersStrings);\n+      if (!isANumber(nextParameter)) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+      expiration = parseExpirationTime(\"EX\", nextParameter);\n+      if (expiration <= 0) {\n+        throw new IllegalArgumentException(ERROR_INVALID_EXPIRE_TIME);\n       }\n     }\n \n+    if (optionalParametersStrings.contains(\"NX\")) {\n+      existsOption = SetOptions.Exists.NX;\n+    } else if (optionalParametersStrings.contains(\"XX\")) {\n+      existsOption = SetOptions.Exists.XX;\n+    }\n     return new SetOptions(existsOption, expiration, keepTTL);\n   }\n \n-  private long parseExpirationTime(int index, List<byte[]> commandElems)\n-      throws IllegalArgumentException {\n-    String expirationString;\n+  private String getNextParameter(String currentParameter,\n+      List<String> optionalParametersStrings) {\n+    int index = optionalParametersStrings.indexOf(currentParameter);\n+    if (optionalParametersStrings.size() <= index + 1) {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+    return optionalParametersStrings.get(index + 1);\n+  }\n+\n+  private void throwExceptionIfUnknownParameter(List<String> optionalParameters) {\n+    List<String> validOptionalParamaters = Arrays.asList(\"EX\", \"PX\", \"NX\", \"XX\", \"KEEPTL\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d1ac779762f879de28bbee4a8f9ad0803357b7c"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA1NTQzMg==", "bodyText": "same", "url": "https://github.com/apache/geode/pull/5216#discussion_r439055432", "createdAt": "2020-06-11T20:32:53Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "diffHunk": "@@ -35,105 +37,182 @@\n   public RedisResponse executeCommandWithResponse(Command command,\n       ExecutionHandlerContext context) {\n \n-    List<byte[]> commandElems = command.getProcessedCommand();\n     ByteArrayWrapper keyToSet = command.getKey();\n-    ByteArrayWrapper valueToSet = getValueToSet(commandElems);\n-\n+    List<byte[]> commandElementsBytes = command.getProcessedCommand();\n+    List<byte[]> optionalParameterBytes = getOptionalParameters(commandElementsBytes);\n+    ByteArrayWrapper valueToSet = getValueToSet(commandElementsBytes);\n     RedisStringCommands redisStringCommands = getRedisStringCommands(context);\n     SetOptions setOptions;\n+\n     try {\n-      setOptions = parseCommandElems(commandElems);\n+      setOptions = parseOptionalParameters(optionalParameterBytes);\n     } catch (IllegalArgumentException ex) {\n       return RedisResponse.error(ex.getMessage());\n     }\n \n-    return doSet(command, context, keyToSet, valueToSet, redisStringCommands, setOptions);\n+    return doSet(keyToSet, valueToSet, redisStringCommands, setOptions);\n+  }\n+\n+  private List<byte[]> getOptionalParameters(List<byte[]> commandElementsBytes) {\n+    return commandElementsBytes.subList(3, commandElementsBytes.size());\n   }\n \n-  private RedisResponse doSet(Command command, ExecutionHandlerContext context,\n-      ByteArrayWrapper key,\n-      ByteArrayWrapper value, RedisStringCommands redisStringCommands, SetOptions setOptions) {\n+  private RedisResponse doSet(ByteArrayWrapper key,\n+      ByteArrayWrapper value,\n+      RedisStringCommands redisStringCommands,\n+      SetOptions setOptions) {\n \n-    boolean result = redisStringCommands.set(key, value, setOptions);\n+    boolean setCompletedSuccessfully = redisStringCommands.set(key, value, setOptions);\n \n-    if (result) {\n+    if (setCompletedSuccessfully) {\n       return RedisResponse.string(SUCCESS);\n+    } else {\n+      return RedisResponse.nil();\n     }\n-\n-    return RedisResponse.nil();\n   }\n \n   private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n     byte[] value = commandElems.get(2);\n     return new ByteArrayWrapper(value);\n   }\n \n+  private SetOptions parseOptionalParameters(List<byte[]> optionalParameterBytes)\n+      throws IllegalArgumentException {\n \n-  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {\n     boolean keepTTL = false;\n     SetOptions.Exists existsOption = SetOptions.Exists.NONE;\n     long expiration = 0L;\n \n-    for (int i = 3; i < commandElems.size(); i++) {\n-      String current_arg = Coder.bytesToString(commandElems.get(i)).toUpperCase();\n-      switch (current_arg) {\n-        case \"KEEPTTL\":\n-          keepTTL = true;\n-          break;\n-        case \"EX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          expiration = SECONDS.toMillis(expiration);\n-          break;\n-        case \"PX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          break;\n-        case \"NX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.NX;\n-          break;\n-        case \"XX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.XX;\n-          break;\n-        default:\n-          throw new IllegalArgumentException(ERROR_SYNTAX);\n+    List<String> optionalParametersStrings =\n+        optionalParameterBytes.stream()\n+            .map(item -> Coder.bytesToString(item).toUpperCase())\n+            .collect(Collectors.toList());\n+\n+    throwExceptionIfUnknownParameter(optionalParametersStrings);\n+    throwExceptionIfIncompatableParamaterOptions(optionalParametersStrings);\n+    keepTTL = optionalParametersStrings.contains(\"KEEPTL\");\n+\n+    if (optionalParametersStrings.contains(\"PX\")) {\n+      String nextParameter =\n+          getNextParameter(\"PX\", optionalParametersStrings);\n+\n+      if (!isANumber(nextParameter)) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+\n+      expiration = parseExpirationTime(\"PX\", nextParameter);\n+      if (expiration <= 0) {\n+        throw new IllegalArgumentException(ERROR_INVALID_EXPIRE_TIME);\n+      }\n+\n+    } else if (optionalParametersStrings.contains(\"EX\")) {\n+      String nextParameter =\n+          getNextParameter(\"EX\", optionalParametersStrings);\n+      if (!isANumber(nextParameter)) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+      expiration = parseExpirationTime(\"EX\", nextParameter);\n+      if (expiration <= 0) {\n+        throw new IllegalArgumentException(ERROR_INVALID_EXPIRE_TIME);\n       }\n     }\n \n+    if (optionalParametersStrings.contains(\"NX\")) {\n+      existsOption = SetOptions.Exists.NX;\n+    } else if (optionalParametersStrings.contains(\"XX\")) {\n+      existsOption = SetOptions.Exists.XX;\n+    }\n     return new SetOptions(existsOption, expiration, keepTTL);\n   }\n \n-  private long parseExpirationTime(int index, List<byte[]> commandElems)\n-      throws IllegalArgumentException {\n-    String expirationString;\n+  private String getNextParameter(String currentParameter,\n+      List<String> optionalParametersStrings) {\n+    int index = optionalParametersStrings.indexOf(currentParameter);\n+    if (optionalParametersStrings.size() <= index + 1) {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+    return optionalParametersStrings.get(index + 1);\n+  }\n+\n+  private void throwExceptionIfUnknownParameter(List<String> optionalParameters) {\n+    List<String> validOptionalParamaters = Arrays.asList(\"EX\", \"PX\", \"NX\", \"XX\", \"KEEPTL\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1NTc2MQ=="}, "originalCommit": {"oid": "3d1ac779762f879de28bbee4a8f9ad0803357b7c"}, "originalPosition": 163}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTQzMTM2OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzoxNTo0NFrOGiJU-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMToyNDowOVrOGivNYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1NzU5NA==", "bodyText": "I don't like that we now call parseLong twice. Once in isANumber and once in parseExpirationTime. Just have parseExpirationTime handle NumberFormatException and throw IllegalArgumentException(ERROR_NOT_INTEGER)", "url": "https://github.com/apache/geode/pull/5216#discussion_r438457594", "createdAt": "2020-06-10T23:15:44Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "diffHunk": "@@ -35,105 +37,182 @@\n   public RedisResponse executeCommandWithResponse(Command command,\n       ExecutionHandlerContext context) {\n \n-    List<byte[]> commandElems = command.getProcessedCommand();\n     ByteArrayWrapper keyToSet = command.getKey();\n-    ByteArrayWrapper valueToSet = getValueToSet(commandElems);\n-\n+    List<byte[]> commandElementsBytes = command.getProcessedCommand();\n+    List<byte[]> optionalParameterBytes = getOptionalParameters(commandElementsBytes);\n+    ByteArrayWrapper valueToSet = getValueToSet(commandElementsBytes);\n     RedisStringCommands redisStringCommands = getRedisStringCommands(context);\n     SetOptions setOptions;\n+\n     try {\n-      setOptions = parseCommandElems(commandElems);\n+      setOptions = parseOptionalParameters(optionalParameterBytes);\n     } catch (IllegalArgumentException ex) {\n       return RedisResponse.error(ex.getMessage());\n     }\n \n-    return doSet(command, context, keyToSet, valueToSet, redisStringCommands, setOptions);\n+    return doSet(keyToSet, valueToSet, redisStringCommands, setOptions);\n+  }\n+\n+  private List<byte[]> getOptionalParameters(List<byte[]> commandElementsBytes) {\n+    return commandElementsBytes.subList(3, commandElementsBytes.size());\n   }\n \n-  private RedisResponse doSet(Command command, ExecutionHandlerContext context,\n-      ByteArrayWrapper key,\n-      ByteArrayWrapper value, RedisStringCommands redisStringCommands, SetOptions setOptions) {\n+  private RedisResponse doSet(ByteArrayWrapper key,\n+      ByteArrayWrapper value,\n+      RedisStringCommands redisStringCommands,\n+      SetOptions setOptions) {\n \n-    boolean result = redisStringCommands.set(key, value, setOptions);\n+    boolean setCompletedSuccessfully = redisStringCommands.set(key, value, setOptions);\n \n-    if (result) {\n+    if (setCompletedSuccessfully) {\n       return RedisResponse.string(SUCCESS);\n+    } else {\n+      return RedisResponse.nil();\n     }\n-\n-    return RedisResponse.nil();\n   }\n \n   private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n     byte[] value = commandElems.get(2);\n     return new ByteArrayWrapper(value);\n   }\n \n+  private SetOptions parseOptionalParameters(List<byte[]> optionalParameterBytes)\n+      throws IllegalArgumentException {\n \n-  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {\n     boolean keepTTL = false;\n     SetOptions.Exists existsOption = SetOptions.Exists.NONE;\n     long expiration = 0L;\n \n-    for (int i = 3; i < commandElems.size(); i++) {\n-      String current_arg = Coder.bytesToString(commandElems.get(i)).toUpperCase();\n-      switch (current_arg) {\n-        case \"KEEPTTL\":\n-          keepTTL = true;\n-          break;\n-        case \"EX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          expiration = SECONDS.toMillis(expiration);\n-          break;\n-        case \"PX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          break;\n-        case \"NX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.NX;\n-          break;\n-        case \"XX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.XX;\n-          break;\n-        default:\n-          throw new IllegalArgumentException(ERROR_SYNTAX);\n+    List<String> optionalParametersStrings =\n+        optionalParameterBytes.stream()\n+            .map(item -> Coder.bytesToString(item).toUpperCase())\n+            .collect(Collectors.toList());\n+\n+    throwExceptionIfUnknownParameter(optionalParametersStrings);\n+    throwExceptionIfIncompatableParamaterOptions(optionalParametersStrings);\n+    keepTTL = optionalParametersStrings.contains(\"KEEPTL\");\n+\n+    if (optionalParametersStrings.contains(\"PX\")) {\n+      String nextParameter =\n+          getNextParameter(\"PX\", optionalParametersStrings);\n+\n+      if (!isANumber(nextParameter)) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+\n+      expiration = parseExpirationTime(\"PX\", nextParameter);\n+      if (expiration <= 0) {\n+        throw new IllegalArgumentException(ERROR_INVALID_EXPIRE_TIME);\n+      }\n+\n+    } else if (optionalParametersStrings.contains(\"EX\")) {\n+      String nextParameter =\n+          getNextParameter(\"EX\", optionalParametersStrings);\n+      if (!isANumber(nextParameter)) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+      expiration = parseExpirationTime(\"EX\", nextParameter);\n+      if (expiration <= 0) {\n+        throw new IllegalArgumentException(ERROR_INVALID_EXPIRE_TIME);\n       }\n     }\n \n+    if (optionalParametersStrings.contains(\"NX\")) {\n+      existsOption = SetOptions.Exists.NX;\n+    } else if (optionalParametersStrings.contains(\"XX\")) {\n+      existsOption = SetOptions.Exists.XX;\n+    }\n     return new SetOptions(existsOption, expiration, keepTTL);\n   }\n \n-  private long parseExpirationTime(int index, List<byte[]> commandElems)\n-      throws IllegalArgumentException {\n-    String expirationString;\n+  private String getNextParameter(String currentParameter,\n+      List<String> optionalParametersStrings) {\n+    int index = optionalParametersStrings.indexOf(currentParameter);\n+    if (optionalParametersStrings.size() <= index + 1) {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+    return optionalParametersStrings.get(index + 1);\n+  }\n+\n+  private void throwExceptionIfUnknownParameter(List<String> optionalParameters) {\n+    List<String> validOptionalParamaters = Arrays.asList(\"EX\", \"PX\", \"NX\", \"XX\", \"KEEPTL\");\n+\n+    List<String> parametersInQuestion =\n+        optionalParameters\n+            .stream()\n+            .filter(parameter -> (!validOptionalParamaters.contains(parameter)))\n+            .collect(Collectors.toList());\n+\n+    parametersInQuestion.forEach(parameter -> throwErrorIfNotANumberInExpectedPosition(\n+        parameter,\n+        optionalParameters));\n+  }\n+\n+  private void throwErrorIfNotANumberInExpectedPosition(\n+      String parameter,\n+      List<String> optionalParameters) {\n+\n+    if (previousOptionIsValidAndExpectsANumber(parameter, optionalParameters)) {\n+      convertToLongOrThrowException(parameter);\n+    } else {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+  }\n \n+  private boolean isANumber(String parameter) {\n     try {\n-      expirationString = Coder.bytesToString(commandElems.get(index));\n-    } catch (IndexOutOfBoundsException e) {\n+      Long.parseLong(parameter);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d1ac779762f879de28bbee4a8f9ad0803357b7c"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3ODI0MA==", "bodyText": "(see below)", "url": "https://github.com/apache/geode/pull/5216#discussion_r439078240", "createdAt": "2020-06-11T21:24:09Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "diffHunk": "@@ -35,105 +37,182 @@\n   public RedisResponse executeCommandWithResponse(Command command,\n       ExecutionHandlerContext context) {\n \n-    List<byte[]> commandElems = command.getProcessedCommand();\n     ByteArrayWrapper keyToSet = command.getKey();\n-    ByteArrayWrapper valueToSet = getValueToSet(commandElems);\n-\n+    List<byte[]> commandElementsBytes = command.getProcessedCommand();\n+    List<byte[]> optionalParameterBytes = getOptionalParameters(commandElementsBytes);\n+    ByteArrayWrapper valueToSet = getValueToSet(commandElementsBytes);\n     RedisStringCommands redisStringCommands = getRedisStringCommands(context);\n     SetOptions setOptions;\n+\n     try {\n-      setOptions = parseCommandElems(commandElems);\n+      setOptions = parseOptionalParameters(optionalParameterBytes);\n     } catch (IllegalArgumentException ex) {\n       return RedisResponse.error(ex.getMessage());\n     }\n \n-    return doSet(command, context, keyToSet, valueToSet, redisStringCommands, setOptions);\n+    return doSet(keyToSet, valueToSet, redisStringCommands, setOptions);\n+  }\n+\n+  private List<byte[]> getOptionalParameters(List<byte[]> commandElementsBytes) {\n+    return commandElementsBytes.subList(3, commandElementsBytes.size());\n   }\n \n-  private RedisResponse doSet(Command command, ExecutionHandlerContext context,\n-      ByteArrayWrapper key,\n-      ByteArrayWrapper value, RedisStringCommands redisStringCommands, SetOptions setOptions) {\n+  private RedisResponse doSet(ByteArrayWrapper key,\n+      ByteArrayWrapper value,\n+      RedisStringCommands redisStringCommands,\n+      SetOptions setOptions) {\n \n-    boolean result = redisStringCommands.set(key, value, setOptions);\n+    boolean setCompletedSuccessfully = redisStringCommands.set(key, value, setOptions);\n \n-    if (result) {\n+    if (setCompletedSuccessfully) {\n       return RedisResponse.string(SUCCESS);\n+    } else {\n+      return RedisResponse.nil();\n     }\n-\n-    return RedisResponse.nil();\n   }\n \n   private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n     byte[] value = commandElems.get(2);\n     return new ByteArrayWrapper(value);\n   }\n \n+  private SetOptions parseOptionalParameters(List<byte[]> optionalParameterBytes)\n+      throws IllegalArgumentException {\n \n-  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {\n     boolean keepTTL = false;\n     SetOptions.Exists existsOption = SetOptions.Exists.NONE;\n     long expiration = 0L;\n \n-    for (int i = 3; i < commandElems.size(); i++) {\n-      String current_arg = Coder.bytesToString(commandElems.get(i)).toUpperCase();\n-      switch (current_arg) {\n-        case \"KEEPTTL\":\n-          keepTTL = true;\n-          break;\n-        case \"EX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          expiration = SECONDS.toMillis(expiration);\n-          break;\n-        case \"PX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          break;\n-        case \"NX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.NX;\n-          break;\n-        case \"XX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.XX;\n-          break;\n-        default:\n-          throw new IllegalArgumentException(ERROR_SYNTAX);\n+    List<String> optionalParametersStrings =\n+        optionalParameterBytes.stream()\n+            .map(item -> Coder.bytesToString(item).toUpperCase())\n+            .collect(Collectors.toList());\n+\n+    throwExceptionIfUnknownParameter(optionalParametersStrings);\n+    throwExceptionIfIncompatableParamaterOptions(optionalParametersStrings);\n+    keepTTL = optionalParametersStrings.contains(\"KEEPTL\");\n+\n+    if (optionalParametersStrings.contains(\"PX\")) {\n+      String nextParameter =\n+          getNextParameter(\"PX\", optionalParametersStrings);\n+\n+      if (!isANumber(nextParameter)) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+\n+      expiration = parseExpirationTime(\"PX\", nextParameter);\n+      if (expiration <= 0) {\n+        throw new IllegalArgumentException(ERROR_INVALID_EXPIRE_TIME);\n+      }\n+\n+    } else if (optionalParametersStrings.contains(\"EX\")) {\n+      String nextParameter =\n+          getNextParameter(\"EX\", optionalParametersStrings);\n+      if (!isANumber(nextParameter)) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+      expiration = parseExpirationTime(\"EX\", nextParameter);\n+      if (expiration <= 0) {\n+        throw new IllegalArgumentException(ERROR_INVALID_EXPIRE_TIME);\n       }\n     }\n \n+    if (optionalParametersStrings.contains(\"NX\")) {\n+      existsOption = SetOptions.Exists.NX;\n+    } else if (optionalParametersStrings.contains(\"XX\")) {\n+      existsOption = SetOptions.Exists.XX;\n+    }\n     return new SetOptions(existsOption, expiration, keepTTL);\n   }\n \n-  private long parseExpirationTime(int index, List<byte[]> commandElems)\n-      throws IllegalArgumentException {\n-    String expirationString;\n+  private String getNextParameter(String currentParameter,\n+      List<String> optionalParametersStrings) {\n+    int index = optionalParametersStrings.indexOf(currentParameter);\n+    if (optionalParametersStrings.size() <= index + 1) {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+    return optionalParametersStrings.get(index + 1);\n+  }\n+\n+  private void throwExceptionIfUnknownParameter(List<String> optionalParameters) {\n+    List<String> validOptionalParamaters = Arrays.asList(\"EX\", \"PX\", \"NX\", \"XX\", \"KEEPTL\");\n+\n+    List<String> parametersInQuestion =\n+        optionalParameters\n+            .stream()\n+            .filter(parameter -> (!validOptionalParamaters.contains(parameter)))\n+            .collect(Collectors.toList());\n+\n+    parametersInQuestion.forEach(parameter -> throwErrorIfNotANumberInExpectedPosition(\n+        parameter,\n+        optionalParameters));\n+  }\n+\n+  private void throwErrorIfNotANumberInExpectedPosition(\n+      String parameter,\n+      List<String> optionalParameters) {\n+\n+    if (previousOptionIsValidAndExpectsANumber(parameter, optionalParameters)) {\n+      convertToLongOrThrowException(parameter);\n+    } else {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+  }\n \n+  private boolean isANumber(String parameter) {\n     try {\n-      expirationString = Coder.bytesToString(commandElems.get(index));\n-    } catch (IndexOutOfBoundsException e) {\n+      Long.parseLong(parameter);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1NzU5NA=="}, "originalCommit": {"oid": "3d1ac779762f879de28bbee4a8f9ad0803357b7c"}, "originalPosition": 191}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTQzMjQ0OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzoxNjoxOVrOGiJVsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMDo1NToxOFrOGiucuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1Nzc3Nw==", "bodyText": "The old code used ERROR_NOT_INTEGER if it was not a number. You have changed that to ERROR_SYNTAX", "url": "https://github.com/apache/geode/pull/5216#discussion_r438457777", "createdAt": "2020-06-10T23:16:19Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "diffHunk": "@@ -35,105 +37,182 @@\n   public RedisResponse executeCommandWithResponse(Command command,\n       ExecutionHandlerContext context) {\n \n-    List<byte[]> commandElems = command.getProcessedCommand();\n     ByteArrayWrapper keyToSet = command.getKey();\n-    ByteArrayWrapper valueToSet = getValueToSet(commandElems);\n-\n+    List<byte[]> commandElementsBytes = command.getProcessedCommand();\n+    List<byte[]> optionalParameterBytes = getOptionalParameters(commandElementsBytes);\n+    ByteArrayWrapper valueToSet = getValueToSet(commandElementsBytes);\n     RedisStringCommands redisStringCommands = getRedisStringCommands(context);\n     SetOptions setOptions;\n+\n     try {\n-      setOptions = parseCommandElems(commandElems);\n+      setOptions = parseOptionalParameters(optionalParameterBytes);\n     } catch (IllegalArgumentException ex) {\n       return RedisResponse.error(ex.getMessage());\n     }\n \n-    return doSet(command, context, keyToSet, valueToSet, redisStringCommands, setOptions);\n+    return doSet(keyToSet, valueToSet, redisStringCommands, setOptions);\n+  }\n+\n+  private List<byte[]> getOptionalParameters(List<byte[]> commandElementsBytes) {\n+    return commandElementsBytes.subList(3, commandElementsBytes.size());\n   }\n \n-  private RedisResponse doSet(Command command, ExecutionHandlerContext context,\n-      ByteArrayWrapper key,\n-      ByteArrayWrapper value, RedisStringCommands redisStringCommands, SetOptions setOptions) {\n+  private RedisResponse doSet(ByteArrayWrapper key,\n+      ByteArrayWrapper value,\n+      RedisStringCommands redisStringCommands,\n+      SetOptions setOptions) {\n \n-    boolean result = redisStringCommands.set(key, value, setOptions);\n+    boolean setCompletedSuccessfully = redisStringCommands.set(key, value, setOptions);\n \n-    if (result) {\n+    if (setCompletedSuccessfully) {\n       return RedisResponse.string(SUCCESS);\n+    } else {\n+      return RedisResponse.nil();\n     }\n-\n-    return RedisResponse.nil();\n   }\n \n   private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n     byte[] value = commandElems.get(2);\n     return new ByteArrayWrapper(value);\n   }\n \n+  private SetOptions parseOptionalParameters(List<byte[]> optionalParameterBytes)\n+      throws IllegalArgumentException {\n \n-  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {\n     boolean keepTTL = false;\n     SetOptions.Exists existsOption = SetOptions.Exists.NONE;\n     long expiration = 0L;\n \n-    for (int i = 3; i < commandElems.size(); i++) {\n-      String current_arg = Coder.bytesToString(commandElems.get(i)).toUpperCase();\n-      switch (current_arg) {\n-        case \"KEEPTTL\":\n-          keepTTL = true;\n-          break;\n-        case \"EX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          expiration = SECONDS.toMillis(expiration);\n-          break;\n-        case \"PX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          break;\n-        case \"NX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.NX;\n-          break;\n-        case \"XX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.XX;\n-          break;\n-        default:\n-          throw new IllegalArgumentException(ERROR_SYNTAX);\n+    List<String> optionalParametersStrings =\n+        optionalParameterBytes.stream()\n+            .map(item -> Coder.bytesToString(item).toUpperCase())\n+            .collect(Collectors.toList());\n+\n+    throwExceptionIfUnknownParameter(optionalParametersStrings);\n+    throwExceptionIfIncompatableParamaterOptions(optionalParametersStrings);\n+    keepTTL = optionalParametersStrings.contains(\"KEEPTL\");\n+\n+    if (optionalParametersStrings.contains(\"PX\")) {\n+      String nextParameter =\n+          getNextParameter(\"PX\", optionalParametersStrings);\n+\n+      if (!isANumber(nextParameter)) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+\n+      expiration = parseExpirationTime(\"PX\", nextParameter);\n+      if (expiration <= 0) {\n+        throw new IllegalArgumentException(ERROR_INVALID_EXPIRE_TIME);\n+      }\n+\n+    } else if (optionalParametersStrings.contains(\"EX\")) {\n+      String nextParameter =\n+          getNextParameter(\"EX\", optionalParametersStrings);\n+      if (!isANumber(nextParameter)) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d1ac779762f879de28bbee4a8f9ad0803357b7c"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2NTc4NA==", "bodyText": "you're right-  just checked native redis.  I'll look into lack of test here, too", "url": "https://github.com/apache/geode/pull/5216#discussion_r439065784", "createdAt": "2020-06-11T20:55:18Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "diffHunk": "@@ -35,105 +37,182 @@\n   public RedisResponse executeCommandWithResponse(Command command,\n       ExecutionHandlerContext context) {\n \n-    List<byte[]> commandElems = command.getProcessedCommand();\n     ByteArrayWrapper keyToSet = command.getKey();\n-    ByteArrayWrapper valueToSet = getValueToSet(commandElems);\n-\n+    List<byte[]> commandElementsBytes = command.getProcessedCommand();\n+    List<byte[]> optionalParameterBytes = getOptionalParameters(commandElementsBytes);\n+    ByteArrayWrapper valueToSet = getValueToSet(commandElementsBytes);\n     RedisStringCommands redisStringCommands = getRedisStringCommands(context);\n     SetOptions setOptions;\n+\n     try {\n-      setOptions = parseCommandElems(commandElems);\n+      setOptions = parseOptionalParameters(optionalParameterBytes);\n     } catch (IllegalArgumentException ex) {\n       return RedisResponse.error(ex.getMessage());\n     }\n \n-    return doSet(command, context, keyToSet, valueToSet, redisStringCommands, setOptions);\n+    return doSet(keyToSet, valueToSet, redisStringCommands, setOptions);\n+  }\n+\n+  private List<byte[]> getOptionalParameters(List<byte[]> commandElementsBytes) {\n+    return commandElementsBytes.subList(3, commandElementsBytes.size());\n   }\n \n-  private RedisResponse doSet(Command command, ExecutionHandlerContext context,\n-      ByteArrayWrapper key,\n-      ByteArrayWrapper value, RedisStringCommands redisStringCommands, SetOptions setOptions) {\n+  private RedisResponse doSet(ByteArrayWrapper key,\n+      ByteArrayWrapper value,\n+      RedisStringCommands redisStringCommands,\n+      SetOptions setOptions) {\n \n-    boolean result = redisStringCommands.set(key, value, setOptions);\n+    boolean setCompletedSuccessfully = redisStringCommands.set(key, value, setOptions);\n \n-    if (result) {\n+    if (setCompletedSuccessfully) {\n       return RedisResponse.string(SUCCESS);\n+    } else {\n+      return RedisResponse.nil();\n     }\n-\n-    return RedisResponse.nil();\n   }\n \n   private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n     byte[] value = commandElems.get(2);\n     return new ByteArrayWrapper(value);\n   }\n \n+  private SetOptions parseOptionalParameters(List<byte[]> optionalParameterBytes)\n+      throws IllegalArgumentException {\n \n-  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {\n     boolean keepTTL = false;\n     SetOptions.Exists existsOption = SetOptions.Exists.NONE;\n     long expiration = 0L;\n \n-    for (int i = 3; i < commandElems.size(); i++) {\n-      String current_arg = Coder.bytesToString(commandElems.get(i)).toUpperCase();\n-      switch (current_arg) {\n-        case \"KEEPTTL\":\n-          keepTTL = true;\n-          break;\n-        case \"EX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          expiration = SECONDS.toMillis(expiration);\n-          break;\n-        case \"PX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          break;\n-        case \"NX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.NX;\n-          break;\n-        case \"XX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.XX;\n-          break;\n-        default:\n-          throw new IllegalArgumentException(ERROR_SYNTAX);\n+    List<String> optionalParametersStrings =\n+        optionalParameterBytes.stream()\n+            .map(item -> Coder.bytesToString(item).toUpperCase())\n+            .collect(Collectors.toList());\n+\n+    throwExceptionIfUnknownParameter(optionalParametersStrings);\n+    throwExceptionIfIncompatableParamaterOptions(optionalParametersStrings);\n+    keepTTL = optionalParametersStrings.contains(\"KEEPTL\");\n+\n+    if (optionalParametersStrings.contains(\"PX\")) {\n+      String nextParameter =\n+          getNextParameter(\"PX\", optionalParametersStrings);\n+\n+      if (!isANumber(nextParameter)) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+\n+      expiration = parseExpirationTime(\"PX\", nextParameter);\n+      if (expiration <= 0) {\n+        throw new IllegalArgumentException(ERROR_INVALID_EXPIRE_TIME);\n+      }\n+\n+    } else if (optionalParametersStrings.contains(\"EX\")) {\n+      String nextParameter =\n+          getNextParameter(\"EX\", optionalParametersStrings);\n+      if (!isANumber(nextParameter)) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1Nzc3Nw=="}, "originalCommit": {"oid": "3d1ac779762f879de28bbee4a8f9ad0803357b7c"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTQzODM1OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzoxOTo0NlrOGiJZlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMTowNToyNFrOGiuusw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1ODc3NQ==", "bodyText": "I think it would be better to do this in the caller that does this for EX. Then you don't need to pass expirationParameter to this method. Its job is just parsing.", "url": "https://github.com/apache/geode/pull/5216#discussion_r438458775", "createdAt": "2020-06-10T23:19:46Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "diffHunk": "@@ -35,105 +37,182 @@\n   public RedisResponse executeCommandWithResponse(Command command,\n       ExecutionHandlerContext context) {\n \n-    List<byte[]> commandElems = command.getProcessedCommand();\n     ByteArrayWrapper keyToSet = command.getKey();\n-    ByteArrayWrapper valueToSet = getValueToSet(commandElems);\n-\n+    List<byte[]> commandElementsBytes = command.getProcessedCommand();\n+    List<byte[]> optionalParameterBytes = getOptionalParameters(commandElementsBytes);\n+    ByteArrayWrapper valueToSet = getValueToSet(commandElementsBytes);\n     RedisStringCommands redisStringCommands = getRedisStringCommands(context);\n     SetOptions setOptions;\n+\n     try {\n-      setOptions = parseCommandElems(commandElems);\n+      setOptions = parseOptionalParameters(optionalParameterBytes);\n     } catch (IllegalArgumentException ex) {\n       return RedisResponse.error(ex.getMessage());\n     }\n \n-    return doSet(command, context, keyToSet, valueToSet, redisStringCommands, setOptions);\n+    return doSet(keyToSet, valueToSet, redisStringCommands, setOptions);\n+  }\n+\n+  private List<byte[]> getOptionalParameters(List<byte[]> commandElementsBytes) {\n+    return commandElementsBytes.subList(3, commandElementsBytes.size());\n   }\n \n-  private RedisResponse doSet(Command command, ExecutionHandlerContext context,\n-      ByteArrayWrapper key,\n-      ByteArrayWrapper value, RedisStringCommands redisStringCommands, SetOptions setOptions) {\n+  private RedisResponse doSet(ByteArrayWrapper key,\n+      ByteArrayWrapper value,\n+      RedisStringCommands redisStringCommands,\n+      SetOptions setOptions) {\n \n-    boolean result = redisStringCommands.set(key, value, setOptions);\n+    boolean setCompletedSuccessfully = redisStringCommands.set(key, value, setOptions);\n \n-    if (result) {\n+    if (setCompletedSuccessfully) {\n       return RedisResponse.string(SUCCESS);\n+    } else {\n+      return RedisResponse.nil();\n     }\n-\n-    return RedisResponse.nil();\n   }\n \n   private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n     byte[] value = commandElems.get(2);\n     return new ByteArrayWrapper(value);\n   }\n \n+  private SetOptions parseOptionalParameters(List<byte[]> optionalParameterBytes)\n+      throws IllegalArgumentException {\n \n-  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {\n     boolean keepTTL = false;\n     SetOptions.Exists existsOption = SetOptions.Exists.NONE;\n     long expiration = 0L;\n \n-    for (int i = 3; i < commandElems.size(); i++) {\n-      String current_arg = Coder.bytesToString(commandElems.get(i)).toUpperCase();\n-      switch (current_arg) {\n-        case \"KEEPTTL\":\n-          keepTTL = true;\n-          break;\n-        case \"EX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          expiration = SECONDS.toMillis(expiration);\n-          break;\n-        case \"PX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          break;\n-        case \"NX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.NX;\n-          break;\n-        case \"XX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.XX;\n-          break;\n-        default:\n-          throw new IllegalArgumentException(ERROR_SYNTAX);\n+    List<String> optionalParametersStrings =\n+        optionalParameterBytes.stream()\n+            .map(item -> Coder.bytesToString(item).toUpperCase())\n+            .collect(Collectors.toList());\n+\n+    throwExceptionIfUnknownParameter(optionalParametersStrings);\n+    throwExceptionIfIncompatableParamaterOptions(optionalParametersStrings);\n+    keepTTL = optionalParametersStrings.contains(\"KEEPTL\");\n+\n+    if (optionalParametersStrings.contains(\"PX\")) {\n+      String nextParameter =\n+          getNextParameter(\"PX\", optionalParametersStrings);\n+\n+      if (!isANumber(nextParameter)) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+\n+      expiration = parseExpirationTime(\"PX\", nextParameter);\n+      if (expiration <= 0) {\n+        throw new IllegalArgumentException(ERROR_INVALID_EXPIRE_TIME);\n+      }\n+\n+    } else if (optionalParametersStrings.contains(\"EX\")) {\n+      String nextParameter =\n+          getNextParameter(\"EX\", optionalParametersStrings);\n+      if (!isANumber(nextParameter)) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+      expiration = parseExpirationTime(\"EX\", nextParameter);\n+      if (expiration <= 0) {\n+        throw new IllegalArgumentException(ERROR_INVALID_EXPIRE_TIME);\n       }\n     }\n \n+    if (optionalParametersStrings.contains(\"NX\")) {\n+      existsOption = SetOptions.Exists.NX;\n+    } else if (optionalParametersStrings.contains(\"XX\")) {\n+      existsOption = SetOptions.Exists.XX;\n+    }\n     return new SetOptions(existsOption, expiration, keepTTL);\n   }\n \n-  private long parseExpirationTime(int index, List<byte[]> commandElems)\n-      throws IllegalArgumentException {\n-    String expirationString;\n+  private String getNextParameter(String currentParameter,\n+      List<String> optionalParametersStrings) {\n+    int index = optionalParametersStrings.indexOf(currentParameter);\n+    if (optionalParametersStrings.size() <= index + 1) {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+    return optionalParametersStrings.get(index + 1);\n+  }\n+\n+  private void throwExceptionIfUnknownParameter(List<String> optionalParameters) {\n+    List<String> validOptionalParamaters = Arrays.asList(\"EX\", \"PX\", \"NX\", \"XX\", \"KEEPTL\");\n+\n+    List<String> parametersInQuestion =\n+        optionalParameters\n+            .stream()\n+            .filter(parameter -> (!validOptionalParamaters.contains(parameter)))\n+            .collect(Collectors.toList());\n+\n+    parametersInQuestion.forEach(parameter -> throwErrorIfNotANumberInExpectedPosition(\n+        parameter,\n+        optionalParameters));\n+  }\n+\n+  private void throwErrorIfNotANumberInExpectedPosition(\n+      String parameter,\n+      List<String> optionalParameters) {\n+\n+    if (previousOptionIsValidAndExpectsANumber(parameter, optionalParameters)) {\n+      convertToLongOrThrowException(parameter);\n+    } else {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+  }\n \n+  private boolean isANumber(String parameter) {\n     try {\n-      expirationString = Coder.bytesToString(commandElems.get(index));\n-    } catch (IndexOutOfBoundsException e) {\n+      Long.parseLong(parameter);\n+      return true;\n+    } catch (NumberFormatException e) {\n+      return false;\n+    }\n+  }\n+\n+  private boolean previousOptionIsValidAndExpectsANumber(String paramter,\n+      List<String> optionalParameters) {\n+\n+    List<String> validParamaters = Arrays.asList(\"EX\", \"PX\");\n+    if (optionalParameters.size() < 2) {\n+      return false;\n+    }\n+\n+    int indexOfParameter = optionalParameters.indexOf(paramter);\n+    String previousParameter = optionalParameters.get(indexOfParameter - 1);\n+\n+    return validParamaters.contains(previousParameter);\n+  }\n+\n+\n+  private void throwExceptionIfIncompatableParamaterOptions(List<String> passedParametersStrings) {\n+\n+    if (passedParametersStrings.contains(\"PX\")\n+        && passedParametersStrings.contains(\"EX\")) {\n       throw new IllegalArgumentException(ERROR_SYNTAX);\n     }\n \n+    if (passedParametersStrings.contains(\"XX\")\n+        && passedParametersStrings.contains(\"NX\")) {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+  }\n+\n+  private long parseExpirationTime(String expirationParameter, String timeUntilExpiration) {\n+\n+    long millisecondsUntilExpirationLong =\n+        Long.parseLong(timeUntilExpiration);\n+\n+    if (expirationParameter.equals(\"EX\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d1ac779762f879de28bbee4a8f9ad0803357b7c"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3MDM4Nw==", "bodyText": "ok-  done (when commit arrives)", "url": "https://github.com/apache/geode/pull/5216#discussion_r439070387", "createdAt": "2020-06-11T21:05:24Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "diffHunk": "@@ -35,105 +37,182 @@\n   public RedisResponse executeCommandWithResponse(Command command,\n       ExecutionHandlerContext context) {\n \n-    List<byte[]> commandElems = command.getProcessedCommand();\n     ByteArrayWrapper keyToSet = command.getKey();\n-    ByteArrayWrapper valueToSet = getValueToSet(commandElems);\n-\n+    List<byte[]> commandElementsBytes = command.getProcessedCommand();\n+    List<byte[]> optionalParameterBytes = getOptionalParameters(commandElementsBytes);\n+    ByteArrayWrapper valueToSet = getValueToSet(commandElementsBytes);\n     RedisStringCommands redisStringCommands = getRedisStringCommands(context);\n     SetOptions setOptions;\n+\n     try {\n-      setOptions = parseCommandElems(commandElems);\n+      setOptions = parseOptionalParameters(optionalParameterBytes);\n     } catch (IllegalArgumentException ex) {\n       return RedisResponse.error(ex.getMessage());\n     }\n \n-    return doSet(command, context, keyToSet, valueToSet, redisStringCommands, setOptions);\n+    return doSet(keyToSet, valueToSet, redisStringCommands, setOptions);\n+  }\n+\n+  private List<byte[]> getOptionalParameters(List<byte[]> commandElementsBytes) {\n+    return commandElementsBytes.subList(3, commandElementsBytes.size());\n   }\n \n-  private RedisResponse doSet(Command command, ExecutionHandlerContext context,\n-      ByteArrayWrapper key,\n-      ByteArrayWrapper value, RedisStringCommands redisStringCommands, SetOptions setOptions) {\n+  private RedisResponse doSet(ByteArrayWrapper key,\n+      ByteArrayWrapper value,\n+      RedisStringCommands redisStringCommands,\n+      SetOptions setOptions) {\n \n-    boolean result = redisStringCommands.set(key, value, setOptions);\n+    boolean setCompletedSuccessfully = redisStringCommands.set(key, value, setOptions);\n \n-    if (result) {\n+    if (setCompletedSuccessfully) {\n       return RedisResponse.string(SUCCESS);\n+    } else {\n+      return RedisResponse.nil();\n     }\n-\n-    return RedisResponse.nil();\n   }\n \n   private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n     byte[] value = commandElems.get(2);\n     return new ByteArrayWrapper(value);\n   }\n \n+  private SetOptions parseOptionalParameters(List<byte[]> optionalParameterBytes)\n+      throws IllegalArgumentException {\n \n-  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {\n     boolean keepTTL = false;\n     SetOptions.Exists existsOption = SetOptions.Exists.NONE;\n     long expiration = 0L;\n \n-    for (int i = 3; i < commandElems.size(); i++) {\n-      String current_arg = Coder.bytesToString(commandElems.get(i)).toUpperCase();\n-      switch (current_arg) {\n-        case \"KEEPTTL\":\n-          keepTTL = true;\n-          break;\n-        case \"EX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          expiration = SECONDS.toMillis(expiration);\n-          break;\n-        case \"PX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          break;\n-        case \"NX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.NX;\n-          break;\n-        case \"XX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.XX;\n-          break;\n-        default:\n-          throw new IllegalArgumentException(ERROR_SYNTAX);\n+    List<String> optionalParametersStrings =\n+        optionalParameterBytes.stream()\n+            .map(item -> Coder.bytesToString(item).toUpperCase())\n+            .collect(Collectors.toList());\n+\n+    throwExceptionIfUnknownParameter(optionalParametersStrings);\n+    throwExceptionIfIncompatableParamaterOptions(optionalParametersStrings);\n+    keepTTL = optionalParametersStrings.contains(\"KEEPTL\");\n+\n+    if (optionalParametersStrings.contains(\"PX\")) {\n+      String nextParameter =\n+          getNextParameter(\"PX\", optionalParametersStrings);\n+\n+      if (!isANumber(nextParameter)) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+\n+      expiration = parseExpirationTime(\"PX\", nextParameter);\n+      if (expiration <= 0) {\n+        throw new IllegalArgumentException(ERROR_INVALID_EXPIRE_TIME);\n+      }\n+\n+    } else if (optionalParametersStrings.contains(\"EX\")) {\n+      String nextParameter =\n+          getNextParameter(\"EX\", optionalParametersStrings);\n+      if (!isANumber(nextParameter)) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+      expiration = parseExpirationTime(\"EX\", nextParameter);\n+      if (expiration <= 0) {\n+        throw new IllegalArgumentException(ERROR_INVALID_EXPIRE_TIME);\n       }\n     }\n \n+    if (optionalParametersStrings.contains(\"NX\")) {\n+      existsOption = SetOptions.Exists.NX;\n+    } else if (optionalParametersStrings.contains(\"XX\")) {\n+      existsOption = SetOptions.Exists.XX;\n+    }\n     return new SetOptions(existsOption, expiration, keepTTL);\n   }\n \n-  private long parseExpirationTime(int index, List<byte[]> commandElems)\n-      throws IllegalArgumentException {\n-    String expirationString;\n+  private String getNextParameter(String currentParameter,\n+      List<String> optionalParametersStrings) {\n+    int index = optionalParametersStrings.indexOf(currentParameter);\n+    if (optionalParametersStrings.size() <= index + 1) {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+    return optionalParametersStrings.get(index + 1);\n+  }\n+\n+  private void throwExceptionIfUnknownParameter(List<String> optionalParameters) {\n+    List<String> validOptionalParamaters = Arrays.asList(\"EX\", \"PX\", \"NX\", \"XX\", \"KEEPTL\");\n+\n+    List<String> parametersInQuestion =\n+        optionalParameters\n+            .stream()\n+            .filter(parameter -> (!validOptionalParamaters.contains(parameter)))\n+            .collect(Collectors.toList());\n+\n+    parametersInQuestion.forEach(parameter -> throwErrorIfNotANumberInExpectedPosition(\n+        parameter,\n+        optionalParameters));\n+  }\n+\n+  private void throwErrorIfNotANumberInExpectedPosition(\n+      String parameter,\n+      List<String> optionalParameters) {\n+\n+    if (previousOptionIsValidAndExpectsANumber(parameter, optionalParameters)) {\n+      convertToLongOrThrowException(parameter);\n+    } else {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+  }\n \n+  private boolean isANumber(String parameter) {\n     try {\n-      expirationString = Coder.bytesToString(commandElems.get(index));\n-    } catch (IndexOutOfBoundsException e) {\n+      Long.parseLong(parameter);\n+      return true;\n+    } catch (NumberFormatException e) {\n+      return false;\n+    }\n+  }\n+\n+  private boolean previousOptionIsValidAndExpectsANumber(String paramter,\n+      List<String> optionalParameters) {\n+\n+    List<String> validParamaters = Arrays.asList(\"EX\", \"PX\");\n+    if (optionalParameters.size() < 2) {\n+      return false;\n+    }\n+\n+    int indexOfParameter = optionalParameters.indexOf(paramter);\n+    String previousParameter = optionalParameters.get(indexOfParameter - 1);\n+\n+    return validParamaters.contains(previousParameter);\n+  }\n+\n+\n+  private void throwExceptionIfIncompatableParamaterOptions(List<String> passedParametersStrings) {\n+\n+    if (passedParametersStrings.contains(\"PX\")\n+        && passedParametersStrings.contains(\"EX\")) {\n       throw new IllegalArgumentException(ERROR_SYNTAX);\n     }\n \n+    if (passedParametersStrings.contains(\"XX\")\n+        && passedParametersStrings.contains(\"NX\")) {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+  }\n+\n+  private long parseExpirationTime(String expirationParameter, String timeUntilExpiration) {\n+\n+    long millisecondsUntilExpirationLong =\n+        Long.parseLong(timeUntilExpiration);\n+\n+    if (expirationParameter.equals(\"EX\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1ODc3NQ=="}, "originalCommit": {"oid": "3d1ac779762f879de28bbee4a8f9ad0803357b7c"}, "originalPosition": 231}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTQ0NjY4OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzoyNDoxM1rOGiJezA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMToyMzo1OVrOGivNHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2MDEwOA==", "bodyText": "so actually it parses the long three times! If you are going to do it here then you should have it also fill a HashMap whose keys are the option that expects a number and whose value is the number. Then this could be used later instead of parsing again.", "url": "https://github.com/apache/geode/pull/5216#discussion_r438460108", "createdAt": "2020-06-10T23:24:13Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "diffHunk": "@@ -35,105 +37,182 @@\n   public RedisResponse executeCommandWithResponse(Command command,\n       ExecutionHandlerContext context) {\n \n-    List<byte[]> commandElems = command.getProcessedCommand();\n     ByteArrayWrapper keyToSet = command.getKey();\n-    ByteArrayWrapper valueToSet = getValueToSet(commandElems);\n-\n+    List<byte[]> commandElementsBytes = command.getProcessedCommand();\n+    List<byte[]> optionalParameterBytes = getOptionalParameters(commandElementsBytes);\n+    ByteArrayWrapper valueToSet = getValueToSet(commandElementsBytes);\n     RedisStringCommands redisStringCommands = getRedisStringCommands(context);\n     SetOptions setOptions;\n+\n     try {\n-      setOptions = parseCommandElems(commandElems);\n+      setOptions = parseOptionalParameters(optionalParameterBytes);\n     } catch (IllegalArgumentException ex) {\n       return RedisResponse.error(ex.getMessage());\n     }\n \n-    return doSet(command, context, keyToSet, valueToSet, redisStringCommands, setOptions);\n+    return doSet(keyToSet, valueToSet, redisStringCommands, setOptions);\n+  }\n+\n+  private List<byte[]> getOptionalParameters(List<byte[]> commandElementsBytes) {\n+    return commandElementsBytes.subList(3, commandElementsBytes.size());\n   }\n \n-  private RedisResponse doSet(Command command, ExecutionHandlerContext context,\n-      ByteArrayWrapper key,\n-      ByteArrayWrapper value, RedisStringCommands redisStringCommands, SetOptions setOptions) {\n+  private RedisResponse doSet(ByteArrayWrapper key,\n+      ByteArrayWrapper value,\n+      RedisStringCommands redisStringCommands,\n+      SetOptions setOptions) {\n \n-    boolean result = redisStringCommands.set(key, value, setOptions);\n+    boolean setCompletedSuccessfully = redisStringCommands.set(key, value, setOptions);\n \n-    if (result) {\n+    if (setCompletedSuccessfully) {\n       return RedisResponse.string(SUCCESS);\n+    } else {\n+      return RedisResponse.nil();\n     }\n-\n-    return RedisResponse.nil();\n   }\n \n   private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n     byte[] value = commandElems.get(2);\n     return new ByteArrayWrapper(value);\n   }\n \n+  private SetOptions parseOptionalParameters(List<byte[]> optionalParameterBytes)\n+      throws IllegalArgumentException {\n \n-  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {\n     boolean keepTTL = false;\n     SetOptions.Exists existsOption = SetOptions.Exists.NONE;\n     long expiration = 0L;\n \n-    for (int i = 3; i < commandElems.size(); i++) {\n-      String current_arg = Coder.bytesToString(commandElems.get(i)).toUpperCase();\n-      switch (current_arg) {\n-        case \"KEEPTTL\":\n-          keepTTL = true;\n-          break;\n-        case \"EX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          expiration = SECONDS.toMillis(expiration);\n-          break;\n-        case \"PX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          break;\n-        case \"NX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.NX;\n-          break;\n-        case \"XX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.XX;\n-          break;\n-        default:\n-          throw new IllegalArgumentException(ERROR_SYNTAX);\n+    List<String> optionalParametersStrings =\n+        optionalParameterBytes.stream()\n+            .map(item -> Coder.bytesToString(item).toUpperCase())\n+            .collect(Collectors.toList());\n+\n+    throwExceptionIfUnknownParameter(optionalParametersStrings);\n+    throwExceptionIfIncompatableParamaterOptions(optionalParametersStrings);\n+    keepTTL = optionalParametersStrings.contains(\"KEEPTL\");\n+\n+    if (optionalParametersStrings.contains(\"PX\")) {\n+      String nextParameter =\n+          getNextParameter(\"PX\", optionalParametersStrings);\n+\n+      if (!isANumber(nextParameter)) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+\n+      expiration = parseExpirationTime(\"PX\", nextParameter);\n+      if (expiration <= 0) {\n+        throw new IllegalArgumentException(ERROR_INVALID_EXPIRE_TIME);\n+      }\n+\n+    } else if (optionalParametersStrings.contains(\"EX\")) {\n+      String nextParameter =\n+          getNextParameter(\"EX\", optionalParametersStrings);\n+      if (!isANumber(nextParameter)) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+      expiration = parseExpirationTime(\"EX\", nextParameter);\n+      if (expiration <= 0) {\n+        throw new IllegalArgumentException(ERROR_INVALID_EXPIRE_TIME);\n       }\n     }\n \n+    if (optionalParametersStrings.contains(\"NX\")) {\n+      existsOption = SetOptions.Exists.NX;\n+    } else if (optionalParametersStrings.contains(\"XX\")) {\n+      existsOption = SetOptions.Exists.XX;\n+    }\n     return new SetOptions(existsOption, expiration, keepTTL);\n   }\n \n-  private long parseExpirationTime(int index, List<byte[]> commandElems)\n-      throws IllegalArgumentException {\n-    String expirationString;\n+  private String getNextParameter(String currentParameter,\n+      List<String> optionalParametersStrings) {\n+    int index = optionalParametersStrings.indexOf(currentParameter);\n+    if (optionalParametersStrings.size() <= index + 1) {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+    return optionalParametersStrings.get(index + 1);\n+  }\n+\n+  private void throwExceptionIfUnknownParameter(List<String> optionalParameters) {\n+    List<String> validOptionalParamaters = Arrays.asList(\"EX\", \"PX\", \"NX\", \"XX\", \"KEEPTL\");\n+\n+    List<String> parametersInQuestion =\n+        optionalParameters\n+            .stream()\n+            .filter(parameter -> (!validOptionalParamaters.contains(parameter)))\n+            .collect(Collectors.toList());\n+\n+    parametersInQuestion.forEach(parameter -> throwErrorIfNotANumberInExpectedPosition(\n+        parameter,\n+        optionalParameters));\n+  }\n+\n+  private void throwErrorIfNotANumberInExpectedPosition(\n+      String parameter,\n+      List<String> optionalParameters) {\n+\n+    if (previousOptionIsValidAndExpectsANumber(parameter, optionalParameters)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d1ac779762f879de28bbee4a8f9ad0803357b7c"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3ODE3NA==", "bodyText": "thanks for catching that done (in forthcoming commit)", "url": "https://github.com/apache/geode/pull/5216#discussion_r439078174", "createdAt": "2020-06-11T21:23:59Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "diffHunk": "@@ -35,105 +37,182 @@\n   public RedisResponse executeCommandWithResponse(Command command,\n       ExecutionHandlerContext context) {\n \n-    List<byte[]> commandElems = command.getProcessedCommand();\n     ByteArrayWrapper keyToSet = command.getKey();\n-    ByteArrayWrapper valueToSet = getValueToSet(commandElems);\n-\n+    List<byte[]> commandElementsBytes = command.getProcessedCommand();\n+    List<byte[]> optionalParameterBytes = getOptionalParameters(commandElementsBytes);\n+    ByteArrayWrapper valueToSet = getValueToSet(commandElementsBytes);\n     RedisStringCommands redisStringCommands = getRedisStringCommands(context);\n     SetOptions setOptions;\n+\n     try {\n-      setOptions = parseCommandElems(commandElems);\n+      setOptions = parseOptionalParameters(optionalParameterBytes);\n     } catch (IllegalArgumentException ex) {\n       return RedisResponse.error(ex.getMessage());\n     }\n \n-    return doSet(command, context, keyToSet, valueToSet, redisStringCommands, setOptions);\n+    return doSet(keyToSet, valueToSet, redisStringCommands, setOptions);\n+  }\n+\n+  private List<byte[]> getOptionalParameters(List<byte[]> commandElementsBytes) {\n+    return commandElementsBytes.subList(3, commandElementsBytes.size());\n   }\n \n-  private RedisResponse doSet(Command command, ExecutionHandlerContext context,\n-      ByteArrayWrapper key,\n-      ByteArrayWrapper value, RedisStringCommands redisStringCommands, SetOptions setOptions) {\n+  private RedisResponse doSet(ByteArrayWrapper key,\n+      ByteArrayWrapper value,\n+      RedisStringCommands redisStringCommands,\n+      SetOptions setOptions) {\n \n-    boolean result = redisStringCommands.set(key, value, setOptions);\n+    boolean setCompletedSuccessfully = redisStringCommands.set(key, value, setOptions);\n \n-    if (result) {\n+    if (setCompletedSuccessfully) {\n       return RedisResponse.string(SUCCESS);\n+    } else {\n+      return RedisResponse.nil();\n     }\n-\n-    return RedisResponse.nil();\n   }\n \n   private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n     byte[] value = commandElems.get(2);\n     return new ByteArrayWrapper(value);\n   }\n \n+  private SetOptions parseOptionalParameters(List<byte[]> optionalParameterBytes)\n+      throws IllegalArgumentException {\n \n-  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {\n     boolean keepTTL = false;\n     SetOptions.Exists existsOption = SetOptions.Exists.NONE;\n     long expiration = 0L;\n \n-    for (int i = 3; i < commandElems.size(); i++) {\n-      String current_arg = Coder.bytesToString(commandElems.get(i)).toUpperCase();\n-      switch (current_arg) {\n-        case \"KEEPTTL\":\n-          keepTTL = true;\n-          break;\n-        case \"EX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          expiration = SECONDS.toMillis(expiration);\n-          break;\n-        case \"PX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          break;\n-        case \"NX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.NX;\n-          break;\n-        case \"XX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.XX;\n-          break;\n-        default:\n-          throw new IllegalArgumentException(ERROR_SYNTAX);\n+    List<String> optionalParametersStrings =\n+        optionalParameterBytes.stream()\n+            .map(item -> Coder.bytesToString(item).toUpperCase())\n+            .collect(Collectors.toList());\n+\n+    throwExceptionIfUnknownParameter(optionalParametersStrings);\n+    throwExceptionIfIncompatableParamaterOptions(optionalParametersStrings);\n+    keepTTL = optionalParametersStrings.contains(\"KEEPTL\");\n+\n+    if (optionalParametersStrings.contains(\"PX\")) {\n+      String nextParameter =\n+          getNextParameter(\"PX\", optionalParametersStrings);\n+\n+      if (!isANumber(nextParameter)) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+\n+      expiration = parseExpirationTime(\"PX\", nextParameter);\n+      if (expiration <= 0) {\n+        throw new IllegalArgumentException(ERROR_INVALID_EXPIRE_TIME);\n+      }\n+\n+    } else if (optionalParametersStrings.contains(\"EX\")) {\n+      String nextParameter =\n+          getNextParameter(\"EX\", optionalParametersStrings);\n+      if (!isANumber(nextParameter)) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+      expiration = parseExpirationTime(\"EX\", nextParameter);\n+      if (expiration <= 0) {\n+        throw new IllegalArgumentException(ERROR_INVALID_EXPIRE_TIME);\n       }\n     }\n \n+    if (optionalParametersStrings.contains(\"NX\")) {\n+      existsOption = SetOptions.Exists.NX;\n+    } else if (optionalParametersStrings.contains(\"XX\")) {\n+      existsOption = SetOptions.Exists.XX;\n+    }\n     return new SetOptions(existsOption, expiration, keepTTL);\n   }\n \n-  private long parseExpirationTime(int index, List<byte[]> commandElems)\n-      throws IllegalArgumentException {\n-    String expirationString;\n+  private String getNextParameter(String currentParameter,\n+      List<String> optionalParametersStrings) {\n+    int index = optionalParametersStrings.indexOf(currentParameter);\n+    if (optionalParametersStrings.size() <= index + 1) {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+    return optionalParametersStrings.get(index + 1);\n+  }\n+\n+  private void throwExceptionIfUnknownParameter(List<String> optionalParameters) {\n+    List<String> validOptionalParamaters = Arrays.asList(\"EX\", \"PX\", \"NX\", \"XX\", \"KEEPTL\");\n+\n+    List<String> parametersInQuestion =\n+        optionalParameters\n+            .stream()\n+            .filter(parameter -> (!validOptionalParamaters.contains(parameter)))\n+            .collect(Collectors.toList());\n+\n+    parametersInQuestion.forEach(parameter -> throwErrorIfNotANumberInExpectedPosition(\n+        parameter,\n+        optionalParameters));\n+  }\n+\n+  private void throwErrorIfNotANumberInExpectedPosition(\n+      String parameter,\n+      List<String> optionalParameters) {\n+\n+    if (previousOptionIsValidAndExpectsANumber(parameter, optionalParameters)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2MDEwOA=="}, "originalCommit": {"oid": "3d1ac779762f879de28bbee4a8f9ad0803357b7c"}, "originalPosition": 180}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MzQ3MDYzOnYy", "diffSide": "RIGHT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/key/RenameExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNzo1NDowNlrOGj8q_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMDo1ODo0NFrOGkChSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0NzM5MQ==", "bodyText": "The changes here look like an incorrect merge perhaps.", "url": "https://github.com/apache/geode/pull/5216#discussion_r440347391", "createdAt": "2020-06-15T17:54:06Z", "author": {"login": "jdeppe-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/key/RenameExecutor.java", "diffHunk": "@@ -16,34 +16,35 @@\n \n package org.apache.geode.redis.internal.executor.key;\n \n-import static org.apache.geode.redis.internal.RedisConstants.ERROR_NO_SUCH_KEY;\n-\n import java.util.List;\n \n+import org.apache.geode.redis.internal.RedisConstants;\n import org.apache.geode.redis.internal.data.ByteArrayWrapper;\n import org.apache.geode.redis.internal.executor.AbstractExecutor;\n-import org.apache.geode.redis.internal.executor.RedisResponse;\n+import org.apache.geode.redis.internal.netty.Coder;\n import org.apache.geode.redis.internal.netty.Command;\n import org.apache.geode.redis.internal.netty.ExecutionHandlerContext;\n \n public class RenameExecutor extends AbstractExecutor {\n-\n   @Override\n-  public RedisResponse executeCommand(Command command,\n-      ExecutionHandlerContext context) {\n+  public void executeCommand(Command command, ExecutionHandlerContext context) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d732d3182b9bf82b303a6d835fe611b40f56e31d"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ0MzIxMA==", "bodyText": "looking into it-  thx", "url": "https://github.com/apache/geode/pull/5216#discussion_r440443210", "createdAt": "2020-06-15T20:58:44Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/key/RenameExecutor.java", "diffHunk": "@@ -16,34 +16,35 @@\n \n package org.apache.geode.redis.internal.executor.key;\n \n-import static org.apache.geode.redis.internal.RedisConstants.ERROR_NO_SUCH_KEY;\n-\n import java.util.List;\n \n+import org.apache.geode.redis.internal.RedisConstants;\n import org.apache.geode.redis.internal.data.ByteArrayWrapper;\n import org.apache.geode.redis.internal.executor.AbstractExecutor;\n-import org.apache.geode.redis.internal.executor.RedisResponse;\n+import org.apache.geode.redis.internal.netty.Coder;\n import org.apache.geode.redis.internal.netty.Command;\n import org.apache.geode.redis.internal.netty.ExecutionHandlerContext;\n \n public class RenameExecutor extends AbstractExecutor {\n-\n   @Override\n-  public RedisResponse executeCommand(Command command,\n-      ExecutionHandlerContext context) {\n+  public void executeCommand(Command command, ExecutionHandlerContext context) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0NzM5MQ=="}, "originalCommit": {"oid": "d732d3182b9bf82b303a6d835fe611b40f56e31d"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MzQxMTgwOnYy", "diffSide": "RIGHT", "path": "geode-redis/src/integrationTest/java/org/apache/geode/redis/internal/executor/string/StringsIntegrationTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxOTowOTo0MlrOGofdXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMjoyNDoyN1rOGolKdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTExMTY0Nw==", "bodyText": "It looks like you may have actually brought StringsIntegrationTest back to life. I think it has been removed from develop and split up into multiple, command focused tests. We now have a SetIntegrationTest so amy tests for SET that you added to this class should now be added to it instead.", "url": "https://github.com/apache/geode/pull/5216#discussion_r445111647", "createdAt": "2020-06-24T19:09:42Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/integrationTest/java/org/apache/geode/redis/internal/executor/string/StringsIntegrationTest.java", "diffHunk": "@@ -0,0 +1,1637 @@\n+/*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2026a5f7bab748cc1f4daef606276ff2e868f206"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIwNTEwOQ==", "bodyText": "whoops.  thanks-  moved Jen's earlier changes into the  SetsIntegrationTest and deleted StringsIntegrationTest", "url": "https://github.com/apache/geode/pull/5216#discussion_r445205109", "createdAt": "2020-06-24T22:24:27Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/integrationTest/java/org/apache/geode/redis/internal/executor/string/StringsIntegrationTest.java", "diffHunk": "@@ -0,0 +1,1637 @@\n+/*", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTExMTY0Nw=="}, "originalCommit": {"oid": "2026a5f7bab748cc1f4daef606276ff2e868f206"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MzQxOTI5OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/test/java/org/apache/geode/redis/internal/executor/string/StringSetExecutorJUnitTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxOToxMTo1NVrOGofiDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMjoyMzoyMFrOGolI2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTExMjg0NA==", "bodyText": "I'm not sure these tests should be added here. If you added them instead to SetIntegrationTest then I'd feel better because they would also run against native redis.", "url": "https://github.com/apache/geode/pull/5216#discussion_r445112844", "createdAt": "2020-06-24T19:11:55Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/test/java/org/apache/geode/redis/internal/executor/string/StringSetExecutorJUnitTest.java", "diffHunk": "@@ -213,4 +229,34 @@ public void testSET_XXandNX_inSameCommand_ReturnsError() {\n     assertThat(response.toString()).contains(RedisConstants.ERROR_SYNTAX);\n   }\n \n+  @Test\n+  public void testSET_unknownOption_ReturnsError() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2026a5f7bab748cc1f4daef606276ff2e868f206"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIwNDQ3Mw==", "bodyText": "done.  (1 test deleted instead of  moved as the same basic test already existed in SetIntegrationTest )", "url": "https://github.com/apache/geode/pull/5216#discussion_r445204473", "createdAt": "2020-06-24T22:22:41Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/test/java/org/apache/geode/redis/internal/executor/string/StringSetExecutorJUnitTest.java", "diffHunk": "@@ -213,4 +229,34 @@ public void testSET_XXandNX_inSameCommand_ReturnsError() {\n     assertThat(response.toString()).contains(RedisConstants.ERROR_SYNTAX);\n   }\n \n+  @Test\n+  public void testSET_unknownOption_ReturnsError() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTExMjg0NA=="}, "originalCommit": {"oid": "2026a5f7bab748cc1f4daef606276ff2e868f206"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIwNDY5Ng==", "bodyText": "done", "url": "https://github.com/apache/geode/pull/5216#discussion_r445204696", "createdAt": "2020-06-24T22:23:20Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/test/java/org/apache/geode/redis/internal/executor/string/StringSetExecutorJUnitTest.java", "diffHunk": "@@ -213,4 +229,34 @@ public void testSET_XXandNX_inSameCommand_ReturnsError() {\n     assertThat(response.toString()).contains(RedisConstants.ERROR_SYNTAX);\n   }\n \n+  @Test\n+  public void testSET_unknownOption_ReturnsError() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTExMjg0NA=="}, "originalCommit": {"oid": "2026a5f7bab748cc1f4daef606276ff2e868f206"}, "originalPosition": 59}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3971, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}