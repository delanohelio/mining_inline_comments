{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkzNzEwNjE1", "number": 4848, "reviewThreads": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxODo0MzoxNVrODryMYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNTozMzozMlrOEQQRyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MjM3NzI5OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxODo0MzoxNVrOF8VVYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNDowOToxNVrOF8yxgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODgwODQxOQ==", "bodyText": "can you add more shortcuts?", "url": "https://github.com/apache/geode/pull/4848#discussion_r398808419", "createdAt": "2020-03-26T18:43:15Z", "author": {"login": "gesterzhou"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheWriter;\n+import org.apache.geode.cache.CacheWriterException;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionEvent;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.util.CacheWriterAdapter;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} can be executed multiple times on\n+ * the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME = \"[{index}] {method}(Coordinator:{0}, Region:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65275b6a5fa3bdf344b5dbf3042705ee5b19e2a6"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI5MDc1Mg==", "bodyText": "There are other tickets aimed at testing concurrent operations with overflow, persistence, etc. Adding more region types should be done as part of the other tickets (that's why I set the RegionShortcut to be configurable through parameters), not this one.", "url": "https://github.com/apache/geode/pull/4848#discussion_r399290752", "createdAt": "2020-03-27T14:09:15Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheWriter;\n+import org.apache.geode.cache.CacheWriterException;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionEvent;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.util.CacheWriterAdapter;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} can be executed multiple times on\n+ * the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME = \"[{index}] {method}(Coordinator:{0}, Region:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODgwODQxOQ=="}, "originalCommit": {"oid": "65275b6a5fa3bdf344b5dbf3042705ee5b19e2a6"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MjYzNDc3OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxOTo1MTowN1rOF8X2bQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNDoxMDo1M1rOF8y2BA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg0OTY0NQ==", "bodyText": "after the first clear, all other gets() will not really do anything. You should re-populateRegion again before next clear.", "url": "https://github.com/apache/geode/pull/4848#discussion_r398849645", "createdAt": "2020-03-26T19:51:07Z", "author": {"login": "gesterzhou"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheWriter;\n+import org.apache.geode.cache.CacheWriterException;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionEvent;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.util.CacheWriterAdapter;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} can be executed multiple times on\n+ * the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME = \"[{index}] {method}(Coordinator:{0}, Region:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION,\n+        RegionShortcut.PARTITION_REDUNDANT\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] vmAndRegionTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    RegionShortcut[] regionShortcuts = regionTypes();\n+\n+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {\n+      parameters.add(new Object[] {TestVM.SERVER1, regionShortcut});\n+      parameters.add(new Object[] {TestVM.ACCESSOR, regionShortcut});\n+    });\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    server1 = getVM(TestVM.SERVER1.vmNumber);\n+    server2 = getVM(TestVM.SERVER2.vmNumber);\n+    accessor = getVM(TestVM.ACCESSOR.vmNumber);\n+  }\n+\n+  private void initAccessor(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .setLocalMaxMemory(0)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+\n+  }\n+\n+  private void initDataStore(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void parametrizedSetup(RegionShortcut regionShortcut) {\n+    server1.invoke(() -> initDataStore(regionShortcut));\n+    server2.invoke(() -> initDataStore(regionShortcut));\n+    accessor.invoke(() -> initAccessor(regionShortcut));\n+  }\n+\n+  /**\n+   * Waits until there are not PR messages in flight for the given region.\n+   */\n+  private void waitForSilence() {\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+\n+    await().untilAsserted(() -> {\n+      PartitionedRegionStats prStats = region.getPrStats();\n+      assertThat(prStats.getVolunteeringInProgress()).isEqualTo(0);\n+      assertThat(prStats.getBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getPrimaryTransfersInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalanceBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalancePrimaryTransfersInProgress()).isEqualTo(0);\n+    });\n+  }\n+\n+  private void assertRegionData(int entryCount, List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      IntStream.range(0, entryCount)\n+          .forEach(i -> assertThat(region.get(String.valueOf(i))).isEqualTo(\"Value_\" + i));\n+    }));\n+  }\n+\n+  /**\n+   * Asserts that the region is empty on requested VMs.\n+   */\n+  private void assertRegionIsEmpty(List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      assertThat(region.isEmpty()).isTrue();\n+    }));\n+  }\n+\n+  /**\n+   * Waits until there are no partition messages in flight and gets a snapshot of the region.\n+   */\n+  private Map<String, String> waitForSilenceAndGetRegionSnapshot() {\n+    waitForSilence();\n+    Map<String, String> regionSnapshot = new HashMap<>();\n+    Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+    region.forEach(regionSnapshot::put);\n+\n+    return regionSnapshot;\n+  }\n+\n+  /**\n+   * Asserts that the region data is consistent on requested VMs.\n+   */\n+  private void assertRegionDataConsistency(List<VM> vms) {\n+    // Get first snapshot to compare with the rest.\n+    final Map<String, String> vm0Snapshot =\n+        vms.get(0).invoke(this::waitForSilenceAndGetRegionSnapshot);\n+\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      final Map<String, String> thisSnapshot = waitForSilenceAndGetRegionSnapshot();\n+      assertThat(thisSnapshot).isEqualTo(vm0Snapshot);\n+      thisSnapshot.forEach((key, value) -> assertThat(value).isEqualTo(\"Value_\" + key));\n+    }));\n+  }\n+\n+  /**\n+   * Populates the region and verifies the data on the selected VMs.\n+   */\n+  private void populateRegion(VM feeder, int entryCount, List<VM> vms) {\n+    feeder.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      IntStream.range(0, entryCount).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    });\n+\n+    assertRegionData(entryCount, vms);\n+  }\n+\n+  /**\n+   * Continuously execute get operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeGets(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      // Region might have been cleared in between, that's why we check for null.\n+      IntStream.range(0, numEntries).forEach(i -> {\n+        Optional<String> nullableValue = Optional.ofNullable(region.get(String.valueOf(i)));\n+        nullableValue.ifPresent(value -> assertThat(value).isEqualTo(\"Value_\" + i));\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute put operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executePuts(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      IntStream.range(0, numEntries).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute clear operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeClears(final long durationInSeconds, final long waitTimeInSeconds)\n+      throws InterruptedException {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      region.clear();\n+      Thread.sleep(waitTimeInSeconds * 1000);\n+    }\n+  }\n+\n+  /**\n+   * Register the MemberKiller CacheWriter on the given vms and cancel auto-reconnects.\n+   */\n+  private void registerVMKillerAsCacheWriter(List<VM> vmsToBounce) {\n+    vmsToBounce.forEach(vm -> vm.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      region.getAttributesMutator().setCacheWriter(new MemberKiller());\n+    }));\n+  }\n+\n+  /**\n+   * The test does the following (the clear coordinator is chosen through parameters):\n+   * - Populates the Partition Region.\n+   * - Verifies that the entries are synchronized on all members.\n+   * - Launches one thread per VM to continuously execute gets for 10 seconds.\n+   * - Clears the Partition Region continuously (once every 2 seconds for 10 seconds).\n+   * - Asserts that, after the clears are finished, the Partition Region is empty on all members.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"vmAndRegionTypes\")\n+  public void clearWithConcurrentGetsShouldWorkCorrectly(TestVM coordinatorVM,\n+      RegionShortcut regionShortcut) throws InterruptedException {\n+    final int entries = 10000;\n+    parametrizedSetup(regionShortcut);\n+    populateRegion(accessor, entries, asList(accessor, server1, server2));\n+\n+    // Let all VMs continuously execute gets for 10 seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executeGets(entries, 10)),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65275b6a5fa3bdf344b5dbf3042705ee5b19e2a6"}, "originalPosition": 297}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI5MTkwOA==", "bodyText": "The test is still valid, though, we aim to verify that there are no issues with concurrent gets and concurrent clears, doesn't matter how many entries (if any) the region has. There is another method within the class that tests concurrent gets + puts + clears.", "url": "https://github.com/apache/geode/pull/4848#discussion_r399291908", "createdAt": "2020-03-27T14:10:53Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheWriter;\n+import org.apache.geode.cache.CacheWriterException;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionEvent;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.util.CacheWriterAdapter;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} can be executed multiple times on\n+ * the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME = \"[{index}] {method}(Coordinator:{0}, Region:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION,\n+        RegionShortcut.PARTITION_REDUNDANT\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] vmAndRegionTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    RegionShortcut[] regionShortcuts = regionTypes();\n+\n+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {\n+      parameters.add(new Object[] {TestVM.SERVER1, regionShortcut});\n+      parameters.add(new Object[] {TestVM.ACCESSOR, regionShortcut});\n+    });\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    server1 = getVM(TestVM.SERVER1.vmNumber);\n+    server2 = getVM(TestVM.SERVER2.vmNumber);\n+    accessor = getVM(TestVM.ACCESSOR.vmNumber);\n+  }\n+\n+  private void initAccessor(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .setLocalMaxMemory(0)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+\n+  }\n+\n+  private void initDataStore(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void parametrizedSetup(RegionShortcut regionShortcut) {\n+    server1.invoke(() -> initDataStore(regionShortcut));\n+    server2.invoke(() -> initDataStore(regionShortcut));\n+    accessor.invoke(() -> initAccessor(regionShortcut));\n+  }\n+\n+  /**\n+   * Waits until there are not PR messages in flight for the given region.\n+   */\n+  private void waitForSilence() {\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+\n+    await().untilAsserted(() -> {\n+      PartitionedRegionStats prStats = region.getPrStats();\n+      assertThat(prStats.getVolunteeringInProgress()).isEqualTo(0);\n+      assertThat(prStats.getBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getPrimaryTransfersInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalanceBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalancePrimaryTransfersInProgress()).isEqualTo(0);\n+    });\n+  }\n+\n+  private void assertRegionData(int entryCount, List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      IntStream.range(0, entryCount)\n+          .forEach(i -> assertThat(region.get(String.valueOf(i))).isEqualTo(\"Value_\" + i));\n+    }));\n+  }\n+\n+  /**\n+   * Asserts that the region is empty on requested VMs.\n+   */\n+  private void assertRegionIsEmpty(List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      assertThat(region.isEmpty()).isTrue();\n+    }));\n+  }\n+\n+  /**\n+   * Waits until there are no partition messages in flight and gets a snapshot of the region.\n+   */\n+  private Map<String, String> waitForSilenceAndGetRegionSnapshot() {\n+    waitForSilence();\n+    Map<String, String> regionSnapshot = new HashMap<>();\n+    Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+    region.forEach(regionSnapshot::put);\n+\n+    return regionSnapshot;\n+  }\n+\n+  /**\n+   * Asserts that the region data is consistent on requested VMs.\n+   */\n+  private void assertRegionDataConsistency(List<VM> vms) {\n+    // Get first snapshot to compare with the rest.\n+    final Map<String, String> vm0Snapshot =\n+        vms.get(0).invoke(this::waitForSilenceAndGetRegionSnapshot);\n+\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      final Map<String, String> thisSnapshot = waitForSilenceAndGetRegionSnapshot();\n+      assertThat(thisSnapshot).isEqualTo(vm0Snapshot);\n+      thisSnapshot.forEach((key, value) -> assertThat(value).isEqualTo(\"Value_\" + key));\n+    }));\n+  }\n+\n+  /**\n+   * Populates the region and verifies the data on the selected VMs.\n+   */\n+  private void populateRegion(VM feeder, int entryCount, List<VM> vms) {\n+    feeder.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      IntStream.range(0, entryCount).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    });\n+\n+    assertRegionData(entryCount, vms);\n+  }\n+\n+  /**\n+   * Continuously execute get operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeGets(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      // Region might have been cleared in between, that's why we check for null.\n+      IntStream.range(0, numEntries).forEach(i -> {\n+        Optional<String> nullableValue = Optional.ofNullable(region.get(String.valueOf(i)));\n+        nullableValue.ifPresent(value -> assertThat(value).isEqualTo(\"Value_\" + i));\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute put operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executePuts(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      IntStream.range(0, numEntries).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute clear operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeClears(final long durationInSeconds, final long waitTimeInSeconds)\n+      throws InterruptedException {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      region.clear();\n+      Thread.sleep(waitTimeInSeconds * 1000);\n+    }\n+  }\n+\n+  /**\n+   * Register the MemberKiller CacheWriter on the given vms and cancel auto-reconnects.\n+   */\n+  private void registerVMKillerAsCacheWriter(List<VM> vmsToBounce) {\n+    vmsToBounce.forEach(vm -> vm.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      region.getAttributesMutator().setCacheWriter(new MemberKiller());\n+    }));\n+  }\n+\n+  /**\n+   * The test does the following (the clear coordinator is chosen through parameters):\n+   * - Populates the Partition Region.\n+   * - Verifies that the entries are synchronized on all members.\n+   * - Launches one thread per VM to continuously execute gets for 10 seconds.\n+   * - Clears the Partition Region continuously (once every 2 seconds for 10 seconds).\n+   * - Asserts that, after the clears are finished, the Partition Region is empty on all members.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"vmAndRegionTypes\")\n+  public void clearWithConcurrentGetsShouldWorkCorrectly(TestVM coordinatorVM,\n+      RegionShortcut regionShortcut) throws InterruptedException {\n+    final int entries = 10000;\n+    parametrizedSetup(regionShortcut);\n+    populateRegion(accessor, entries, asList(accessor, server1, server2));\n+\n+    // Let all VMs continuously execute gets for 10 seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executeGets(entries, 10)),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg0OTY0NQ=="}, "originalCommit": {"oid": "65275b6a5fa3bdf344b5dbf3042705ee5b19e2a6"}, "originalPosition": 297}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MjY1Mzk0OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxOTo1NjozOVrOF8YCXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxODowOTowOVrOF88lQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg1MjcwMw==", "bodyText": "Shortening the test name :)\nWe have PRConcurrentMapOpsJUnitTest - similar to this?", "url": "https://github.com/apache/geode/pull/4848#discussion_r398852703", "createdAt": "2020-03-26T19:56:39Z", "author": {"login": "agingade"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheWriter;\n+import org.apache.geode.cache.CacheWriterException;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionEvent;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.util.CacheWriterAdapter;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} can be executed multiple times on\n+ * the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65275b6a5fa3bdf344b5dbf3042705ee5b19e2a6"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk1ODc3Mg==", "bodyText": "This is a good start; other cache ops that can be added in mix are Region ops (destroyRegion, invalidateRegion), querying; Region with index, rebalance, etc.", "url": "https://github.com/apache/geode/pull/4848#discussion_r398958772", "createdAt": "2020-03-26T23:51:14Z", "author": {"login": "agingade"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheWriter;\n+import org.apache.geode.cache.CacheWriterException;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionEvent;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.util.CacheWriterAdapter;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} can be executed multiple times on\n+ * the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg1MjcwMw=="}, "originalCommit": {"oid": "65275b6a5fa3bdf344b5dbf3042705ee5b19e2a6"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI5Njk2MQ==", "bodyText": "I'm in favour of having clear names in tests and classes, that's why I prefer to use long ones :-). Regarding the second comment, strongly agreed!.\nThis PR is to specifically address GEODE-7670, that's why it only addresses gets and puts, we can certainly improve the test and add extra operations (or region types) as part of other tickets.", "url": "https://github.com/apache/geode/pull/4848#discussion_r399296961", "createdAt": "2020-03-27T14:18:09Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheWriter;\n+import org.apache.geode.cache.CacheWriterException;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionEvent;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.util.CacheWriterAdapter;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} can be executed multiple times on\n+ * the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg1MjcwMw=="}, "originalCommit": {"oid": "65275b6a5fa3bdf344b5dbf3042705ee5b19e2a6"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ1MTQ1Ng==", "bodyText": "@jujoramos name change and adding new ops I will leave it to you. The acceptance criteria and ticket heading doesn't match; anyways we could add additional tickets to try out other ops.", "url": "https://github.com/apache/geode/pull/4848#discussion_r399451456", "createdAt": "2020-03-27T18:09:09Z", "author": {"login": "agingade"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheWriter;\n+import org.apache.geode.cache.CacheWriterException;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionEvent;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.util.CacheWriterAdapter;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} can be executed multiple times on\n+ * the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg1MjcwMw=="}, "originalCommit": {"oid": "65275b6a5fa3bdf344b5dbf3042705ee5b19e2a6"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3Mjg2ODg3OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQyMDo1ODoyMFrOF8aJZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNTo0NTo1MVrOF_G5dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg4NzI3MQ==", "bodyText": "you need to measure how long a clear() took. If it's more than 5 seconds, something must be wrong.", "url": "https://github.com/apache/geode/pull/4848#discussion_r398887271", "createdAt": "2020-03-26T20:58:20Z", "author": {"login": "gesterzhou"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheWriter;\n+import org.apache.geode.cache.CacheWriterException;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionEvent;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.util.CacheWriterAdapter;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} can be executed multiple times on\n+ * the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME = \"[{index}] {method}(Coordinator:{0}, Region:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION,\n+        RegionShortcut.PARTITION_REDUNDANT\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] vmAndRegionTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    RegionShortcut[] regionShortcuts = regionTypes();\n+\n+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {\n+      parameters.add(new Object[] {TestVM.SERVER1, regionShortcut});\n+      parameters.add(new Object[] {TestVM.ACCESSOR, regionShortcut});\n+    });\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    server1 = getVM(TestVM.SERVER1.vmNumber);\n+    server2 = getVM(TestVM.SERVER2.vmNumber);\n+    accessor = getVM(TestVM.ACCESSOR.vmNumber);\n+  }\n+\n+  private void initAccessor(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .setLocalMaxMemory(0)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+\n+  }\n+\n+  private void initDataStore(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void parametrizedSetup(RegionShortcut regionShortcut) {\n+    server1.invoke(() -> initDataStore(regionShortcut));\n+    server2.invoke(() -> initDataStore(regionShortcut));\n+    accessor.invoke(() -> initAccessor(regionShortcut));\n+  }\n+\n+  /**\n+   * Waits until there are not PR messages in flight for the given region.\n+   */\n+  private void waitForSilence() {\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+\n+    await().untilAsserted(() -> {\n+      PartitionedRegionStats prStats = region.getPrStats();\n+      assertThat(prStats.getVolunteeringInProgress()).isEqualTo(0);\n+      assertThat(prStats.getBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getPrimaryTransfersInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalanceBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalancePrimaryTransfersInProgress()).isEqualTo(0);\n+    });\n+  }\n+\n+  private void assertRegionData(int entryCount, List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      IntStream.range(0, entryCount)\n+          .forEach(i -> assertThat(region.get(String.valueOf(i))).isEqualTo(\"Value_\" + i));\n+    }));\n+  }\n+\n+  /**\n+   * Asserts that the region is empty on requested VMs.\n+   */\n+  private void assertRegionIsEmpty(List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      assertThat(region.isEmpty()).isTrue();\n+    }));\n+  }\n+\n+  /**\n+   * Waits until there are no partition messages in flight and gets a snapshot of the region.\n+   */\n+  private Map<String, String> waitForSilenceAndGetRegionSnapshot() {\n+    waitForSilence();\n+    Map<String, String> regionSnapshot = new HashMap<>();\n+    Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+    region.forEach(regionSnapshot::put);\n+\n+    return regionSnapshot;\n+  }\n+\n+  /**\n+   * Asserts that the region data is consistent on requested VMs.\n+   */\n+  private void assertRegionDataConsistency(List<VM> vms) {\n+    // Get first snapshot to compare with the rest.\n+    final Map<String, String> vm0Snapshot =\n+        vms.get(0).invoke(this::waitForSilenceAndGetRegionSnapshot);\n+\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      final Map<String, String> thisSnapshot = waitForSilenceAndGetRegionSnapshot();\n+      assertThat(thisSnapshot).isEqualTo(vm0Snapshot);\n+      thisSnapshot.forEach((key, value) -> assertThat(value).isEqualTo(\"Value_\" + key));\n+    }));\n+  }\n+\n+  /**\n+   * Populates the region and verifies the data on the selected VMs.\n+   */\n+  private void populateRegion(VM feeder, int entryCount, List<VM> vms) {\n+    feeder.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      IntStream.range(0, entryCount).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    });\n+\n+    assertRegionData(entryCount, vms);\n+  }\n+\n+  /**\n+   * Continuously execute get operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeGets(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      // Region might have been cleared in between, that's why we check for null.\n+      IntStream.range(0, numEntries).forEach(i -> {\n+        Optional<String> nullableValue = Optional.ofNullable(region.get(String.valueOf(i)));\n+        nullableValue.ifPresent(value -> assertThat(value).isEqualTo(\"Value_\" + i));\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute put operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executePuts(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      IntStream.range(0, numEntries).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute clear operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeClears(final long durationInSeconds, final long waitTimeInSeconds)\n+      throws InterruptedException {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      region.clear();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65275b6a5fa3bdf344b5dbf3042705ee5b19e2a6"}, "originalPosition": 263}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI5MzUxMQ==", "bodyText": "I'm not following you on this one... why only 5 seconds?, and why should the test verify how long the operation actually took?. The method basically executes the clear operation for a specific period of time to be able to interleave this operation with other concurrent ones in the cache. Measuring how long the operation took should be part of another ticket (a performance one, probably).", "url": "https://github.com/apache/geode/pull/4848#discussion_r399293511", "createdAt": "2020-03-27T14:13:12Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheWriter;\n+import org.apache.geode.cache.CacheWriterException;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionEvent;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.util.CacheWriterAdapter;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} can be executed multiple times on\n+ * the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME = \"[{index}] {method}(Coordinator:{0}, Region:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION,\n+        RegionShortcut.PARTITION_REDUNDANT\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] vmAndRegionTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    RegionShortcut[] regionShortcuts = regionTypes();\n+\n+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {\n+      parameters.add(new Object[] {TestVM.SERVER1, regionShortcut});\n+      parameters.add(new Object[] {TestVM.ACCESSOR, regionShortcut});\n+    });\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    server1 = getVM(TestVM.SERVER1.vmNumber);\n+    server2 = getVM(TestVM.SERVER2.vmNumber);\n+    accessor = getVM(TestVM.ACCESSOR.vmNumber);\n+  }\n+\n+  private void initAccessor(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .setLocalMaxMemory(0)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+\n+  }\n+\n+  private void initDataStore(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void parametrizedSetup(RegionShortcut regionShortcut) {\n+    server1.invoke(() -> initDataStore(regionShortcut));\n+    server2.invoke(() -> initDataStore(regionShortcut));\n+    accessor.invoke(() -> initAccessor(regionShortcut));\n+  }\n+\n+  /**\n+   * Waits until there are not PR messages in flight for the given region.\n+   */\n+  private void waitForSilence() {\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+\n+    await().untilAsserted(() -> {\n+      PartitionedRegionStats prStats = region.getPrStats();\n+      assertThat(prStats.getVolunteeringInProgress()).isEqualTo(0);\n+      assertThat(prStats.getBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getPrimaryTransfersInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalanceBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalancePrimaryTransfersInProgress()).isEqualTo(0);\n+    });\n+  }\n+\n+  private void assertRegionData(int entryCount, List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      IntStream.range(0, entryCount)\n+          .forEach(i -> assertThat(region.get(String.valueOf(i))).isEqualTo(\"Value_\" + i));\n+    }));\n+  }\n+\n+  /**\n+   * Asserts that the region is empty on requested VMs.\n+   */\n+  private void assertRegionIsEmpty(List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      assertThat(region.isEmpty()).isTrue();\n+    }));\n+  }\n+\n+  /**\n+   * Waits until there are no partition messages in flight and gets a snapshot of the region.\n+   */\n+  private Map<String, String> waitForSilenceAndGetRegionSnapshot() {\n+    waitForSilence();\n+    Map<String, String> regionSnapshot = new HashMap<>();\n+    Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+    region.forEach(regionSnapshot::put);\n+\n+    return regionSnapshot;\n+  }\n+\n+  /**\n+   * Asserts that the region data is consistent on requested VMs.\n+   */\n+  private void assertRegionDataConsistency(List<VM> vms) {\n+    // Get first snapshot to compare with the rest.\n+    final Map<String, String> vm0Snapshot =\n+        vms.get(0).invoke(this::waitForSilenceAndGetRegionSnapshot);\n+\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      final Map<String, String> thisSnapshot = waitForSilenceAndGetRegionSnapshot();\n+      assertThat(thisSnapshot).isEqualTo(vm0Snapshot);\n+      thisSnapshot.forEach((key, value) -> assertThat(value).isEqualTo(\"Value_\" + key));\n+    }));\n+  }\n+\n+  /**\n+   * Populates the region and verifies the data on the selected VMs.\n+   */\n+  private void populateRegion(VM feeder, int entryCount, List<VM> vms) {\n+    feeder.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      IntStream.range(0, entryCount).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    });\n+\n+    assertRegionData(entryCount, vms);\n+  }\n+\n+  /**\n+   * Continuously execute get operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeGets(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      // Region might have been cleared in between, that's why we check for null.\n+      IntStream.range(0, numEntries).forEach(i -> {\n+        Optional<String> nullableValue = Optional.ofNullable(region.get(String.valueOf(i)));\n+        nullableValue.ifPresent(value -> assertThat(value).isEqualTo(\"Value_\" + i));\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute put operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executePuts(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      IntStream.range(0, numEntries).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute clear operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeClears(final long durationInSeconds, final long waitTimeInSeconds)\n+      throws InterruptedException {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      region.clear();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg4NzI3MQ=="}, "originalCommit": {"oid": "65275b6a5fa3bdf344b5dbf3042705ee5b19e2a6"}, "originalPosition": 263}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM3ODU5OQ==", "bodyText": "5 seconds is rvv domination timeout. If clear operation took more than 5 seconds, something must be wrong. No need to measure other operations' time.", "url": "https://github.com/apache/geode/pull/4848#discussion_r400378599", "createdAt": "2020-03-30T17:46:41Z", "author": {"login": "gesterzhou"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheWriter;\n+import org.apache.geode.cache.CacheWriterException;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionEvent;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.util.CacheWriterAdapter;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} can be executed multiple times on\n+ * the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME = \"[{index}] {method}(Coordinator:{0}, Region:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION,\n+        RegionShortcut.PARTITION_REDUNDANT\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] vmAndRegionTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    RegionShortcut[] regionShortcuts = regionTypes();\n+\n+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {\n+      parameters.add(new Object[] {TestVM.SERVER1, regionShortcut});\n+      parameters.add(new Object[] {TestVM.ACCESSOR, regionShortcut});\n+    });\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    server1 = getVM(TestVM.SERVER1.vmNumber);\n+    server2 = getVM(TestVM.SERVER2.vmNumber);\n+    accessor = getVM(TestVM.ACCESSOR.vmNumber);\n+  }\n+\n+  private void initAccessor(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .setLocalMaxMemory(0)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+\n+  }\n+\n+  private void initDataStore(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void parametrizedSetup(RegionShortcut regionShortcut) {\n+    server1.invoke(() -> initDataStore(regionShortcut));\n+    server2.invoke(() -> initDataStore(regionShortcut));\n+    accessor.invoke(() -> initAccessor(regionShortcut));\n+  }\n+\n+  /**\n+   * Waits until there are not PR messages in flight for the given region.\n+   */\n+  private void waitForSilence() {\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+\n+    await().untilAsserted(() -> {\n+      PartitionedRegionStats prStats = region.getPrStats();\n+      assertThat(prStats.getVolunteeringInProgress()).isEqualTo(0);\n+      assertThat(prStats.getBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getPrimaryTransfersInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalanceBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalancePrimaryTransfersInProgress()).isEqualTo(0);\n+    });\n+  }\n+\n+  private void assertRegionData(int entryCount, List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      IntStream.range(0, entryCount)\n+          .forEach(i -> assertThat(region.get(String.valueOf(i))).isEqualTo(\"Value_\" + i));\n+    }));\n+  }\n+\n+  /**\n+   * Asserts that the region is empty on requested VMs.\n+   */\n+  private void assertRegionIsEmpty(List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      assertThat(region.isEmpty()).isTrue();\n+    }));\n+  }\n+\n+  /**\n+   * Waits until there are no partition messages in flight and gets a snapshot of the region.\n+   */\n+  private Map<String, String> waitForSilenceAndGetRegionSnapshot() {\n+    waitForSilence();\n+    Map<String, String> regionSnapshot = new HashMap<>();\n+    Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+    region.forEach(regionSnapshot::put);\n+\n+    return regionSnapshot;\n+  }\n+\n+  /**\n+   * Asserts that the region data is consistent on requested VMs.\n+   */\n+  private void assertRegionDataConsistency(List<VM> vms) {\n+    // Get first snapshot to compare with the rest.\n+    final Map<String, String> vm0Snapshot =\n+        vms.get(0).invoke(this::waitForSilenceAndGetRegionSnapshot);\n+\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      final Map<String, String> thisSnapshot = waitForSilenceAndGetRegionSnapshot();\n+      assertThat(thisSnapshot).isEqualTo(vm0Snapshot);\n+      thisSnapshot.forEach((key, value) -> assertThat(value).isEqualTo(\"Value_\" + key));\n+    }));\n+  }\n+\n+  /**\n+   * Populates the region and verifies the data on the selected VMs.\n+   */\n+  private void populateRegion(VM feeder, int entryCount, List<VM> vms) {\n+    feeder.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      IntStream.range(0, entryCount).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    });\n+\n+    assertRegionData(entryCount, vms);\n+  }\n+\n+  /**\n+   * Continuously execute get operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeGets(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      // Region might have been cleared in between, that's why we check for null.\n+      IntStream.range(0, numEntries).forEach(i -> {\n+        Optional<String> nullableValue = Optional.ofNullable(region.get(String.valueOf(i)));\n+        nullableValue.ifPresent(value -> assertThat(value).isEqualTo(\"Value_\" + i));\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute put operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executePuts(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      IntStream.range(0, numEntries).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute clear operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeClears(final long durationInSeconds, final long waitTimeInSeconds)\n+      throws InterruptedException {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      region.clear();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg4NzI3MQ=="}, "originalCommit": {"oid": "65275b6a5fa3bdf344b5dbf3042705ee5b19e2a6"}, "originalPosition": 263}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcxNzYyMw==", "bodyText": "@gesterzhou : I still don't understand what these tests have to do with the fact that a clear operation should take less than 5 seconds. The ticket is to purely verify that clear can be executed while other cache operations are being executed at the same time on the same region, shouldn't we create an extra ticket to test the scenario you're talking about?.", "url": "https://github.com/apache/geode/pull/4848#discussion_r401717623", "createdAt": "2020-04-01T15:45:51Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheWriter;\n+import org.apache.geode.cache.CacheWriterException;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionEvent;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.util.CacheWriterAdapter;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} can be executed multiple times on\n+ * the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME = \"[{index}] {method}(Coordinator:{0}, Region:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION,\n+        RegionShortcut.PARTITION_REDUNDANT\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] vmAndRegionTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    RegionShortcut[] regionShortcuts = regionTypes();\n+\n+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {\n+      parameters.add(new Object[] {TestVM.SERVER1, regionShortcut});\n+      parameters.add(new Object[] {TestVM.ACCESSOR, regionShortcut});\n+    });\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    server1 = getVM(TestVM.SERVER1.vmNumber);\n+    server2 = getVM(TestVM.SERVER2.vmNumber);\n+    accessor = getVM(TestVM.ACCESSOR.vmNumber);\n+  }\n+\n+  private void initAccessor(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .setLocalMaxMemory(0)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+\n+  }\n+\n+  private void initDataStore(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void parametrizedSetup(RegionShortcut regionShortcut) {\n+    server1.invoke(() -> initDataStore(regionShortcut));\n+    server2.invoke(() -> initDataStore(regionShortcut));\n+    accessor.invoke(() -> initAccessor(regionShortcut));\n+  }\n+\n+  /**\n+   * Waits until there are not PR messages in flight for the given region.\n+   */\n+  private void waitForSilence() {\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+\n+    await().untilAsserted(() -> {\n+      PartitionedRegionStats prStats = region.getPrStats();\n+      assertThat(prStats.getVolunteeringInProgress()).isEqualTo(0);\n+      assertThat(prStats.getBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getPrimaryTransfersInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalanceBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalancePrimaryTransfersInProgress()).isEqualTo(0);\n+    });\n+  }\n+\n+  private void assertRegionData(int entryCount, List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      IntStream.range(0, entryCount)\n+          .forEach(i -> assertThat(region.get(String.valueOf(i))).isEqualTo(\"Value_\" + i));\n+    }));\n+  }\n+\n+  /**\n+   * Asserts that the region is empty on requested VMs.\n+   */\n+  private void assertRegionIsEmpty(List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      assertThat(region.isEmpty()).isTrue();\n+    }));\n+  }\n+\n+  /**\n+   * Waits until there are no partition messages in flight and gets a snapshot of the region.\n+   */\n+  private Map<String, String> waitForSilenceAndGetRegionSnapshot() {\n+    waitForSilence();\n+    Map<String, String> regionSnapshot = new HashMap<>();\n+    Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+    region.forEach(regionSnapshot::put);\n+\n+    return regionSnapshot;\n+  }\n+\n+  /**\n+   * Asserts that the region data is consistent on requested VMs.\n+   */\n+  private void assertRegionDataConsistency(List<VM> vms) {\n+    // Get first snapshot to compare with the rest.\n+    final Map<String, String> vm0Snapshot =\n+        vms.get(0).invoke(this::waitForSilenceAndGetRegionSnapshot);\n+\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      final Map<String, String> thisSnapshot = waitForSilenceAndGetRegionSnapshot();\n+      assertThat(thisSnapshot).isEqualTo(vm0Snapshot);\n+      thisSnapshot.forEach((key, value) -> assertThat(value).isEqualTo(\"Value_\" + key));\n+    }));\n+  }\n+\n+  /**\n+   * Populates the region and verifies the data on the selected VMs.\n+   */\n+  private void populateRegion(VM feeder, int entryCount, List<VM> vms) {\n+    feeder.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      IntStream.range(0, entryCount).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    });\n+\n+    assertRegionData(entryCount, vms);\n+  }\n+\n+  /**\n+   * Continuously execute get operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeGets(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      // Region might have been cleared in between, that's why we check for null.\n+      IntStream.range(0, numEntries).forEach(i -> {\n+        Optional<String> nullableValue = Optional.ofNullable(region.get(String.valueOf(i)));\n+        nullableValue.ifPresent(value -> assertThat(value).isEqualTo(\"Value_\" + i));\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute put operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executePuts(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      IntStream.range(0, numEntries).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute clear operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeClears(final long durationInSeconds, final long waitTimeInSeconds)\n+      throws InterruptedException {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      region.clear();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg4NzI3MQ=="}, "originalCommit": {"oid": "65275b6a5fa3bdf344b5dbf3042705ee5b19e2a6"}, "originalPosition": 263}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3Mjg3NDY2OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQyMTowMDoxNVrOF8aNCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNTo0NjoyN1rOF_G7OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg4ODIwMg==", "bodyText": "it's better to change the continuous put into continuous putAll.", "url": "https://github.com/apache/geode/pull/4848#discussion_r398888202", "createdAt": "2020-03-26T21:00:15Z", "author": {"login": "gesterzhou"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheWriter;\n+import org.apache.geode.cache.CacheWriterException;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionEvent;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.util.CacheWriterAdapter;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} can be executed multiple times on\n+ * the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME = \"[{index}] {method}(Coordinator:{0}, Region:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION,\n+        RegionShortcut.PARTITION_REDUNDANT\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] vmAndRegionTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    RegionShortcut[] regionShortcuts = regionTypes();\n+\n+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {\n+      parameters.add(new Object[] {TestVM.SERVER1, regionShortcut});\n+      parameters.add(new Object[] {TestVM.ACCESSOR, regionShortcut});\n+    });\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    server1 = getVM(TestVM.SERVER1.vmNumber);\n+    server2 = getVM(TestVM.SERVER2.vmNumber);\n+    accessor = getVM(TestVM.ACCESSOR.vmNumber);\n+  }\n+\n+  private void initAccessor(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .setLocalMaxMemory(0)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+\n+  }\n+\n+  private void initDataStore(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void parametrizedSetup(RegionShortcut regionShortcut) {\n+    server1.invoke(() -> initDataStore(regionShortcut));\n+    server2.invoke(() -> initDataStore(regionShortcut));\n+    accessor.invoke(() -> initAccessor(regionShortcut));\n+  }\n+\n+  /**\n+   * Waits until there are not PR messages in flight for the given region.\n+   */\n+  private void waitForSilence() {\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+\n+    await().untilAsserted(() -> {\n+      PartitionedRegionStats prStats = region.getPrStats();\n+      assertThat(prStats.getVolunteeringInProgress()).isEqualTo(0);\n+      assertThat(prStats.getBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getPrimaryTransfersInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalanceBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalancePrimaryTransfersInProgress()).isEqualTo(0);\n+    });\n+  }\n+\n+  private void assertRegionData(int entryCount, List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      IntStream.range(0, entryCount)\n+          .forEach(i -> assertThat(region.get(String.valueOf(i))).isEqualTo(\"Value_\" + i));\n+    }));\n+  }\n+\n+  /**\n+   * Asserts that the region is empty on requested VMs.\n+   */\n+  private void assertRegionIsEmpty(List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      assertThat(region.isEmpty()).isTrue();\n+    }));\n+  }\n+\n+  /**\n+   * Waits until there are no partition messages in flight and gets a snapshot of the region.\n+   */\n+  private Map<String, String> waitForSilenceAndGetRegionSnapshot() {\n+    waitForSilence();\n+    Map<String, String> regionSnapshot = new HashMap<>();\n+    Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+    region.forEach(regionSnapshot::put);\n+\n+    return regionSnapshot;\n+  }\n+\n+  /**\n+   * Asserts that the region data is consistent on requested VMs.\n+   */\n+  private void assertRegionDataConsistency(List<VM> vms) {\n+    // Get first snapshot to compare with the rest.\n+    final Map<String, String> vm0Snapshot =\n+        vms.get(0).invoke(this::waitForSilenceAndGetRegionSnapshot);\n+\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      final Map<String, String> thisSnapshot = waitForSilenceAndGetRegionSnapshot();\n+      assertThat(thisSnapshot).isEqualTo(vm0Snapshot);\n+      thisSnapshot.forEach((key, value) -> assertThat(value).isEqualTo(\"Value_\" + key));\n+    }));\n+  }\n+\n+  /**\n+   * Populates the region and verifies the data on the selected VMs.\n+   */\n+  private void populateRegion(VM feeder, int entryCount, List<VM> vms) {\n+    feeder.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      IntStream.range(0, entryCount).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    });\n+\n+    assertRegionData(entryCount, vms);\n+  }\n+\n+  /**\n+   * Continuously execute get operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeGets(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      // Region might have been cleared in between, that's why we check for null.\n+      IntStream.range(0, numEntries).forEach(i -> {\n+        Optional<String> nullableValue = Optional.ofNullable(region.get(String.valueOf(i)));\n+        nullableValue.ifPresent(value -> assertThat(value).isEqualTo(\"Value_\" + i));\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute put operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executePuts(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      IntStream.range(0, numEntries).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65275b6a5fa3bdf344b5dbf3042705ee5b19e2a6"}, "originalPosition": 249}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI5NDA5Mw==", "bodyText": "Any reason for that?. I can certainly do it, just wondering what's the actual reasoning behind the request.", "url": "https://github.com/apache/geode/pull/4848#discussion_r399294093", "createdAt": "2020-03-27T14:13:57Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheWriter;\n+import org.apache.geode.cache.CacheWriterException;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionEvent;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.util.CacheWriterAdapter;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} can be executed multiple times on\n+ * the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME = \"[{index}] {method}(Coordinator:{0}, Region:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION,\n+        RegionShortcut.PARTITION_REDUNDANT\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] vmAndRegionTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    RegionShortcut[] regionShortcuts = regionTypes();\n+\n+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {\n+      parameters.add(new Object[] {TestVM.SERVER1, regionShortcut});\n+      parameters.add(new Object[] {TestVM.ACCESSOR, regionShortcut});\n+    });\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    server1 = getVM(TestVM.SERVER1.vmNumber);\n+    server2 = getVM(TestVM.SERVER2.vmNumber);\n+    accessor = getVM(TestVM.ACCESSOR.vmNumber);\n+  }\n+\n+  private void initAccessor(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .setLocalMaxMemory(0)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+\n+  }\n+\n+  private void initDataStore(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void parametrizedSetup(RegionShortcut regionShortcut) {\n+    server1.invoke(() -> initDataStore(regionShortcut));\n+    server2.invoke(() -> initDataStore(regionShortcut));\n+    accessor.invoke(() -> initAccessor(regionShortcut));\n+  }\n+\n+  /**\n+   * Waits until there are not PR messages in flight for the given region.\n+   */\n+  private void waitForSilence() {\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+\n+    await().untilAsserted(() -> {\n+      PartitionedRegionStats prStats = region.getPrStats();\n+      assertThat(prStats.getVolunteeringInProgress()).isEqualTo(0);\n+      assertThat(prStats.getBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getPrimaryTransfersInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalanceBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalancePrimaryTransfersInProgress()).isEqualTo(0);\n+    });\n+  }\n+\n+  private void assertRegionData(int entryCount, List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      IntStream.range(0, entryCount)\n+          .forEach(i -> assertThat(region.get(String.valueOf(i))).isEqualTo(\"Value_\" + i));\n+    }));\n+  }\n+\n+  /**\n+   * Asserts that the region is empty on requested VMs.\n+   */\n+  private void assertRegionIsEmpty(List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      assertThat(region.isEmpty()).isTrue();\n+    }));\n+  }\n+\n+  /**\n+   * Waits until there are no partition messages in flight and gets a snapshot of the region.\n+   */\n+  private Map<String, String> waitForSilenceAndGetRegionSnapshot() {\n+    waitForSilence();\n+    Map<String, String> regionSnapshot = new HashMap<>();\n+    Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+    region.forEach(regionSnapshot::put);\n+\n+    return regionSnapshot;\n+  }\n+\n+  /**\n+   * Asserts that the region data is consistent on requested VMs.\n+   */\n+  private void assertRegionDataConsistency(List<VM> vms) {\n+    // Get first snapshot to compare with the rest.\n+    final Map<String, String> vm0Snapshot =\n+        vms.get(0).invoke(this::waitForSilenceAndGetRegionSnapshot);\n+\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      final Map<String, String> thisSnapshot = waitForSilenceAndGetRegionSnapshot();\n+      assertThat(thisSnapshot).isEqualTo(vm0Snapshot);\n+      thisSnapshot.forEach((key, value) -> assertThat(value).isEqualTo(\"Value_\" + key));\n+    }));\n+  }\n+\n+  /**\n+   * Populates the region and verifies the data on the selected VMs.\n+   */\n+  private void populateRegion(VM feeder, int entryCount, List<VM> vms) {\n+    feeder.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      IntStream.range(0, entryCount).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    });\n+\n+    assertRegionData(entryCount, vms);\n+  }\n+\n+  /**\n+   * Continuously execute get operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeGets(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      // Region might have been cleared in between, that's why we check for null.\n+      IntStream.range(0, numEntries).forEach(i -> {\n+        Optional<String> nullableValue = Optional.ofNullable(region.get(String.valueOf(i)));\n+        nullableValue.ifPresent(value -> assertThat(value).isEqualTo(\"Value_\" + i));\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute put operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executePuts(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      IntStream.range(0, numEntries).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg4ODIwMg=="}, "originalCommit": {"oid": "65275b6a5fa3bdf344b5dbf3042705ee5b19e2a6"}, "originalPosition": 249}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM3OTA0Ng==", "bodyText": "putAll will have longer window to reproduce synchronization issues", "url": "https://github.com/apache/geode/pull/4848#discussion_r400379046", "createdAt": "2020-03-30T17:47:19Z", "author": {"login": "gesterzhou"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheWriter;\n+import org.apache.geode.cache.CacheWriterException;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionEvent;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.util.CacheWriterAdapter;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} can be executed multiple times on\n+ * the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME = \"[{index}] {method}(Coordinator:{0}, Region:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION,\n+        RegionShortcut.PARTITION_REDUNDANT\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] vmAndRegionTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    RegionShortcut[] regionShortcuts = regionTypes();\n+\n+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {\n+      parameters.add(new Object[] {TestVM.SERVER1, regionShortcut});\n+      parameters.add(new Object[] {TestVM.ACCESSOR, regionShortcut});\n+    });\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    server1 = getVM(TestVM.SERVER1.vmNumber);\n+    server2 = getVM(TestVM.SERVER2.vmNumber);\n+    accessor = getVM(TestVM.ACCESSOR.vmNumber);\n+  }\n+\n+  private void initAccessor(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .setLocalMaxMemory(0)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+\n+  }\n+\n+  private void initDataStore(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void parametrizedSetup(RegionShortcut regionShortcut) {\n+    server1.invoke(() -> initDataStore(regionShortcut));\n+    server2.invoke(() -> initDataStore(regionShortcut));\n+    accessor.invoke(() -> initAccessor(regionShortcut));\n+  }\n+\n+  /**\n+   * Waits until there are not PR messages in flight for the given region.\n+   */\n+  private void waitForSilence() {\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+\n+    await().untilAsserted(() -> {\n+      PartitionedRegionStats prStats = region.getPrStats();\n+      assertThat(prStats.getVolunteeringInProgress()).isEqualTo(0);\n+      assertThat(prStats.getBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getPrimaryTransfersInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalanceBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalancePrimaryTransfersInProgress()).isEqualTo(0);\n+    });\n+  }\n+\n+  private void assertRegionData(int entryCount, List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      IntStream.range(0, entryCount)\n+          .forEach(i -> assertThat(region.get(String.valueOf(i))).isEqualTo(\"Value_\" + i));\n+    }));\n+  }\n+\n+  /**\n+   * Asserts that the region is empty on requested VMs.\n+   */\n+  private void assertRegionIsEmpty(List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      assertThat(region.isEmpty()).isTrue();\n+    }));\n+  }\n+\n+  /**\n+   * Waits until there are no partition messages in flight and gets a snapshot of the region.\n+   */\n+  private Map<String, String> waitForSilenceAndGetRegionSnapshot() {\n+    waitForSilence();\n+    Map<String, String> regionSnapshot = new HashMap<>();\n+    Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+    region.forEach(regionSnapshot::put);\n+\n+    return regionSnapshot;\n+  }\n+\n+  /**\n+   * Asserts that the region data is consistent on requested VMs.\n+   */\n+  private void assertRegionDataConsistency(List<VM> vms) {\n+    // Get first snapshot to compare with the rest.\n+    final Map<String, String> vm0Snapshot =\n+        vms.get(0).invoke(this::waitForSilenceAndGetRegionSnapshot);\n+\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      final Map<String, String> thisSnapshot = waitForSilenceAndGetRegionSnapshot();\n+      assertThat(thisSnapshot).isEqualTo(vm0Snapshot);\n+      thisSnapshot.forEach((key, value) -> assertThat(value).isEqualTo(\"Value_\" + key));\n+    }));\n+  }\n+\n+  /**\n+   * Populates the region and verifies the data on the selected VMs.\n+   */\n+  private void populateRegion(VM feeder, int entryCount, List<VM> vms) {\n+    feeder.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      IntStream.range(0, entryCount).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    });\n+\n+    assertRegionData(entryCount, vms);\n+  }\n+\n+  /**\n+   * Continuously execute get operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeGets(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      // Region might have been cleared in between, that's why we check for null.\n+      IntStream.range(0, numEntries).forEach(i -> {\n+        Optional<String> nullableValue = Optional.ofNullable(region.get(String.valueOf(i)));\n+        nullableValue.ifPresent(value -> assertThat(value).isEqualTo(\"Value_\" + i));\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute put operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executePuts(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      IntStream.range(0, numEntries).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg4ODIwMg=="}, "originalCommit": {"oid": "65275b6a5fa3bdf344b5dbf3042705ee5b19e2a6"}, "originalPosition": 249}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcxODA3Mg==", "bodyText": "Cool, will add another test to execute multiple putAll instead of regular put opertations.", "url": "https://github.com/apache/geode/pull/4848#discussion_r401718072", "createdAt": "2020-04-01T15:46:27Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheWriter;\n+import org.apache.geode.cache.CacheWriterException;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionEvent;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.util.CacheWriterAdapter;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} can be executed multiple times on\n+ * the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME = \"[{index}] {method}(Coordinator:{0}, Region:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION,\n+        RegionShortcut.PARTITION_REDUNDANT\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] vmAndRegionTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    RegionShortcut[] regionShortcuts = regionTypes();\n+\n+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {\n+      parameters.add(new Object[] {TestVM.SERVER1, regionShortcut});\n+      parameters.add(new Object[] {TestVM.ACCESSOR, regionShortcut});\n+    });\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    server1 = getVM(TestVM.SERVER1.vmNumber);\n+    server2 = getVM(TestVM.SERVER2.vmNumber);\n+    accessor = getVM(TestVM.ACCESSOR.vmNumber);\n+  }\n+\n+  private void initAccessor(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .setLocalMaxMemory(0)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+\n+  }\n+\n+  private void initDataStore(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void parametrizedSetup(RegionShortcut regionShortcut) {\n+    server1.invoke(() -> initDataStore(regionShortcut));\n+    server2.invoke(() -> initDataStore(regionShortcut));\n+    accessor.invoke(() -> initAccessor(regionShortcut));\n+  }\n+\n+  /**\n+   * Waits until there are not PR messages in flight for the given region.\n+   */\n+  private void waitForSilence() {\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+\n+    await().untilAsserted(() -> {\n+      PartitionedRegionStats prStats = region.getPrStats();\n+      assertThat(prStats.getVolunteeringInProgress()).isEqualTo(0);\n+      assertThat(prStats.getBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getPrimaryTransfersInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalanceBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalancePrimaryTransfersInProgress()).isEqualTo(0);\n+    });\n+  }\n+\n+  private void assertRegionData(int entryCount, List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      IntStream.range(0, entryCount)\n+          .forEach(i -> assertThat(region.get(String.valueOf(i))).isEqualTo(\"Value_\" + i));\n+    }));\n+  }\n+\n+  /**\n+   * Asserts that the region is empty on requested VMs.\n+   */\n+  private void assertRegionIsEmpty(List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      assertThat(region.isEmpty()).isTrue();\n+    }));\n+  }\n+\n+  /**\n+   * Waits until there are no partition messages in flight and gets a snapshot of the region.\n+   */\n+  private Map<String, String> waitForSilenceAndGetRegionSnapshot() {\n+    waitForSilence();\n+    Map<String, String> regionSnapshot = new HashMap<>();\n+    Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+    region.forEach(regionSnapshot::put);\n+\n+    return regionSnapshot;\n+  }\n+\n+  /**\n+   * Asserts that the region data is consistent on requested VMs.\n+   */\n+  private void assertRegionDataConsistency(List<VM> vms) {\n+    // Get first snapshot to compare with the rest.\n+    final Map<String, String> vm0Snapshot =\n+        vms.get(0).invoke(this::waitForSilenceAndGetRegionSnapshot);\n+\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      final Map<String, String> thisSnapshot = waitForSilenceAndGetRegionSnapshot();\n+      assertThat(thisSnapshot).isEqualTo(vm0Snapshot);\n+      thisSnapshot.forEach((key, value) -> assertThat(value).isEqualTo(\"Value_\" + key));\n+    }));\n+  }\n+\n+  /**\n+   * Populates the region and verifies the data on the selected VMs.\n+   */\n+  private void populateRegion(VM feeder, int entryCount, List<VM> vms) {\n+    feeder.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      IntStream.range(0, entryCount).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    });\n+\n+    assertRegionData(entryCount, vms);\n+  }\n+\n+  /**\n+   * Continuously execute get operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeGets(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      // Region might have been cleared in between, that's why we check for null.\n+      IntStream.range(0, numEntries).forEach(i -> {\n+        Optional<String> nullableValue = Optional.ofNullable(region.get(String.valueOf(i)));\n+        nullableValue.ifPresent(value -> assertThat(value).isEqualTo(\"Value_\" + i));\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute put operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executePuts(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      IntStream.range(0, numEntries).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg4ODIwMg=="}, "originalCommit": {"oid": "65275b6a5fa3bdf344b5dbf3042705ee5b19e2a6"}, "originalPosition": 249}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MzI0MDYxOnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQyMzoxMDowNVrOF8dsHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNDoyMDo1OFrOF8zRcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk0NTMwOA==", "bodyText": "2 secs may be long pauses...Since there is continuous cache operation, how about sleeping for few mili secs (say 50)", "url": "https://github.com/apache/geode/pull/4848#discussion_r398945308", "createdAt": "2020-03-26T23:10:05Z", "author": {"login": "agingade"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheWriter;\n+import org.apache.geode.cache.CacheWriterException;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionEvent;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.util.CacheWriterAdapter;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} can be executed multiple times on\n+ * the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME = \"[{index}] {method}(Coordinator:{0}, Region:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION,\n+        RegionShortcut.PARTITION_REDUNDANT\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] vmAndRegionTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    RegionShortcut[] regionShortcuts = regionTypes();\n+\n+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {\n+      parameters.add(new Object[] {TestVM.SERVER1, regionShortcut});\n+      parameters.add(new Object[] {TestVM.ACCESSOR, regionShortcut});\n+    });\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    server1 = getVM(TestVM.SERVER1.vmNumber);\n+    server2 = getVM(TestVM.SERVER2.vmNumber);\n+    accessor = getVM(TestVM.ACCESSOR.vmNumber);\n+  }\n+\n+  private void initAccessor(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .setLocalMaxMemory(0)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+\n+  }\n+\n+  private void initDataStore(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void parametrizedSetup(RegionShortcut regionShortcut) {\n+    server1.invoke(() -> initDataStore(regionShortcut));\n+    server2.invoke(() -> initDataStore(regionShortcut));\n+    accessor.invoke(() -> initAccessor(regionShortcut));\n+  }\n+\n+  /**\n+   * Waits until there are not PR messages in flight for the given region.\n+   */\n+  private void waitForSilence() {\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+\n+    await().untilAsserted(() -> {\n+      PartitionedRegionStats prStats = region.getPrStats();\n+      assertThat(prStats.getVolunteeringInProgress()).isEqualTo(0);\n+      assertThat(prStats.getBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getPrimaryTransfersInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalanceBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalancePrimaryTransfersInProgress()).isEqualTo(0);\n+    });\n+  }\n+\n+  private void assertRegionData(int entryCount, List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      IntStream.range(0, entryCount)\n+          .forEach(i -> assertThat(region.get(String.valueOf(i))).isEqualTo(\"Value_\" + i));\n+    }));\n+  }\n+\n+  /**\n+   * Asserts that the region is empty on requested VMs.\n+   */\n+  private void assertRegionIsEmpty(List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      assertThat(region.isEmpty()).isTrue();\n+    }));\n+  }\n+\n+  /**\n+   * Waits until there are no partition messages in flight and gets a snapshot of the region.\n+   */\n+  private Map<String, String> waitForSilenceAndGetRegionSnapshot() {\n+    waitForSilence();\n+    Map<String, String> regionSnapshot = new HashMap<>();\n+    Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+    region.forEach(regionSnapshot::put);\n+\n+    return regionSnapshot;\n+  }\n+\n+  /**\n+   * Asserts that the region data is consistent on requested VMs.\n+   */\n+  private void assertRegionDataConsistency(List<VM> vms) {\n+    // Get first snapshot to compare with the rest.\n+    final Map<String, String> vm0Snapshot =\n+        vms.get(0).invoke(this::waitForSilenceAndGetRegionSnapshot);\n+\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      final Map<String, String> thisSnapshot = waitForSilenceAndGetRegionSnapshot();\n+      assertThat(thisSnapshot).isEqualTo(vm0Snapshot);\n+      thisSnapshot.forEach((key, value) -> assertThat(value).isEqualTo(\"Value_\" + key));\n+    }));\n+  }\n+\n+  /**\n+   * Populates the region and verifies the data on the selected VMs.\n+   */\n+  private void populateRegion(VM feeder, int entryCount, List<VM> vms) {\n+    feeder.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      IntStream.range(0, entryCount).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    });\n+\n+    assertRegionData(entryCount, vms);\n+  }\n+\n+  /**\n+   * Continuously execute get operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeGets(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      // Region might have been cleared in between, that's why we check for null.\n+      IntStream.range(0, numEntries).forEach(i -> {\n+        Optional<String> nullableValue = Optional.ofNullable(region.get(String.valueOf(i)));\n+        nullableValue.ifPresent(value -> assertThat(value).isEqualTo(\"Value_\" + i));\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute put operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executePuts(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      IntStream.range(0, numEntries).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute clear operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeClears(final long durationInSeconds, final long waitTimeInSeconds)\n+      throws InterruptedException {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      region.clear();\n+      Thread.sleep(waitTimeInSeconds * 1000);\n+    }\n+  }\n+\n+  /**\n+   * Register the MemberKiller CacheWriter on the given vms and cancel auto-reconnects.\n+   */\n+  private void registerVMKillerAsCacheWriter(List<VM> vmsToBounce) {\n+    vmsToBounce.forEach(vm -> vm.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      region.getAttributesMutator().setCacheWriter(new MemberKiller());\n+    }));\n+  }\n+\n+  /**\n+   * The test does the following (the clear coordinator is chosen through parameters):\n+   * - Populates the Partition Region.\n+   * - Verifies that the entries are synchronized on all members.\n+   * - Launches one thread per VM to continuously execute gets for 10 seconds.\n+   * - Clears the Partition Region continuously (once every 2 seconds for 10 seconds).\n+   * - Asserts that, after the clears are finished, the Partition Region is empty on all members.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"vmAndRegionTypes\")\n+  public void clearWithConcurrentGetsShouldWorkCorrectly(TestVM coordinatorVM,\n+      RegionShortcut regionShortcut) throws InterruptedException {\n+    final int entries = 10000;\n+    parametrizedSetup(regionShortcut);\n+    populateRegion(accessor, entries, asList(accessor, server1, server2));\n+\n+    // Let all VMs continuously execute gets for 10 seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executeGets(entries, 10)),\n+        server2.invokeAsync(() -> executeGets(entries, 10)),\n+        accessor.invokeAsync(() -> executeGets(entries, 10)));\n+\n+    // Clear the region every 2 seconds for 10 seconds.\n+    getVM(coordinatorVM.vmNumber).invoke(() -> executeClears(10, 2));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65275b6a5fa3bdf344b5dbf3042705ee5b19e2a6"}, "originalPosition": 302}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI5ODkzMA==", "bodyText": "Changed.", "url": "https://github.com/apache/geode/pull/4848#discussion_r399298930", "createdAt": "2020-03-27T14:20:58Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheWriter;\n+import org.apache.geode.cache.CacheWriterException;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionEvent;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.util.CacheWriterAdapter;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} can be executed multiple times on\n+ * the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME = \"[{index}] {method}(Coordinator:{0}, Region:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION,\n+        RegionShortcut.PARTITION_REDUNDANT\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] vmAndRegionTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    RegionShortcut[] regionShortcuts = regionTypes();\n+\n+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {\n+      parameters.add(new Object[] {TestVM.SERVER1, regionShortcut});\n+      parameters.add(new Object[] {TestVM.ACCESSOR, regionShortcut});\n+    });\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    server1 = getVM(TestVM.SERVER1.vmNumber);\n+    server2 = getVM(TestVM.SERVER2.vmNumber);\n+    accessor = getVM(TestVM.ACCESSOR.vmNumber);\n+  }\n+\n+  private void initAccessor(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .setLocalMaxMemory(0)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+\n+  }\n+\n+  private void initDataStore(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void parametrizedSetup(RegionShortcut regionShortcut) {\n+    server1.invoke(() -> initDataStore(regionShortcut));\n+    server2.invoke(() -> initDataStore(regionShortcut));\n+    accessor.invoke(() -> initAccessor(regionShortcut));\n+  }\n+\n+  /**\n+   * Waits until there are not PR messages in flight for the given region.\n+   */\n+  private void waitForSilence() {\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+\n+    await().untilAsserted(() -> {\n+      PartitionedRegionStats prStats = region.getPrStats();\n+      assertThat(prStats.getVolunteeringInProgress()).isEqualTo(0);\n+      assertThat(prStats.getBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getPrimaryTransfersInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalanceBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalancePrimaryTransfersInProgress()).isEqualTo(0);\n+    });\n+  }\n+\n+  private void assertRegionData(int entryCount, List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      IntStream.range(0, entryCount)\n+          .forEach(i -> assertThat(region.get(String.valueOf(i))).isEqualTo(\"Value_\" + i));\n+    }));\n+  }\n+\n+  /**\n+   * Asserts that the region is empty on requested VMs.\n+   */\n+  private void assertRegionIsEmpty(List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      assertThat(region.isEmpty()).isTrue();\n+    }));\n+  }\n+\n+  /**\n+   * Waits until there are no partition messages in flight and gets a snapshot of the region.\n+   */\n+  private Map<String, String> waitForSilenceAndGetRegionSnapshot() {\n+    waitForSilence();\n+    Map<String, String> regionSnapshot = new HashMap<>();\n+    Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+    region.forEach(regionSnapshot::put);\n+\n+    return regionSnapshot;\n+  }\n+\n+  /**\n+   * Asserts that the region data is consistent on requested VMs.\n+   */\n+  private void assertRegionDataConsistency(List<VM> vms) {\n+    // Get first snapshot to compare with the rest.\n+    final Map<String, String> vm0Snapshot =\n+        vms.get(0).invoke(this::waitForSilenceAndGetRegionSnapshot);\n+\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      final Map<String, String> thisSnapshot = waitForSilenceAndGetRegionSnapshot();\n+      assertThat(thisSnapshot).isEqualTo(vm0Snapshot);\n+      thisSnapshot.forEach((key, value) -> assertThat(value).isEqualTo(\"Value_\" + key));\n+    }));\n+  }\n+\n+  /**\n+   * Populates the region and verifies the data on the selected VMs.\n+   */\n+  private void populateRegion(VM feeder, int entryCount, List<VM> vms) {\n+    feeder.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      IntStream.range(0, entryCount).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    });\n+\n+    assertRegionData(entryCount, vms);\n+  }\n+\n+  /**\n+   * Continuously execute get operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeGets(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      // Region might have been cleared in between, that's why we check for null.\n+      IntStream.range(0, numEntries).forEach(i -> {\n+        Optional<String> nullableValue = Optional.ofNullable(region.get(String.valueOf(i)));\n+        nullableValue.ifPresent(value -> assertThat(value).isEqualTo(\"Value_\" + i));\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute put operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executePuts(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      IntStream.range(0, numEntries).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute clear operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeClears(final long durationInSeconds, final long waitTimeInSeconds)\n+      throws InterruptedException {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      region.clear();\n+      Thread.sleep(waitTimeInSeconds * 1000);\n+    }\n+  }\n+\n+  /**\n+   * Register the MemberKiller CacheWriter on the given vms and cancel auto-reconnects.\n+   */\n+  private void registerVMKillerAsCacheWriter(List<VM> vmsToBounce) {\n+    vmsToBounce.forEach(vm -> vm.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      region.getAttributesMutator().setCacheWriter(new MemberKiller());\n+    }));\n+  }\n+\n+  /**\n+   * The test does the following (the clear coordinator is chosen through parameters):\n+   * - Populates the Partition Region.\n+   * - Verifies that the entries are synchronized on all members.\n+   * - Launches one thread per VM to continuously execute gets for 10 seconds.\n+   * - Clears the Partition Region continuously (once every 2 seconds for 10 seconds).\n+   * - Asserts that, after the clears are finished, the Partition Region is empty on all members.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"vmAndRegionTypes\")\n+  public void clearWithConcurrentGetsShouldWorkCorrectly(TestVM coordinatorVM,\n+      RegionShortcut regionShortcut) throws InterruptedException {\n+    final int entries = 10000;\n+    parametrizedSetup(regionShortcut);\n+    populateRegion(accessor, entries, asList(accessor, server1, server2));\n+\n+    // Let all VMs continuously execute gets for 10 seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executeGets(entries, 10)),\n+        server2.invokeAsync(() -> executeGets(entries, 10)),\n+        accessor.invokeAsync(() -> executeGets(entries, 10)));\n+\n+    // Clear the region every 2 seconds for 10 seconds.\n+    getVM(coordinatorVM.vmNumber).invoke(() -> executeClears(10, 2));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk0NTMwOA=="}, "originalCommit": {"oid": "65275b6a5fa3bdf344b5dbf3042705ee5b19e2a6"}, "originalPosition": 302}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MzI0MTE0OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQyMzoxMDoyMVrOF8dsdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNDoyMTo1MFrOF8zTvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk0NTM5Ng==", "bodyText": "3 secs long sleep.", "url": "https://github.com/apache/geode/pull/4848#discussion_r398945396", "createdAt": "2020-03-26T23:10:21Z", "author": {"login": "agingade"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheWriter;\n+import org.apache.geode.cache.CacheWriterException;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionEvent;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.util.CacheWriterAdapter;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} can be executed multiple times on\n+ * the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME = \"[{index}] {method}(Coordinator:{0}, Region:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION,\n+        RegionShortcut.PARTITION_REDUNDANT\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] vmAndRegionTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    RegionShortcut[] regionShortcuts = regionTypes();\n+\n+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {\n+      parameters.add(new Object[] {TestVM.SERVER1, regionShortcut});\n+      parameters.add(new Object[] {TestVM.ACCESSOR, regionShortcut});\n+    });\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    server1 = getVM(TestVM.SERVER1.vmNumber);\n+    server2 = getVM(TestVM.SERVER2.vmNumber);\n+    accessor = getVM(TestVM.ACCESSOR.vmNumber);\n+  }\n+\n+  private void initAccessor(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .setLocalMaxMemory(0)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+\n+  }\n+\n+  private void initDataStore(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void parametrizedSetup(RegionShortcut regionShortcut) {\n+    server1.invoke(() -> initDataStore(regionShortcut));\n+    server2.invoke(() -> initDataStore(regionShortcut));\n+    accessor.invoke(() -> initAccessor(regionShortcut));\n+  }\n+\n+  /**\n+   * Waits until there are not PR messages in flight for the given region.\n+   */\n+  private void waitForSilence() {\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+\n+    await().untilAsserted(() -> {\n+      PartitionedRegionStats prStats = region.getPrStats();\n+      assertThat(prStats.getVolunteeringInProgress()).isEqualTo(0);\n+      assertThat(prStats.getBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getPrimaryTransfersInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalanceBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalancePrimaryTransfersInProgress()).isEqualTo(0);\n+    });\n+  }\n+\n+  private void assertRegionData(int entryCount, List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      IntStream.range(0, entryCount)\n+          .forEach(i -> assertThat(region.get(String.valueOf(i))).isEqualTo(\"Value_\" + i));\n+    }));\n+  }\n+\n+  /**\n+   * Asserts that the region is empty on requested VMs.\n+   */\n+  private void assertRegionIsEmpty(List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      assertThat(region.isEmpty()).isTrue();\n+    }));\n+  }\n+\n+  /**\n+   * Waits until there are no partition messages in flight and gets a snapshot of the region.\n+   */\n+  private Map<String, String> waitForSilenceAndGetRegionSnapshot() {\n+    waitForSilence();\n+    Map<String, String> regionSnapshot = new HashMap<>();\n+    Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+    region.forEach(regionSnapshot::put);\n+\n+    return regionSnapshot;\n+  }\n+\n+  /**\n+   * Asserts that the region data is consistent on requested VMs.\n+   */\n+  private void assertRegionDataConsistency(List<VM> vms) {\n+    // Get first snapshot to compare with the rest.\n+    final Map<String, String> vm0Snapshot =\n+        vms.get(0).invoke(this::waitForSilenceAndGetRegionSnapshot);\n+\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      final Map<String, String> thisSnapshot = waitForSilenceAndGetRegionSnapshot();\n+      assertThat(thisSnapshot).isEqualTo(vm0Snapshot);\n+      thisSnapshot.forEach((key, value) -> assertThat(value).isEqualTo(\"Value_\" + key));\n+    }));\n+  }\n+\n+  /**\n+   * Populates the region and verifies the data on the selected VMs.\n+   */\n+  private void populateRegion(VM feeder, int entryCount, List<VM> vms) {\n+    feeder.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      IntStream.range(0, entryCount).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    });\n+\n+    assertRegionData(entryCount, vms);\n+  }\n+\n+  /**\n+   * Continuously execute get operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeGets(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      // Region might have been cleared in between, that's why we check for null.\n+      IntStream.range(0, numEntries).forEach(i -> {\n+        Optional<String> nullableValue = Optional.ofNullable(region.get(String.valueOf(i)));\n+        nullableValue.ifPresent(value -> assertThat(value).isEqualTo(\"Value_\" + i));\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute put operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executePuts(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      IntStream.range(0, numEntries).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute clear operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeClears(final long durationInSeconds, final long waitTimeInSeconds)\n+      throws InterruptedException {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      region.clear();\n+      Thread.sleep(waitTimeInSeconds * 1000);\n+    }\n+  }\n+\n+  /**\n+   * Register the MemberKiller CacheWriter on the given vms and cancel auto-reconnects.\n+   */\n+  private void registerVMKillerAsCacheWriter(List<VM> vmsToBounce) {\n+    vmsToBounce.forEach(vm -> vm.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      region.getAttributesMutator().setCacheWriter(new MemberKiller());\n+    }));\n+  }\n+\n+  /**\n+   * The test does the following (the clear coordinator is chosen through parameters):\n+   * - Populates the Partition Region.\n+   * - Verifies that the entries are synchronized on all members.\n+   * - Launches one thread per VM to continuously execute gets for 10 seconds.\n+   * - Clears the Partition Region continuously (once every 2 seconds for 10 seconds).\n+   * - Asserts that, after the clears are finished, the Partition Region is empty on all members.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"vmAndRegionTypes\")\n+  public void clearWithConcurrentGetsShouldWorkCorrectly(TestVM coordinatorVM,\n+      RegionShortcut regionShortcut) throws InterruptedException {\n+    final int entries = 10000;\n+    parametrizedSetup(regionShortcut);\n+    populateRegion(accessor, entries, asList(accessor, server1, server2));\n+\n+    // Let all VMs continuously execute gets for 10 seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executeGets(entries, 10)),\n+        server2.invokeAsync(() -> executeGets(entries, 10)),\n+        accessor.invokeAsync(() -> executeGets(entries, 10)));\n+\n+    // Clear the region every 2 seconds for 10 seconds.\n+    getVM(coordinatorVM.vmNumber).invoke(() -> executeClears(10, 2));\n+\n+    // Let asyncInvocations finish.\n+    for (AsyncInvocation<Void> asyncInvocation : asyncInvocationList) {\n+      asyncInvocation.await();\n+    }\n+\n+    // Assert Region is empty across VMs.\n+    assertRegionIsEmpty(asList(accessor, server1, server1));\n+  }\n+\n+  /**\n+   * The test does the following (the clear coordinator is chosen through parameters):\n+   * - Launches one thread per VM to continuously execute puts for 15 seconds.\n+   * - Clears the Partition Region continuously (once every 3 seconds for 15 seconds).\n+   * - Asserts that, after the clears are finished, the Region data is consistent across members.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"vmAndRegionTypes\")\n+  public void clearWithConcurrentPutsShouldWorkCorrectly(TestVM coordinatorVM,\n+      RegionShortcut regionShortcut) throws InterruptedException {\n+    final int entries = 5000;\n+    parametrizedSetup(regionShortcut);\n+\n+    // Let all VMs continuously execute puts for 15 seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executePuts(entries, 15)),\n+        server2.invokeAsync(() -> executePuts(entries, 15)),\n+        accessor.invokeAsync(() -> executePuts(entries, 15)));\n+\n+    // Clear the region every 3 seconds for 15 seconds.\n+    getVM(coordinatorVM.vmNumber).invoke(() -> executeClears(15, 3));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65275b6a5fa3bdf344b5dbf3042705ee5b19e2a6"}, "originalPosition": 334}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI5OTUxOA==", "bodyText": "Changed.", "url": "https://github.com/apache/geode/pull/4848#discussion_r399299518", "createdAt": "2020-03-27T14:21:50Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheWriter;\n+import org.apache.geode.cache.CacheWriterException;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionEvent;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.util.CacheWriterAdapter;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} can be executed multiple times on\n+ * the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME = \"[{index}] {method}(Coordinator:{0}, Region:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION,\n+        RegionShortcut.PARTITION_REDUNDANT\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] vmAndRegionTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    RegionShortcut[] regionShortcuts = regionTypes();\n+\n+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {\n+      parameters.add(new Object[] {TestVM.SERVER1, regionShortcut});\n+      parameters.add(new Object[] {TestVM.ACCESSOR, regionShortcut});\n+    });\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    server1 = getVM(TestVM.SERVER1.vmNumber);\n+    server2 = getVM(TestVM.SERVER2.vmNumber);\n+    accessor = getVM(TestVM.ACCESSOR.vmNumber);\n+  }\n+\n+  private void initAccessor(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .setLocalMaxMemory(0)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+\n+  }\n+\n+  private void initDataStore(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void parametrizedSetup(RegionShortcut regionShortcut) {\n+    server1.invoke(() -> initDataStore(regionShortcut));\n+    server2.invoke(() -> initDataStore(regionShortcut));\n+    accessor.invoke(() -> initAccessor(regionShortcut));\n+  }\n+\n+  /**\n+   * Waits until there are not PR messages in flight for the given region.\n+   */\n+  private void waitForSilence() {\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+\n+    await().untilAsserted(() -> {\n+      PartitionedRegionStats prStats = region.getPrStats();\n+      assertThat(prStats.getVolunteeringInProgress()).isEqualTo(0);\n+      assertThat(prStats.getBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getPrimaryTransfersInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalanceBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalancePrimaryTransfersInProgress()).isEqualTo(0);\n+    });\n+  }\n+\n+  private void assertRegionData(int entryCount, List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      IntStream.range(0, entryCount)\n+          .forEach(i -> assertThat(region.get(String.valueOf(i))).isEqualTo(\"Value_\" + i));\n+    }));\n+  }\n+\n+  /**\n+   * Asserts that the region is empty on requested VMs.\n+   */\n+  private void assertRegionIsEmpty(List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      assertThat(region.isEmpty()).isTrue();\n+    }));\n+  }\n+\n+  /**\n+   * Waits until there are no partition messages in flight and gets a snapshot of the region.\n+   */\n+  private Map<String, String> waitForSilenceAndGetRegionSnapshot() {\n+    waitForSilence();\n+    Map<String, String> regionSnapshot = new HashMap<>();\n+    Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+    region.forEach(regionSnapshot::put);\n+\n+    return regionSnapshot;\n+  }\n+\n+  /**\n+   * Asserts that the region data is consistent on requested VMs.\n+   */\n+  private void assertRegionDataConsistency(List<VM> vms) {\n+    // Get first snapshot to compare with the rest.\n+    final Map<String, String> vm0Snapshot =\n+        vms.get(0).invoke(this::waitForSilenceAndGetRegionSnapshot);\n+\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      final Map<String, String> thisSnapshot = waitForSilenceAndGetRegionSnapshot();\n+      assertThat(thisSnapshot).isEqualTo(vm0Snapshot);\n+      thisSnapshot.forEach((key, value) -> assertThat(value).isEqualTo(\"Value_\" + key));\n+    }));\n+  }\n+\n+  /**\n+   * Populates the region and verifies the data on the selected VMs.\n+   */\n+  private void populateRegion(VM feeder, int entryCount, List<VM> vms) {\n+    feeder.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      IntStream.range(0, entryCount).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    });\n+\n+    assertRegionData(entryCount, vms);\n+  }\n+\n+  /**\n+   * Continuously execute get operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeGets(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      // Region might have been cleared in between, that's why we check for null.\n+      IntStream.range(0, numEntries).forEach(i -> {\n+        Optional<String> nullableValue = Optional.ofNullable(region.get(String.valueOf(i)));\n+        nullableValue.ifPresent(value -> assertThat(value).isEqualTo(\"Value_\" + i));\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute put operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executePuts(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      IntStream.range(0, numEntries).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute clear operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeClears(final long durationInSeconds, final long waitTimeInSeconds)\n+      throws InterruptedException {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      region.clear();\n+      Thread.sleep(waitTimeInSeconds * 1000);\n+    }\n+  }\n+\n+  /**\n+   * Register the MemberKiller CacheWriter on the given vms and cancel auto-reconnects.\n+   */\n+  private void registerVMKillerAsCacheWriter(List<VM> vmsToBounce) {\n+    vmsToBounce.forEach(vm -> vm.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      region.getAttributesMutator().setCacheWriter(new MemberKiller());\n+    }));\n+  }\n+\n+  /**\n+   * The test does the following (the clear coordinator is chosen through parameters):\n+   * - Populates the Partition Region.\n+   * - Verifies that the entries are synchronized on all members.\n+   * - Launches one thread per VM to continuously execute gets for 10 seconds.\n+   * - Clears the Partition Region continuously (once every 2 seconds for 10 seconds).\n+   * - Asserts that, after the clears are finished, the Partition Region is empty on all members.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"vmAndRegionTypes\")\n+  public void clearWithConcurrentGetsShouldWorkCorrectly(TestVM coordinatorVM,\n+      RegionShortcut regionShortcut) throws InterruptedException {\n+    final int entries = 10000;\n+    parametrizedSetup(regionShortcut);\n+    populateRegion(accessor, entries, asList(accessor, server1, server2));\n+\n+    // Let all VMs continuously execute gets for 10 seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executeGets(entries, 10)),\n+        server2.invokeAsync(() -> executeGets(entries, 10)),\n+        accessor.invokeAsync(() -> executeGets(entries, 10)));\n+\n+    // Clear the region every 2 seconds for 10 seconds.\n+    getVM(coordinatorVM.vmNumber).invoke(() -> executeClears(10, 2));\n+\n+    // Let asyncInvocations finish.\n+    for (AsyncInvocation<Void> asyncInvocation : asyncInvocationList) {\n+      asyncInvocation.await();\n+    }\n+\n+    // Assert Region is empty across VMs.\n+    assertRegionIsEmpty(asList(accessor, server1, server1));\n+  }\n+\n+  /**\n+   * The test does the following (the clear coordinator is chosen through parameters):\n+   * - Launches one thread per VM to continuously execute puts for 15 seconds.\n+   * - Clears the Partition Region continuously (once every 3 seconds for 15 seconds).\n+   * - Asserts that, after the clears are finished, the Region data is consistent across members.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"vmAndRegionTypes\")\n+  public void clearWithConcurrentPutsShouldWorkCorrectly(TestVM coordinatorVM,\n+      RegionShortcut regionShortcut) throws InterruptedException {\n+    final int entries = 5000;\n+    parametrizedSetup(regionShortcut);\n+\n+    // Let all VMs continuously execute puts for 15 seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executePuts(entries, 15)),\n+        server2.invokeAsync(() -> executePuts(entries, 15)),\n+        accessor.invokeAsync(() -> executePuts(entries, 15)));\n+\n+    // Clear the region every 3 seconds for 15 seconds.\n+    getVM(coordinatorVM.vmNumber).invoke(() -> executeClears(15, 3));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk0NTM5Ng=="}, "originalCommit": {"oid": "65275b6a5fa3bdf344b5dbf3042705ee5b19e2a6"}, "originalPosition": 334}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MzI3MDA5OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQyMzoyMjozOVrOF8d8kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxODoxMzoxMFrOF88uKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk0OTUyMg==", "bodyText": "This waits for message pertaining to region creation or status change. There is DistributionMessageObserver that can be used to see if any messages are still in progress.", "url": "https://github.com/apache/geode/pull/4848#discussion_r398949522", "createdAt": "2020-03-26T23:22:39Z", "author": {"login": "agingade"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheWriter;\n+import org.apache.geode.cache.CacheWriterException;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionEvent;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.util.CacheWriterAdapter;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} can be executed multiple times on\n+ * the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME = \"[{index}] {method}(Coordinator:{0}, Region:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION,\n+        RegionShortcut.PARTITION_REDUNDANT\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] vmAndRegionTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    RegionShortcut[] regionShortcuts = regionTypes();\n+\n+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {\n+      parameters.add(new Object[] {TestVM.SERVER1, regionShortcut});\n+      parameters.add(new Object[] {TestVM.ACCESSOR, regionShortcut});\n+    });\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    server1 = getVM(TestVM.SERVER1.vmNumber);\n+    server2 = getVM(TestVM.SERVER2.vmNumber);\n+    accessor = getVM(TestVM.ACCESSOR.vmNumber);\n+  }\n+\n+  private void initAccessor(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .setLocalMaxMemory(0)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+\n+  }\n+\n+  private void initDataStore(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void parametrizedSetup(RegionShortcut regionShortcut) {\n+    server1.invoke(() -> initDataStore(regionShortcut));\n+    server2.invoke(() -> initDataStore(regionShortcut));\n+    accessor.invoke(() -> initAccessor(regionShortcut));\n+  }\n+\n+  /**\n+   * Waits until there are not PR messages in flight for the given region.\n+   */\n+  private void waitForSilence() {\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+\n+    await().untilAsserted(() -> {\n+      PartitionedRegionStats prStats = region.getPrStats();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65275b6a5fa3bdf344b5dbf3042705ee5b19e2a6"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMwMTkwNQ==", "bodyText": "Agreed, the DistributionMessageObserver can be used but it's a test hook and I've heard we want to get rid of that eventually, that's why I chose to use another approach (which seems to work fine, so I'm not sure I should to apply the requested change here).", "url": "https://github.com/apache/geode/pull/4848#discussion_r399301905", "createdAt": "2020-03-27T14:25:09Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheWriter;\n+import org.apache.geode.cache.CacheWriterException;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionEvent;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.util.CacheWriterAdapter;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} can be executed multiple times on\n+ * the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME = \"[{index}] {method}(Coordinator:{0}, Region:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION,\n+        RegionShortcut.PARTITION_REDUNDANT\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] vmAndRegionTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    RegionShortcut[] regionShortcuts = regionTypes();\n+\n+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {\n+      parameters.add(new Object[] {TestVM.SERVER1, regionShortcut});\n+      parameters.add(new Object[] {TestVM.ACCESSOR, regionShortcut});\n+    });\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    server1 = getVM(TestVM.SERVER1.vmNumber);\n+    server2 = getVM(TestVM.SERVER2.vmNumber);\n+    accessor = getVM(TestVM.ACCESSOR.vmNumber);\n+  }\n+\n+  private void initAccessor(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .setLocalMaxMemory(0)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+\n+  }\n+\n+  private void initDataStore(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void parametrizedSetup(RegionShortcut regionShortcut) {\n+    server1.invoke(() -> initDataStore(regionShortcut));\n+    server2.invoke(() -> initDataStore(regionShortcut));\n+    accessor.invoke(() -> initAccessor(regionShortcut));\n+  }\n+\n+  /**\n+   * Waits until there are not PR messages in flight for the given region.\n+   */\n+  private void waitForSilence() {\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+\n+    await().untilAsserted(() -> {\n+      PartitionedRegionStats prStats = region.getPrStats();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk0OTUyMg=="}, "originalCommit": {"oid": "65275b6a5fa3bdf344b5dbf3042705ee5b19e2a6"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ1MzczNw==", "bodyText": "I won't foresee removal of observers; again there are multiple ways to do it; it is your choice :)", "url": "https://github.com/apache/geode/pull/4848#discussion_r399453737", "createdAt": "2020-03-27T18:13:10Z", "author": {"login": "agingade"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheWriter;\n+import org.apache.geode.cache.CacheWriterException;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionEvent;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.util.CacheWriterAdapter;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} can be executed multiple times on\n+ * the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME = \"[{index}] {method}(Coordinator:{0}, Region:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION,\n+        RegionShortcut.PARTITION_REDUNDANT\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] vmAndRegionTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    RegionShortcut[] regionShortcuts = regionTypes();\n+\n+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {\n+      parameters.add(new Object[] {TestVM.SERVER1, regionShortcut});\n+      parameters.add(new Object[] {TestVM.ACCESSOR, regionShortcut});\n+    });\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    server1 = getVM(TestVM.SERVER1.vmNumber);\n+    server2 = getVM(TestVM.SERVER2.vmNumber);\n+    accessor = getVM(TestVM.ACCESSOR.vmNumber);\n+  }\n+\n+  private void initAccessor(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .setLocalMaxMemory(0)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+\n+  }\n+\n+  private void initDataStore(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void parametrizedSetup(RegionShortcut regionShortcut) {\n+    server1.invoke(() -> initDataStore(regionShortcut));\n+    server2.invoke(() -> initDataStore(regionShortcut));\n+    accessor.invoke(() -> initAccessor(regionShortcut));\n+  }\n+\n+  /**\n+   * Waits until there are not PR messages in flight for the given region.\n+   */\n+  private void waitForSilence() {\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+\n+    await().untilAsserted(() -> {\n+      PartitionedRegionStats prStats = region.getPrStats();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk0OTUyMg=="}, "originalCommit": {"oid": "65275b6a5fa3bdf344b5dbf3042705ee5b19e2a6"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MzI4NzU1OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQyMzoyOTo1N1rOF8eGWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNTo0ODo0MlrOF_HCJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk1MjAyNw==", "bodyText": "This is going over the PRs entry/key set getting all the values. This will be consistent where-ever this is called.\nAre we trying to see if the data in one vm is same as in another vm. Or are we trying to see data in primary buckets are same as in secondary buckets.\nFetching the local PR data-set and iterating over it will give the data stored in that vm.\nOr just to see an op could be executed successfully after clear?", "url": "https://github.com/apache/geode/pull/4848#discussion_r398952027", "createdAt": "2020-03-26T23:29:57Z", "author": {"login": "agingade"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheWriter;\n+import org.apache.geode.cache.CacheWriterException;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionEvent;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.util.CacheWriterAdapter;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} can be executed multiple times on\n+ * the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME = \"[{index}] {method}(Coordinator:{0}, Region:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION,\n+        RegionShortcut.PARTITION_REDUNDANT\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] vmAndRegionTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    RegionShortcut[] regionShortcuts = regionTypes();\n+\n+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {\n+      parameters.add(new Object[] {TestVM.SERVER1, regionShortcut});\n+      parameters.add(new Object[] {TestVM.ACCESSOR, regionShortcut});\n+    });\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    server1 = getVM(TestVM.SERVER1.vmNumber);\n+    server2 = getVM(TestVM.SERVER2.vmNumber);\n+    accessor = getVM(TestVM.ACCESSOR.vmNumber);\n+  }\n+\n+  private void initAccessor(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .setLocalMaxMemory(0)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+\n+  }\n+\n+  private void initDataStore(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void parametrizedSetup(RegionShortcut regionShortcut) {\n+    server1.invoke(() -> initDataStore(regionShortcut));\n+    server2.invoke(() -> initDataStore(regionShortcut));\n+    accessor.invoke(() -> initAccessor(regionShortcut));\n+  }\n+\n+  /**\n+   * Waits until there are not PR messages in flight for the given region.\n+   */\n+  private void waitForSilence() {\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+\n+    await().untilAsserted(() -> {\n+      PartitionedRegionStats prStats = region.getPrStats();\n+      assertThat(prStats.getVolunteeringInProgress()).isEqualTo(0);\n+      assertThat(prStats.getBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getPrimaryTransfersInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalanceBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalancePrimaryTransfersInProgress()).isEqualTo(0);\n+    });\n+  }\n+\n+  private void assertRegionData(int entryCount, List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      IntStream.range(0, entryCount)\n+          .forEach(i -> assertThat(region.get(String.valueOf(i))).isEqualTo(\"Value_\" + i));\n+    }));\n+  }\n+\n+  /**\n+   * Asserts that the region is empty on requested VMs.\n+   */\n+  private void assertRegionIsEmpty(List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      assertThat(region.isEmpty()).isTrue();\n+    }));\n+  }\n+\n+  /**\n+   * Waits until there are no partition messages in flight and gets a snapshot of the region.\n+   */\n+  private Map<String, String> waitForSilenceAndGetRegionSnapshot() {\n+    waitForSilence();\n+    Map<String, String> regionSnapshot = new HashMap<>();\n+    Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+    region.forEach(regionSnapshot::put);\n+\n+    return regionSnapshot;\n+  }\n+\n+  /**\n+   * Asserts that the region data is consistent on requested VMs.\n+   */\n+  private void assertRegionDataConsistency(List<VM> vms) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65275b6a5fa3bdf344b5dbf3042705ee5b19e2a6"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMwMzUxMQ==", "bodyText": "The method asserts that the data is consistent across VMs by tacking a snapshot of the region per VM and comparing it against the other running VMs, it doesn't check primaries vs secondaries.\n    vms.forEach(vm -> vm.invoke(() -> {\n      final Map<String, String> thisSnapshot = waitForSilenceAndGetRegionSnapshot();\n      assertThat(thisSnapshot).isEqualTo(vm0Snapshot);\n      thisSnapshot.forEach((key, value) -> assertThat(value).isEqualTo(\"Value_\" + key));\n    }));", "url": "https://github.com/apache/geode/pull/4848#discussion_r399303511", "createdAt": "2020-03-27T14:27:20Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheWriter;\n+import org.apache.geode.cache.CacheWriterException;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionEvent;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.util.CacheWriterAdapter;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} can be executed multiple times on\n+ * the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME = \"[{index}] {method}(Coordinator:{0}, Region:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION,\n+        RegionShortcut.PARTITION_REDUNDANT\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] vmAndRegionTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    RegionShortcut[] regionShortcuts = regionTypes();\n+\n+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {\n+      parameters.add(new Object[] {TestVM.SERVER1, regionShortcut});\n+      parameters.add(new Object[] {TestVM.ACCESSOR, regionShortcut});\n+    });\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    server1 = getVM(TestVM.SERVER1.vmNumber);\n+    server2 = getVM(TestVM.SERVER2.vmNumber);\n+    accessor = getVM(TestVM.ACCESSOR.vmNumber);\n+  }\n+\n+  private void initAccessor(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .setLocalMaxMemory(0)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+\n+  }\n+\n+  private void initDataStore(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void parametrizedSetup(RegionShortcut regionShortcut) {\n+    server1.invoke(() -> initDataStore(regionShortcut));\n+    server2.invoke(() -> initDataStore(regionShortcut));\n+    accessor.invoke(() -> initAccessor(regionShortcut));\n+  }\n+\n+  /**\n+   * Waits until there are not PR messages in flight for the given region.\n+   */\n+  private void waitForSilence() {\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+\n+    await().untilAsserted(() -> {\n+      PartitionedRegionStats prStats = region.getPrStats();\n+      assertThat(prStats.getVolunteeringInProgress()).isEqualTo(0);\n+      assertThat(prStats.getBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getPrimaryTransfersInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalanceBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalancePrimaryTransfersInProgress()).isEqualTo(0);\n+    });\n+  }\n+\n+  private void assertRegionData(int entryCount, List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      IntStream.range(0, entryCount)\n+          .forEach(i -> assertThat(region.get(String.valueOf(i))).isEqualTo(\"Value_\" + i));\n+    }));\n+  }\n+\n+  /**\n+   * Asserts that the region is empty on requested VMs.\n+   */\n+  private void assertRegionIsEmpty(List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      assertThat(region.isEmpty()).isTrue();\n+    }));\n+  }\n+\n+  /**\n+   * Waits until there are no partition messages in flight and gets a snapshot of the region.\n+   */\n+  private Map<String, String> waitForSilenceAndGetRegionSnapshot() {\n+    waitForSilence();\n+    Map<String, String> regionSnapshot = new HashMap<>();\n+    Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+    region.forEach(regionSnapshot::put);\n+\n+    return regionSnapshot;\n+  }\n+\n+  /**\n+   * Asserts that the region data is consistent on requested VMs.\n+   */\n+  private void assertRegionDataConsistency(List<VM> vms) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk1MjAyNw=="}, "originalCommit": {"oid": "65275b6a5fa3bdf344b5dbf3042705ee5b19e2a6"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ1NTY1MQ==", "bodyText": "What I am trying to says is, since you are iterating over the PR region; it will get the data from all the nodes. Thats remains same across all the nodes.", "url": "https://github.com/apache/geode/pull/4848#discussion_r399455651", "createdAt": "2020-03-27T18:16:42Z", "author": {"login": "agingade"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheWriter;\n+import org.apache.geode.cache.CacheWriterException;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionEvent;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.util.CacheWriterAdapter;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} can be executed multiple times on\n+ * the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME = \"[{index}] {method}(Coordinator:{0}, Region:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION,\n+        RegionShortcut.PARTITION_REDUNDANT\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] vmAndRegionTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    RegionShortcut[] regionShortcuts = regionTypes();\n+\n+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {\n+      parameters.add(new Object[] {TestVM.SERVER1, regionShortcut});\n+      parameters.add(new Object[] {TestVM.ACCESSOR, regionShortcut});\n+    });\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    server1 = getVM(TestVM.SERVER1.vmNumber);\n+    server2 = getVM(TestVM.SERVER2.vmNumber);\n+    accessor = getVM(TestVM.ACCESSOR.vmNumber);\n+  }\n+\n+  private void initAccessor(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .setLocalMaxMemory(0)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+\n+  }\n+\n+  private void initDataStore(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void parametrizedSetup(RegionShortcut regionShortcut) {\n+    server1.invoke(() -> initDataStore(regionShortcut));\n+    server2.invoke(() -> initDataStore(regionShortcut));\n+    accessor.invoke(() -> initAccessor(regionShortcut));\n+  }\n+\n+  /**\n+   * Waits until there are not PR messages in flight for the given region.\n+   */\n+  private void waitForSilence() {\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+\n+    await().untilAsserted(() -> {\n+      PartitionedRegionStats prStats = region.getPrStats();\n+      assertThat(prStats.getVolunteeringInProgress()).isEqualTo(0);\n+      assertThat(prStats.getBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getPrimaryTransfersInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalanceBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalancePrimaryTransfersInProgress()).isEqualTo(0);\n+    });\n+  }\n+\n+  private void assertRegionData(int entryCount, List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      IntStream.range(0, entryCount)\n+          .forEach(i -> assertThat(region.get(String.valueOf(i))).isEqualTo(\"Value_\" + i));\n+    }));\n+  }\n+\n+  /**\n+   * Asserts that the region is empty on requested VMs.\n+   */\n+  private void assertRegionIsEmpty(List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      assertThat(region.isEmpty()).isTrue();\n+    }));\n+  }\n+\n+  /**\n+   * Waits until there are no partition messages in flight and gets a snapshot of the region.\n+   */\n+  private Map<String, String> waitForSilenceAndGetRegionSnapshot() {\n+    waitForSilence();\n+    Map<String, String> regionSnapshot = new HashMap<>();\n+    Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+    region.forEach(regionSnapshot::put);\n+\n+    return regionSnapshot;\n+  }\n+\n+  /**\n+   * Asserts that the region data is consistent on requested VMs.\n+   */\n+  private void assertRegionDataConsistency(List<VM> vms) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk1MjAyNw=="}, "originalCommit": {"oid": "65275b6a5fa3bdf344b5dbf3042705ee5b19e2a6"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcxOTg0NA==", "bodyText": "@agingade : got your point, thanks for catching this. Will change the method to verify that the data both on the primary and secondary buckets are in sync.", "url": "https://github.com/apache/geode/pull/4848#discussion_r401719844", "createdAt": "2020-04-01T15:48:42Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheWriter;\n+import org.apache.geode.cache.CacheWriterException;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionEvent;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.util.CacheWriterAdapter;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} can be executed multiple times on\n+ * the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME = \"[{index}] {method}(Coordinator:{0}, Region:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION,\n+        RegionShortcut.PARTITION_REDUNDANT\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] vmAndRegionTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    RegionShortcut[] regionShortcuts = regionTypes();\n+\n+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {\n+      parameters.add(new Object[] {TestVM.SERVER1, regionShortcut});\n+      parameters.add(new Object[] {TestVM.ACCESSOR, regionShortcut});\n+    });\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    server1 = getVM(TestVM.SERVER1.vmNumber);\n+    server2 = getVM(TestVM.SERVER2.vmNumber);\n+    accessor = getVM(TestVM.ACCESSOR.vmNumber);\n+  }\n+\n+  private void initAccessor(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .setLocalMaxMemory(0)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+\n+  }\n+\n+  private void initDataStore(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void parametrizedSetup(RegionShortcut regionShortcut) {\n+    server1.invoke(() -> initDataStore(regionShortcut));\n+    server2.invoke(() -> initDataStore(regionShortcut));\n+    accessor.invoke(() -> initAccessor(regionShortcut));\n+  }\n+\n+  /**\n+   * Waits until there are not PR messages in flight for the given region.\n+   */\n+  private void waitForSilence() {\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+\n+    await().untilAsserted(() -> {\n+      PartitionedRegionStats prStats = region.getPrStats();\n+      assertThat(prStats.getVolunteeringInProgress()).isEqualTo(0);\n+      assertThat(prStats.getBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getPrimaryTransfersInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalanceBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalancePrimaryTransfersInProgress()).isEqualTo(0);\n+    });\n+  }\n+\n+  private void assertRegionData(int entryCount, List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      IntStream.range(0, entryCount)\n+          .forEach(i -> assertThat(region.get(String.valueOf(i))).isEqualTo(\"Value_\" + i));\n+    }));\n+  }\n+\n+  /**\n+   * Asserts that the region is empty on requested VMs.\n+   */\n+  private void assertRegionIsEmpty(List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      assertThat(region.isEmpty()).isTrue();\n+    }));\n+  }\n+\n+  /**\n+   * Waits until there are no partition messages in flight and gets a snapshot of the region.\n+   */\n+  private Map<String, String> waitForSilenceAndGetRegionSnapshot() {\n+    waitForSilence();\n+    Map<String, String> regionSnapshot = new HashMap<>();\n+    Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+    region.forEach(regionSnapshot::put);\n+\n+    return regionSnapshot;\n+  }\n+\n+  /**\n+   * Asserts that the region data is consistent on requested VMs.\n+   */\n+  private void assertRegionDataConsistency(List<VM> vms) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk1MjAyNw=="}, "originalCommit": {"oid": "65275b6a5fa3bdf344b5dbf3042705ee5b19e2a6"}, "originalPosition": 199}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MzI5MzE4OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQyMzozMjozMlrOF8eJqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNDoyNzoyOVrOF8zj7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk1Mjg3NQ==", "bodyText": "No need to specify time; if someone changes the time and doesn't update it, this will become incorrect.", "url": "https://github.com/apache/geode/pull/4848#discussion_r398952875", "createdAt": "2020-03-26T23:32:32Z", "author": {"login": "agingade"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheWriter;\n+import org.apache.geode.cache.CacheWriterException;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionEvent;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.util.CacheWriterAdapter;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} can be executed multiple times on\n+ * the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME = \"[{index}] {method}(Coordinator:{0}, Region:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION,\n+        RegionShortcut.PARTITION_REDUNDANT\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] vmAndRegionTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    RegionShortcut[] regionShortcuts = regionTypes();\n+\n+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {\n+      parameters.add(new Object[] {TestVM.SERVER1, regionShortcut});\n+      parameters.add(new Object[] {TestVM.ACCESSOR, regionShortcut});\n+    });\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    server1 = getVM(TestVM.SERVER1.vmNumber);\n+    server2 = getVM(TestVM.SERVER2.vmNumber);\n+    accessor = getVM(TestVM.ACCESSOR.vmNumber);\n+  }\n+\n+  private void initAccessor(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .setLocalMaxMemory(0)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+\n+  }\n+\n+  private void initDataStore(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void parametrizedSetup(RegionShortcut regionShortcut) {\n+    server1.invoke(() -> initDataStore(regionShortcut));\n+    server2.invoke(() -> initDataStore(regionShortcut));\n+    accessor.invoke(() -> initAccessor(regionShortcut));\n+  }\n+\n+  /**\n+   * Waits until there are not PR messages in flight for the given region.\n+   */\n+  private void waitForSilence() {\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+\n+    await().untilAsserted(() -> {\n+      PartitionedRegionStats prStats = region.getPrStats();\n+      assertThat(prStats.getVolunteeringInProgress()).isEqualTo(0);\n+      assertThat(prStats.getBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getPrimaryTransfersInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalanceBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalancePrimaryTransfersInProgress()).isEqualTo(0);\n+    });\n+  }\n+\n+  private void assertRegionData(int entryCount, List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      IntStream.range(0, entryCount)\n+          .forEach(i -> assertThat(region.get(String.valueOf(i))).isEqualTo(\"Value_\" + i));\n+    }));\n+  }\n+\n+  /**\n+   * Asserts that the region is empty on requested VMs.\n+   */\n+  private void assertRegionIsEmpty(List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      assertThat(region.isEmpty()).isTrue();\n+    }));\n+  }\n+\n+  /**\n+   * Waits until there are no partition messages in flight and gets a snapshot of the region.\n+   */\n+  private Map<String, String> waitForSilenceAndGetRegionSnapshot() {\n+    waitForSilence();\n+    Map<String, String> regionSnapshot = new HashMap<>();\n+    Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+    region.forEach(regionSnapshot::put);\n+\n+    return regionSnapshot;\n+  }\n+\n+  /**\n+   * Asserts that the region data is consistent on requested VMs.\n+   */\n+  private void assertRegionDataConsistency(List<VM> vms) {\n+    // Get first snapshot to compare with the rest.\n+    final Map<String, String> vm0Snapshot =\n+        vms.get(0).invoke(this::waitForSilenceAndGetRegionSnapshot);\n+\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      final Map<String, String> thisSnapshot = waitForSilenceAndGetRegionSnapshot();\n+      assertThat(thisSnapshot).isEqualTo(vm0Snapshot);\n+      thisSnapshot.forEach((key, value) -> assertThat(value).isEqualTo(\"Value_\" + key));\n+    }));\n+  }\n+\n+  /**\n+   * Populates the region and verifies the data on the selected VMs.\n+   */\n+  private void populateRegion(VM feeder, int entryCount, List<VM> vms) {\n+    feeder.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      IntStream.range(0, entryCount).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    });\n+\n+    assertRegionData(entryCount, vms);\n+  }\n+\n+  /**\n+   * Continuously execute get operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeGets(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      // Region might have been cleared in between, that's why we check for null.\n+      IntStream.range(0, numEntries).forEach(i -> {\n+        Optional<String> nullableValue = Optional.ofNullable(region.get(String.valueOf(i)));\n+        nullableValue.ifPresent(value -> assertThat(value).isEqualTo(\"Value_\" + i));\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute put operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executePuts(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      IntStream.range(0, numEntries).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute clear operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeClears(final long durationInSeconds, final long waitTimeInSeconds)\n+      throws InterruptedException {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      region.clear();\n+      Thread.sleep(waitTimeInSeconds * 1000);\n+    }\n+  }\n+\n+  /**\n+   * Register the MemberKiller CacheWriter on the given vms and cancel auto-reconnects.\n+   */\n+  private void registerVMKillerAsCacheWriter(List<VM> vmsToBounce) {\n+    vmsToBounce.forEach(vm -> vm.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      region.getAttributesMutator().setCacheWriter(new MemberKiller());\n+    }));\n+  }\n+\n+  /**\n+   * The test does the following (the clear coordinator is chosen through parameters):\n+   * - Populates the Partition Region.\n+   * - Verifies that the entries are synchronized on all members.\n+   * - Launches one thread per VM to continuously execute gets for 10 seconds.\n+   * - Clears the Partition Region continuously (once every 2 seconds for 10 seconds).\n+   * - Asserts that, after the clears are finished, the Partition Region is empty on all members.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"vmAndRegionTypes\")\n+  public void clearWithConcurrentGetsShouldWorkCorrectly(TestVM coordinatorVM,\n+      RegionShortcut regionShortcut) throws InterruptedException {\n+    final int entries = 10000;\n+    parametrizedSetup(regionShortcut);\n+    populateRegion(accessor, entries, asList(accessor, server1, server2));\n+\n+    // Let all VMs continuously execute gets for 10 seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executeGets(entries, 10)),\n+        server2.invokeAsync(() -> executeGets(entries, 10)),\n+        accessor.invokeAsync(() -> executeGets(entries, 10)));\n+\n+    // Clear the region every 2 seconds for 10 seconds.\n+    getVM(coordinatorVM.vmNumber).invoke(() -> executeClears(10, 2));\n+\n+    // Let asyncInvocations finish.\n+    for (AsyncInvocation<Void> asyncInvocation : asyncInvocationList) {\n+      asyncInvocation.await();\n+    }\n+\n+    // Assert Region is empty across VMs.\n+    assertRegionIsEmpty(asList(accessor, server1, server1));\n+  }\n+\n+  /**\n+   * The test does the following (the clear coordinator is chosen through parameters):\n+   * - Launches one thread per VM to continuously execute puts for 15 seconds.\n+   * - Clears the Partition Region continuously (once every 3 seconds for 15 seconds).\n+   * - Asserts that, after the clears are finished, the Region data is consistent across members.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"vmAndRegionTypes\")\n+  public void clearWithConcurrentPutsShouldWorkCorrectly(TestVM coordinatorVM,\n+      RegionShortcut regionShortcut) throws InterruptedException {\n+    final int entries = 5000;\n+    parametrizedSetup(regionShortcut);\n+\n+    // Let all VMs continuously execute puts for 15 seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executePuts(entries, 15)),\n+        server2.invokeAsync(() -> executePuts(entries, 15)),\n+        accessor.invokeAsync(() -> executePuts(entries, 15)));\n+\n+    // Clear the region every 3 seconds for 15 seconds.\n+    getVM(coordinatorVM.vmNumber).invoke(() -> executeClears(15, 3));\n+\n+    // Let asyncInvocations finish.\n+    for (AsyncInvocation<Void> asyncInvocation : asyncInvocationList) {\n+      asyncInvocation.await();\n+    }\n+\n+    // Assert Region Data is consistent across members.\n+    assertRegionDataConsistency(asList(accessor, server1, server2));\n+  }\n+\n+  /**\n+   * The test does the following (the clear coordinator is chosen through parameters):\n+   * - Launches threads to continuously execute puts and gets for 60 seconds.\n+   * - Clears the Partition Region continuously (once every 10 seconds for 60 seconds).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65275b6a5fa3bdf344b5dbf3042705ee5b19e2a6"}, "originalPosition": 348}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMwMzY2MA==", "bodyText": "Done!.", "url": "https://github.com/apache/geode/pull/4848#discussion_r399303660", "createdAt": "2020-03-27T14:27:29Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheWriter;\n+import org.apache.geode.cache.CacheWriterException;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionEvent;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.util.CacheWriterAdapter;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} can be executed multiple times on\n+ * the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME = \"[{index}] {method}(Coordinator:{0}, Region:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION,\n+        RegionShortcut.PARTITION_REDUNDANT\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] vmAndRegionTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    RegionShortcut[] regionShortcuts = regionTypes();\n+\n+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {\n+      parameters.add(new Object[] {TestVM.SERVER1, regionShortcut});\n+      parameters.add(new Object[] {TestVM.ACCESSOR, regionShortcut});\n+    });\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    server1 = getVM(TestVM.SERVER1.vmNumber);\n+    server2 = getVM(TestVM.SERVER2.vmNumber);\n+    accessor = getVM(TestVM.ACCESSOR.vmNumber);\n+  }\n+\n+  private void initAccessor(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .setLocalMaxMemory(0)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+\n+  }\n+\n+  private void initDataStore(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void parametrizedSetup(RegionShortcut regionShortcut) {\n+    server1.invoke(() -> initDataStore(regionShortcut));\n+    server2.invoke(() -> initDataStore(regionShortcut));\n+    accessor.invoke(() -> initAccessor(regionShortcut));\n+  }\n+\n+  /**\n+   * Waits until there are not PR messages in flight for the given region.\n+   */\n+  private void waitForSilence() {\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+\n+    await().untilAsserted(() -> {\n+      PartitionedRegionStats prStats = region.getPrStats();\n+      assertThat(prStats.getVolunteeringInProgress()).isEqualTo(0);\n+      assertThat(prStats.getBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getPrimaryTransfersInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalanceBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalancePrimaryTransfersInProgress()).isEqualTo(0);\n+    });\n+  }\n+\n+  private void assertRegionData(int entryCount, List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      IntStream.range(0, entryCount)\n+          .forEach(i -> assertThat(region.get(String.valueOf(i))).isEqualTo(\"Value_\" + i));\n+    }));\n+  }\n+\n+  /**\n+   * Asserts that the region is empty on requested VMs.\n+   */\n+  private void assertRegionIsEmpty(List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      assertThat(region.isEmpty()).isTrue();\n+    }));\n+  }\n+\n+  /**\n+   * Waits until there are no partition messages in flight and gets a snapshot of the region.\n+   */\n+  private Map<String, String> waitForSilenceAndGetRegionSnapshot() {\n+    waitForSilence();\n+    Map<String, String> regionSnapshot = new HashMap<>();\n+    Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+    region.forEach(regionSnapshot::put);\n+\n+    return regionSnapshot;\n+  }\n+\n+  /**\n+   * Asserts that the region data is consistent on requested VMs.\n+   */\n+  private void assertRegionDataConsistency(List<VM> vms) {\n+    // Get first snapshot to compare with the rest.\n+    final Map<String, String> vm0Snapshot =\n+        vms.get(0).invoke(this::waitForSilenceAndGetRegionSnapshot);\n+\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      final Map<String, String> thisSnapshot = waitForSilenceAndGetRegionSnapshot();\n+      assertThat(thisSnapshot).isEqualTo(vm0Snapshot);\n+      thisSnapshot.forEach((key, value) -> assertThat(value).isEqualTo(\"Value_\" + key));\n+    }));\n+  }\n+\n+  /**\n+   * Populates the region and verifies the data on the selected VMs.\n+   */\n+  private void populateRegion(VM feeder, int entryCount, List<VM> vms) {\n+    feeder.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      IntStream.range(0, entryCount).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    });\n+\n+    assertRegionData(entryCount, vms);\n+  }\n+\n+  /**\n+   * Continuously execute get operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeGets(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      // Region might have been cleared in between, that's why we check for null.\n+      IntStream.range(0, numEntries).forEach(i -> {\n+        Optional<String> nullableValue = Optional.ofNullable(region.get(String.valueOf(i)));\n+        nullableValue.ifPresent(value -> assertThat(value).isEqualTo(\"Value_\" + i));\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute put operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executePuts(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      IntStream.range(0, numEntries).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute clear operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeClears(final long durationInSeconds, final long waitTimeInSeconds)\n+      throws InterruptedException {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      region.clear();\n+      Thread.sleep(waitTimeInSeconds * 1000);\n+    }\n+  }\n+\n+  /**\n+   * Register the MemberKiller CacheWriter on the given vms and cancel auto-reconnects.\n+   */\n+  private void registerVMKillerAsCacheWriter(List<VM> vmsToBounce) {\n+    vmsToBounce.forEach(vm -> vm.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      region.getAttributesMutator().setCacheWriter(new MemberKiller());\n+    }));\n+  }\n+\n+  /**\n+   * The test does the following (the clear coordinator is chosen through parameters):\n+   * - Populates the Partition Region.\n+   * - Verifies that the entries are synchronized on all members.\n+   * - Launches one thread per VM to continuously execute gets for 10 seconds.\n+   * - Clears the Partition Region continuously (once every 2 seconds for 10 seconds).\n+   * - Asserts that, after the clears are finished, the Partition Region is empty on all members.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"vmAndRegionTypes\")\n+  public void clearWithConcurrentGetsShouldWorkCorrectly(TestVM coordinatorVM,\n+      RegionShortcut regionShortcut) throws InterruptedException {\n+    final int entries = 10000;\n+    parametrizedSetup(regionShortcut);\n+    populateRegion(accessor, entries, asList(accessor, server1, server2));\n+\n+    // Let all VMs continuously execute gets for 10 seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executeGets(entries, 10)),\n+        server2.invokeAsync(() -> executeGets(entries, 10)),\n+        accessor.invokeAsync(() -> executeGets(entries, 10)));\n+\n+    // Clear the region every 2 seconds for 10 seconds.\n+    getVM(coordinatorVM.vmNumber).invoke(() -> executeClears(10, 2));\n+\n+    // Let asyncInvocations finish.\n+    for (AsyncInvocation<Void> asyncInvocation : asyncInvocationList) {\n+      asyncInvocation.await();\n+    }\n+\n+    // Assert Region is empty across VMs.\n+    assertRegionIsEmpty(asList(accessor, server1, server1));\n+  }\n+\n+  /**\n+   * The test does the following (the clear coordinator is chosen through parameters):\n+   * - Launches one thread per VM to continuously execute puts for 15 seconds.\n+   * - Clears the Partition Region continuously (once every 3 seconds for 15 seconds).\n+   * - Asserts that, after the clears are finished, the Region data is consistent across members.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"vmAndRegionTypes\")\n+  public void clearWithConcurrentPutsShouldWorkCorrectly(TestVM coordinatorVM,\n+      RegionShortcut regionShortcut) throws InterruptedException {\n+    final int entries = 5000;\n+    parametrizedSetup(regionShortcut);\n+\n+    // Let all VMs continuously execute puts for 15 seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executePuts(entries, 15)),\n+        server2.invokeAsync(() -> executePuts(entries, 15)),\n+        accessor.invokeAsync(() -> executePuts(entries, 15)));\n+\n+    // Clear the region every 3 seconds for 15 seconds.\n+    getVM(coordinatorVM.vmNumber).invoke(() -> executeClears(15, 3));\n+\n+    // Let asyncInvocations finish.\n+    for (AsyncInvocation<Void> asyncInvocation : asyncInvocationList) {\n+      asyncInvocation.await();\n+    }\n+\n+    // Assert Region Data is consistent across members.\n+    assertRegionDataConsistency(asList(accessor, server1, server2));\n+  }\n+\n+  /**\n+   * The test does the following (the clear coordinator is chosen through parameters):\n+   * - Launches threads to continuously execute puts and gets for 60 seconds.\n+   * - Clears the Partition Region continuously (once every 10 seconds for 60 seconds).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk1Mjg3NQ=="}, "originalCommit": {"oid": "65275b6a5fa3bdf344b5dbf3042705ee5b19e2a6"}, "originalPosition": 348}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MzMyNDQ4OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQyMzo0Nzo0NVrOF8eccg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxODoxOToxMFrOF887Lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk1NzY4Mg==", "bodyText": "Instead of CacheWriter, you can use DistributionMessageObserver. And can use VM.bounce* to kill vms. No need to wait for CacheWriter messaging implementation.", "url": "https://github.com/apache/geode/pull/4848#discussion_r398957682", "createdAt": "2020-03-26T23:47:45Z", "author": {"login": "agingade"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheWriter;\n+import org.apache.geode.cache.CacheWriterException;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionEvent;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.util.CacheWriterAdapter;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} can be executed multiple times on\n+ * the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME = \"[{index}] {method}(Coordinator:{0}, Region:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION,\n+        RegionShortcut.PARTITION_REDUNDANT\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] vmAndRegionTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    RegionShortcut[] regionShortcuts = regionTypes();\n+\n+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {\n+      parameters.add(new Object[] {TestVM.SERVER1, regionShortcut});\n+      parameters.add(new Object[] {TestVM.ACCESSOR, regionShortcut});\n+    });\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    server1 = getVM(TestVM.SERVER1.vmNumber);\n+    server2 = getVM(TestVM.SERVER2.vmNumber);\n+    accessor = getVM(TestVM.ACCESSOR.vmNumber);\n+  }\n+\n+  private void initAccessor(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .setLocalMaxMemory(0)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+\n+  }\n+\n+  private void initDataStore(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void parametrizedSetup(RegionShortcut regionShortcut) {\n+    server1.invoke(() -> initDataStore(regionShortcut));\n+    server2.invoke(() -> initDataStore(regionShortcut));\n+    accessor.invoke(() -> initAccessor(regionShortcut));\n+  }\n+\n+  /**\n+   * Waits until there are not PR messages in flight for the given region.\n+   */\n+  private void waitForSilence() {\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+\n+    await().untilAsserted(() -> {\n+      PartitionedRegionStats prStats = region.getPrStats();\n+      assertThat(prStats.getVolunteeringInProgress()).isEqualTo(0);\n+      assertThat(prStats.getBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getPrimaryTransfersInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalanceBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalancePrimaryTransfersInProgress()).isEqualTo(0);\n+    });\n+  }\n+\n+  private void assertRegionData(int entryCount, List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      IntStream.range(0, entryCount)\n+          .forEach(i -> assertThat(region.get(String.valueOf(i))).isEqualTo(\"Value_\" + i));\n+    }));\n+  }\n+\n+  /**\n+   * Asserts that the region is empty on requested VMs.\n+   */\n+  private void assertRegionIsEmpty(List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      assertThat(region.isEmpty()).isTrue();\n+    }));\n+  }\n+\n+  /**\n+   * Waits until there are no partition messages in flight and gets a snapshot of the region.\n+   */\n+  private Map<String, String> waitForSilenceAndGetRegionSnapshot() {\n+    waitForSilence();\n+    Map<String, String> regionSnapshot = new HashMap<>();\n+    Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+    region.forEach(regionSnapshot::put);\n+\n+    return regionSnapshot;\n+  }\n+\n+  /**\n+   * Asserts that the region data is consistent on requested VMs.\n+   */\n+  private void assertRegionDataConsistency(List<VM> vms) {\n+    // Get first snapshot to compare with the rest.\n+    final Map<String, String> vm0Snapshot =\n+        vms.get(0).invoke(this::waitForSilenceAndGetRegionSnapshot);\n+\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      final Map<String, String> thisSnapshot = waitForSilenceAndGetRegionSnapshot();\n+      assertThat(thisSnapshot).isEqualTo(vm0Snapshot);\n+      thisSnapshot.forEach((key, value) -> assertThat(value).isEqualTo(\"Value_\" + key));\n+    }));\n+  }\n+\n+  /**\n+   * Populates the region and verifies the data on the selected VMs.\n+   */\n+  private void populateRegion(VM feeder, int entryCount, List<VM> vms) {\n+    feeder.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      IntStream.range(0, entryCount).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    });\n+\n+    assertRegionData(entryCount, vms);\n+  }\n+\n+  /**\n+   * Continuously execute get operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeGets(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      // Region might have been cleared in between, that's why we check for null.\n+      IntStream.range(0, numEntries).forEach(i -> {\n+        Optional<String> nullableValue = Optional.ofNullable(region.get(String.valueOf(i)));\n+        nullableValue.ifPresent(value -> assertThat(value).isEqualTo(\"Value_\" + i));\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute put operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executePuts(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      IntStream.range(0, numEntries).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute clear operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeClears(final long durationInSeconds, final long waitTimeInSeconds)\n+      throws InterruptedException {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      region.clear();\n+      Thread.sleep(waitTimeInSeconds * 1000);\n+    }\n+  }\n+\n+  /**\n+   * Register the MemberKiller CacheWriter on the given vms and cancel auto-reconnects.\n+   */\n+  private void registerVMKillerAsCacheWriter(List<VM> vmsToBounce) {\n+    vmsToBounce.forEach(vm -> vm.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      region.getAttributesMutator().setCacheWriter(new MemberKiller());\n+    }));\n+  }\n+\n+  /**\n+   * The test does the following (the clear coordinator is chosen through parameters):\n+   * - Populates the Partition Region.\n+   * - Verifies that the entries are synchronized on all members.\n+   * - Launches one thread per VM to continuously execute gets for 10 seconds.\n+   * - Clears the Partition Region continuously (once every 2 seconds for 10 seconds).\n+   * - Asserts that, after the clears are finished, the Partition Region is empty on all members.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"vmAndRegionTypes\")\n+  public void clearWithConcurrentGetsShouldWorkCorrectly(TestVM coordinatorVM,\n+      RegionShortcut regionShortcut) throws InterruptedException {\n+    final int entries = 10000;\n+    parametrizedSetup(regionShortcut);\n+    populateRegion(accessor, entries, asList(accessor, server1, server2));\n+\n+    // Let all VMs continuously execute gets for 10 seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executeGets(entries, 10)),\n+        server2.invokeAsync(() -> executeGets(entries, 10)),\n+        accessor.invokeAsync(() -> executeGets(entries, 10)));\n+\n+    // Clear the region every 2 seconds for 10 seconds.\n+    getVM(coordinatorVM.vmNumber).invoke(() -> executeClears(10, 2));\n+\n+    // Let asyncInvocations finish.\n+    for (AsyncInvocation<Void> asyncInvocation : asyncInvocationList) {\n+      asyncInvocation.await();\n+    }\n+\n+    // Assert Region is empty across VMs.\n+    assertRegionIsEmpty(asList(accessor, server1, server1));\n+  }\n+\n+  /**\n+   * The test does the following (the clear coordinator is chosen through parameters):\n+   * - Launches one thread per VM to continuously execute puts for 15 seconds.\n+   * - Clears the Partition Region continuously (once every 3 seconds for 15 seconds).\n+   * - Asserts that, after the clears are finished, the Region data is consistent across members.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"vmAndRegionTypes\")\n+  public void clearWithConcurrentPutsShouldWorkCorrectly(TestVM coordinatorVM,\n+      RegionShortcut regionShortcut) throws InterruptedException {\n+    final int entries = 5000;\n+    parametrizedSetup(regionShortcut);\n+\n+    // Let all VMs continuously execute puts for 15 seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executePuts(entries, 15)),\n+        server2.invokeAsync(() -> executePuts(entries, 15)),\n+        accessor.invokeAsync(() -> executePuts(entries, 15)));\n+\n+    // Clear the region every 3 seconds for 15 seconds.\n+    getVM(coordinatorVM.vmNumber).invoke(() -> executeClears(15, 3));\n+\n+    // Let asyncInvocations finish.\n+    for (AsyncInvocation<Void> asyncInvocation : asyncInvocationList) {\n+      asyncInvocation.await();\n+    }\n+\n+    // Assert Region Data is consistent across members.\n+    assertRegionDataConsistency(asList(accessor, server1, server2));\n+  }\n+\n+  /**\n+   * The test does the following (the clear coordinator is chosen through parameters):\n+   * - Launches threads to continuously execute puts and gets for 60 seconds.\n+   * - Clears the Partition Region continuously (once every 10 seconds for 60 seconds).\n+   * - Asserts that, after the clears are finished, the Region data is consistent across members.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"vmAndRegionTypes\")\n+  public void clearWithConcurrentPutsAndGetsShouldWorkCorrectly(TestVM coordinatorVM,\n+      RegionShortcut regionShortcut)\n+      throws InterruptedException {\n+    final int entries = 15000;\n+    parametrizedSetup(regionShortcut);\n+\n+    // Let all VMs continuously execute puts and gets for 60 seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executeGets(entries, 60)),\n+        server2.invokeAsync(() -> executeGets(entries, 60)),\n+        accessor.invokeAsync(() -> executePuts(entries, 60)));\n+\n+    // Clear the region every 10 seconds for 60 seconds.\n+    getVM(coordinatorVM.vmNumber).invoke(() -> executeClears(60, 10));\n+\n+    // Let asyncInvocations finish.\n+    for (AsyncInvocation<Void> asyncInvocation : asyncInvocationList) {\n+      asyncInvocation.await();\n+    }\n+\n+    // Assert Region Data is consistent across members.\n+    assertRegionDataConsistency(asList(accessor, server1, server2));\n+  }\n+\n+  /**\n+   * The test does the following:\n+   * - Populates the Partition Region.\n+   * - Verifies that the entries are synchronized on all members.\n+   * - Sets the {@link MemberKiller} as a {@link CacheWriter} to stop the coordinator VM while the\n+   * clear is in progress.\n+   * - Clears the Partition Region (at this point the coordinator is restarted).\n+   * - Asserts that, after the member joins again, entries have not been deleted.\n+   */\n+  @Test\n+  @TestCaseName(\"[{index}] {method}(Region:{0})\")\n+  @Parameters(method = \"regionTypes\")\n+  public void clearShouldFailWhenCoordinatorMemberIsBounced(RegionShortcut regionShortcut) {\n+    final int entries = 1000;\n+    parametrizedSetup(regionShortcut);\n+    populateRegion(accessor, entries, asList(accessor, server1, server2));\n+    registerVMKillerAsCacheWriter(Collections.singletonList(server1));\n+\n+    // Clear the region.\n+    server1.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      assertThatThrownBy(region::clear)\n+          .isInstanceOf(DistributedSystemDisconnectedException.class)\n+          .hasCauseInstanceOf(ForcedDisconnectException.class);\n+    });\n+\n+    // Wait for member to get back online.\n+    server1.invoke(() -> {\n+      cacheRule.createCache();\n+      initDataStore(regionShortcut);\n+\n+      await().untilAsserted(\n+          () -> assertThat(InternalDistributedSystem.getConnectedInstance()).isNotNull());\n+    });\n+\n+    // Assert Region Data is consistent across members.\n+    assertRegionDataConsistency(asList(accessor, server1, server2));\n+  }\n+\n+  /**\n+   * The test does the following (the clear coordinator is chosen through parameters):\n+   * - Populates the Partition Region.\n+   * - Verifies that the entries are synchronized on all members.\n+   * - Sets the {@link MemberKiller} as a {@link CacheWriter} to stop a non-coordinator VM while the\n+   * clear is in progress (the member has primary buckets, though, so participates on\n+   * the clear operation).\n+   * - Launches one thread per VM to continuously execute gets for 60 seconds.\n+   * - Clears the Partition Region (at this point the non-coordinator is restarted).\n+   * - Asserts that, after the clears are finished, the Partition Region is empty on all members.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"vmAndRegionTypes\")\n+  public void clearWithConcurrentGetsShouldWorkCorrectlyWhenNonCoordinatorMembersAreBounced(\n+      TestVM coordinatorVM, RegionShortcut regionShortcut) throws InterruptedException {\n+    final int entries = 7500;\n+    parametrizedSetup(regionShortcut);\n+    registerVMKillerAsCacheWriter(Collections.singletonList(server2));\n+    populateRegion(accessor, entries, asList(accessor, server1, server2));\n+\n+    // Let all VMs (except the one to kill) continuously execute gets for 60 seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executeGets(entries, 60)),\n+        accessor.invokeAsync(() -> executeGets(entries, 60)));\n+\n+    // Clear the region.\n+    getVM(coordinatorVM.vmNumber).invoke(() -> cacheRule.getCache().getRegion(REGION_NAME).clear());\n+\n+    // Wait for member to get back online.\n+    server2.invoke(() -> {\n+      cacheRule.createCache();\n+      initDataStore(regionShortcut);\n+      await().untilAsserted(\n+          () -> assertThat(InternalDistributedSystem.getConnectedInstance()).isNotNull());\n+    });\n+\n+    // Let asyncInvocations finish.\n+    for (AsyncInvocation<Void> asyncInvocation : asyncInvocationList) {\n+      asyncInvocation.await();\n+    }\n+\n+    // Assert Region is empty across VMs.\n+    assertRegionIsEmpty(asList(accessor, server1, server2));\n+  }\n+\n+  /**\n+   * The test does the following (the clear coordinator is chosen through parameters):\n+   * - Sets the {@link MemberKiller} as a {@link CacheWriter} to stop a non-coordinator VM while the\n+   * clear is in progress (the member has primary buckets, though, so participates on\n+   * the clear operation).\n+   * - Launches one thread per VM to continuously execute puts for 30 seconds.\n+   * - Clears the Partition Region (at this point the non-coordinator is restarted).\n+   * - Asserts that, after the clears are finished, the Region data is consistent across members.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"vmAndRegionTypes\")\n+  public void clearWithConcurrentPutsShouldWorkCorrectlyWhenNonCoordinatorMembersAreBounced(\n+      TestVM coordinatorVM, RegionShortcut regionShortcut) throws InterruptedException {\n+    final int entries = 7000;\n+    parametrizedSetup(regionShortcut);\n+    registerVMKillerAsCacheWriter(Collections.singletonList(server2));\n+\n+    // Let all VMs (except the one to kill) continuously execute gets for 60 seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executePuts(entries, 60)),\n+        accessor.invokeAsync(() -> executePuts(entries, 60)));\n+\n+    // Clear the region.\n+    getVM(coordinatorVM.vmNumber).invoke(() -> cacheRule.getCache().getRegion(REGION_NAME).clear());\n+\n+    // Wait for member to get back online.\n+    server2.invoke(() -> {\n+      cacheRule.createCache();\n+      initDataStore(regionShortcut);\n+      await().untilAsserted(\n+          () -> assertThat(InternalDistributedSystem.getConnectedInstance()).isNotNull());\n+    });\n+\n+    // Let asyncInvocations finish.\n+    for (AsyncInvocation<Void> asyncInvocation : asyncInvocationList) {\n+      asyncInvocation.await();\n+    }\n+\n+    // Assert Region Data is consistent across members.\n+    assertRegionDataConsistency(asList(accessor, server1, server2));\n+  }\n+\n+  /**\n+   * Shutdowns a member while the clear operation is in progress.\n+   * The writer is only installed on the member the test wants to shutdown, doesn't matter whether\n+   * it's the clear coordinator or another member holding primary buckets.\n+   *\n+   * TODO: Review once GEODE-7678 / GEODE-7912 are merged (CacheWriter lifecycle might change).\n+   */\n+  public static class MemberKiller extends CacheWriterAdapter<String, String> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65275b6a5fa3bdf344b5dbf3042705ee5b19e2a6"}, "originalPosition": 513}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMwNDkxNA==", "bodyText": "Same as above, I'm still inclined to use the CacheWriter for now instead of the DistributionMessageObserver hook. If the lifecycle of the listener changes, I'll be more than happy to use another approach :-). If you think this should block the PR from being merged, though, I'll explore using the DistributionMessageObserver.", "url": "https://github.com/apache/geode/pull/4848#discussion_r399304914", "createdAt": "2020-03-27T14:29:03Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheWriter;\n+import org.apache.geode.cache.CacheWriterException;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionEvent;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.util.CacheWriterAdapter;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} can be executed multiple times on\n+ * the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME = \"[{index}] {method}(Coordinator:{0}, Region:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION,\n+        RegionShortcut.PARTITION_REDUNDANT\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] vmAndRegionTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    RegionShortcut[] regionShortcuts = regionTypes();\n+\n+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {\n+      parameters.add(new Object[] {TestVM.SERVER1, regionShortcut});\n+      parameters.add(new Object[] {TestVM.ACCESSOR, regionShortcut});\n+    });\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    server1 = getVM(TestVM.SERVER1.vmNumber);\n+    server2 = getVM(TestVM.SERVER2.vmNumber);\n+    accessor = getVM(TestVM.ACCESSOR.vmNumber);\n+  }\n+\n+  private void initAccessor(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .setLocalMaxMemory(0)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+\n+  }\n+\n+  private void initDataStore(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void parametrizedSetup(RegionShortcut regionShortcut) {\n+    server1.invoke(() -> initDataStore(regionShortcut));\n+    server2.invoke(() -> initDataStore(regionShortcut));\n+    accessor.invoke(() -> initAccessor(regionShortcut));\n+  }\n+\n+  /**\n+   * Waits until there are not PR messages in flight for the given region.\n+   */\n+  private void waitForSilence() {\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+\n+    await().untilAsserted(() -> {\n+      PartitionedRegionStats prStats = region.getPrStats();\n+      assertThat(prStats.getVolunteeringInProgress()).isEqualTo(0);\n+      assertThat(prStats.getBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getPrimaryTransfersInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalanceBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalancePrimaryTransfersInProgress()).isEqualTo(0);\n+    });\n+  }\n+\n+  private void assertRegionData(int entryCount, List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      IntStream.range(0, entryCount)\n+          .forEach(i -> assertThat(region.get(String.valueOf(i))).isEqualTo(\"Value_\" + i));\n+    }));\n+  }\n+\n+  /**\n+   * Asserts that the region is empty on requested VMs.\n+   */\n+  private void assertRegionIsEmpty(List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      assertThat(region.isEmpty()).isTrue();\n+    }));\n+  }\n+\n+  /**\n+   * Waits until there are no partition messages in flight and gets a snapshot of the region.\n+   */\n+  private Map<String, String> waitForSilenceAndGetRegionSnapshot() {\n+    waitForSilence();\n+    Map<String, String> regionSnapshot = new HashMap<>();\n+    Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+    region.forEach(regionSnapshot::put);\n+\n+    return regionSnapshot;\n+  }\n+\n+  /**\n+   * Asserts that the region data is consistent on requested VMs.\n+   */\n+  private void assertRegionDataConsistency(List<VM> vms) {\n+    // Get first snapshot to compare with the rest.\n+    final Map<String, String> vm0Snapshot =\n+        vms.get(0).invoke(this::waitForSilenceAndGetRegionSnapshot);\n+\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      final Map<String, String> thisSnapshot = waitForSilenceAndGetRegionSnapshot();\n+      assertThat(thisSnapshot).isEqualTo(vm0Snapshot);\n+      thisSnapshot.forEach((key, value) -> assertThat(value).isEqualTo(\"Value_\" + key));\n+    }));\n+  }\n+\n+  /**\n+   * Populates the region and verifies the data on the selected VMs.\n+   */\n+  private void populateRegion(VM feeder, int entryCount, List<VM> vms) {\n+    feeder.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      IntStream.range(0, entryCount).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    });\n+\n+    assertRegionData(entryCount, vms);\n+  }\n+\n+  /**\n+   * Continuously execute get operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeGets(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      // Region might have been cleared in between, that's why we check for null.\n+      IntStream.range(0, numEntries).forEach(i -> {\n+        Optional<String> nullableValue = Optional.ofNullable(region.get(String.valueOf(i)));\n+        nullableValue.ifPresent(value -> assertThat(value).isEqualTo(\"Value_\" + i));\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute put operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executePuts(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      IntStream.range(0, numEntries).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute clear operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeClears(final long durationInSeconds, final long waitTimeInSeconds)\n+      throws InterruptedException {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      region.clear();\n+      Thread.sleep(waitTimeInSeconds * 1000);\n+    }\n+  }\n+\n+  /**\n+   * Register the MemberKiller CacheWriter on the given vms and cancel auto-reconnects.\n+   */\n+  private void registerVMKillerAsCacheWriter(List<VM> vmsToBounce) {\n+    vmsToBounce.forEach(vm -> vm.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      region.getAttributesMutator().setCacheWriter(new MemberKiller());\n+    }));\n+  }\n+\n+  /**\n+   * The test does the following (the clear coordinator is chosen through parameters):\n+   * - Populates the Partition Region.\n+   * - Verifies that the entries are synchronized on all members.\n+   * - Launches one thread per VM to continuously execute gets for 10 seconds.\n+   * - Clears the Partition Region continuously (once every 2 seconds for 10 seconds).\n+   * - Asserts that, after the clears are finished, the Partition Region is empty on all members.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"vmAndRegionTypes\")\n+  public void clearWithConcurrentGetsShouldWorkCorrectly(TestVM coordinatorVM,\n+      RegionShortcut regionShortcut) throws InterruptedException {\n+    final int entries = 10000;\n+    parametrizedSetup(regionShortcut);\n+    populateRegion(accessor, entries, asList(accessor, server1, server2));\n+\n+    // Let all VMs continuously execute gets for 10 seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executeGets(entries, 10)),\n+        server2.invokeAsync(() -> executeGets(entries, 10)),\n+        accessor.invokeAsync(() -> executeGets(entries, 10)));\n+\n+    // Clear the region every 2 seconds for 10 seconds.\n+    getVM(coordinatorVM.vmNumber).invoke(() -> executeClears(10, 2));\n+\n+    // Let asyncInvocations finish.\n+    for (AsyncInvocation<Void> asyncInvocation : asyncInvocationList) {\n+      asyncInvocation.await();\n+    }\n+\n+    // Assert Region is empty across VMs.\n+    assertRegionIsEmpty(asList(accessor, server1, server1));\n+  }\n+\n+  /**\n+   * The test does the following (the clear coordinator is chosen through parameters):\n+   * - Launches one thread per VM to continuously execute puts for 15 seconds.\n+   * - Clears the Partition Region continuously (once every 3 seconds for 15 seconds).\n+   * - Asserts that, after the clears are finished, the Region data is consistent across members.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"vmAndRegionTypes\")\n+  public void clearWithConcurrentPutsShouldWorkCorrectly(TestVM coordinatorVM,\n+      RegionShortcut regionShortcut) throws InterruptedException {\n+    final int entries = 5000;\n+    parametrizedSetup(regionShortcut);\n+\n+    // Let all VMs continuously execute puts for 15 seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executePuts(entries, 15)),\n+        server2.invokeAsync(() -> executePuts(entries, 15)),\n+        accessor.invokeAsync(() -> executePuts(entries, 15)));\n+\n+    // Clear the region every 3 seconds for 15 seconds.\n+    getVM(coordinatorVM.vmNumber).invoke(() -> executeClears(15, 3));\n+\n+    // Let asyncInvocations finish.\n+    for (AsyncInvocation<Void> asyncInvocation : asyncInvocationList) {\n+      asyncInvocation.await();\n+    }\n+\n+    // Assert Region Data is consistent across members.\n+    assertRegionDataConsistency(asList(accessor, server1, server2));\n+  }\n+\n+  /**\n+   * The test does the following (the clear coordinator is chosen through parameters):\n+   * - Launches threads to continuously execute puts and gets for 60 seconds.\n+   * - Clears the Partition Region continuously (once every 10 seconds for 60 seconds).\n+   * - Asserts that, after the clears are finished, the Region data is consistent across members.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"vmAndRegionTypes\")\n+  public void clearWithConcurrentPutsAndGetsShouldWorkCorrectly(TestVM coordinatorVM,\n+      RegionShortcut regionShortcut)\n+      throws InterruptedException {\n+    final int entries = 15000;\n+    parametrizedSetup(regionShortcut);\n+\n+    // Let all VMs continuously execute puts and gets for 60 seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executeGets(entries, 60)),\n+        server2.invokeAsync(() -> executeGets(entries, 60)),\n+        accessor.invokeAsync(() -> executePuts(entries, 60)));\n+\n+    // Clear the region every 10 seconds for 60 seconds.\n+    getVM(coordinatorVM.vmNumber).invoke(() -> executeClears(60, 10));\n+\n+    // Let asyncInvocations finish.\n+    for (AsyncInvocation<Void> asyncInvocation : asyncInvocationList) {\n+      asyncInvocation.await();\n+    }\n+\n+    // Assert Region Data is consistent across members.\n+    assertRegionDataConsistency(asList(accessor, server1, server2));\n+  }\n+\n+  /**\n+   * The test does the following:\n+   * - Populates the Partition Region.\n+   * - Verifies that the entries are synchronized on all members.\n+   * - Sets the {@link MemberKiller} as a {@link CacheWriter} to stop the coordinator VM while the\n+   * clear is in progress.\n+   * - Clears the Partition Region (at this point the coordinator is restarted).\n+   * - Asserts that, after the member joins again, entries have not been deleted.\n+   */\n+  @Test\n+  @TestCaseName(\"[{index}] {method}(Region:{0})\")\n+  @Parameters(method = \"regionTypes\")\n+  public void clearShouldFailWhenCoordinatorMemberIsBounced(RegionShortcut regionShortcut) {\n+    final int entries = 1000;\n+    parametrizedSetup(regionShortcut);\n+    populateRegion(accessor, entries, asList(accessor, server1, server2));\n+    registerVMKillerAsCacheWriter(Collections.singletonList(server1));\n+\n+    // Clear the region.\n+    server1.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      assertThatThrownBy(region::clear)\n+          .isInstanceOf(DistributedSystemDisconnectedException.class)\n+          .hasCauseInstanceOf(ForcedDisconnectException.class);\n+    });\n+\n+    // Wait for member to get back online.\n+    server1.invoke(() -> {\n+      cacheRule.createCache();\n+      initDataStore(regionShortcut);\n+\n+      await().untilAsserted(\n+          () -> assertThat(InternalDistributedSystem.getConnectedInstance()).isNotNull());\n+    });\n+\n+    // Assert Region Data is consistent across members.\n+    assertRegionDataConsistency(asList(accessor, server1, server2));\n+  }\n+\n+  /**\n+   * The test does the following (the clear coordinator is chosen through parameters):\n+   * - Populates the Partition Region.\n+   * - Verifies that the entries are synchronized on all members.\n+   * - Sets the {@link MemberKiller} as a {@link CacheWriter} to stop a non-coordinator VM while the\n+   * clear is in progress (the member has primary buckets, though, so participates on\n+   * the clear operation).\n+   * - Launches one thread per VM to continuously execute gets for 60 seconds.\n+   * - Clears the Partition Region (at this point the non-coordinator is restarted).\n+   * - Asserts that, after the clears are finished, the Partition Region is empty on all members.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"vmAndRegionTypes\")\n+  public void clearWithConcurrentGetsShouldWorkCorrectlyWhenNonCoordinatorMembersAreBounced(\n+      TestVM coordinatorVM, RegionShortcut regionShortcut) throws InterruptedException {\n+    final int entries = 7500;\n+    parametrizedSetup(regionShortcut);\n+    registerVMKillerAsCacheWriter(Collections.singletonList(server2));\n+    populateRegion(accessor, entries, asList(accessor, server1, server2));\n+\n+    // Let all VMs (except the one to kill) continuously execute gets for 60 seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executeGets(entries, 60)),\n+        accessor.invokeAsync(() -> executeGets(entries, 60)));\n+\n+    // Clear the region.\n+    getVM(coordinatorVM.vmNumber).invoke(() -> cacheRule.getCache().getRegion(REGION_NAME).clear());\n+\n+    // Wait for member to get back online.\n+    server2.invoke(() -> {\n+      cacheRule.createCache();\n+      initDataStore(regionShortcut);\n+      await().untilAsserted(\n+          () -> assertThat(InternalDistributedSystem.getConnectedInstance()).isNotNull());\n+    });\n+\n+    // Let asyncInvocations finish.\n+    for (AsyncInvocation<Void> asyncInvocation : asyncInvocationList) {\n+      asyncInvocation.await();\n+    }\n+\n+    // Assert Region is empty across VMs.\n+    assertRegionIsEmpty(asList(accessor, server1, server2));\n+  }\n+\n+  /**\n+   * The test does the following (the clear coordinator is chosen through parameters):\n+   * - Sets the {@link MemberKiller} as a {@link CacheWriter} to stop a non-coordinator VM while the\n+   * clear is in progress (the member has primary buckets, though, so participates on\n+   * the clear operation).\n+   * - Launches one thread per VM to continuously execute puts for 30 seconds.\n+   * - Clears the Partition Region (at this point the non-coordinator is restarted).\n+   * - Asserts that, after the clears are finished, the Region data is consistent across members.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"vmAndRegionTypes\")\n+  public void clearWithConcurrentPutsShouldWorkCorrectlyWhenNonCoordinatorMembersAreBounced(\n+      TestVM coordinatorVM, RegionShortcut regionShortcut) throws InterruptedException {\n+    final int entries = 7000;\n+    parametrizedSetup(regionShortcut);\n+    registerVMKillerAsCacheWriter(Collections.singletonList(server2));\n+\n+    // Let all VMs (except the one to kill) continuously execute gets for 60 seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executePuts(entries, 60)),\n+        accessor.invokeAsync(() -> executePuts(entries, 60)));\n+\n+    // Clear the region.\n+    getVM(coordinatorVM.vmNumber).invoke(() -> cacheRule.getCache().getRegion(REGION_NAME).clear());\n+\n+    // Wait for member to get back online.\n+    server2.invoke(() -> {\n+      cacheRule.createCache();\n+      initDataStore(regionShortcut);\n+      await().untilAsserted(\n+          () -> assertThat(InternalDistributedSystem.getConnectedInstance()).isNotNull());\n+    });\n+\n+    // Let asyncInvocations finish.\n+    for (AsyncInvocation<Void> asyncInvocation : asyncInvocationList) {\n+      asyncInvocation.await();\n+    }\n+\n+    // Assert Region Data is consistent across members.\n+    assertRegionDataConsistency(asList(accessor, server1, server2));\n+  }\n+\n+  /**\n+   * Shutdowns a member while the clear operation is in progress.\n+   * The writer is only installed on the member the test wants to shutdown, doesn't matter whether\n+   * it's the clear coordinator or another member holding primary buckets.\n+   *\n+   * TODO: Review once GEODE-7678 / GEODE-7912 are merged (CacheWriter lifecycle might change).\n+   */\n+  public static class MemberKiller extends CacheWriterAdapter<String, String> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk1NzY4Mg=="}, "originalCommit": {"oid": "65275b6a5fa3bdf344b5dbf3042705ee5b19e2a6"}, "originalPosition": 513}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ1NzA3MQ==", "bodyText": "I don't think lifecycle of listeners changing. Its your choice.", "url": "https://github.com/apache/geode/pull/4848#discussion_r399457071", "createdAt": "2020-03-27T18:19:10Z", "author": {"login": "agingade"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheWriter;\n+import org.apache.geode.cache.CacheWriterException;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionEvent;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.util.CacheWriterAdapter;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} can be executed multiple times on\n+ * the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME = \"[{index}] {method}(Coordinator:{0}, Region:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION,\n+        RegionShortcut.PARTITION_REDUNDANT\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] vmAndRegionTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    RegionShortcut[] regionShortcuts = regionTypes();\n+\n+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {\n+      parameters.add(new Object[] {TestVM.SERVER1, regionShortcut});\n+      parameters.add(new Object[] {TestVM.ACCESSOR, regionShortcut});\n+    });\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    server1 = getVM(TestVM.SERVER1.vmNumber);\n+    server2 = getVM(TestVM.SERVER2.vmNumber);\n+    accessor = getVM(TestVM.ACCESSOR.vmNumber);\n+  }\n+\n+  private void initAccessor(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .setLocalMaxMemory(0)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+\n+  }\n+\n+  private void initDataStore(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void parametrizedSetup(RegionShortcut regionShortcut) {\n+    server1.invoke(() -> initDataStore(regionShortcut));\n+    server2.invoke(() -> initDataStore(regionShortcut));\n+    accessor.invoke(() -> initAccessor(regionShortcut));\n+  }\n+\n+  /**\n+   * Waits until there are not PR messages in flight for the given region.\n+   */\n+  private void waitForSilence() {\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+\n+    await().untilAsserted(() -> {\n+      PartitionedRegionStats prStats = region.getPrStats();\n+      assertThat(prStats.getVolunteeringInProgress()).isEqualTo(0);\n+      assertThat(prStats.getBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getPrimaryTransfersInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalanceBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(prStats.getRebalancePrimaryTransfersInProgress()).isEqualTo(0);\n+    });\n+  }\n+\n+  private void assertRegionData(int entryCount, List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      IntStream.range(0, entryCount)\n+          .forEach(i -> assertThat(region.get(String.valueOf(i))).isEqualTo(\"Value_\" + i));\n+    }));\n+  }\n+\n+  /**\n+   * Asserts that the region is empty on requested VMs.\n+   */\n+  private void assertRegionIsEmpty(List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      assertThat(region.isEmpty()).isTrue();\n+    }));\n+  }\n+\n+  /**\n+   * Waits until there are no partition messages in flight and gets a snapshot of the region.\n+   */\n+  private Map<String, String> waitForSilenceAndGetRegionSnapshot() {\n+    waitForSilence();\n+    Map<String, String> regionSnapshot = new HashMap<>();\n+    Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+    region.forEach(regionSnapshot::put);\n+\n+    return regionSnapshot;\n+  }\n+\n+  /**\n+   * Asserts that the region data is consistent on requested VMs.\n+   */\n+  private void assertRegionDataConsistency(List<VM> vms) {\n+    // Get first snapshot to compare with the rest.\n+    final Map<String, String> vm0Snapshot =\n+        vms.get(0).invoke(this::waitForSilenceAndGetRegionSnapshot);\n+\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      final Map<String, String> thisSnapshot = waitForSilenceAndGetRegionSnapshot();\n+      assertThat(thisSnapshot).isEqualTo(vm0Snapshot);\n+      thisSnapshot.forEach((key, value) -> assertThat(value).isEqualTo(\"Value_\" + key));\n+    }));\n+  }\n+\n+  /**\n+   * Populates the region and verifies the data on the selected VMs.\n+   */\n+  private void populateRegion(VM feeder, int entryCount, List<VM> vms) {\n+    feeder.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      IntStream.range(0, entryCount).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    });\n+\n+    assertRegionData(entryCount, vms);\n+  }\n+\n+  /**\n+   * Continuously execute get operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeGets(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      // Region might have been cleared in between, that's why we check for null.\n+      IntStream.range(0, numEntries).forEach(i -> {\n+        Optional<String> nullableValue = Optional.ofNullable(region.get(String.valueOf(i)));\n+        nullableValue.ifPresent(value -> assertThat(value).isEqualTo(\"Value_\" + i));\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute put operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executePuts(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      IntStream.range(0, numEntries).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute clear operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeClears(final long durationInSeconds, final long waitTimeInSeconds)\n+      throws InterruptedException {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      region.clear();\n+      Thread.sleep(waitTimeInSeconds * 1000);\n+    }\n+  }\n+\n+  /**\n+   * Register the MemberKiller CacheWriter on the given vms and cancel auto-reconnects.\n+   */\n+  private void registerVMKillerAsCacheWriter(List<VM> vmsToBounce) {\n+    vmsToBounce.forEach(vm -> vm.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      region.getAttributesMutator().setCacheWriter(new MemberKiller());\n+    }));\n+  }\n+\n+  /**\n+   * The test does the following (the clear coordinator is chosen through parameters):\n+   * - Populates the Partition Region.\n+   * - Verifies that the entries are synchronized on all members.\n+   * - Launches one thread per VM to continuously execute gets for 10 seconds.\n+   * - Clears the Partition Region continuously (once every 2 seconds for 10 seconds).\n+   * - Asserts that, after the clears are finished, the Partition Region is empty on all members.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"vmAndRegionTypes\")\n+  public void clearWithConcurrentGetsShouldWorkCorrectly(TestVM coordinatorVM,\n+      RegionShortcut regionShortcut) throws InterruptedException {\n+    final int entries = 10000;\n+    parametrizedSetup(regionShortcut);\n+    populateRegion(accessor, entries, asList(accessor, server1, server2));\n+\n+    // Let all VMs continuously execute gets for 10 seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executeGets(entries, 10)),\n+        server2.invokeAsync(() -> executeGets(entries, 10)),\n+        accessor.invokeAsync(() -> executeGets(entries, 10)));\n+\n+    // Clear the region every 2 seconds for 10 seconds.\n+    getVM(coordinatorVM.vmNumber).invoke(() -> executeClears(10, 2));\n+\n+    // Let asyncInvocations finish.\n+    for (AsyncInvocation<Void> asyncInvocation : asyncInvocationList) {\n+      asyncInvocation.await();\n+    }\n+\n+    // Assert Region is empty across VMs.\n+    assertRegionIsEmpty(asList(accessor, server1, server1));\n+  }\n+\n+  /**\n+   * The test does the following (the clear coordinator is chosen through parameters):\n+   * - Launches one thread per VM to continuously execute puts for 15 seconds.\n+   * - Clears the Partition Region continuously (once every 3 seconds for 15 seconds).\n+   * - Asserts that, after the clears are finished, the Region data is consistent across members.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"vmAndRegionTypes\")\n+  public void clearWithConcurrentPutsShouldWorkCorrectly(TestVM coordinatorVM,\n+      RegionShortcut regionShortcut) throws InterruptedException {\n+    final int entries = 5000;\n+    parametrizedSetup(regionShortcut);\n+\n+    // Let all VMs continuously execute puts for 15 seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executePuts(entries, 15)),\n+        server2.invokeAsync(() -> executePuts(entries, 15)),\n+        accessor.invokeAsync(() -> executePuts(entries, 15)));\n+\n+    // Clear the region every 3 seconds for 15 seconds.\n+    getVM(coordinatorVM.vmNumber).invoke(() -> executeClears(15, 3));\n+\n+    // Let asyncInvocations finish.\n+    for (AsyncInvocation<Void> asyncInvocation : asyncInvocationList) {\n+      asyncInvocation.await();\n+    }\n+\n+    // Assert Region Data is consistent across members.\n+    assertRegionDataConsistency(asList(accessor, server1, server2));\n+  }\n+\n+  /**\n+   * The test does the following (the clear coordinator is chosen through parameters):\n+   * - Launches threads to continuously execute puts and gets for 60 seconds.\n+   * - Clears the Partition Region continuously (once every 10 seconds for 60 seconds).\n+   * - Asserts that, after the clears are finished, the Region data is consistent across members.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"vmAndRegionTypes\")\n+  public void clearWithConcurrentPutsAndGetsShouldWorkCorrectly(TestVM coordinatorVM,\n+      RegionShortcut regionShortcut)\n+      throws InterruptedException {\n+    final int entries = 15000;\n+    parametrizedSetup(regionShortcut);\n+\n+    // Let all VMs continuously execute puts and gets for 60 seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executeGets(entries, 60)),\n+        server2.invokeAsync(() -> executeGets(entries, 60)),\n+        accessor.invokeAsync(() -> executePuts(entries, 60)));\n+\n+    // Clear the region every 10 seconds for 60 seconds.\n+    getVM(coordinatorVM.vmNumber).invoke(() -> executeClears(60, 10));\n+\n+    // Let asyncInvocations finish.\n+    for (AsyncInvocation<Void> asyncInvocation : asyncInvocationList) {\n+      asyncInvocation.await();\n+    }\n+\n+    // Assert Region Data is consistent across members.\n+    assertRegionDataConsistency(asList(accessor, server1, server2));\n+  }\n+\n+  /**\n+   * The test does the following:\n+   * - Populates the Partition Region.\n+   * - Verifies that the entries are synchronized on all members.\n+   * - Sets the {@link MemberKiller} as a {@link CacheWriter} to stop the coordinator VM while the\n+   * clear is in progress.\n+   * - Clears the Partition Region (at this point the coordinator is restarted).\n+   * - Asserts that, after the member joins again, entries have not been deleted.\n+   */\n+  @Test\n+  @TestCaseName(\"[{index}] {method}(Region:{0})\")\n+  @Parameters(method = \"regionTypes\")\n+  public void clearShouldFailWhenCoordinatorMemberIsBounced(RegionShortcut regionShortcut) {\n+    final int entries = 1000;\n+    parametrizedSetup(regionShortcut);\n+    populateRegion(accessor, entries, asList(accessor, server1, server2));\n+    registerVMKillerAsCacheWriter(Collections.singletonList(server1));\n+\n+    // Clear the region.\n+    server1.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      assertThatThrownBy(region::clear)\n+          .isInstanceOf(DistributedSystemDisconnectedException.class)\n+          .hasCauseInstanceOf(ForcedDisconnectException.class);\n+    });\n+\n+    // Wait for member to get back online.\n+    server1.invoke(() -> {\n+      cacheRule.createCache();\n+      initDataStore(regionShortcut);\n+\n+      await().untilAsserted(\n+          () -> assertThat(InternalDistributedSystem.getConnectedInstance()).isNotNull());\n+    });\n+\n+    // Assert Region Data is consistent across members.\n+    assertRegionDataConsistency(asList(accessor, server1, server2));\n+  }\n+\n+  /**\n+   * The test does the following (the clear coordinator is chosen through parameters):\n+   * - Populates the Partition Region.\n+   * - Verifies that the entries are synchronized on all members.\n+   * - Sets the {@link MemberKiller} as a {@link CacheWriter} to stop a non-coordinator VM while the\n+   * clear is in progress (the member has primary buckets, though, so participates on\n+   * the clear operation).\n+   * - Launches one thread per VM to continuously execute gets for 60 seconds.\n+   * - Clears the Partition Region (at this point the non-coordinator is restarted).\n+   * - Asserts that, after the clears are finished, the Partition Region is empty on all members.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"vmAndRegionTypes\")\n+  public void clearWithConcurrentGetsShouldWorkCorrectlyWhenNonCoordinatorMembersAreBounced(\n+      TestVM coordinatorVM, RegionShortcut regionShortcut) throws InterruptedException {\n+    final int entries = 7500;\n+    parametrizedSetup(regionShortcut);\n+    registerVMKillerAsCacheWriter(Collections.singletonList(server2));\n+    populateRegion(accessor, entries, asList(accessor, server1, server2));\n+\n+    // Let all VMs (except the one to kill) continuously execute gets for 60 seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executeGets(entries, 60)),\n+        accessor.invokeAsync(() -> executeGets(entries, 60)));\n+\n+    // Clear the region.\n+    getVM(coordinatorVM.vmNumber).invoke(() -> cacheRule.getCache().getRegion(REGION_NAME).clear());\n+\n+    // Wait for member to get back online.\n+    server2.invoke(() -> {\n+      cacheRule.createCache();\n+      initDataStore(regionShortcut);\n+      await().untilAsserted(\n+          () -> assertThat(InternalDistributedSystem.getConnectedInstance()).isNotNull());\n+    });\n+\n+    // Let asyncInvocations finish.\n+    for (AsyncInvocation<Void> asyncInvocation : asyncInvocationList) {\n+      asyncInvocation.await();\n+    }\n+\n+    // Assert Region is empty across VMs.\n+    assertRegionIsEmpty(asList(accessor, server1, server2));\n+  }\n+\n+  /**\n+   * The test does the following (the clear coordinator is chosen through parameters):\n+   * - Sets the {@link MemberKiller} as a {@link CacheWriter} to stop a non-coordinator VM while the\n+   * clear is in progress (the member has primary buckets, though, so participates on\n+   * the clear operation).\n+   * - Launches one thread per VM to continuously execute puts for 30 seconds.\n+   * - Clears the Partition Region (at this point the non-coordinator is restarted).\n+   * - Asserts that, after the clears are finished, the Region data is consistent across members.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"vmAndRegionTypes\")\n+  public void clearWithConcurrentPutsShouldWorkCorrectlyWhenNonCoordinatorMembersAreBounced(\n+      TestVM coordinatorVM, RegionShortcut regionShortcut) throws InterruptedException {\n+    final int entries = 7000;\n+    parametrizedSetup(regionShortcut);\n+    registerVMKillerAsCacheWriter(Collections.singletonList(server2));\n+\n+    // Let all VMs (except the one to kill) continuously execute gets for 60 seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executePuts(entries, 60)),\n+        accessor.invokeAsync(() -> executePuts(entries, 60)));\n+\n+    // Clear the region.\n+    getVM(coordinatorVM.vmNumber).invoke(() -> cacheRule.getCache().getRegion(REGION_NAME).clear());\n+\n+    // Wait for member to get back online.\n+    server2.invoke(() -> {\n+      cacheRule.createCache();\n+      initDataStore(regionShortcut);\n+      await().untilAsserted(\n+          () -> assertThat(InternalDistributedSystem.getConnectedInstance()).isNotNull());\n+    });\n+\n+    // Let asyncInvocations finish.\n+    for (AsyncInvocation<Void> asyncInvocation : asyncInvocationList) {\n+      asyncInvocation.await();\n+    }\n+\n+    // Assert Region Data is consistent across members.\n+    assertRegionDataConsistency(asList(accessor, server1, server2));\n+  }\n+\n+  /**\n+   * Shutdowns a member while the clear operation is in progress.\n+   * The writer is only installed on the member the test wants to shutdown, doesn't matter whether\n+   * it's the clear coordinator or another member holding primary buckets.\n+   *\n+   * TODO: Review once GEODE-7678 / GEODE-7912 are merged (CacheWriter lifecycle might change).\n+   */\n+  public static class MemberKiller extends CacheWriterAdapter<String, String> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk1NzY4Mg=="}, "originalCommit": {"oid": "65275b6a5fa3bdf344b5dbf3042705ee5b19e2a6"}, "originalPosition": 513}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4Nzc5MDM5OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQyMzowNToxNlrOGqlihw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQyMzowNToxNlrOGqlihw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMwODQyMw==", "bodyText": "This validation needs to be changed....The RVV's are maintained as local-rvv (local to the node/member) and array of remote-rvvs (all other members). The RVVs has to be taken for corresponding member from both dumps and compared.", "url": "https://github.com/apache/geode/pull/4848#discussion_r447308423", "createdAt": "2020-06-29T23:05:16Z", "author": {"login": "agingade"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,680 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheWriter;\n+import org.apache.geode.cache.CacheWriterException;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.PartitionedRegionPartialClearException;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionEvent;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.partition.PartitionRegionHelper;\n+import org.apache.geode.cache.util.CacheWriterAdapter;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.DMStats;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} operation can be executed multiple times\n+ * on the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME =\n+      \"[{index}] {method}(Coordinator:{0}, RegionType:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION,\n+        RegionShortcut.PARTITION_REDUNDANT\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static TestVM[] vms() {\n+    return new TestVM[] {\n+        TestVM.SERVER1, TestVM.ACCESSOR\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] vmAndRegionTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    RegionShortcut[] regionShortcuts = regionTypes();\n+\n+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {\n+      parameters.add(new Object[] {TestVM.SERVER1, regionShortcut});\n+      parameters.add(new Object[] {TestVM.ACCESSOR, regionShortcut});\n+    });\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    server1 = getVM(TestVM.SERVER1.vmNumber);\n+    server2 = getVM(TestVM.SERVER2.vmNumber);\n+    accessor = getVM(TestVM.ACCESSOR.vmNumber);\n+  }\n+\n+  private void initAccessor(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .setLocalMaxMemory(0)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+\n+  }\n+\n+  private void initDataStore(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void parametrizedSetup(RegionShortcut regionShortcut) {\n+    server1.invoke(() -> initDataStore(regionShortcut));\n+    server2.invoke(() -> initDataStore(regionShortcut));\n+    accessor.invoke(() -> initAccessor(regionShortcut));\n+  }\n+\n+  private void waitForSilence() {\n+    DMStats dmStats = cacheRule.getSystem().getDistributionManager().getStats();\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+    PartitionedRegionStats partitionedRegionStats = region.getPrStats();\n+\n+    await().untilAsserted(() -> {\n+      assertThat(dmStats.getReplyWaitsInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getVolunteeringInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getPrimaryTransfersInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getRebalanceBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getRebalancePrimaryTransfersInProgress()).isEqualTo(0);\n+    });\n+  }\n+\n+  /**\n+   * Populates the region and verifies the data on the selected VMs.\n+   */\n+  private void populateRegion(VM feeder, int entryCount, List<VM> vms) {\n+    feeder.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      IntStream.range(0, entryCount).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    });\n+\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      IntStream.range(0, entryCount)\n+          .forEach(i -> assertThat(region.get(String.valueOf(i))).isEqualTo(\"Value_\" + i));\n+    }));\n+  }\n+\n+  /**\n+   * Asserts that the region is empty on requested VMs.\n+   */\n+  private void assertRegionIsEmpty(List<VM> vms) {\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      assertThat(region.getLocalSize()).isEqualTo(0);\n+    }));\n+  }\n+\n+  /**\n+   * Asserts that the region data is consistent across buckets.\n+   */\n+  private void assertRegionBucketsConsistency() throws ForceReattemptException {\n+    List<BucketDump> bucketDumps;\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+    // Redundant copies + 1 primary.\n+    int expectedCopies = region.getRedundantCopies() + 1;\n+\n+    for (int bucketId = 0; bucketId < BUCKETS; bucketId++) {\n+      bucketDumps = region.getAllBucketEntries(bucketId);\n+      assertThat(bucketDumps.size())\n+          .as(\"Bucket \" + bucketId + \" should have \" + expectedCopies + \" copies, but has \"\n+              + bucketDumps.size())\n+          .isEqualTo(expectedCopies);\n+\n+      // Check that all copies of the bucket have the same data.\n+      if (bucketDumps.size() > 1) {\n+        BucketDump firstDump = bucketDumps.get(0);\n+\n+        for (int j = 1; j < bucketDumps.size(); j++) {\n+          BucketDump otherDump = bucketDumps.get(j);\n+\n+          assertThat(otherDump.getRvv())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfc40f4eff22ae338c429549040bde08f43dceba"}, "originalPosition": 226}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMTM3MTg0OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjoyMjowOVrOGw8iwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMDoyNToyNlrOGx38qA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk3Njc2OQ==", "bodyText": "The PartialClearException could happen here but not 100% will happen. Your assertion could fail here.", "url": "https://github.com/apache/geode/pull/4848#discussion_r453976769", "createdAt": "2020-07-13T22:22:09Z", "author": {"login": "gesterzhou"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,715 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheWriter;\n+import org.apache.geode.cache.CacheWriterException;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.PartitionedRegionPartialClearException;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionEvent;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.partition.PartitionRegionHelper;\n+import org.apache.geode.cache.util.CacheWriterAdapter;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.DMStats;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.internal.cache.versions.RegionVersionHolder;\n+import org.apache.geode.internal.cache.versions.RegionVersionVector;\n+import org.apache.geode.internal.cache.versions.VersionSource;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} operation can be executed multiple times\n+ * on the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME =\n+      \"[{index}] {method}(Coordinator:{0}, RegionType:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION, RegionShortcut.PARTITION_REDUNDANT\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static TestVM[] coordinators() {\n+    return new TestVM[] {\n+        TestVM.SERVER1, TestVM.ACCESSOR\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] coordinatorsAndRegionTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    RegionShortcut[] regionShortcuts = regionTypes();\n+\n+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {\n+      parameters.add(new Object[] {TestVM.SERVER1, regionShortcut});\n+      parameters.add(new Object[] {TestVM.ACCESSOR, regionShortcut});\n+    });\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    server1 = getVM(TestVM.SERVER1.vmNumber);\n+    server2 = getVM(TestVM.SERVER2.vmNumber);\n+    accessor = getVM(TestVM.ACCESSOR.vmNumber);\n+  }\n+\n+  private void initAccessor(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .setLocalMaxMemory(0)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+\n+  }\n+\n+  private void initDataStore(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void parametrizedSetup(RegionShortcut regionShortcut) {\n+    server1.invoke(() -> initDataStore(regionShortcut));\n+    server2.invoke(() -> initDataStore(regionShortcut));\n+    accessor.invoke(() -> initAccessor(regionShortcut));\n+  }\n+\n+  private void waitForSilence() {\n+    DMStats dmStats = cacheRule.getSystem().getDistributionManager().getStats();\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+    PartitionedRegionStats partitionedRegionStats = region.getPrStats();\n+\n+    await().untilAsserted(() -> {\n+      assertThat(dmStats.getReplyWaitsInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getVolunteeringInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getPrimaryTransfersInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getRebalanceBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getRebalancePrimaryTransfersInProgress()).isEqualTo(0);\n+    });\n+  }\n+\n+  /**\n+   * Populates the region and verifies the data on the selected VMs.\n+   */\n+  private void populateRegion(VM feeder, int entryCount, List<VM> vms) {\n+    feeder.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      IntStream.range(0, entryCount).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    });\n+\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      IntStream.range(0, entryCount)\n+          .forEach(i -> assertThat(region.get(String.valueOf(i))).isEqualTo(\"Value_\" + i));\n+    }));\n+  }\n+\n+  /**\n+   * Asserts that the RegionVersionVectors for both buckets are consistent.\n+   *\n+   * @param bucketId Id of the bucket to compare.\n+   * @param bucketDump1 First bucketDump.\n+   * @param bucketDump2 Second bucketDump.\n+   */\n+  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+  private void assertRegionVersionVectorsConsistency(int bucketId, BucketDump bucketDump1,\n+      BucketDump bucketDump2) {\n+    RegionVersionVector rvv1 = bucketDump1.getRvv();\n+    RegionVersionVector rvv2 = bucketDump2.getRvv();\n+\n+    if (rvv1 == null) {\n+      assertThat(rvv2)\n+          .as(\"Bucket \" + bucketId + \" has an RVV on member \" + bucketDump2.getMember()\n+              + \", but does not on member \" + bucketDump1.getMember())\n+          .isNull();\n+    }\n+\n+    if (rvv2 == null) {\n+      assertThat(rvv1)\n+          .as(\"Bucket \" + bucketId + \" has an RVV on member \" + bucketDump1.getMember()\n+              + \", but does not on member \" + bucketDump2.getMember())\n+          .isNull();\n+    }\n+\n+    assertThat(rvv1).isNotNull();\n+    assertThat(rvv2).isNotNull();\n+    Map<VersionSource, RegionVersionHolder> rvv2Members =\n+        new HashMap<VersionSource, RegionVersionHolder>(rvv1.getMemberToVersion());\n+    Map<VersionSource, RegionVersionHolder> rvv1Members =\n+        new HashMap<VersionSource, RegionVersionHolder>(rvv1.getMemberToVersion());\n+    for (Map.Entry<VersionSource, RegionVersionHolder> entry : rvv1Members.entrySet()) {\n+      VersionSource memberId = entry.getKey();\n+      RegionVersionHolder versionHolder1 = entry.getValue();\n+      RegionVersionHolder versionHolder2 = rvv2Members.remove(memberId);\n+      assertThat(versionHolder1)\n+          .as(\"RegionVersionVector for bucket \" + bucketId + \" on member \" + bucketDump1.getMember()\n+              + \" is not consistent with member \" + bucketDump2.getMember())\n+          .isEqualTo(versionHolder2);\n+    }\n+  }\n+\n+  /**\n+   * Asserts that the region data is consistent across buckets.\n+   */\n+  private void assertRegionBucketsConsistency() throws ForceReattemptException {\n+    List<BucketDump> bucketDumps;\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+    // Redundant copies + 1 primary.\n+    int expectedCopies = region.getRedundantCopies() + 1;\n+\n+    for (int bId = 0; bId < BUCKETS; bId++) {\n+      final int bucketId = bId;\n+      bucketDumps = region.getAllBucketEntries(bucketId);\n+      assertThat(bucketDumps.size())\n+          .as(\"Bucket \" + bucketId + \" should have \" + expectedCopies + \" copies, but has \"\n+              + bucketDumps.size())\n+          .isEqualTo(expectedCopies);\n+\n+      // Check that all copies of the bucket have the same data.\n+      if (bucketDumps.size() > 1) {\n+        BucketDump firstDump = bucketDumps.get(0);\n+\n+        for (int j = 1; j < bucketDumps.size(); j++) {\n+          BucketDump otherDump = bucketDumps.get(j);\n+          assertRegionVersionVectorsConsistency(bucketId, firstDump, otherDump);\n+\n+          await().untilAsserted(() -> assertThat(otherDump.getValues())\n+              .as(\"Values for bucket \" + bucketId + \" on member \" + otherDump.getMember()\n+                  + \" are not consistent with member \" + firstDump.getMember())\n+              .isEqualTo(firstDump.getValues()));\n+\n+          await().untilAsserted(() -> assertThat(otherDump.getVersions())\n+              .as(\"Versions for bucket \" + bucketId + \" on member \" + otherDump.getMember()\n+                  + \" are not consistent with member \" + firstDump.getMember())\n+              .isEqualTo(firstDump.getVersions()));\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute get operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeGets(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      // Region might have been cleared in between, that's why we check for null.\n+      IntStream.range(0, numEntries).forEach(i -> {\n+        Optional<String> nullableValue = Optional.ofNullable(region.get(String.valueOf(i)));\n+        nullableValue.ifPresent(value -> assertThat(value).isEqualTo(\"Value_\" + i));\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute put operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executePuts(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      IntStream.range(0, numEntries).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute putAll operations on the PartitionedRegion for the given\n+   * durationInSeconds.\n+   */\n+  private void executePutAlls(final int start, final int finish, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Map<String, String> valuesToInsert = new HashMap<>();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    IntStream.range(start, finish)\n+        .forEach(i -> valuesToInsert.put(String.valueOf(i), \"Value_\" + i));\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      region.putAll(valuesToInsert);\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute remove operations on the PartitionedRegion for the given\n+   * durationInSeconds.\n+   */\n+  private void executeRemoves(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      // Region might have been cleared in between, that's why we check for null.\n+      IntStream.range(0, numEntries).forEach(i -> {\n+        Optional<String> nullableValue = Optional.ofNullable(region.remove(String.valueOf(i)));\n+        nullableValue.ifPresent(value -> assertThat(value).isEqualTo(\"Value_\" + i));\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute removeAll operations on the PartitionedRegion for the given\n+   * durationInSeconds.\n+   */\n+  private void executeRemoveAlls(final int start, final int finish, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    List<String> keysToRemove = new ArrayList<>();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    IntStream.range(start, finish).forEach(i -> keysToRemove.add(String.valueOf(i)));\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      region.removeAll(keysToRemove);\n+    }\n+  }\n+\n+  /**\n+   * Execute the clear operation and retry until success.\n+   */\n+  private void executeClearWithRetry(VM coordinator) {\n+    coordinator.invoke(() -> {\n+      boolean retry;\n+\n+      do {\n+        retry = false;\n+\n+        try {\n+          cacheRule.getCache().getRegion(REGION_NAME).clear();\n+        } catch (PartitionedRegionPartialClearException pce) {\n+          retry = true;\n+        }\n+      } while (retry);\n+    });\n+  }\n+\n+  /**\n+   * Continuously execute clear operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeClears(final long durationInSeconds, final long waitTimeInMilliseconds)\n+      throws InterruptedException {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      region.clear();\n+      Thread.sleep(waitTimeInMilliseconds);\n+    }\n+  }\n+\n+  /**\n+   * Register the MemberKiller CacheWriter on the given vms and cancel auto-reconnects.\n+   */\n+  private void registerVMKillerAsCacheWriter(List<VM> vmsToBounce) {\n+    vmsToBounce.forEach(vm -> vm.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      region.getAttributesMutator().setCacheWriter(new MemberKiller());\n+    }));\n+  }\n+\n+  /**\n+   * The test does the following (clear coordinator and regionType are parametrized):\n+   * - Populates the Partition Region.\n+   * - Verifies that the entries are synchronized on all members.\n+   * - Launches one thread per VM to continuously execute gets, puts and removes for a given time.\n+   * - Clears the Partition Region continuously every X milliseconds for a given time.\n+   * - Asserts that, after the clears have finished, the Region Buckets are consistent across\n+   * members.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"coordinatorsAndRegionTypes\")\n+  public void clearWithConcurrentPutGetRemoveShouldWorkCorrectly(TestVM coordinatorVM,\n+      RegionShortcut regionShortcut) throws InterruptedException {\n+    final int entries = 15000;\n+    final int workSeconds = 60;\n+    parametrizedSetup(regionShortcut);\n+\n+    // Let all VMs continuously execute puts and gets for 60 seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executePuts(entries, workSeconds)),\n+        server2.invokeAsync(() -> executeGets(entries, workSeconds)),\n+        accessor.invokeAsync(() -> executeRemoves(entries, workSeconds)));\n+\n+    // Clear the region every second for 60 seconds.\n+    getVM(coordinatorVM.vmNumber).invoke(() -> executeClears(workSeconds, 1000));\n+\n+    // Let asyncInvocations finish.\n+    for (AsyncInvocation<Void> asyncInvocation : asyncInvocationList) {\n+      asyncInvocation.await();\n+    }\n+\n+    // Assert Region Buckets are consistent.\n+    asList(accessor, server1, server2).forEach(vm -> vm.invoke(this::waitForSilence));\n+    accessor.invoke(this::assertRegionBucketsConsistency);\n+  }\n+\n+  /**\n+   * The test does the following (clear coordinator and regionType are parametrized):\n+   * - Launches two threads per VM to continuously execute putAll and removeAll for a given time.\n+   * - Clears the Partition Region continuously every X milliseconds for a given time.\n+   * - Asserts that, after the clears have finished, the Region Buckets are consistent across\n+   * members.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"coordinatorsAndRegionTypes\")\n+  public void clearWithConcurrentPutAllRemoveAllShouldWorkCorrectly(TestVM coordinatorVM,\n+      RegionShortcut regionShortcut) throws InterruptedException {\n+    final int workSeconds = 15;\n+    parametrizedSetup(regionShortcut);\n+\n+    // Let all VMs continuously execute putAll for 15 seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executePutAlls(0, 2000, workSeconds)),\n+        server1.invokeAsync(() -> executeRemoveAlls(0, 2000, workSeconds)),\n+        server2.invokeAsync(() -> executePutAlls(2000, 4000, workSeconds)),\n+        server2.invokeAsync(() -> executeRemoveAlls(2000, 4000, workSeconds)),\n+        accessor.invokeAsync(() -> executePutAlls(4000, 6000, workSeconds)),\n+        accessor.invokeAsync(() -> executeRemoveAlls(4000, 6000, workSeconds)));\n+\n+    // Clear the region every half second for 15 seconds.\n+    getVM(coordinatorVM.vmNumber).invoke(() -> executeClears(workSeconds, 500));\n+\n+    // Let asyncInvocations finish.\n+    for (AsyncInvocation<Void> asyncInvocation : asyncInvocationList) {\n+      asyncInvocation.await();\n+    }\n+\n+    // Assert Region Buckets are consistent.\n+    asList(accessor, server1, server2).forEach(vm -> vm.invoke(this::waitForSilence));\n+    accessor.invoke(this::assertRegionBucketsConsistency);\n+  }\n+\n+  /**\n+   * The test does the following (regionType is parametrized):\n+   * - Populates the Partition Region.\n+   * - Verifies that the entries are synchronized on all members.\n+   * - Sets the {@link MemberKiller} as a {@link CacheWriter} to stop the coordinator VM while the\n+   * clear is in progress.\n+   * - Clears the Partition Region (at this point the coordinator is restarted).\n+   * - Asserts that, after the member joins again, the Region Buckets are consistent.\n+   */\n+  @Test\n+  @TestCaseName(\"[{index}] {method}(RegionType:{0})\")\n+  @Parameters(method = \"regionTypes\")\n+  public void clearShouldFailWhenCoordinatorMemberIsBounced(RegionShortcut regionShortcut) {\n+    final int entries = 1000;\n+    parametrizedSetup(regionShortcut);\n+    populateRegion(accessor, entries, asList(accessor, server1, server2));\n+    registerVMKillerAsCacheWriter(Collections.singletonList(server1));\n+\n+    // Clear the region.\n+    server1.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      assertThatThrownBy(region::clear)\n+          .isInstanceOf(DistributedSystemDisconnectedException.class)\n+          .hasCauseInstanceOf(ForcedDisconnectException.class);\n+    });\n+\n+    // Wait for member to get back online and assign all buckets.\n+    server1.invoke(() -> {\n+      cacheRule.createCache();\n+      initDataStore(regionShortcut);\n+      await().untilAsserted(\n+          () -> assertThat(InternalDistributedSystem.getConnectedInstance()).isNotNull());\n+      PartitionRegionHelper.assignBucketsToPartitions(cacheRule.getCache().getRegion(REGION_NAME));\n+    });\n+\n+    // Assert Region Buckets are consistent.\n+    asList(accessor, server1, server2).forEach(vm -> vm.invoke(this::waitForSilence));\n+    accessor.invoke(this::assertRegionBucketsConsistency);\n+  }\n+\n+  /**\n+   * The test does the following (clear coordinator is chosen through parameters):\n+   * - Populates the Partition Region.\n+   * - Verifies that the entries are synchronized on all members.\n+   * - Sets the {@link MemberKiller} as a {@link CacheWriter} to stop a non-coordinator VM while the\n+   * clear is in progress (the member has primary buckets, though, so participates on\n+   * the clear operation).\n+   * - Launches two threads per VM to continuously execute gets, puts and removes for a given time.\n+   * - Clears the Partition Region (at this point the non-coordinator is restarted).\n+   * - Asserts that, after the clear has finished, the Region Buckets are consistent across members.\n+   */\n+  @Test\n+  @Parameters(method = \"coordinators\")\n+  @TestCaseName(\"[{index}] {method}(Coordinator:{0})\")\n+  public void clearOnRedundantPartitionRegionWithConcurrentPutGetRemoveShouldWorkCorrectlyWhenNonCoordinatorMembersAreBounced(\n+      TestVM coordinatorVM) throws InterruptedException {\n+    final int entries = 7500;\n+    final int workSeconds = 60;\n+    parametrizedSetup(RegionShortcut.PARTITION_REDUNDANT);\n+    registerVMKillerAsCacheWriter(Collections.singletonList(server2));\n+    populateRegion(accessor, entries, asList(accessor, server1, server2));\n+\n+    // Let all VMs (except the one to kill) continuously execute gets, put and removes for 60\n+    // seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executeGets(entries, workSeconds)),\n+        server1.invokeAsync(() -> executePuts(entries, workSeconds)),\n+        accessor.invokeAsync(() -> executeGets(entries, workSeconds)),\n+        accessor.invokeAsync(() -> executeRemoves(entries, workSeconds)));\n+\n+    // Retry the clear operation on the region until success (server2 will go down, but other\n+    // members will become primary for those buckets previously hosted by server2).\n+    executeClearWithRetry(getVM(coordinatorVM.vmNumber));\n+\n+    // Wait for member to get back online.\n+    server2.invoke(() -> {\n+      cacheRule.createCache();\n+      initDataStore(RegionShortcut.PARTITION_REDUNDANT);\n+      await().untilAsserted(\n+          () -> assertThat(InternalDistributedSystem.getConnectedInstance()).isNotNull());\n+    });\n+\n+    // Let asyncInvocations finish.\n+    for (AsyncInvocation<Void> asyncInvocation : asyncInvocationList) {\n+      asyncInvocation.await();\n+    }\n+\n+    // Assert Region Buckets are consistent.\n+    asList(accessor, server1, server2).forEach(vm -> vm.invoke(this::waitForSilence));\n+    accessor.invoke(this::assertRegionBucketsConsistency);\n+  }\n+\n+  /**\n+   * The test does the following (clear coordinator is chosen through parameters):\n+   * - Populates the Partition Region.\n+   * - Verifies that the entries are synchronized on all members.\n+   * - Sets the {@link MemberKiller} as a {@link CacheWriter} to stop a non-coordinator VM while the\n+   * clear is in progress (the member has primary buckets, though, so participates on\n+   * the clear operation).\n+   * - Launches two threads per VM to continuously execute gets, puts and removes for a given time.\n+   * - Clears the Partition Region (at this point the non-coordinator is restarted).\n+   * - Asserts that the clear operation failed with PartitionedRegionPartialClearException (primary\n+   * buckets on the the restarted members are not available).\n+   */\n+  @Test\n+  @Parameters(method = \"coordinators\")\n+  @TestCaseName(\"[{index}] {method}(Coordinator:{0})\")\n+  public void clearOnNonRedundantPartitionRegionWithConcurrentPutGetRemoveShouldFailWhenNonCoordinatorMembersAreBounced(\n+      TestVM coordinatorVM) throws InterruptedException {\n+    final int entries = 7500;\n+    final int workSeconds = 45;\n+    parametrizedSetup(RegionShortcut.PARTITION);\n+    registerVMKillerAsCacheWriter(Collections.singletonList(server2));\n+    populateRegion(accessor, entries, asList(accessor, server1, server2));\n+\n+    // Let all VMs (except the one to kill) continuously execute gets, put and removes for 45\n+    // seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executeGets(entries, workSeconds)),\n+        server1.invokeAsync(() -> executePuts(entries, workSeconds)),\n+        accessor.invokeAsync(() -> executeGets(entries, workSeconds)),\n+        accessor.invokeAsync(() -> executeRemoves(entries, workSeconds)));\n+\n+    // Clear the region.\n+    getVM(coordinatorVM.vmNumber).invoke(() -> {\n+      assertThatThrownBy(() -> cacheRule.getCache().getRegion(REGION_NAME).clear())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a24ace73cfaa3fc20ddfb9dcee4b67a22d9cd440"}, "originalPosition": 600}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIxOTE4OA==", "bodyText": "@gesterzhou\nThere are three members in this test: ACCESSOR, SERVER1 and SERVER2, both servers host primary buckets locally for the region. The clear operation is executed either from the ACCESSOR or SERVER1, and SERVER2 is always killed through the MemberKiller class (CacheWriter.beforeRegionClear()) before the clear is locally executed.\nAccording to what I understand, the PartitionedRegionPartialClearException should always be thrown as SERVER2 doesn't get started (after the initial shutdown) until the clear \"finishes\", meaning that the clear coordinator will never be able to get the lock for all the primary buckets (the region is configured as PARTITION, not as PARTITION_REDUNDANT, so there are no secondary buckets that can become primary while SERVER2 is down).\nAm I missing something here?, shouldn't the exception be thrown no matter what, given the above conditions?.\n\nAs a side note, the test clearOnNonRedundantPartitionRegionWithConcurrentPutGetRemoveShouldFailWhenNonCoordinatorMembersAreBounced failed 4 times out of 100 executions, the actual failure depends on whether the clear is executed on the ACCESSOR or SERVER1 vm.\nThe two failures seen when the clear is executed on the the ACCESSOR node are basically assertion errors, caused by the fact the the PartitionedRegionPartialClearException is not thrown (discussed above).\nThe two failures seen when the clear is executed on SERVER1, on the other hand, are caused by the fact that the exception message is different from the one expected by the test (I'll change this and update the PR).", "url": "https://github.com/apache/geode/pull/4848#discussion_r454219188", "createdAt": "2020-07-14T09:16:39Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,715 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheWriter;\n+import org.apache.geode.cache.CacheWriterException;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.PartitionedRegionPartialClearException;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionEvent;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.partition.PartitionRegionHelper;\n+import org.apache.geode.cache.util.CacheWriterAdapter;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.DMStats;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.internal.cache.versions.RegionVersionHolder;\n+import org.apache.geode.internal.cache.versions.RegionVersionVector;\n+import org.apache.geode.internal.cache.versions.VersionSource;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} operation can be executed multiple times\n+ * on the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME =\n+      \"[{index}] {method}(Coordinator:{0}, RegionType:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION, RegionShortcut.PARTITION_REDUNDANT\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static TestVM[] coordinators() {\n+    return new TestVM[] {\n+        TestVM.SERVER1, TestVM.ACCESSOR\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] coordinatorsAndRegionTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    RegionShortcut[] regionShortcuts = regionTypes();\n+\n+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {\n+      parameters.add(new Object[] {TestVM.SERVER1, regionShortcut});\n+      parameters.add(new Object[] {TestVM.ACCESSOR, regionShortcut});\n+    });\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    server1 = getVM(TestVM.SERVER1.vmNumber);\n+    server2 = getVM(TestVM.SERVER2.vmNumber);\n+    accessor = getVM(TestVM.ACCESSOR.vmNumber);\n+  }\n+\n+  private void initAccessor(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .setLocalMaxMemory(0)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+\n+  }\n+\n+  private void initDataStore(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void parametrizedSetup(RegionShortcut regionShortcut) {\n+    server1.invoke(() -> initDataStore(regionShortcut));\n+    server2.invoke(() -> initDataStore(regionShortcut));\n+    accessor.invoke(() -> initAccessor(regionShortcut));\n+  }\n+\n+  private void waitForSilence() {\n+    DMStats dmStats = cacheRule.getSystem().getDistributionManager().getStats();\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+    PartitionedRegionStats partitionedRegionStats = region.getPrStats();\n+\n+    await().untilAsserted(() -> {\n+      assertThat(dmStats.getReplyWaitsInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getVolunteeringInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getPrimaryTransfersInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getRebalanceBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getRebalancePrimaryTransfersInProgress()).isEqualTo(0);\n+    });\n+  }\n+\n+  /**\n+   * Populates the region and verifies the data on the selected VMs.\n+   */\n+  private void populateRegion(VM feeder, int entryCount, List<VM> vms) {\n+    feeder.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      IntStream.range(0, entryCount).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    });\n+\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      IntStream.range(0, entryCount)\n+          .forEach(i -> assertThat(region.get(String.valueOf(i))).isEqualTo(\"Value_\" + i));\n+    }));\n+  }\n+\n+  /**\n+   * Asserts that the RegionVersionVectors for both buckets are consistent.\n+   *\n+   * @param bucketId Id of the bucket to compare.\n+   * @param bucketDump1 First bucketDump.\n+   * @param bucketDump2 Second bucketDump.\n+   */\n+  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+  private void assertRegionVersionVectorsConsistency(int bucketId, BucketDump bucketDump1,\n+      BucketDump bucketDump2) {\n+    RegionVersionVector rvv1 = bucketDump1.getRvv();\n+    RegionVersionVector rvv2 = bucketDump2.getRvv();\n+\n+    if (rvv1 == null) {\n+      assertThat(rvv2)\n+          .as(\"Bucket \" + bucketId + \" has an RVV on member \" + bucketDump2.getMember()\n+              + \", but does not on member \" + bucketDump1.getMember())\n+          .isNull();\n+    }\n+\n+    if (rvv2 == null) {\n+      assertThat(rvv1)\n+          .as(\"Bucket \" + bucketId + \" has an RVV on member \" + bucketDump1.getMember()\n+              + \", but does not on member \" + bucketDump2.getMember())\n+          .isNull();\n+    }\n+\n+    assertThat(rvv1).isNotNull();\n+    assertThat(rvv2).isNotNull();\n+    Map<VersionSource, RegionVersionHolder> rvv2Members =\n+        new HashMap<VersionSource, RegionVersionHolder>(rvv1.getMemberToVersion());\n+    Map<VersionSource, RegionVersionHolder> rvv1Members =\n+        new HashMap<VersionSource, RegionVersionHolder>(rvv1.getMemberToVersion());\n+    for (Map.Entry<VersionSource, RegionVersionHolder> entry : rvv1Members.entrySet()) {\n+      VersionSource memberId = entry.getKey();\n+      RegionVersionHolder versionHolder1 = entry.getValue();\n+      RegionVersionHolder versionHolder2 = rvv2Members.remove(memberId);\n+      assertThat(versionHolder1)\n+          .as(\"RegionVersionVector for bucket \" + bucketId + \" on member \" + bucketDump1.getMember()\n+              + \" is not consistent with member \" + bucketDump2.getMember())\n+          .isEqualTo(versionHolder2);\n+    }\n+  }\n+\n+  /**\n+   * Asserts that the region data is consistent across buckets.\n+   */\n+  private void assertRegionBucketsConsistency() throws ForceReattemptException {\n+    List<BucketDump> bucketDumps;\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+    // Redundant copies + 1 primary.\n+    int expectedCopies = region.getRedundantCopies() + 1;\n+\n+    for (int bId = 0; bId < BUCKETS; bId++) {\n+      final int bucketId = bId;\n+      bucketDumps = region.getAllBucketEntries(bucketId);\n+      assertThat(bucketDumps.size())\n+          .as(\"Bucket \" + bucketId + \" should have \" + expectedCopies + \" copies, but has \"\n+              + bucketDumps.size())\n+          .isEqualTo(expectedCopies);\n+\n+      // Check that all copies of the bucket have the same data.\n+      if (bucketDumps.size() > 1) {\n+        BucketDump firstDump = bucketDumps.get(0);\n+\n+        for (int j = 1; j < bucketDumps.size(); j++) {\n+          BucketDump otherDump = bucketDumps.get(j);\n+          assertRegionVersionVectorsConsistency(bucketId, firstDump, otherDump);\n+\n+          await().untilAsserted(() -> assertThat(otherDump.getValues())\n+              .as(\"Values for bucket \" + bucketId + \" on member \" + otherDump.getMember()\n+                  + \" are not consistent with member \" + firstDump.getMember())\n+              .isEqualTo(firstDump.getValues()));\n+\n+          await().untilAsserted(() -> assertThat(otherDump.getVersions())\n+              .as(\"Versions for bucket \" + bucketId + \" on member \" + otherDump.getMember()\n+                  + \" are not consistent with member \" + firstDump.getMember())\n+              .isEqualTo(firstDump.getVersions()));\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute get operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeGets(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      // Region might have been cleared in between, that's why we check for null.\n+      IntStream.range(0, numEntries).forEach(i -> {\n+        Optional<String> nullableValue = Optional.ofNullable(region.get(String.valueOf(i)));\n+        nullableValue.ifPresent(value -> assertThat(value).isEqualTo(\"Value_\" + i));\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute put operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executePuts(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      IntStream.range(0, numEntries).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute putAll operations on the PartitionedRegion for the given\n+   * durationInSeconds.\n+   */\n+  private void executePutAlls(final int start, final int finish, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Map<String, String> valuesToInsert = new HashMap<>();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    IntStream.range(start, finish)\n+        .forEach(i -> valuesToInsert.put(String.valueOf(i), \"Value_\" + i));\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      region.putAll(valuesToInsert);\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute remove operations on the PartitionedRegion for the given\n+   * durationInSeconds.\n+   */\n+  private void executeRemoves(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      // Region might have been cleared in between, that's why we check for null.\n+      IntStream.range(0, numEntries).forEach(i -> {\n+        Optional<String> nullableValue = Optional.ofNullable(region.remove(String.valueOf(i)));\n+        nullableValue.ifPresent(value -> assertThat(value).isEqualTo(\"Value_\" + i));\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute removeAll operations on the PartitionedRegion for the given\n+   * durationInSeconds.\n+   */\n+  private void executeRemoveAlls(final int start, final int finish, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    List<String> keysToRemove = new ArrayList<>();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    IntStream.range(start, finish).forEach(i -> keysToRemove.add(String.valueOf(i)));\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      region.removeAll(keysToRemove);\n+    }\n+  }\n+\n+  /**\n+   * Execute the clear operation and retry until success.\n+   */\n+  private void executeClearWithRetry(VM coordinator) {\n+    coordinator.invoke(() -> {\n+      boolean retry;\n+\n+      do {\n+        retry = false;\n+\n+        try {\n+          cacheRule.getCache().getRegion(REGION_NAME).clear();\n+        } catch (PartitionedRegionPartialClearException pce) {\n+          retry = true;\n+        }\n+      } while (retry);\n+    });\n+  }\n+\n+  /**\n+   * Continuously execute clear operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeClears(final long durationInSeconds, final long waitTimeInMilliseconds)\n+      throws InterruptedException {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      region.clear();\n+      Thread.sleep(waitTimeInMilliseconds);\n+    }\n+  }\n+\n+  /**\n+   * Register the MemberKiller CacheWriter on the given vms and cancel auto-reconnects.\n+   */\n+  private void registerVMKillerAsCacheWriter(List<VM> vmsToBounce) {\n+    vmsToBounce.forEach(vm -> vm.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      region.getAttributesMutator().setCacheWriter(new MemberKiller());\n+    }));\n+  }\n+\n+  /**\n+   * The test does the following (clear coordinator and regionType are parametrized):\n+   * - Populates the Partition Region.\n+   * - Verifies that the entries are synchronized on all members.\n+   * - Launches one thread per VM to continuously execute gets, puts and removes for a given time.\n+   * - Clears the Partition Region continuously every X milliseconds for a given time.\n+   * - Asserts that, after the clears have finished, the Region Buckets are consistent across\n+   * members.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"coordinatorsAndRegionTypes\")\n+  public void clearWithConcurrentPutGetRemoveShouldWorkCorrectly(TestVM coordinatorVM,\n+      RegionShortcut regionShortcut) throws InterruptedException {\n+    final int entries = 15000;\n+    final int workSeconds = 60;\n+    parametrizedSetup(regionShortcut);\n+\n+    // Let all VMs continuously execute puts and gets for 60 seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executePuts(entries, workSeconds)),\n+        server2.invokeAsync(() -> executeGets(entries, workSeconds)),\n+        accessor.invokeAsync(() -> executeRemoves(entries, workSeconds)));\n+\n+    // Clear the region every second for 60 seconds.\n+    getVM(coordinatorVM.vmNumber).invoke(() -> executeClears(workSeconds, 1000));\n+\n+    // Let asyncInvocations finish.\n+    for (AsyncInvocation<Void> asyncInvocation : asyncInvocationList) {\n+      asyncInvocation.await();\n+    }\n+\n+    // Assert Region Buckets are consistent.\n+    asList(accessor, server1, server2).forEach(vm -> vm.invoke(this::waitForSilence));\n+    accessor.invoke(this::assertRegionBucketsConsistency);\n+  }\n+\n+  /**\n+   * The test does the following (clear coordinator and regionType are parametrized):\n+   * - Launches two threads per VM to continuously execute putAll and removeAll for a given time.\n+   * - Clears the Partition Region continuously every X milliseconds for a given time.\n+   * - Asserts that, after the clears have finished, the Region Buckets are consistent across\n+   * members.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"coordinatorsAndRegionTypes\")\n+  public void clearWithConcurrentPutAllRemoveAllShouldWorkCorrectly(TestVM coordinatorVM,\n+      RegionShortcut regionShortcut) throws InterruptedException {\n+    final int workSeconds = 15;\n+    parametrizedSetup(regionShortcut);\n+\n+    // Let all VMs continuously execute putAll for 15 seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executePutAlls(0, 2000, workSeconds)),\n+        server1.invokeAsync(() -> executeRemoveAlls(0, 2000, workSeconds)),\n+        server2.invokeAsync(() -> executePutAlls(2000, 4000, workSeconds)),\n+        server2.invokeAsync(() -> executeRemoveAlls(2000, 4000, workSeconds)),\n+        accessor.invokeAsync(() -> executePutAlls(4000, 6000, workSeconds)),\n+        accessor.invokeAsync(() -> executeRemoveAlls(4000, 6000, workSeconds)));\n+\n+    // Clear the region every half second for 15 seconds.\n+    getVM(coordinatorVM.vmNumber).invoke(() -> executeClears(workSeconds, 500));\n+\n+    // Let asyncInvocations finish.\n+    for (AsyncInvocation<Void> asyncInvocation : asyncInvocationList) {\n+      asyncInvocation.await();\n+    }\n+\n+    // Assert Region Buckets are consistent.\n+    asList(accessor, server1, server2).forEach(vm -> vm.invoke(this::waitForSilence));\n+    accessor.invoke(this::assertRegionBucketsConsistency);\n+  }\n+\n+  /**\n+   * The test does the following (regionType is parametrized):\n+   * - Populates the Partition Region.\n+   * - Verifies that the entries are synchronized on all members.\n+   * - Sets the {@link MemberKiller} as a {@link CacheWriter} to stop the coordinator VM while the\n+   * clear is in progress.\n+   * - Clears the Partition Region (at this point the coordinator is restarted).\n+   * - Asserts that, after the member joins again, the Region Buckets are consistent.\n+   */\n+  @Test\n+  @TestCaseName(\"[{index}] {method}(RegionType:{0})\")\n+  @Parameters(method = \"regionTypes\")\n+  public void clearShouldFailWhenCoordinatorMemberIsBounced(RegionShortcut regionShortcut) {\n+    final int entries = 1000;\n+    parametrizedSetup(regionShortcut);\n+    populateRegion(accessor, entries, asList(accessor, server1, server2));\n+    registerVMKillerAsCacheWriter(Collections.singletonList(server1));\n+\n+    // Clear the region.\n+    server1.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      assertThatThrownBy(region::clear)\n+          .isInstanceOf(DistributedSystemDisconnectedException.class)\n+          .hasCauseInstanceOf(ForcedDisconnectException.class);\n+    });\n+\n+    // Wait for member to get back online and assign all buckets.\n+    server1.invoke(() -> {\n+      cacheRule.createCache();\n+      initDataStore(regionShortcut);\n+      await().untilAsserted(\n+          () -> assertThat(InternalDistributedSystem.getConnectedInstance()).isNotNull());\n+      PartitionRegionHelper.assignBucketsToPartitions(cacheRule.getCache().getRegion(REGION_NAME));\n+    });\n+\n+    // Assert Region Buckets are consistent.\n+    asList(accessor, server1, server2).forEach(vm -> vm.invoke(this::waitForSilence));\n+    accessor.invoke(this::assertRegionBucketsConsistency);\n+  }\n+\n+  /**\n+   * The test does the following (clear coordinator is chosen through parameters):\n+   * - Populates the Partition Region.\n+   * - Verifies that the entries are synchronized on all members.\n+   * - Sets the {@link MemberKiller} as a {@link CacheWriter} to stop a non-coordinator VM while the\n+   * clear is in progress (the member has primary buckets, though, so participates on\n+   * the clear operation).\n+   * - Launches two threads per VM to continuously execute gets, puts and removes for a given time.\n+   * - Clears the Partition Region (at this point the non-coordinator is restarted).\n+   * - Asserts that, after the clear has finished, the Region Buckets are consistent across members.\n+   */\n+  @Test\n+  @Parameters(method = \"coordinators\")\n+  @TestCaseName(\"[{index}] {method}(Coordinator:{0})\")\n+  public void clearOnRedundantPartitionRegionWithConcurrentPutGetRemoveShouldWorkCorrectlyWhenNonCoordinatorMembersAreBounced(\n+      TestVM coordinatorVM) throws InterruptedException {\n+    final int entries = 7500;\n+    final int workSeconds = 60;\n+    parametrizedSetup(RegionShortcut.PARTITION_REDUNDANT);\n+    registerVMKillerAsCacheWriter(Collections.singletonList(server2));\n+    populateRegion(accessor, entries, asList(accessor, server1, server2));\n+\n+    // Let all VMs (except the one to kill) continuously execute gets, put and removes for 60\n+    // seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executeGets(entries, workSeconds)),\n+        server1.invokeAsync(() -> executePuts(entries, workSeconds)),\n+        accessor.invokeAsync(() -> executeGets(entries, workSeconds)),\n+        accessor.invokeAsync(() -> executeRemoves(entries, workSeconds)));\n+\n+    // Retry the clear operation on the region until success (server2 will go down, but other\n+    // members will become primary for those buckets previously hosted by server2).\n+    executeClearWithRetry(getVM(coordinatorVM.vmNumber));\n+\n+    // Wait for member to get back online.\n+    server2.invoke(() -> {\n+      cacheRule.createCache();\n+      initDataStore(RegionShortcut.PARTITION_REDUNDANT);\n+      await().untilAsserted(\n+          () -> assertThat(InternalDistributedSystem.getConnectedInstance()).isNotNull());\n+    });\n+\n+    // Let asyncInvocations finish.\n+    for (AsyncInvocation<Void> asyncInvocation : asyncInvocationList) {\n+      asyncInvocation.await();\n+    }\n+\n+    // Assert Region Buckets are consistent.\n+    asList(accessor, server1, server2).forEach(vm -> vm.invoke(this::waitForSilence));\n+    accessor.invoke(this::assertRegionBucketsConsistency);\n+  }\n+\n+  /**\n+   * The test does the following (clear coordinator is chosen through parameters):\n+   * - Populates the Partition Region.\n+   * - Verifies that the entries are synchronized on all members.\n+   * - Sets the {@link MemberKiller} as a {@link CacheWriter} to stop a non-coordinator VM while the\n+   * clear is in progress (the member has primary buckets, though, so participates on\n+   * the clear operation).\n+   * - Launches two threads per VM to continuously execute gets, puts and removes for a given time.\n+   * - Clears the Partition Region (at this point the non-coordinator is restarted).\n+   * - Asserts that the clear operation failed with PartitionedRegionPartialClearException (primary\n+   * buckets on the the restarted members are not available).\n+   */\n+  @Test\n+  @Parameters(method = \"coordinators\")\n+  @TestCaseName(\"[{index}] {method}(Coordinator:{0})\")\n+  public void clearOnNonRedundantPartitionRegionWithConcurrentPutGetRemoveShouldFailWhenNonCoordinatorMembersAreBounced(\n+      TestVM coordinatorVM) throws InterruptedException {\n+    final int entries = 7500;\n+    final int workSeconds = 45;\n+    parametrizedSetup(RegionShortcut.PARTITION);\n+    registerVMKillerAsCacheWriter(Collections.singletonList(server2));\n+    populateRegion(accessor, entries, asList(accessor, server1, server2));\n+\n+    // Let all VMs (except the one to kill) continuously execute gets, put and removes for 45\n+    // seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executeGets(entries, workSeconds)),\n+        server1.invokeAsync(() -> executePuts(entries, workSeconds)),\n+        accessor.invokeAsync(() -> executeGets(entries, workSeconds)),\n+        accessor.invokeAsync(() -> executeRemoves(entries, workSeconds)));\n+\n+    // Clear the region.\n+    getVM(coordinatorVM.vmNumber).invoke(() -> {\n+      assertThatThrownBy(() -> cacheRule.getCache().getRegion(REGION_NAME).clear())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk3Njc2OQ=="}, "originalCommit": {"oid": "a24ace73cfaa3fc20ddfb9dcee4b67a22d9cd440"}, "originalPosition": 600}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDM5NDkxMQ==", "bodyText": "@gesterzhou\nI've modified the test assertion to always expect the PartitionedRegionPartialClearException but don't check the actual message, all the related failures are gone now.\nThe question still remains, though, the PartitionedRegionPartialClearException is always thrown under the conditions set by the test (that's what I would expect), why do you think the mentioned exception shouldn't be thrown 100% of time under these conditions?.", "url": "https://github.com/apache/geode/pull/4848#discussion_r454394911", "createdAt": "2020-07-14T14:24:13Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,715 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheWriter;\n+import org.apache.geode.cache.CacheWriterException;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.PartitionedRegionPartialClearException;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionEvent;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.partition.PartitionRegionHelper;\n+import org.apache.geode.cache.util.CacheWriterAdapter;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.DMStats;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.internal.cache.versions.RegionVersionHolder;\n+import org.apache.geode.internal.cache.versions.RegionVersionVector;\n+import org.apache.geode.internal.cache.versions.VersionSource;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} operation can be executed multiple times\n+ * on the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME =\n+      \"[{index}] {method}(Coordinator:{0}, RegionType:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION, RegionShortcut.PARTITION_REDUNDANT\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static TestVM[] coordinators() {\n+    return new TestVM[] {\n+        TestVM.SERVER1, TestVM.ACCESSOR\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] coordinatorsAndRegionTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    RegionShortcut[] regionShortcuts = regionTypes();\n+\n+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {\n+      parameters.add(new Object[] {TestVM.SERVER1, regionShortcut});\n+      parameters.add(new Object[] {TestVM.ACCESSOR, regionShortcut});\n+    });\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    server1 = getVM(TestVM.SERVER1.vmNumber);\n+    server2 = getVM(TestVM.SERVER2.vmNumber);\n+    accessor = getVM(TestVM.ACCESSOR.vmNumber);\n+  }\n+\n+  private void initAccessor(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .setLocalMaxMemory(0)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+\n+  }\n+\n+  private void initDataStore(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void parametrizedSetup(RegionShortcut regionShortcut) {\n+    server1.invoke(() -> initDataStore(regionShortcut));\n+    server2.invoke(() -> initDataStore(regionShortcut));\n+    accessor.invoke(() -> initAccessor(regionShortcut));\n+  }\n+\n+  private void waitForSilence() {\n+    DMStats dmStats = cacheRule.getSystem().getDistributionManager().getStats();\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+    PartitionedRegionStats partitionedRegionStats = region.getPrStats();\n+\n+    await().untilAsserted(() -> {\n+      assertThat(dmStats.getReplyWaitsInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getVolunteeringInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getPrimaryTransfersInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getRebalanceBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getRebalancePrimaryTransfersInProgress()).isEqualTo(0);\n+    });\n+  }\n+\n+  /**\n+   * Populates the region and verifies the data on the selected VMs.\n+   */\n+  private void populateRegion(VM feeder, int entryCount, List<VM> vms) {\n+    feeder.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      IntStream.range(0, entryCount).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    });\n+\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      IntStream.range(0, entryCount)\n+          .forEach(i -> assertThat(region.get(String.valueOf(i))).isEqualTo(\"Value_\" + i));\n+    }));\n+  }\n+\n+  /**\n+   * Asserts that the RegionVersionVectors for both buckets are consistent.\n+   *\n+   * @param bucketId Id of the bucket to compare.\n+   * @param bucketDump1 First bucketDump.\n+   * @param bucketDump2 Second bucketDump.\n+   */\n+  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+  private void assertRegionVersionVectorsConsistency(int bucketId, BucketDump bucketDump1,\n+      BucketDump bucketDump2) {\n+    RegionVersionVector rvv1 = bucketDump1.getRvv();\n+    RegionVersionVector rvv2 = bucketDump2.getRvv();\n+\n+    if (rvv1 == null) {\n+      assertThat(rvv2)\n+          .as(\"Bucket \" + bucketId + \" has an RVV on member \" + bucketDump2.getMember()\n+              + \", but does not on member \" + bucketDump1.getMember())\n+          .isNull();\n+    }\n+\n+    if (rvv2 == null) {\n+      assertThat(rvv1)\n+          .as(\"Bucket \" + bucketId + \" has an RVV on member \" + bucketDump1.getMember()\n+              + \", but does not on member \" + bucketDump2.getMember())\n+          .isNull();\n+    }\n+\n+    assertThat(rvv1).isNotNull();\n+    assertThat(rvv2).isNotNull();\n+    Map<VersionSource, RegionVersionHolder> rvv2Members =\n+        new HashMap<VersionSource, RegionVersionHolder>(rvv1.getMemberToVersion());\n+    Map<VersionSource, RegionVersionHolder> rvv1Members =\n+        new HashMap<VersionSource, RegionVersionHolder>(rvv1.getMemberToVersion());\n+    for (Map.Entry<VersionSource, RegionVersionHolder> entry : rvv1Members.entrySet()) {\n+      VersionSource memberId = entry.getKey();\n+      RegionVersionHolder versionHolder1 = entry.getValue();\n+      RegionVersionHolder versionHolder2 = rvv2Members.remove(memberId);\n+      assertThat(versionHolder1)\n+          .as(\"RegionVersionVector for bucket \" + bucketId + \" on member \" + bucketDump1.getMember()\n+              + \" is not consistent with member \" + bucketDump2.getMember())\n+          .isEqualTo(versionHolder2);\n+    }\n+  }\n+\n+  /**\n+   * Asserts that the region data is consistent across buckets.\n+   */\n+  private void assertRegionBucketsConsistency() throws ForceReattemptException {\n+    List<BucketDump> bucketDumps;\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+    // Redundant copies + 1 primary.\n+    int expectedCopies = region.getRedundantCopies() + 1;\n+\n+    for (int bId = 0; bId < BUCKETS; bId++) {\n+      final int bucketId = bId;\n+      bucketDumps = region.getAllBucketEntries(bucketId);\n+      assertThat(bucketDumps.size())\n+          .as(\"Bucket \" + bucketId + \" should have \" + expectedCopies + \" copies, but has \"\n+              + bucketDumps.size())\n+          .isEqualTo(expectedCopies);\n+\n+      // Check that all copies of the bucket have the same data.\n+      if (bucketDumps.size() > 1) {\n+        BucketDump firstDump = bucketDumps.get(0);\n+\n+        for (int j = 1; j < bucketDumps.size(); j++) {\n+          BucketDump otherDump = bucketDumps.get(j);\n+          assertRegionVersionVectorsConsistency(bucketId, firstDump, otherDump);\n+\n+          await().untilAsserted(() -> assertThat(otherDump.getValues())\n+              .as(\"Values for bucket \" + bucketId + \" on member \" + otherDump.getMember()\n+                  + \" are not consistent with member \" + firstDump.getMember())\n+              .isEqualTo(firstDump.getValues()));\n+\n+          await().untilAsserted(() -> assertThat(otherDump.getVersions())\n+              .as(\"Versions for bucket \" + bucketId + \" on member \" + otherDump.getMember()\n+                  + \" are not consistent with member \" + firstDump.getMember())\n+              .isEqualTo(firstDump.getVersions()));\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute get operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeGets(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      // Region might have been cleared in between, that's why we check for null.\n+      IntStream.range(0, numEntries).forEach(i -> {\n+        Optional<String> nullableValue = Optional.ofNullable(region.get(String.valueOf(i)));\n+        nullableValue.ifPresent(value -> assertThat(value).isEqualTo(\"Value_\" + i));\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute put operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executePuts(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      IntStream.range(0, numEntries).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute putAll operations on the PartitionedRegion for the given\n+   * durationInSeconds.\n+   */\n+  private void executePutAlls(final int start, final int finish, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Map<String, String> valuesToInsert = new HashMap<>();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    IntStream.range(start, finish)\n+        .forEach(i -> valuesToInsert.put(String.valueOf(i), \"Value_\" + i));\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      region.putAll(valuesToInsert);\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute remove operations on the PartitionedRegion for the given\n+   * durationInSeconds.\n+   */\n+  private void executeRemoves(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      // Region might have been cleared in between, that's why we check for null.\n+      IntStream.range(0, numEntries).forEach(i -> {\n+        Optional<String> nullableValue = Optional.ofNullable(region.remove(String.valueOf(i)));\n+        nullableValue.ifPresent(value -> assertThat(value).isEqualTo(\"Value_\" + i));\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute removeAll operations on the PartitionedRegion for the given\n+   * durationInSeconds.\n+   */\n+  private void executeRemoveAlls(final int start, final int finish, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    List<String> keysToRemove = new ArrayList<>();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    IntStream.range(start, finish).forEach(i -> keysToRemove.add(String.valueOf(i)));\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      region.removeAll(keysToRemove);\n+    }\n+  }\n+\n+  /**\n+   * Execute the clear operation and retry until success.\n+   */\n+  private void executeClearWithRetry(VM coordinator) {\n+    coordinator.invoke(() -> {\n+      boolean retry;\n+\n+      do {\n+        retry = false;\n+\n+        try {\n+          cacheRule.getCache().getRegion(REGION_NAME).clear();\n+        } catch (PartitionedRegionPartialClearException pce) {\n+          retry = true;\n+        }\n+      } while (retry);\n+    });\n+  }\n+\n+  /**\n+   * Continuously execute clear operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeClears(final long durationInSeconds, final long waitTimeInMilliseconds)\n+      throws InterruptedException {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      region.clear();\n+      Thread.sleep(waitTimeInMilliseconds);\n+    }\n+  }\n+\n+  /**\n+   * Register the MemberKiller CacheWriter on the given vms and cancel auto-reconnects.\n+   */\n+  private void registerVMKillerAsCacheWriter(List<VM> vmsToBounce) {\n+    vmsToBounce.forEach(vm -> vm.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      region.getAttributesMutator().setCacheWriter(new MemberKiller());\n+    }));\n+  }\n+\n+  /**\n+   * The test does the following (clear coordinator and regionType are parametrized):\n+   * - Populates the Partition Region.\n+   * - Verifies that the entries are synchronized on all members.\n+   * - Launches one thread per VM to continuously execute gets, puts and removes for a given time.\n+   * - Clears the Partition Region continuously every X milliseconds for a given time.\n+   * - Asserts that, after the clears have finished, the Region Buckets are consistent across\n+   * members.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"coordinatorsAndRegionTypes\")\n+  public void clearWithConcurrentPutGetRemoveShouldWorkCorrectly(TestVM coordinatorVM,\n+      RegionShortcut regionShortcut) throws InterruptedException {\n+    final int entries = 15000;\n+    final int workSeconds = 60;\n+    parametrizedSetup(regionShortcut);\n+\n+    // Let all VMs continuously execute puts and gets for 60 seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executePuts(entries, workSeconds)),\n+        server2.invokeAsync(() -> executeGets(entries, workSeconds)),\n+        accessor.invokeAsync(() -> executeRemoves(entries, workSeconds)));\n+\n+    // Clear the region every second for 60 seconds.\n+    getVM(coordinatorVM.vmNumber).invoke(() -> executeClears(workSeconds, 1000));\n+\n+    // Let asyncInvocations finish.\n+    for (AsyncInvocation<Void> asyncInvocation : asyncInvocationList) {\n+      asyncInvocation.await();\n+    }\n+\n+    // Assert Region Buckets are consistent.\n+    asList(accessor, server1, server2).forEach(vm -> vm.invoke(this::waitForSilence));\n+    accessor.invoke(this::assertRegionBucketsConsistency);\n+  }\n+\n+  /**\n+   * The test does the following (clear coordinator and regionType are parametrized):\n+   * - Launches two threads per VM to continuously execute putAll and removeAll for a given time.\n+   * - Clears the Partition Region continuously every X milliseconds for a given time.\n+   * - Asserts that, after the clears have finished, the Region Buckets are consistent across\n+   * members.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"coordinatorsAndRegionTypes\")\n+  public void clearWithConcurrentPutAllRemoveAllShouldWorkCorrectly(TestVM coordinatorVM,\n+      RegionShortcut regionShortcut) throws InterruptedException {\n+    final int workSeconds = 15;\n+    parametrizedSetup(regionShortcut);\n+\n+    // Let all VMs continuously execute putAll for 15 seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executePutAlls(0, 2000, workSeconds)),\n+        server1.invokeAsync(() -> executeRemoveAlls(0, 2000, workSeconds)),\n+        server2.invokeAsync(() -> executePutAlls(2000, 4000, workSeconds)),\n+        server2.invokeAsync(() -> executeRemoveAlls(2000, 4000, workSeconds)),\n+        accessor.invokeAsync(() -> executePutAlls(4000, 6000, workSeconds)),\n+        accessor.invokeAsync(() -> executeRemoveAlls(4000, 6000, workSeconds)));\n+\n+    // Clear the region every half second for 15 seconds.\n+    getVM(coordinatorVM.vmNumber).invoke(() -> executeClears(workSeconds, 500));\n+\n+    // Let asyncInvocations finish.\n+    for (AsyncInvocation<Void> asyncInvocation : asyncInvocationList) {\n+      asyncInvocation.await();\n+    }\n+\n+    // Assert Region Buckets are consistent.\n+    asList(accessor, server1, server2).forEach(vm -> vm.invoke(this::waitForSilence));\n+    accessor.invoke(this::assertRegionBucketsConsistency);\n+  }\n+\n+  /**\n+   * The test does the following (regionType is parametrized):\n+   * - Populates the Partition Region.\n+   * - Verifies that the entries are synchronized on all members.\n+   * - Sets the {@link MemberKiller} as a {@link CacheWriter} to stop the coordinator VM while the\n+   * clear is in progress.\n+   * - Clears the Partition Region (at this point the coordinator is restarted).\n+   * - Asserts that, after the member joins again, the Region Buckets are consistent.\n+   */\n+  @Test\n+  @TestCaseName(\"[{index}] {method}(RegionType:{0})\")\n+  @Parameters(method = \"regionTypes\")\n+  public void clearShouldFailWhenCoordinatorMemberIsBounced(RegionShortcut regionShortcut) {\n+    final int entries = 1000;\n+    parametrizedSetup(regionShortcut);\n+    populateRegion(accessor, entries, asList(accessor, server1, server2));\n+    registerVMKillerAsCacheWriter(Collections.singletonList(server1));\n+\n+    // Clear the region.\n+    server1.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      assertThatThrownBy(region::clear)\n+          .isInstanceOf(DistributedSystemDisconnectedException.class)\n+          .hasCauseInstanceOf(ForcedDisconnectException.class);\n+    });\n+\n+    // Wait for member to get back online and assign all buckets.\n+    server1.invoke(() -> {\n+      cacheRule.createCache();\n+      initDataStore(regionShortcut);\n+      await().untilAsserted(\n+          () -> assertThat(InternalDistributedSystem.getConnectedInstance()).isNotNull());\n+      PartitionRegionHelper.assignBucketsToPartitions(cacheRule.getCache().getRegion(REGION_NAME));\n+    });\n+\n+    // Assert Region Buckets are consistent.\n+    asList(accessor, server1, server2).forEach(vm -> vm.invoke(this::waitForSilence));\n+    accessor.invoke(this::assertRegionBucketsConsistency);\n+  }\n+\n+  /**\n+   * The test does the following (clear coordinator is chosen through parameters):\n+   * - Populates the Partition Region.\n+   * - Verifies that the entries are synchronized on all members.\n+   * - Sets the {@link MemberKiller} as a {@link CacheWriter} to stop a non-coordinator VM while the\n+   * clear is in progress (the member has primary buckets, though, so participates on\n+   * the clear operation).\n+   * - Launches two threads per VM to continuously execute gets, puts and removes for a given time.\n+   * - Clears the Partition Region (at this point the non-coordinator is restarted).\n+   * - Asserts that, after the clear has finished, the Region Buckets are consistent across members.\n+   */\n+  @Test\n+  @Parameters(method = \"coordinators\")\n+  @TestCaseName(\"[{index}] {method}(Coordinator:{0})\")\n+  public void clearOnRedundantPartitionRegionWithConcurrentPutGetRemoveShouldWorkCorrectlyWhenNonCoordinatorMembersAreBounced(\n+      TestVM coordinatorVM) throws InterruptedException {\n+    final int entries = 7500;\n+    final int workSeconds = 60;\n+    parametrizedSetup(RegionShortcut.PARTITION_REDUNDANT);\n+    registerVMKillerAsCacheWriter(Collections.singletonList(server2));\n+    populateRegion(accessor, entries, asList(accessor, server1, server2));\n+\n+    // Let all VMs (except the one to kill) continuously execute gets, put and removes for 60\n+    // seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executeGets(entries, workSeconds)),\n+        server1.invokeAsync(() -> executePuts(entries, workSeconds)),\n+        accessor.invokeAsync(() -> executeGets(entries, workSeconds)),\n+        accessor.invokeAsync(() -> executeRemoves(entries, workSeconds)));\n+\n+    // Retry the clear operation on the region until success (server2 will go down, but other\n+    // members will become primary for those buckets previously hosted by server2).\n+    executeClearWithRetry(getVM(coordinatorVM.vmNumber));\n+\n+    // Wait for member to get back online.\n+    server2.invoke(() -> {\n+      cacheRule.createCache();\n+      initDataStore(RegionShortcut.PARTITION_REDUNDANT);\n+      await().untilAsserted(\n+          () -> assertThat(InternalDistributedSystem.getConnectedInstance()).isNotNull());\n+    });\n+\n+    // Let asyncInvocations finish.\n+    for (AsyncInvocation<Void> asyncInvocation : asyncInvocationList) {\n+      asyncInvocation.await();\n+    }\n+\n+    // Assert Region Buckets are consistent.\n+    asList(accessor, server1, server2).forEach(vm -> vm.invoke(this::waitForSilence));\n+    accessor.invoke(this::assertRegionBucketsConsistency);\n+  }\n+\n+  /**\n+   * The test does the following (clear coordinator is chosen through parameters):\n+   * - Populates the Partition Region.\n+   * - Verifies that the entries are synchronized on all members.\n+   * - Sets the {@link MemberKiller} as a {@link CacheWriter} to stop a non-coordinator VM while the\n+   * clear is in progress (the member has primary buckets, though, so participates on\n+   * the clear operation).\n+   * - Launches two threads per VM to continuously execute gets, puts and removes for a given time.\n+   * - Clears the Partition Region (at this point the non-coordinator is restarted).\n+   * - Asserts that the clear operation failed with PartitionedRegionPartialClearException (primary\n+   * buckets on the the restarted members are not available).\n+   */\n+  @Test\n+  @Parameters(method = \"coordinators\")\n+  @TestCaseName(\"[{index}] {method}(Coordinator:{0})\")\n+  public void clearOnNonRedundantPartitionRegionWithConcurrentPutGetRemoveShouldFailWhenNonCoordinatorMembersAreBounced(\n+      TestVM coordinatorVM) throws InterruptedException {\n+    final int entries = 7500;\n+    final int workSeconds = 45;\n+    parametrizedSetup(RegionShortcut.PARTITION);\n+    registerVMKillerAsCacheWriter(Collections.singletonList(server2));\n+    populateRegion(accessor, entries, asList(accessor, server1, server2));\n+\n+    // Let all VMs (except the one to kill) continuously execute gets, put and removes for 45\n+    // seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executeGets(entries, workSeconds)),\n+        server1.invokeAsync(() -> executePuts(entries, workSeconds)),\n+        accessor.invokeAsync(() -> executeGets(entries, workSeconds)),\n+        accessor.invokeAsync(() -> executeRemoves(entries, workSeconds)));\n+\n+    // Clear the region.\n+    getVM(coordinatorVM.vmNumber).invoke(() -> {\n+      assertThatThrownBy(() -> cacheRule.getCache().getRegion(REGION_NAME).clear())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk3Njc2OQ=="}, "originalCommit": {"oid": "a24ace73cfaa3fc20ddfb9dcee4b67a22d9cd440"}, "originalPosition": 600}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUyODE1MA==", "bodyText": "Only when the primary holder cannot be found any where, the PartitionedRegionPartialClearException will be throw.\nIn your case, only killing server2. There're chances and races that the primary buckets are recreated quick enough on server1. So PartitionedRegionPartialClearException is not 100%.", "url": "https://github.com/apache/geode/pull/4848#discussion_r454528150", "createdAt": "2020-07-14T17:37:46Z", "author": {"login": "gesterzhou"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,715 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheWriter;\n+import org.apache.geode.cache.CacheWriterException;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.PartitionedRegionPartialClearException;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionEvent;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.partition.PartitionRegionHelper;\n+import org.apache.geode.cache.util.CacheWriterAdapter;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.DMStats;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.internal.cache.versions.RegionVersionHolder;\n+import org.apache.geode.internal.cache.versions.RegionVersionVector;\n+import org.apache.geode.internal.cache.versions.VersionSource;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} operation can be executed multiple times\n+ * on the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME =\n+      \"[{index}] {method}(Coordinator:{0}, RegionType:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION, RegionShortcut.PARTITION_REDUNDANT\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static TestVM[] coordinators() {\n+    return new TestVM[] {\n+        TestVM.SERVER1, TestVM.ACCESSOR\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] coordinatorsAndRegionTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    RegionShortcut[] regionShortcuts = regionTypes();\n+\n+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {\n+      parameters.add(new Object[] {TestVM.SERVER1, regionShortcut});\n+      parameters.add(new Object[] {TestVM.ACCESSOR, regionShortcut});\n+    });\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    server1 = getVM(TestVM.SERVER1.vmNumber);\n+    server2 = getVM(TestVM.SERVER2.vmNumber);\n+    accessor = getVM(TestVM.ACCESSOR.vmNumber);\n+  }\n+\n+  private void initAccessor(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .setLocalMaxMemory(0)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+\n+  }\n+\n+  private void initDataStore(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void parametrizedSetup(RegionShortcut regionShortcut) {\n+    server1.invoke(() -> initDataStore(regionShortcut));\n+    server2.invoke(() -> initDataStore(regionShortcut));\n+    accessor.invoke(() -> initAccessor(regionShortcut));\n+  }\n+\n+  private void waitForSilence() {\n+    DMStats dmStats = cacheRule.getSystem().getDistributionManager().getStats();\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+    PartitionedRegionStats partitionedRegionStats = region.getPrStats();\n+\n+    await().untilAsserted(() -> {\n+      assertThat(dmStats.getReplyWaitsInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getVolunteeringInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getPrimaryTransfersInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getRebalanceBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getRebalancePrimaryTransfersInProgress()).isEqualTo(0);\n+    });\n+  }\n+\n+  /**\n+   * Populates the region and verifies the data on the selected VMs.\n+   */\n+  private void populateRegion(VM feeder, int entryCount, List<VM> vms) {\n+    feeder.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      IntStream.range(0, entryCount).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    });\n+\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      IntStream.range(0, entryCount)\n+          .forEach(i -> assertThat(region.get(String.valueOf(i))).isEqualTo(\"Value_\" + i));\n+    }));\n+  }\n+\n+  /**\n+   * Asserts that the RegionVersionVectors for both buckets are consistent.\n+   *\n+   * @param bucketId Id of the bucket to compare.\n+   * @param bucketDump1 First bucketDump.\n+   * @param bucketDump2 Second bucketDump.\n+   */\n+  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+  private void assertRegionVersionVectorsConsistency(int bucketId, BucketDump bucketDump1,\n+      BucketDump bucketDump2) {\n+    RegionVersionVector rvv1 = bucketDump1.getRvv();\n+    RegionVersionVector rvv2 = bucketDump2.getRvv();\n+\n+    if (rvv1 == null) {\n+      assertThat(rvv2)\n+          .as(\"Bucket \" + bucketId + \" has an RVV on member \" + bucketDump2.getMember()\n+              + \", but does not on member \" + bucketDump1.getMember())\n+          .isNull();\n+    }\n+\n+    if (rvv2 == null) {\n+      assertThat(rvv1)\n+          .as(\"Bucket \" + bucketId + \" has an RVV on member \" + bucketDump1.getMember()\n+              + \", but does not on member \" + bucketDump2.getMember())\n+          .isNull();\n+    }\n+\n+    assertThat(rvv1).isNotNull();\n+    assertThat(rvv2).isNotNull();\n+    Map<VersionSource, RegionVersionHolder> rvv2Members =\n+        new HashMap<VersionSource, RegionVersionHolder>(rvv1.getMemberToVersion());\n+    Map<VersionSource, RegionVersionHolder> rvv1Members =\n+        new HashMap<VersionSource, RegionVersionHolder>(rvv1.getMemberToVersion());\n+    for (Map.Entry<VersionSource, RegionVersionHolder> entry : rvv1Members.entrySet()) {\n+      VersionSource memberId = entry.getKey();\n+      RegionVersionHolder versionHolder1 = entry.getValue();\n+      RegionVersionHolder versionHolder2 = rvv2Members.remove(memberId);\n+      assertThat(versionHolder1)\n+          .as(\"RegionVersionVector for bucket \" + bucketId + \" on member \" + bucketDump1.getMember()\n+              + \" is not consistent with member \" + bucketDump2.getMember())\n+          .isEqualTo(versionHolder2);\n+    }\n+  }\n+\n+  /**\n+   * Asserts that the region data is consistent across buckets.\n+   */\n+  private void assertRegionBucketsConsistency() throws ForceReattemptException {\n+    List<BucketDump> bucketDumps;\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+    // Redundant copies + 1 primary.\n+    int expectedCopies = region.getRedundantCopies() + 1;\n+\n+    for (int bId = 0; bId < BUCKETS; bId++) {\n+      final int bucketId = bId;\n+      bucketDumps = region.getAllBucketEntries(bucketId);\n+      assertThat(bucketDumps.size())\n+          .as(\"Bucket \" + bucketId + \" should have \" + expectedCopies + \" copies, but has \"\n+              + bucketDumps.size())\n+          .isEqualTo(expectedCopies);\n+\n+      // Check that all copies of the bucket have the same data.\n+      if (bucketDumps.size() > 1) {\n+        BucketDump firstDump = bucketDumps.get(0);\n+\n+        for (int j = 1; j < bucketDumps.size(); j++) {\n+          BucketDump otherDump = bucketDumps.get(j);\n+          assertRegionVersionVectorsConsistency(bucketId, firstDump, otherDump);\n+\n+          await().untilAsserted(() -> assertThat(otherDump.getValues())\n+              .as(\"Values for bucket \" + bucketId + \" on member \" + otherDump.getMember()\n+                  + \" are not consistent with member \" + firstDump.getMember())\n+              .isEqualTo(firstDump.getValues()));\n+\n+          await().untilAsserted(() -> assertThat(otherDump.getVersions())\n+              .as(\"Versions for bucket \" + bucketId + \" on member \" + otherDump.getMember()\n+                  + \" are not consistent with member \" + firstDump.getMember())\n+              .isEqualTo(firstDump.getVersions()));\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute get operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeGets(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      // Region might have been cleared in between, that's why we check for null.\n+      IntStream.range(0, numEntries).forEach(i -> {\n+        Optional<String> nullableValue = Optional.ofNullable(region.get(String.valueOf(i)));\n+        nullableValue.ifPresent(value -> assertThat(value).isEqualTo(\"Value_\" + i));\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute put operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executePuts(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      IntStream.range(0, numEntries).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute putAll operations on the PartitionedRegion for the given\n+   * durationInSeconds.\n+   */\n+  private void executePutAlls(final int start, final int finish, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Map<String, String> valuesToInsert = new HashMap<>();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    IntStream.range(start, finish)\n+        .forEach(i -> valuesToInsert.put(String.valueOf(i), \"Value_\" + i));\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      region.putAll(valuesToInsert);\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute remove operations on the PartitionedRegion for the given\n+   * durationInSeconds.\n+   */\n+  private void executeRemoves(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      // Region might have been cleared in between, that's why we check for null.\n+      IntStream.range(0, numEntries).forEach(i -> {\n+        Optional<String> nullableValue = Optional.ofNullable(region.remove(String.valueOf(i)));\n+        nullableValue.ifPresent(value -> assertThat(value).isEqualTo(\"Value_\" + i));\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute removeAll operations on the PartitionedRegion for the given\n+   * durationInSeconds.\n+   */\n+  private void executeRemoveAlls(final int start, final int finish, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    List<String> keysToRemove = new ArrayList<>();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    IntStream.range(start, finish).forEach(i -> keysToRemove.add(String.valueOf(i)));\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      region.removeAll(keysToRemove);\n+    }\n+  }\n+\n+  /**\n+   * Execute the clear operation and retry until success.\n+   */\n+  private void executeClearWithRetry(VM coordinator) {\n+    coordinator.invoke(() -> {\n+      boolean retry;\n+\n+      do {\n+        retry = false;\n+\n+        try {\n+          cacheRule.getCache().getRegion(REGION_NAME).clear();\n+        } catch (PartitionedRegionPartialClearException pce) {\n+          retry = true;\n+        }\n+      } while (retry);\n+    });\n+  }\n+\n+  /**\n+   * Continuously execute clear operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeClears(final long durationInSeconds, final long waitTimeInMilliseconds)\n+      throws InterruptedException {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      region.clear();\n+      Thread.sleep(waitTimeInMilliseconds);\n+    }\n+  }\n+\n+  /**\n+   * Register the MemberKiller CacheWriter on the given vms and cancel auto-reconnects.\n+   */\n+  private void registerVMKillerAsCacheWriter(List<VM> vmsToBounce) {\n+    vmsToBounce.forEach(vm -> vm.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      region.getAttributesMutator().setCacheWriter(new MemberKiller());\n+    }));\n+  }\n+\n+  /**\n+   * The test does the following (clear coordinator and regionType are parametrized):\n+   * - Populates the Partition Region.\n+   * - Verifies that the entries are synchronized on all members.\n+   * - Launches one thread per VM to continuously execute gets, puts and removes for a given time.\n+   * - Clears the Partition Region continuously every X milliseconds for a given time.\n+   * - Asserts that, after the clears have finished, the Region Buckets are consistent across\n+   * members.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"coordinatorsAndRegionTypes\")\n+  public void clearWithConcurrentPutGetRemoveShouldWorkCorrectly(TestVM coordinatorVM,\n+      RegionShortcut regionShortcut) throws InterruptedException {\n+    final int entries = 15000;\n+    final int workSeconds = 60;\n+    parametrizedSetup(regionShortcut);\n+\n+    // Let all VMs continuously execute puts and gets for 60 seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executePuts(entries, workSeconds)),\n+        server2.invokeAsync(() -> executeGets(entries, workSeconds)),\n+        accessor.invokeAsync(() -> executeRemoves(entries, workSeconds)));\n+\n+    // Clear the region every second for 60 seconds.\n+    getVM(coordinatorVM.vmNumber).invoke(() -> executeClears(workSeconds, 1000));\n+\n+    // Let asyncInvocations finish.\n+    for (AsyncInvocation<Void> asyncInvocation : asyncInvocationList) {\n+      asyncInvocation.await();\n+    }\n+\n+    // Assert Region Buckets are consistent.\n+    asList(accessor, server1, server2).forEach(vm -> vm.invoke(this::waitForSilence));\n+    accessor.invoke(this::assertRegionBucketsConsistency);\n+  }\n+\n+  /**\n+   * The test does the following (clear coordinator and regionType are parametrized):\n+   * - Launches two threads per VM to continuously execute putAll and removeAll for a given time.\n+   * - Clears the Partition Region continuously every X milliseconds for a given time.\n+   * - Asserts that, after the clears have finished, the Region Buckets are consistent across\n+   * members.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"coordinatorsAndRegionTypes\")\n+  public void clearWithConcurrentPutAllRemoveAllShouldWorkCorrectly(TestVM coordinatorVM,\n+      RegionShortcut regionShortcut) throws InterruptedException {\n+    final int workSeconds = 15;\n+    parametrizedSetup(regionShortcut);\n+\n+    // Let all VMs continuously execute putAll for 15 seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executePutAlls(0, 2000, workSeconds)),\n+        server1.invokeAsync(() -> executeRemoveAlls(0, 2000, workSeconds)),\n+        server2.invokeAsync(() -> executePutAlls(2000, 4000, workSeconds)),\n+        server2.invokeAsync(() -> executeRemoveAlls(2000, 4000, workSeconds)),\n+        accessor.invokeAsync(() -> executePutAlls(4000, 6000, workSeconds)),\n+        accessor.invokeAsync(() -> executeRemoveAlls(4000, 6000, workSeconds)));\n+\n+    // Clear the region every half second for 15 seconds.\n+    getVM(coordinatorVM.vmNumber).invoke(() -> executeClears(workSeconds, 500));\n+\n+    // Let asyncInvocations finish.\n+    for (AsyncInvocation<Void> asyncInvocation : asyncInvocationList) {\n+      asyncInvocation.await();\n+    }\n+\n+    // Assert Region Buckets are consistent.\n+    asList(accessor, server1, server2).forEach(vm -> vm.invoke(this::waitForSilence));\n+    accessor.invoke(this::assertRegionBucketsConsistency);\n+  }\n+\n+  /**\n+   * The test does the following (regionType is parametrized):\n+   * - Populates the Partition Region.\n+   * - Verifies that the entries are synchronized on all members.\n+   * - Sets the {@link MemberKiller} as a {@link CacheWriter} to stop the coordinator VM while the\n+   * clear is in progress.\n+   * - Clears the Partition Region (at this point the coordinator is restarted).\n+   * - Asserts that, after the member joins again, the Region Buckets are consistent.\n+   */\n+  @Test\n+  @TestCaseName(\"[{index}] {method}(RegionType:{0})\")\n+  @Parameters(method = \"regionTypes\")\n+  public void clearShouldFailWhenCoordinatorMemberIsBounced(RegionShortcut regionShortcut) {\n+    final int entries = 1000;\n+    parametrizedSetup(regionShortcut);\n+    populateRegion(accessor, entries, asList(accessor, server1, server2));\n+    registerVMKillerAsCacheWriter(Collections.singletonList(server1));\n+\n+    // Clear the region.\n+    server1.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      assertThatThrownBy(region::clear)\n+          .isInstanceOf(DistributedSystemDisconnectedException.class)\n+          .hasCauseInstanceOf(ForcedDisconnectException.class);\n+    });\n+\n+    // Wait for member to get back online and assign all buckets.\n+    server1.invoke(() -> {\n+      cacheRule.createCache();\n+      initDataStore(regionShortcut);\n+      await().untilAsserted(\n+          () -> assertThat(InternalDistributedSystem.getConnectedInstance()).isNotNull());\n+      PartitionRegionHelper.assignBucketsToPartitions(cacheRule.getCache().getRegion(REGION_NAME));\n+    });\n+\n+    // Assert Region Buckets are consistent.\n+    asList(accessor, server1, server2).forEach(vm -> vm.invoke(this::waitForSilence));\n+    accessor.invoke(this::assertRegionBucketsConsistency);\n+  }\n+\n+  /**\n+   * The test does the following (clear coordinator is chosen through parameters):\n+   * - Populates the Partition Region.\n+   * - Verifies that the entries are synchronized on all members.\n+   * - Sets the {@link MemberKiller} as a {@link CacheWriter} to stop a non-coordinator VM while the\n+   * clear is in progress (the member has primary buckets, though, so participates on\n+   * the clear operation).\n+   * - Launches two threads per VM to continuously execute gets, puts and removes for a given time.\n+   * - Clears the Partition Region (at this point the non-coordinator is restarted).\n+   * - Asserts that, after the clear has finished, the Region Buckets are consistent across members.\n+   */\n+  @Test\n+  @Parameters(method = \"coordinators\")\n+  @TestCaseName(\"[{index}] {method}(Coordinator:{0})\")\n+  public void clearOnRedundantPartitionRegionWithConcurrentPutGetRemoveShouldWorkCorrectlyWhenNonCoordinatorMembersAreBounced(\n+      TestVM coordinatorVM) throws InterruptedException {\n+    final int entries = 7500;\n+    final int workSeconds = 60;\n+    parametrizedSetup(RegionShortcut.PARTITION_REDUNDANT);\n+    registerVMKillerAsCacheWriter(Collections.singletonList(server2));\n+    populateRegion(accessor, entries, asList(accessor, server1, server2));\n+\n+    // Let all VMs (except the one to kill) continuously execute gets, put and removes for 60\n+    // seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executeGets(entries, workSeconds)),\n+        server1.invokeAsync(() -> executePuts(entries, workSeconds)),\n+        accessor.invokeAsync(() -> executeGets(entries, workSeconds)),\n+        accessor.invokeAsync(() -> executeRemoves(entries, workSeconds)));\n+\n+    // Retry the clear operation on the region until success (server2 will go down, but other\n+    // members will become primary for those buckets previously hosted by server2).\n+    executeClearWithRetry(getVM(coordinatorVM.vmNumber));\n+\n+    // Wait for member to get back online.\n+    server2.invoke(() -> {\n+      cacheRule.createCache();\n+      initDataStore(RegionShortcut.PARTITION_REDUNDANT);\n+      await().untilAsserted(\n+          () -> assertThat(InternalDistributedSystem.getConnectedInstance()).isNotNull());\n+    });\n+\n+    // Let asyncInvocations finish.\n+    for (AsyncInvocation<Void> asyncInvocation : asyncInvocationList) {\n+      asyncInvocation.await();\n+    }\n+\n+    // Assert Region Buckets are consistent.\n+    asList(accessor, server1, server2).forEach(vm -> vm.invoke(this::waitForSilence));\n+    accessor.invoke(this::assertRegionBucketsConsistency);\n+  }\n+\n+  /**\n+   * The test does the following (clear coordinator is chosen through parameters):\n+   * - Populates the Partition Region.\n+   * - Verifies that the entries are synchronized on all members.\n+   * - Sets the {@link MemberKiller} as a {@link CacheWriter} to stop a non-coordinator VM while the\n+   * clear is in progress (the member has primary buckets, though, so participates on\n+   * the clear operation).\n+   * - Launches two threads per VM to continuously execute gets, puts and removes for a given time.\n+   * - Clears the Partition Region (at this point the non-coordinator is restarted).\n+   * - Asserts that the clear operation failed with PartitionedRegionPartialClearException (primary\n+   * buckets on the the restarted members are not available).\n+   */\n+  @Test\n+  @Parameters(method = \"coordinators\")\n+  @TestCaseName(\"[{index}] {method}(Coordinator:{0})\")\n+  public void clearOnNonRedundantPartitionRegionWithConcurrentPutGetRemoveShouldFailWhenNonCoordinatorMembersAreBounced(\n+      TestVM coordinatorVM) throws InterruptedException {\n+    final int entries = 7500;\n+    final int workSeconds = 45;\n+    parametrizedSetup(RegionShortcut.PARTITION);\n+    registerVMKillerAsCacheWriter(Collections.singletonList(server2));\n+    populateRegion(accessor, entries, asList(accessor, server1, server2));\n+\n+    // Let all VMs (except the one to kill) continuously execute gets, put and removes for 45\n+    // seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executeGets(entries, workSeconds)),\n+        server1.invokeAsync(() -> executePuts(entries, workSeconds)),\n+        accessor.invokeAsync(() -> executeGets(entries, workSeconds)),\n+        accessor.invokeAsync(() -> executeRemoves(entries, workSeconds)));\n+\n+    // Clear the region.\n+    getVM(coordinatorVM.vmNumber).invoke(() -> {\n+      assertThatThrownBy(() -> cacheRule.getCache().getRegion(REGION_NAME).clear())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk3Njc2OQ=="}, "originalCommit": {"oid": "a24ace73cfaa3fc20ddfb9dcee4b67a22d9cd440"}, "originalPosition": 600}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk1MDA1Ng==", "bodyText": "Maybe I'm missing something here, but there's no activity on the cluster at the time server2 is killed, so the primaries previously hosted by that server shouldn't be recreated anywhere (and there are no secondaries to promote as the region is just PARTITION, not REDUNDANT_PARTITION). Moreover, and since server2 is abruptly shutdown, no other members can re-create the primaries as they don't have any of the data that was hosted by server2 at the time it was brought down.", "url": "https://github.com/apache/geode/pull/4848#discussion_r454950056", "createdAt": "2020-07-15T10:25:26Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,715 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheWriter;\n+import org.apache.geode.cache.CacheWriterException;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.PartitionedRegionPartialClearException;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionEvent;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.partition.PartitionRegionHelper;\n+import org.apache.geode.cache.util.CacheWriterAdapter;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.DMStats;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.internal.cache.versions.RegionVersionHolder;\n+import org.apache.geode.internal.cache.versions.RegionVersionVector;\n+import org.apache.geode.internal.cache.versions.VersionSource;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} operation can be executed multiple times\n+ * on the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME =\n+      \"[{index}] {method}(Coordinator:{0}, RegionType:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION, RegionShortcut.PARTITION_REDUNDANT\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static TestVM[] coordinators() {\n+    return new TestVM[] {\n+        TestVM.SERVER1, TestVM.ACCESSOR\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] coordinatorsAndRegionTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    RegionShortcut[] regionShortcuts = regionTypes();\n+\n+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {\n+      parameters.add(new Object[] {TestVM.SERVER1, regionShortcut});\n+      parameters.add(new Object[] {TestVM.ACCESSOR, regionShortcut});\n+    });\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    server1 = getVM(TestVM.SERVER1.vmNumber);\n+    server2 = getVM(TestVM.SERVER2.vmNumber);\n+    accessor = getVM(TestVM.ACCESSOR.vmNumber);\n+  }\n+\n+  private void initAccessor(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .setLocalMaxMemory(0)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+\n+  }\n+\n+  private void initDataStore(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void parametrizedSetup(RegionShortcut regionShortcut) {\n+    server1.invoke(() -> initDataStore(regionShortcut));\n+    server2.invoke(() -> initDataStore(regionShortcut));\n+    accessor.invoke(() -> initAccessor(regionShortcut));\n+  }\n+\n+  private void waitForSilence() {\n+    DMStats dmStats = cacheRule.getSystem().getDistributionManager().getStats();\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+    PartitionedRegionStats partitionedRegionStats = region.getPrStats();\n+\n+    await().untilAsserted(() -> {\n+      assertThat(dmStats.getReplyWaitsInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getVolunteeringInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getPrimaryTransfersInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getRebalanceBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getRebalancePrimaryTransfersInProgress()).isEqualTo(0);\n+    });\n+  }\n+\n+  /**\n+   * Populates the region and verifies the data on the selected VMs.\n+   */\n+  private void populateRegion(VM feeder, int entryCount, List<VM> vms) {\n+    feeder.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      IntStream.range(0, entryCount).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    });\n+\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      IntStream.range(0, entryCount)\n+          .forEach(i -> assertThat(region.get(String.valueOf(i))).isEqualTo(\"Value_\" + i));\n+    }));\n+  }\n+\n+  /**\n+   * Asserts that the RegionVersionVectors for both buckets are consistent.\n+   *\n+   * @param bucketId Id of the bucket to compare.\n+   * @param bucketDump1 First bucketDump.\n+   * @param bucketDump2 Second bucketDump.\n+   */\n+  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+  private void assertRegionVersionVectorsConsistency(int bucketId, BucketDump bucketDump1,\n+      BucketDump bucketDump2) {\n+    RegionVersionVector rvv1 = bucketDump1.getRvv();\n+    RegionVersionVector rvv2 = bucketDump2.getRvv();\n+\n+    if (rvv1 == null) {\n+      assertThat(rvv2)\n+          .as(\"Bucket \" + bucketId + \" has an RVV on member \" + bucketDump2.getMember()\n+              + \", but does not on member \" + bucketDump1.getMember())\n+          .isNull();\n+    }\n+\n+    if (rvv2 == null) {\n+      assertThat(rvv1)\n+          .as(\"Bucket \" + bucketId + \" has an RVV on member \" + bucketDump1.getMember()\n+              + \", but does not on member \" + bucketDump2.getMember())\n+          .isNull();\n+    }\n+\n+    assertThat(rvv1).isNotNull();\n+    assertThat(rvv2).isNotNull();\n+    Map<VersionSource, RegionVersionHolder> rvv2Members =\n+        new HashMap<VersionSource, RegionVersionHolder>(rvv1.getMemberToVersion());\n+    Map<VersionSource, RegionVersionHolder> rvv1Members =\n+        new HashMap<VersionSource, RegionVersionHolder>(rvv1.getMemberToVersion());\n+    for (Map.Entry<VersionSource, RegionVersionHolder> entry : rvv1Members.entrySet()) {\n+      VersionSource memberId = entry.getKey();\n+      RegionVersionHolder versionHolder1 = entry.getValue();\n+      RegionVersionHolder versionHolder2 = rvv2Members.remove(memberId);\n+      assertThat(versionHolder1)\n+          .as(\"RegionVersionVector for bucket \" + bucketId + \" on member \" + bucketDump1.getMember()\n+              + \" is not consistent with member \" + bucketDump2.getMember())\n+          .isEqualTo(versionHolder2);\n+    }\n+  }\n+\n+  /**\n+   * Asserts that the region data is consistent across buckets.\n+   */\n+  private void assertRegionBucketsConsistency() throws ForceReattemptException {\n+    List<BucketDump> bucketDumps;\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+    // Redundant copies + 1 primary.\n+    int expectedCopies = region.getRedundantCopies() + 1;\n+\n+    for (int bId = 0; bId < BUCKETS; bId++) {\n+      final int bucketId = bId;\n+      bucketDumps = region.getAllBucketEntries(bucketId);\n+      assertThat(bucketDumps.size())\n+          .as(\"Bucket \" + bucketId + \" should have \" + expectedCopies + \" copies, but has \"\n+              + bucketDumps.size())\n+          .isEqualTo(expectedCopies);\n+\n+      // Check that all copies of the bucket have the same data.\n+      if (bucketDumps.size() > 1) {\n+        BucketDump firstDump = bucketDumps.get(0);\n+\n+        for (int j = 1; j < bucketDumps.size(); j++) {\n+          BucketDump otherDump = bucketDumps.get(j);\n+          assertRegionVersionVectorsConsistency(bucketId, firstDump, otherDump);\n+\n+          await().untilAsserted(() -> assertThat(otherDump.getValues())\n+              .as(\"Values for bucket \" + bucketId + \" on member \" + otherDump.getMember()\n+                  + \" are not consistent with member \" + firstDump.getMember())\n+              .isEqualTo(firstDump.getValues()));\n+\n+          await().untilAsserted(() -> assertThat(otherDump.getVersions())\n+              .as(\"Versions for bucket \" + bucketId + \" on member \" + otherDump.getMember()\n+                  + \" are not consistent with member \" + firstDump.getMember())\n+              .isEqualTo(firstDump.getVersions()));\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute get operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeGets(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      // Region might have been cleared in between, that's why we check for null.\n+      IntStream.range(0, numEntries).forEach(i -> {\n+        Optional<String> nullableValue = Optional.ofNullable(region.get(String.valueOf(i)));\n+        nullableValue.ifPresent(value -> assertThat(value).isEqualTo(\"Value_\" + i));\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute put operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executePuts(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      IntStream.range(0, numEntries).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute putAll operations on the PartitionedRegion for the given\n+   * durationInSeconds.\n+   */\n+  private void executePutAlls(final int start, final int finish, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Map<String, String> valuesToInsert = new HashMap<>();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    IntStream.range(start, finish)\n+        .forEach(i -> valuesToInsert.put(String.valueOf(i), \"Value_\" + i));\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      region.putAll(valuesToInsert);\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute remove operations on the PartitionedRegion for the given\n+   * durationInSeconds.\n+   */\n+  private void executeRemoves(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      // Region might have been cleared in between, that's why we check for null.\n+      IntStream.range(0, numEntries).forEach(i -> {\n+        Optional<String> nullableValue = Optional.ofNullable(region.remove(String.valueOf(i)));\n+        nullableValue.ifPresent(value -> assertThat(value).isEqualTo(\"Value_\" + i));\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute removeAll operations on the PartitionedRegion for the given\n+   * durationInSeconds.\n+   */\n+  private void executeRemoveAlls(final int start, final int finish, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    List<String> keysToRemove = new ArrayList<>();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    IntStream.range(start, finish).forEach(i -> keysToRemove.add(String.valueOf(i)));\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      region.removeAll(keysToRemove);\n+    }\n+  }\n+\n+  /**\n+   * Execute the clear operation and retry until success.\n+   */\n+  private void executeClearWithRetry(VM coordinator) {\n+    coordinator.invoke(() -> {\n+      boolean retry;\n+\n+      do {\n+        retry = false;\n+\n+        try {\n+          cacheRule.getCache().getRegion(REGION_NAME).clear();\n+        } catch (PartitionedRegionPartialClearException pce) {\n+          retry = true;\n+        }\n+      } while (retry);\n+    });\n+  }\n+\n+  /**\n+   * Continuously execute clear operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeClears(final long durationInSeconds, final long waitTimeInMilliseconds)\n+      throws InterruptedException {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      region.clear();\n+      Thread.sleep(waitTimeInMilliseconds);\n+    }\n+  }\n+\n+  /**\n+   * Register the MemberKiller CacheWriter on the given vms and cancel auto-reconnects.\n+   */\n+  private void registerVMKillerAsCacheWriter(List<VM> vmsToBounce) {\n+    vmsToBounce.forEach(vm -> vm.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      region.getAttributesMutator().setCacheWriter(new MemberKiller());\n+    }));\n+  }\n+\n+  /**\n+   * The test does the following (clear coordinator and regionType are parametrized):\n+   * - Populates the Partition Region.\n+   * - Verifies that the entries are synchronized on all members.\n+   * - Launches one thread per VM to continuously execute gets, puts and removes for a given time.\n+   * - Clears the Partition Region continuously every X milliseconds for a given time.\n+   * - Asserts that, after the clears have finished, the Region Buckets are consistent across\n+   * members.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"coordinatorsAndRegionTypes\")\n+  public void clearWithConcurrentPutGetRemoveShouldWorkCorrectly(TestVM coordinatorVM,\n+      RegionShortcut regionShortcut) throws InterruptedException {\n+    final int entries = 15000;\n+    final int workSeconds = 60;\n+    parametrizedSetup(regionShortcut);\n+\n+    // Let all VMs continuously execute puts and gets for 60 seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executePuts(entries, workSeconds)),\n+        server2.invokeAsync(() -> executeGets(entries, workSeconds)),\n+        accessor.invokeAsync(() -> executeRemoves(entries, workSeconds)));\n+\n+    // Clear the region every second for 60 seconds.\n+    getVM(coordinatorVM.vmNumber).invoke(() -> executeClears(workSeconds, 1000));\n+\n+    // Let asyncInvocations finish.\n+    for (AsyncInvocation<Void> asyncInvocation : asyncInvocationList) {\n+      asyncInvocation.await();\n+    }\n+\n+    // Assert Region Buckets are consistent.\n+    asList(accessor, server1, server2).forEach(vm -> vm.invoke(this::waitForSilence));\n+    accessor.invoke(this::assertRegionBucketsConsistency);\n+  }\n+\n+  /**\n+   * The test does the following (clear coordinator and regionType are parametrized):\n+   * - Launches two threads per VM to continuously execute putAll and removeAll for a given time.\n+   * - Clears the Partition Region continuously every X milliseconds for a given time.\n+   * - Asserts that, after the clears have finished, the Region Buckets are consistent across\n+   * members.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"coordinatorsAndRegionTypes\")\n+  public void clearWithConcurrentPutAllRemoveAllShouldWorkCorrectly(TestVM coordinatorVM,\n+      RegionShortcut regionShortcut) throws InterruptedException {\n+    final int workSeconds = 15;\n+    parametrizedSetup(regionShortcut);\n+\n+    // Let all VMs continuously execute putAll for 15 seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executePutAlls(0, 2000, workSeconds)),\n+        server1.invokeAsync(() -> executeRemoveAlls(0, 2000, workSeconds)),\n+        server2.invokeAsync(() -> executePutAlls(2000, 4000, workSeconds)),\n+        server2.invokeAsync(() -> executeRemoveAlls(2000, 4000, workSeconds)),\n+        accessor.invokeAsync(() -> executePutAlls(4000, 6000, workSeconds)),\n+        accessor.invokeAsync(() -> executeRemoveAlls(4000, 6000, workSeconds)));\n+\n+    // Clear the region every half second for 15 seconds.\n+    getVM(coordinatorVM.vmNumber).invoke(() -> executeClears(workSeconds, 500));\n+\n+    // Let asyncInvocations finish.\n+    for (AsyncInvocation<Void> asyncInvocation : asyncInvocationList) {\n+      asyncInvocation.await();\n+    }\n+\n+    // Assert Region Buckets are consistent.\n+    asList(accessor, server1, server2).forEach(vm -> vm.invoke(this::waitForSilence));\n+    accessor.invoke(this::assertRegionBucketsConsistency);\n+  }\n+\n+  /**\n+   * The test does the following (regionType is parametrized):\n+   * - Populates the Partition Region.\n+   * - Verifies that the entries are synchronized on all members.\n+   * - Sets the {@link MemberKiller} as a {@link CacheWriter} to stop the coordinator VM while the\n+   * clear is in progress.\n+   * - Clears the Partition Region (at this point the coordinator is restarted).\n+   * - Asserts that, after the member joins again, the Region Buckets are consistent.\n+   */\n+  @Test\n+  @TestCaseName(\"[{index}] {method}(RegionType:{0})\")\n+  @Parameters(method = \"regionTypes\")\n+  public void clearShouldFailWhenCoordinatorMemberIsBounced(RegionShortcut regionShortcut) {\n+    final int entries = 1000;\n+    parametrizedSetup(regionShortcut);\n+    populateRegion(accessor, entries, asList(accessor, server1, server2));\n+    registerVMKillerAsCacheWriter(Collections.singletonList(server1));\n+\n+    // Clear the region.\n+    server1.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      assertThatThrownBy(region::clear)\n+          .isInstanceOf(DistributedSystemDisconnectedException.class)\n+          .hasCauseInstanceOf(ForcedDisconnectException.class);\n+    });\n+\n+    // Wait for member to get back online and assign all buckets.\n+    server1.invoke(() -> {\n+      cacheRule.createCache();\n+      initDataStore(regionShortcut);\n+      await().untilAsserted(\n+          () -> assertThat(InternalDistributedSystem.getConnectedInstance()).isNotNull());\n+      PartitionRegionHelper.assignBucketsToPartitions(cacheRule.getCache().getRegion(REGION_NAME));\n+    });\n+\n+    // Assert Region Buckets are consistent.\n+    asList(accessor, server1, server2).forEach(vm -> vm.invoke(this::waitForSilence));\n+    accessor.invoke(this::assertRegionBucketsConsistency);\n+  }\n+\n+  /**\n+   * The test does the following (clear coordinator is chosen through parameters):\n+   * - Populates the Partition Region.\n+   * - Verifies that the entries are synchronized on all members.\n+   * - Sets the {@link MemberKiller} as a {@link CacheWriter} to stop a non-coordinator VM while the\n+   * clear is in progress (the member has primary buckets, though, so participates on\n+   * the clear operation).\n+   * - Launches two threads per VM to continuously execute gets, puts and removes for a given time.\n+   * - Clears the Partition Region (at this point the non-coordinator is restarted).\n+   * - Asserts that, after the clear has finished, the Region Buckets are consistent across members.\n+   */\n+  @Test\n+  @Parameters(method = \"coordinators\")\n+  @TestCaseName(\"[{index}] {method}(Coordinator:{0})\")\n+  public void clearOnRedundantPartitionRegionWithConcurrentPutGetRemoveShouldWorkCorrectlyWhenNonCoordinatorMembersAreBounced(\n+      TestVM coordinatorVM) throws InterruptedException {\n+    final int entries = 7500;\n+    final int workSeconds = 60;\n+    parametrizedSetup(RegionShortcut.PARTITION_REDUNDANT);\n+    registerVMKillerAsCacheWriter(Collections.singletonList(server2));\n+    populateRegion(accessor, entries, asList(accessor, server1, server2));\n+\n+    // Let all VMs (except the one to kill) continuously execute gets, put and removes for 60\n+    // seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executeGets(entries, workSeconds)),\n+        server1.invokeAsync(() -> executePuts(entries, workSeconds)),\n+        accessor.invokeAsync(() -> executeGets(entries, workSeconds)),\n+        accessor.invokeAsync(() -> executeRemoves(entries, workSeconds)));\n+\n+    // Retry the clear operation on the region until success (server2 will go down, but other\n+    // members will become primary for those buckets previously hosted by server2).\n+    executeClearWithRetry(getVM(coordinatorVM.vmNumber));\n+\n+    // Wait for member to get back online.\n+    server2.invoke(() -> {\n+      cacheRule.createCache();\n+      initDataStore(RegionShortcut.PARTITION_REDUNDANT);\n+      await().untilAsserted(\n+          () -> assertThat(InternalDistributedSystem.getConnectedInstance()).isNotNull());\n+    });\n+\n+    // Let asyncInvocations finish.\n+    for (AsyncInvocation<Void> asyncInvocation : asyncInvocationList) {\n+      asyncInvocation.await();\n+    }\n+\n+    // Assert Region Buckets are consistent.\n+    asList(accessor, server1, server2).forEach(vm -> vm.invoke(this::waitForSilence));\n+    accessor.invoke(this::assertRegionBucketsConsistency);\n+  }\n+\n+  /**\n+   * The test does the following (clear coordinator is chosen through parameters):\n+   * - Populates the Partition Region.\n+   * - Verifies that the entries are synchronized on all members.\n+   * - Sets the {@link MemberKiller} as a {@link CacheWriter} to stop a non-coordinator VM while the\n+   * clear is in progress (the member has primary buckets, though, so participates on\n+   * the clear operation).\n+   * - Launches two threads per VM to continuously execute gets, puts and removes for a given time.\n+   * - Clears the Partition Region (at this point the non-coordinator is restarted).\n+   * - Asserts that the clear operation failed with PartitionedRegionPartialClearException (primary\n+   * buckets on the the restarted members are not available).\n+   */\n+  @Test\n+  @Parameters(method = \"coordinators\")\n+  @TestCaseName(\"[{index}] {method}(Coordinator:{0})\")\n+  public void clearOnNonRedundantPartitionRegionWithConcurrentPutGetRemoveShouldFailWhenNonCoordinatorMembersAreBounced(\n+      TestVM coordinatorVM) throws InterruptedException {\n+    final int entries = 7500;\n+    final int workSeconds = 45;\n+    parametrizedSetup(RegionShortcut.PARTITION);\n+    registerVMKillerAsCacheWriter(Collections.singletonList(server2));\n+    populateRegion(accessor, entries, asList(accessor, server1, server2));\n+\n+    // Let all VMs (except the one to kill) continuously execute gets, put and removes for 45\n+    // seconds.\n+    List<AsyncInvocation<Void>> asyncInvocationList = Arrays.asList(\n+        server1.invokeAsync(() -> executeGets(entries, workSeconds)),\n+        server1.invokeAsync(() -> executePuts(entries, workSeconds)),\n+        accessor.invokeAsync(() -> executeGets(entries, workSeconds)),\n+        accessor.invokeAsync(() -> executeRemoves(entries, workSeconds)));\n+\n+    // Clear the region.\n+    getVM(coordinatorVM.vmNumber).invoke(() -> {\n+      assertThatThrownBy(() -> cacheRule.getCache().getRegion(REGION_NAME).clear())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk3Njc2OQ=="}, "originalCommit": {"oid": "a24ace73cfaa3fc20ddfb9dcee4b67a22d9cd440"}, "originalPosition": 600}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NDU5MTE3OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNTowMjowOVrOG0RvBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNTowMjowOVrOG0RvBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ2OTcwMA==", "bodyText": "It's recommended not to declare multiple variables inline, so this should ideally be split into three separate lines.", "url": "https://github.com/apache/geode/pull/4848#discussion_r457469700", "createdAt": "2020-07-20T15:02:09Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,733 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.PartitionedRegionPartialClearException;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.partition.PartitionRegionHelper;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DMStats;\n+import org.apache.geode.distributed.internal.DistributionMessage;\n+import org.apache.geode.distributed.internal.DistributionMessageObserver;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.internal.cache.versions.RegionVersionHolder;\n+import org.apache.geode.internal.cache.versions.RegionVersionVector;\n+import org.apache.geode.internal.cache.versions.VersionSource;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} operation can be executed multiple times\n+ * on the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME =\n+      \"[{index}] {method}(Coordinator:{0}, RegionType:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0f6aa05dfcc4bd2d72ca14f21c553c717802565"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NDYwNjE2OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNTowNDoyOFrOG0R3Zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNTowNDoyOFrOG0R3Zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ3MTg0Nw==", "bodyText": "This warning suppression is not necessary, as the method is used in coordinatorsAndRegionTypes() below.", "url": "https://github.com/apache/geode/pull/4848#discussion_r457471847", "createdAt": "2020-07-20T15:04:28Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,733 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.PartitionedRegionPartialClearException;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.partition.PartitionRegionHelper;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DMStats;\n+import org.apache.geode.distributed.internal.DistributionMessage;\n+import org.apache.geode.distributed.internal.DistributionMessageObserver;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.internal.cache.versions.RegionVersionHolder;\n+import org.apache.geode.internal.cache.versions.RegionVersionVector;\n+import org.apache.geode.internal.cache.versions.VersionSource;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} operation can be executed multiple times\n+ * on the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME =\n+      \"[{index}] {method}(Coordinator:{0}, RegionType:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unused\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0f6aa05dfcc4bd2d72ca14f21c553c717802565"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NDYyNzkyOnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNTowODowN1rOG0SEHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNTowODowN1rOG0SEHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ3NTEwMQ==", "bodyText": "This warning suppression can be removed if the below line is changed to PartitionAttributes<String, String> attributes = new PartitionAttributesFactory<String, String>()", "url": "https://github.com/apache/geode/pull/4848#discussion_r457475101", "createdAt": "2020-07-20T15:08:07Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,733 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.PartitionedRegionPartialClearException;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.partition.PartitionRegionHelper;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DMStats;\n+import org.apache.geode.distributed.internal.DistributionMessage;\n+import org.apache.geode.distributed.internal.DistributionMessageObserver;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.internal.cache.versions.RegionVersionHolder;\n+import org.apache.geode.internal.cache.versions.RegionVersionVector;\n+import org.apache.geode.internal.cache.versions.VersionSource;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} operation can be executed multiple times\n+ * on the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME =\n+      \"[{index}] {method}(Coordinator:{0}, RegionType:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION, RegionShortcut.PARTITION_REDUNDANT\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static TestVM[] coordinators() {\n+    return new TestVM[] {\n+        TestVM.SERVER1, TestVM.ACCESSOR\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] coordinatorsAndRegionTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    RegionShortcut[] regionShortcuts = regionTypes();\n+\n+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {\n+      parameters.add(new Object[] {TestVM.SERVER1, regionShortcut});\n+      parameters.add(new Object[] {TestVM.ACCESSOR, regionShortcut});\n+    });\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    server1 = getVM(TestVM.SERVER1.vmNumber);\n+    server2 = getVM(TestVM.SERVER2.vmNumber);\n+    accessor = getVM(TestVM.ACCESSOR.vmNumber);\n+  }\n+\n+  private void initAccessor(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0f6aa05dfcc4bd2d72ca14f21c553c717802565"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NDYyOTYxOnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNTowODoyNlrOG0SFEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNTowODoyNlrOG0SFEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ3NTM0Nw==", "bodyText": "This warning suppression can be removed if the below line is changed to PartitionAttributes<String, String> attributes = new PartitionAttributesFactory<String, String>()", "url": "https://github.com/apache/geode/pull/4848#discussion_r457475347", "createdAt": "2020-07-20T15:08:26Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,733 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.PartitionedRegionPartialClearException;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.partition.PartitionRegionHelper;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DMStats;\n+import org.apache.geode.distributed.internal.DistributionMessage;\n+import org.apache.geode.distributed.internal.DistributionMessageObserver;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.internal.cache.versions.RegionVersionHolder;\n+import org.apache.geode.internal.cache.versions.RegionVersionVector;\n+import org.apache.geode.internal.cache.versions.VersionSource;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} operation can be executed multiple times\n+ * on the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME =\n+      \"[{index}] {method}(Coordinator:{0}, RegionType:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION, RegionShortcut.PARTITION_REDUNDANT\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static TestVM[] coordinators() {\n+    return new TestVM[] {\n+        TestVM.SERVER1, TestVM.ACCESSOR\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] coordinatorsAndRegionTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    RegionShortcut[] regionShortcuts = regionTypes();\n+\n+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {\n+      parameters.add(new Object[] {TestVM.SERVER1, regionShortcut});\n+      parameters.add(new Object[] {TestVM.ACCESSOR, regionShortcut});\n+    });\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    server1 = getVM(TestVM.SERVER1.vmNumber);\n+    server2 = getVM(TestVM.SERVER2.vmNumber);\n+    accessor = getVM(TestVM.ACCESSOR.vmNumber);\n+  }\n+\n+  private void initAccessor(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .setLocalMaxMemory(0)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+\n+  }\n+\n+  private void initDataStore(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0f6aa05dfcc4bd2d72ca14f21c553c717802565"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NDY3NDcyOnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNToxNDo1M1rOG0Sd0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNToxNDo1M1rOG0Sd0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ4MTY4MQ==", "bodyText": "These warning suppressions can be safely removed if some changes are made in this method, as described below.", "url": "https://github.com/apache/geode/pull/4848#discussion_r457481681", "createdAt": "2020-07-20T15:14:53Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,733 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.PartitionedRegionPartialClearException;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.partition.PartitionRegionHelper;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DMStats;\n+import org.apache.geode.distributed.internal.DistributionMessage;\n+import org.apache.geode.distributed.internal.DistributionMessageObserver;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.internal.cache.versions.RegionVersionHolder;\n+import org.apache.geode.internal.cache.versions.RegionVersionVector;\n+import org.apache.geode.internal.cache.versions.VersionSource;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} operation can be executed multiple times\n+ * on the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME =\n+      \"[{index}] {method}(Coordinator:{0}, RegionType:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION, RegionShortcut.PARTITION_REDUNDANT\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static TestVM[] coordinators() {\n+    return new TestVM[] {\n+        TestVM.SERVER1, TestVM.ACCESSOR\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] coordinatorsAndRegionTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    RegionShortcut[] regionShortcuts = regionTypes();\n+\n+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {\n+      parameters.add(new Object[] {TestVM.SERVER1, regionShortcut});\n+      parameters.add(new Object[] {TestVM.ACCESSOR, regionShortcut});\n+    });\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    server1 = getVM(TestVM.SERVER1.vmNumber);\n+    server2 = getVM(TestVM.SERVER2.vmNumber);\n+    accessor = getVM(TestVM.ACCESSOR.vmNumber);\n+  }\n+\n+  private void initAccessor(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .setLocalMaxMemory(0)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+\n+  }\n+\n+  private void initDataStore(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void parametrizedSetup(RegionShortcut regionShortcut) {\n+    server1.invoke(() -> initDataStore(regionShortcut));\n+    server2.invoke(() -> initDataStore(regionShortcut));\n+    accessor.invoke(() -> initAccessor(regionShortcut));\n+  }\n+\n+  private void waitForSilence() {\n+    DMStats dmStats = cacheRule.getSystem().getDistributionManager().getStats();\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+    PartitionedRegionStats partitionedRegionStats = region.getPrStats();\n+\n+    await().untilAsserted(() -> {\n+      assertThat(dmStats.getReplyWaitsInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getVolunteeringInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getPrimaryTransfersInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getRebalanceBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getRebalancePrimaryTransfersInProgress()).isEqualTo(0);\n+    });\n+  }\n+\n+  /**\n+   * Populates the region and verifies the data on the selected VMs.\n+   */\n+  private void populateRegion(VM feeder, int entryCount, List<VM> vms) {\n+    feeder.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      IntStream.range(0, entryCount).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    });\n+\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      IntStream.range(0, entryCount)\n+          .forEach(i -> assertThat(region.get(String.valueOf(i))).isEqualTo(\"Value_\" + i));\n+    }));\n+  }\n+\n+  /**\n+   * Asserts that the RegionVersionVectors for both buckets are consistent.\n+   *\n+   * @param bucketId Id of the bucket to compare.\n+   * @param bucketDump1 First bucketDump.\n+   * @param bucketDump2 Second bucketDump.\n+   */\n+  @SuppressWarnings({\"unchecked\", \"rawtypes\"})", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0f6aa05dfcc4bd2d72ca14f21c553c717802565"}, "originalPosition": 198}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NDY4NDY1OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNToxNjoxMFrOG0SjIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNToxNjoxMFrOG0SjIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ4MzA0MQ==", "bodyText": "These can be changed to RegionVersionVector<?> to prevent \"rawtypes\" warnings.", "url": "https://github.com/apache/geode/pull/4848#discussion_r457483041", "createdAt": "2020-07-20T15:16:10Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,733 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.PartitionedRegionPartialClearException;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.partition.PartitionRegionHelper;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DMStats;\n+import org.apache.geode.distributed.internal.DistributionMessage;\n+import org.apache.geode.distributed.internal.DistributionMessageObserver;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.internal.cache.versions.RegionVersionHolder;\n+import org.apache.geode.internal.cache.versions.RegionVersionVector;\n+import org.apache.geode.internal.cache.versions.VersionSource;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} operation can be executed multiple times\n+ * on the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME =\n+      \"[{index}] {method}(Coordinator:{0}, RegionType:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION, RegionShortcut.PARTITION_REDUNDANT\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static TestVM[] coordinators() {\n+    return new TestVM[] {\n+        TestVM.SERVER1, TestVM.ACCESSOR\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] coordinatorsAndRegionTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    RegionShortcut[] regionShortcuts = regionTypes();\n+\n+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {\n+      parameters.add(new Object[] {TestVM.SERVER1, regionShortcut});\n+      parameters.add(new Object[] {TestVM.ACCESSOR, regionShortcut});\n+    });\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    server1 = getVM(TestVM.SERVER1.vmNumber);\n+    server2 = getVM(TestVM.SERVER2.vmNumber);\n+    accessor = getVM(TestVM.ACCESSOR.vmNumber);\n+  }\n+\n+  private void initAccessor(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .setLocalMaxMemory(0)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+\n+  }\n+\n+  private void initDataStore(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void parametrizedSetup(RegionShortcut regionShortcut) {\n+    server1.invoke(() -> initDataStore(regionShortcut));\n+    server2.invoke(() -> initDataStore(regionShortcut));\n+    accessor.invoke(() -> initAccessor(regionShortcut));\n+  }\n+\n+  private void waitForSilence() {\n+    DMStats dmStats = cacheRule.getSystem().getDistributionManager().getStats();\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+    PartitionedRegionStats partitionedRegionStats = region.getPrStats();\n+\n+    await().untilAsserted(() -> {\n+      assertThat(dmStats.getReplyWaitsInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getVolunteeringInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getPrimaryTransfersInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getRebalanceBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getRebalancePrimaryTransfersInProgress()).isEqualTo(0);\n+    });\n+  }\n+\n+  /**\n+   * Populates the region and verifies the data on the selected VMs.\n+   */\n+  private void populateRegion(VM feeder, int entryCount, List<VM> vms) {\n+    feeder.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      IntStream.range(0, entryCount).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    });\n+\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      IntStream.range(0, entryCount)\n+          .forEach(i -> assertThat(region.get(String.valueOf(i))).isEqualTo(\"Value_\" + i));\n+    }));\n+  }\n+\n+  /**\n+   * Asserts that the RegionVersionVectors for both buckets are consistent.\n+   *\n+   * @param bucketId Id of the bucket to compare.\n+   * @param bucketDump1 First bucketDump.\n+   * @param bucketDump2 Second bucketDump.\n+   */\n+  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+  private void assertRegionVersionVectorsConsistency(int bucketId, BucketDump bucketDump1,\n+      BucketDump bucketDump2) {\n+    RegionVersionVector rvv1 = bucketDump1.getRvv();\n+    RegionVersionVector rvv2 = bucketDump2.getRvv();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0f6aa05dfcc4bd2d72ca14f21c553c717802565"}, "originalPosition": 202}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NDcxMjQwOnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNToyMDoxMlrOG0SyYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNToyMDoxMlrOG0SyYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ4Njk0NA==", "bodyText": "The following change set will remove the need for suppressed \"unchecked\" and \"rawtypes\" warnings in this method:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Map<VersionSource, RegionVersionHolder> rvv2Members =\n          \n          \n            \n                    new HashMap<VersionSource, RegionVersionHolder>(rvv1.getMemberToVersion());\n          \n          \n            \n                Map<VersionSource, RegionVersionHolder> rvv1Members =\n          \n          \n            \n                    new HashMap<VersionSource, RegionVersionHolder>(rvv1.getMemberToVersion());\n          \n          \n            \n                for (Map.Entry<VersionSource, RegionVersionHolder> entry : rvv1Members.entrySet()) {\n          \n          \n            \n                  VersionSource memberId = entry.getKey();\n          \n          \n            \n                  RegionVersionHolder versionHolder1 = entry.getValue();\n          \n          \n            \n                  RegionVersionHolder versionHolder2 = rvv2Members.remove(memberId);\n          \n          \n            \n                Map<VersionSource<?>, RegionVersionHolder<?>> rvv2Members =\n          \n          \n            \n                    new HashMap<>(rvv1.getMemberToVersion());\n          \n          \n            \n                Map<VersionSource<?>, RegionVersionHolder<?>> rvv1Members =\n          \n          \n            \n                    new HashMap<>(rvv1.getMemberToVersion());\n          \n          \n            \n                for (Map.Entry<VersionSource<?>, RegionVersionHolder<?>> entry : rvv1Members.entrySet()) {\n          \n          \n            \n                  VersionSource<?> memberId = entry.getKey();\n          \n          \n            \n                  RegionVersionHolder<?> versionHolder1 = entry.getValue();\n          \n          \n            \n                  RegionVersionHolder<?> versionHolder2 = rvv2Members.remove(memberId);", "url": "https://github.com/apache/geode/pull/4848#discussion_r457486944", "createdAt": "2020-07-20T15:20:12Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,733 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.PartitionedRegionPartialClearException;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.partition.PartitionRegionHelper;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DMStats;\n+import org.apache.geode.distributed.internal.DistributionMessage;\n+import org.apache.geode.distributed.internal.DistributionMessageObserver;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.internal.cache.versions.RegionVersionHolder;\n+import org.apache.geode.internal.cache.versions.RegionVersionVector;\n+import org.apache.geode.internal.cache.versions.VersionSource;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} operation can be executed multiple times\n+ * on the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME =\n+      \"[{index}] {method}(Coordinator:{0}, RegionType:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION, RegionShortcut.PARTITION_REDUNDANT\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static TestVM[] coordinators() {\n+    return new TestVM[] {\n+        TestVM.SERVER1, TestVM.ACCESSOR\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] coordinatorsAndRegionTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    RegionShortcut[] regionShortcuts = regionTypes();\n+\n+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {\n+      parameters.add(new Object[] {TestVM.SERVER1, regionShortcut});\n+      parameters.add(new Object[] {TestVM.ACCESSOR, regionShortcut});\n+    });\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    server1 = getVM(TestVM.SERVER1.vmNumber);\n+    server2 = getVM(TestVM.SERVER2.vmNumber);\n+    accessor = getVM(TestVM.ACCESSOR.vmNumber);\n+  }\n+\n+  private void initAccessor(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .setLocalMaxMemory(0)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+\n+  }\n+\n+  private void initDataStore(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void parametrizedSetup(RegionShortcut regionShortcut) {\n+    server1.invoke(() -> initDataStore(regionShortcut));\n+    server2.invoke(() -> initDataStore(regionShortcut));\n+    accessor.invoke(() -> initAccessor(regionShortcut));\n+  }\n+\n+  private void waitForSilence() {\n+    DMStats dmStats = cacheRule.getSystem().getDistributionManager().getStats();\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+    PartitionedRegionStats partitionedRegionStats = region.getPrStats();\n+\n+    await().untilAsserted(() -> {\n+      assertThat(dmStats.getReplyWaitsInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getVolunteeringInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getPrimaryTransfersInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getRebalanceBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getRebalancePrimaryTransfersInProgress()).isEqualTo(0);\n+    });\n+  }\n+\n+  /**\n+   * Populates the region and verifies the data on the selected VMs.\n+   */\n+  private void populateRegion(VM feeder, int entryCount, List<VM> vms) {\n+    feeder.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      IntStream.range(0, entryCount).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    });\n+\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      IntStream.range(0, entryCount)\n+          .forEach(i -> assertThat(region.get(String.valueOf(i))).isEqualTo(\"Value_\" + i));\n+    }));\n+  }\n+\n+  /**\n+   * Asserts that the RegionVersionVectors for both buckets are consistent.\n+   *\n+   * @param bucketId Id of the bucket to compare.\n+   * @param bucketDump1 First bucketDump.\n+   * @param bucketDump2 Second bucketDump.\n+   */\n+  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+  private void assertRegionVersionVectorsConsistency(int bucketId, BucketDump bucketDump1,\n+      BucketDump bucketDump2) {\n+    RegionVersionVector rvv1 = bucketDump1.getRvv();\n+    RegionVersionVector rvv2 = bucketDump2.getRvv();\n+\n+    if (rvv1 == null) {\n+      assertThat(rvv2)\n+          .as(\"Bucket \" + bucketId + \" has an RVV on member \" + bucketDump2.getMember()\n+              + \", but does not on member \" + bucketDump1.getMember())\n+          .isNull();\n+    }\n+\n+    if (rvv2 == null) {\n+      assertThat(rvv1)\n+          .as(\"Bucket \" + bucketId + \" has an RVV on member \" + bucketDump1.getMember()\n+              + \", but does not on member \" + bucketDump2.getMember())\n+          .isNull();\n+    }\n+\n+    assertThat(rvv1).isNotNull();\n+    assertThat(rvv2).isNotNull();\n+    Map<VersionSource, RegionVersionHolder> rvv2Members =\n+        new HashMap<VersionSource, RegionVersionHolder>(rvv1.getMemberToVersion());\n+    Map<VersionSource, RegionVersionHolder> rvv1Members =\n+        new HashMap<VersionSource, RegionVersionHolder>(rvv1.getMemberToVersion());\n+    for (Map.Entry<VersionSource, RegionVersionHolder> entry : rvv1Members.entrySet()) {\n+      VersionSource memberId = entry.getKey();\n+      RegionVersionHolder versionHolder1 = entry.getValue();\n+      RegionVersionHolder versionHolder2 = rvv2Members.remove(memberId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0f6aa05dfcc4bd2d72ca14f21c553c717802565"}, "originalPosition": 227}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NDc1MDQyOnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNToyNjoxN1rOG0TIjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNToyNjoxN1rOG0TIjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ5MjYyMA==", "bodyText": "The arguments \"start\" and \"finish\" here might be better named as \"startKey\" and \"endKey\" or something similar, to make it clear that they are not related to time.", "url": "https://github.com/apache/geode/pull/4848#discussion_r457492620", "createdAt": "2020-07-20T15:26:17Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,733 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.PartitionedRegionPartialClearException;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.partition.PartitionRegionHelper;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DMStats;\n+import org.apache.geode.distributed.internal.DistributionMessage;\n+import org.apache.geode.distributed.internal.DistributionMessageObserver;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.internal.cache.versions.RegionVersionHolder;\n+import org.apache.geode.internal.cache.versions.RegionVersionVector;\n+import org.apache.geode.internal.cache.versions.VersionSource;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} operation can be executed multiple times\n+ * on the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME =\n+      \"[{index}] {method}(Coordinator:{0}, RegionType:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION, RegionShortcut.PARTITION_REDUNDANT\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static TestVM[] coordinators() {\n+    return new TestVM[] {\n+        TestVM.SERVER1, TestVM.ACCESSOR\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] coordinatorsAndRegionTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    RegionShortcut[] regionShortcuts = regionTypes();\n+\n+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {\n+      parameters.add(new Object[] {TestVM.SERVER1, regionShortcut});\n+      parameters.add(new Object[] {TestVM.ACCESSOR, regionShortcut});\n+    });\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    server1 = getVM(TestVM.SERVER1.vmNumber);\n+    server2 = getVM(TestVM.SERVER2.vmNumber);\n+    accessor = getVM(TestVM.ACCESSOR.vmNumber);\n+  }\n+\n+  private void initAccessor(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .setLocalMaxMemory(0)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+\n+  }\n+\n+  private void initDataStore(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void parametrizedSetup(RegionShortcut regionShortcut) {\n+    server1.invoke(() -> initDataStore(regionShortcut));\n+    server2.invoke(() -> initDataStore(regionShortcut));\n+    accessor.invoke(() -> initAccessor(regionShortcut));\n+  }\n+\n+  private void waitForSilence() {\n+    DMStats dmStats = cacheRule.getSystem().getDistributionManager().getStats();\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+    PartitionedRegionStats partitionedRegionStats = region.getPrStats();\n+\n+    await().untilAsserted(() -> {\n+      assertThat(dmStats.getReplyWaitsInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getVolunteeringInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getPrimaryTransfersInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getRebalanceBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getRebalancePrimaryTransfersInProgress()).isEqualTo(0);\n+    });\n+  }\n+\n+  /**\n+   * Populates the region and verifies the data on the selected VMs.\n+   */\n+  private void populateRegion(VM feeder, int entryCount, List<VM> vms) {\n+    feeder.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      IntStream.range(0, entryCount).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    });\n+\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      IntStream.range(0, entryCount)\n+          .forEach(i -> assertThat(region.get(String.valueOf(i))).isEqualTo(\"Value_\" + i));\n+    }));\n+  }\n+\n+  /**\n+   * Asserts that the RegionVersionVectors for both buckets are consistent.\n+   *\n+   * @param bucketId Id of the bucket to compare.\n+   * @param bucketDump1 First bucketDump.\n+   * @param bucketDump2 Second bucketDump.\n+   */\n+  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+  private void assertRegionVersionVectorsConsistency(int bucketId, BucketDump bucketDump1,\n+      BucketDump bucketDump2) {\n+    RegionVersionVector rvv1 = bucketDump1.getRvv();\n+    RegionVersionVector rvv2 = bucketDump2.getRvv();\n+\n+    if (rvv1 == null) {\n+      assertThat(rvv2)\n+          .as(\"Bucket \" + bucketId + \" has an RVV on member \" + bucketDump2.getMember()\n+              + \", but does not on member \" + bucketDump1.getMember())\n+          .isNull();\n+    }\n+\n+    if (rvv2 == null) {\n+      assertThat(rvv1)\n+          .as(\"Bucket \" + bucketId + \" has an RVV on member \" + bucketDump1.getMember()\n+              + \", but does not on member \" + bucketDump2.getMember())\n+          .isNull();\n+    }\n+\n+    assertThat(rvv1).isNotNull();\n+    assertThat(rvv2).isNotNull();\n+    Map<VersionSource, RegionVersionHolder> rvv2Members =\n+        new HashMap<VersionSource, RegionVersionHolder>(rvv1.getMemberToVersion());\n+    Map<VersionSource, RegionVersionHolder> rvv1Members =\n+        new HashMap<VersionSource, RegionVersionHolder>(rvv1.getMemberToVersion());\n+    for (Map.Entry<VersionSource, RegionVersionHolder> entry : rvv1Members.entrySet()) {\n+      VersionSource memberId = entry.getKey();\n+      RegionVersionHolder versionHolder1 = entry.getValue();\n+      RegionVersionHolder versionHolder2 = rvv2Members.remove(memberId);\n+      assertThat(versionHolder1)\n+          .as(\"RegionVersionVector for bucket \" + bucketId + \" on member \" + bucketDump1.getMember()\n+              + \" is not consistent with member \" + bucketDump2.getMember())\n+          .isEqualTo(versionHolder2);\n+    }\n+  }\n+\n+  /**\n+   * Asserts that the region data is consistent across buckets.\n+   */\n+  private void assertRegionBucketsConsistency() throws ForceReattemptException {\n+    List<BucketDump> bucketDumps;\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+    // Redundant copies + 1 primary.\n+    int expectedCopies = region.getRedundantCopies() + 1;\n+\n+    for (int bId = 0; bId < BUCKETS; bId++) {\n+      final int bucketId = bId;\n+      bucketDumps = region.getAllBucketEntries(bucketId);\n+      assertThat(bucketDumps.size())\n+          .as(\"Bucket \" + bucketId + \" should have \" + expectedCopies + \" copies, but has \"\n+              + bucketDumps.size())\n+          .isEqualTo(expectedCopies);\n+\n+      // Check that all copies of the bucket have the same data.\n+      if (bucketDumps.size() > 1) {\n+        BucketDump firstDump = bucketDumps.get(0);\n+\n+        for (int j = 1; j < bucketDumps.size(); j++) {\n+          BucketDump otherDump = bucketDumps.get(j);\n+          assertRegionVersionVectorsConsistency(bucketId, firstDump, otherDump);\n+\n+          await().untilAsserted(() -> assertThat(otherDump.getValues())\n+              .as(\"Values for bucket \" + bucketId + \" on member \" + otherDump.getMember()\n+                  + \" are not consistent with member \" + firstDump.getMember())\n+              .isEqualTo(firstDump.getValues()));\n+\n+          await().untilAsserted(() -> assertThat(otherDump.getVersions())\n+              .as(\"Versions for bucket \" + bucketId + \" on member \" + otherDump.getMember()\n+                  + \" are not consistent with member \" + firstDump.getMember())\n+              .isEqualTo(firstDump.getVersions()));\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute get operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeGets(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      // Region might have been cleared in between, that's why we check for null.\n+      IntStream.range(0, numEntries).forEach(i -> {\n+        Optional<String> nullableValue = Optional.ofNullable(region.get(String.valueOf(i)));\n+        nullableValue.ifPresent(value -> assertThat(value).isEqualTo(\"Value_\" + i));\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute put operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executePuts(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      IntStream.range(0, numEntries).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute putAll operations on the PartitionedRegion for the given\n+   * durationInSeconds.\n+   */\n+  private void executePutAlls(final int start, final int finish, final long durationInSeconds) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0f6aa05dfcc4bd2d72ca14f21c553c717802565"}, "originalPosition": 308}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NDc1NTEwOnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNToyNzowNFrOG0TLXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNToyNzowNFrOG0TLXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ5MzM0Mw==", "bodyText": "The arguments \"start\" and \"finish\" here might be better named as \"startKey\" and \"endKey\" or something similar, to make it clear that they are not related to time.", "url": "https://github.com/apache/geode/pull/4848#discussion_r457493343", "createdAt": "2020-07-20T15:27:04Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,733 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.PartitionedRegionPartialClearException;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.partition.PartitionRegionHelper;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DMStats;\n+import org.apache.geode.distributed.internal.DistributionMessage;\n+import org.apache.geode.distributed.internal.DistributionMessageObserver;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.internal.cache.versions.RegionVersionHolder;\n+import org.apache.geode.internal.cache.versions.RegionVersionVector;\n+import org.apache.geode.internal.cache.versions.VersionSource;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} operation can be executed multiple times\n+ * on the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME =\n+      \"[{index}] {method}(Coordinator:{0}, RegionType:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION, RegionShortcut.PARTITION_REDUNDANT\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static TestVM[] coordinators() {\n+    return new TestVM[] {\n+        TestVM.SERVER1, TestVM.ACCESSOR\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] coordinatorsAndRegionTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    RegionShortcut[] regionShortcuts = regionTypes();\n+\n+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {\n+      parameters.add(new Object[] {TestVM.SERVER1, regionShortcut});\n+      parameters.add(new Object[] {TestVM.ACCESSOR, regionShortcut});\n+    });\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    server1 = getVM(TestVM.SERVER1.vmNumber);\n+    server2 = getVM(TestVM.SERVER2.vmNumber);\n+    accessor = getVM(TestVM.ACCESSOR.vmNumber);\n+  }\n+\n+  private void initAccessor(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .setLocalMaxMemory(0)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+\n+  }\n+\n+  private void initDataStore(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void parametrizedSetup(RegionShortcut regionShortcut) {\n+    server1.invoke(() -> initDataStore(regionShortcut));\n+    server2.invoke(() -> initDataStore(regionShortcut));\n+    accessor.invoke(() -> initAccessor(regionShortcut));\n+  }\n+\n+  private void waitForSilence() {\n+    DMStats dmStats = cacheRule.getSystem().getDistributionManager().getStats();\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+    PartitionedRegionStats partitionedRegionStats = region.getPrStats();\n+\n+    await().untilAsserted(() -> {\n+      assertThat(dmStats.getReplyWaitsInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getVolunteeringInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getPrimaryTransfersInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getRebalanceBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getRebalancePrimaryTransfersInProgress()).isEqualTo(0);\n+    });\n+  }\n+\n+  /**\n+   * Populates the region and verifies the data on the selected VMs.\n+   */\n+  private void populateRegion(VM feeder, int entryCount, List<VM> vms) {\n+    feeder.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      IntStream.range(0, entryCount).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    });\n+\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      IntStream.range(0, entryCount)\n+          .forEach(i -> assertThat(region.get(String.valueOf(i))).isEqualTo(\"Value_\" + i));\n+    }));\n+  }\n+\n+  /**\n+   * Asserts that the RegionVersionVectors for both buckets are consistent.\n+   *\n+   * @param bucketId Id of the bucket to compare.\n+   * @param bucketDump1 First bucketDump.\n+   * @param bucketDump2 Second bucketDump.\n+   */\n+  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+  private void assertRegionVersionVectorsConsistency(int bucketId, BucketDump bucketDump1,\n+      BucketDump bucketDump2) {\n+    RegionVersionVector rvv1 = bucketDump1.getRvv();\n+    RegionVersionVector rvv2 = bucketDump2.getRvv();\n+\n+    if (rvv1 == null) {\n+      assertThat(rvv2)\n+          .as(\"Bucket \" + bucketId + \" has an RVV on member \" + bucketDump2.getMember()\n+              + \", but does not on member \" + bucketDump1.getMember())\n+          .isNull();\n+    }\n+\n+    if (rvv2 == null) {\n+      assertThat(rvv1)\n+          .as(\"Bucket \" + bucketId + \" has an RVV on member \" + bucketDump1.getMember()\n+              + \", but does not on member \" + bucketDump2.getMember())\n+          .isNull();\n+    }\n+\n+    assertThat(rvv1).isNotNull();\n+    assertThat(rvv2).isNotNull();\n+    Map<VersionSource, RegionVersionHolder> rvv2Members =\n+        new HashMap<VersionSource, RegionVersionHolder>(rvv1.getMemberToVersion());\n+    Map<VersionSource, RegionVersionHolder> rvv1Members =\n+        new HashMap<VersionSource, RegionVersionHolder>(rvv1.getMemberToVersion());\n+    for (Map.Entry<VersionSource, RegionVersionHolder> entry : rvv1Members.entrySet()) {\n+      VersionSource memberId = entry.getKey();\n+      RegionVersionHolder versionHolder1 = entry.getValue();\n+      RegionVersionHolder versionHolder2 = rvv2Members.remove(memberId);\n+      assertThat(versionHolder1)\n+          .as(\"RegionVersionVector for bucket \" + bucketId + \" on member \" + bucketDump1.getMember()\n+              + \" is not consistent with member \" + bucketDump2.getMember())\n+          .isEqualTo(versionHolder2);\n+    }\n+  }\n+\n+  /**\n+   * Asserts that the region data is consistent across buckets.\n+   */\n+  private void assertRegionBucketsConsistency() throws ForceReattemptException {\n+    List<BucketDump> bucketDumps;\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+    // Redundant copies + 1 primary.\n+    int expectedCopies = region.getRedundantCopies() + 1;\n+\n+    for (int bId = 0; bId < BUCKETS; bId++) {\n+      final int bucketId = bId;\n+      bucketDumps = region.getAllBucketEntries(bucketId);\n+      assertThat(bucketDumps.size())\n+          .as(\"Bucket \" + bucketId + \" should have \" + expectedCopies + \" copies, but has \"\n+              + bucketDumps.size())\n+          .isEqualTo(expectedCopies);\n+\n+      // Check that all copies of the bucket have the same data.\n+      if (bucketDumps.size() > 1) {\n+        BucketDump firstDump = bucketDumps.get(0);\n+\n+        for (int j = 1; j < bucketDumps.size(); j++) {\n+          BucketDump otherDump = bucketDumps.get(j);\n+          assertRegionVersionVectorsConsistency(bucketId, firstDump, otherDump);\n+\n+          await().untilAsserted(() -> assertThat(otherDump.getValues())\n+              .as(\"Values for bucket \" + bucketId + \" on member \" + otherDump.getMember()\n+                  + \" are not consistent with member \" + firstDump.getMember())\n+              .isEqualTo(firstDump.getValues()));\n+\n+          await().untilAsserted(() -> assertThat(otherDump.getVersions())\n+              .as(\"Versions for bucket \" + bucketId + \" on member \" + otherDump.getMember()\n+                  + \" are not consistent with member \" + firstDump.getMember())\n+              .isEqualTo(firstDump.getVersions()));\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute get operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeGets(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      // Region might have been cleared in between, that's why we check for null.\n+      IntStream.range(0, numEntries).forEach(i -> {\n+        Optional<String> nullableValue = Optional.ofNullable(region.get(String.valueOf(i)));\n+        nullableValue.ifPresent(value -> assertThat(value).isEqualTo(\"Value_\" + i));\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute put operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executePuts(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      IntStream.range(0, numEntries).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute putAll operations on the PartitionedRegion for the given\n+   * durationInSeconds.\n+   */\n+  private void executePutAlls(final int start, final int finish, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Map<String, String> valuesToInsert = new HashMap<>();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    IntStream.range(start, finish)\n+        .forEach(i -> valuesToInsert.put(String.valueOf(i), \"Value_\" + i));\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      region.putAll(valuesToInsert);\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute remove operations on the PartitionedRegion for the given\n+   * durationInSeconds.\n+   */\n+  private void executeRemoves(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      // Region might have been cleared in between, that's why we check for null.\n+      IntStream.range(0, numEntries).forEach(i -> {\n+        Optional<String> nullableValue = Optional.ofNullable(region.remove(String.valueOf(i)));\n+        nullableValue.ifPresent(value -> assertThat(value).isEqualTo(\"Value_\" + i));\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute removeAll operations on the PartitionedRegion for the given\n+   * durationInSeconds.\n+   */\n+  private void executeRemoveAlls(final int start, final int finish, final long durationInSeconds) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0f6aa05dfcc4bd2d72ca14f21c553c717802565"}, "originalPosition": 343}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NDc5MzcwOnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNTozMzozMlrOG0TiVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNTozMzozMlrOG0TiVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ5OTIyMg==", "bodyText": "Instead of a while loop with a Thread.sleep(), it might be better to use the Timer and TimerTask classes to execute clears (specifically the scheduleAtFixedRate() method.) Entirely personal preference, but I do know that in general we try not to use Thread.sleep() directly in tests.", "url": "https://github.com/apache/geode/pull/4848#discussion_r457499222", "createdAt": "2020-07-20T15:33:32Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithConcurrentOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,733 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.util.ArrayUtils.asList;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.PartitionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.PartitionedRegionPartialClearException;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.partition.PartitionRegionHelper;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DMStats;\n+import org.apache.geode.distributed.internal.DistributionMessage;\n+import org.apache.geode.distributed.internal.DistributionMessageObserver;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;\n+import org.apache.geode.internal.cache.versions.RegionVersionHolder;\n+import org.apache.geode.internal.cache.versions.RegionVersionVector;\n+import org.apache.geode.internal.cache.versions.VersionSource;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+\n+/**\n+ * Tests to verify that {@link PartitionedRegion#clear()} operation can be executed multiple times\n+ * on the same region while other cache operations are being executed concurrently and members are\n+ * added or removed.\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PartitionedRegionClearWithConcurrentOperationsDUnitTest implements Serializable {\n+  private static final Integer BUCKETS = 13;\n+  private static final String REGION_NAME = \"PartitionedRegion\";\n+  private static final String TEST_CASE_NAME =\n+      \"[{index}] {method}(Coordinator:{0}, RegionType:{1})\";\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(3);\n+\n+  @Rule\n+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();\n+\n+  private VM accessor, server1, server2;\n+\n+  private enum TestVM {\n+    ACCESSOR(0), SERVER1(1), SERVER2(2);\n+\n+    final int vmNumber;\n+\n+    TestVM(int vmNumber) {\n+      this.vmNumber = vmNumber;\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static RegionShortcut[] regionTypes() {\n+    return new RegionShortcut[] {\n+        RegionShortcut.PARTITION, RegionShortcut.PARTITION_REDUNDANT\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static TestVM[] coordinators() {\n+    return new TestVM[] {\n+        TestVM.SERVER1, TestVM.ACCESSOR\n+    };\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] coordinatorsAndRegionTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    RegionShortcut[] regionShortcuts = regionTypes();\n+\n+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {\n+      parameters.add(new Object[] {TestVM.SERVER1, regionShortcut});\n+      parameters.add(new Object[] {TestVM.ACCESSOR, regionShortcut});\n+    });\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    server1 = getVM(TestVM.SERVER1.vmNumber);\n+    server2 = getVM(TestVM.SERVER2.vmNumber);\n+    accessor = getVM(TestVM.ACCESSOR.vmNumber);\n+  }\n+\n+  private void initAccessor(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .setLocalMaxMemory(0)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+\n+  }\n+\n+  private void initDataStore(RegionShortcut regionShortcut) {\n+    @SuppressWarnings(\"rawtypes\")\n+    PartitionAttributes attributes = new PartitionAttributesFactory<String, String>()\n+        .setTotalNumBuckets(BUCKETS)\n+        .create();\n+\n+    cacheRule.getCache().createRegionFactory(regionShortcut)\n+        .setPartitionAttributes(attributes)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void parametrizedSetup(RegionShortcut regionShortcut) {\n+    server1.invoke(() -> initDataStore(regionShortcut));\n+    server2.invoke(() -> initDataStore(regionShortcut));\n+    accessor.invoke(() -> initAccessor(regionShortcut));\n+  }\n+\n+  private void waitForSilence() {\n+    DMStats dmStats = cacheRule.getSystem().getDistributionManager().getStats();\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+    PartitionedRegionStats partitionedRegionStats = region.getPrStats();\n+\n+    await().untilAsserted(() -> {\n+      assertThat(dmStats.getReplyWaitsInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getVolunteeringInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getPrimaryTransfersInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getRebalanceBucketCreatesInProgress()).isEqualTo(0);\n+      assertThat(partitionedRegionStats.getRebalancePrimaryTransfersInProgress()).isEqualTo(0);\n+    });\n+  }\n+\n+  /**\n+   * Populates the region and verifies the data on the selected VMs.\n+   */\n+  private void populateRegion(VM feeder, int entryCount, List<VM> vms) {\n+    feeder.invoke(() -> {\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      IntStream.range(0, entryCount).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    });\n+\n+    vms.forEach(vm -> vm.invoke(() -> {\n+      waitForSilence();\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      IntStream.range(0, entryCount)\n+          .forEach(i -> assertThat(region.get(String.valueOf(i))).isEqualTo(\"Value_\" + i));\n+    }));\n+  }\n+\n+  /**\n+   * Asserts that the RegionVersionVectors for both buckets are consistent.\n+   *\n+   * @param bucketId Id of the bucket to compare.\n+   * @param bucketDump1 First bucketDump.\n+   * @param bucketDump2 Second bucketDump.\n+   */\n+  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+  private void assertRegionVersionVectorsConsistency(int bucketId, BucketDump bucketDump1,\n+      BucketDump bucketDump2) {\n+    RegionVersionVector rvv1 = bucketDump1.getRvv();\n+    RegionVersionVector rvv2 = bucketDump2.getRvv();\n+\n+    if (rvv1 == null) {\n+      assertThat(rvv2)\n+          .as(\"Bucket \" + bucketId + \" has an RVV on member \" + bucketDump2.getMember()\n+              + \", but does not on member \" + bucketDump1.getMember())\n+          .isNull();\n+    }\n+\n+    if (rvv2 == null) {\n+      assertThat(rvv1)\n+          .as(\"Bucket \" + bucketId + \" has an RVV on member \" + bucketDump1.getMember()\n+              + \", but does not on member \" + bucketDump2.getMember())\n+          .isNull();\n+    }\n+\n+    assertThat(rvv1).isNotNull();\n+    assertThat(rvv2).isNotNull();\n+    Map<VersionSource, RegionVersionHolder> rvv2Members =\n+        new HashMap<VersionSource, RegionVersionHolder>(rvv1.getMemberToVersion());\n+    Map<VersionSource, RegionVersionHolder> rvv1Members =\n+        new HashMap<VersionSource, RegionVersionHolder>(rvv1.getMemberToVersion());\n+    for (Map.Entry<VersionSource, RegionVersionHolder> entry : rvv1Members.entrySet()) {\n+      VersionSource memberId = entry.getKey();\n+      RegionVersionHolder versionHolder1 = entry.getValue();\n+      RegionVersionHolder versionHolder2 = rvv2Members.remove(memberId);\n+      assertThat(versionHolder1)\n+          .as(\"RegionVersionVector for bucket \" + bucketId + \" on member \" + bucketDump1.getMember()\n+              + \" is not consistent with member \" + bucketDump2.getMember())\n+          .isEqualTo(versionHolder2);\n+    }\n+  }\n+\n+  /**\n+   * Asserts that the region data is consistent across buckets.\n+   */\n+  private void assertRegionBucketsConsistency() throws ForceReattemptException {\n+    List<BucketDump> bucketDumps;\n+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);\n+    // Redundant copies + 1 primary.\n+    int expectedCopies = region.getRedundantCopies() + 1;\n+\n+    for (int bId = 0; bId < BUCKETS; bId++) {\n+      final int bucketId = bId;\n+      bucketDumps = region.getAllBucketEntries(bucketId);\n+      assertThat(bucketDumps.size())\n+          .as(\"Bucket \" + bucketId + \" should have \" + expectedCopies + \" copies, but has \"\n+              + bucketDumps.size())\n+          .isEqualTo(expectedCopies);\n+\n+      // Check that all copies of the bucket have the same data.\n+      if (bucketDumps.size() > 1) {\n+        BucketDump firstDump = bucketDumps.get(0);\n+\n+        for (int j = 1; j < bucketDumps.size(); j++) {\n+          BucketDump otherDump = bucketDumps.get(j);\n+          assertRegionVersionVectorsConsistency(bucketId, firstDump, otherDump);\n+\n+          await().untilAsserted(() -> assertThat(otherDump.getValues())\n+              .as(\"Values for bucket \" + bucketId + \" on member \" + otherDump.getMember()\n+                  + \" are not consistent with member \" + firstDump.getMember())\n+              .isEqualTo(firstDump.getValues()));\n+\n+          await().untilAsserted(() -> assertThat(otherDump.getVersions())\n+              .as(\"Versions for bucket \" + bucketId + \" on member \" + otherDump.getMember()\n+                  + \" are not consistent with member \" + firstDump.getMember())\n+              .isEqualTo(firstDump.getVersions()));\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute get operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeGets(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      // Region might have been cleared in between, that's why we check for null.\n+      IntStream.range(0, numEntries).forEach(i -> {\n+        Optional<String> nullableValue = Optional.ofNullable(region.get(String.valueOf(i)));\n+        nullableValue.ifPresent(value -> assertThat(value).isEqualTo(\"Value_\" + i));\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute put operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executePuts(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      IntStream.range(0, numEntries).forEach(i -> region.put(String.valueOf(i), \"Value_\" + i));\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute putAll operations on the PartitionedRegion for the given\n+   * durationInSeconds.\n+   */\n+  private void executePutAlls(final int start, final int finish, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Map<String, String> valuesToInsert = new HashMap<>();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    IntStream.range(start, finish)\n+        .forEach(i -> valuesToInsert.put(String.valueOf(i), \"Value_\" + i));\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      region.putAll(valuesToInsert);\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute remove operations on the PartitionedRegion for the given\n+   * durationInSeconds.\n+   */\n+  private void executeRemoves(final int numEntries, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      // Region might have been cleared in between, that's why we check for null.\n+      IntStream.range(0, numEntries).forEach(i -> {\n+        Optional<String> nullableValue = Optional.ofNullable(region.remove(String.valueOf(i)));\n+        nullableValue.ifPresent(value -> assertThat(value).isEqualTo(\"Value_\" + i));\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Continuously execute removeAll operations on the PartitionedRegion for the given\n+   * durationInSeconds.\n+   */\n+  private void executeRemoveAlls(final int start, final int finish, final long durationInSeconds) {\n+    Cache cache = cacheRule.getCache();\n+    List<String> keysToRemove = new ArrayList<>();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    IntStream.range(start, finish).forEach(i -> keysToRemove.add(String.valueOf(i)));\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      region.removeAll(keysToRemove);\n+    }\n+  }\n+\n+  /**\n+   * Execute the clear operation and retry until success.\n+   */\n+  private void executeClearWithRetry(VM coordinator) {\n+    coordinator.invoke(() -> {\n+      boolean retry;\n+\n+      do {\n+        retry = false;\n+\n+        try {\n+          cacheRule.getCache().getRegion(REGION_NAME).clear();\n+        } catch (PartitionedRegionPartialClearException pce) {\n+          retry = true;\n+        }\n+\n+      } while (retry);\n+    });\n+  }\n+\n+  /**\n+   * Continuously execute clear operations on the PartitionedRegion for the given durationInSeconds.\n+   */\n+  private void executeClears(final long durationInSeconds, final long waitTimeInMilliseconds)\n+      throws InterruptedException {\n+    Cache cache = cacheRule.getCache();\n+    Region<String, String> region = cache.getRegion(REGION_NAME);\n+    Instant finishTime = Instant.now().plusSeconds(durationInSeconds);\n+\n+    while (Instant.now().isBefore(finishTime)) {\n+      region.clear();\n+      Thread.sleep(waitTimeInMilliseconds);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0f6aa05dfcc4bd2d72ca14f21c553c717802565"}, "originalPosition": 386}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4423, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}