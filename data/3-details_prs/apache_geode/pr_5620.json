{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAyMjUxODIw", "number": 5620, "title": "GEODE-8293: fix activeCQCount has negative value after close/stop cq for PR", "bodyText": "For partitioned regions if the CQ is registered on one server, it will be created on all the nodes/servers hosting the region.\nIn this case activeCQCount is increment only on one server.\nAfter close/stop CQ it found that it has CQ on all members and decrement num of active CQs, despite of that it is only incremented on one server, so we got negative values.\nWith fix it will increment activeCQCount on all nodes/servers that hosting the region. So when it close/stop it will not go to the negative values.\nThis change will not have effects on non-partitioned(replicated) regions.\nThank you for submitting a contribution to Apache Geode.\nIn order to streamline the review of the contribution we ask you\nto ensure the following steps have been taken:\nFor all changes:\n\n\n Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?\n\n\n Has your PR been rebased against the latest commit within the target branch (typically develop)?\n\n\n Is your initial contribution a single, squashed commit?\n\n\n Does gradlew build run cleanly?\n\n\n Have you written or updated unit tests to verify your changes?\n\n\n If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under ASF 2.0?\n\n\nNote:\nPlease ensure that once the PR is submitted, check Concourse for build issues and\nsubmit an update to your PR as soon as possible. If you need help, please send an\nemail to dev@geode.apache.org.", "createdAt": "2020-10-13T12:19:29Z", "url": "https://github.com/apache/geode/pull/5620", "merged": true, "mergeCommit": {"oid": "f3d806f66a2e9a0e1bdfc7e98f6ebed5fba53322"}, "closed": true, "closedAt": "2020-11-17T07:38:18Z", "author": {"login": "mkevo"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdSHl4XgH2gAyNTAyMjUxODIwOjllMmEwYTIzMzIzMWZmODNhODU3MDUyMzcxOGFlMTcwODcyODgyNjM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdbkPOQAFqTUyODUyMTY2NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "9e2a0a233231ff83a8570523718ae17087288263", "author": {"user": {"login": "mkevo", "name": "Mario Kevo"}}, "url": "https://github.com/apache/geode/commit/9e2a0a233231ff83a8570523718ae17087288263", "committedDate": "2020-10-13T12:18:35Z", "message": "GEODE-8293: fix activeCQCount negative value"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4ODE0Mzcz", "url": "https://github.com/apache/geode/pull/5620#pullrequestreview-508814373", "createdAt": "2020-10-14T22:29:30Z", "commit": {"oid": "9e2a0a233231ff83a8570523718ae17087288263"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQyMjoyOTozMVrOHhoOsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQyMjoyOTozMVrOHhoOsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTAyNDE3Ng==", "bodyText": "May we discuss what is intended in this Note? I don't understand it, so I'd like to help revise the wording.", "url": "https://github.com/apache/geode/pull/5620#discussion_r505024176", "createdAt": "2020-10-14T22:29:31Z", "author": {"login": "karensmolermiller"}, "path": "geode-docs/reference/statistics_list.html.md.erb", "diffHunk": "@@ -553,7 +553,12 @@ These statistics are in a client and they describe one of the client\u2019s connect\n \n ## <a id=\"section_66C0E7748501480B85209D57D24256D5\" class=\"no-quick-link\"></a>Continuous Querying (CqQueryStats)\n \n-These statistics are for continuous querying information. The statistics are:\n+These statistics are for continuous querying information.\n+\n+**Note:**\n+The subscription redundancy changes CQS_ACTIVE, CQS_STOPPED and CQS_CLOSED count on partitioned region", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e2a0a233231ff83a8570523718ae17087288263"}, "originalPosition": 8}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e15cda98297d2c705c19d67733360784df43a31", "author": {"user": {"login": "mkevo", "name": "Mario Kevo"}}, "url": "https://github.com/apache/geode/commit/0e15cda98297d2c705c19d67733360784df43a31", "committedDate": "2020-11-02T07:49:54Z", "message": "document changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxOTQ0Nzky", "url": "https://github.com/apache/geode/pull/5620#pullrequestreview-521944792", "createdAt": "2020-11-02T19:49:12Z", "commit": {"oid": "0e15cda98297d2c705c19d67733360784df43a31"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyMTQ1Mjc5", "url": "https://github.com/apache/geode/pull/5620#pullrequestreview-522145279", "createdAt": "2020-11-03T01:40:57Z", "commit": {"oid": "0e15cda98297d2c705c19d67733360784df43a31"}, "state": "DISMISSED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMTo0MDo1N1rOHsduBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMTo0MzowOVrOHsdv-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM4NjMwOA==", "bodyText": "Please provide a timeout. I tested it with timeout(30, TimeUnit.SECONDS). This way, this test will terminate in a \"reasonable\" time.", "url": "https://github.com/apache/geode/pull/5620#discussion_r516386308", "createdAt": "2020-11-03T01:40:57Z", "author": {"login": "kohlmu-pivotal"}, "path": "geode-cq/src/distributedTest/java/org/apache/geode/cache/query/cq/CQMetricsDUnitTest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.cache.query.cq;\n+\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.rules.ClusterStartupRule.getCache;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.Serializable;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.client.ClientCache;\n+import org.apache.geode.cache.client.ClientCacheFactory;\n+import org.apache.geode.cache.client.ClientRegionShortcut;\n+import org.apache.geode.cache.query.CqAttributes;\n+import org.apache.geode.cache.query.CqAttributesFactory;\n+import org.apache.geode.cache.query.CqEvent;\n+import org.apache.geode.cache.query.CqListener;\n+import org.apache.geode.cache.query.CqServiceStatistics;\n+import org.apache.geode.cache.query.QueryService;\n+import org.apache.geode.cache.query.data.Portfolio;\n+import org.apache.geode.management.DistributedSystemMXBean;\n+import org.apache.geode.management.ManagementService;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.rules.GfshCommandRule;\n+\n+public class CQMetricsDUnitTest {\n+\n+  private CqAttributes cqa;\n+  private QueryService qs;\n+  private TestCqListener testListener;\n+  private MemberVM locator, server1, server2;\n+\n+  @Rule\n+  public ClusterStartupRule cluster = new ClusterStartupRule(5);\n+\n+  @Rule\n+  public GfshCommandRule gfsh = new GfshCommandRule();\n+\n+  @Before\n+  public void setUpServers() throws Exception {\n+    locator = cluster.startLocatorVM(0, l -> l.withoutClusterConfigurationService());\n+    server1 = cluster.startServerVM(1, locator.getPort());\n+    server2 = cluster.startServerVM(2, locator.getPort());\n+\n+    ClientCache clientCache = createClientCache(locator.getPort());\n+    Region region =\n+        clientCache.createClientRegionFactory(ClientRegionShortcut.CACHING_PROXY).create(\"region\");\n+\n+    qs = clientCache.getQueryService();\n+    CqAttributesFactory cqaf = new CqAttributesFactory();\n+    testListener = new TestCqListener();\n+    cqaf.addCqListener(testListener);\n+\n+    cqa = cqaf.create();\n+    gfsh.connectAndVerify(locator);\n+  }\n+\n+  @Test\n+  public void testStopCq() throws Exception {\n+    gfsh.executeAndAssertThat(\"create region --name=region --type=PARTITION\")\n+        .statusIsSuccess();\n+    qs.newCq(\"Select * from /region r where r.ID = 1\", cqa).execute();\n+\n+    server1.invoke(() -> populateRegion(0, 100));\n+\n+    locator.invoke(() -> {\n+      Cache cache = getCache();\n+      ManagementService service = ManagementService.getManagementService(cache);\n+      DistributedSystemMXBean dsmbean = service.getDistributedSystemMXBean();\n+      await().untilAsserted(() -> assertThat(dsmbean.getActiveCQCount()).isEqualTo(2));\n+    });\n+\n+    // stop cq\n+    qs.stopCqs();\n+\n+    locator.invoke(() -> {\n+      Cache cache = getCache();\n+      ManagementService service = ManagementService.getManagementService(cache);\n+      DistributedSystemMXBean dsmbean = service.getDistributedSystemMXBean();\n+      await().untilAsserted(() -> assertThat(dsmbean.getActiveCQCount()).isEqualTo(0));\n+    });\n+\n+    checkActiveCqCount(server1, 0);\n+    checkActiveCqCount(server2, 0);\n+  }\n+\n+  @Test\n+  public void testCloseCq() throws Exception {\n+    gfsh.executeAndAssertThat(\"create region --name=region --type=PARTITION\")\n+        .statusIsSuccess();\n+    qs.newCq(\"Select * from /region r where r.ID = 1\", cqa).execute();\n+\n+    server1.invoke(() -> populateRegion(0, 100));\n+\n+    locator.invoke(() -> {\n+      Cache cache = getCache();\n+      ManagementService service = ManagementService.getManagementService(cache);\n+      DistributedSystemMXBean dsmbean = service.getDistributedSystemMXBean();\n+      await().untilAsserted(() -> assertThat(dsmbean.getActiveCQCount()).isEqualTo(2));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e15cda98297d2c705c19d67733360784df43a31"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM4NjM4Ng==", "bodyText": "Please provide a timeout. I tested it with timeout(30, TimeUnit.SECONDS). This way, this test will terminate in a \"reasonable\" time.", "url": "https://github.com/apache/geode/pull/5620#discussion_r516386386", "createdAt": "2020-11-03T01:41:15Z", "author": {"login": "kohlmu-pivotal"}, "path": "geode-cq/src/distributedTest/java/org/apache/geode/cache/query/cq/CQMetricsDUnitTest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.cache.query.cq;\n+\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.rules.ClusterStartupRule.getCache;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.Serializable;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.client.ClientCache;\n+import org.apache.geode.cache.client.ClientCacheFactory;\n+import org.apache.geode.cache.client.ClientRegionShortcut;\n+import org.apache.geode.cache.query.CqAttributes;\n+import org.apache.geode.cache.query.CqAttributesFactory;\n+import org.apache.geode.cache.query.CqEvent;\n+import org.apache.geode.cache.query.CqListener;\n+import org.apache.geode.cache.query.CqServiceStatistics;\n+import org.apache.geode.cache.query.QueryService;\n+import org.apache.geode.cache.query.data.Portfolio;\n+import org.apache.geode.management.DistributedSystemMXBean;\n+import org.apache.geode.management.ManagementService;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.rules.GfshCommandRule;\n+\n+public class CQMetricsDUnitTest {\n+\n+  private CqAttributes cqa;\n+  private QueryService qs;\n+  private TestCqListener testListener;\n+  private MemberVM locator, server1, server2;\n+\n+  @Rule\n+  public ClusterStartupRule cluster = new ClusterStartupRule(5);\n+\n+  @Rule\n+  public GfshCommandRule gfsh = new GfshCommandRule();\n+\n+  @Before\n+  public void setUpServers() throws Exception {\n+    locator = cluster.startLocatorVM(0, l -> l.withoutClusterConfigurationService());\n+    server1 = cluster.startServerVM(1, locator.getPort());\n+    server2 = cluster.startServerVM(2, locator.getPort());\n+\n+    ClientCache clientCache = createClientCache(locator.getPort());\n+    Region region =\n+        clientCache.createClientRegionFactory(ClientRegionShortcut.CACHING_PROXY).create(\"region\");\n+\n+    qs = clientCache.getQueryService();\n+    CqAttributesFactory cqaf = new CqAttributesFactory();\n+    testListener = new TestCqListener();\n+    cqaf.addCqListener(testListener);\n+\n+    cqa = cqaf.create();\n+    gfsh.connectAndVerify(locator);\n+  }\n+\n+  @Test\n+  public void testStopCq() throws Exception {\n+    gfsh.executeAndAssertThat(\"create region --name=region --type=PARTITION\")\n+        .statusIsSuccess();\n+    qs.newCq(\"Select * from /region r where r.ID = 1\", cqa).execute();\n+\n+    server1.invoke(() -> populateRegion(0, 100));\n+\n+    locator.invoke(() -> {\n+      Cache cache = getCache();\n+      ManagementService service = ManagementService.getManagementService(cache);\n+      DistributedSystemMXBean dsmbean = service.getDistributedSystemMXBean();\n+      await().untilAsserted(() -> assertThat(dsmbean.getActiveCQCount()).isEqualTo(2));\n+    });\n+\n+    // stop cq\n+    qs.stopCqs();\n+\n+    locator.invoke(() -> {\n+      Cache cache = getCache();\n+      ManagementService service = ManagementService.getManagementService(cache);\n+      DistributedSystemMXBean dsmbean = service.getDistributedSystemMXBean();\n+      await().untilAsserted(() -> assertThat(dsmbean.getActiveCQCount()).isEqualTo(0));\n+    });\n+\n+    checkActiveCqCount(server1, 0);\n+    checkActiveCqCount(server2, 0);\n+  }\n+\n+  @Test\n+  public void testCloseCq() throws Exception {\n+    gfsh.executeAndAssertThat(\"create region --name=region --type=PARTITION\")\n+        .statusIsSuccess();\n+    qs.newCq(\"Select * from /region r where r.ID = 1\", cqa).execute();\n+\n+    server1.invoke(() -> populateRegion(0, 100));\n+\n+    locator.invoke(() -> {\n+      Cache cache = getCache();\n+      ManagementService service = ManagementService.getManagementService(cache);\n+      DistributedSystemMXBean dsmbean = service.getDistributedSystemMXBean();\n+      await().untilAsserted(() -> assertThat(dsmbean.getActiveCQCount()).isEqualTo(2));\n+    });\n+\n+    // close cq\n+    qs.closeCqs();\n+\n+    locator.invoke(() -> {\n+      Cache cache = getCache();\n+      ManagementService service = ManagementService.getManagementService(cache);\n+      DistributedSystemMXBean dsmbean = service.getDistributedSystemMXBean();\n+      await().untilAsserted(() -> assertThat(dsmbean.getActiveCQCount()).isEqualTo(0));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e15cda98297d2c705c19d67733360784df43a31"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM4NjM5Mg==", "bodyText": "Please provide a timeout. I tested it with timeout(30, TimeUnit.SECONDS). This way, this test will terminate in a \"reasonable\" time.", "url": "https://github.com/apache/geode/pull/5620#discussion_r516386392", "createdAt": "2020-11-03T01:41:17Z", "author": {"login": "kohlmu-pivotal"}, "path": "geode-cq/src/distributedTest/java/org/apache/geode/cache/query/cq/CQMetricsDUnitTest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.cache.query.cq;\n+\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.rules.ClusterStartupRule.getCache;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.Serializable;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.client.ClientCache;\n+import org.apache.geode.cache.client.ClientCacheFactory;\n+import org.apache.geode.cache.client.ClientRegionShortcut;\n+import org.apache.geode.cache.query.CqAttributes;\n+import org.apache.geode.cache.query.CqAttributesFactory;\n+import org.apache.geode.cache.query.CqEvent;\n+import org.apache.geode.cache.query.CqListener;\n+import org.apache.geode.cache.query.CqServiceStatistics;\n+import org.apache.geode.cache.query.QueryService;\n+import org.apache.geode.cache.query.data.Portfolio;\n+import org.apache.geode.management.DistributedSystemMXBean;\n+import org.apache.geode.management.ManagementService;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.rules.GfshCommandRule;\n+\n+public class CQMetricsDUnitTest {\n+\n+  private CqAttributes cqa;\n+  private QueryService qs;\n+  private TestCqListener testListener;\n+  private MemberVM locator, server1, server2;\n+\n+  @Rule\n+  public ClusterStartupRule cluster = new ClusterStartupRule(5);\n+\n+  @Rule\n+  public GfshCommandRule gfsh = new GfshCommandRule();\n+\n+  @Before\n+  public void setUpServers() throws Exception {\n+    locator = cluster.startLocatorVM(0, l -> l.withoutClusterConfigurationService());\n+    server1 = cluster.startServerVM(1, locator.getPort());\n+    server2 = cluster.startServerVM(2, locator.getPort());\n+\n+    ClientCache clientCache = createClientCache(locator.getPort());\n+    Region region =\n+        clientCache.createClientRegionFactory(ClientRegionShortcut.CACHING_PROXY).create(\"region\");\n+\n+    qs = clientCache.getQueryService();\n+    CqAttributesFactory cqaf = new CqAttributesFactory();\n+    testListener = new TestCqListener();\n+    cqaf.addCqListener(testListener);\n+\n+    cqa = cqaf.create();\n+    gfsh.connectAndVerify(locator);\n+  }\n+\n+  @Test\n+  public void testStopCq() throws Exception {\n+    gfsh.executeAndAssertThat(\"create region --name=region --type=PARTITION\")\n+        .statusIsSuccess();\n+    qs.newCq(\"Select * from /region r where r.ID = 1\", cqa).execute();\n+\n+    server1.invoke(() -> populateRegion(0, 100));\n+\n+    locator.invoke(() -> {\n+      Cache cache = getCache();\n+      ManagementService service = ManagementService.getManagementService(cache);\n+      DistributedSystemMXBean dsmbean = service.getDistributedSystemMXBean();\n+      await().untilAsserted(() -> assertThat(dsmbean.getActiveCQCount()).isEqualTo(2));\n+    });\n+\n+    // stop cq\n+    qs.stopCqs();\n+\n+    locator.invoke(() -> {\n+      Cache cache = getCache();\n+      ManagementService service = ManagementService.getManagementService(cache);\n+      DistributedSystemMXBean dsmbean = service.getDistributedSystemMXBean();\n+      await().untilAsserted(() -> assertThat(dsmbean.getActiveCQCount()).isEqualTo(0));\n+    });\n+\n+    checkActiveCqCount(server1, 0);\n+    checkActiveCqCount(server2, 0);\n+  }\n+\n+  @Test\n+  public void testCloseCq() throws Exception {\n+    gfsh.executeAndAssertThat(\"create region --name=region --type=PARTITION\")\n+        .statusIsSuccess();\n+    qs.newCq(\"Select * from /region r where r.ID = 1\", cqa).execute();\n+\n+    server1.invoke(() -> populateRegion(0, 100));\n+\n+    locator.invoke(() -> {\n+      Cache cache = getCache();\n+      ManagementService service = ManagementService.getManagementService(cache);\n+      DistributedSystemMXBean dsmbean = service.getDistributedSystemMXBean();\n+      await().untilAsserted(() -> assertThat(dsmbean.getActiveCQCount()).isEqualTo(2));\n+    });\n+\n+    // close cq\n+    qs.closeCqs();\n+\n+    locator.invoke(() -> {\n+      Cache cache = getCache();\n+      ManagementService service = ManagementService.getManagementService(cache);\n+      DistributedSystemMXBean dsmbean = service.getDistributedSystemMXBean();\n+      await().untilAsserted(() -> assertThat(dsmbean.getActiveCQCount()).isEqualTo(0));\n+    });\n+  }\n+\n+  private class TestCqListener implements CqListener, Serializable {\n+    public int onEventCalls = 0;\n+\n+    @Override\n+    public void onEvent(CqEvent aCqEvent) {\n+      onEventCalls++;\n+    }\n+\n+    @Override\n+    public void onError(CqEvent aCqEvent) {}\n+\n+    @Override\n+    public void close() {}\n+  }\n+\n+  private static void populateRegion(int startingId, int endingId) {\n+    Region exampleRegion = getCache().getRegion(\"region\");\n+    for (int i = startingId; i < endingId; i++) {\n+      exampleRegion.put(\"\" + i, new Portfolio(i));\n+    }\n+  }\n+\n+  private ClientCache createClientCache(Integer locator1Port) {\n+    ClientCacheFactory ccf = new ClientCacheFactory();\n+    ccf.addPoolLocator(\"localhost\", locator1Port);\n+    ccf.setPoolSubscriptionEnabled(true);\n+    return ccf.create();\n+  }\n+\n+  private void checkActiveCqCount(MemberVM vm, int expectedResult) {\n+    vm.invoke(() -> {\n+      QueryService queryService = getCache().getQueryService();\n+      CqServiceStatistics cqServiceStats = queryService.getCqStatistics();\n+      await()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e15cda98297d2c705c19d67733360784df43a31"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM4NjQ0OA==", "bodyText": "Please provide a timeout. I tested it with timeout(30, TimeUnit.SECONDS). This way, this test will terminate in a \"reasonable\" time.", "url": "https://github.com/apache/geode/pull/5620#discussion_r516386448", "createdAt": "2020-11-03T01:41:31Z", "author": {"login": "kohlmu-pivotal"}, "path": "geode-cq/src/distributedTest/java/org/apache/geode/cache/query/cq/CQMetricsDUnitTest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.cache.query.cq;\n+\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.rules.ClusterStartupRule.getCache;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.Serializable;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.client.ClientCache;\n+import org.apache.geode.cache.client.ClientCacheFactory;\n+import org.apache.geode.cache.client.ClientRegionShortcut;\n+import org.apache.geode.cache.query.CqAttributes;\n+import org.apache.geode.cache.query.CqAttributesFactory;\n+import org.apache.geode.cache.query.CqEvent;\n+import org.apache.geode.cache.query.CqListener;\n+import org.apache.geode.cache.query.CqServiceStatistics;\n+import org.apache.geode.cache.query.QueryService;\n+import org.apache.geode.cache.query.data.Portfolio;\n+import org.apache.geode.management.DistributedSystemMXBean;\n+import org.apache.geode.management.ManagementService;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.rules.GfshCommandRule;\n+\n+public class CQMetricsDUnitTest {\n+\n+  private CqAttributes cqa;\n+  private QueryService qs;\n+  private TestCqListener testListener;\n+  private MemberVM locator, server1, server2;\n+\n+  @Rule\n+  public ClusterStartupRule cluster = new ClusterStartupRule(5);\n+\n+  @Rule\n+  public GfshCommandRule gfsh = new GfshCommandRule();\n+\n+  @Before\n+  public void setUpServers() throws Exception {\n+    locator = cluster.startLocatorVM(0, l -> l.withoutClusterConfigurationService());\n+    server1 = cluster.startServerVM(1, locator.getPort());\n+    server2 = cluster.startServerVM(2, locator.getPort());\n+\n+    ClientCache clientCache = createClientCache(locator.getPort());\n+    Region region =\n+        clientCache.createClientRegionFactory(ClientRegionShortcut.CACHING_PROXY).create(\"region\");\n+\n+    qs = clientCache.getQueryService();\n+    CqAttributesFactory cqaf = new CqAttributesFactory();\n+    testListener = new TestCqListener();\n+    cqaf.addCqListener(testListener);\n+\n+    cqa = cqaf.create();\n+    gfsh.connectAndVerify(locator);\n+  }\n+\n+  @Test\n+  public void testStopCq() throws Exception {\n+    gfsh.executeAndAssertThat(\"create region --name=region --type=PARTITION\")\n+        .statusIsSuccess();\n+    qs.newCq(\"Select * from /region r where r.ID = 1\", cqa).execute();\n+\n+    server1.invoke(() -> populateRegion(0, 100));\n+\n+    locator.invoke(() -> {\n+      Cache cache = getCache();\n+      ManagementService service = ManagementService.getManagementService(cache);\n+      DistributedSystemMXBean dsmbean = service.getDistributedSystemMXBean();\n+      await().untilAsserted(() -> assertThat(dsmbean.getActiveCQCount()).isEqualTo(2));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e15cda98297d2c705c19d67733360784df43a31"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM4NjQ3Nw==", "bodyText": "Please provide a timeout. I tested it with timeout(30, TimeUnit.SECONDS). This way, this test will terminate in a \"reasonable\" time.", "url": "https://github.com/apache/geode/pull/5620#discussion_r516386477", "createdAt": "2020-11-03T01:41:36Z", "author": {"login": "kohlmu-pivotal"}, "path": "geode-cq/src/distributedTest/java/org/apache/geode/cache/query/cq/CQMetricsDUnitTest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.cache.query.cq;\n+\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.rules.ClusterStartupRule.getCache;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.Serializable;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.client.ClientCache;\n+import org.apache.geode.cache.client.ClientCacheFactory;\n+import org.apache.geode.cache.client.ClientRegionShortcut;\n+import org.apache.geode.cache.query.CqAttributes;\n+import org.apache.geode.cache.query.CqAttributesFactory;\n+import org.apache.geode.cache.query.CqEvent;\n+import org.apache.geode.cache.query.CqListener;\n+import org.apache.geode.cache.query.CqServiceStatistics;\n+import org.apache.geode.cache.query.QueryService;\n+import org.apache.geode.cache.query.data.Portfolio;\n+import org.apache.geode.management.DistributedSystemMXBean;\n+import org.apache.geode.management.ManagementService;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.rules.GfshCommandRule;\n+\n+public class CQMetricsDUnitTest {\n+\n+  private CqAttributes cqa;\n+  private QueryService qs;\n+  private TestCqListener testListener;\n+  private MemberVM locator, server1, server2;\n+\n+  @Rule\n+  public ClusterStartupRule cluster = new ClusterStartupRule(5);\n+\n+  @Rule\n+  public GfshCommandRule gfsh = new GfshCommandRule();\n+\n+  @Before\n+  public void setUpServers() throws Exception {\n+    locator = cluster.startLocatorVM(0, l -> l.withoutClusterConfigurationService());\n+    server1 = cluster.startServerVM(1, locator.getPort());\n+    server2 = cluster.startServerVM(2, locator.getPort());\n+\n+    ClientCache clientCache = createClientCache(locator.getPort());\n+    Region region =\n+        clientCache.createClientRegionFactory(ClientRegionShortcut.CACHING_PROXY).create(\"region\");\n+\n+    qs = clientCache.getQueryService();\n+    CqAttributesFactory cqaf = new CqAttributesFactory();\n+    testListener = new TestCqListener();\n+    cqaf.addCqListener(testListener);\n+\n+    cqa = cqaf.create();\n+    gfsh.connectAndVerify(locator);\n+  }\n+\n+  @Test\n+  public void testStopCq() throws Exception {\n+    gfsh.executeAndAssertThat(\"create region --name=region --type=PARTITION\")\n+        .statusIsSuccess();\n+    qs.newCq(\"Select * from /region r where r.ID = 1\", cqa).execute();\n+\n+    server1.invoke(() -> populateRegion(0, 100));\n+\n+    locator.invoke(() -> {\n+      Cache cache = getCache();\n+      ManagementService service = ManagementService.getManagementService(cache);\n+      DistributedSystemMXBean dsmbean = service.getDistributedSystemMXBean();\n+      await().untilAsserted(() -> assertThat(dsmbean.getActiveCQCount()).isEqualTo(2));\n+    });\n+\n+    // stop cq\n+    qs.stopCqs();\n+\n+    locator.invoke(() -> {\n+      Cache cache = getCache();\n+      ManagementService service = ManagementService.getManagementService(cache);\n+      DistributedSystemMXBean dsmbean = service.getDistributedSystemMXBean();\n+      await().untilAsserted(() -> assertThat(dsmbean.getActiveCQCount()).isEqualTo(0));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e15cda98297d2c705c19d67733360784df43a31"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM4NjgxMA==", "bodyText": "Please rename ccn to cacheClientNotifier... Just small changes to increase the code cleanliness.", "url": "https://github.com/apache/geode/pull/5620#discussion_r516386810", "createdAt": "2020-11-03T01:43:09Z", "author": {"login": "kohlmu-pivotal"}, "path": "geode-cq/src/main/java/org/apache/geode/cache/query/cq/internal/ServerCQImpl.java", "diffHunk": "@@ -203,7 +203,7 @@ public void registerCq(ClientProxyMembershipID p_clientProxyId, CacheClientNotif\n     this.updateCqCreateStats();\n \n     // Initialize the state of CQ.\n-    if (this.cqState.getState() != p_cqState) {\n+    if (this.cqState.getState() != p_cqState || ccn == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e15cda98297d2c705c19d67733360784df43a31"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85a1c975b590c10d1bfeadb65b9b2948cd673eec", "author": {"user": {"login": "mkevo", "name": "Mario Kevo"}}, "url": "https://github.com/apache/geode/commit/85a1c975b590c10d1bfeadb65b9b2948cd673eec", "committedDate": "2020-11-03T06:46:01Z", "message": "add small changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyOTQ1NDYz", "url": "https://github.com/apache/geode/pull/5620#pullrequestreview-522945463", "createdAt": "2020-11-03T23:23:37Z", "commit": {"oid": "85a1c975b590c10d1bfeadb65b9b2948cd673eec"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMzoyMzozN1rOHtD_gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMzoyMzozN1rOHtD_gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAxMzM3OQ==", "bodyText": "Please use longer variable names", "url": "https://github.com/apache/geode/pull/5620#discussion_r517013379", "createdAt": "2020-11-03T23:23:37Z", "author": {"login": "kohlmu-pivotal"}, "path": "geode-cq/src/distributedTest/java/org/apache/geode/cache/query/cq/CQMetricsDUnitTest.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.cache.query.cq;\n+\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.rules.ClusterStartupRule.getCache;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.Serializable;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.client.ClientCache;\n+import org.apache.geode.cache.client.ClientCacheFactory;\n+import org.apache.geode.cache.client.ClientRegionShortcut;\n+import org.apache.geode.cache.query.CqAttributes;\n+import org.apache.geode.cache.query.CqAttributesFactory;\n+import org.apache.geode.cache.query.CqEvent;\n+import org.apache.geode.cache.query.CqListener;\n+import org.apache.geode.cache.query.CqServiceStatistics;\n+import org.apache.geode.cache.query.QueryService;\n+import org.apache.geode.cache.query.data.Portfolio;\n+import org.apache.geode.management.DistributedSystemMXBean;\n+import org.apache.geode.management.ManagementService;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.rules.GfshCommandRule;\n+\n+public class CQMetricsDUnitTest {\n+\n+  private CqAttributes cqa;\n+  private QueryService qs;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85a1c975b590c10d1bfeadb65b9b2948cd673eec"}, "originalPosition": 49}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29cdef6c3d5af1e66f9cc7fb1417b5112cb5b505", "author": {"user": {"login": "mkevo", "name": "Mario Kevo"}}, "url": "https://github.com/apache/geode/commit/29cdef6c3d5af1e66f9cc7fb1417b5112cb5b505", "committedDate": "2020-11-04T10:32:46Z", "message": "change variable names in test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4NTIxNjY1", "url": "https://github.com/apache/geode/pull/5620#pullrequestreview-528521665", "createdAt": "2020-11-11T20:46:24Z", "commit": {"oid": "29cdef6c3d5af1e66f9cc7fb1417b5112cb5b505"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4098, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}