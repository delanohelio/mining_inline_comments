{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcyNTU2NDUw", "number": 4682, "title": "GEODE-7778: Add PUBLISH, SUBSCRIBE and UNSUBSCRIBE Redis commands", "bodyText": "Redis PUBLISH/SUBSCRIBE is described here: https://redis.io/topics/pubsub\nThis implementation introduces 3 new command classes to support this:\nSubscribeExecutor, PublishExecutor and UnsubscribeExecutor. At a high\nlevel, the flow is as follows:\n\nA Redis client issues a SUBSCRIBE command. The server maintains a list of\nsubscribed clients and associate channel(s) in the Subscribers class. A\nsubscribed Client uses Netty's notion of a uniqueID to identify itself\nuniquely.\nWhen a client PUBLISHes a message on a channel, the publish 'event' uses an\nonMembers function call to distribute the channel/message to all members.\nEach member then publishes the message to any Clients registered on the\nchannel.\n\nPoints to note:\nRedis pub/sub is not HA. i.e. A subscriber only receives those messages\npublished after it has successfully subscribed. If the client is disconnected\nand reconnects, it will not receive messages published during the disconnect\nwindow.\nWhen clients subscribe, an open connection is established to the server and the\nclient blocks waiting for messages.\nThis implementation does not require messages to be published on the same\nserver to which the clients, executing subscribe, are connected since the\npublished message is distributed to all servers.\nCo-authored-by: Jens Deppe jdeppe@pivotal.io\nCo-authored-by: Prasath Durairaj vdurairaj@pivotal.io\nCo-authored-by: Murtuza Boxwala mboxwala@pivotal.io\nCo-authored-by: Sarah Abbey sabbey@pivotal.io\nCo-authored-by: John Hutchison jhutchison@pivotal.io\nCo-authored-by: Ray Ingles ringles@pivotal.io\nThank you for submitting a contribution to Apache Geode.\nIn order to streamline the review of the contribution we ask you\nto ensure the following steps have been taken:\nFor all changes:\n\n\n Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?\n\n\n Has your PR been rebased against the latest commit within the target branch (typically develop)?\n\n\n Is your initial contribution a single, squashed commit?\n\n\n Does gradlew build run cleanly?\n\n\n Have you written or updated unit tests to verify your changes?\n\n\n If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under ASF 2.0?\n\n\nNote:\nPlease ensure that once the PR is submitted, check Concourse for build issues and\nsubmit an update to your PR as soon as possible. If you need help, please send an\nemail to dev@geode.apache.org.", "createdAt": "2020-02-07T19:06:58Z", "url": "https://github.com/apache/geode/pull/4682", "merged": true, "mergeCommit": {"oid": "d3ecaaafd7b08c667c1a7a4eb36060ea560b0347"}, "closed": true, "closedAt": "2020-02-12T22:12:28Z", "author": {"login": "sabbey37"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcCFNkygH2gAyMzcyNTU2NDUwOmQ4OTI0YTgxMDUyOTQyODZmYzM4Y2I2ZjJhOGU2MDJkZjUxMjM4MmU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcDtv7aAFqTM1NzgyMjk4Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e", "author": {"user": {"login": "prettyClouds", "name": "Murtuza Boxwala"}}, "url": "https://github.com/apache/geode/commit/d8924a8105294286fc38cb6f2a8e602df512382e", "committedDate": "2020-02-07T20:18:17Z", "message": "GEODE-7778: Add PUBLISH, SUBSCRIBE and UNSUBSCRIBE Redis commands\n\nCo-authored-by: Jens Deppe <jdeppe@pivotal.io>\nCo-authored-by: Prasath Durairaj <vdurairaj@pivotal.io>\nCo-authored-by: Murtuza Boxwala <mboxwala@pivotal.io>\nCo-authored-by: Sarah Abbey <sabbey@pivotal.io>\nCo-authored-by: John Hutchison <jhutchison@pivotal.io>\nCo-authored-by: Ray Ingles <ringles@pivotal.io>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c5e448d02b9569f0cb1c356d0878cdb17f9bbec4", "author": {"user": {"login": "prettyClouds", "name": "Murtuza Boxwala"}}, "url": "https://github.com/apache/geode/commit/c5e448d02b9569f0cb1c356d0878cdb17f9bbec4", "committedDate": "2020-02-07T18:58:47Z", "message": "GEODE-7778: Add PUBLISH, SUBSCRIBE and UNSUBSCRIBE Redis commands\n\nCo-authored-by: Jens Deppe <jdeppe@pivotal.io>\nCo-authored-by: Prasath Durairaj <vdurairaj@pivotal.io>\nCo-authored-by: Murtuza Boxwala <mboxwala@pivotal.io>\nCo-authored-by: Sarah Abbey <sabbey@pivotal.io>\nCo-authored-by: John Hutchison <jhutchison@pivotal.io>\nCo-authored-by: Ray Ingles <ringles@pivotal.io>"}, "afterCommit": {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e", "author": {"user": {"login": "prettyClouds", "name": "Murtuza Boxwala"}}, "url": "https://github.com/apache/geode/commit/d8924a8105294286fc38cb6f2a8e602df512382e", "committedDate": "2020-02-07T20:18:17Z", "message": "GEODE-7778: Add PUBLISH, SUBSCRIBE and UNSUBSCRIBE Redis commands\n\nCo-authored-by: Jens Deppe <jdeppe@pivotal.io>\nCo-authored-by: Prasath Durairaj <vdurairaj@pivotal.io>\nCo-authored-by: Murtuza Boxwala <mboxwala@pivotal.io>\nCo-authored-by: Sarah Abbey <sabbey@pivotal.io>\nCo-authored-by: John Hutchison <jhutchison@pivotal.io>\nCo-authored-by: Ray Ingles <ringles@pivotal.io>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MjUxMTIy", "url": "https://github.com/apache/geode/pull/4682#pullrequestreview-356251122", "createdAt": "2020-02-10T20:47:59Z", "commit": {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MzIyNjgz", "url": "https://github.com/apache/geode/pull/4682#pullrequestreview-356322683", "createdAt": "2020-02-10T22:49:10Z", "commit": {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MjYyNzk4", "url": "https://github.com/apache/geode/pull/4682#pullrequestreview-356262798", "createdAt": "2020-02-10T21:06:22Z", "commit": {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 30, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMTowNjoyMlrOFn1jTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMzowMDoyMlrOFn4wPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMxNjE3Mg==", "bodyText": "Does this mean that every RedisAdapter will have a PubSub instance, even if it is not required?", "url": "https://github.com/apache/geode/pull/4682#discussion_r377316172", "createdAt": "2020-02-10T21:06:22Z", "author": {"login": "kohlmu-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/ExecutionHandlerContext.java", "diffHunk": "@@ -86,6 +88,11 @@ public KeyRegistrar getKeyRegistrar() {\n   }\n \n   private KeyRegistrar keyRegistrar;\n+  private PubSub pubSub;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMxNjgyNw==", "bodyText": "Why would this not be an Interface? Then at least there is the ability that one could have another implementation of this, without tightly coupling the code.", "url": "https://github.com/apache/geode/pull/4682#discussion_r377316827", "createdAt": "2020-02-10T21:07:44Z", "author": {"login": "kohlmu-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.apache.geode.redis.internal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.FunctionContext;\n+import org.apache.geode.cache.execute.FunctionService;\n+import org.apache.geode.cache.execute.ResultCollector;\n+\n+public class PubSub {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMxOTE5Mw==", "bodyText": "Is this timeout an SLA or just best guess? What happens if a message takes 2s to send, is that bad? Maybe a timeout that can be either configured or maybe a little more lenient?", "url": "https://github.com/apache/geode/pull/4682#discussion_r377319193", "createdAt": "2020-02-10T21:12:40Z", "author": {"login": "kohlmu-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/Subscriber.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.apache.geode.redis.internal;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+\n+class Subscriber {\n+  public final Client client;\n+  public final String channel;\n+  private ExecutionHandlerContext context;\n+\n+  public Subscriber(Client client, String channel,\n+      ExecutionHandlerContext context) {\n+\n+    this.client = client;\n+    this.channel = channel;\n+    this.context = context;\n+  }\n+\n+  public boolean isEqualTo(String channel, Client client) {\n+    return channel.equals(this.channel) && client.equals(this.client);\n+  }\n+\n+  public boolean publishMessage(String channel, String message) {\n+    ByteBuf messageByteBuffer;\n+    try {\n+      messageByteBuffer = Coder.getArrayResponse(context.getByteBufAllocator(),\n+          Arrays.asList(\"message\", channel, message));\n+    } catch (CoderException e) {\n+      throw new RuntimeException(e);\n+    }\n+\n+    CountDownLatch latch = new CountDownLatch(1);\n+\n+    ChannelFutureListener channelFutureListener = future -> latch.countDown();\n+\n+    ChannelFuture channelFuture =\n+        context.writeToChannelWithListener(messageByteBuffer, channelFutureListener);\n+\n+    try {\n+      latch.await(1, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMyMDg2Nw==", "bodyText": "what is s here? I don't have an IDE to tell me what this is supposed to be", "url": "https://github.com/apache/geode/pull/4682#discussion_r377320867", "createdAt": "2020-02-10T21:16:16Z", "author": {"login": "kohlmu-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.apache.geode.redis.internal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.FunctionContext;\n+import org.apache.geode.cache.execute.FunctionService;\n+import org.apache.geode.cache.execute.ResultCollector;\n+\n+public class PubSub {\n+  public static final String REDIS_PUB_SUB_FUNCTION_ID = \"redisPubSubFunctionID\";\n+\n+  Subscribers subscribers = new Subscribers();\n+\n+  public long publish(String channel, String message) {\n+    ResultCollector<?, ?> subscriberCountCollector = FunctionService\n+        .onMembers()\n+        .setArguments(new String[] {channel, message})\n+        .execute(REDIS_PUB_SUB_FUNCTION_ID);\n+\n+    List<Long> subscriberCounts = (List<Long>) subscriberCountCollector.getResult();\n+    long totalSubscribers = 0;\n+    for (long subscriberCount : subscriberCounts) {\n+      totalSubscribers += subscriberCount;\n+    }\n+    return totalSubscribers;\n+  }\n+\n+  public long subscribe(String channel, ExecutionHandlerContext context, Client client) {\n+    if (subscribers.exists(channel, client)) {\n+      return subscribers.findSubscribers(client).size();\n+    }\n+    Subscriber subscriber = new Subscriber(client, channel, context);\n+    subscribers.add(subscriber);\n+    return subscribers.findSubscribers(client).size();\n+  }\n+\n+  public void registerPublishFunction() {\n+    FunctionService.registerFunction(new Function() {\n+      @Override\n+      public String getId() {\n+        return REDIS_PUB_SUB_FUNCTION_ID;\n+      }\n+\n+      @Override\n+      public void execute(FunctionContext context) {\n+        String[] publishMessage = (String[]) context.getArguments();\n+        long subscriberCount = publishMessageToSubscribers(publishMessage[0], publishMessage[1]);\n+        context.getResultSender().lastResult(subscriberCount);\n+      }\n+    });\n+  }\n+\n+  public long unsubscribe(String channel, Client client) {\n+    this.subscribers.remove(channel, client);\n+    return this.subscribers.findSubscribers(client).size();\n+  }\n+\n+  private long publishMessageToSubscribers(String channel, String message) {\n+    Map<Boolean, List<Subscriber>> results = this.subscribers\n+        .findSubscribers(channel)\n+        .stream()\n+        .collect(Collectors.partitioningBy(s -> s.publishMessage(channel, message)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMyMTEwOQ==", "bodyText": "s = subscriber?", "url": "https://github.com/apache/geode/pull/4682#discussion_r377321109", "createdAt": "2020-02-10T21:16:44Z", "author": {"login": "kohlmu-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.apache.geode.redis.internal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.FunctionContext;\n+import org.apache.geode.cache.execute.FunctionService;\n+import org.apache.geode.cache.execute.ResultCollector;\n+\n+public class PubSub {\n+  public static final String REDIS_PUB_SUB_FUNCTION_ID = \"redisPubSubFunctionID\";\n+\n+  Subscribers subscribers = new Subscribers();\n+\n+  public long publish(String channel, String message) {\n+    ResultCollector<?, ?> subscriberCountCollector = FunctionService\n+        .onMembers()\n+        .setArguments(new String[] {channel, message})\n+        .execute(REDIS_PUB_SUB_FUNCTION_ID);\n+\n+    List<Long> subscriberCounts = (List<Long>) subscriberCountCollector.getResult();\n+    long totalSubscribers = 0;\n+    for (long subscriberCount : subscriberCounts) {\n+      totalSubscribers += subscriberCount;\n+    }\n+    return totalSubscribers;\n+  }\n+\n+  public long subscribe(String channel, ExecutionHandlerContext context, Client client) {\n+    if (subscribers.exists(channel, client)) {\n+      return subscribers.findSubscribers(client).size();\n+    }\n+    Subscriber subscriber = new Subscriber(client, channel, context);\n+    subscribers.add(subscriber);\n+    return subscribers.findSubscribers(client).size();\n+  }\n+\n+  public void registerPublishFunction() {\n+    FunctionService.registerFunction(new Function() {\n+      @Override\n+      public String getId() {\n+        return REDIS_PUB_SUB_FUNCTION_ID;\n+      }\n+\n+      @Override\n+      public void execute(FunctionContext context) {\n+        String[] publishMessage = (String[]) context.getArguments();\n+        long subscriberCount = publishMessageToSubscribers(publishMessage[0], publishMessage[1]);\n+        context.getResultSender().lastResult(subscriberCount);\n+      }\n+    });\n+  }\n+\n+  public long unsubscribe(String channel, Client client) {\n+    this.subscribers.remove(channel, client);\n+    return this.subscribers.findSubscribers(client).size();\n+  }\n+\n+  private long publishMessageToSubscribers(String channel, String message) {\n+    Map<Boolean, List<Subscriber>> results = this.subscribers\n+        .findSubscribers(channel)\n+        .stream()\n+        .collect(Collectors.partitioningBy(s -> s.publishMessage(channel, message)));\n+\n+    prune(results.get(false));\n+\n+    return results.get(true).size();\n+  }\n+\n+  private void prune(List<Subscriber> failedSubscribers) {\n+    failedSubscribers.forEach(subscriber -> {\n+      if (subscriber.client.isDead()) {\n+        subscribers.remove(subscriber.client);\n+      }\n+    });\n+  }\n+\n+  private class Subscribers {\n+    List<Subscriber> subscribers = new ArrayList<>();\n+\n+    private boolean exists(String channel, Client client) {\n+      return subscribers.stream().anyMatch((s) -> s.isEqualTo(channel, client));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMyMTE1Nw==", "bodyText": "s = subscriber?", "url": "https://github.com/apache/geode/pull/4682#discussion_r377321157", "createdAt": "2020-02-10T21:16:51Z", "author": {"login": "kohlmu-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.apache.geode.redis.internal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.FunctionContext;\n+import org.apache.geode.cache.execute.FunctionService;\n+import org.apache.geode.cache.execute.ResultCollector;\n+\n+public class PubSub {\n+  public static final String REDIS_PUB_SUB_FUNCTION_ID = \"redisPubSubFunctionID\";\n+\n+  Subscribers subscribers = new Subscribers();\n+\n+  public long publish(String channel, String message) {\n+    ResultCollector<?, ?> subscriberCountCollector = FunctionService\n+        .onMembers()\n+        .setArguments(new String[] {channel, message})\n+        .execute(REDIS_PUB_SUB_FUNCTION_ID);\n+\n+    List<Long> subscriberCounts = (List<Long>) subscriberCountCollector.getResult();\n+    long totalSubscribers = 0;\n+    for (long subscriberCount : subscriberCounts) {\n+      totalSubscribers += subscriberCount;\n+    }\n+    return totalSubscribers;\n+  }\n+\n+  public long subscribe(String channel, ExecutionHandlerContext context, Client client) {\n+    if (subscribers.exists(channel, client)) {\n+      return subscribers.findSubscribers(client).size();\n+    }\n+    Subscriber subscriber = new Subscriber(client, channel, context);\n+    subscribers.add(subscriber);\n+    return subscribers.findSubscribers(client).size();\n+  }\n+\n+  public void registerPublishFunction() {\n+    FunctionService.registerFunction(new Function() {\n+      @Override\n+      public String getId() {\n+        return REDIS_PUB_SUB_FUNCTION_ID;\n+      }\n+\n+      @Override\n+      public void execute(FunctionContext context) {\n+        String[] publishMessage = (String[]) context.getArguments();\n+        long subscriberCount = publishMessageToSubscribers(publishMessage[0], publishMessage[1]);\n+        context.getResultSender().lastResult(subscriberCount);\n+      }\n+    });\n+  }\n+\n+  public long unsubscribe(String channel, Client client) {\n+    this.subscribers.remove(channel, client);\n+    return this.subscribers.findSubscribers(client).size();\n+  }\n+\n+  private long publishMessageToSubscribers(String channel, String message) {\n+    Map<Boolean, List<Subscriber>> results = this.subscribers\n+        .findSubscribers(channel)\n+        .stream()\n+        .collect(Collectors.partitioningBy(s -> s.publishMessage(channel, message)));\n+\n+    prune(results.get(false));\n+\n+    return results.get(true).size();\n+  }\n+\n+  private void prune(List<Subscriber> failedSubscribers) {\n+    failedSubscribers.forEach(subscriber -> {\n+      if (subscriber.client.isDead()) {\n+        subscribers.remove(subscriber.client);\n+      }\n+    });\n+  }\n+\n+  private class Subscribers {\n+    List<Subscriber> subscribers = new ArrayList<>();\n+\n+    private boolean exists(String channel, Client client) {\n+      return subscribers.stream().anyMatch((s) -> s.isEqualTo(channel, client));\n+    }\n+\n+    private List<Subscriber> findSubscribers(Client client) {\n+      return subscribers.stream().filter((s) -> s.client.equals(client))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMyMTE4OQ==", "bodyText": "s = subscriber?", "url": "https://github.com/apache/geode/pull/4682#discussion_r377321189", "createdAt": "2020-02-10T21:16:56Z", "author": {"login": "kohlmu-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.apache.geode.redis.internal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.FunctionContext;\n+import org.apache.geode.cache.execute.FunctionService;\n+import org.apache.geode.cache.execute.ResultCollector;\n+\n+public class PubSub {\n+  public static final String REDIS_PUB_SUB_FUNCTION_ID = \"redisPubSubFunctionID\";\n+\n+  Subscribers subscribers = new Subscribers();\n+\n+  public long publish(String channel, String message) {\n+    ResultCollector<?, ?> subscriberCountCollector = FunctionService\n+        .onMembers()\n+        .setArguments(new String[] {channel, message})\n+        .execute(REDIS_PUB_SUB_FUNCTION_ID);\n+\n+    List<Long> subscriberCounts = (List<Long>) subscriberCountCollector.getResult();\n+    long totalSubscribers = 0;\n+    for (long subscriberCount : subscriberCounts) {\n+      totalSubscribers += subscriberCount;\n+    }\n+    return totalSubscribers;\n+  }\n+\n+  public long subscribe(String channel, ExecutionHandlerContext context, Client client) {\n+    if (subscribers.exists(channel, client)) {\n+      return subscribers.findSubscribers(client).size();\n+    }\n+    Subscriber subscriber = new Subscriber(client, channel, context);\n+    subscribers.add(subscriber);\n+    return subscribers.findSubscribers(client).size();\n+  }\n+\n+  public void registerPublishFunction() {\n+    FunctionService.registerFunction(new Function() {\n+      @Override\n+      public String getId() {\n+        return REDIS_PUB_SUB_FUNCTION_ID;\n+      }\n+\n+      @Override\n+      public void execute(FunctionContext context) {\n+        String[] publishMessage = (String[]) context.getArguments();\n+        long subscriberCount = publishMessageToSubscribers(publishMessage[0], publishMessage[1]);\n+        context.getResultSender().lastResult(subscriberCount);\n+      }\n+    });\n+  }\n+\n+  public long unsubscribe(String channel, Client client) {\n+    this.subscribers.remove(channel, client);\n+    return this.subscribers.findSubscribers(client).size();\n+  }\n+\n+  private long publishMessageToSubscribers(String channel, String message) {\n+    Map<Boolean, List<Subscriber>> results = this.subscribers\n+        .findSubscribers(channel)\n+        .stream()\n+        .collect(Collectors.partitioningBy(s -> s.publishMessage(channel, message)));\n+\n+    prune(results.get(false));\n+\n+    return results.get(true).size();\n+  }\n+\n+  private void prune(List<Subscriber> failedSubscribers) {\n+    failedSubscribers.forEach(subscriber -> {\n+      if (subscriber.client.isDead()) {\n+        subscribers.remove(subscriber.client);\n+      }\n+    });\n+  }\n+\n+  private class Subscribers {\n+    List<Subscriber> subscribers = new ArrayList<>();\n+\n+    private boolean exists(String channel, Client client) {\n+      return subscribers.stream().anyMatch((s) -> s.isEqualTo(channel, client));\n+    }\n+\n+    private List<Subscriber> findSubscribers(Client client) {\n+      return subscribers.stream().filter((s) -> s.client.equals(client))\n+          .collect(Collectors.toList());\n+    }\n+\n+    private List<Subscriber> findSubscribers(String channel) {\n+      return subscribers.stream().filter((s) -> s.channel.equals(channel))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMyMTU0MQ==", "bodyText": "Seems we are lacking some consistency... Here we specifically name the param subscriber, but higher up we just call it s", "url": "https://github.com/apache/geode/pull/4682#discussion_r377321541", "createdAt": "2020-02-10T21:17:43Z", "author": {"login": "kohlmu-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.apache.geode.redis.internal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.FunctionContext;\n+import org.apache.geode.cache.execute.FunctionService;\n+import org.apache.geode.cache.execute.ResultCollector;\n+\n+public class PubSub {\n+  public static final String REDIS_PUB_SUB_FUNCTION_ID = \"redisPubSubFunctionID\";\n+\n+  Subscribers subscribers = new Subscribers();\n+\n+  public long publish(String channel, String message) {\n+    ResultCollector<?, ?> subscriberCountCollector = FunctionService\n+        .onMembers()\n+        .setArguments(new String[] {channel, message})\n+        .execute(REDIS_PUB_SUB_FUNCTION_ID);\n+\n+    List<Long> subscriberCounts = (List<Long>) subscriberCountCollector.getResult();\n+    long totalSubscribers = 0;\n+    for (long subscriberCount : subscriberCounts) {\n+      totalSubscribers += subscriberCount;\n+    }\n+    return totalSubscribers;\n+  }\n+\n+  public long subscribe(String channel, ExecutionHandlerContext context, Client client) {\n+    if (subscribers.exists(channel, client)) {\n+      return subscribers.findSubscribers(client).size();\n+    }\n+    Subscriber subscriber = new Subscriber(client, channel, context);\n+    subscribers.add(subscriber);\n+    return subscribers.findSubscribers(client).size();\n+  }\n+\n+  public void registerPublishFunction() {\n+    FunctionService.registerFunction(new Function() {\n+      @Override\n+      public String getId() {\n+        return REDIS_PUB_SUB_FUNCTION_ID;\n+      }\n+\n+      @Override\n+      public void execute(FunctionContext context) {\n+        String[] publishMessage = (String[]) context.getArguments();\n+        long subscriberCount = publishMessageToSubscribers(publishMessage[0], publishMessage[1]);\n+        context.getResultSender().lastResult(subscriberCount);\n+      }\n+    });\n+  }\n+\n+  public long unsubscribe(String channel, Client client) {\n+    this.subscribers.remove(channel, client);\n+    return this.subscribers.findSubscribers(client).size();\n+  }\n+\n+  private long publishMessageToSubscribers(String channel, String message) {\n+    Map<Boolean, List<Subscriber>> results = this.subscribers\n+        .findSubscribers(channel)\n+        .stream()\n+        .collect(Collectors.partitioningBy(s -> s.publishMessage(channel, message)));\n+\n+    prune(results.get(false));\n+\n+    return results.get(true).size();\n+  }\n+\n+  private void prune(List<Subscriber> failedSubscribers) {\n+    failedSubscribers.forEach(subscriber -> {\n+      if (subscriber.client.isDead()) {\n+        subscribers.remove(subscriber.client);\n+      }\n+    });\n+  }\n+\n+  private class Subscribers {\n+    List<Subscriber> subscribers = new ArrayList<>();\n+\n+    private boolean exists(String channel, Client client) {\n+      return subscribers.stream().anyMatch((s) -> s.isEqualTo(channel, client));\n+    }\n+\n+    private List<Subscriber> findSubscribers(Client client) {\n+      return subscribers.stream().filter((s) -> s.client.equals(client))\n+          .collect(Collectors.toList());\n+    }\n+\n+    private List<Subscriber> findSubscribers(String channel) {\n+      return subscribers.stream().filter((s) -> s.channel.equals(channel))\n+          .collect(Collectors.toList());\n+    }\n+\n+    public void add(Subscriber subscriber) {\n+      this.subscribers.add(subscriber);\n+    }\n+\n+    public void remove(String channel, Client client) {\n+      this.subscribers.removeIf((subscriber) -> subscriber.isEqualTo(channel, client));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMyMjA5Mw==", "bodyText": "Maybe some JavaDoc here.. what is this class and why do we care....", "url": "https://github.com/apache/geode/pull/4682#discussion_r377322093", "createdAt": "2020-02-10T21:18:55Z", "author": {"login": "kohlmu-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.apache.geode.redis.internal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.FunctionContext;\n+import org.apache.geode.cache.execute.FunctionService;\n+import org.apache.geode.cache.execute.ResultCollector;\n+\n+public class PubSub {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMyNjE0OA==", "bodyText": "Why not a LinkedList if every operation is a \"iterate\" over all entries. No benefit to using ArrayList if you don't use the indexing or ordering.", "url": "https://github.com/apache/geode/pull/4682#discussion_r377326148", "createdAt": "2020-02-10T21:27:27Z", "author": {"login": "kohlmu-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.apache.geode.redis.internal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.FunctionContext;\n+import org.apache.geode.cache.execute.FunctionService;\n+import org.apache.geode.cache.execute.ResultCollector;\n+\n+public class PubSub {\n+  public static final String REDIS_PUB_SUB_FUNCTION_ID = \"redisPubSubFunctionID\";\n+\n+  Subscribers subscribers = new Subscribers();\n+\n+  public long publish(String channel, String message) {\n+    ResultCollector<?, ?> subscriberCountCollector = FunctionService\n+        .onMembers()\n+        .setArguments(new String[] {channel, message})\n+        .execute(REDIS_PUB_SUB_FUNCTION_ID);\n+\n+    List<Long> subscriberCounts = (List<Long>) subscriberCountCollector.getResult();\n+    long totalSubscribers = 0;\n+    for (long subscriberCount : subscriberCounts) {\n+      totalSubscribers += subscriberCount;\n+    }\n+    return totalSubscribers;\n+  }\n+\n+  public long subscribe(String channel, ExecutionHandlerContext context, Client client) {\n+    if (subscribers.exists(channel, client)) {\n+      return subscribers.findSubscribers(client).size();\n+    }\n+    Subscriber subscriber = new Subscriber(client, channel, context);\n+    subscribers.add(subscriber);\n+    return subscribers.findSubscribers(client).size();\n+  }\n+\n+  public void registerPublishFunction() {\n+    FunctionService.registerFunction(new Function() {\n+      @Override\n+      public String getId() {\n+        return REDIS_PUB_SUB_FUNCTION_ID;\n+      }\n+\n+      @Override\n+      public void execute(FunctionContext context) {\n+        String[] publishMessage = (String[]) context.getArguments();\n+        long subscriberCount = publishMessageToSubscribers(publishMessage[0], publishMessage[1]);\n+        context.getResultSender().lastResult(subscriberCount);\n+      }\n+    });\n+  }\n+\n+  public long unsubscribe(String channel, Client client) {\n+    this.subscribers.remove(channel, client);\n+    return this.subscribers.findSubscribers(client).size();\n+  }\n+\n+  private long publishMessageToSubscribers(String channel, String message) {\n+    Map<Boolean, List<Subscriber>> results = this.subscribers\n+        .findSubscribers(channel)\n+        .stream()\n+        .collect(Collectors.partitioningBy(s -> s.publishMessage(channel, message)));\n+\n+    prune(results.get(false));\n+\n+    return results.get(true).size();\n+  }\n+\n+  private void prune(List<Subscriber> failedSubscribers) {\n+    failedSubscribers.forEach(subscriber -> {\n+      if (subscriber.client.isDead()) {\n+        subscribers.remove(subscriber.client);\n+      }\n+    });\n+  }\n+\n+  private class Subscribers {\n+    List<Subscriber> subscribers = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMzNjY4Mg==", "bodyText": "I wonder if one should expose the PubSub world here... maybe have the context have a publish method, which then delegates to the internal PubSub. To me it is a little like feature envy... Where instead of having the ExecutionHandlerContext handle the publish, we first have to know that there is a PubSub and then ask it to do work  -- https://refactoring.guru/smells/feature-envy", "url": "https://github.com/apache/geode/pull/4682#discussion_r377336682", "createdAt": "2020-02-10T21:49:02Z", "author": {"login": "kohlmu-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/pubsub/PublishExecutor.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis.internal.executor.pubsub;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+import org.apache.geode.redis.internal.Coder;\n+import org.apache.geode.redis.internal.Command;\n+import org.apache.geode.redis.internal.ExecutionHandlerContext;\n+import org.apache.geode.redis.internal.Executor;\n+\n+public class PublishExecutor implements Executor {\n+  @Override\n+  public void executeCommand(Command command, ExecutionHandlerContext context) {\n+    byte[] channelName = command.getProcessedCommand().get(1);\n+    byte[] message = command.getProcessedCommand().get(2);\n+    long publishCount = context.getPubSub().publish(new String(channelName), new String(message));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMzNzI2Mw==", "bodyText": "See same comment on the PublishExecutor. I don't think we should expose the PubSub here.", "url": "https://github.com/apache/geode/pull/4682#discussion_r377337263", "createdAt": "2020-02-10T21:50:17Z", "author": {"login": "kohlmu-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/pubsub/SubscribeExecutor.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis.internal.executor.pubsub;\n+\n+import java.util.ArrayList;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+import org.apache.geode.redis.internal.Coder;\n+import org.apache.geode.redis.internal.CoderException;\n+import org.apache.geode.redis.internal.Command;\n+import org.apache.geode.redis.internal.ExecutionHandlerContext;\n+import org.apache.geode.redis.internal.executor.AbstractExecutor;\n+\n+public class SubscribeExecutor extends AbstractExecutor {\n+\n+  @Override\n+  public void executeCommand(Command command, ExecutionHandlerContext context) {\n+    ArrayList<ArrayList<Object>> items = new ArrayList<>();\n+    for (int i = 1; i < command.getProcessedCommand().size(); i++) {\n+      ArrayList<Object> item = new ArrayList<>();\n+      byte[] channelName = command.getProcessedCommand().get(i);\n+      long subscribedChannels =\n+          context.getPubSub().subscribe(new String(channelName), context, context.getClient());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMzNzU5OQ==", "bodyText": "See above in PublishExecutor and SubscribeExecutor", "url": "https://github.com/apache/geode/pull/4682#discussion_r377337599", "createdAt": "2020-02-10T21:50:59Z", "author": {"login": "kohlmu-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/pubsub/UnsubscribeExecutor.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis.internal.executor.pubsub;\n+\n+import java.util.ArrayList;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+import org.apache.geode.redis.internal.Coder;\n+import org.apache.geode.redis.internal.CoderException;\n+import org.apache.geode.redis.internal.Command;\n+import org.apache.geode.redis.internal.ExecutionHandlerContext;\n+import org.apache.geode.redis.internal.executor.AbstractExecutor;\n+\n+public class UnsubscribeExecutor extends AbstractExecutor {\n+\n+  @Override\n+  public void executeCommand(Command command, ExecutionHandlerContext context) {\n+    byte[] channelName = command.getProcessedCommand().get(1);\n+    long subscriptionCount =\n+        context.getPubSub().unsubscribe(new String(channelName), context.getClient());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMzNzgxMg==", "bodyText": "Maybe have a logger?", "url": "https://github.com/apache/geode/pull/4682#discussion_r377337812", "createdAt": "2020-02-10T21:51:26Z", "author": {"login": "kohlmu-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/pubsub/UnsubscribeExecutor.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis.internal.executor.pubsub;\n+\n+import java.util.ArrayList;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+import org.apache.geode.redis.internal.Coder;\n+import org.apache.geode.redis.internal.CoderException;\n+import org.apache.geode.redis.internal.Command;\n+import org.apache.geode.redis.internal.ExecutionHandlerContext;\n+import org.apache.geode.redis.internal.executor.AbstractExecutor;\n+\n+public class UnsubscribeExecutor extends AbstractExecutor {\n+\n+  @Override\n+  public void executeCommand(Command command, ExecutionHandlerContext context) {\n+    byte[] channelName = command.getProcessedCommand().get(1);\n+    long subscriptionCount =\n+        context.getPubSub().unsubscribe(new String(channelName), context.getClient());\n+\n+    ArrayList<Object> items = new ArrayList<>();\n+    items.add(\"unsubscribe\");\n+    items.add(channelName);\n+    items.add(subscriptionCount);\n+    ByteBuf response = null;\n+    try {\n+      response = Coder.getArrayResponse(context.getByteBufAllocator(), items);\n+    } catch (CoderException e) {\n+      e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMzNzkyNQ==", "bodyText": "Maybe have a logger?", "url": "https://github.com/apache/geode/pull/4682#discussion_r377337925", "createdAt": "2020-02-10T21:51:37Z", "author": {"login": "kohlmu-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/pubsub/SubscribeExecutor.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis.internal.executor.pubsub;\n+\n+import java.util.ArrayList;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+import org.apache.geode.redis.internal.Coder;\n+import org.apache.geode.redis.internal.CoderException;\n+import org.apache.geode.redis.internal.Command;\n+import org.apache.geode.redis.internal.ExecutionHandlerContext;\n+import org.apache.geode.redis.internal.executor.AbstractExecutor;\n+\n+public class SubscribeExecutor extends AbstractExecutor {\n+\n+  @Override\n+  public void executeCommand(Command command, ExecutionHandlerContext context) {\n+    ArrayList<ArrayList<Object>> items = new ArrayList<>();\n+    for (int i = 1; i < command.getProcessedCommand().size(); i++) {\n+      ArrayList<Object> item = new ArrayList<>();\n+      byte[] channelName = command.getProcessedCommand().get(i);\n+      long subscribedChannels =\n+          context.getPubSub().subscribe(new String(channelName), context, context.getClient());\n+\n+      item.add(\"subscribe\");\n+      item.add(channelName);\n+      item.add(subscribedChannels);\n+\n+      items.add(item);\n+    }\n+\n+    writeResponse(command, context, items);\n+  }\n+\n+  private void writeResponse(Command command, ExecutionHandlerContext context,\n+      ArrayList<ArrayList<Object>> items) {\n+    ByteBuf bigResponse = context.getByteBufAllocator().buffer();\n+    items.forEach(item -> {\n+      ByteBuf response = null;\n+      try {\n+        response = Coder.getArrayResponse(context.getByteBufAllocator(), item);\n+      } catch (CoderException e) {\n+        e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMzOTA3Mg==", "bodyText": "Maybe add Comparable onto the class. Then one does not have to go outside of \"standard\" Java conventions, but creating a isEqualTo method", "url": "https://github.com/apache/geode/pull/4682#discussion_r377339072", "createdAt": "2020-02-10T21:53:55Z", "author": {"login": "kohlmu-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/Subscriber.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.apache.geode.redis.internal;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+\n+class Subscriber {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMzOTQzMw==", "bodyText": "Is this thread safe?", "url": "https://github.com/apache/geode/pull/4682#discussion_r377339433", "createdAt": "2020-02-10T21:54:41Z", "author": {"login": "kohlmu-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/RedisCommandType.java", "diffHunk": "@@ -2595,6 +2598,69 @@ public RedisDataType getDataType() {\n     }\n   },\n \n+  /***************************************\n+   ********** Publish Subscribe **********\n+   ***************************************/\n+  /**\n+   * SUBSCRIBE channel...\n+   * <p>\n+   * subscribe to channel\n+   */\n+  SUBSCRIBE {\n+    private Executor executor;\n+\n+    @Override\n+    public Executor getExecutor() {\n+      if (executor == null) {\n+        executor = new SubscribeExecutor();\n+      }\n+      return executor;\n+    }\n+\n+    private final RedisDataType dataType = RedisDataType.REDIS_PUBSUB;\n+\n+    @Override\n+    public RedisDataType getDataType() {\n+      return this.dataType;\n+    }\n+  },\n+  PUBLISH {\n+    private Executor executor;\n+\n+    @Override\n+    public Executor getExecutor() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMzOTQ2OA==", "bodyText": "Is this thread safe?", "url": "https://github.com/apache/geode/pull/4682#discussion_r377339468", "createdAt": "2020-02-10T21:54:45Z", "author": {"login": "kohlmu-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/RedisCommandType.java", "diffHunk": "@@ -2595,6 +2598,69 @@ public RedisDataType getDataType() {\n     }\n   },\n \n+  /***************************************\n+   ********** Publish Subscribe **********\n+   ***************************************/\n+  /**\n+   * SUBSCRIBE channel...\n+   * <p>\n+   * subscribe to channel\n+   */\n+  SUBSCRIBE {\n+    private Executor executor;\n+\n+    @Override\n+    public Executor getExecutor() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMzOTUyMA==", "bodyText": "Is this thread safe?", "url": "https://github.com/apache/geode/pull/4682#discussion_r377339520", "createdAt": "2020-02-10T21:54:52Z", "author": {"login": "kohlmu-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/RedisCommandType.java", "diffHunk": "@@ -2595,6 +2598,69 @@ public RedisDataType getDataType() {\n     }\n   },\n \n+  /***************************************\n+   ********** Publish Subscribe **********\n+   ***************************************/\n+  /**\n+   * SUBSCRIBE channel...\n+   * <p>\n+   * subscribe to channel\n+   */\n+  SUBSCRIBE {\n+    private Executor executor;\n+\n+    @Override\n+    public Executor getExecutor() {\n+      if (executor == null) {\n+        executor = new SubscribeExecutor();\n+      }\n+      return executor;\n+    }\n+\n+    private final RedisDataType dataType = RedisDataType.REDIS_PUBSUB;\n+\n+    @Override\n+    public RedisDataType getDataType() {\n+      return this.dataType;\n+    }\n+  },\n+  PUBLISH {\n+    private Executor executor;\n+\n+    @Override\n+    public Executor getExecutor() {\n+      if (executor == null) {\n+        executor = new PublishExecutor();\n+      }\n+      return executor;\n+    }\n+\n+    private final RedisDataType dataType = RedisDataType.REDIS_PUBSUB;\n+\n+    @Override\n+    public RedisDataType getDataType() {\n+      return this.dataType;\n+    }\n+  },\n+  UNSUBSCRIBE {\n+    private Executor executor;\n+\n+    @Override\n+    public Executor getExecutor() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM0MDE5NQ==", "bodyText": "Maybe make this final, if you are going through all the effort of constructor initialization and private", "url": "https://github.com/apache/geode/pull/4682#discussion_r377340195", "createdAt": "2020-02-10T21:56:19Z", "author": {"login": "kohlmu-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/ExecutionHandlerContext.java", "diffHunk": "@@ -86,6 +88,11 @@ public KeyRegistrar getKeyRegistrar() {\n   }\n \n   private KeyRegistrar keyRegistrar;\n+  private PubSub pubSub;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM1MTg0Mw==", "bodyText": "Maybe treat the final String.valueof(d) as the else then at least it seams one have thought of all the combinations.", "url": "https://github.com/apache/geode/pull/4682#discussion_r377351843", "createdAt": "2020-02-10T22:21:14Z", "author": {"login": "kohlmu-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/Coder.java", "diffHunk": "@@ -436,16 +452,18 @@ public static String bytesToString(byte[] bytes) {\n   }\n \n   public static String doubleToString(double d) {\n-    if (d == Double.POSITIVE_INFINITY)\n+    if (d == Double.POSITIVE_INFINITY) {\n       return \"Infinity\";\n-    else if (d == Double.NEGATIVE_INFINITY)\n+    } else if (d == Double.NEGATIVE_INFINITY) {\n       return \"-Infinity\";\n+    }\n     return String.valueOf(d);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM1MTkzNg==", "bodyText": "What about strings with \"whitespaces\"?", "url": "https://github.com/apache/geode/pull/4682#discussion_r377351936", "createdAt": "2020-02-10T22:21:27Z", "author": {"login": "kohlmu-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/Coder.java", "diffHunk": "@@ -436,16 +452,18 @@ public static String bytesToString(byte[] bytes) {\n   }\n \n   public static String doubleToString(double d) {\n-    if (d == Double.POSITIVE_INFINITY)\n+    if (d == Double.POSITIVE_INFINITY) {\n       return \"Infinity\";\n-    else if (d == Double.NEGATIVE_INFINITY)\n+    } else if (d == Double.NEGATIVE_INFINITY) {\n       return \"-Infinity\";\n+    }\n     return String.valueOf(d);\n   }\n \n   public static byte[] stringToBytes(String string) {\n-    if (string == null || string.equals(\"\"))\n+    if (string == null || string.equals(\"\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM1NDc4OA==", "bodyText": "Why do we need to expose the PubSub externally?", "url": "https://github.com/apache/geode/pull/4682#discussion_r377354788", "createdAt": "2020-02-10T22:27:41Z", "author": {"login": "kohlmu-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/ExecutionHandlerContext.java", "diffHunk": "@@ -86,6 +88,11 @@ public KeyRegistrar getKeyRegistrar() {\n   }\n \n   private KeyRegistrar keyRegistrar;\n+  private PubSub pubSub;\n+\n+  public PubSub getPubSub() {\n+    return pubSub;\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM2MTU3OQ==", "bodyText": "why is this package protected and not private? or even private final?", "url": "https://github.com/apache/geode/pull/4682#discussion_r377361579", "createdAt": "2020-02-10T22:43:21Z", "author": {"login": "kohlmu-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.apache.geode.redis.internal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.FunctionContext;\n+import org.apache.geode.cache.execute.FunctionService;\n+import org.apache.geode.cache.execute.ResultCollector;\n+\n+public class PubSub {\n+  public static final String REDIS_PUB_SUB_FUNCTION_ID = \"redisPubSubFunctionID\";\n+\n+  Subscribers subscribers = new Subscribers();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM2MjA3OA==", "bodyText": "Everywhere where there are collections, streams are used. Why not here? Why not a collect function? Consistency...", "url": "https://github.com/apache/geode/pull/4682#discussion_r377362078", "createdAt": "2020-02-10T22:44:25Z", "author": {"login": "kohlmu-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.apache.geode.redis.internal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.FunctionContext;\n+import org.apache.geode.cache.execute.FunctionService;\n+import org.apache.geode.cache.execute.ResultCollector;\n+\n+public class PubSub {\n+  public static final String REDIS_PUB_SUB_FUNCTION_ID = \"redisPubSubFunctionID\";\n+\n+  Subscribers subscribers = new Subscribers();\n+\n+  public long publish(String channel, String message) {\n+    ResultCollector<?, ?> subscriberCountCollector = FunctionService\n+        .onMembers()\n+        .setArguments(new String[] {channel, message})\n+        .execute(REDIS_PUB_SUB_FUNCTION_ID);\n+\n+    List<Long> subscriberCounts = (List<Long>) subscriberCountCollector.getResult();\n+    long totalSubscribers = 0;\n+    for (long subscriberCount : subscriberCounts) {\n+      totalSubscribers += subscriberCount;\n+    }\n+    return totalSubscribers;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM2MjYzNg==", "bodyText": "I think this might be a little fragile. What happens if there are NOT 2 entries or even 0... What if there are no arguments and it is null?", "url": "https://github.com/apache/geode/pull/4682#discussion_r377362636", "createdAt": "2020-02-10T22:45:54Z", "author": {"login": "kohlmu-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.apache.geode.redis.internal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.FunctionContext;\n+import org.apache.geode.cache.execute.FunctionService;\n+import org.apache.geode.cache.execute.ResultCollector;\n+\n+public class PubSub {\n+  public static final String REDIS_PUB_SUB_FUNCTION_ID = \"redisPubSubFunctionID\";\n+\n+  Subscribers subscribers = new Subscribers();\n+\n+  public long publish(String channel, String message) {\n+    ResultCollector<?, ?> subscriberCountCollector = FunctionService\n+        .onMembers()\n+        .setArguments(new String[] {channel, message})\n+        .execute(REDIS_PUB_SUB_FUNCTION_ID);\n+\n+    List<Long> subscriberCounts = (List<Long>) subscriberCountCollector.getResult();\n+    long totalSubscribers = 0;\n+    for (long subscriberCount : subscriberCounts) {\n+      totalSubscribers += subscriberCount;\n+    }\n+    return totalSubscribers;\n+  }\n+\n+  public long subscribe(String channel, ExecutionHandlerContext context, Client client) {\n+    if (subscribers.exists(channel, client)) {\n+      return subscribers.findSubscribers(client).size();\n+    }\n+    Subscriber subscriber = new Subscriber(client, channel, context);\n+    subscribers.add(subscriber);\n+    return subscribers.findSubscribers(client).size();\n+  }\n+\n+  public void registerPublishFunction() {\n+    FunctionService.registerFunction(new Function() {\n+      @Override\n+      public String getId() {\n+        return REDIS_PUB_SUB_FUNCTION_ID;\n+      }\n+\n+      @Override\n+      public void execute(FunctionContext context) {\n+        String[] publishMessage = (String[]) context.getArguments();\n+        long subscriberCount = publishMessageToSubscribers(publishMessage[0], publishMessage[1]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM2NTAxMw==", "bodyText": "Why explicitly call registerPublishFunction if this can be done inside the constructor? Why is this method even required?", "url": "https://github.com/apache/geode/pull/4682#discussion_r377365013", "createdAt": "2020-02-10T22:51:27Z", "author": {"login": "kohlmu-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/GeodeRedisServer.java", "diffHunk": "@@ -730,4 +740,11 @@ private static String getLogLevel(String arg) {\n     }\n     return logLevel;\n   }\n+\n+  private PubSub createPubSub() {\n+    PubSub pubSub = new PubSub();\n+    pubSub.registerPublishFunction();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM2NTcxNw==", "bodyText": "This initialization could have been done on line 263, where the field is declared.", "url": "https://github.com/apache/geode/pull/4682#discussion_r377365717", "createdAt": "2020-02-10T22:53:06Z", "author": {"login": "kohlmu-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/GeodeRedisServer.java", "diffHunk": "@@ -446,6 +449,7 @@ private void initializeRedis() {\n         throw assErr;\n       }\n       this.keyRegistrar = new KeyRegistrar(redisMetaData);\n+      this.pubSub = createPubSub();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM2ODA0Ng==", "bodyText": "This is very inefficient. First iterate over all subscribers to see if there is a match. Then iterate over all subscribers again to return a count. Maybe one can findSubscribers if count = 0 then add other wise return count", "url": "https://github.com/apache/geode/pull/4682#discussion_r377368046", "createdAt": "2020-02-10T22:58:49Z", "author": {"login": "kohlmu-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.apache.geode.redis.internal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.FunctionContext;\n+import org.apache.geode.cache.execute.FunctionService;\n+import org.apache.geode.cache.execute.ResultCollector;\n+\n+public class PubSub {\n+  public static final String REDIS_PUB_SUB_FUNCTION_ID = \"redisPubSubFunctionID\";\n+\n+  Subscribers subscribers = new Subscribers();\n+\n+  public long publish(String channel, String message) {\n+    ResultCollector<?, ?> subscriberCountCollector = FunctionService\n+        .onMembers()\n+        .setArguments(new String[] {channel, message})\n+        .execute(REDIS_PUB_SUB_FUNCTION_ID);\n+\n+    List<Long> subscriberCounts = (List<Long>) subscriberCountCollector.getResult();\n+    long totalSubscribers = 0;\n+    for (long subscriberCount : subscriberCounts) {\n+      totalSubscribers += subscriberCount;\n+    }\n+    return totalSubscribers;\n+  }\n+\n+  public long subscribe(String channel, ExecutionHandlerContext context, Client client) {\n+    if (subscribers.exists(channel, client)) {\n+      return subscribers.findSubscribers(client).size();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM2ODYzOA==", "bodyText": "Are we concerned about thread safety here or not? Because, if we would have done a count of all subscribers before adding, then we don't have to iterate all subscribers again just to in all reality do previousCount + 1", "url": "https://github.com/apache/geode/pull/4682#discussion_r377368638", "createdAt": "2020-02-10T23:00:22Z", "author": {"login": "kohlmu-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/PubSub.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.apache.geode.redis.internal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.FunctionContext;\n+import org.apache.geode.cache.execute.FunctionService;\n+import org.apache.geode.cache.execute.ResultCollector;\n+\n+public class PubSub {\n+  public static final String REDIS_PUB_SUB_FUNCTION_ID = \"redisPubSubFunctionID\";\n+\n+  Subscribers subscribers = new Subscribers();\n+\n+  public long publish(String channel, String message) {\n+    ResultCollector<?, ?> subscriberCountCollector = FunctionService\n+        .onMembers()\n+        .setArguments(new String[] {channel, message})\n+        .execute(REDIS_PUB_SUB_FUNCTION_ID);\n+\n+    List<Long> subscriberCounts = (List<Long>) subscriberCountCollector.getResult();\n+    long totalSubscribers = 0;\n+    for (long subscriberCount : subscriberCounts) {\n+      totalSubscribers += subscriberCount;\n+    }\n+    return totalSubscribers;\n+  }\n+\n+  public long subscribe(String channel, ExecutionHandlerContext context, Client client) {\n+    if (subscribers.exists(channel, client)) {\n+      return subscribers.findSubscribers(client).size();\n+    }\n+    Subscriber subscriber = new Subscriber(client, channel, context);\n+    subscribers.add(subscriber);\n+    return subscribers.findSubscribers(client).size();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MzI5MDk4", "url": "https://github.com/apache/geode/pull/4682#pullrequestreview-356329098", "createdAt": "2020-02-10T23:02:30Z", "commit": {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2ODQxMDg5", "url": "https://github.com/apache/geode/pull/4682#pullrequestreview-356841089", "createdAt": "2020-02-11T17:14:49Z", "commit": {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNzoxNDo0OVrOFoRttQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNzoxNDo0OVrOFoRttQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3NzU4OQ==", "bodyText": "There is no null checking happening. Can we really assume that the input channel and client are non-null?", "url": "https://github.com/apache/geode/pull/4682#discussion_r377777589", "createdAt": "2020-02-11T17:14:49Z", "author": {"login": "kohlmu-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/Subscriber.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.apache.geode.redis.internal;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+\n+class Subscriber {\n+  public final Client client;\n+  public final String channel;\n+  private ExecutionHandlerContext context;\n+\n+  public Subscriber(Client client, String channel,\n+      ExecutionHandlerContext context) {\n+\n+    this.client = client;\n+    this.channel = channel;\n+    this.context = context;\n+  }\n+\n+  public boolean isEqualTo(String channel, Client client) {\n+    return channel.equals(this.channel) && client.equals(this.client);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e"}, "originalPosition": 41}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2ODQyODc2", "url": "https://github.com/apache/geode/pull/4682#pullrequestreview-356842876", "createdAt": "2020-02-11T17:17:13Z", "commit": {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNzoxNzoxM1rOFoRy8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNzoxNzoxM1rOFoRy8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3ODkyOA==", "bodyText": "Would we not prefer a checked exception here?", "url": "https://github.com/apache/geode/pull/4682#discussion_r377778928", "createdAt": "2020-02-11T17:17:13Z", "author": {"login": "kohlmu-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/Subscriber.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.apache.geode.redis.internal;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+\n+class Subscriber {\n+  public final Client client;\n+  public final String channel;\n+  private ExecutionHandlerContext context;\n+\n+  public Subscriber(Client client, String channel,\n+      ExecutionHandlerContext context) {\n+\n+    this.client = client;\n+    this.channel = channel;\n+    this.context = context;\n+  }\n+\n+  public boolean isEqualTo(String channel, Client client) {\n+    return channel.equals(this.channel) && client.equals(this.client);\n+  }\n+\n+  public boolean publishMessage(String channel, String message) {\n+    ByteBuf messageByteBuffer;\n+    try {\n+      messageByteBuffer = Coder.getArrayResponse(context.getByteBufAllocator(),\n+          Arrays.asList(\"message\", channel, message));\n+    } catch (CoderException e) {\n+      throw new RuntimeException(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8924a8105294286fc38cb6f2a8e602df512382e"}, "originalPosition": 50}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "547191f996beea67696b13d926b9d7fbbf55e932", "author": {"user": {"login": "jdeppe-pivotal", "name": "Jens Deppe"}}, "url": "https://github.com/apache/geode/commit/547191f996beea67696b13d926b9d7fbbf55e932", "committedDate": "2020-02-11T19:19:11Z", "message": "Address review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35b874e592ad485ab3000bcf2c685cd2086b6941", "author": {"user": {"login": "jdeppe-pivotal", "name": "Jens Deppe"}}, "url": "https://github.com/apache/geode/commit/35b874e592ad485ab3000bcf2c685cd2086b6941", "committedDate": "2020-02-11T19:26:29Z", "message": "More review updates"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c8288e0fb38289a1fe6a8b36c1a1348fb3e0b75d", "author": {"user": {"login": "jdeppe-pivotal", "name": "Jens Deppe"}}, "url": "https://github.com/apache/geode/commit/c8288e0fb38289a1fe6a8b36c1a1348fb3e0b75d", "committedDate": "2020-02-11T22:58:34Z", "message": "Add validation to publish call"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a07a25fb88692daadb37b0caef2e9da2454faa7a", "author": {"user": {"login": "jdeppe-pivotal", "name": "Jens Deppe"}}, "url": "https://github.com/apache/geode/commit/a07a25fb88692daadb37b0caef2e9da2454faa7a", "committedDate": "2020-02-12T16:23:29Z", "message": "Change PubSub to an interface"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0eaf5c7e151dae6d5d6574e459d62bf5046cf76b", "author": {"user": {"login": "jdeppe-pivotal", "name": "Jens Deppe"}}, "url": "https://github.com/apache/geode/commit/0eaf5c7e151dae6d5d6574e459d62bf5046cf76b", "committedDate": "2020-02-12T16:45:48Z", "message": "Make pub/sub fn registration internal"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3NjIzNjAz", "url": "https://github.com/apache/geode/pull/4682#pullrequestreview-357623603", "createdAt": "2020-02-12T16:58:12Z", "commit": {"oid": "0eaf5c7e151dae6d5d6574e459d62bf5046cf76b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxNjo1ODoxM1rOFo2vCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxNjo1ODoxM1rOFo2vCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM4NDEzOA==", "bodyText": "Feature envy. Can we please change.", "url": "https://github.com/apache/geode/pull/4682#discussion_r378384138", "createdAt": "2020-02-12T16:58:13Z", "author": {"login": "kohlmu-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/pubsub/PublishExecutor.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis.internal.executor.pubsub;\n+\n+import java.util.List;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+import org.apache.geode.redis.internal.Coder;\n+import org.apache.geode.redis.internal.Command;\n+import org.apache.geode.redis.internal.ExecutionHandlerContext;\n+import org.apache.geode.redis.internal.Executor;\n+import org.apache.geode.redis.internal.RedisConstants.ArityDef;\n+\n+public class PublishExecutor implements Executor {\n+\n+\n+  @Override\n+  public void executeCommand(Command command, ExecutionHandlerContext context) {\n+    List<byte[]> args = command.getProcessedCommand();\n+    if (args.size() != 3) {\n+      command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(), ArityDef.PUBLISH));\n+      return;\n+    }\n+\n+    String channelName = new String(args.get(1));\n+    String message = new String(args.get(2));\n+    long publishCount = context.getPubSub().publish(channelName, message);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0eaf5c7e151dae6d5d6574e459d62bf5046cf76b"}, "originalPosition": 41}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3ODIyOTgz", "url": "https://github.com/apache/geode/pull/4682#pullrequestreview-357822983", "createdAt": "2020-02-12T22:05:56Z", "commit": {"oid": "0eaf5c7e151dae6d5d6574e459d62bf5046cf76b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3765, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}