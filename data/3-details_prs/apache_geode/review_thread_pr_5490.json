{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc2NTE4NDE5", "number": 5490, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMzoxNzo0MVrOEehGfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMzoxNzo0MVrOEehGfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNDM1MDY5OnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/GemFireCacheImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMzoxNzo0MVrOHKNZDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMzoxNzo0MVrOHKNZDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ2NzIxMw==", "bodyText": "I guess it's ok to not rethrow the Throwable here. saveConfg() is called from two places in GMSMembership:\n\nManagerImpl.forceDisconnect()\nrequestMemberRemoval()\n\nIn both those cases it looks like setDisableAutoReconnect(true) will set us on a permanent shutdown path. Since we've logged the Throwable here we've fulfilled our obligation to inform the operator.", "url": "https://github.com/apache/geode/pull/5490#discussion_r480467213", "createdAt": "2020-08-31T23:17:41Z", "author": {"login": "Bill"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/GemFireCacheImpl.java", "diffHunk": "@@ -1177,34 +1178,53 @@ public MeterRegistry getMeterRegistry() {\n \n   @Override\n   public void saveCacheXmlForReconnect() {\n-    // there are two versions of this method so it can be unit-tested\n-    boolean sharedConfigEnabled = getDistributionManager().getConfig().getUseSharedConfiguration();\n+    prepareForReconnect((pw) -> CacheXmlGenerator.generate((Cache) this, pw, false));\n+  }\n \n-    if (!Boolean.getBoolean(GEMFIRE_PREFIX + \"autoReconnect-useCacheXMLFile\")\n-        && !sharedConfigEnabled) {\n-      try {\n-        logger.info(\"generating XML to rebuild the cache after reconnect completes\");\n-        StringPrintWriter pw = new StringPrintWriter();\n-        CacheXmlGenerator.generate((Cache) this, pw, false);\n-        String cacheXML = pw.toString();\n-        getCacheConfig().setCacheXMLDescription(cacheXML);\n-        logger.info(\"XML generation completed: {}\", cacheXML);\n-      } catch (CancelException e) {\n-        logger.info(\"Unable to generate XML description for reconnect of cache due to exception\",\n-            e);\n-      }\n-    } else if (sharedConfigEnabled && !getCacheServers().isEmpty()) {\n-      // we need to retain a cache-server description if this JVM was started by gfsh\n-      List<CacheServerCreation> list = new ArrayList<>(getCacheServers().size());\n-      for (Object o : getCacheServers()) {\n-        CacheServerImpl cs = (CacheServerImpl) o;\n-        if (cs.isDefaultServer()) {\n-          CacheServerCreation bsc = new CacheServerCreation(this, cs);\n-          list.add(bsc);\n+\n+  /**\n+   * Testable version of saveCacheXmlForReconnect() that allows us to inject an XML generator\n+   *\n+   * @param xmlGenerator a consumer of a PrintWriter that generates a description of the Cache\n+   */\n+  protected void prepareForReconnect(Consumer<PrintWriter> xmlGenerator) {\n+    boolean sharedConfigEnabled =\n+        getInternalDistributedSystem().getConfig().getUseSharedConfiguration();\n+\n+    try {\n+      if (!Boolean.getBoolean(GEMFIRE_PREFIX + \"autoReconnect-useCacheXMLFile\")\n+          && !sharedConfigEnabled) {\n+        try {\n+          logger.info(\"generating XML to rebuild the cache after reconnect completes\");\n+          StringPrintWriter pw = new StringPrintWriter();\n+          xmlGenerator.accept(pw);\n+          String cacheXML = pw.toString();\n+          getCacheConfig().setCacheXMLDescription(cacheXML);\n+          logger.info(\"XML generation completed: {}\", cacheXML);\n+        } catch (CancelException e) {\n+          logger.info(\"Unable to generate XML description for reconnect of cache due to exception\",\n+              e);\n         }\n+      } else if (sharedConfigEnabled && !getCacheServers().isEmpty()) {\n+        // we need to retain a cache-server description if this JVM was started by gfsh\n+        logger.info(\"saving cache server configuration for use with the cluster-configuration \"\n+            + \"service on reconnect\");\n+        List<CacheServerCreation> list = new ArrayList<>(getCacheServers().size());\n+        for (Object o : getCacheServers()) {\n+          CacheServerImpl cs = (CacheServerImpl) o;\n+          if (cs.isDefaultServer()) {\n+            CacheServerCreation bsc = new CacheServerCreation(this, cs);\n+            list.add(bsc);\n+          }\n+        }\n+        getCacheConfig().setCacheServerCreation(list);\n+        logger.info(\"cache server configuration saved\");\n       }\n-      getCacheConfig().setCacheServerCreation(list);\n-      logger.info(\"CacheServer configuration saved\");\n+    } catch (Throwable throwable) {\n+      logger.info(\"Saving of cache configuration for auto-reconnect has failed.  \"\n+          + \"Auto-reconnect will be disabled since the cache cannot be rebuilt.\", throwable);\n+      getInternalDistributedSystem().getConfig().setDisableAutoReconnect(true);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fa7e3f3965e6c449cbb1982e092eba0f594eec2"}, "originalPosition": 83}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4764, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}