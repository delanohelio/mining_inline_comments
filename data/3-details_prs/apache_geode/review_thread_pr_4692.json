{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc0MTMyOTY5", "number": 4692, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxNzozNDo0NlrODf9w_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQyMjozODo1MVrODgCYgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0ODQ0NDEzOnYy", "diffSide": "RIGHT", "path": "geode-assembly/src/distributedTest/java/org/apache/geode/management/internal/rest/ClientClusterManagementServiceDunitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxNzozNDo0NlrOFp-TTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxOToyNzo1OVrOFqBRgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU1NjY4NA==", "bodyText": "why do we need this requireNonNull here?", "url": "https://github.com/apache/geode/pull/4692#discussion_r379556684", "createdAt": "2020-02-14T17:34:46Z", "author": {"login": "jinmeiliao"}, "path": "geode-assembly/src/distributedTest/java/org/apache/geode/management/internal/rest/ClientClusterManagementServiceDunitTest.java", "diffHunk": "@@ -115,7 +119,8 @@ public void createRegionWithGroup() {\n \n     locator.invoke(() -> {\n       InternalConfigurationPersistenceService persistenceService =\n-          ClusterStartupRule.getLocator().getConfigurationPersistenceService();\n+          Objects.requireNonNull(ClusterStartupRule.getLocator())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "640f1260965d3e9f0015f983880e94e5823081ba"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYwNTM3Ng==", "bodyText": "why do we need this requireNonNull here?\n\nIt's just to reduce the warnings you get in the code.", "url": "https://github.com/apache/geode/pull/4692#discussion_r379605376", "createdAt": "2020-02-14T19:27:59Z", "author": {"login": "jmelchio"}, "path": "geode-assembly/src/distributedTest/java/org/apache/geode/management/internal/rest/ClientClusterManagementServiceDunitTest.java", "diffHunk": "@@ -115,7 +119,8 @@ public void createRegionWithGroup() {\n \n     locator.invoke(() -> {\n       InternalConfigurationPersistenceService persistenceService =\n-          ClusterStartupRule.getLocator().getConfigurationPersistenceService();\n+          Objects.requireNonNull(ClusterStartupRule.getLocator())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU1NjY4NA=="}, "originalCommit": {"oid": "640f1260965d3e9f0015f983880e94e5823081ba"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0ODYwNDU2OnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/RegionFactoryImpl.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxODozNTowOVrOFp_4nQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQyMDo1NjoxM1rOFqDbZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU4MjYyMQ==", "bodyText": "looks like this change is prompted by similar code in InternalConfigurationPersistenceService to create the internal region. Would be nice to change that code to use this method as well.", "url": "https://github.com/apache/geode/pull/4692#discussion_r379582621", "createdAt": "2020-02-14T18:35:09Z", "author": {"login": "jinmeiliao"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/RegionFactoryImpl.java", "diffHunk": "@@ -43,4 +53,22 @@ public RegionFactoryImpl(InternalCache cache, String regionAttributesId) {\n   public RegionFactoryImpl(RegionFactory<K, V> regionFactory) {\n     super(regionFactory);\n   }\n+\n+  public void setInternalRegionArguments(\n+      InternalRegionArguments internalRegionArguments) {\n+    this.internalRegionArguments = internalRegionArguments;\n+  }\n+\n+  @Override\n+  public Region<K, V> create(String name)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "640f1260965d3e9f0015f983880e94e5823081ba"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYwMjYxNQ==", "bodyText": "That is a good idea but I think we should do it in another pull request. I will file a refactor ticket about not using the deprecated AttributesFactory to create internal regions. So this PR introduces the new RegionFactoryImpl but will only use it in the new code in this PR. The other ticket can look for other places in the code (like the one you mention) that use deprecated apis to create internal regions.", "url": "https://github.com/apache/geode/pull/4692#discussion_r379602615", "createdAt": "2020-02-14T19:21:36Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/RegionFactoryImpl.java", "diffHunk": "@@ -43,4 +53,22 @@ public RegionFactoryImpl(InternalCache cache, String regionAttributesId) {\n   public RegionFactoryImpl(RegionFactory<K, V> regionFactory) {\n     super(regionFactory);\n   }\n+\n+  public void setInternalRegionArguments(\n+      InternalRegionArguments internalRegionArguments) {\n+    this.internalRegionArguments = internalRegionArguments;\n+  }\n+\n+  @Override\n+  public Region<K, V> create(String name)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU4MjYyMQ=="}, "originalCommit": {"oid": "640f1260965d3e9f0015f983880e94e5823081ba"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY0MDY3Ng==", "bodyText": "I filed: https://issues.apache.org/jira/browse/GEODE-7803 for this", "url": "https://github.com/apache/geode/pull/4692#discussion_r379640676", "createdAt": "2020-02-14T20:56:13Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/RegionFactoryImpl.java", "diffHunk": "@@ -43,4 +53,22 @@ public RegionFactoryImpl(InternalCache cache, String regionAttributesId) {\n   public RegionFactoryImpl(RegionFactory<K, V> regionFactory) {\n     super(regionFactory);\n   }\n+\n+  public void setInternalRegionArguments(\n+      InternalRegionArguments internalRegionArguments) {\n+    this.internalRegionArguments = internalRegionArguments;\n+  }\n+\n+  @Override\n+  public Region<K, V> create(String name)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU4MjYyMQ=="}, "originalCommit": {"oid": "640f1260965d3e9f0015f983880e94e5823081ba"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0ODYyNjcwOnYy", "diffSide": "RIGHT", "path": "geode-management/src/main/java/org/apache/geode/management/internal/ClusterManagementOperationStatusResult.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxODo0Mzo0MVrOFqAGzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxOToyMzo0M1rOFqBKVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU4NjI1Mw==", "bodyText": "looks like this is only used in the test now. Should be removed.", "url": "https://github.com/apache/geode/pull/4692#discussion_r379586253", "createdAt": "2020-02-14T18:43:41Z", "author": {"login": "jinmeiliao"}, "path": "geode-management/src/main/java/org/apache/geode/management/internal/ClusterManagementOperationStatusResult.java", "diffHunk": "@@ -23,6 +23,7 @@\n import org.apache.geode.management.runtime.OperationResult;\n \n @Experimental\n+// TODO can this class be removed?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "640f1260965d3e9f0015f983880e94e5823081ba"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYwMzU0Mw==", "bodyText": "Thanks for catching this! We intended to remove it but forgot to do so", "url": "https://github.com/apache/geode/pull/4692#discussion_r379603543", "createdAt": "2020-02-14T19:23:43Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-management/src/main/java/org/apache/geode/management/internal/ClusterManagementOperationStatusResult.java", "diffHunk": "@@ -23,6 +23,7 @@\n import org.apache.geode.management.runtime.OperationResult;\n \n @Experimental\n+// TODO can this class be removed?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU4NjI1Mw=="}, "originalCommit": {"oid": "640f1260965d3e9f0015f983880e94e5823081ba"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0ODY0ODkwOnYy", "diffSide": "RIGHT", "path": "geode-management/src/test/java/org/apache/geode/management/api/ClusterManagementOperationResultTest.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxODo1MjoyNlrOFqAVNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQwMDo1NzoyN1rOFqHR-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU4OTk0Mw==", "bodyText": "I am always not a fan of  \"Impl\" class. Wondering why we couldn't make RebalanceResult a concrete class directly.", "url": "https://github.com/apache/geode/pull/4692#discussion_r379589943", "createdAt": "2020-02-14T18:52:26Z", "author": {"login": "jinmeiliao"}, "path": "geode-management/src/test/java/org/apache/geode/management/api/ClusterManagementOperationResultTest.java", "diffHunk": "@@ -37,20 +39,32 @@ public void setUp() {\n \n   @Test\n   public void serialize() throws Exception {\n-    CompletableFuture<TestOperationResult> operationResult =\n-        new CompletableFuture<>();\n     ClusterManagementResult result1 = new ClusterManagementResult();\n     result1.setStatus(StatusCode.OK, \"Success!!\");\n-    ClusterManagementOperationResult<TestOperationResult> result =\n-        new ClusterManagementOperationResult<>(result1, operationResult, new Date(),\n-            new CompletableFuture<>(), \"operator\", \"id\");\n+    ClusterManagementOperationResult<ClusterManagementOperation<OperationResult>, OperationResult> result =\n+        new ClusterManagementOperationResult<>(result1, new Date(), new Date(),\n+            null, \"id\", null, null);\n     String json = mapper.writeValueAsString(result);\n     System.out.println(json);\n-    ClusterManagementOperationResult value =\n+    ClusterManagementOperationResult<ClusterManagementOperation<OperationResult>, OperationResult> value =\n         mapper.readValue(json, ClusterManagementOperationResult.class);\n     assertThat(value.getStatusMessage()).isEqualTo(\"Success!!\");\n   }\n \n-  static class TestOperationResult implements OperationResult {\n+  @Test\n+  public void serializeRebal() throws Exception {\n+    ClusterManagementResult result1 = new ClusterManagementResult();\n+    result1.setStatus(StatusCode.OK, \"Success!!\");\n+    RebalanceOperation rebalanceOperation = new RebalanceOperation();\n+    rebalanceOperation.setOperator(\"operator\");\n+    ClusterManagementOperationResult<RebalanceOperation, RebalanceResult> result =\n+        new ClusterManagementOperationResult(result1, new Date(), new Date(),\n+            rebalanceOperation, \"id\", new RebalanceResultImpl(), null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "640f1260965d3e9f0015f983880e94e5823081ba"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYxNDE2NQ==", "bodyText": "Yes, let us look at that. Agree that given that we're extending an interface already in RebalanceResult it makes sense to make RebalanceResult the implemenation.", "url": "https://github.com/apache/geode/pull/4692#discussion_r379614165", "createdAt": "2020-02-14T19:48:32Z", "author": {"login": "jmelchio"}, "path": "geode-management/src/test/java/org/apache/geode/management/api/ClusterManagementOperationResultTest.java", "diffHunk": "@@ -37,20 +39,32 @@ public void setUp() {\n \n   @Test\n   public void serialize() throws Exception {\n-    CompletableFuture<TestOperationResult> operationResult =\n-        new CompletableFuture<>();\n     ClusterManagementResult result1 = new ClusterManagementResult();\n     result1.setStatus(StatusCode.OK, \"Success!!\");\n-    ClusterManagementOperationResult<TestOperationResult> result =\n-        new ClusterManagementOperationResult<>(result1, operationResult, new Date(),\n-            new CompletableFuture<>(), \"operator\", \"id\");\n+    ClusterManagementOperationResult<ClusterManagementOperation<OperationResult>, OperationResult> result =\n+        new ClusterManagementOperationResult<>(result1, new Date(), new Date(),\n+            null, \"id\", null, null);\n     String json = mapper.writeValueAsString(result);\n     System.out.println(json);\n-    ClusterManagementOperationResult value =\n+    ClusterManagementOperationResult<ClusterManagementOperation<OperationResult>, OperationResult> value =\n         mapper.readValue(json, ClusterManagementOperationResult.class);\n     assertThat(value.getStatusMessage()).isEqualTo(\"Success!!\");\n   }\n \n-  static class TestOperationResult implements OperationResult {\n+  @Test\n+  public void serializeRebal() throws Exception {\n+    ClusterManagementResult result1 = new ClusterManagementResult();\n+    result1.setStatus(StatusCode.OK, \"Success!!\");\n+    RebalanceOperation rebalanceOperation = new RebalanceOperation();\n+    rebalanceOperation.setOperator(\"operator\");\n+    ClusterManagementOperationResult<RebalanceOperation, RebalanceResult> result =\n+        new ClusterManagementOperationResult(result1, new Date(), new Date(),\n+            rebalanceOperation, \"id\", new RebalanceResultImpl(), null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU4OTk0Mw=="}, "originalCommit": {"oid": "640f1260965d3e9f0015f983880e94e5823081ba"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYzNzYxNg==", "bodyText": "This PR did not introduce RebalanceResult nor RebalanceResultImpl.\nI prefer keeping the current interface and having an internal implementation class. This prevents our external apis from having internal things exposed. For example, in this case, the external api does not need a constructor nor settors.\nI think it would be good to have more of our external api contract defined by interfaces and try to minimize the number of classes in it.", "url": "https://github.com/apache/geode/pull/4692#discussion_r379637616", "createdAt": "2020-02-14T20:48:06Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-management/src/test/java/org/apache/geode/management/api/ClusterManagementOperationResultTest.java", "diffHunk": "@@ -37,20 +39,32 @@ public void setUp() {\n \n   @Test\n   public void serialize() throws Exception {\n-    CompletableFuture<TestOperationResult> operationResult =\n-        new CompletableFuture<>();\n     ClusterManagementResult result1 = new ClusterManagementResult();\n     result1.setStatus(StatusCode.OK, \"Success!!\");\n-    ClusterManagementOperationResult<TestOperationResult> result =\n-        new ClusterManagementOperationResult<>(result1, operationResult, new Date(),\n-            new CompletableFuture<>(), \"operator\", \"id\");\n+    ClusterManagementOperationResult<ClusterManagementOperation<OperationResult>, OperationResult> result =\n+        new ClusterManagementOperationResult<>(result1, new Date(), new Date(),\n+            null, \"id\", null, null);\n     String json = mapper.writeValueAsString(result);\n     System.out.println(json);\n-    ClusterManagementOperationResult value =\n+    ClusterManagementOperationResult<ClusterManagementOperation<OperationResult>, OperationResult> value =\n         mapper.readValue(json, ClusterManagementOperationResult.class);\n     assertThat(value.getStatusMessage()).isEqualTo(\"Success!!\");\n   }\n \n-  static class TestOperationResult implements OperationResult {\n+  @Test\n+  public void serializeRebal() throws Exception {\n+    ClusterManagementResult result1 = new ClusterManagementResult();\n+    result1.setStatus(StatusCode.OK, \"Success!!\");\n+    RebalanceOperation rebalanceOperation = new RebalanceOperation();\n+    rebalanceOperation.setOperator(\"operator\");\n+    ClusterManagementOperationResult<RebalanceOperation, RebalanceResult> result =\n+        new ClusterManagementOperationResult(result1, new Date(), new Date(),\n+            rebalanceOperation, \"id\", new RebalanceResultImpl(), null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU4OTk0Mw=="}, "originalCommit": {"oid": "640f1260965d3e9f0015f983880e94e5823081ba"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYzODUyMg==", "bodyText": "ps: I'm fine with some other name for the class that implements the RebalanceResult.\nI also find it odd that RebalanceResult has \"getSuccess()\" and \"getStatusMessage()\" but its super interface \"OperationResult\" is empty. It seems like both of these would be reasonable things to expect from every OperationResult.", "url": "https://github.com/apache/geode/pull/4692#discussion_r379638522", "createdAt": "2020-02-14T20:50:27Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-management/src/test/java/org/apache/geode/management/api/ClusterManagementOperationResultTest.java", "diffHunk": "@@ -37,20 +39,32 @@ public void setUp() {\n \n   @Test\n   public void serialize() throws Exception {\n-    CompletableFuture<TestOperationResult> operationResult =\n-        new CompletableFuture<>();\n     ClusterManagementResult result1 = new ClusterManagementResult();\n     result1.setStatus(StatusCode.OK, \"Success!!\");\n-    ClusterManagementOperationResult<TestOperationResult> result =\n-        new ClusterManagementOperationResult<>(result1, operationResult, new Date(),\n-            new CompletableFuture<>(), \"operator\", \"id\");\n+    ClusterManagementOperationResult<ClusterManagementOperation<OperationResult>, OperationResult> result =\n+        new ClusterManagementOperationResult<>(result1, new Date(), new Date(),\n+            null, \"id\", null, null);\n     String json = mapper.writeValueAsString(result);\n     System.out.println(json);\n-    ClusterManagementOperationResult value =\n+    ClusterManagementOperationResult<ClusterManagementOperation<OperationResult>, OperationResult> value =\n         mapper.readValue(json, ClusterManagementOperationResult.class);\n     assertThat(value.getStatusMessage()).isEqualTo(\"Success!!\");\n   }\n \n-  static class TestOperationResult implements OperationResult {\n+  @Test\n+  public void serializeRebal() throws Exception {\n+    ClusterManagementResult result1 = new ClusterManagementResult();\n+    result1.setStatus(StatusCode.OK, \"Success!!\");\n+    RebalanceOperation rebalanceOperation = new RebalanceOperation();\n+    rebalanceOperation.setOperator(\"operator\");\n+    ClusterManagementOperationResult<RebalanceOperation, RebalanceResult> result =\n+        new ClusterManagementOperationResult(result1, new Date(), new Date(),\n+            rebalanceOperation, \"id\", new RebalanceResultImpl(), null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU4OTk0Mw=="}, "originalCommit": {"oid": "640f1260965d3e9f0015f983880e94e5823081ba"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTcwMzgwMQ==", "bodyText": "I filed a geode ticket about moving those methods up to OperationResult.\nThe team talked and we decided it would be best to keep the impl class", "url": "https://github.com/apache/geode/pull/4692#discussion_r379703801", "createdAt": "2020-02-15T00:57:27Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-management/src/test/java/org/apache/geode/management/api/ClusterManagementOperationResultTest.java", "diffHunk": "@@ -37,20 +39,32 @@ public void setUp() {\n \n   @Test\n   public void serialize() throws Exception {\n-    CompletableFuture<TestOperationResult> operationResult =\n-        new CompletableFuture<>();\n     ClusterManagementResult result1 = new ClusterManagementResult();\n     result1.setStatus(StatusCode.OK, \"Success!!\");\n-    ClusterManagementOperationResult<TestOperationResult> result =\n-        new ClusterManagementOperationResult<>(result1, operationResult, new Date(),\n-            new CompletableFuture<>(), \"operator\", \"id\");\n+    ClusterManagementOperationResult<ClusterManagementOperation<OperationResult>, OperationResult> result =\n+        new ClusterManagementOperationResult<>(result1, new Date(), new Date(),\n+            null, \"id\", null, null);\n     String json = mapper.writeValueAsString(result);\n     System.out.println(json);\n-    ClusterManagementOperationResult value =\n+    ClusterManagementOperationResult<ClusterManagementOperation<OperationResult>, OperationResult> value =\n         mapper.readValue(json, ClusterManagementOperationResult.class);\n     assertThat(value.getStatusMessage()).isEqualTo(\"Success!!\");\n   }\n \n-  static class TestOperationResult implements OperationResult {\n+  @Test\n+  public void serializeRebal() throws Exception {\n+    ClusterManagementResult result1 = new ClusterManagementResult();\n+    result1.setStatus(StatusCode.OK, \"Success!!\");\n+    RebalanceOperation rebalanceOperation = new RebalanceOperation();\n+    rebalanceOperation.setOperator(\"operator\");\n+    ClusterManagementOperationResult<RebalanceOperation, RebalanceResult> result =\n+        new ClusterManagementOperationResult(result1, new Date(), new Date(),\n+            rebalanceOperation, \"id\", new RebalanceResultImpl(), null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU4OTk0Mw=="}, "originalCommit": {"oid": "640f1260965d3e9f0015f983880e94e5823081ba"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0ODY4MDUzOnYy", "diffSide": "RIGHT", "path": "geode-management/src/main/java/org/apache/geode/management/api/ClusterManagementOperation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxOTowNDoyN1rOFqAp2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxOTo1MDo1OFrOFqB37Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU5NTIyNg==", "bodyText": "I know this isn't introduced by this PR, but now I am wondering: V really isn't used by this interface, why do we need to declare it here?", "url": "https://github.com/apache/geode/pull/4692#discussion_r379595226", "createdAt": "2020-02-14T19:04:27Z", "author": {"login": "jinmeiliao"}, "path": "geode-management/src/main/java/org/apache/geode/management/api/ClusterManagementOperation.java", "diffHunk": "@@ -29,12 +31,15 @@\n  * @param <V> the result type of the operation\n  */\n @SuppressWarnings(\"unused\")\n-public interface ClusterManagementOperation<V extends OperationResult> {\n+public interface ClusterManagementOperation<V extends OperationResult>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "640f1260965d3e9f0015f983880e94e5823081ba"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYxNTIxMw==", "bodyText": "I know this isn't introduced by this PR, but now I am wondering: V really isn't used by this interface, why do we need to declare it here?\n\nWe need this to maintain the coupling between the operation and the result in the implementations of ClusterManagementOperation.", "url": "https://github.com/apache/geode/pull/4692#discussion_r379615213", "createdAt": "2020-02-14T19:50:58Z", "author": {"login": "jmelchio"}, "path": "geode-management/src/main/java/org/apache/geode/management/api/ClusterManagementOperation.java", "diffHunk": "@@ -29,12 +31,15 @@\n  * @param <V> the result type of the operation\n  */\n @SuppressWarnings(\"unused\")\n-public interface ClusterManagementOperation<V extends OperationResult> {\n+public interface ClusterManagementOperation<V extends OperationResult>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU5NTIyNg=="}, "originalCommit": {"oid": "640f1260965d3e9f0015f983880e94e5823081ba"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0ODcwNTQwOnYy", "diffSide": "RIGHT", "path": "geode-assembly/src/distributedTest/java/org/apache/geode/management/internal/rest/RebalanceManagementDunitTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxOToxMzo0MlrOFqA5ZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQyMjo1Njo0NVrOFrVhXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU5OTIwNQ==", "bodyText": "this is something that I had hoped that could be built in the result that's coming back from the \"start\" operation.", "url": "https://github.com/apache/geode/pull/4692#discussion_r379599205", "createdAt": "2020-02-14T19:13:42Z", "author": {"login": "jinmeiliao"}, "path": "geode-assembly/src/distributedTest/java/org/apache/geode/management/internal/rest/RebalanceManagementDunitTest.java", "diffHunk": "@@ -36,92 +37,110 @@\n import org.apache.geode.management.operation.RebalanceOperation;\n import org.apache.geode.management.runtime.RebalanceRegionResult;\n import org.apache.geode.management.runtime.RebalanceResult;\n+import org.apache.geode.test.awaitility.GeodeAwaitility;\n import org.apache.geode.test.dunit.IgnoredException;\n import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n import org.apache.geode.test.dunit.rules.MemberVM;\n-import org.apache.geode.test.junit.rules.GfshCommandRule;\n import org.apache.geode.test.junit.rules.MemberStarterRule;\n \n public class RebalanceManagementDunitTest {\n \n   @ClassRule\n   public static ClusterStartupRule cluster = new ClusterStartupRule();\n \n-  private static MemberVM locator, server1, server2;\n-\n-  private static ClusterManagementService client;\n-\n-  @ClassRule\n-  public static GfshCommandRule gfsh = new GfshCommandRule();\n+  private static ClusterManagementService client1, client2;\n \n   @BeforeClass\n-  public static void beforeClass() throws Exception {\n-    locator = cluster.startLocatorVM(0, MemberStarterRule::withHttpService);\n-    server1 = cluster.startServerVM(1, \"group1\", locator.getPort());\n-    server2 = cluster.startServerVM(2, \"group2\", locator.getPort());\n-\n-    client = new ClusterManagementServiceBuilder()\n-        .setPort(locator.getHttpPort())\n+  public static void beforeClass() {\n+    MemberVM locator1 = cluster.startLocatorVM(0, MemberStarterRule::withHttpService);\n+    int locator1Port = locator1.getPort();\n+    MemberVM locator2 =\n+        cluster.startLocatorVM(1, l -> l.withHttpService().withConnectionToLocator(locator1Port));\n+    cluster.startServerVM(2, \"group1\", locator1Port);\n+    cluster.startServerVM(3, \"group2\", locator1Port);\n+\n+    client1 = new ClusterManagementServiceBuilder()\n+        .setHost(\"localhost\")\n+        .setPort(locator1.getHttpPort())\n+        .build();\n+    client2 = new ClusterManagementServiceBuilder()\n+        .setHost(\"localhost\")\n+        .setPort(locator2.getHttpPort())\n         .build();\n-    gfsh.connect(locator);\n \n     // create regions\n     Region regionConfig = new Region();\n     regionConfig.setName(\"customers1\");\n     regionConfig.setType(RegionType.PARTITION);\n-    client.create(regionConfig);\n-    locator.waitUntilRegionIsReadyOnExactlyThisManyServers(\"/customers1\", 2);\n+    client1.create(regionConfig);\n+    locator1.waitUntilRegionIsReadyOnExactlyThisManyServers(\"/customers1\", 2);\n \n     regionConfig = new Region();\n     regionConfig.setName(\"customers2\");\n     regionConfig.setType(RegionType.PARTITION);\n-    client.create(regionConfig);\n-    locator.waitUntilRegionIsReadyOnExactlyThisManyServers(\"/customers2\", 2);\n+    client1.create(regionConfig);\n+    locator1.waitUntilRegionIsReadyOnExactlyThisManyServers(\"/customers2\", 2);\n   }\n \n   @Test\n-  public void rebalance() throws Exception {\n-    ClusterManagementOperationResult<RebalanceResult> cmr =\n-        client.start(new RebalanceOperation());\n-    assertThat(cmr.isSuccessful()).isTrue();\n+  public void rebalance() {\n+    ClusterManagementOperationResult<RebalanceOperation, RebalanceResult> startResult =\n+        client1.start(new RebalanceOperation());\n+    assertThat(startResult.isSuccessful()).isTrue();\n     long now = System.currentTimeMillis();\n-    assertThat(cmr.getOperationStart().getTime()).isBetween(now - 60000, now);\n+    assertThat(startResult.getOperationStart().getTime()).isBetween(now - 60000, now);\n \n-    RebalanceResult result = cmr.getFutureResult().get();\n-    long end = cmr.getFutureOperationEnded().get().getTime();\n+    ClusterManagementOperationResult<RebalanceOperation, RebalanceResult> endResult =\n+        waitForStartToEnd(client1, startResult.getOperationId());\n+    long end = endResult.getOperationEnd().getTime();\n     now = System.currentTimeMillis();\n     assertThat(end).isBetween(now - 60000, now)\n-        .isGreaterThanOrEqualTo(cmr.getOperationStart().getTime());\n+        .isGreaterThanOrEqualTo(endResult.getOperationStart().getTime());\n+    RebalanceResult result = endResult.getOperationResult();\n     assertThat(result.getRebalanceRegionResults().size()).isEqualTo(2);\n     RebalanceRegionResult firstRegionSummary = result.getRebalanceRegionResults().get(0);\n     assertThat(firstRegionSummary.getRegionName()).isIn(\"customers1\", \"customers2\");\n   }\n \n+  private ClusterManagementOperationResult<RebalanceOperation, RebalanceResult> waitForStartToEnd(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "640f1260965d3e9f0015f983880e94e5823081ba"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTcwMzkxNA==", "bodyText": "We decided as a team to look into adding a way for the java api user to block until the started op has completed.", "url": "https://github.com/apache/geode/pull/4692#discussion_r379703914", "createdAt": "2020-02-15T00:58:15Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-assembly/src/distributedTest/java/org/apache/geode/management/internal/rest/RebalanceManagementDunitTest.java", "diffHunk": "@@ -36,92 +37,110 @@\n import org.apache.geode.management.operation.RebalanceOperation;\n import org.apache.geode.management.runtime.RebalanceRegionResult;\n import org.apache.geode.management.runtime.RebalanceResult;\n+import org.apache.geode.test.awaitility.GeodeAwaitility;\n import org.apache.geode.test.dunit.IgnoredException;\n import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n import org.apache.geode.test.dunit.rules.MemberVM;\n-import org.apache.geode.test.junit.rules.GfshCommandRule;\n import org.apache.geode.test.junit.rules.MemberStarterRule;\n \n public class RebalanceManagementDunitTest {\n \n   @ClassRule\n   public static ClusterStartupRule cluster = new ClusterStartupRule();\n \n-  private static MemberVM locator, server1, server2;\n-\n-  private static ClusterManagementService client;\n-\n-  @ClassRule\n-  public static GfshCommandRule gfsh = new GfshCommandRule();\n+  private static ClusterManagementService client1, client2;\n \n   @BeforeClass\n-  public static void beforeClass() throws Exception {\n-    locator = cluster.startLocatorVM(0, MemberStarterRule::withHttpService);\n-    server1 = cluster.startServerVM(1, \"group1\", locator.getPort());\n-    server2 = cluster.startServerVM(2, \"group2\", locator.getPort());\n-\n-    client = new ClusterManagementServiceBuilder()\n-        .setPort(locator.getHttpPort())\n+  public static void beforeClass() {\n+    MemberVM locator1 = cluster.startLocatorVM(0, MemberStarterRule::withHttpService);\n+    int locator1Port = locator1.getPort();\n+    MemberVM locator2 =\n+        cluster.startLocatorVM(1, l -> l.withHttpService().withConnectionToLocator(locator1Port));\n+    cluster.startServerVM(2, \"group1\", locator1Port);\n+    cluster.startServerVM(3, \"group2\", locator1Port);\n+\n+    client1 = new ClusterManagementServiceBuilder()\n+        .setHost(\"localhost\")\n+        .setPort(locator1.getHttpPort())\n+        .build();\n+    client2 = new ClusterManagementServiceBuilder()\n+        .setHost(\"localhost\")\n+        .setPort(locator2.getHttpPort())\n         .build();\n-    gfsh.connect(locator);\n \n     // create regions\n     Region regionConfig = new Region();\n     regionConfig.setName(\"customers1\");\n     regionConfig.setType(RegionType.PARTITION);\n-    client.create(regionConfig);\n-    locator.waitUntilRegionIsReadyOnExactlyThisManyServers(\"/customers1\", 2);\n+    client1.create(regionConfig);\n+    locator1.waitUntilRegionIsReadyOnExactlyThisManyServers(\"/customers1\", 2);\n \n     regionConfig = new Region();\n     regionConfig.setName(\"customers2\");\n     regionConfig.setType(RegionType.PARTITION);\n-    client.create(regionConfig);\n-    locator.waitUntilRegionIsReadyOnExactlyThisManyServers(\"/customers2\", 2);\n+    client1.create(regionConfig);\n+    locator1.waitUntilRegionIsReadyOnExactlyThisManyServers(\"/customers2\", 2);\n   }\n \n   @Test\n-  public void rebalance() throws Exception {\n-    ClusterManagementOperationResult<RebalanceResult> cmr =\n-        client.start(new RebalanceOperation());\n-    assertThat(cmr.isSuccessful()).isTrue();\n+  public void rebalance() {\n+    ClusterManagementOperationResult<RebalanceOperation, RebalanceResult> startResult =\n+        client1.start(new RebalanceOperation());\n+    assertThat(startResult.isSuccessful()).isTrue();\n     long now = System.currentTimeMillis();\n-    assertThat(cmr.getOperationStart().getTime()).isBetween(now - 60000, now);\n+    assertThat(startResult.getOperationStart().getTime()).isBetween(now - 60000, now);\n \n-    RebalanceResult result = cmr.getFutureResult().get();\n-    long end = cmr.getFutureOperationEnded().get().getTime();\n+    ClusterManagementOperationResult<RebalanceOperation, RebalanceResult> endResult =\n+        waitForStartToEnd(client1, startResult.getOperationId());\n+    long end = endResult.getOperationEnd().getTime();\n     now = System.currentTimeMillis();\n     assertThat(end).isBetween(now - 60000, now)\n-        .isGreaterThanOrEqualTo(cmr.getOperationStart().getTime());\n+        .isGreaterThanOrEqualTo(endResult.getOperationStart().getTime());\n+    RebalanceResult result = endResult.getOperationResult();\n     assertThat(result.getRebalanceRegionResults().size()).isEqualTo(2);\n     RebalanceRegionResult firstRegionSummary = result.getRebalanceRegionResults().get(0);\n     assertThat(firstRegionSummary.getRegionName()).isIn(\"customers1\", \"customers2\");\n   }\n \n+  private ClusterManagementOperationResult<RebalanceOperation, RebalanceResult> waitForStartToEnd(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU5OTIwNQ=="}, "originalCommit": {"oid": "640f1260965d3e9f0015f983880e94e5823081ba"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk4NTY5NA==", "bodyText": "We added \"getFuture\" to the ClusterManagementService. We thought this was cleaner than adding \"getFuture\" to ClusterManagementOperationResult because if we did that it would need to have a reference to the ClusterManagementService to repeatedly call \"get\".", "url": "https://github.com/apache/geode/pull/4692#discussion_r380985694", "createdAt": "2020-02-18T22:56:45Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-assembly/src/distributedTest/java/org/apache/geode/management/internal/rest/RebalanceManagementDunitTest.java", "diffHunk": "@@ -36,92 +37,110 @@\n import org.apache.geode.management.operation.RebalanceOperation;\n import org.apache.geode.management.runtime.RebalanceRegionResult;\n import org.apache.geode.management.runtime.RebalanceResult;\n+import org.apache.geode.test.awaitility.GeodeAwaitility;\n import org.apache.geode.test.dunit.IgnoredException;\n import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n import org.apache.geode.test.dunit.rules.MemberVM;\n-import org.apache.geode.test.junit.rules.GfshCommandRule;\n import org.apache.geode.test.junit.rules.MemberStarterRule;\n \n public class RebalanceManagementDunitTest {\n \n   @ClassRule\n   public static ClusterStartupRule cluster = new ClusterStartupRule();\n \n-  private static MemberVM locator, server1, server2;\n-\n-  private static ClusterManagementService client;\n-\n-  @ClassRule\n-  public static GfshCommandRule gfsh = new GfshCommandRule();\n+  private static ClusterManagementService client1, client2;\n \n   @BeforeClass\n-  public static void beforeClass() throws Exception {\n-    locator = cluster.startLocatorVM(0, MemberStarterRule::withHttpService);\n-    server1 = cluster.startServerVM(1, \"group1\", locator.getPort());\n-    server2 = cluster.startServerVM(2, \"group2\", locator.getPort());\n-\n-    client = new ClusterManagementServiceBuilder()\n-        .setPort(locator.getHttpPort())\n+  public static void beforeClass() {\n+    MemberVM locator1 = cluster.startLocatorVM(0, MemberStarterRule::withHttpService);\n+    int locator1Port = locator1.getPort();\n+    MemberVM locator2 =\n+        cluster.startLocatorVM(1, l -> l.withHttpService().withConnectionToLocator(locator1Port));\n+    cluster.startServerVM(2, \"group1\", locator1Port);\n+    cluster.startServerVM(3, \"group2\", locator1Port);\n+\n+    client1 = new ClusterManagementServiceBuilder()\n+        .setHost(\"localhost\")\n+        .setPort(locator1.getHttpPort())\n+        .build();\n+    client2 = new ClusterManagementServiceBuilder()\n+        .setHost(\"localhost\")\n+        .setPort(locator2.getHttpPort())\n         .build();\n-    gfsh.connect(locator);\n \n     // create regions\n     Region regionConfig = new Region();\n     regionConfig.setName(\"customers1\");\n     regionConfig.setType(RegionType.PARTITION);\n-    client.create(regionConfig);\n-    locator.waitUntilRegionIsReadyOnExactlyThisManyServers(\"/customers1\", 2);\n+    client1.create(regionConfig);\n+    locator1.waitUntilRegionIsReadyOnExactlyThisManyServers(\"/customers1\", 2);\n \n     regionConfig = new Region();\n     regionConfig.setName(\"customers2\");\n     regionConfig.setType(RegionType.PARTITION);\n-    client.create(regionConfig);\n-    locator.waitUntilRegionIsReadyOnExactlyThisManyServers(\"/customers2\", 2);\n+    client1.create(regionConfig);\n+    locator1.waitUntilRegionIsReadyOnExactlyThisManyServers(\"/customers2\", 2);\n   }\n \n   @Test\n-  public void rebalance() throws Exception {\n-    ClusterManagementOperationResult<RebalanceResult> cmr =\n-        client.start(new RebalanceOperation());\n-    assertThat(cmr.isSuccessful()).isTrue();\n+  public void rebalance() {\n+    ClusterManagementOperationResult<RebalanceOperation, RebalanceResult> startResult =\n+        client1.start(new RebalanceOperation());\n+    assertThat(startResult.isSuccessful()).isTrue();\n     long now = System.currentTimeMillis();\n-    assertThat(cmr.getOperationStart().getTime()).isBetween(now - 60000, now);\n+    assertThat(startResult.getOperationStart().getTime()).isBetween(now - 60000, now);\n \n-    RebalanceResult result = cmr.getFutureResult().get();\n-    long end = cmr.getFutureOperationEnded().get().getTime();\n+    ClusterManagementOperationResult<RebalanceOperation, RebalanceResult> endResult =\n+        waitForStartToEnd(client1, startResult.getOperationId());\n+    long end = endResult.getOperationEnd().getTime();\n     now = System.currentTimeMillis();\n     assertThat(end).isBetween(now - 60000, now)\n-        .isGreaterThanOrEqualTo(cmr.getOperationStart().getTime());\n+        .isGreaterThanOrEqualTo(endResult.getOperationStart().getTime());\n+    RebalanceResult result = endResult.getOperationResult();\n     assertThat(result.getRebalanceRegionResults().size()).isEqualTo(2);\n     RebalanceRegionResult firstRegionSummary = result.getRebalanceRegionResults().get(0);\n     assertThat(firstRegionSummary.getRegionName()).isIn(\"customers1\", \"customers2\");\n   }\n \n+  private ClusterManagementOperationResult<RebalanceOperation, RebalanceResult> waitForStartToEnd(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU5OTIwNQ=="}, "originalCommit": {"oid": "640f1260965d3e9f0015f983880e94e5823081ba"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0OTA5ODUyOnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/management/internal/operation/OperationHistoryManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQyMTo0OToxN1rOFqEpcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwMDoxOTo1N1rOFrXIXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY2MDY1Ng==", "bodyText": "Gang: please change it to one week.", "url": "https://github.com/apache/geode/pull/4692#discussion_r379660656", "createdAt": "2020-02-14T21:49:17Z", "author": {"login": "jinmeiliao"}, "path": "geode-core/src/main/java/org/apache/geode/management/internal/operation/OperationHistoryManager.java", "diffHunk": "@@ -38,146 +33,88 @@\n  */\n @Experimental\n public class OperationHistoryManager {\n-  private final ConcurrentMap<String, OperationInstance> history;\n   private final long keepCompletedMillis;\n+  private final OperationStateDistributionService operationStateDistributionService;\n \n   /**\n    * set a default retention policy to keep results for 2 hours after completion\n    */\n-  public OperationHistoryManager() {\n-    this(2, TimeUnit.HOURS);\n+  public OperationHistoryManager(\n+      OperationStateDistributionService operationStateDistributionService) {\n+    this(2, TimeUnit.HOURS, operationStateDistributionService);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "640f1260965d3e9f0015f983880e94e5823081ba"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAxMjA2MQ==", "bodyText": "done", "url": "https://github.com/apache/geode/pull/4692#discussion_r381012061", "createdAt": "2020-02-19T00:19:57Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-core/src/main/java/org/apache/geode/management/internal/operation/OperationHistoryManager.java", "diffHunk": "@@ -38,146 +33,88 @@\n  */\n @Experimental\n public class OperationHistoryManager {\n-  private final ConcurrentMap<String, OperationInstance> history;\n   private final long keepCompletedMillis;\n+  private final OperationStateDistributionService operationStateDistributionService;\n \n   /**\n    * set a default retention policy to keep results for 2 hours after completion\n    */\n-  public OperationHistoryManager() {\n-    this(2, TimeUnit.HOURS);\n+  public OperationHistoryManager(\n+      OperationStateDistributionService operationStateDistributionService) {\n+    this(2, TimeUnit.HOURS, operationStateDistributionService);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY2MDY1Ng=="}, "originalCommit": {"oid": "640f1260965d3e9f0015f983880e94e5823081ba"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0OTEwNzc5OnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/management/internal/operation/RegionOperationStateDistributionService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQyMTo1MzozMFrOFqEvOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQwMDo1ODo1NVrOFqHSxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY2MjEzOQ==", "bodyText": "internal region needs to be started with \"_\" or \"__\".", "url": "https://github.com/apache/geode/pull/4692#discussion_r379662139", "createdAt": "2020-02-14T21:53:30Z", "author": {"login": "jinmeiliao"}, "path": "geode-core/src/main/java/org/apache/geode/management/internal/operation/RegionOperationStateDistributionService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.management.internal.operation;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.function.Supplier;\n+\n+import org.apache.geode.annotations.VisibleForTesting;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionFactory;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.RegionFactoryImpl;\n+import org.apache.geode.management.api.ClusterManagementOperation;\n+import org.apache.geode.management.runtime.OperationResult;\n+\n+public class RegionOperationStateDistributionService\n+    implements OperationStateDistributionService {\n+  private final Supplier<String> uniqueIdSupplier;\n+  private final Region<String, OperationState<ClusterManagementOperation<OperationResult>, OperationResult>> region;\n+\n+  public static final String OPERATION_STATE_REGION_NAME = \"OperationStateRegion\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "640f1260965d3e9f0015f983880e94e5823081ba"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTcwNDAwNg==", "bodyText": "This has been changed to start with \"\". I found a validator that does not allow names to start with \"\".", "url": "https://github.com/apache/geode/pull/4692#discussion_r379704006", "createdAt": "2020-02-15T00:58:55Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-core/src/main/java/org/apache/geode/management/internal/operation/RegionOperationStateDistributionService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.management.internal.operation;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.function.Supplier;\n+\n+import org.apache.geode.annotations.VisibleForTesting;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionFactory;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.RegionFactoryImpl;\n+import org.apache.geode.management.api.ClusterManagementOperation;\n+import org.apache.geode.management.runtime.OperationResult;\n+\n+public class RegionOperationStateDistributionService\n+    implements OperationStateDistributionService {\n+  private final Supplier<String> uniqueIdSupplier;\n+  private final Region<String, OperationState<ClusterManagementOperation<OperationResult>, OperationResult>> region;\n+\n+  public static final String OPERATION_STATE_REGION_NAME = \"OperationStateRegion\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY2MjEzOQ=="}, "originalCommit": {"oid": "640f1260965d3e9f0015f983880e94e5823081ba"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0OTIwMDY2OnYy", "diffSide": "LEFT", "path": "geode-core/src/main/java/org/apache/geode/management/internal/operation/OperationHistoryManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQyMjozODo1MVrOFqFnSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwMDoyMDoyMlrOFrXIxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY3NjQ5MA==", "bodyText": "Consider using Java's very nice Duration and Instant classes to carry information about durations and instants.", "url": "https://github.com/apache/geode/pull/4692#discussion_r379676490", "createdAt": "2020-02-14T22:38:51Z", "author": {"login": "demery-pivotal"}, "path": "geode-core/src/main/java/org/apache/geode/management/internal/operation/OperationHistoryManager.java", "diffHunk": "@@ -38,146 +33,88 @@\n  */\n @Experimental\n public class OperationHistoryManager {\n-  private final ConcurrentMap<String, OperationInstance> history;\n   private final long keepCompletedMillis;\n+  private final OperationStateDistributionService operationStateDistributionService;\n \n   /**\n    * set a default retention policy to keep results for 2 hours after completion\n    */\n-  public OperationHistoryManager() {\n-    this(2, TimeUnit.HOURS);\n+  public OperationHistoryManager(\n+      OperationStateDistributionService operationStateDistributionService) {\n+    this(2, TimeUnit.HOURS, operationStateDistributionService);\n   }\n \n   /**\n    * set a custom retention policy to keep results for X amount of time after completion\n    */\n-  public OperationHistoryManager(long keepCompleted, TimeUnit timeUnit) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "640f1260965d3e9f0015f983880e94e5823081ba"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAxMjE2Ng==", "bodyText": "constructor now takes a Duration instead of a long and a TimeUnit", "url": "https://github.com/apache/geode/pull/4692#discussion_r381012166", "createdAt": "2020-02-19T00:20:22Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-core/src/main/java/org/apache/geode/management/internal/operation/OperationHistoryManager.java", "diffHunk": "@@ -38,146 +33,88 @@\n  */\n @Experimental\n public class OperationHistoryManager {\n-  private final ConcurrentMap<String, OperationInstance> history;\n   private final long keepCompletedMillis;\n+  private final OperationStateDistributionService operationStateDistributionService;\n \n   /**\n    * set a default retention policy to keep results for 2 hours after completion\n    */\n-  public OperationHistoryManager() {\n-    this(2, TimeUnit.HOURS);\n+  public OperationHistoryManager(\n+      OperationStateDistributionService operationStateDistributionService) {\n+    this(2, TimeUnit.HOURS, operationStateDistributionService);\n   }\n \n   /**\n    * set a custom retention policy to keep results for X amount of time after completion\n    */\n-  public OperationHistoryManager(long keepCompleted, TimeUnit timeUnit) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY3NjQ5MA=="}, "originalCommit": {"oid": "640f1260965d3e9f0015f983880e94e5823081ba"}, "originalPosition": 40}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3772, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}