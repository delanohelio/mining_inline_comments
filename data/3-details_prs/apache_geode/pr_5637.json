{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA1Mjk0NzU5", "number": 5637, "title": "GEODE-8626: Omitting field-mapping tag of cache.xml when using Simple JDBC Connector", "bodyText": "Use the default mapping when using the Simple JDBC Connector in cache.xml and without the field-mapping tag\nThank you for submitting a contribution to Apache Geode.\nIn order to streamline the review of the contribution we ask you\nto ensure the following steps have been taken:\nFor all changes:\n\n\n Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?\n\n\n Has your PR been rebased against the latest commit within the target branch (typically develop)?\n\n\n Is your initial contribution a single, squashed commit?\n\n\n Does gradlew build run cleanly?\n\n\n Have you written or updated unit tests to verify your changes?\n\n\n[-] If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under ASF 2.0?\n\n\nNote:\nPlease ensure that once the PR is submitted, check Concourse for build issues and\nsubmit an update to your PR as soon as possible. If you need help, please send an\nemail to dev@geode.apache.org.", "createdAt": "2020-10-17T14:54:26Z", "url": "https://github.com/apache/geode/pull/5637", "merged": true, "mergeCommit": {"oid": "723429f291f48f309acc3407f1405339ddbcfc20"}, "closed": true, "closedAt": "2021-09-11T00:02:08Z", "author": {"login": "masaki-yamakawa"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdZYkJqgFqTUyMzgyNzY0Nw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABel3yKEgFqTY5NjQzNjU5Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzODI3NjQ3", "url": "https://github.com/apache/geode/pull/5637#pullrequestreview-523827647", "createdAt": "2020-11-05T00:14:20Z", "commit": {"oid": "784f29f1ae07e98fb6cf39bd95718b8cc05cf726"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwMDoxNDoyMFrOHtuTKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwMTo0ODoxMlrOHtv_YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcwNjUzOQ==", "bodyText": "Is this replacement of & necessary?", "url": "https://github.com/apache/geode/pull/5637#discussion_r517706539", "createdAt": "2020-11-05T00:14:20Z", "author": {"login": "jchen21"}, "path": "geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/CacheXmlJdbcMappingIntegrationTest.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.connectors.jdbc;\n+\n+import static org.apache.geode.test.util.ResourceUtils.createTempFileFromResource;\n+\n+import org.junit.Rule;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+\n+import org.apache.geode.cache.CacheFactory;\n+import org.apache.geode.internal.cache.InternalCache;\n+\n+public class CacheXmlJdbcMappingIntegrationTest extends JdbcMappingIntegrationTest {\n+\n+  @Rule\n+  public RestoreSystemProperties restoreSystemProperties = new RestoreSystemProperties();\n+\n+  @Override\n+  protected InternalCache createCacheAndCreateJdbcMapping(String cacheXmlTestName)\n+      throws Exception {\n+    String url = dbRule.getConnectionUrl().replaceAll(\"&\", \"&amp;\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "784f29f1ae07e98fb6cf39bd95718b8cc05cf726"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxMzIxNw==", "bodyText": "To create region, data store and mapping etc, I would recommend using GfshRule and execute gfsh commands, instead of calling the internal functions that implement the gfsh commands.", "url": "https://github.com/apache/geode/pull/5637#discussion_r517713217", "createdAt": "2020-11-05T00:36:40Z", "author": {"login": "jchen21"}, "path": "geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/GfshJdbcMappingIntegrationTest.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.connectors.jdbc;\n+\n+import java.lang.reflect.Constructor;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.geode.cache.CacheFactory;\n+import org.apache.geode.cache.configuration.JndiBindingsType;\n+import org.apache.geode.cache.configuration.RegionConfig;\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.ResultCollector;\n+import org.apache.geode.connectors.jdbc.internal.cli.CreateMappingFunction;\n+import org.apache.geode.connectors.jdbc.internal.cli.CreateMappingPreconditionCheckFunction;\n+import org.apache.geode.connectors.jdbc.internal.configuration.FieldMapping;\n+import org.apache.geode.connectors.jdbc.internal.configuration.RegionMapping;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.management.configuration.RegionType;\n+import org.apache.geode.management.internal.cli.commands.CreateJndiBindingCommand;\n+import org.apache.geode.management.internal.cli.functions.CreateJndiBindingFunction;\n+import org.apache.geode.management.internal.cli.functions.CreateRegionFunctionArgs;\n+import org.apache.geode.management.internal.cli.functions.RegionCreateFunction;\n+import org.apache.geode.management.internal.configuration.converters.RegionConverter;\n+import org.apache.geode.management.internal.functions.CliFunctionResult;\n+import org.apache.geode.management.internal.util.ManagementUtils;\n+\n+public class GfshJdbcMappingIntegrationTest extends JdbcMappingIntegrationTest {\n+\n+  @Override\n+  protected InternalCache createCacheAndCreateJdbcMapping(String cacheXmlTestName)\n+      throws Exception {\n+    InternalCache cache =\n+        (InternalCache) new CacheFactory().set(\"locators\", \"\").set(\"mcast-port\", \"0\").create();\n+    Set<DistributedMember> targetMembers = findMembers(cache, null, null);\n+\n+    CliFunctionResult createRegionFuncResult = executeCreateRegionFunction(targetMembers);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "784f29f1ae07e98fb6cf39bd95718b8cc05cf726"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxOTQwNw==", "bodyText": "Why this class has to be public?", "url": "https://github.com/apache/geode/pull/5637#discussion_r517719407", "createdAt": "2020-11-05T00:57:21Z", "author": {"login": "jchen21"}, "path": "geode-connectors/src/distributedTest/java/org/apache/geode/connectors/jdbc/internal/cli/CreateMappingCommandDUnitTest.java", "diffHunk": "@@ -1142,7 +1142,7 @@ public void createMappingWithExistingQueueFails() {\n             + \" must not already exist.\");\n   }\n \n-  private static class Employee implements PdxSerializable {\n+  public static class Employee implements PdxSerializable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "784f29f1ae07e98fb6cf39bd95718b8cc05cf726"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxOTY1Mg==", "bodyText": "Why this class has to be public?", "url": "https://github.com/apache/geode/pull/5637#discussion_r517719652", "createdAt": "2020-11-05T00:58:09Z", "author": {"login": "jchen21"}, "path": "geode-connectors/src/distributedTest/java/org/apache/geode/connectors/jdbc/internal/cli/CreateMappingCommandDUnitTest.java", "diffHunk": "@@ -1185,7 +1185,7 @@ public void fromData(PdxReader reader) {\n     }\n   }\n \n-  private static class EmployeeNumeric implements PdxSerializerObject {\n+  public static class EmployeeNumeric implements PdxSerializerObject {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "784f29f1ae07e98fb6cf39bd95718b8cc05cf726"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxOTY4Mw==", "bodyText": "Why this class has to be public?", "url": "https://github.com/apache/geode/pull/5637#discussion_r517719683", "createdAt": "2020-11-05T00:58:16Z", "author": {"login": "jchen21"}, "path": "geode-connectors/src/distributedTest/java/org/apache/geode/connectors/jdbc/internal/cli/CreateMappingCommandDUnitTest.java", "diffHunk": "@@ -1234,7 +1234,7 @@ void setRefid(long refid) {\n     }\n   }\n \n-  private static class IdAndName implements PdxSerializable {\n+  public static class IdAndName implements PdxSerializable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "784f29f1ae07e98fb6cf39bd95718b8cc05cf726"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyMTEzNQ==", "bodyText": "The data source has nothing to do with table metadata or region name. I recommend removing this line of error message.", "url": "https://github.com/apache/geode/pull/5637#discussion_r517721135", "createdAt": "2020-11-05T01:03:12Z", "author": {"login": "jchen21"}, "path": "geode-connectors/src/main/java/org/apache/geode/connectors/jdbc/internal/JdbcConnectorServiceImpl.java", "diffHunk": "@@ -210,4 +224,152 @@ private TableMetaDataView getTableMetaDataView(RegionMapping regionMapping,\n               + regionMapping.getDataSourceName() + \"\\\": \", ex);\n     }\n   }\n+\n+  @Override\n+  public TableMetaDataView getTableMetaDataView(RegionMapping regionMapping) {\n+    DataSource dataSource = getDataSource(regionMapping.getDataSourceName());\n+    if (dataSource == null) {\n+      throw new JdbcConnectorException(\"No datasource \\\"\" + regionMapping.getDataSourceName()\n+          + \"\\\" found when getting table meta data \\\"\" + regionMapping.getRegionName() + \"\\\"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "784f29f1ae07e98fb6cf39bd95718b8cc05cf726"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyMTIxMQ==", "bodyText": "The data source has nothing to do with table metadata or region name. I recommend removing this line of error message.", "url": "https://github.com/apache/geode/pull/5637#discussion_r517721211", "createdAt": "2020-11-05T01:03:28Z", "author": {"login": "jchen21"}, "path": "geode-connectors/src/main/java/org/apache/geode/connectors/jdbc/internal/JdbcConnectorServiceImpl.java", "diffHunk": "@@ -210,4 +224,152 @@ private TableMetaDataView getTableMetaDataView(RegionMapping regionMapping,\n               + regionMapping.getDataSourceName() + \"\\\": \", ex);\n     }\n   }\n+\n+  @Override\n+  public TableMetaDataView getTableMetaDataView(RegionMapping regionMapping) {\n+    DataSource dataSource = getDataSource(regionMapping.getDataSourceName());\n+    if (dataSource == null) {\n+      throw new JdbcConnectorException(\"No datasource \\\"\" + regionMapping.getDataSourceName()\n+          + \"\\\" found when getting table meta data \\\"\" + regionMapping.getRegionName() + \"\\\"\");\n+    }\n+    return getTableMetaDataView(regionMapping, dataSource);\n+  }\n+\n+  @Override\n+  public List<FieldMapping> createDefaultFieldMapping(RegionMapping regionMapping,\n+      PdxType pdxType) {\n+    DataSource dataSource = getDataSource(regionMapping.getDataSourceName());\n+    if (dataSource == null) {\n+      throw new JdbcConnectorException(\"No datasource \\\"\" + regionMapping.getDataSourceName()\n+          + \"\\\" found when creating mapping \\\"\" + regionMapping.getRegionName() + \"\\\"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "784f29f1ae07e98fb6cf39bd95718b8cc05cf726"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyODAzNQ==", "bodyText": "Since its implementation is just one line, why not inline it?", "url": "https://github.com/apache/geode/pull/5637#discussion_r517728035", "createdAt": "2020-11-05T01:27:09Z", "author": {"login": "jchen21"}, "path": "geode-connectors/src/main/java/org/apache/geode/connectors/jdbc/internal/xml/RegionMappingConfiguration.java", "diffHunk": "@@ -62,4 +77,17 @@ private void createRegionMapping(JdbcConnectorService service,\n       throw new InternalGemFireException(e);\n     }\n   }\n+\n+  private Class<?> loadPdxClass(String className) {\n+    try {\n+      return loadClass(className);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "784f29f1ae07e98fb6cf39bd95718b8cc05cf726"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczMTc4Ng==", "bodyText": "Why this test is removed?", "url": "https://github.com/apache/geode/pull/5637#discussion_r517731786", "createdAt": "2020-11-05T01:39:59Z", "author": {"login": "jchen21"}, "path": "geode-connectors/src/test/java/org/apache/geode/connectors/jdbc/internal/cli/CreateMappingPreconditionCheckFunctionTest.java", "diffHunk": "@@ -172,16 +168,6 @@ public void executeFunctionThrowsIfDataSourceDoesNotExist() {\n             + DATA_SOURCE_NAME + \"'.\");\n   }\n \n-  @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "784f29f1ae07e98fb6cf39bd95718b8cc05cf726"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczNDI0MQ==", "bodyText": "Some functions of CreateMappingPreconditionCheckFunction are moved to JdbcConnectorServiceImpl. So if you remove this test here, there should be similar test coverage added in JdbcConnectorServiceTest. In JdbcConnectorServiceTest there are some tests that test ReflectionBasedAutoSerializer. However, those tests don't verify FieldMapping like this test.", "url": "https://github.com/apache/geode/pull/5637#discussion_r517734241", "createdAt": "2020-11-05T01:48:12Z", "author": {"login": "jchen21"}, "path": "geode-connectors/src/test/java/org/apache/geode/connectors/jdbc/internal/cli/CreateMappingPreconditionCheckFunctionTest.java", "diffHunk": "@@ -306,45 +292,10 @@ public void executeFunctionThrowsGivenPdxSerializableWithNoZeroArgConstructor()\n             \"Could not generate a PdxType for the class org.apache.geode.connectors.jdbc.internal.cli.CreateMappingPreconditionCheckFunctionTest$PdxClassDummyNoZeroArg because it did not have a public zero arg constructor. Details: java.lang.NoSuchMethodException: org.apache.geode.connectors.jdbc.internal.cli.CreateMappingPreconditionCheckFunctionTest$PdxClassDummyNoZeroArg.<init>()\");\n   }\n \n-  @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "784f29f1ae07e98fb6cf39bd95718b8cc05cf726"}, "originalPosition": 134}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NTI1NjAw", "url": "https://github.com/apache/geode/pull/5637#pullrequestreview-526525600", "createdAt": "2020-11-09T18:15:39Z", "commit": {"oid": "7fc1417ec80c177e4cb46add831dfdfc4c99224f"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxODoxNTo0MFrOHv7dWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMDowODo1NVrOHv_uag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAxOTI4OQ==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/apache/geode/pull/5637#discussion_r520019289", "createdAt": "2020-11-09T18:15:40Z", "author": {"login": "jchen21"}, "path": "geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/CacheXmlJdbcMappingIntegrationTest.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.connectors.jdbc;\n+\n+import static org.apache.geode.test.util.ResourceUtils.createTempFileFromResource;\n+\n+import org.junit.Rule;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+\n+import org.apache.geode.cache.CacheFactory;\n+import org.apache.geode.internal.cache.InternalCache;\n+\n+public class CacheXmlJdbcMappingIntegrationTest extends JdbcMappingIntegrationTest {\n+\n+  @Rule\n+  public RestoreSystemProperties restoreSystemProperties = new RestoreSystemProperties();\n+\n+  @Override\n+  protected InternalCache createCacheAndCreateJdbcMapping(String cacheXmlTestName)\n+      throws Exception {\n+    String url = dbRule.getConnectionUrl().replaceAll(\"&\", \"&amp;\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcwNjUzOQ=="}, "originalCommit": {"oid": "784f29f1ae07e98fb6cf39bd95718b8cc05cf726"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAyMzU4OA==", "bodyText": "I was trying to say:\nif (dataSource == null) {\n      throw new JdbcConnectorException(\"No datasource \\\"\" + regionMapping.getDataSourceName());\n}\n\nIf you would like to provide more information,\nif (dataSource == null) {\n      throw new JdbcConnectorException(\"No datasource \\\"\" + regionMapping.getDataSourceName()\n          + \"\\\" found when getting table meta data \\\"\" + regionMapping.getTableName() + \"\\\"\");\n}\n\nNote that it is regionMapping.getTableName(), not regionMapping.getRegionName().", "url": "https://github.com/apache/geode/pull/5637#discussion_r520023588", "createdAt": "2020-11-09T18:23:03Z", "author": {"login": "jchen21"}, "path": "geode-connectors/src/main/java/org/apache/geode/connectors/jdbc/internal/JdbcConnectorServiceImpl.java", "diffHunk": "@@ -210,4 +224,152 @@ private TableMetaDataView getTableMetaDataView(RegionMapping regionMapping,\n               + regionMapping.getDataSourceName() + \"\\\": \", ex);\n     }\n   }\n+\n+  @Override\n+  public TableMetaDataView getTableMetaDataView(RegionMapping regionMapping) {\n+    DataSource dataSource = getDataSource(regionMapping.getDataSourceName());\n+    if (dataSource == null) {\n+      throw new JdbcConnectorException(\"No datasource \\\"\" + regionMapping.getDataSourceName()\n+          + \"\\\" found when getting table meta data \\\"\" + regionMapping.getRegionName() + \"\\\"\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyMTEzNQ=="}, "originalCommit": {"oid": "784f29f1ae07e98fb6cf39bd95718b8cc05cf726"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAzNjY3MA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/apache/geode/pull/5637#discussion_r520036670", "createdAt": "2020-11-09T18:45:52Z", "author": {"login": "jchen21"}, "path": "geode-connectors/src/test/java/org/apache/geode/connectors/jdbc/internal/cli/CreateMappingPreconditionCheckFunctionTest.java", "diffHunk": "@@ -172,16 +168,6 @@ public void executeFunctionThrowsIfDataSourceDoesNotExist() {\n             + DATA_SOURCE_NAME + \"'.\");\n   }\n \n-  @Test", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczMTc4Ng=="}, "originalCommit": {"oid": "784f29f1ae07e98fb6cf39bd95718b8cc05cf726"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAzODczNg==", "bodyText": "Minor pick. I would recommend some error message for the SQLException, e.g.\n String reason = \"connection failed\";\t\n    when(dataSource.getConnection()).thenThrow(new SQLException(reason));\n\nThe the error message in the next few lines would be Exception thrown while connecting to datasource \\\"dataSource\\\": connection failed, instead of Exception thrown while connecting to datasource \\\"dataSource\\\": null", "url": "https://github.com/apache/geode/pull/5637#discussion_r520038736", "createdAt": "2020-11-09T18:49:18Z", "author": {"login": "jchen21"}, "path": "geode-connectors/src/test/java/org/apache/geode/connectors/jdbc/internal/JdbcConnectorServiceTest.java", "diffHunk": "@@ -216,4 +249,213 @@ public void validateMappingSucceedsWithCompositeKeys() {\n     when(mapping.getIds()).thenReturn(KEY_COLUMN_NAME + \",\" + COMPOSITE_KEY_COLUMN_NAME);\n     service.validateMapping(mapping);\n   }\n+\n+  @Test\n+  public void getTableMetaDataViewSucceeds() {\n+    TableMetaDataView result = service.getTableMetaDataView(mapping);\n+    assertThat(result).isEqualTo(view);\n+    verify(manager).getTableMetaDataView(connection, mapping);\n+  }\n+\n+  @Test\n+  public void getTableMetaDataViewThrowsExceptionWhenDataSourceDoesNotExist() {\n+    doReturn(null).when(service).getDataSource(DATA_SOURCE_NAME);\n+    Throwable throwable = catchThrowable(() -> service.getTableMetaDataView(mapping));\n+    assertThat(throwable).isInstanceOf(JdbcConnectorException.class).hasMessageContaining(\n+        String.format(\"No datasource \\\"%s\\\" found when getting table meta data \\\"%s\\\"\",\n+            mapping.getDataSourceName(), mapping.getRegionName()));\n+  }\n+\n+  @Test\n+  public void getTableMetaDataViewThrowsExceptionWhenGetConnectionHasSqlException()\n+      throws SQLException {\n+    when(dataSource.getConnection()).thenThrow(SQLException.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fc1417ec80c177e4cb46add831dfdfc4c99224f"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA1NzQwNQ==", "bodyText": "I understand that. However, none of the JdbcConnectorServiceTest.createDefaultFieldMapping* uses ReflectionBasedAutoSerializer. Although those tests do verify the field mapping. I expect there is some test that uses ReflectionBasedAutoSerializer and verifies the field mapping as well, like the test deleted below.", "url": "https://github.com/apache/geode/pull/5637#discussion_r520057405", "createdAt": "2020-11-09T19:13:12Z", "author": {"login": "jchen21"}, "path": "geode-connectors/src/test/java/org/apache/geode/connectors/jdbc/internal/cli/CreateMappingPreconditionCheckFunctionTest.java", "diffHunk": "@@ -306,45 +292,10 @@ public void executeFunctionThrowsGivenPdxSerializableWithNoZeroArgConstructor()\n             \"Could not generate a PdxType for the class org.apache.geode.connectors.jdbc.internal.cli.CreateMappingPreconditionCheckFunctionTest$PdxClassDummyNoZeroArg because it did not have a public zero arg constructor. Details: java.lang.NoSuchMethodException: org.apache.geode.connectors.jdbc.internal.cli.CreateMappingPreconditionCheckFunctionTest$PdxClassDummyNoZeroArg.<init>()\");\n   }\n \n-  @Test", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczNDI0MQ=="}, "originalCommit": {"oid": "784f29f1ae07e98fb6cf39bd95718b8cc05cf726"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA4OTE5NA==", "bodyText": "This is an integration test, which tests the behavior of gfsh commands from a user's point view. I don't think this test should use internal functions of specific gfsh command's implementation. The users should not worry about the gfsh implementation.\nAnd I don't recommend using a lot of System.out.println in the tests. Is that for debugging purpose?\nIf you have to use internal functions, I would recommend testing them in a unit test, or some other integration test or dunit that specifically test a specific gfsh command.  You said you use the internal functions because some parts of GfshRule can not verify in case of errors. Can you give a specific example?", "url": "https://github.com/apache/geode/pull/5637#discussion_r520089194", "createdAt": "2020-11-09T20:08:55Z", "author": {"login": "jchen21"}, "path": "geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/GfshJdbcMappingIntegrationTest.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.connectors.jdbc;\n+\n+import java.lang.reflect.Constructor;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.geode.cache.CacheFactory;\n+import org.apache.geode.cache.configuration.JndiBindingsType;\n+import org.apache.geode.cache.configuration.RegionConfig;\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.ResultCollector;\n+import org.apache.geode.connectors.jdbc.internal.cli.CreateMappingFunction;\n+import org.apache.geode.connectors.jdbc.internal.cli.CreateMappingPreconditionCheckFunction;\n+import org.apache.geode.connectors.jdbc.internal.configuration.FieldMapping;\n+import org.apache.geode.connectors.jdbc.internal.configuration.RegionMapping;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.management.configuration.RegionType;\n+import org.apache.geode.management.internal.cli.commands.CreateJndiBindingCommand;\n+import org.apache.geode.management.internal.cli.functions.CreateJndiBindingFunction;\n+import org.apache.geode.management.internal.cli.functions.CreateRegionFunctionArgs;\n+import org.apache.geode.management.internal.cli.functions.RegionCreateFunction;\n+import org.apache.geode.management.internal.configuration.converters.RegionConverter;\n+import org.apache.geode.management.internal.functions.CliFunctionResult;\n+import org.apache.geode.management.internal.util.ManagementUtils;\n+\n+public class GfshJdbcMappingIntegrationTest extends JdbcMappingIntegrationTest {\n+\n+  @Override\n+  protected InternalCache createCacheAndCreateJdbcMapping(String cacheXmlTestName)\n+      throws Exception {\n+    InternalCache cache =\n+        (InternalCache) new CacheFactory().set(\"locators\", \"\").set(\"mcast-port\", \"0\").create();\n+    Set<DistributedMember> targetMembers = findMembers(cache, null, null);\n+\n+    CliFunctionResult createRegionFuncResult = executeCreateRegionFunction(targetMembers);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxMzIxNw=="}, "originalCommit": {"oid": "784f29f1ae07e98fb6cf39bd95718b8cc05cf726"}, "originalPosition": 52}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1ODM0NjM0", "url": "https://github.com/apache/geode/pull/5637#pullrequestreview-565834634", "createdAt": "2021-01-12T00:09:04Z", "commit": {"oid": "135a7797f557bbde0e89a954a79275639f5021f0"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQwMDowOTowNFrOIRsEDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQwMTowOTozN1rOIRtefg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQxODYzOQ==", "bodyText": "This is a bug. I believe the string in the quote should be WrongPdxName instead of NoPdxName. There is no such file CacheXmlJdbcMappingIntegrationTest.NoPdxName.cache.xml. So the actual error is something like FileNotFoundException returned by getXmlFileForTest(). And the assertion at line 241 and 242 doesn't really catch the bug.", "url": "https://github.com/apache/geode/pull/5637#discussion_r555418639", "createdAt": "2021-01-12T00:09:04Z", "author": {"login": "jchen21"}, "path": "geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/CacheXmlJdbcMappingIntegrationTest.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.connectors.jdbc;\n+\n+import static org.apache.geode.test.util.ResourceUtils.createTempFileFromResource;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.catchThrowable;\n+\n+import java.net.URL;\n+import java.sql.Connection;\n+import java.sql.JDBCType;\n+import java.sql.Statement;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+\n+import org.apache.geode.cache.CacheFactory;\n+import org.apache.geode.connectors.jdbc.internal.JdbcConnectorService;\n+import org.apache.geode.connectors.jdbc.internal.configuration.FieldMapping;\n+import org.apache.geode.connectors.jdbc.internal.configuration.RegionMapping;\n+import org.apache.geode.connectors.jdbc.test.junit.rules.DatabaseConnectionRule;\n+import org.apache.geode.connectors.jdbc.test.junit.rules.MySqlConnectionRule;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.jndi.JNDIInvoker;\n+import org.apache.geode.pdx.FieldType;\n+import org.apache.geode.pdx.internal.AutoSerializableManager;\n+\n+public class CacheXmlJdbcMappingIntegrationTest {\n+\n+  private static final URL COMPOSE_RESOURCE_PATH =\n+      CacheXmlJdbcMappingIntegrationTest.class.getResource(\"mysql.yml\");\n+  protected static final String DATA_SOURCE_NAME = \"TestDataSource\";\n+  protected static final String DB_NAME = \"test\";\n+  protected static final String REGION_TABLE_NAME = \"employees\";\n+  protected static final String REGION_NAME = \"Region1\";\n+\n+  @Rule\n+  public RestoreSystemProperties restoreSystemProperties = new RestoreSystemProperties();\n+\n+  private Connection connection;\n+  private Statement statement;\n+  private InternalCache cache;\n+\n+  @ClassRule\n+  public static DatabaseConnectionRule dbRule = new MySqlConnectionRule.Builder()\n+      .file(COMPOSE_RESOURCE_PATH.getPath()).serviceName(\"db\").port(3306).database(DB_NAME).build();\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    System.setProperty(AutoSerializableManager.NO_HARDCODED_EXCLUDES_PARAM, \"true\");\n+    connection = dbRule.getConnection();\n+    statement = connection.createStatement();\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    JNDIInvoker.unMapDatasource(DATA_SOURCE_NAME);\n+\n+    if (cache != null) {\n+      cache.close();\n+    }\n+\n+    if (statement == null) {\n+      statement = connection.createStatement();\n+    }\n+    statement.execute(\"Drop table IF EXISTS \" + REGION_TABLE_NAME);\n+    statement.close();\n+\n+    if (connection != null) {\n+      connection.close();\n+    }\n+  }\n+\n+  private InternalCache createCacheAndCreateJdbcMapping(String cacheXmlTestName)\n+      throws Exception {\n+    String url = dbRule.getConnectionUrl().replaceAll(\"&\", \"&amp;\");\n+    System.setProperty(\"TestDataSourceUrl\", url);\n+    InternalCache cache =\n+        (InternalCache) new CacheFactory().set(\"locators\", \"\").set(\"mcast-port\", \"0\")\n+            .set(\"cache-xml-file\", getXmlFileForTest(cacheXmlTestName))\n+            .create();\n+    return cache;\n+  }\n+\n+  private InternalCache createCacheAndCreateJdbcMappingWithNonSerializedClass(\n+      String cacheXmlTestName) throws Exception {\n+    return createCacheAndCreateJdbcMapping(cacheXmlTestName);\n+  }\n+\n+  private InternalCache createCacheAndCreateJdbcMappingWithWrongDataSource(\n+      String cacheXmlTestName) throws Exception {\n+    System.setProperty(\"TestDataSourceUrl\", \"jdbc:mysql://localhost/test\");\n+    InternalCache cache =\n+        (InternalCache) new CacheFactory().set(\"locators\", \"\").set(\"mcast-port\", \"0\")\n+            .set(\"cache-xml-file\", getXmlFileForTest(cacheXmlTestName))\n+            .create();\n+    return cache;\n+  }\n+\n+  private InternalCache createCacheAndCreateJdbcMappingWithWrongPdxName(String cacheXmlTestName)\n+      throws Exception {\n+    String url = dbRule.getConnectionUrl().replaceAll(\"&\", \"&amp;\");\n+    System.setProperty(\"TestDataSourceUrl\", url);\n+    InternalCache cache =\n+        (InternalCache) new CacheFactory().set(\"locators\", \"\").set(\"mcast-port\", \"0\")\n+            .set(\"cache-xml-file\", getXmlFileForTest(cacheXmlTestName))\n+            .create();\n+    return cache;\n+  }\n+\n+  private String getXmlFileForTest(String testName) {\n+    return createTempFileFromResource(getClass(),\n+        getClassSimpleName() + \".\" + testName + \".cache.xml\").getAbsolutePath();\n+  }\n+\n+  private String getClassSimpleName() {\n+    return getClass().getSimpleName();\n+  }\n+\n+  private void createEmployeeTable() throws Exception {\n+    statement.execute(\"Create Table \" + REGION_TABLE_NAME\n+        + \" (id varchar(10) primary key not null, name varchar(10), age int)\");\n+  }\n+\n+  private void createEmployeeTableWithColumnNamesWithUnderscores() throws Exception {\n+    statement.execute(\"Create Table \" + REGION_TABLE_NAME\n+        + \" (id varchar(10) primary key not null, _name varchar(10), _age int)\");\n+  }\n+\n+  private List<FieldMapping> getEmployeeTableFieldMappings() {\n+    List<FieldMapping> fieldMappings = Arrays.asList(\n+        new FieldMapping(\"id\", FieldType.STRING.name(), \"id\", JDBCType.VARCHAR.name(), false),\n+        new FieldMapping(\"name\", FieldType.STRING.name(), \"name\", JDBCType.VARCHAR.name(), true),\n+        new FieldMapping(\"age\", FieldType.INT.name(), \"age\", JDBCType.INTEGER.name(), true));\n+    return fieldMappings;\n+  }\n+\n+  private List<FieldMapping> getEmployeeTableColumnNameWithUnderscoresFieldMappings() {\n+    List<FieldMapping> fieldMappings = Arrays.asList(\n+        new FieldMapping(\"id\", FieldType.STRING.name(), \"id\", JDBCType.VARCHAR.name(), false),\n+        new FieldMapping(\"name\", FieldType.STRING.name(), \"_name\", JDBCType.VARCHAR.name(), true),\n+        new FieldMapping(\"age\", FieldType.INT.name(), \"_age\", JDBCType.INTEGER.name(), true));\n+    return fieldMappings;\n+  }\n+\n+  @Test\n+  public void mappingSuccessWhenFieldMappingsAreExists() throws Exception {\n+    createEmployeeTable();\n+\n+    cache = createCacheAndCreateJdbcMapping(\"FieldMappings\");\n+    JdbcConnectorService service = cache.getService(JdbcConnectorService.class);\n+\n+    RegionMapping mapping = service.getMappingForRegion(REGION_NAME);\n+    assertThat(mapping.getDataSourceName()).isEqualTo(DATA_SOURCE_NAME);\n+    assertThat(mapping.getTableName()).isEqualTo(REGION_TABLE_NAME);\n+    assertThat(mapping.getRegionName()).isEqualTo(REGION_NAME);\n+    assertThat(mapping.getPdxName()).isEqualTo(Employee.class.getName());\n+    assertThat(mapping.getIds()).isEqualTo(\"id\");\n+    assertThat(mapping.getFieldMappings().size()).isEqualTo(3);\n+    assertThat(mapping.getFieldMappings()).containsAll(getEmployeeTableFieldMappings());\n+  }\n+\n+  @Test\n+  public void mappingSuccessWhenFieldMappingsAreOmitted() throws Exception {\n+    createEmployeeTable();\n+\n+    cache = createCacheAndCreateJdbcMapping(\"NoFieldMappings\");\n+    JdbcConnectorService service = cache.getService(JdbcConnectorService.class);\n+\n+    RegionMapping mapping = service.getMappingForRegion(REGION_NAME);\n+    assertThat(mapping.getDataSourceName()).isEqualTo(DATA_SOURCE_NAME);\n+    assertThat(mapping.getTableName()).isEqualTo(REGION_TABLE_NAME);\n+    assertThat(mapping.getRegionName()).isEqualTo(REGION_NAME);\n+    assertThat(mapping.getPdxName()).isEqualTo(Employee.class.getName());\n+    assertThat(mapping.getIds()).isEqualTo(\"id\");\n+    assertThat(mapping.getFieldMappings().size()).isEqualTo(3);\n+    assertThat(mapping.getFieldMappings()).containsAll(getEmployeeTableFieldMappings());\n+  }\n+\n+  @Test\n+  public void mappingSuccessWhenFieldMappingsAreOmittedWithNonSerializedClass() throws Exception {\n+    createEmployeeTable();\n+\n+    cache = createCacheAndCreateJdbcMappingWithNonSerializedClass(\n+        \"NoFieldMappingsWithNonSerializedClass\");\n+    JdbcConnectorService service = cache.getService(JdbcConnectorService.class);\n+\n+    RegionMapping mapping = service.getMappingForRegion(REGION_NAME);\n+    assertThat(mapping.getDataSourceName()).isEqualTo(DATA_SOURCE_NAME);\n+    assertThat(mapping.getTableName()).isEqualTo(REGION_TABLE_NAME);\n+    assertThat(mapping.getRegionName()).isEqualTo(REGION_NAME);\n+    assertThat(mapping.getPdxName()).isEqualTo(NonSerializedEmployee.class.getName());\n+    assertThat(mapping.getIds()).isEqualTo(\"id\");\n+    assertThat(mapping.getFieldMappings().size()).isEqualTo(3);\n+    assertThat(mapping.getFieldMappings()).containsAll(getEmployeeTableFieldMappings());\n+  }\n+\n+  @Test\n+  public void mappingFailureWhenConnectWrongDataSource() {\n+    Throwable throwable =\n+        catchThrowable(() -> createCacheAndCreateJdbcMappingWithWrongDataSource(\"NoFieldMappings\"));\n+\n+    assertThat(throwable).isInstanceOf(JdbcConnectorException.class)\n+        .hasMessage(String.format(\"No datasource \\\"%s\\\" found when creating default field mapping\",\n+            DATA_SOURCE_NAME));\n+  }\n+\n+  @Test\n+  public void mappingFailureWhenTableNotExists() {\n+    Throwable throwable = catchThrowable(() -> createCacheAndCreateJdbcMapping(\"NoFieldMappings\"));\n+\n+    assertThat(throwable).isInstanceOf(JdbcConnectorException.class)\n+        .hasMessage(String.format(\"No table was found that matches \\\"%s\\\"\", REGION_TABLE_NAME));\n+  }\n+\n+  @Test\n+  public void mappingFailureWhenPdxNotExists() throws Exception {\n+    createEmployeeTable();\n+\n+    Throwable throwable =\n+        catchThrowable(() -> createCacheAndCreateJdbcMappingWithWrongPdxName(\"NoPdxName\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135a7797f557bbde0e89a954a79275639f5021f0"}, "originalPosition": 239}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQzNTk3Ng==", "bodyText": "This is method implementation is exactly the same as createCacheAndCreateJdbcMapping(). The only difference is the method name. So how about just using createCacheAndCreateJdbcMapping()?", "url": "https://github.com/apache/geode/pull/5637#discussion_r555435976", "createdAt": "2021-01-12T00:50:24Z", "author": {"login": "jchen21"}, "path": "geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/CacheXmlJdbcMappingIntegrationTest.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.connectors.jdbc;\n+\n+import static org.apache.geode.test.util.ResourceUtils.createTempFileFromResource;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.catchThrowable;\n+\n+import java.net.URL;\n+import java.sql.Connection;\n+import java.sql.JDBCType;\n+import java.sql.Statement;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+\n+import org.apache.geode.cache.CacheFactory;\n+import org.apache.geode.connectors.jdbc.internal.JdbcConnectorService;\n+import org.apache.geode.connectors.jdbc.internal.configuration.FieldMapping;\n+import org.apache.geode.connectors.jdbc.internal.configuration.RegionMapping;\n+import org.apache.geode.connectors.jdbc.test.junit.rules.DatabaseConnectionRule;\n+import org.apache.geode.connectors.jdbc.test.junit.rules.MySqlConnectionRule;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.jndi.JNDIInvoker;\n+import org.apache.geode.pdx.FieldType;\n+import org.apache.geode.pdx.internal.AutoSerializableManager;\n+\n+public class CacheXmlJdbcMappingIntegrationTest {\n+\n+  private static final URL COMPOSE_RESOURCE_PATH =\n+      CacheXmlJdbcMappingIntegrationTest.class.getResource(\"mysql.yml\");\n+  protected static final String DATA_SOURCE_NAME = \"TestDataSource\";\n+  protected static final String DB_NAME = \"test\";\n+  protected static final String REGION_TABLE_NAME = \"employees\";\n+  protected static final String REGION_NAME = \"Region1\";\n+\n+  @Rule\n+  public RestoreSystemProperties restoreSystemProperties = new RestoreSystemProperties();\n+\n+  private Connection connection;\n+  private Statement statement;\n+  private InternalCache cache;\n+\n+  @ClassRule\n+  public static DatabaseConnectionRule dbRule = new MySqlConnectionRule.Builder()\n+      .file(COMPOSE_RESOURCE_PATH.getPath()).serviceName(\"db\").port(3306).database(DB_NAME).build();\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    System.setProperty(AutoSerializableManager.NO_HARDCODED_EXCLUDES_PARAM, \"true\");\n+    connection = dbRule.getConnection();\n+    statement = connection.createStatement();\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    JNDIInvoker.unMapDatasource(DATA_SOURCE_NAME);\n+\n+    if (cache != null) {\n+      cache.close();\n+    }\n+\n+    if (statement == null) {\n+      statement = connection.createStatement();\n+    }\n+    statement.execute(\"Drop table IF EXISTS \" + REGION_TABLE_NAME);\n+    statement.close();\n+\n+    if (connection != null) {\n+      connection.close();\n+    }\n+  }\n+\n+  private InternalCache createCacheAndCreateJdbcMapping(String cacheXmlTestName)\n+      throws Exception {\n+    String url = dbRule.getConnectionUrl().replaceAll(\"&\", \"&amp;\");\n+    System.setProperty(\"TestDataSourceUrl\", url);\n+    InternalCache cache =\n+        (InternalCache) new CacheFactory().set(\"locators\", \"\").set(\"mcast-port\", \"0\")\n+            .set(\"cache-xml-file\", getXmlFileForTest(cacheXmlTestName))\n+            .create();\n+    return cache;\n+  }\n+\n+  private InternalCache createCacheAndCreateJdbcMappingWithNonSerializedClass(\n+      String cacheXmlTestName) throws Exception {\n+    return createCacheAndCreateJdbcMapping(cacheXmlTestName);\n+  }\n+\n+  private InternalCache createCacheAndCreateJdbcMappingWithWrongDataSource(\n+      String cacheXmlTestName) throws Exception {\n+    System.setProperty(\"TestDataSourceUrl\", \"jdbc:mysql://localhost/test\");\n+    InternalCache cache =\n+        (InternalCache) new CacheFactory().set(\"locators\", \"\").set(\"mcast-port\", \"0\")\n+            .set(\"cache-xml-file\", getXmlFileForTest(cacheXmlTestName))\n+            .create();\n+    return cache;\n+  }\n+\n+  private InternalCache createCacheAndCreateJdbcMappingWithWrongPdxName(String cacheXmlTestName)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135a7797f557bbde0e89a954a79275639f5021f0"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQzNjQwMw==", "bodyText": "This throws Exception can be removed. The same for line 93, 109 and 119.", "url": "https://github.com/apache/geode/pull/5637#discussion_r555436403", "createdAt": "2021-01-12T00:52:02Z", "author": {"login": "jchen21"}, "path": "geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/CacheXmlJdbcMappingIntegrationTest.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.connectors.jdbc;\n+\n+import static org.apache.geode.test.util.ResourceUtils.createTempFileFromResource;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.catchThrowable;\n+\n+import java.net.URL;\n+import java.sql.Connection;\n+import java.sql.JDBCType;\n+import java.sql.Statement;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+\n+import org.apache.geode.cache.CacheFactory;\n+import org.apache.geode.connectors.jdbc.internal.JdbcConnectorService;\n+import org.apache.geode.connectors.jdbc.internal.configuration.FieldMapping;\n+import org.apache.geode.connectors.jdbc.internal.configuration.RegionMapping;\n+import org.apache.geode.connectors.jdbc.test.junit.rules.DatabaseConnectionRule;\n+import org.apache.geode.connectors.jdbc.test.junit.rules.MySqlConnectionRule;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.jndi.JNDIInvoker;\n+import org.apache.geode.pdx.FieldType;\n+import org.apache.geode.pdx.internal.AutoSerializableManager;\n+\n+public class CacheXmlJdbcMappingIntegrationTest {\n+\n+  private static final URL COMPOSE_RESOURCE_PATH =\n+      CacheXmlJdbcMappingIntegrationTest.class.getResource(\"mysql.yml\");\n+  protected static final String DATA_SOURCE_NAME = \"TestDataSource\";\n+  protected static final String DB_NAME = \"test\";\n+  protected static final String REGION_TABLE_NAME = \"employees\";\n+  protected static final String REGION_NAME = \"Region1\";\n+\n+  @Rule\n+  public RestoreSystemProperties restoreSystemProperties = new RestoreSystemProperties();\n+\n+  private Connection connection;\n+  private Statement statement;\n+  private InternalCache cache;\n+\n+  @ClassRule\n+  public static DatabaseConnectionRule dbRule = new MySqlConnectionRule.Builder()\n+      .file(COMPOSE_RESOURCE_PATH.getPath()).serviceName(\"db\").port(3306).database(DB_NAME).build();\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    System.setProperty(AutoSerializableManager.NO_HARDCODED_EXCLUDES_PARAM, \"true\");\n+    connection = dbRule.getConnection();\n+    statement = connection.createStatement();\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    JNDIInvoker.unMapDatasource(DATA_SOURCE_NAME);\n+\n+    if (cache != null) {\n+      cache.close();\n+    }\n+\n+    if (statement == null) {\n+      statement = connection.createStatement();\n+    }\n+    statement.execute(\"Drop table IF EXISTS \" + REGION_TABLE_NAME);\n+    statement.close();\n+\n+    if (connection != null) {\n+      connection.close();\n+    }\n+  }\n+\n+  private InternalCache createCacheAndCreateJdbcMapping(String cacheXmlTestName)\n+      throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135a7797f557bbde0e89a954a79275639f5021f0"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQzNjY3NQ==", "bodyText": "I would recommend inline this one-line implementation for readability of code.", "url": "https://github.com/apache/geode/pull/5637#discussion_r555436675", "createdAt": "2021-01-12T00:52:54Z", "author": {"login": "jchen21"}, "path": "geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/CacheXmlJdbcMappingIntegrationTest.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.connectors.jdbc;\n+\n+import static org.apache.geode.test.util.ResourceUtils.createTempFileFromResource;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.catchThrowable;\n+\n+import java.net.URL;\n+import java.sql.Connection;\n+import java.sql.JDBCType;\n+import java.sql.Statement;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+\n+import org.apache.geode.cache.CacheFactory;\n+import org.apache.geode.connectors.jdbc.internal.JdbcConnectorService;\n+import org.apache.geode.connectors.jdbc.internal.configuration.FieldMapping;\n+import org.apache.geode.connectors.jdbc.internal.configuration.RegionMapping;\n+import org.apache.geode.connectors.jdbc.test.junit.rules.DatabaseConnectionRule;\n+import org.apache.geode.connectors.jdbc.test.junit.rules.MySqlConnectionRule;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.jndi.JNDIInvoker;\n+import org.apache.geode.pdx.FieldType;\n+import org.apache.geode.pdx.internal.AutoSerializableManager;\n+\n+public class CacheXmlJdbcMappingIntegrationTest {\n+\n+  private static final URL COMPOSE_RESOURCE_PATH =\n+      CacheXmlJdbcMappingIntegrationTest.class.getResource(\"mysql.yml\");\n+  protected static final String DATA_SOURCE_NAME = \"TestDataSource\";\n+  protected static final String DB_NAME = \"test\";\n+  protected static final String REGION_TABLE_NAME = \"employees\";\n+  protected static final String REGION_NAME = \"Region1\";\n+\n+  @Rule\n+  public RestoreSystemProperties restoreSystemProperties = new RestoreSystemProperties();\n+\n+  private Connection connection;\n+  private Statement statement;\n+  private InternalCache cache;\n+\n+  @ClassRule\n+  public static DatabaseConnectionRule dbRule = new MySqlConnectionRule.Builder()\n+      .file(COMPOSE_RESOURCE_PATH.getPath()).serviceName(\"db\").port(3306).database(DB_NAME).build();\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    System.setProperty(AutoSerializableManager.NO_HARDCODED_EXCLUDES_PARAM, \"true\");\n+    connection = dbRule.getConnection();\n+    statement = connection.createStatement();\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    JNDIInvoker.unMapDatasource(DATA_SOURCE_NAME);\n+\n+    if (cache != null) {\n+      cache.close();\n+    }\n+\n+    if (statement == null) {\n+      statement = connection.createStatement();\n+    }\n+    statement.execute(\"Drop table IF EXISTS \" + REGION_TABLE_NAME);\n+    statement.close();\n+\n+    if (connection != null) {\n+      connection.close();\n+    }\n+  }\n+\n+  private InternalCache createCacheAndCreateJdbcMapping(String cacheXmlTestName)\n+      throws Exception {\n+    String url = dbRule.getConnectionUrl().replaceAll(\"&\", \"&amp;\");\n+    System.setProperty(\"TestDataSourceUrl\", url);\n+    InternalCache cache =\n+        (InternalCache) new CacheFactory().set(\"locators\", \"\").set(\"mcast-port\", \"0\")\n+            .set(\"cache-xml-file\", getXmlFileForTest(cacheXmlTestName))\n+            .create();\n+    return cache;\n+  }\n+\n+  private InternalCache createCacheAndCreateJdbcMappingWithNonSerializedClass(\n+      String cacheXmlTestName) throws Exception {\n+    return createCacheAndCreateJdbcMapping(cacheXmlTestName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135a7797f557bbde0e89a954a79275639f5021f0"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQ0MTc5MA==", "bodyText": "The regionMapping argument is not used, and can be removed.", "url": "https://github.com/apache/geode/pull/5637#discussion_r555441790", "createdAt": "2021-01-12T01:09:37Z", "author": {"login": "jchen21"}, "path": "geode-connectors/src/main/java/org/apache/geode/connectors/jdbc/internal/xml/RegionMappingConfiguration.java", "diffHunk": "@@ -62,4 +96,159 @@ private void createRegionMapping(JdbcConnectorService service,\n       throw new InternalGemFireException(e);\n     }\n   }\n+\n+  protected List<FieldMapping> createDefaultFieldMapping(RegionMapping regionMapping,\n+      PdxType pdxType) {\n+    DataSource dataSource = getDataSource(regionMapping.getDataSourceName());\n+    if (dataSource == null) {\n+      throw new JdbcConnectorException(\"No datasource \\\"\" + regionMapping.getDataSourceName()\n+          + \"\\\" found when creating default field mapping\");\n+    }\n+    TableMetaDataManager manager = getTableMetaDataManager();\n+    try (Connection connection = dataSource.getConnection()) {\n+      TableMetaDataView tableMetaData = manager.getTableMetaDataView(connection, regionMapping);\n+      return createDefaultFieldMapping(regionMapping, pdxType, tableMetaData);\n+    } catch (SQLException e) {\n+      throw JdbcConnectorException.createException(e);\n+    }\n+  }\n+\n+  private List<FieldMapping> createDefaultFieldMapping(RegionMapping regionMapping,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135a7797f557bbde0e89a954a79275639f5021f0"}, "originalPosition": 80}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY4NjA0Mzg4", "url": "https://github.com/apache/geode/pull/5637#pullrequestreview-568604388", "createdAt": "2021-01-14T20:33:45Z", "commit": {"oid": "08362f8dd3b4095c37d91ca2a0204ed05ccaf7a6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f4aa56eb6eb1a0090fc0122b39dbbc8fae532b4", "author": {"user": {"login": "masaki-yamakawa", "name": "Masaki Yamakawa"}}, "url": "https://github.com/apache/geode/commit/5f4aa56eb6eb1a0090fc0122b39dbbc8fae532b4", "committedDate": "2021-01-14T22:31:08Z", "message": "GEODE-8626: Omitting field-mapping tag of cache.xml when using Simple JDBC Connector\n\nUse the default mapping when using the Simple JDBC Connector in cache.xml and without the field-mapping tag"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "08362f8dd3b4095c37d91ca2a0204ed05ccaf7a6", "author": {"user": {"login": "masaki-yamakawa", "name": "Masaki Yamakawa"}}, "url": "https://github.com/apache/geode/commit/08362f8dd3b4095c37d91ca2a0204ed05ccaf7a6", "committedDate": "2021-01-14T02:03:26Z", "message": "Apply spotlessJava:CacheXmlJdbcMappingIntegrationTest"}, "afterCommit": {"oid": "5f4aa56eb6eb1a0090fc0122b39dbbc8fae532b4", "author": {"user": {"login": "masaki-yamakawa", "name": "Masaki Yamakawa"}}, "url": "https://github.com/apache/geode/commit/5f4aa56eb6eb1a0090fc0122b39dbbc8fae532b4", "committedDate": "2021-01-14T22:31:08Z", "message": "GEODE-8626: Omitting field-mapping tag of cache.xml when using Simple JDBC Connector\n\nUse the default mapping when using the Simple JDBC Connector in cache.xml and without the field-mapping tag"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5NTc2MDEx", "url": "https://github.com/apache/geode/pull/5637#pullrequestreview-579576011", "createdAt": "2021-01-29T19:57:35Z", "commit": {"oid": "5f4aa56eb6eb1a0090fc0122b39dbbc8fae532b4"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd326746ef0778a781af03d103bfba662bae2ea8", "author": {"user": {"login": "masaki-yamakawa", "name": "Masaki Yamakawa"}}, "url": "https://github.com/apache/geode/commit/fd326746ef0778a781af03d103bfba662bae2ea8", "committedDate": "2021-06-12T11:34:00Z", "message": "Merge branch 'develop' into feature/GEODE-8626"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e29918ce27e172859148f24f59f59e59e0b18f91", "author": {"user": {"login": "masaki-yamakawa", "name": "Masaki Yamakawa"}}, "url": "https://github.com/apache/geode/commit/e29918ce27e172859148f24f59f59e59e0b18f91", "committedDate": "2021-06-13T08:05:10Z", "message": "Move some methods of CreateMappingPreconditionCheckFunction class to JdbcConnectorServiceImpl class"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjkwOTY4MTgw", "url": "https://github.com/apache/geode/pull/5637#pullrequestreview-690968180", "createdAt": "2021-06-23T17:46:42Z", "commit": {"oid": "e29918ce27e172859148f24f59f59e59e0b18f91"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk2NDM2NTk3", "url": "https://github.com/apache/geode/pull/5637#pullrequestreview-696436597", "createdAt": "2021-06-30T17:23:09Z", "commit": {"oid": "e29918ce27e172859148f24f59f59e59e0b18f91"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4119, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}