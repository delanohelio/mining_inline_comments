{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEwMDY3MzUx", "number": 5670, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMzoyNDozOVrOE6Rwqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMzo0MjowNlrOE6SBiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NTQzODUwOnYy", "diffSide": "RIGHT", "path": "geode-assembly/src/acceptanceTest/java/org/apache/geode/cache/wan/SeveralGatewayReceiversWithSamePortAndHostnameForSenders.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMzoyNDozOVrOH1Pmkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMzoyNDozOVrOH1Pmkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU5MjIxMA==", "bodyText": "I don't know if it's a rule or not but the names of literally all of the other unit test classes in the Geode repository end with \"Test\", so maybe this could be SeveralGatewayReceiversWithSamePortAndHostnameForSendersTest.", "url": "https://github.com/apache/geode/pull/5670#discussion_r525592210", "createdAt": "2020-11-17T23:24:39Z", "author": {"login": "bschuchardt"}, "path": "geode-assembly/src/acceptanceTest/java/org/apache/geode/cache/wan/SeveralGatewayReceiversWithSamePortAndHostnameForSenders.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.cache.wan;\n+\n+import static com.palantir.docker.compose.execution.DockerComposeExecArgument.arguments;\n+import static com.palantir.docker.compose.execution.DockerComposeExecOption.options;\n+import static org.apache.geode.cache.Region.SEPARATOR;\n+import static org.apache.geode.distributed.ConfigurationProperties.DISTRIBUTED_SYSTEM_ID;\n+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.REMOTE_LOCATORS;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+import java.io.File;\n+import java.net.URL;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.StringTokenizer;\n+\n+import com.palantir.docker.compose.DockerComposeRule;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheFactory;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionFactory;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.persistence.PartitionOfflineException;\n+import org.apache.geode.client.sni.NotOnWindowsDockerRule;\n+import org.apache.geode.distributed.Locator;\n+import org.apache.geode.internal.cache.ForceReattemptException;\n+import org.apache.geode.internal.cache.PoolStats;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.InternalGatewaySenderFactory;\n+import org.apache.geode.test.dunit.IgnoredException;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+import org.apache.geode.test.junit.categories.WanTest;\n+\n+\n+/**\n+ * These tests use two Geode sites:\n+ *\n+ * - One site (the remote one) consisting of a 2-server, 1-locator Geode cluster.\n+ * The servers host a partition region (region-wan) and have gateway senders to receive events\n+ * from the other site with the same value for hostname-for-senders and listening on the\n+ * same port (2324).\n+ * The servers and locator run each inside a Docker container and are not route-able\n+ * from the host (where this JUnit test is running).\n+ * Another Docker container is running the HAProxy image and it's set up as a TCP load balancer.\n+ * The other site connects to the locator and to the gateway receivers via the\n+ * TCP load balancer that forwards traffic directed to the 20334 port to the locator and\n+ * traffic directed to the 2324 port to the receivers in a round robin fashion.\n+ *\n+ * - Another site consisting of a 1-server, 1-locator Geode cluster.\n+ * The server hosts a partition region (region-wan) and has a parallel gateway receiver\n+ * to send events to the remote site.\n+ *\n+ * The aim of the tests is verify that when several gateway receivers in a remote site\n+ * share the same port and hostname-for-senders, the pings sent from the gateway senders\n+ * reach the right gateway receiver and not just any of the receivers. Failure to do this\n+ * may result in the closing of connections by a gateway receiver for not having\n+ * received the ping in time.\n+ */\n+@Category({WanTest.class})\n+public class SeveralGatewayReceiversWithSamePortAndHostnameForSenders {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ccb5120d0ae0002f3bd228c199ded7fdb659f75"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NTQ1MDc1OnYy", "diffSide": "RIGHT", "path": "geode-assembly/src/acceptanceTest/java/org/apache/geode/cache/wan/SeveralGatewayReceiversWithSamePortAndHostnameForSenders.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMzoyOToyM1rOH1PtqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMzoyOToyM1rOH1PtqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU5NDAyNA==", "bodyText": "While Intellij Idea likes to generate this kind of code it isn't useful when there's a failure.\nGet rid of the try/catch and add a \"throws\" to the test method instead.", "url": "https://github.com/apache/geode/pull/5670#discussion_r525594024", "createdAt": "2020-11-17T23:29:23Z", "author": {"login": "bschuchardt"}, "path": "geode-assembly/src/acceptanceTest/java/org/apache/geode/cache/wan/SeveralGatewayReceiversWithSamePortAndHostnameForSenders.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.cache.wan;\n+\n+import static com.palantir.docker.compose.execution.DockerComposeExecArgument.arguments;\n+import static com.palantir.docker.compose.execution.DockerComposeExecOption.options;\n+import static org.apache.geode.cache.Region.SEPARATOR;\n+import static org.apache.geode.distributed.ConfigurationProperties.DISTRIBUTED_SYSTEM_ID;\n+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.REMOTE_LOCATORS;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+import java.io.File;\n+import java.net.URL;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.StringTokenizer;\n+\n+import com.palantir.docker.compose.DockerComposeRule;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheFactory;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionFactory;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.persistence.PartitionOfflineException;\n+import org.apache.geode.client.sni.NotOnWindowsDockerRule;\n+import org.apache.geode.distributed.Locator;\n+import org.apache.geode.internal.cache.ForceReattemptException;\n+import org.apache.geode.internal.cache.PoolStats;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.InternalGatewaySenderFactory;\n+import org.apache.geode.test.dunit.IgnoredException;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+import org.apache.geode.test.junit.categories.WanTest;\n+\n+\n+/**\n+ * These tests use two Geode sites:\n+ *\n+ * - One site (the remote one) consisting of a 2-server, 1-locator Geode cluster.\n+ * The servers host a partition region (region-wan) and have gateway senders to receive events\n+ * from the other site with the same value for hostname-for-senders and listening on the\n+ * same port (2324).\n+ * The servers and locator run each inside a Docker container and are not route-able\n+ * from the host (where this JUnit test is running).\n+ * Another Docker container is running the HAProxy image and it's set up as a TCP load balancer.\n+ * The other site connects to the locator and to the gateway receivers via the\n+ * TCP load balancer that forwards traffic directed to the 20334 port to the locator and\n+ * traffic directed to the 2324 port to the receivers in a round robin fashion.\n+ *\n+ * - Another site consisting of a 1-server, 1-locator Geode cluster.\n+ * The server hosts a partition region (region-wan) and has a parallel gateway receiver\n+ * to send events to the remote site.\n+ *\n+ * The aim of the tests is verify that when several gateway receivers in a remote site\n+ * share the same port and hostname-for-senders, the pings sent from the gateway senders\n+ * reach the right gateway receiver and not just any of the receivers. Failure to do this\n+ * may result in the closing of connections by a gateway receiver for not having\n+ * received the ping in time.\n+ */\n+@Category({WanTest.class})\n+public class SeveralGatewayReceiversWithSamePortAndHostnameForSenders {\n+\n+  private static final int NUM_SERVERS = 2;\n+\n+  private static Cache cache;\n+\n+  private static final URL DOCKER_COMPOSE_PATH =\n+      SeveralGatewayReceiversWithSamePortAndHostnameForSenders.class\n+          .getResource(\"docker-compose.yml\");\n+\n+  // Docker compose does not work on windows in CI. Ignore this test on windows\n+  // Using a RuleChain to make sure we ignore the test before the rule comes into play\n+  @ClassRule\n+  public static NotOnWindowsDockerRule docker =\n+      new NotOnWindowsDockerRule(() -> DockerComposeRule.builder()\n+          .file(DOCKER_COMPOSE_PATH.getPath()).build());\n+\n+  @Rule\n+  public DistributedRule distributedRule =\n+      DistributedRule.builder().withVMCount(NUM_SERVERS + 1).build();\n+\n+  @BeforeClass\n+  public static void beforeClass() throws Exception {\n+    // Start locator\n+    docker.get().exec(options(\"-T\"), \"locator\",\n+        arguments(\"gfsh\", \"run\", \"--file=/geode/scripts/geode-starter-locator.gfsh\"));\n+    // Start server1\n+    docker.get().exec(options(\"-T\"), \"server1\",\n+        arguments(\"gfsh\", \"run\", \"--file=/geode/scripts/geode-starter-server1.gfsh\"));\n+    // Start server2\n+    docker.get().exec(options(\"-T\"), \"server2\",\n+        arguments(\"gfsh\", \"run\", \"--file=/geode/scripts/geode-starter-server2.gfsh\"));\n+    // Create partition region and gateway receiver\n+    docker.get().exec(options(\"-T\"), \"locator\",\n+        arguments(\"gfsh\", \"run\", \"--file=/geode/scripts/geode-starter-create.gfsh\"));\n+  }\n+\n+  public SeveralGatewayReceiversWithSamePortAndHostnameForSenders() {\n+    super();\n+  }\n+\n+  @Test\n+  public void testPingsToReceiversWithSamePortAndHostnameForSendersReachTheRightReceivers() {\n+    String senderId = \"ln\";\n+    String regionName = \"region-wan\";\n+    final int remoteLocPort = 20334;\n+\n+    int locPort = createLocator(VM.getVM(0), 1, remoteLocPort);\n+\n+    VM vm1 = VM.getVM(1);\n+    createCache(vm1, locPort);\n+\n+    // We must use more than one dispatcher thread. With just one dispatcher thread, only one\n+    // connection will be created by the sender towards one of the receivers and it will be\n+    // monitored by the one ping thread for that remote receiver.\n+    // With more than one thread, several connections will be opened and there should be one ping\n+    // thread per remote receiver.\n+    createGatewaySender(vm1, senderId, 2, true, 5,\n+        5, GatewaySender.DEFAULT_ORDER_POLICY);\n+\n+    createPartitionedRegion(vm1, regionName, senderId, 0, 10);\n+\n+    int NUM_PUTS = 10;\n+\n+    putKeyValues(vm1, NUM_PUTS, regionName);\n+\n+    // Wait longer than the value set in the receivers for\n+    // maximum-time-between-pings (60000) to verify that connections are not closed\n+    // by the receivers because each has received the pings timely.\n+    int maxTimeBetweenPingsInReceiver = 65000;\n+    try {\n+      Thread.sleep(maxTimeBetweenPingsInReceiver);\n+    } catch (InterruptedException e) {\n+      e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ccb5120d0ae0002f3bd228c199ded7fdb659f75"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NTQ1MjIwOnYy", "diffSide": "RIGHT", "path": "geode-assembly/src/acceptanceTest/java/org/apache/geode/cache/wan/SeveralGatewayReceiversWithSamePortAndHostnameForSenders.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMzoyOTo1M1rOH1PugA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwNzoxNDo1MVrOH2PhZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU5NDI0MA==", "bodyText": "can the max be shortened so that this test doesn't take so long to run?", "url": "https://github.com/apache/geode/pull/5670#discussion_r525594240", "createdAt": "2020-11-17T23:29:53Z", "author": {"login": "bschuchardt"}, "path": "geode-assembly/src/acceptanceTest/java/org/apache/geode/cache/wan/SeveralGatewayReceiversWithSamePortAndHostnameForSenders.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.cache.wan;\n+\n+import static com.palantir.docker.compose.execution.DockerComposeExecArgument.arguments;\n+import static com.palantir.docker.compose.execution.DockerComposeExecOption.options;\n+import static org.apache.geode.cache.Region.SEPARATOR;\n+import static org.apache.geode.distributed.ConfigurationProperties.DISTRIBUTED_SYSTEM_ID;\n+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.REMOTE_LOCATORS;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+import java.io.File;\n+import java.net.URL;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.StringTokenizer;\n+\n+import com.palantir.docker.compose.DockerComposeRule;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheFactory;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionFactory;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.persistence.PartitionOfflineException;\n+import org.apache.geode.client.sni.NotOnWindowsDockerRule;\n+import org.apache.geode.distributed.Locator;\n+import org.apache.geode.internal.cache.ForceReattemptException;\n+import org.apache.geode.internal.cache.PoolStats;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.InternalGatewaySenderFactory;\n+import org.apache.geode.test.dunit.IgnoredException;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+import org.apache.geode.test.junit.categories.WanTest;\n+\n+\n+/**\n+ * These tests use two Geode sites:\n+ *\n+ * - One site (the remote one) consisting of a 2-server, 1-locator Geode cluster.\n+ * The servers host a partition region (region-wan) and have gateway senders to receive events\n+ * from the other site with the same value for hostname-for-senders and listening on the\n+ * same port (2324).\n+ * The servers and locator run each inside a Docker container and are not route-able\n+ * from the host (where this JUnit test is running).\n+ * Another Docker container is running the HAProxy image and it's set up as a TCP load balancer.\n+ * The other site connects to the locator and to the gateway receivers via the\n+ * TCP load balancer that forwards traffic directed to the 20334 port to the locator and\n+ * traffic directed to the 2324 port to the receivers in a round robin fashion.\n+ *\n+ * - Another site consisting of a 1-server, 1-locator Geode cluster.\n+ * The server hosts a partition region (region-wan) and has a parallel gateway receiver\n+ * to send events to the remote site.\n+ *\n+ * The aim of the tests is verify that when several gateway receivers in a remote site\n+ * share the same port and hostname-for-senders, the pings sent from the gateway senders\n+ * reach the right gateway receiver and not just any of the receivers. Failure to do this\n+ * may result in the closing of connections by a gateway receiver for not having\n+ * received the ping in time.\n+ */\n+@Category({WanTest.class})\n+public class SeveralGatewayReceiversWithSamePortAndHostnameForSenders {\n+\n+  private static final int NUM_SERVERS = 2;\n+\n+  private static Cache cache;\n+\n+  private static final URL DOCKER_COMPOSE_PATH =\n+      SeveralGatewayReceiversWithSamePortAndHostnameForSenders.class\n+          .getResource(\"docker-compose.yml\");\n+\n+  // Docker compose does not work on windows in CI. Ignore this test on windows\n+  // Using a RuleChain to make sure we ignore the test before the rule comes into play\n+  @ClassRule\n+  public static NotOnWindowsDockerRule docker =\n+      new NotOnWindowsDockerRule(() -> DockerComposeRule.builder()\n+          .file(DOCKER_COMPOSE_PATH.getPath()).build());\n+\n+  @Rule\n+  public DistributedRule distributedRule =\n+      DistributedRule.builder().withVMCount(NUM_SERVERS + 1).build();\n+\n+  @BeforeClass\n+  public static void beforeClass() throws Exception {\n+    // Start locator\n+    docker.get().exec(options(\"-T\"), \"locator\",\n+        arguments(\"gfsh\", \"run\", \"--file=/geode/scripts/geode-starter-locator.gfsh\"));\n+    // Start server1\n+    docker.get().exec(options(\"-T\"), \"server1\",\n+        arguments(\"gfsh\", \"run\", \"--file=/geode/scripts/geode-starter-server1.gfsh\"));\n+    // Start server2\n+    docker.get().exec(options(\"-T\"), \"server2\",\n+        arguments(\"gfsh\", \"run\", \"--file=/geode/scripts/geode-starter-server2.gfsh\"));\n+    // Create partition region and gateway receiver\n+    docker.get().exec(options(\"-T\"), \"locator\",\n+        arguments(\"gfsh\", \"run\", \"--file=/geode/scripts/geode-starter-create.gfsh\"));\n+  }\n+\n+  public SeveralGatewayReceiversWithSamePortAndHostnameForSenders() {\n+    super();\n+  }\n+\n+  @Test\n+  public void testPingsToReceiversWithSamePortAndHostnameForSendersReachTheRightReceivers() {\n+    String senderId = \"ln\";\n+    String regionName = \"region-wan\";\n+    final int remoteLocPort = 20334;\n+\n+    int locPort = createLocator(VM.getVM(0), 1, remoteLocPort);\n+\n+    VM vm1 = VM.getVM(1);\n+    createCache(vm1, locPort);\n+\n+    // We must use more than one dispatcher thread. With just one dispatcher thread, only one\n+    // connection will be created by the sender towards one of the receivers and it will be\n+    // monitored by the one ping thread for that remote receiver.\n+    // With more than one thread, several connections will be opened and there should be one ping\n+    // thread per remote receiver.\n+    createGatewaySender(vm1, senderId, 2, true, 5,\n+        5, GatewaySender.DEFAULT_ORDER_POLICY);\n+\n+    createPartitionedRegion(vm1, regionName, senderId, 0, 10);\n+\n+    int NUM_PUTS = 10;\n+\n+    putKeyValues(vm1, NUM_PUTS, regionName);\n+\n+    // Wait longer than the value set in the receivers for\n+    // maximum-time-between-pings (60000) to verify that connections are not closed\n+    // by the receivers because each has received the pings timely.\n+    int maxTimeBetweenPingsInReceiver = 65000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ccb5120d0ae0002f3bd228c199ded7fdb659f75"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjYzOTQ2Mw==", "bodyText": "It was not possible before the fix for #5701 but as that is now in place, I have been able to reduce the max to 15 secs.", "url": "https://github.com/apache/geode/pull/5670#discussion_r526639463", "createdAt": "2020-11-19T07:14:51Z", "author": {"login": "albertogpz"}, "path": "geode-assembly/src/acceptanceTest/java/org/apache/geode/cache/wan/SeveralGatewayReceiversWithSamePortAndHostnameForSenders.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.cache.wan;\n+\n+import static com.palantir.docker.compose.execution.DockerComposeExecArgument.arguments;\n+import static com.palantir.docker.compose.execution.DockerComposeExecOption.options;\n+import static org.apache.geode.cache.Region.SEPARATOR;\n+import static org.apache.geode.distributed.ConfigurationProperties.DISTRIBUTED_SYSTEM_ID;\n+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.REMOTE_LOCATORS;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+import java.io.File;\n+import java.net.URL;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.StringTokenizer;\n+\n+import com.palantir.docker.compose.DockerComposeRule;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.CacheFactory;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionFactory;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.persistence.PartitionOfflineException;\n+import org.apache.geode.client.sni.NotOnWindowsDockerRule;\n+import org.apache.geode.distributed.Locator;\n+import org.apache.geode.internal.cache.ForceReattemptException;\n+import org.apache.geode.internal.cache.PoolStats;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.InternalGatewaySenderFactory;\n+import org.apache.geode.test.dunit.IgnoredException;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+import org.apache.geode.test.junit.categories.WanTest;\n+\n+\n+/**\n+ * These tests use two Geode sites:\n+ *\n+ * - One site (the remote one) consisting of a 2-server, 1-locator Geode cluster.\n+ * The servers host a partition region (region-wan) and have gateway senders to receive events\n+ * from the other site with the same value for hostname-for-senders and listening on the\n+ * same port (2324).\n+ * The servers and locator run each inside a Docker container and are not route-able\n+ * from the host (where this JUnit test is running).\n+ * Another Docker container is running the HAProxy image and it's set up as a TCP load balancer.\n+ * The other site connects to the locator and to the gateway receivers via the\n+ * TCP load balancer that forwards traffic directed to the 20334 port to the locator and\n+ * traffic directed to the 2324 port to the receivers in a round robin fashion.\n+ *\n+ * - Another site consisting of a 1-server, 1-locator Geode cluster.\n+ * The server hosts a partition region (region-wan) and has a parallel gateway receiver\n+ * to send events to the remote site.\n+ *\n+ * The aim of the tests is verify that when several gateway receivers in a remote site\n+ * share the same port and hostname-for-senders, the pings sent from the gateway senders\n+ * reach the right gateway receiver and not just any of the receivers. Failure to do this\n+ * may result in the closing of connections by a gateway receiver for not having\n+ * received the ping in time.\n+ */\n+@Category({WanTest.class})\n+public class SeveralGatewayReceiversWithSamePortAndHostnameForSenders {\n+\n+  private static final int NUM_SERVERS = 2;\n+\n+  private static Cache cache;\n+\n+  private static final URL DOCKER_COMPOSE_PATH =\n+      SeveralGatewayReceiversWithSamePortAndHostnameForSenders.class\n+          .getResource(\"docker-compose.yml\");\n+\n+  // Docker compose does not work on windows in CI. Ignore this test on windows\n+  // Using a RuleChain to make sure we ignore the test before the rule comes into play\n+  @ClassRule\n+  public static NotOnWindowsDockerRule docker =\n+      new NotOnWindowsDockerRule(() -> DockerComposeRule.builder()\n+          .file(DOCKER_COMPOSE_PATH.getPath()).build());\n+\n+  @Rule\n+  public DistributedRule distributedRule =\n+      DistributedRule.builder().withVMCount(NUM_SERVERS + 1).build();\n+\n+  @BeforeClass\n+  public static void beforeClass() throws Exception {\n+    // Start locator\n+    docker.get().exec(options(\"-T\"), \"locator\",\n+        arguments(\"gfsh\", \"run\", \"--file=/geode/scripts/geode-starter-locator.gfsh\"));\n+    // Start server1\n+    docker.get().exec(options(\"-T\"), \"server1\",\n+        arguments(\"gfsh\", \"run\", \"--file=/geode/scripts/geode-starter-server1.gfsh\"));\n+    // Start server2\n+    docker.get().exec(options(\"-T\"), \"server2\",\n+        arguments(\"gfsh\", \"run\", \"--file=/geode/scripts/geode-starter-server2.gfsh\"));\n+    // Create partition region and gateway receiver\n+    docker.get().exec(options(\"-T\"), \"locator\",\n+        arguments(\"gfsh\", \"run\", \"--file=/geode/scripts/geode-starter-create.gfsh\"));\n+  }\n+\n+  public SeveralGatewayReceiversWithSamePortAndHostnameForSenders() {\n+    super();\n+  }\n+\n+  @Test\n+  public void testPingsToReceiversWithSamePortAndHostnameForSendersReachTheRightReceivers() {\n+    String senderId = \"ln\";\n+    String regionName = \"region-wan\";\n+    final int remoteLocPort = 20334;\n+\n+    int locPort = createLocator(VM.getVM(0), 1, remoteLocPort);\n+\n+    VM vm1 = VM.getVM(1);\n+    createCache(vm1, locPort);\n+\n+    // We must use more than one dispatcher thread. With just one dispatcher thread, only one\n+    // connection will be created by the sender towards one of the receivers and it will be\n+    // monitored by the one ping thread for that remote receiver.\n+    // With more than one thread, several connections will be opened and there should be one ping\n+    // thread per remote receiver.\n+    createGatewaySender(vm1, senderId, 2, true, 5,\n+        5, GatewaySender.DEFAULT_ORDER_POLICY);\n+\n+    createPartitionedRegion(vm1, regionName, senderId, 0, 10);\n+\n+    int NUM_PUTS = 10;\n+\n+    putKeyValues(vm1, NUM_PUTS, regionName);\n+\n+    // Wait longer than the value set in the receivers for\n+    // maximum-time-between-pings (60000) to verify that connections are not closed\n+    // by the receivers because each has received the pings timely.\n+    int maxTimeBetweenPingsInReceiver = 65000;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU5NDI0MA=="}, "originalCommit": {"oid": "6ccb5120d0ae0002f3bd228c199ded7fdb659f75"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NTQ4MTY4OnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/cache/client/internal/LiveServerPinger.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMzo0MjowNlrOH1P__w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMzo0MjowNlrOH1P__w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU5ODcxOQ==", "bodyText": "(just a comment) I see that you've moved the updateLastExecute() for PingOp to LiveServerPinger.", "url": "https://github.com/apache/geode/pull/5670#discussion_r525598719", "createdAt": "2020-11-17T23:42:06Z", "author": {"login": "bschuchardt"}, "path": "geode-core/src/main/java/org/apache/geode/cache/client/internal/LiveServerPinger.java", "diffHunk": "@@ -87,6 +87,7 @@ private void cancelFuture(Endpoint endpoint) {\n     public void run2() {\n       if (endpoint.timeToPing(pingIntervalNanos)) {\n         try {\n+          endpoint.updateLastExecute();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ccb5120d0ae0002f3bd228c199ded7fdb659f75"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4588, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}