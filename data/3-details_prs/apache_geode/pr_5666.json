{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA5Mjk1OTI0", "number": 5666, "title": "GEODE-8652: Allow NioSslEngine.close() to Bypass Locks", "bodyText": "This PR for GEODE-8652 works around the situation where a thread wants to close a Connection while other threads are reading or writing on it.\n\n\nNioSslEngine.close() proceeds even if readers (or writers) are\noperating on its ByteBuffers, allowing Connection.close() to close its\nsocket and proceed.\n\n\nNioSslEngine.close() needed a lock only on the output buffer, so\nwe split what was a single lock into two. Also instead of using\nsynchronized we use a ReentrantLock so we can\ncall tryLock() and time out if needed in NioSslEngine.close()\n\n\nSince readers/writers may hold locks on these input/output buffers\nwhen NioSslEngine.close() is called we needed to reference count\nthe buffers and return them to the pool only when the last user\nwas finished.\n\n\nTo manage the locking and reference counting a new AutoCloseable\nByteBufferSharing interface is introduced with a trivial implementation:\nByteBufferSharingNoOp and a real implementation:\nByteBufferSharingImpl.\n\n\nCo-authored-by: Bill Burcham bill.burcham@gmail.com\nCo-authored-by: Darrel Schneider dschneider@pivotal.io\nCo-authored-by: Ernie Burghardt burghardte@vmware.com\n\n\n Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?\n\n\n Has your PR been rebased against the latest commit within the target branch (typically develop)?\n\n\n Is your initial contribution a single, squashed commit?\n\n\n Does gradlew build run cleanly?\n\n\n Have you written or updated unit tests to verify your changes?", "createdAt": "2020-10-24T00:45:33Z", "url": "https://github.com/apache/geode/pull/5666", "merged": true, "mergeCommit": {"oid": "08e9e9673d0ed05555a3d74c6d16e706817cab09"}, "closed": true, "closedAt": "2020-10-29T23:38:25Z", "author": {"login": "Bill"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdWciEBgFqTUxNzIyOTc4NQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdXZ9_lAFqTUyMDEyODAwMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3MjI5Nzg1", "url": "https://github.com/apache/geode/pull/5666#pullrequestreview-517229785", "createdAt": "2020-10-26T22:45:51Z", "commit": {"oid": "bb722678b005675f9bc2d7fab6f862215fd9f987"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMjo0NTo1MVrOHolJIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMjo0NTo1MVrOHolJIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjMxMzYzNQ==", "bodyText": "no need to modify SocketCloser.java in this pr", "url": "https://github.com/apache/geode/pull/5666#discussion_r512313635", "createdAt": "2020-10-26T22:45:51Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-core/src/main/java/org/apache/geode/internal/net/SocketCloser.java", "diffHunk": "@@ -41,6 +44,7 @@\n  * This max threads can be configured using the \"p2p.ASYNC_CLOSE_POOL_MAX_THREADS\" system property.\n  */\n public class SocketCloser {\n+  private static final Logger logger = LogService.getLogger();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb722678b005675f9bc2d7fab6f862215fd9f987"}, "originalPosition": 16}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3ODMxMTE5", "url": "https://github.com/apache/geode/pull/5666#pullrequestreview-517831119", "createdAt": "2020-10-27T15:24:24Z", "commit": {"oid": "e04624cefb29974f550579c347ea601c0f9dd86e"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxNToyNDoyNFrOHpCFJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxNTo1NjoxN1rOHpD1dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc4Nzc0OA==", "bodyText": "the return value from this method is never used", "url": "https://github.com/apache/geode/pull/5666#discussion_r512787748", "createdAt": "2020-10-27T15:24:24Z", "author": {"login": "bschuchardt"}, "path": "geode-core/src/main/java/org/apache/geode/internal/net/ByteBufferSharingImpl.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.net;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.apache.geode.annotations.VisibleForTesting;\n+import org.apache.geode.internal.net.BufferPool.BufferType;\n+\n+/**\n+ * An {@link AutoCloseable} meant to be acquired in a try-with-resources statement. The resource (a\n+ * {@link ByteBuffer}) is available (for reading and modification) in the scope of the\n+ * try-with-resources.\n+ */\n+class ByteBufferSharingImpl implements ByteBufferSharing {\n+\n+  static class LockAttemptTimedOut extends Exception {\n+  }\n+\n+  private final Lock lock;\n+  private final AtomicBoolean isClosed;\n+  // mutable because in general our ByteBuffer may need to be resized (grown or compacted)\n+  private ByteBuffer buffer;\n+  private final BufferType bufferType;\n+  private final AtomicInteger counter;\n+  private final BufferPool bufferPool;\n+\n+  /**\n+   * This constructor is for use only by the owner of the shared resource (a {@link ByteBuffer}).\n+   *\n+   * A resource owner must invoke {@link #alias()} once for each reference that escapes (is passed\n+   * to an external object or is returned to an external caller.)\n+   *\n+   * This constructor acquires no lock. The reference count will be 1 after this constructor\n+   * completes.\n+   */\n+  ByteBufferSharingImpl(final ByteBuffer buffer, final BufferType bufferType,\n+      final BufferPool bufferPool) {\n+    this.buffer = buffer;\n+    this.bufferType = bufferType;\n+    this.bufferPool = bufferPool;\n+    lock = new ReentrantLock();\n+    counter = new AtomicInteger(1);\n+    isClosed = new AtomicBoolean(false);\n+  }\n+\n+  /**\n+   * The destructor. Called by the resource owner to undo the work of the constructor.\n+   */\n+  void destruct() {\n+    if (isClosed.compareAndSet(false, true)) {\n+      dropReference();\n+    }\n+  }\n+\n+  /**\n+   * This method is for use only by the owner of the shared resource. It's used for handing out\n+   * references to the shared resource. So it does reference counting and also acquires a lock.\n+   *\n+   * Resource owners call this method as the last thing before returning a reference to the caller.\n+   * That caller binds that reference to a variable in a try-with-resources statement and relies on\n+   * the AutoCloseable protocol to invoke close() on the object at the end of the block.\n+   */\n+  ByteBufferSharing alias() {\n+    lock.lock();\n+    addReference();\n+    return this;\n+  }\n+\n+  /**\n+   * This variant throws {@link LockAttemptTimedOut} if it can't acquire the lock in time.\n+   */\n+  ByteBufferSharing alias(final long time, final TimeUnit unit) throws LockAttemptTimedOut {\n+    try {\n+      if (!lock.tryLock(time, unit)) {\n+        throw new LockAttemptTimedOut();\n+      }\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new LockAttemptTimedOut();\n+    }\n+    addReference();\n+    return this;\n+  }\n+\n+  @Override\n+  public ByteBuffer getBuffer() throws IOException {\n+    if (isClosed.get()) {\n+      throw new IOException(\"NioSslEngine has been closed\");\n+    } else {\n+      return buffer;\n+    }\n+  }\n+\n+  @Override\n+  public ByteBuffer expandWriteBufferIfNeeded(final int newCapacity) throws IOException {\n+    return buffer = bufferPool.expandWriteBufferIfNeeded(bufferType, getBuffer(), newCapacity);\n+  }\n+\n+  @Override\n+  public void close() {\n+    dropReference();\n+    lock.unlock();\n+  }\n+\n+  private int addReference() {\n+    return counter.incrementAndGet();\n+  }\n+\n+  private int dropReference() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e04624cefb29974f550579c347ea601c0f9dd86e"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc5NDI1Ng==", "bodyText": "If the buffer is released to the BufferPool shouldn't this impl be marked as \"closed\"?", "url": "https://github.com/apache/geode/pull/5666#discussion_r512794256", "createdAt": "2020-10-27T15:32:03Z", "author": {"login": "bschuchardt"}, "path": "geode-core/src/main/java/org/apache/geode/internal/net/ByteBufferSharingImpl.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.net;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.apache.geode.annotations.VisibleForTesting;\n+import org.apache.geode.internal.net.BufferPool.BufferType;\n+\n+/**\n+ * An {@link AutoCloseable} meant to be acquired in a try-with-resources statement. The resource (a\n+ * {@link ByteBuffer}) is available (for reading and modification) in the scope of the\n+ * try-with-resources.\n+ */\n+class ByteBufferSharingImpl implements ByteBufferSharing {\n+\n+  static class LockAttemptTimedOut extends Exception {\n+  }\n+\n+  private final Lock lock;\n+  private final AtomicBoolean isClosed;\n+  // mutable because in general our ByteBuffer may need to be resized (grown or compacted)\n+  private ByteBuffer buffer;\n+  private final BufferType bufferType;\n+  private final AtomicInteger counter;\n+  private final BufferPool bufferPool;\n+\n+  /**\n+   * This constructor is for use only by the owner of the shared resource (a {@link ByteBuffer}).\n+   *\n+   * A resource owner must invoke {@link #alias()} once for each reference that escapes (is passed\n+   * to an external object or is returned to an external caller.)\n+   *\n+   * This constructor acquires no lock. The reference count will be 1 after this constructor\n+   * completes.\n+   */\n+  ByteBufferSharingImpl(final ByteBuffer buffer, final BufferType bufferType,\n+      final BufferPool bufferPool) {\n+    this.buffer = buffer;\n+    this.bufferType = bufferType;\n+    this.bufferPool = bufferPool;\n+    lock = new ReentrantLock();\n+    counter = new AtomicInteger(1);\n+    isClosed = new AtomicBoolean(false);\n+  }\n+\n+  /**\n+   * The destructor. Called by the resource owner to undo the work of the constructor.\n+   */\n+  void destruct() {\n+    if (isClosed.compareAndSet(false, true)) {\n+      dropReference();\n+    }\n+  }\n+\n+  /**\n+   * This method is for use only by the owner of the shared resource. It's used for handing out\n+   * references to the shared resource. So it does reference counting and also acquires a lock.\n+   *\n+   * Resource owners call this method as the last thing before returning a reference to the caller.\n+   * That caller binds that reference to a variable in a try-with-resources statement and relies on\n+   * the AutoCloseable protocol to invoke close() on the object at the end of the block.\n+   */\n+  ByteBufferSharing alias() {\n+    lock.lock();\n+    addReference();\n+    return this;\n+  }\n+\n+  /**\n+   * This variant throws {@link LockAttemptTimedOut} if it can't acquire the lock in time.\n+   */\n+  ByteBufferSharing alias(final long time, final TimeUnit unit) throws LockAttemptTimedOut {\n+    try {\n+      if (!lock.tryLock(time, unit)) {\n+        throw new LockAttemptTimedOut();\n+      }\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new LockAttemptTimedOut();\n+    }\n+    addReference();\n+    return this;\n+  }\n+\n+  @Override\n+  public ByteBuffer getBuffer() throws IOException {\n+    if (isClosed.get()) {\n+      throw new IOException(\"NioSslEngine has been closed\");\n+    } else {\n+      return buffer;\n+    }\n+  }\n+\n+  @Override\n+  public ByteBuffer expandWriteBufferIfNeeded(final int newCapacity) throws IOException {\n+    return buffer = bufferPool.expandWriteBufferIfNeeded(bufferType, getBuffer(), newCapacity);\n+  }\n+\n+  @Override\n+  public void close() {\n+    dropReference();\n+    lock.unlock();\n+  }\n+\n+  private int addReference() {\n+    return counter.incrementAndGet();\n+  }\n+\n+  private int dropReference() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc4Nzc0OA=="}, "originalCommit": {"oid": "e04624cefb29974f550579c347ea601c0f9dd86e"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjgxMDU1Mw==", "bodyText": "Can we name this something more pertinent, like \"createReference\"?  The name \"alias\" doesn't tell me that this method is creating a reference that needs to be released.", "url": "https://github.com/apache/geode/pull/5666#discussion_r512810553", "createdAt": "2020-10-27T15:49:37Z", "author": {"login": "bschuchardt"}, "path": "geode-core/src/main/java/org/apache/geode/internal/net/ByteBufferSharingImpl.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.net;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.apache.geode.annotations.VisibleForTesting;\n+import org.apache.geode.internal.net.BufferPool.BufferType;\n+\n+/**\n+ * An {@link AutoCloseable} meant to be acquired in a try-with-resources statement. The resource (a\n+ * {@link ByteBuffer}) is available (for reading and modification) in the scope of the\n+ * try-with-resources.\n+ */\n+class ByteBufferSharingImpl implements ByteBufferSharing {\n+\n+  static class LockAttemptTimedOut extends Exception {\n+  }\n+\n+  private final Lock lock;\n+  private final AtomicBoolean isClosed;\n+  // mutable because in general our ByteBuffer may need to be resized (grown or compacted)\n+  private ByteBuffer buffer;\n+  private final BufferType bufferType;\n+  private final AtomicInteger counter;\n+  private final BufferPool bufferPool;\n+\n+  /**\n+   * This constructor is for use only by the owner of the shared resource (a {@link ByteBuffer}).\n+   *\n+   * A resource owner must invoke {@link #alias()} once for each reference that escapes (is passed\n+   * to an external object or is returned to an external caller.)\n+   *\n+   * This constructor acquires no lock. The reference count will be 1 after this constructor\n+   * completes.\n+   */\n+  ByteBufferSharingImpl(final ByteBuffer buffer, final BufferType bufferType,\n+      final BufferPool bufferPool) {\n+    this.buffer = buffer;\n+    this.bufferType = bufferType;\n+    this.bufferPool = bufferPool;\n+    lock = new ReentrantLock();\n+    counter = new AtomicInteger(1);\n+    isClosed = new AtomicBoolean(false);\n+  }\n+\n+  /**\n+   * The destructor. Called by the resource owner to undo the work of the constructor.\n+   */\n+  void destruct() {\n+    if (isClosed.compareAndSet(false, true)) {\n+      dropReference();\n+    }\n+  }\n+\n+  /**\n+   * This method is for use only by the owner of the shared resource. It's used for handing out\n+   * references to the shared resource. So it does reference counting and also acquires a lock.\n+   *\n+   * Resource owners call this method as the last thing before returning a reference to the caller.\n+   * That caller binds that reference to a variable in a try-with-resources statement and relies on\n+   * the AutoCloseable protocol to invoke close() on the object at the end of the block.\n+   */\n+  ByteBufferSharing alias() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e04624cefb29974f550579c347ea601c0f9dd86e"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjgxMzU4MA==", "bodyText": "please address this new TODO", "url": "https://github.com/apache/geode/pull/5666#discussion_r512813580", "createdAt": "2020-10-27T15:52:57Z", "author": {"login": "bschuchardt"}, "path": "geode-core/src/main/java/org/apache/geode/internal/net/NioSslEngine.java", "diffHunk": "@@ -315,50 +317,48 @@ public ByteBuffer ensureWrappedCapacity(int amount, ByteBuffer wrappedBuffer,\n   }\n \n   @Override\n-  public ByteBuffer readAtLeast(SocketChannel channel, int bytes,\n+  public ByteBufferSharing readAtLeast(SocketChannel channel, int bytes,\n       ByteBuffer wrappedBuffer) throws IOException {\n-    if (peerAppData.capacity() > bytes) {\n-      // we already have a buffer that's big enough\n-      if (peerAppData.capacity() - peerAppData.position() < bytes) {\n-        peerAppData.compact();\n-        peerAppData.flip();\n-      }\n-    }\n+    try (final ByteBufferSharing inputSharing = shareInputBuffer()) {\n \n-    while (peerAppData.remaining() < bytes) {\n-      wrappedBuffer.limit(wrappedBuffer.capacity());\n-      int amountRead = channel.read(wrappedBuffer);\n-      if (amountRead < 0) {\n-        throw new EOFException();\n+      ByteBuffer peerAppData = inputSharing.getBuffer();\n+\n+      if (peerAppData.capacity() > bytes) {\n+        // we already have a buffer that's big enough\n+        if (peerAppData.capacity() - peerAppData.position() < bytes) {\n+          peerAppData.compact();\n+          peerAppData.flip();\n+        }\n       }\n-      if (amountRead > 0) {\n-        wrappedBuffer.flip();\n-        // prep the decoded buffer for writing\n-        peerAppData.compact();\n-        peerAppData = unwrap(wrappedBuffer);\n-        // done writing to the decoded buffer - prep it for reading again\n-        peerAppData.flip();\n+\n+      while (peerAppData.remaining() < bytes) {\n+        wrappedBuffer.limit(wrappedBuffer.capacity());\n+        int amountRead = channel.read(wrappedBuffer);\n+        if (amountRead < 0) {\n+          throw new EOFException();\n+        }\n+        if (amountRead > 0) {\n+          wrappedBuffer.flip();\n+          // prep the decoded buffer for writing\n+          peerAppData.compact();\n+          try (final ByteBufferSharing inputSharing2 = unwrap(wrappedBuffer)) {\n+            // done writing to the decoded buffer - prep it for reading again\n+            final ByteBuffer peerAppDataNew = inputSharing2.getBuffer();\n+            peerAppDataNew.flip();\n+            peerAppData = peerAppDataNew; // loop needs new reference!\n+          }\n+        }\n       }\n+      return shareInputBuffer();\n     }\n-    return peerAppData;\n   }\n \n   @Override\n-  public ByteBuffer getUnwrappedBuffer(ByteBuffer wrappedBuffer) {\n-    return peerAppData;\n-  }\n-\n-  /**\n-   * ensures that the unwrapped buffer associated with the given wrapped buffer has\n-   * sufficient capacity for the given amount of bytes. This may compact the\n-   * buffer or it may return a new buffer.\n-   */\n-  public ByteBuffer ensureUnwrappedCapacity(int amount) {\n-    // for TTLS the app-data buffers do not need to be tracked direct-buffers since we\n-    // do not use them for I/O operations\n-    peerAppData =\n-        bufferPool.expandReadBufferIfNeeded(TRACKED_RECEIVER, peerAppData, amount);\n-    return peerAppData;\n+  public ByteBufferSharing getUnwrappedBuffer(ByteBuffer wrappedBuffer) {\n+    /*\n+     * TODO: it can't be right that we ignore the wrappedBuffer parameter here!", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e04624cefb29974f550579c347ea601c0f9dd86e"}, "originalPosition": 403}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjgxNjUwMg==", "bodyText": "I like how you've removed the need for this method", "url": "https://github.com/apache/geode/pull/5666#discussion_r512816502", "createdAt": "2020-10-27T15:56:17Z", "author": {"login": "bschuchardt"}, "path": "geode-core/src/main/java/org/apache/geode/internal/net/NioSslEngine.java", "diffHunk": "@@ -368,17 +368,15 @@ public void doneReadingDirectAck(ByteBuffer unwrappedBuffer) {\n     // read-operations\n   }\n \n-  @Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e04624cefb29974f550579c347ea601c0f9dd86e"}, "originalPosition": 413}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4OTA0ODIz", "url": "https://github.com/apache/geode/pull/5666#pullrequestreview-518904823", "createdAt": "2020-10-28T17:16:40Z", "commit": {"oid": "834481296e35735218e5fa9310e774ed9ff5b223"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNzoxNjo0MFrOHp1EDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNzoxNjo0MFrOHp1EDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyMzA1NQ==", "bodyText": "This method should throw an exception, not return a ByteBufferSharing with a null buffer.", "url": "https://github.com/apache/geode/pull/5666#discussion_r513623055", "createdAt": "2020-10-28T17:16:40Z", "author": {"login": "bschuchardt"}, "path": "geode-core/src/main/java/org/apache/geode/internal/net/NioPlainEngine.java", "diffHunk": "@@ -121,8 +121,12 @@ public void doneReading(ByteBuffer unwrappedBuffer) {\n   }\n \n   @Override\n-  public ByteBuffer getUnwrappedBuffer(ByteBuffer wrappedBuffer) {\n-    return wrappedBuffer;\n+  public ByteBufferSharing getUnwrappedBuffer() {\n+    return shareBuffer(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "834481296e35735218e5fa9310e774ed9ff5b223"}, "originalPosition": 44}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b0a257f473d8c16b8a91148942edb40066c00de8", "author": {"user": {"login": "Bill", "name": "Bill Burcham"}}, "url": "https://github.com/apache/geode/commit/b0a257f473d8c16b8a91148942edb40066c00de8", "committedDate": "2020-10-28T17:39:39Z", "message": "GEODE-8652: NioSslEngine.close() to Bypasses Locks\n\n- NioSslEngine.close() to proceed even if readers (or writers) are\n  operating on its ByteBuffers, allowing Connection.close() to close\n  its socket and proceed.\n\nCo-authored-by: Bill Burcham <bill.burcham@gmail.com>\nCo-authored-by: Darrel Schneider <dschneider@pivotal.io>\nCo-authored-by: Ernie Burghardt <burghardte@vmware.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "834481296e35735218e5fa9310e774ed9ff5b223", "author": {"user": {"login": "Bill", "name": "Bill Burcham"}}, "url": "https://github.com/apache/geode/commit/834481296e35735218e5fa9310e774ed9ff5b223", "committedDate": "2020-10-28T00:23:04Z", "message": "renamed an exception class"}, "afterCommit": {"oid": "b0a257f473d8c16b8a91148942edb40066c00de8", "author": {"user": {"login": "Bill", "name": "Bill Burcham"}}, "url": "https://github.com/apache/geode/commit/b0a257f473d8c16b8a91148942edb40066c00de8", "committedDate": "2020-10-28T17:39:39Z", "message": "GEODE-8652: NioSslEngine.close() to Bypasses Locks\n\n- NioSslEngine.close() to proceed even if readers (or writers) are\n  operating on its ByteBuffers, allowing Connection.close() to close\n  its socket and proceed.\n\nCo-authored-by: Bill Burcham <bill.burcham@gmail.com>\nCo-authored-by: Darrel Schneider <dschneider@pivotal.io>\nCo-authored-by: Ernie Burghardt <burghardte@vmware.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5MzQyMTg0", "url": "https://github.com/apache/geode/pull/5666#pullrequestreview-519342184", "createdAt": "2020-10-29T05:29:28Z", "commit": {"oid": "b0a257f473d8c16b8a91148942edb40066c00de8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQwNToyOToyOFrOHqLJtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQwNToyOToyOFrOHqLJtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzk4NDk0OA==", "bodyText": "Will this \"synchronized\" sync with wrap() method's shareOutputBuffer?\nwrap() and close() have to sync with each other, otherwise it will encounter bug Gem-3116.", "url": "https://github.com/apache/geode/pull/5666#discussion_r513984948", "createdAt": "2020-10-29T05:29:28Z", "author": {"login": "gesterzhou"}, "path": "geode-core/src/main/java/org/apache/geode/internal/net/NioSslEngine.java", "diffHunk": "@@ -368,17 +365,15 @@ public void doneReadingDirectAck(ByteBuffer unwrappedBuffer) {\n     // read-operations\n   }\n \n-  @Override\n-  public synchronized boolean isClosed() {\n-    return closed;\n-  }\n-\n   @Override\n   public synchronized void close(SocketChannel socketChannel) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0a257f473d8c16b8a91148942edb40066c00de8"}, "originalPosition": 416}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c44db3f68f108ebebecbc36391a70489b4743d82", "author": {"user": {"login": "Bill", "name": "Bill Burcham"}}, "url": "https://github.com/apache/geode/commit/c44db3f68f108ebebecbc36391a70489b4743d82", "committedDate": "2020-10-29T20:52:12Z", "message": "added tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d30664795920a72ba02d0d969b64ef7943a9b36", "author": {"user": {"login": "Bill", "name": "Bill Burcham"}}, "url": "https://github.com/apache/geode/commit/7d30664795920a72ba02d0d969b64ef7943a9b36", "committedDate": "2020-10-29T21:09:03Z", "message": "embed empty ByteBuffer instead of null"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwMTI5MzE2", "url": "https://github.com/apache/geode/pull/5666#pullrequestreview-520129316", "createdAt": "2020-10-29T22:19:16Z", "commit": {"oid": "7d30664795920a72ba02d0d969b64ef7943a9b36"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwMTI4MDAx", "url": "https://github.com/apache/geode/pull/5666#pullrequestreview-520128001", "createdAt": "2020-10-29T22:16:23Z", "commit": {"oid": "7d30664795920a72ba02d0d969b64ef7943a9b36"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMjoxNjoyM1rOHqwo-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMjoyMDo1N1rOHqwvzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU5OTE2MQ==", "bodyText": "i appreciate the buffer naming with their respective directions\nmaybe in the future this decoration can be extended to the uses of peerAppData and 'myNetData`  just to reduce cognitive load and increase readability", "url": "https://github.com/apache/geode/pull/5666#discussion_r514599161", "createdAt": "2020-10-29T22:16:23Z", "author": {"login": "echobravopapa"}, "path": "geode-core/src/main/java/org/apache/geode/internal/net/NioSslEngine.java", "diffHunk": "@@ -40,48 +40,48 @@\n import org.apache.logging.log4j.Logger;\n \n import org.apache.geode.GemFireIOException;\n-import org.apache.geode.annotations.internal.MakeImmutable;\n+import org.apache.geode.annotations.VisibleForTesting;\n import org.apache.geode.internal.net.BufferPool.BufferType;\n+import org.apache.geode.internal.net.ByteBufferSharingImpl.OpenAttemptTimedOut;\n import org.apache.geode.logging.internal.log4j.api.LogService;\n \n \n /**\n- * NioSslEngine uses an SSLEngine to bind SSL logic to a data source. This class is not thread\n- * safe. Its use should be confined to one thread or should be protected by external\n- * synchronization.\n+ * NioSslEngine uses an SSLEngine to bind SSL logic to a data source. This class is not thread safe.\n+ * Its use should be confined to one thread or should be protected by external synchronization.\n  */\n public class NioSslEngine implements NioFilter {\n   private static final Logger logger = LogService.getLogger();\n \n-  // this variable requires the MakeImmutable annotation but the buffer is empty and\n-  // not really modifiable\n-  @MakeImmutable\n-  private static final ByteBuffer EMPTY_BUFFER = ByteBuffer.allocate(0);\n-\n   private final BufferPool bufferPool;\n \n   private boolean closed;\n \n   SSLEngine engine;\n \n   /**\n-   * myNetData holds bytes wrapped by the SSLEngine\n+   * holds bytes wrapped by the SSLEngine; a.k.a. myNetData", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d30664795920a72ba02d0d969b64ef7943a9b36"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYwMDUwOA==", "bodyText": "this probably warrants a comment for posterity...", "url": "https://github.com/apache/geode/pull/5666#discussion_r514600508", "createdAt": "2020-10-29T22:19:57Z", "author": {"login": "echobravopapa"}, "path": "geode-core/src/main/java/org/apache/geode/internal/net/NioSslEngine.java", "diffHunk": "@@ -368,17 +365,15 @@ public void doneReadingDirectAck(ByteBuffer unwrappedBuffer) {\n     // read-operations\n   }\n \n-  @Override\n-  public synchronized boolean isClosed() {\n-    return closed;\n-  }\n-\n   @Override\n   public synchronized void close(SocketChannel socketChannel) {\n     if (closed) {\n       return;\n     }\n-    try {\n+    closed = true;\n+    inputSharing.destruct();\n+    try (final ByteBufferSharing outputSharing = shareOutputBuffer(1, TimeUnit.MINUTES)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d30664795920a72ba02d0d969b64ef7943a9b36"}, "originalPosition": 423}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYwMDkxMQ==", "bodyText": "much cleaner, like it!", "url": "https://github.com/apache/geode/pull/5666#discussion_r514600911", "createdAt": "2020-10-29T22:20:57Z", "author": {"login": "echobravopapa"}, "path": "geode-core/src/main/java/org/apache/geode/internal/net/NioSslEngine.java", "diffHunk": "@@ -405,14 +400,13 @@ public synchronized void close(SocketChannel socketChannel) {\n       // we can't send a close message if the channel is closed\n     } catch (IOException e) {\n       throw new GemFireIOException(\"exception closing SSL session\", e);\n+    } catch (final OpenAttemptTimedOut _unused) {\n+      logger.info(String.format(\"Couldn't get output lock in time, eliding TLS close message\"));\n+      if (!engine.isOutboundDone()) {\n+        engine.closeOutbound();\n+      }\n     } finally {\n-      ByteBuffer netData = myNetData;\n-      ByteBuffer appData = peerAppData;\n-      myNetData = null;\n-      peerAppData = EMPTY_BUFFER;\n-      bufferPool.releaseBuffer(TRACKED_SENDER, netData);\n-      bufferPool.releaseBuffer(TRACKED_RECEIVER, appData);\n-      this.closed = true;\n+      outputSharing.destruct();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d30664795920a72ba02d0d969b64ef7943a9b36"}, "originalPosition": 445}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3974, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}