{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcwODUyMzY1", "number": 5466, "title": "GEODE-8119: Threads hangs when offline disk store command is invoked", "bodyText": "Thank you for submitting a contribution to Apache Geode.\nIn order to streamline the review of the contribution we ask you\nto ensure the following steps have been taken:\nFor all changes:\n\n\n Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?\n\n\n Has your PR been rebased against the latest commit within the target branch (typically develop)?\n\n\n Is your initial contribution a single, squashed commit?\n\n\n Does gradlew build run cleanly?\n\n\n Have you written or updated unit tests to verify your changes?\n\n\n If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under ASF 2.0?\n\n\nNote:\nPlease ensure that once the PR is submitted, check Concourse for build issues and\nsubmit an update to your PR as soon as possible. If you need help, please send an\nemail to dev@geode.apache.org.", "createdAt": "2020-08-20T11:42:30Z", "url": "https://github.com/apache/geode/pull/5466", "merged": true, "mergeCommit": {"oid": "afb161fe793ebaede473c996e88cc161b9c5b6f5"}, "closed": true, "closedAt": "2020-08-24T08:22:42Z", "author": {"login": "mkevo"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdAw7e7gFqTQ3MTY1MDExNw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdB-NBlAFqTQ3MzIxNTgxMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxNjUwMTE3", "url": "https://github.com/apache/geode/pull/5466#pullrequestreview-471650117", "createdAt": "2020-08-20T14:06:38Z", "commit": {"oid": "aaa9106caf3df2293c7d9622c652ac4923246ea3"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNDowNjozOFrOHEDS-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNDoxNzowM1rOHEDvYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAxMDM2Mw==", "bodyText": "Can you change the test name to something more meaningful?, maybe offlineDiskStoreCommandShouldFailWhenDiskStoreFileDoesNotExist?.", "url": "https://github.com/apache/geode/pull/5466#discussion_r474010363", "createdAt": "2020-08-20T14:06:38Z", "author": {"login": "jujoramos"}, "path": "geode-gfsh/src/distributedTest/java/org/apache/geode/management/internal/cli/commands/DiskStoreCommandsDUnitTest.java", "diffHunk": "@@ -519,6 +520,25 @@ public void offlineDiskStoreCommandShouldNotCreateFolderIfDiskStoreDoesNotExist(\n     assertThat(Files.exists(nonExistingDiskStorePath)).isFalse();\n   }\n \n+  @Test\n+  @Parameters({\"compact offline-disk-store\", \"describe offline-disk-store\",\n+      \"upgrade offline-disk-store\", \"validate offline-disk-store\",\n+      \"alter disk-store --region=testRegion --enable-statistics=true\"})\n+  public void offlineDiskStoreCommandShouldNotPassIfDiskStoreFileDoesNotExist(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaa9106caf3df2293c7d9622c652ac4923246ea3"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAxMTgzMA==", "bodyText": "Can you change the test name to something more meaningful?, maybe offlineDiskStoreCommandsShouldSucceedWhenDiskStoreHasMultipleDirectories, or offlineDiskStoreCommandsSupportDiskStoresWithMultipleDirerctories?", "url": "https://github.com/apache/geode/pull/5466#discussion_r474011830", "createdAt": "2020-08-20T14:08:50Z", "author": {"login": "jujoramos"}, "path": "geode-gfsh/src/distributedTest/java/org/apache/geode/management/internal/cli/commands/OfflineDiskStoreCommandsDUnitTest.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.management.internal.cli.commands;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;\n+import static org.apache.geode.distributed.ConfigurationProperties.START_LOCATOR;\n+import static org.apache.geode.internal.AvailablePortHelper.getRandomAvailableTCPPortsForDUnitSite;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.ThreadInfo;\n+import java.lang.management.ThreadMXBean;\n+import java.util.Arrays;\n+import java.util.Properties;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.cache.DiskStoreFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.DiskInitFile;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+import org.apache.geode.test.junit.rules.GfshCommandRule;\n+\n+@RunWith(JUnitParamsRunner.class)\n+public class OfflineDiskStoreCommandsDUnitTest implements Serializable {\n+  private static final String REGION_NAME = \"testRegion\";\n+  private static final String DISK_STORE_ID = \"testDisk\";\n+  private static final String WRONG_DISK_STORE_ID = \"wrongTestDisk\";\n+\n+  @Rule\n+  public CacheRule cacheRule = new CacheRule();\n+\n+  @Rule\n+  public transient GfshCommandRule gfsh = new GfshCommandRule();\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule();\n+\n+  @Rule\n+  public transient TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+\n+  private Properties createLocatorConfiguration(int localLocatorPort) {\n+    Properties config = new Properties();\n+    config.setProperty(MCAST_PORT, \"0\");\n+    config.setProperty(LOCATORS, \"localhost[\" + localLocatorPort + ']');\n+    config.setProperty(START_LOCATOR,\n+        \"localhost[\" + localLocatorPort + \"],server=true,peer=true,hostname-for-clients=localhost\");\n+\n+    return config;\n+  }\n+\n+  private Properties createServerConfiguration(int localLocatorPort) {\n+    Properties config = new Properties();\n+    config.setProperty(MCAST_PORT, \"0\");\n+    config.setProperty(LOCATORS, \"localhost[\" + localLocatorPort + ']');\n+\n+    return config;\n+  }\n+\n+  private void createDiskStore(File[] diskStoreDirectories) {\n+    DiskStoreFactory diskStoreFactory = cacheRule.getCache().createDiskStoreFactory();\n+    diskStoreFactory.setMaxOplogSize(1);\n+    diskStoreFactory.setAutoCompact(true);\n+    diskStoreFactory.setAllowForceCompaction(true);\n+    diskStoreFactory.setDiskDirs(diskStoreDirectories);\n+\n+    diskStoreFactory.create(DISK_STORE_ID);\n+  }\n+\n+  private void createRegion() {\n+    cacheRule.getCache()\n+        .<String, String>createRegionFactory(RegionShortcut.PARTITION_PERSISTENT)\n+        .setDiskStoreName(DISK_STORE_ID)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void createServerWithRegionAndPersistentRegion(File[] diskStoreDirectories) {\n+    createDiskStore(diskStoreDirectories);\n+    createRegion();\n+    cacheRule.getCache().getRegion(REGION_NAME);\n+  }\n+\n+  private void gracefullyDisconnect() {\n+    InternalDistributedSystem.getConnectedInstance().stopReconnectingNoDisconnect();\n+    InternalDistributedSystem.getConnectedInstance().disconnect();\n+    await()\n+        .untilAsserted(() -> assertThat(InternalDistributedSystem.getConnectedInstance()).isNull());\n+  }\n+\n+  @Test\n+  @Parameters({\"compact offline-disk-store\", \"describe offline-disk-store\",\n+      \"validate offline-disk-store\",\n+      \"alter disk-store --region=testRegion --enable-statistics=true\"})\n+  public void testOfflineCommandsWithMultipleDirs(String baseCommand) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaa9106caf3df2293c7d9622c652ac4923246ea3"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAxNDU4MA==", "bodyText": "Can you change the test name to something more meaningful?, maybe asyncFlusherThreadIsNotStartedForOfflineDiskStoreCommands, or offlineDiskStoreCommandsDoNotLeaveLingeringThreadsRunning?", "url": "https://github.com/apache/geode/pull/5466#discussion_r474014580", "createdAt": "2020-08-20T14:12:42Z", "author": {"login": "jujoramos"}, "path": "geode-gfsh/src/distributedTest/java/org/apache/geode/management/internal/cli/commands/OfflineDiskStoreCommandsDUnitTest.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.management.internal.cli.commands;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;\n+import static org.apache.geode.distributed.ConfigurationProperties.START_LOCATOR;\n+import static org.apache.geode.internal.AvailablePortHelper.getRandomAvailableTCPPortsForDUnitSite;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.ThreadInfo;\n+import java.lang.management.ThreadMXBean;\n+import java.util.Arrays;\n+import java.util.Properties;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.cache.DiskStoreFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.DiskInitFile;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+import org.apache.geode.test.junit.rules.GfshCommandRule;\n+\n+@RunWith(JUnitParamsRunner.class)\n+public class OfflineDiskStoreCommandsDUnitTest implements Serializable {\n+  private static final String REGION_NAME = \"testRegion\";\n+  private static final String DISK_STORE_ID = \"testDisk\";\n+  private static final String WRONG_DISK_STORE_ID = \"wrongTestDisk\";\n+\n+  @Rule\n+  public CacheRule cacheRule = new CacheRule();\n+\n+  @Rule\n+  public transient GfshCommandRule gfsh = new GfshCommandRule();\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule();\n+\n+  @Rule\n+  public transient TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+\n+  private Properties createLocatorConfiguration(int localLocatorPort) {\n+    Properties config = new Properties();\n+    config.setProperty(MCAST_PORT, \"0\");\n+    config.setProperty(LOCATORS, \"localhost[\" + localLocatorPort + ']');\n+    config.setProperty(START_LOCATOR,\n+        \"localhost[\" + localLocatorPort + \"],server=true,peer=true,hostname-for-clients=localhost\");\n+\n+    return config;\n+  }\n+\n+  private Properties createServerConfiguration(int localLocatorPort) {\n+    Properties config = new Properties();\n+    config.setProperty(MCAST_PORT, \"0\");\n+    config.setProperty(LOCATORS, \"localhost[\" + localLocatorPort + ']');\n+\n+    return config;\n+  }\n+\n+  private void createDiskStore(File[] diskStoreDirectories) {\n+    DiskStoreFactory diskStoreFactory = cacheRule.getCache().createDiskStoreFactory();\n+    diskStoreFactory.setMaxOplogSize(1);\n+    diskStoreFactory.setAutoCompact(true);\n+    diskStoreFactory.setAllowForceCompaction(true);\n+    diskStoreFactory.setDiskDirs(diskStoreDirectories);\n+\n+    diskStoreFactory.create(DISK_STORE_ID);\n+  }\n+\n+  private void createRegion() {\n+    cacheRule.getCache()\n+        .<String, String>createRegionFactory(RegionShortcut.PARTITION_PERSISTENT)\n+        .setDiskStoreName(DISK_STORE_ID)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void createServerWithRegionAndPersistentRegion(File[] diskStoreDirectories) {\n+    createDiskStore(diskStoreDirectories);\n+    createRegion();\n+    cacheRule.getCache().getRegion(REGION_NAME);\n+  }\n+\n+  private void gracefullyDisconnect() {\n+    InternalDistributedSystem.getConnectedInstance().stopReconnectingNoDisconnect();\n+    InternalDistributedSystem.getConnectedInstance().disconnect();\n+    await()\n+        .untilAsserted(() -> assertThat(InternalDistributedSystem.getConnectedInstance()).isNull());\n+  }\n+\n+  @Test\n+  @Parameters({\"compact offline-disk-store\", \"describe offline-disk-store\",\n+      \"validate offline-disk-store\",\n+      \"alter disk-store --region=testRegion --enable-statistics=true\"})\n+  public void testOfflineCommandsWithMultipleDirs(String baseCommand) throws IOException {\n+    VM locator = getVM(0);\n+    VM server = getVM(1);\n+    final int ENTRIES = 100000;\n+    int site1Port = getRandomAvailableTCPPortsForDUnitSite(1)[0];\n+\n+    File diskStoreDirectory1 = temporaryFolder.newFolder(\"diskDir1\");\n+    File diskStoreDirectory2 = temporaryFolder.newFolder(\"diskDir2\");\n+    File diskStoreDirectory3 = temporaryFolder.newFolder(\"diskDir3\");\n+    File[] diskStoreDirectories =\n+        new File[] {diskStoreDirectory1, diskStoreDirectory2, diskStoreDirectory3};\n+    String diskDirs = Arrays.stream(diskStoreDirectories).map(File::getAbsolutePath)\n+        .collect(Collectors.joining(\",\"));\n+\n+    locator.invoke(() -> cacheRule.createCache(createLocatorConfiguration(site1Port)));\n+    server.invoke(() -> cacheRule.createCache(createServerConfiguration(site1Port)));\n+    server.invoke(() -> {\n+      createServerWithRegionAndPersistentRegion(diskStoreDirectories);\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      IntStream.range(0, ENTRIES).forEach(i -> region.put(\"Key_\" + i, \"Value_\" + i));\n+    });\n+    locator.invoke(this::gracefullyDisconnect);\n+    server.invoke(this::gracefullyDisconnect);\n+    gfsh.executeAndAssertThat(\n+        baseCommand + \" --name=\" + DISK_STORE_ID + \" --disk-dirs=\" + diskDirs)\n+        .statusIsSuccess();\n+  }\n+\n+  @Test\n+  @Parameters({\"describe offline-disk-store\",\n+      \"validate offline-disk-store\",\n+      \"alter disk-store --region=testRegion --enable-statistics=true\"})\n+  public void testThreadHangWithOfflineDiskStoreCommands(String baseCommand) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaa9106caf3df2293c7d9622c652ac4923246ea3"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAxNTEyMw==", "bodyText": "Can you change the test name to something more meaningful?, maybe offlineDiskStoreCommandShouldFailWhenDiskStoreFileDoesNotExist?.", "url": "https://github.com/apache/geode/pull/5466#discussion_r474015123", "createdAt": "2020-08-20T14:13:27Z", "author": {"login": "jujoramos"}, "path": "geode-gfsh/src/distributedTest/java/org/apache/geode/management/internal/cli/commands/OfflineDiskStoreCommandsDUnitTest.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.management.internal.cli.commands;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;\n+import static org.apache.geode.distributed.ConfigurationProperties.START_LOCATOR;\n+import static org.apache.geode.internal.AvailablePortHelper.getRandomAvailableTCPPortsForDUnitSite;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.ThreadInfo;\n+import java.lang.management.ThreadMXBean;\n+import java.util.Arrays;\n+import java.util.Properties;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.cache.DiskStoreFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.DiskInitFile;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+import org.apache.geode.test.junit.rules.GfshCommandRule;\n+\n+@RunWith(JUnitParamsRunner.class)\n+public class OfflineDiskStoreCommandsDUnitTest implements Serializable {\n+  private static final String REGION_NAME = \"testRegion\";\n+  private static final String DISK_STORE_ID = \"testDisk\";\n+  private static final String WRONG_DISK_STORE_ID = \"wrongTestDisk\";\n+\n+  @Rule\n+  public CacheRule cacheRule = new CacheRule();\n+\n+  @Rule\n+  public transient GfshCommandRule gfsh = new GfshCommandRule();\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule();\n+\n+  @Rule\n+  public transient TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+\n+  private Properties createLocatorConfiguration(int localLocatorPort) {\n+    Properties config = new Properties();\n+    config.setProperty(MCAST_PORT, \"0\");\n+    config.setProperty(LOCATORS, \"localhost[\" + localLocatorPort + ']');\n+    config.setProperty(START_LOCATOR,\n+        \"localhost[\" + localLocatorPort + \"],server=true,peer=true,hostname-for-clients=localhost\");\n+\n+    return config;\n+  }\n+\n+  private Properties createServerConfiguration(int localLocatorPort) {\n+    Properties config = new Properties();\n+    config.setProperty(MCAST_PORT, \"0\");\n+    config.setProperty(LOCATORS, \"localhost[\" + localLocatorPort + ']');\n+\n+    return config;\n+  }\n+\n+  private void createDiskStore(File[] diskStoreDirectories) {\n+    DiskStoreFactory diskStoreFactory = cacheRule.getCache().createDiskStoreFactory();\n+    diskStoreFactory.setMaxOplogSize(1);\n+    diskStoreFactory.setAutoCompact(true);\n+    diskStoreFactory.setAllowForceCompaction(true);\n+    diskStoreFactory.setDiskDirs(diskStoreDirectories);\n+\n+    diskStoreFactory.create(DISK_STORE_ID);\n+  }\n+\n+  private void createRegion() {\n+    cacheRule.getCache()\n+        .<String, String>createRegionFactory(RegionShortcut.PARTITION_PERSISTENT)\n+        .setDiskStoreName(DISK_STORE_ID)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void createServerWithRegionAndPersistentRegion(File[] diskStoreDirectories) {\n+    createDiskStore(diskStoreDirectories);\n+    createRegion();\n+    cacheRule.getCache().getRegion(REGION_NAME);\n+  }\n+\n+  private void gracefullyDisconnect() {\n+    InternalDistributedSystem.getConnectedInstance().stopReconnectingNoDisconnect();\n+    InternalDistributedSystem.getConnectedInstance().disconnect();\n+    await()\n+        .untilAsserted(() -> assertThat(InternalDistributedSystem.getConnectedInstance()).isNull());\n+  }\n+\n+  @Test\n+  @Parameters({\"compact offline-disk-store\", \"describe offline-disk-store\",\n+      \"validate offline-disk-store\",\n+      \"alter disk-store --region=testRegion --enable-statistics=true\"})\n+  public void testOfflineCommandsWithMultipleDirs(String baseCommand) throws IOException {\n+    VM locator = getVM(0);\n+    VM server = getVM(1);\n+    final int ENTRIES = 100000;\n+    int site1Port = getRandomAvailableTCPPortsForDUnitSite(1)[0];\n+\n+    File diskStoreDirectory1 = temporaryFolder.newFolder(\"diskDir1\");\n+    File diskStoreDirectory2 = temporaryFolder.newFolder(\"diskDir2\");\n+    File diskStoreDirectory3 = temporaryFolder.newFolder(\"diskDir3\");\n+    File[] diskStoreDirectories =\n+        new File[] {diskStoreDirectory1, diskStoreDirectory2, diskStoreDirectory3};\n+    String diskDirs = Arrays.stream(diskStoreDirectories).map(File::getAbsolutePath)\n+        .collect(Collectors.joining(\",\"));\n+\n+    locator.invoke(() -> cacheRule.createCache(createLocatorConfiguration(site1Port)));\n+    server.invoke(() -> cacheRule.createCache(createServerConfiguration(site1Port)));\n+    server.invoke(() -> {\n+      createServerWithRegionAndPersistentRegion(diskStoreDirectories);\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      IntStream.range(0, ENTRIES).forEach(i -> region.put(\"Key_\" + i, \"Value_\" + i));\n+    });\n+    locator.invoke(this::gracefullyDisconnect);\n+    server.invoke(this::gracefullyDisconnect);\n+    gfsh.executeAndAssertThat(\n+        baseCommand + \" --name=\" + DISK_STORE_ID + \" --disk-dirs=\" + diskDirs)\n+        .statusIsSuccess();\n+  }\n+\n+  @Test\n+  @Parameters({\"describe offline-disk-store\",\n+      \"validate offline-disk-store\",\n+      \"alter disk-store --region=testRegion --enable-statistics=true\"})\n+  public void testThreadHangWithOfflineDiskStoreCommands(String baseCommand) throws IOException {\n+    VM locator = getVM(0);\n+    VM server = getVM(1);\n+    final int ENTRIES = 100000;\n+    int site1Port = getRandomAvailableTCPPortsForDUnitSite(1)[0];\n+    String threadName = \"Asynchronous disk writer for region\";\n+    int counter = 0;\n+\n+    File diskStoreDirectory1 = temporaryFolder.newFolder(\"diskDir1\");\n+\n+    File[] diskStoreDirectories =\n+        new File[] {diskStoreDirectory1};\n+    String diskDirs = Arrays.stream(diskStoreDirectories).map(File::getAbsolutePath)\n+        .collect(Collectors.joining(\",\"));\n+\n+    locator.invoke(() -> cacheRule.createCache(createLocatorConfiguration(site1Port)));\n+    server.invoke(() -> cacheRule.createCache(createServerConfiguration(site1Port)));\n+    server.invoke(() -> {\n+      createServerWithRegionAndPersistentRegion(diskStoreDirectories);\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      IntStream.range(0, ENTRIES).forEach(i -> region.put(\"Key_\" + i, \"Value_\" + i));\n+    });\n+    locator.invoke(this::gracefullyDisconnect);\n+    server.invoke(this::gracefullyDisconnect);\n+\n+    gfsh.executeAndAssertThat(\n+        baseCommand + \" --name=\" + DISK_STORE_ID + \" --disk-dirs=\" + diskDirs)\n+        .statusIsSuccess();\n+\n+    File tempFile = temporaryFolder.newFile(\"dumpFile.txt\");\n+    BufferedWriter writer = new BufferedWriter(new FileWriter(tempFile));\n+    ThreadMXBean bean = ManagementFactory.getThreadMXBean();\n+    ThreadInfo[] infos = bean.dumpAllThreads(true, true);\n+    for (ThreadInfo info : infos) {\n+      if (info.toString().contains(threadName))\n+        writer.append(info.toString());\n+    }\n+\n+    writer.close();\n+\n+    try (BufferedReader br = new BufferedReader(new FileReader(tempFile))) {\n+      String line;\n+      while ((line = br.readLine()) != null) {\n+        if (line.contains(threadName))\n+          counter++;\n+      }\n+    }\n+    assertThat(counter).isEqualTo(0);\n+  }\n+\n+  @Test\n+  @Parameters({\"compact offline-disk-store\", \"describe offline-disk-store\",\n+      \"validate offline-disk-store\",\n+      \"alter disk-store --region=testRegion --enable-statistics=true\"})\n+  public void testOfflineCommandsWithMultipleDirsAndWrongName(String baseCommand)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaa9106caf3df2293c7d9622c652ac4923246ea3"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAxNTg0MQ==", "bodyText": "Can you remove throws IOException as it's not thrown from within the method body?.", "url": "https://github.com/apache/geode/pull/5466#discussion_r474015841", "createdAt": "2020-08-20T14:14:31Z", "author": {"login": "jujoramos"}, "path": "geode-gfsh/src/integrationTest/java/org/apache/geode/management/internal/cli/commands/AlterDiskStoreCommandIntegrationTest.java", "diffHunk": "@@ -55,4 +59,33 @@ public void removeOptionMustBeUsedAlone() {\n     gfsh.executeAndAssertThat(command, commandString).statusIsError()\n         .containsOutput(\"Cannot use the --remove=true parameter with any other parameters\");\n   }\n+\n+  @Test\n+  public void testDirValidation() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaa9106caf3df2293c7d9622c652ac4923246ea3"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAxNTkzNg==", "bodyText": "Can you remove throws IOException as it's not thrown from within the method body?.", "url": "https://github.com/apache/geode/pull/5466#discussion_r474015936", "createdAt": "2020-08-20T14:14:39Z", "author": {"login": "jujoramos"}, "path": "geode-gfsh/src/integrationTest/java/org/apache/geode/management/internal/cli/commands/AlterDiskStoreCommandIntegrationTest.java", "diffHunk": "@@ -55,4 +59,33 @@ public void removeOptionMustBeUsedAlone() {\n     gfsh.executeAndAssertThat(command, commandString).statusIsError()\n         .containsOutput(\"Cannot use the --remove=true parameter with any other parameters\");\n   }\n+\n+  @Test\n+  public void testDirValidation() throws IOException {\n+    CommandStringBuilder csb = new CommandStringBuilder(CliStrings.ALTER_DISK_STORE);\n+    csb.addOption(CliStrings.ALTER_DISK_STORE__DISKSTORENAME, \"diskStoreName\");\n+    csb.addOption(CliStrings.ALTER_DISK_STORE__REGIONNAME, \"regionName\");\n+    csb.addOption(CliStrings.ALTER_DISK_STORE__DISKDIRS, \"wrongDiskDir\");\n+    csb.addOption(CliStrings.ALTER_DISK_STORE__CONCURRENCY__LEVEL, \"5\");\n+    String commandString = csb.toString();\n+\n+    gfsh.executeAndAssertThat(command, commandString).statusIsError()\n+        .containsOutput(\"Could not find disk-dirs: \\\"wrongDiskDir\");\n+  }\n+\n+  @Test\n+  public void testNameValidation() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaa9106caf3df2293c7d9622c652ac4923246ea3"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAxNjc4Mw==", "bodyText": "This variable is not used across the test, can you delete it?.", "url": "https://github.com/apache/geode/pull/5466#discussion_r474016783", "createdAt": "2020-08-20T14:15:47Z", "author": {"login": "jujoramos"}, "path": "geode-gfsh/src/integrationTest/java/org/apache/geode/management/internal/cli/commands/DescribeDiskStoreCommandIntegrationTest.java", "diffHunk": "@@ -34,6 +38,7 @@\n   private static final String REGION_NAME = \"test-region\";\n   private static final String MEMBER_NAME = \"testServer\";\n   private static final String DISK_STORE_NAME = \"testDiskStore\";\n+  private static final String WRONG_DISK_STORE_NAME = \"wrongTestDiskStore\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaa9106caf3df2293c7d9622c652ac4923246ea3"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAxNzYzNQ==", "bodyText": "Can you remove throws Exception as it's not thrown from within the method body?. Since you're already modifying the file, also, it would be great if you can remove throws Exception from every single method in the class as none actually throws anything \ud83d\udc4d .", "url": "https://github.com/apache/geode/pull/5466#discussion_r474017635", "createdAt": "2020-08-20T14:17:03Z", "author": {"login": "jujoramos"}, "path": "geode-gfsh/src/integrationTest/java/org/apache/geode/management/internal/cli/commands/DescribeDiskStoreCommandIntegrationTest.java", "diffHunk": "@@ -98,4 +106,16 @@ public void commandSucceedsWithNameAndMember() throws Exception {\n     gfsh.executeAndAssertThat(cmd).statusIsSuccess()\n         .containsOutput(expectedData.toArray(new String[0]));\n   }\n+\n+  @Test\n+  public void testDirValidation() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaa9106caf3df2293c7d9622c652ac4923246ea3"}, "originalPosition": 39}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "08660e253641012d5eca4b6861f3c209ca584eca", "author": {"user": {"login": "mkevo", "name": "Mario Kevo"}}, "url": "https://github.com/apache/geode/commit/08660e253641012d5eca4b6861f3c209ca584eca", "committedDate": "2020-08-21T09:34:16Z", "message": "GEODE-8119: Threads hangs when offline disk store command is invoked"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86bf3ee30c705aa23a44ee8c77cdf487bd90d76f", "author": {"user": {"login": "mkevo", "name": "Mario Kevo"}}, "url": "https://github.com/apache/geode/commit/86bf3ee30c705aa23a44ee8c77cdf487bd90d76f", "committedDate": "2020-08-21T09:34:16Z", "message": "changes after comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b64ce64f859b9403411c732ba21b44713c63e2d3", "author": {"user": {"login": "mkevo", "name": "Mario Kevo"}}, "url": "https://github.com/apache/geode/commit/b64ce64f859b9403411c732ba21b44713c63e2d3", "committedDate": "2020-08-21T06:37:29Z", "message": "changes after comments"}, "afterCommit": {"oid": "86bf3ee30c705aa23a44ee8c77cdf487bd90d76f", "author": {"user": {"login": "mkevo", "name": "Mario Kevo"}}, "url": "https://github.com/apache/geode/commit/86bf3ee30c705aa23a44ee8c77cdf487bd90d76f", "committedDate": "2020-08-21T09:34:16Z", "message": "changes after comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMjE1ODEw", "url": "https://github.com/apache/geode/pull/5466#pullrequestreview-473215810", "createdAt": "2020-08-24T08:19:30Z", "commit": {"oid": "86bf3ee30c705aa23a44ee8c77cdf487bd90d76f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4153, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}