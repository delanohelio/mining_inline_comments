{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYwMDk1MjUy", "number": 4568, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxOToyMDozOFrODY6fng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxOTozOTo0NFrODY6z1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDUwNzgyOnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/ConnectionPoolDUnitTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxOToyMDozOFrOFfCzfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxOToyMDozOFrOFfCzfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA5NjEyNA==", "bodyText": "Remember to remove these logger statements containing MLH", "url": "https://github.com/apache/geode/pull/4568#discussion_r368096124", "createdAt": "2020-01-17T19:20:38Z", "author": {"login": "kirklund"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/ConnectionPoolDUnitTest.java", "diffHunk": "@@ -2720,8 +2677,10 @@ public void run2() throws CacheException {\n     });\n \n     vm2.invoke(\"Verify destroy propagate\", () -> {\n-      Region<Object, Object> region = getRootRegion().getSubregion(name);\n-      await().until(() -> region == null);\n+      await().until(() -> {\n+        logger.info(\"MLH region = \" + getRootRegion().getSubregion(name));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6"}, "originalPosition": 564}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDUxMzE5OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/ConnectionPoolDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxOToyMjozNFrOFfC2tA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QyMDozNzozOFrOFfEoow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA5Njk0OA==", "bodyText": "I think this test will run into same thing I hit with another test. There's a brief window in which getRegion may throw RegionDestroyedException before it starts returning null:\nawait().ignoreException(RegionDestroyedException.class).until(() -> \n    getCache().getRegion(drName) == null);", "url": "https://github.com/apache/geode/pull/4568#discussion_r368096948", "createdAt": "2020-01-17T19:22:34Z", "author": {"login": "kirklund"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/ConnectionPoolDUnitTest.java", "diffHunk": "@@ -3207,7 +3149,7 @@ public void test028DynamicRegionCreation() {\n       assertThat(r).isNotNull();\n       String drName = r.getFullPath() + Region.SEPARATOR + dynFromServerName;\n \n-      await().pollInterval(100, MILLISECONDS).until(() -> getCache().getRegion(drName) == null);\n+      await().until(() -> getCache().getRegion(drName) == null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6"}, "originalPosition": 712}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEyNjExNQ==", "bodyText": "done", "url": "https://github.com/apache/geode/pull/4568#discussion_r368126115", "createdAt": "2020-01-17T20:37:38Z", "author": {"login": "mhansonp"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/ConnectionPoolDUnitTest.java", "diffHunk": "@@ -3207,7 +3149,7 @@ public void test028DynamicRegionCreation() {\n       assertThat(r).isNotNull();\n       String drName = r.getFullPath() + Region.SEPARATOR + dynFromServerName;\n \n-      await().pollInterval(100, MILLISECONDS).until(() -> getCache().getRegion(drName) == null);\n+      await().until(() -> getCache().getRegion(drName) == null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA5Njk0OA=="}, "originalCommit": {"oid": "9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6"}, "originalPosition": 712}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDUxNDg4OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/ConnectionPoolDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxOToyMzoxN1rOFfC3xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QyMDozOTo0OVrOFfEr_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA5NzIyMw==", "bodyText": "Add ignoreException(RegionDestroyedException.class)", "url": "https://github.com/apache/geode/pull/4568#discussion_r368097223", "createdAt": "2020-01-17T19:23:17Z", "author": {"login": "kirklund"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/ConnectionPoolDUnitTest.java", "diffHunk": "@@ -3217,13 +3159,11 @@ public void test028DynamicRegionCreation() {\n       Region<Object, Object> r = getRootRegion(name);\n       assertThat(r).isNotNull();\n       String drName = r.getFullPath() + Region.SEPARATOR + dynFromServerName;\n-      await().pollInterval(100, MILLISECONDS).until(() -> getCache().getRegion(drName) == null);\n+      await().until(() -> getCache().getRegion(drName) == null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6"}, "originalPosition": 721}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEyNjk3NA==", "bodyText": "done", "url": "https://github.com/apache/geode/pull/4568#discussion_r368126974", "createdAt": "2020-01-17T20:39:49Z", "author": {"login": "mhansonp"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/ConnectionPoolDUnitTest.java", "diffHunk": "@@ -3217,13 +3159,11 @@ public void test028DynamicRegionCreation() {\n       Region<Object, Object> r = getRootRegion(name);\n       assertThat(r).isNotNull();\n       String drName = r.getFullPath() + Region.SEPARATOR + dynFromServerName;\n-      await().pollInterval(100, MILLISECONDS).until(() -> getCache().getRegion(drName) == null);\n+      await().until(() -> getCache().getRegion(drName) == null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA5NzIyMw=="}, "originalCommit": {"oid": "9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6"}, "originalPosition": 721}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDUyODcwOnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache30/DistributedAckRegionCCEDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxOToyODowN1rOFfDAKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QyMDo0MToyNFrOFfEuGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA5OTM2OQ==", "bodyText": "I recommend changing any sort of loop containing a sleep into an await call:\nawait().ignoreException(RegionDestroyedException.class).until(() ->\n    ccregion.isDestroyed() && ccregion.getRegionEntry(key) != null);", "url": "https://github.com/apache/geode/pull/4568#discussion_r368099369", "createdAt": "2020-01-17T19:28:07Z", "author": {"login": "kirklund"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache30/DistributedAckRegionCCEDUnitTest.java", "diffHunk": "@@ -147,129 +146,118 @@ public void testConcurrentOpWithGII() {\n     VM vm2 = VM.getVM(2);\n \n     // create some destroyed entries so the GC service is populated\n-    SerializableCallable create = new SerializableCallable(\"create region\") {\n-      @Override\n-      public Object call() {\n-        RegionFactory f = getCache().createRegionFactory(getRegionAttributes());\n-        CCRegion = (LocalRegion) f.create(name);\n-        return CCRegion.getDistributionManager().getDistributionManagerId();\n-      }\n-    };\n     // do conflicting update() and destroy() on the region. We want the update() to\n     // be sent with a message and the destroy() to be transferred in the initial image\n     // and be the value that we want to keep\n-    vm1.invoke(create);\n+    vm1.invoke(\"create region\", () -> {\n+      RegionFactory f1 = getCache().createRegionFactory(getRegionAttributes());\n+      CCRegion = (LocalRegion) f1.create(name);\n+      return CCRegion.getDistributionManager().getDistributionManagerId();\n+    });\n \n     AsyncInvocation partialCreate =\n-        vm2.invokeAsync(new SerializableCallable<Object>(\"create region with stall\") {\n-          @Override\n-          public Object call() {\n-            final GemFireCacheImpl cache = (GemFireCacheImpl) getCache();\n-            RegionFactory f = cache.createRegionFactory(getRegionAttributes());\n-            InitialImageOperation.VMOTION_DURING_GII = true;\n-            // this will stall region creation at the point of asking for an initial image\n-            VMotionObserverHolder.setInstance(new VMotionObserver() {\n-              @Override\n-              public void vMotionBeforeCQRegistration() {}\n-\n-              @Override\n-              public void vMotionBeforeRegisterInterest() {}\n-\n-              @Override\n-              public void vMotionDuringGII(Set recipientSet, LocalRegion region) {\n-                InitialImageOperation.VMOTION_DURING_GII = false;\n-                final InitializationLevel oldLevel =\n-                    LocalRegion.setThreadInitLevelRequirement(BEFORE_INITIAL_IMAGE);\n-                LocalRegion ccregion = (LocalRegion) cache.getInternalRegionByPath(\"/\" + name);\n-                try {\n-                  // wait for the update op (sent below from vm1) to arrive, then allow the GII to\n-                  // happen\n-                  while (!ccregion.isDestroyed() && ccregion.getRegionEntry(key) == null) {\n-                    try {\n-                      Thread.sleep(1000);\n-                    } catch (InterruptedException e) {\n-                      return;\n-                    }\n+        vm2.invokeAsync(\"create region with stall\", () -> {\n+\n+          final GemFireCacheImpl cache = (GemFireCacheImpl) getCache();\n+          RegionFactory f = cache.createRegionFactory(getRegionAttributes());\n+          InitialImageOperation.VMOTION_DURING_GII = true;\n+          // this will stall region creation at the point of asking for an initial image\n+          VMotionObserverHolder.setInstance(new VMotionObserver() {\n+            @Override\n+            public void vMotionBeforeCQRegistration() {}\n+\n+            @Override\n+            public void vMotionBeforeRegisterInterest() {}\n+\n+            @Override\n+            public void vMotionDuringGII(Set recipientSet, LocalRegion region) {\n+              InitialImageOperation.VMOTION_DURING_GII = false;\n+              final InitializationLevel oldLevel =\n+                  LocalRegion.setThreadInitLevelRequirement(BEFORE_INITIAL_IMAGE);\n+              LocalRegion ccregion = (LocalRegion) cache.getInternalRegionByPath(\"/\" + name);\n+              try {\n+                // wait for the update op (sent below from vm1) to arrive, then allow the GII to\n+                // happen\n+                while (!ccregion.isDestroyed() && ccregion.getRegionEntry(key) == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEyNzUxMw==", "bodyText": "done", "url": "https://github.com/apache/geode/pull/4568#discussion_r368127513", "createdAt": "2020-01-17T20:41:24Z", "author": {"login": "mhansonp"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache30/DistributedAckRegionCCEDUnitTest.java", "diffHunk": "@@ -147,129 +146,118 @@ public void testConcurrentOpWithGII() {\n     VM vm2 = VM.getVM(2);\n \n     // create some destroyed entries so the GC service is populated\n-    SerializableCallable create = new SerializableCallable(\"create region\") {\n-      @Override\n-      public Object call() {\n-        RegionFactory f = getCache().createRegionFactory(getRegionAttributes());\n-        CCRegion = (LocalRegion) f.create(name);\n-        return CCRegion.getDistributionManager().getDistributionManagerId();\n-      }\n-    };\n     // do conflicting update() and destroy() on the region. We want the update() to\n     // be sent with a message and the destroy() to be transferred in the initial image\n     // and be the value that we want to keep\n-    vm1.invoke(create);\n+    vm1.invoke(\"create region\", () -> {\n+      RegionFactory f1 = getCache().createRegionFactory(getRegionAttributes());\n+      CCRegion = (LocalRegion) f1.create(name);\n+      return CCRegion.getDistributionManager().getDistributionManagerId();\n+    });\n \n     AsyncInvocation partialCreate =\n-        vm2.invokeAsync(new SerializableCallable<Object>(\"create region with stall\") {\n-          @Override\n-          public Object call() {\n-            final GemFireCacheImpl cache = (GemFireCacheImpl) getCache();\n-            RegionFactory f = cache.createRegionFactory(getRegionAttributes());\n-            InitialImageOperation.VMOTION_DURING_GII = true;\n-            // this will stall region creation at the point of asking for an initial image\n-            VMotionObserverHolder.setInstance(new VMotionObserver() {\n-              @Override\n-              public void vMotionBeforeCQRegistration() {}\n-\n-              @Override\n-              public void vMotionBeforeRegisterInterest() {}\n-\n-              @Override\n-              public void vMotionDuringGII(Set recipientSet, LocalRegion region) {\n-                InitialImageOperation.VMOTION_DURING_GII = false;\n-                final InitializationLevel oldLevel =\n-                    LocalRegion.setThreadInitLevelRequirement(BEFORE_INITIAL_IMAGE);\n-                LocalRegion ccregion = (LocalRegion) cache.getInternalRegionByPath(\"/\" + name);\n-                try {\n-                  // wait for the update op (sent below from vm1) to arrive, then allow the GII to\n-                  // happen\n-                  while (!ccregion.isDestroyed() && ccregion.getRegionEntry(key) == null) {\n-                    try {\n-                      Thread.sleep(1000);\n-                    } catch (InterruptedException e) {\n-                      return;\n-                    }\n+        vm2.invokeAsync(\"create region with stall\", () -> {\n+\n+          final GemFireCacheImpl cache = (GemFireCacheImpl) getCache();\n+          RegionFactory f = cache.createRegionFactory(getRegionAttributes());\n+          InitialImageOperation.VMOTION_DURING_GII = true;\n+          // this will stall region creation at the point of asking for an initial image\n+          VMotionObserverHolder.setInstance(new VMotionObserver() {\n+            @Override\n+            public void vMotionBeforeCQRegistration() {}\n+\n+            @Override\n+            public void vMotionBeforeRegisterInterest() {}\n+\n+            @Override\n+            public void vMotionDuringGII(Set recipientSet, LocalRegion region) {\n+              InitialImageOperation.VMOTION_DURING_GII = false;\n+              final InitializationLevel oldLevel =\n+                  LocalRegion.setThreadInitLevelRequirement(BEFORE_INITIAL_IMAGE);\n+              LocalRegion ccregion = (LocalRegion) cache.getInternalRegionByPath(\"/\" + name);\n+              try {\n+                // wait for the update op (sent below from vm1) to arrive, then allow the GII to\n+                // happen\n+                while (!ccregion.isDestroyed() && ccregion.getRegionEntry(key) == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA5OTM2OQ=="}, "originalCommit": {"oid": "9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDUzNTE1OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache30/DistributedAckRegionCCEDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxOTozMDoxM1rOFfDECQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QyMDo0MjoxMFrOFfEvOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwMDM2MQ==", "bodyText": "Delete any catch block with a fail and let the test throw UnknownHostException.", "url": "https://github.com/apache/geode/pull/4568#discussion_r368100361", "createdAt": "2020-01-17T19:30:13Z", "author": {"login": "kirklund"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache30/DistributedAckRegionCCEDUnitTest.java", "diffHunk": "@@ -147,129 +146,118 @@ public void testConcurrentOpWithGII() {\n     VM vm2 = VM.getVM(2);\n \n     // create some destroyed entries so the GC service is populated\n-    SerializableCallable create = new SerializableCallable(\"create region\") {\n-      @Override\n-      public Object call() {\n-        RegionFactory f = getCache().createRegionFactory(getRegionAttributes());\n-        CCRegion = (LocalRegion) f.create(name);\n-        return CCRegion.getDistributionManager().getDistributionManagerId();\n-      }\n-    };\n     // do conflicting update() and destroy() on the region. We want the update() to\n     // be sent with a message and the destroy() to be transferred in the initial image\n     // and be the value that we want to keep\n-    vm1.invoke(create);\n+    vm1.invoke(\"create region\", () -> {\n+      RegionFactory f1 = getCache().createRegionFactory(getRegionAttributes());\n+      CCRegion = (LocalRegion) f1.create(name);\n+      return CCRegion.getDistributionManager().getDistributionManagerId();\n+    });\n \n     AsyncInvocation partialCreate =\n-        vm2.invokeAsync(new SerializableCallable<Object>(\"create region with stall\") {\n-          @Override\n-          public Object call() {\n-            final GemFireCacheImpl cache = (GemFireCacheImpl) getCache();\n-            RegionFactory f = cache.createRegionFactory(getRegionAttributes());\n-            InitialImageOperation.VMOTION_DURING_GII = true;\n-            // this will stall region creation at the point of asking for an initial image\n-            VMotionObserverHolder.setInstance(new VMotionObserver() {\n-              @Override\n-              public void vMotionBeforeCQRegistration() {}\n-\n-              @Override\n-              public void vMotionBeforeRegisterInterest() {}\n-\n-              @Override\n-              public void vMotionDuringGII(Set recipientSet, LocalRegion region) {\n-                InitialImageOperation.VMOTION_DURING_GII = false;\n-                final InitializationLevel oldLevel =\n-                    LocalRegion.setThreadInitLevelRequirement(BEFORE_INITIAL_IMAGE);\n-                LocalRegion ccregion = (LocalRegion) cache.getInternalRegionByPath(\"/\" + name);\n-                try {\n-                  // wait for the update op (sent below from vm1) to arrive, then allow the GII to\n-                  // happen\n-                  while (!ccregion.isDestroyed() && ccregion.getRegionEntry(key) == null) {\n-                    try {\n-                      Thread.sleep(1000);\n-                    } catch (InterruptedException e) {\n-                      return;\n-                    }\n+        vm2.invokeAsync(\"create region with stall\", () -> {\n+\n+          final GemFireCacheImpl cache = (GemFireCacheImpl) getCache();\n+          RegionFactory f = cache.createRegionFactory(getRegionAttributes());\n+          InitialImageOperation.VMOTION_DURING_GII = true;\n+          // this will stall region creation at the point of asking for an initial image\n+          VMotionObserverHolder.setInstance(new VMotionObserver() {\n+            @Override\n+            public void vMotionBeforeCQRegistration() {}\n+\n+            @Override\n+            public void vMotionBeforeRegisterInterest() {}\n+\n+            @Override\n+            public void vMotionDuringGII(Set recipientSet, LocalRegion region) {\n+              InitialImageOperation.VMOTION_DURING_GII = false;\n+              final InitializationLevel oldLevel =\n+                  LocalRegion.setThreadInitLevelRequirement(BEFORE_INITIAL_IMAGE);\n+              LocalRegion ccregion = (LocalRegion) cache.getInternalRegionByPath(\"/\" + name);\n+              try {\n+                // wait for the update op (sent below from vm1) to arrive, then allow the GII to\n+                // happen\n+                while (!ccregion.isDestroyed() && ccregion.getRegionEntry(key) == null) {\n+                  try {\n+                    Thread.sleep(1000);\n+                  } catch (InterruptedException e) {\n+                    return;\n                   }\n-                } finally {\n-                  LocalRegion.setThreadInitLevelRequirement(oldLevel);\n                 }\n+              } finally {\n+                LocalRegion.setThreadInitLevelRequirement(oldLevel);\n               }\n-            });\n-            try {\n-              CCRegion = (LocalRegion) f.create(name);\n-              // at this point we should have received the update op and then the GII, which should\n-              // overwrite\n-              // the conflicting update op\n-              assertThat(CCRegion.containsKey(key))\n-                  .describedAs(\"entry was destroyed by initial image transfer\")\n-                  .isFalse();\n-            } finally {\n-              InitialImageOperation.VMOTION_DURING_GII = false;\n             }\n-            return null;\n-          }\n-        });\n-    vm1.invoke(new SerializableRunnable(\"create conflicting events\") {\n-      @Override\n-      public void run() {\n-        // wait for the other to come on line\n-        long waitEnd = System.currentTimeMillis() + 45000;\n-        DistributionAdvisor adv = ((DistributedRegion) CCRegion).getCacheDistributionAdvisor();\n-        while (System.currentTimeMillis() < waitEnd && adv.adviseGeneric().isEmpty()) {\n+          });\n           try {\n-            Thread.sleep(1000);\n-          } catch (InterruptedException e) {\n-            return;\n+            CCRegion = (LocalRegion) f.create(name);\n+            // at this point we should have received the update op and then the GII, which should\n+            // overwrite the conflicting update op\n+            assertThat(CCRegion.containsKey(key))\n+                .describedAs(\"entry was destroyed by initial image transfer\")\n+                .isFalse();\n+          } finally {\n+            InitialImageOperation.VMOTION_DURING_GII = false;\n           }\n-        }\n-        assertThat(adv.adviseGeneric())\n-            .withFailMessage(\"other member never came on line\")\n-            .isNotEmpty();\n-\n-        DistributedCacheOperation.LOSS_SIMULATION_RATIO = 200.0; // inhibit all messaging\n-        try {\n-          CCRegion.put(\"mykey\", \"initialValue\");\n-          CCRegion.destroy(\"mykey\");\n-        } finally {\n-          DistributedCacheOperation.LOSS_SIMULATION_RATIO = 0.0;\n-        }\n+          return null;\n+        });\n \n-        // generate a fake version tag for the message\n-        final VersionStamp versionStamp = CCRegion.getRegionEntry(key).getVersionStamp();\n-        VersionTag<InternalDistributedMember> tag =\n-            (VersionTag<InternalDistributedMember>) versionStamp.asVersionTag();\n-        // create a fake member ID that will be < mine and lose a concurrency check\n-        MemberData nm =\n-            CCRegion.getDistributionManager().getDistributionManagerId().getMemberData();\n-        InternalDistributedMember mbr = null;\n+    vm1.invoke(\"create conflicting events\", () -> {\n+      // wait for the other to come on line\n+      long waitEnd = System.currentTimeMillis() + 45000;\n+      DistributionAdvisor adv = ((DistributedRegion) CCRegion).getCacheDistributionAdvisor();\n+      while (System.currentTimeMillis() < waitEnd && adv.adviseGeneric().isEmpty()) {\n         try {\n-          mbr = new InternalDistributedMember(nm.getInetAddress().getCanonicalHostName(),\n-              nm.getMembershipPort() - 1, \"fake_id\", \"fake_id_ustring\",\n-              ClusterDistributionManager.NORMAL_DM_TYPE, null, null);\n-          tag.setMemberID(mbr);\n-        } catch (UnknownHostException e) {\n-          fail(\"could not create member id: \", e);\n+          Thread.sleep(1000);\n+        } catch (InterruptedException e) {\n+          return;\n         }\n+      }\n+      assertThat(adv.adviseGeneric())\n+          .withFailMessage(\"other member never came on line\")\n+          .isNotEmpty();\n+\n+      DistributedCacheOperation.LOSS_SIMULATION_RATIO = 200.0; // inhibit all messaging\n+      try {\n+        CCRegion.put(\"mykey\", \"initialValue\");\n+        CCRegion.destroy(\"mykey\");\n+      } finally {\n+        DistributedCacheOperation.LOSS_SIMULATION_RATIO = 0.0;\n+      }\n \n-        // generate an event to distribute that contains the fake version tag\n-        EntryEventImpl event =\n-            EntryEventImpl.create(CCRegion, Operation.UPDATE, key, false, mbr, true, false);\n-        event.setNewValue(\"newValue\");\n-        event.setVersionTag(tag);\n-\n-        // this should update the controller's cache with the updated value but leave this cache\n-        // alone\n-        DistributedCacheOperation op = new UpdateOperation(event, tag.getVersionTimeStamp());\n-        op.distribute();\n-        event.release();\n+      // generate a fake version tag for the message\n+      final VersionStamp versionStamp = CCRegion.getRegionEntry(key).getVersionStamp();\n+      VersionTag<InternalDistributedMember> tag =\n+          (VersionTag<InternalDistributedMember>) versionStamp.asVersionTag();\n+      // create a fake member ID that will be < mine and lose a concurrency check\n+      MemberData nm =\n+          CCRegion.getDistributionManager().getDistributionManagerId().getMemberData();\n+      InternalDistributedMember mbr = null;\n+      try {\n+        mbr = new InternalDistributedMember(nm.getInetAddress().getCanonicalHostName(),\n+            nm.getMembershipPort() - 1, \"fake_id\", \"fake_id_ustring\",\n+            ClusterDistributionManager.NORMAL_DM_TYPE, null, null);\n+        tag.setMemberID(mbr);\n+      } catch (UnknownHostException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEyNzgwMw==", "bodyText": "done", "url": "https://github.com/apache/geode/pull/4568#discussion_r368127803", "createdAt": "2020-01-17T20:42:10Z", "author": {"login": "mhansonp"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache30/DistributedAckRegionCCEDUnitTest.java", "diffHunk": "@@ -147,129 +146,118 @@ public void testConcurrentOpWithGII() {\n     VM vm2 = VM.getVM(2);\n \n     // create some destroyed entries so the GC service is populated\n-    SerializableCallable create = new SerializableCallable(\"create region\") {\n-      @Override\n-      public Object call() {\n-        RegionFactory f = getCache().createRegionFactory(getRegionAttributes());\n-        CCRegion = (LocalRegion) f.create(name);\n-        return CCRegion.getDistributionManager().getDistributionManagerId();\n-      }\n-    };\n     // do conflicting update() and destroy() on the region. We want the update() to\n     // be sent with a message and the destroy() to be transferred in the initial image\n     // and be the value that we want to keep\n-    vm1.invoke(create);\n+    vm1.invoke(\"create region\", () -> {\n+      RegionFactory f1 = getCache().createRegionFactory(getRegionAttributes());\n+      CCRegion = (LocalRegion) f1.create(name);\n+      return CCRegion.getDistributionManager().getDistributionManagerId();\n+    });\n \n     AsyncInvocation partialCreate =\n-        vm2.invokeAsync(new SerializableCallable<Object>(\"create region with stall\") {\n-          @Override\n-          public Object call() {\n-            final GemFireCacheImpl cache = (GemFireCacheImpl) getCache();\n-            RegionFactory f = cache.createRegionFactory(getRegionAttributes());\n-            InitialImageOperation.VMOTION_DURING_GII = true;\n-            // this will stall region creation at the point of asking for an initial image\n-            VMotionObserverHolder.setInstance(new VMotionObserver() {\n-              @Override\n-              public void vMotionBeforeCQRegistration() {}\n-\n-              @Override\n-              public void vMotionBeforeRegisterInterest() {}\n-\n-              @Override\n-              public void vMotionDuringGII(Set recipientSet, LocalRegion region) {\n-                InitialImageOperation.VMOTION_DURING_GII = false;\n-                final InitializationLevel oldLevel =\n-                    LocalRegion.setThreadInitLevelRequirement(BEFORE_INITIAL_IMAGE);\n-                LocalRegion ccregion = (LocalRegion) cache.getInternalRegionByPath(\"/\" + name);\n-                try {\n-                  // wait for the update op (sent below from vm1) to arrive, then allow the GII to\n-                  // happen\n-                  while (!ccregion.isDestroyed() && ccregion.getRegionEntry(key) == null) {\n-                    try {\n-                      Thread.sleep(1000);\n-                    } catch (InterruptedException e) {\n-                      return;\n-                    }\n+        vm2.invokeAsync(\"create region with stall\", () -> {\n+\n+          final GemFireCacheImpl cache = (GemFireCacheImpl) getCache();\n+          RegionFactory f = cache.createRegionFactory(getRegionAttributes());\n+          InitialImageOperation.VMOTION_DURING_GII = true;\n+          // this will stall region creation at the point of asking for an initial image\n+          VMotionObserverHolder.setInstance(new VMotionObserver() {\n+            @Override\n+            public void vMotionBeforeCQRegistration() {}\n+\n+            @Override\n+            public void vMotionBeforeRegisterInterest() {}\n+\n+            @Override\n+            public void vMotionDuringGII(Set recipientSet, LocalRegion region) {\n+              InitialImageOperation.VMOTION_DURING_GII = false;\n+              final InitializationLevel oldLevel =\n+                  LocalRegion.setThreadInitLevelRequirement(BEFORE_INITIAL_IMAGE);\n+              LocalRegion ccregion = (LocalRegion) cache.getInternalRegionByPath(\"/\" + name);\n+              try {\n+                // wait for the update op (sent below from vm1) to arrive, then allow the GII to\n+                // happen\n+                while (!ccregion.isDestroyed() && ccregion.getRegionEntry(key) == null) {\n+                  try {\n+                    Thread.sleep(1000);\n+                  } catch (InterruptedException e) {\n+                    return;\n                   }\n-                } finally {\n-                  LocalRegion.setThreadInitLevelRequirement(oldLevel);\n                 }\n+              } finally {\n+                LocalRegion.setThreadInitLevelRequirement(oldLevel);\n               }\n-            });\n-            try {\n-              CCRegion = (LocalRegion) f.create(name);\n-              // at this point we should have received the update op and then the GII, which should\n-              // overwrite\n-              // the conflicting update op\n-              assertThat(CCRegion.containsKey(key))\n-                  .describedAs(\"entry was destroyed by initial image transfer\")\n-                  .isFalse();\n-            } finally {\n-              InitialImageOperation.VMOTION_DURING_GII = false;\n             }\n-            return null;\n-          }\n-        });\n-    vm1.invoke(new SerializableRunnable(\"create conflicting events\") {\n-      @Override\n-      public void run() {\n-        // wait for the other to come on line\n-        long waitEnd = System.currentTimeMillis() + 45000;\n-        DistributionAdvisor adv = ((DistributedRegion) CCRegion).getCacheDistributionAdvisor();\n-        while (System.currentTimeMillis() < waitEnd && adv.adviseGeneric().isEmpty()) {\n+          });\n           try {\n-            Thread.sleep(1000);\n-          } catch (InterruptedException e) {\n-            return;\n+            CCRegion = (LocalRegion) f.create(name);\n+            // at this point we should have received the update op and then the GII, which should\n+            // overwrite the conflicting update op\n+            assertThat(CCRegion.containsKey(key))\n+                .describedAs(\"entry was destroyed by initial image transfer\")\n+                .isFalse();\n+          } finally {\n+            InitialImageOperation.VMOTION_DURING_GII = false;\n           }\n-        }\n-        assertThat(adv.adviseGeneric())\n-            .withFailMessage(\"other member never came on line\")\n-            .isNotEmpty();\n-\n-        DistributedCacheOperation.LOSS_SIMULATION_RATIO = 200.0; // inhibit all messaging\n-        try {\n-          CCRegion.put(\"mykey\", \"initialValue\");\n-          CCRegion.destroy(\"mykey\");\n-        } finally {\n-          DistributedCacheOperation.LOSS_SIMULATION_RATIO = 0.0;\n-        }\n+          return null;\n+        });\n \n-        // generate a fake version tag for the message\n-        final VersionStamp versionStamp = CCRegion.getRegionEntry(key).getVersionStamp();\n-        VersionTag<InternalDistributedMember> tag =\n-            (VersionTag<InternalDistributedMember>) versionStamp.asVersionTag();\n-        // create a fake member ID that will be < mine and lose a concurrency check\n-        MemberData nm =\n-            CCRegion.getDistributionManager().getDistributionManagerId().getMemberData();\n-        InternalDistributedMember mbr = null;\n+    vm1.invoke(\"create conflicting events\", () -> {\n+      // wait for the other to come on line\n+      long waitEnd = System.currentTimeMillis() + 45000;\n+      DistributionAdvisor adv = ((DistributedRegion) CCRegion).getCacheDistributionAdvisor();\n+      while (System.currentTimeMillis() < waitEnd && adv.adviseGeneric().isEmpty()) {\n         try {\n-          mbr = new InternalDistributedMember(nm.getInetAddress().getCanonicalHostName(),\n-              nm.getMembershipPort() - 1, \"fake_id\", \"fake_id_ustring\",\n-              ClusterDistributionManager.NORMAL_DM_TYPE, null, null);\n-          tag.setMemberID(mbr);\n-        } catch (UnknownHostException e) {\n-          fail(\"could not create member id: \", e);\n+          Thread.sleep(1000);\n+        } catch (InterruptedException e) {\n+          return;\n         }\n+      }\n+      assertThat(adv.adviseGeneric())\n+          .withFailMessage(\"other member never came on line\")\n+          .isNotEmpty();\n+\n+      DistributedCacheOperation.LOSS_SIMULATION_RATIO = 200.0; // inhibit all messaging\n+      try {\n+        CCRegion.put(\"mykey\", \"initialValue\");\n+        CCRegion.destroy(\"mykey\");\n+      } finally {\n+        DistributedCacheOperation.LOSS_SIMULATION_RATIO = 0.0;\n+      }\n \n-        // generate an event to distribute that contains the fake version tag\n-        EntryEventImpl event =\n-            EntryEventImpl.create(CCRegion, Operation.UPDATE, key, false, mbr, true, false);\n-        event.setNewValue(\"newValue\");\n-        event.setVersionTag(tag);\n-\n-        // this should update the controller's cache with the updated value but leave this cache\n-        // alone\n-        DistributedCacheOperation op = new UpdateOperation(event, tag.getVersionTimeStamp());\n-        op.distribute();\n-        event.release();\n+      // generate a fake version tag for the message\n+      final VersionStamp versionStamp = CCRegion.getRegionEntry(key).getVersionStamp();\n+      VersionTag<InternalDistributedMember> tag =\n+          (VersionTag<InternalDistributedMember>) versionStamp.asVersionTag();\n+      // create a fake member ID that will be < mine and lose a concurrency check\n+      MemberData nm =\n+          CCRegion.getDistributionManager().getDistributionManagerId().getMemberData();\n+      InternalDistributedMember mbr = null;\n+      try {\n+        mbr = new InternalDistributedMember(nm.getInetAddress().getCanonicalHostName(),\n+            nm.getMembershipPort() - 1, \"fake_id\", \"fake_id_ustring\",\n+            ClusterDistributionManager.NORMAL_DM_TYPE, null, null);\n+        tag.setMemberID(mbr);\n+      } catch (UnknownHostException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwMDM2MQ=="}, "originalCommit": {"oid": "9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6"}, "originalPosition": 215}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDUzOTA3OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache30/DistributedAckRegionCCEDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxOTozMTozN1rOFfDGXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QyMDo0MzowM1rOFfEwdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwMDk1Nw==", "bodyText": "Delete this catch block and change the methods to throws Exception.", "url": "https://github.com/apache/geode/pull/4568#discussion_r368100957", "createdAt": "2020-01-17T19:31:37Z", "author": {"login": "kirklund"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache30/DistributedAckRegionCCEDUnitTest.java", "diffHunk": "@@ -312,63 +299,47 @@ public void testTombstoneExpirationRace() {\n     VM vm1 = VM.getVM(1);\n \n     final String name = this.getUniqueName() + \"-CC\";\n-    SerializableRunnable createRegion = new SerializableRunnable(\"Create Region\") {\n+    SerializableRunnable createRegion = new SerializableRunnable() {\n       @Override\n       public void run() {\n-        try {\n-          RegionFactory f = getCache().createRegionFactory(getRegionAttributes());\n-          CCRegion = (LocalRegion) f.create(name);\n-          CCRegion.put(\"cckey0\", \"ccvalue\");\n-          CCRegion.put(\"cckey0\", \"ccvalue\"); // version number will end up at 4\n-        } catch (CacheException ex) {\n-          ex.printStackTrace();\n-          fail(\"While creating region \", ex);\n-        }\n+        RegionFactory f = getCache().createRegionFactory(getRegionAttributes());\n+        CCRegion = (LocalRegion) f.create(name);\n+        CCRegion.put(\"cckey0\", \"ccvalue\");\n+        CCRegion.put(\"cckey0\", \"ccvalue\"); // version number will end up at 4;\n       }\n     };\n \n-    vm0.invoke(createRegion);\n-    vm1.invoke(createRegion);\n-    vm1.invoke(new SerializableRunnable(\"Create local tombstone and adjust time\") {\n-      @Override\n-      public void run() {\n-        // make the entry for cckey0 a tombstone in this VM and set its modification time to be\n-        // older\n-        // than the tombstone GC interval. This means it could be in the process of being reaped by\n-        // distributed-GC\n-        RegionEntry entry = CCRegion.getRegionEntry(\"cckey0\");\n-        VersionTag tag = entry.getVersionStamp().asVersionTag();\n-        assertThat(tag.getEntryVersion()).isGreaterThan(1);\n-        tag.setVersionTimeStamp(\n-            System.currentTimeMillis() - TombstoneService.REPLICATE_TOMBSTONE_TIMEOUT - 1000);\n-        entry.getVersionStamp().setVersionTimeStamp(tag.getVersionTimeStamp());\n-        try {\n-          entry.makeTombstone(CCRegion, tag);\n-        } catch (RegionClearedException e) {\n-\n-          fail(\"region was mysteriously cleared during unit testing \", e);\n-        }\n+    vm0.invoke(\"Create Region\", createRegion);\n+    vm1.invoke(\"Create Region\", createRegion);\n+    vm1.invoke(\"Create local tombstone and adjust time\", () -> {\n+      // make the entry for cckey0 a tombstone in this VM and set its modification time to be\n+      // older than the tombstone GC interval. This means it could be in the process of being\n+      // reaped by distributed-GC\n+      RegionEntry entry = CCRegion.getRegionEntry(\"cckey0\");\n+      VersionTag tag = entry.getVersionStamp().asVersionTag();\n+      assertThat(tag.getEntryVersion()).isGreaterThan(1);\n+      tag.setVersionTimeStamp(\n+          System.currentTimeMillis() - TombstoneService.REPLICATE_TOMBSTONE_TIMEOUT - 1000);\n+      entry.getVersionStamp().setVersionTimeStamp(tag.getVersionTimeStamp());\n+      try {\n+        entry.makeTombstone(CCRegion, tag);\n+      } catch (RegionClearedException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6"}, "originalPosition": 317}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEyODExOA==", "bodyText": "done", "url": "https://github.com/apache/geode/pull/4568#discussion_r368128118", "createdAt": "2020-01-17T20:43:03Z", "author": {"login": "mhansonp"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache30/DistributedAckRegionCCEDUnitTest.java", "diffHunk": "@@ -312,63 +299,47 @@ public void testTombstoneExpirationRace() {\n     VM vm1 = VM.getVM(1);\n \n     final String name = this.getUniqueName() + \"-CC\";\n-    SerializableRunnable createRegion = new SerializableRunnable(\"Create Region\") {\n+    SerializableRunnable createRegion = new SerializableRunnable() {\n       @Override\n       public void run() {\n-        try {\n-          RegionFactory f = getCache().createRegionFactory(getRegionAttributes());\n-          CCRegion = (LocalRegion) f.create(name);\n-          CCRegion.put(\"cckey0\", \"ccvalue\");\n-          CCRegion.put(\"cckey0\", \"ccvalue\"); // version number will end up at 4\n-        } catch (CacheException ex) {\n-          ex.printStackTrace();\n-          fail(\"While creating region \", ex);\n-        }\n+        RegionFactory f = getCache().createRegionFactory(getRegionAttributes());\n+        CCRegion = (LocalRegion) f.create(name);\n+        CCRegion.put(\"cckey0\", \"ccvalue\");\n+        CCRegion.put(\"cckey0\", \"ccvalue\"); // version number will end up at 4;\n       }\n     };\n \n-    vm0.invoke(createRegion);\n-    vm1.invoke(createRegion);\n-    vm1.invoke(new SerializableRunnable(\"Create local tombstone and adjust time\") {\n-      @Override\n-      public void run() {\n-        // make the entry for cckey0 a tombstone in this VM and set its modification time to be\n-        // older\n-        // than the tombstone GC interval. This means it could be in the process of being reaped by\n-        // distributed-GC\n-        RegionEntry entry = CCRegion.getRegionEntry(\"cckey0\");\n-        VersionTag tag = entry.getVersionStamp().asVersionTag();\n-        assertThat(tag.getEntryVersion()).isGreaterThan(1);\n-        tag.setVersionTimeStamp(\n-            System.currentTimeMillis() - TombstoneService.REPLICATE_TOMBSTONE_TIMEOUT - 1000);\n-        entry.getVersionStamp().setVersionTimeStamp(tag.getVersionTimeStamp());\n-        try {\n-          entry.makeTombstone(CCRegion, tag);\n-        } catch (RegionClearedException e) {\n-\n-          fail(\"region was mysteriously cleared during unit testing \", e);\n-        }\n+    vm0.invoke(\"Create Region\", createRegion);\n+    vm1.invoke(\"Create Region\", createRegion);\n+    vm1.invoke(\"Create local tombstone and adjust time\", () -> {\n+      // make the entry for cckey0 a tombstone in this VM and set its modification time to be\n+      // older than the tombstone GC interval. This means it could be in the process of being\n+      // reaped by distributed-GC\n+      RegionEntry entry = CCRegion.getRegionEntry(\"cckey0\");\n+      VersionTag tag = entry.getVersionStamp().asVersionTag();\n+      assertThat(tag.getEntryVersion()).isGreaterThan(1);\n+      tag.setVersionTimeStamp(\n+          System.currentTimeMillis() - TombstoneService.REPLICATE_TOMBSTONE_TIMEOUT - 1000);\n+      entry.getVersionStamp().setVersionTimeStamp(tag.getVersionTimeStamp());\n+      try {\n+        entry.makeTombstone(CCRegion, tag);\n+      } catch (RegionClearedException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwMDk1Nw=="}, "originalCommit": {"oid": "9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6"}, "originalPosition": 317}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDU0NDUyOnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionCCEDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxOTozMzo0MVrOFfDJtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QyMDo0NzoxNVrOFfE2WA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwMTgxMg==", "bodyText": "Optional: Delete this catch block. CacheException is a RuntimeException so it doesn't even requires a throws clause.", "url": "https://github.com/apache/geode/pull/4568#discussion_r368101812", "createdAt": "2020-01-17T19:33:41Z", "author": {"login": "kirklund"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionCCEDUnitTest.java", "diffHunk": "@@ -163,78 +150,58 @@ public void testTombstones() {\n    */\n   @Test\n   public void testTombstoneExpirationRace() {\n-    VM vm0 = VM.getVM(0);\n-    VM vm1 = VM.getVM(1);\n \n     final String name = this.getUniqueName() + \"-CC\";\n-    SerializableRunnable createRegion = new SerializableRunnable(\"Create Region\") {\n+    SerializableRunnable createRegion = new SerializableRunnable() {\n       @Override\n       public void run() {\n         try {\n           RegionFactory f = getCache().createRegionFactory(getRegionAttributes());\n           CCRegion = (LocalRegion) f.create(name);\n+\n+          // noinspection OverwrittenKey\n           CCRegion.put(\"cckey0\", \"ccvalue\");\n+          // noinspection OverwrittenKey\n           CCRegion.put(\"cckey0\", \"ccvalue\"); // version number will end up at 4\n         } catch (CacheException ex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEyOTYyNA==", "bodyText": "done", "url": "https://github.com/apache/geode/pull/4568#discussion_r368129624", "createdAt": "2020-01-17T20:47:15Z", "author": {"login": "mhansonp"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionCCEDUnitTest.java", "diffHunk": "@@ -163,78 +150,58 @@ public void testTombstones() {\n    */\n   @Test\n   public void testTombstoneExpirationRace() {\n-    VM vm0 = VM.getVM(0);\n-    VM vm1 = VM.getVM(1);\n \n     final String name = this.getUniqueName() + \"-CC\";\n-    SerializableRunnable createRegion = new SerializableRunnable(\"Create Region\") {\n+    SerializableRunnable createRegion = new SerializableRunnable() {\n       @Override\n       public void run() {\n         try {\n           RegionFactory f = getCache().createRegionFactory(getRegionAttributes());\n           CCRegion = (LocalRegion) f.create(name);\n+\n+          // noinspection OverwrittenKey\n           CCRegion.put(\"cckey0\", \"ccvalue\");\n+          // noinspection OverwrittenKey\n           CCRegion.put(\"cckey0\", \"ccvalue\"); // version number will end up at 4\n         } catch (CacheException ex) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwMTgxMg=="}, "originalCommit": {"oid": "9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDU0NTMwOnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionCCEDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxOTozNDowMFrOFfDKMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QyMDo0Nzo0N1rOFfE3Cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwMTkzNg==", "bodyText": "Another catch block to delete.", "url": "https://github.com/apache/geode/pull/4568#discussion_r368101936", "createdAt": "2020-01-17T19:34:00Z", "author": {"login": "kirklund"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionCCEDUnitTest.java", "diffHunk": "@@ -163,78 +150,58 @@ public void testTombstones() {\n    */\n   @Test\n   public void testTombstoneExpirationRace() {\n-    VM vm0 = VM.getVM(0);\n-    VM vm1 = VM.getVM(1);\n \n     final String name = this.getUniqueName() + \"-CC\";\n-    SerializableRunnable createRegion = new SerializableRunnable(\"Create Region\") {\n+    SerializableRunnable createRegion = new SerializableRunnable() {\n       @Override\n       public void run() {\n         try {\n           RegionFactory f = getCache().createRegionFactory(getRegionAttributes());\n           CCRegion = (LocalRegion) f.create(name);\n+\n+          // noinspection OverwrittenKey\n           CCRegion.put(\"cckey0\", \"ccvalue\");\n+          // noinspection OverwrittenKey\n           CCRegion.put(\"cckey0\", \"ccvalue\"); // version number will end up at 4\n         } catch (CacheException ex) {\n           fail(\"While creating region\", ex);\n         }\n       }\n     };\n-    vm0.invoke(createRegion);\n-    vm1.invoke(createRegion);\n-    vm1.invoke(new SerializableRunnable(\"Create local tombstone and adjust time\") {\n-      @Override\n-      public void run() {\n-        // make the entry for cckey0 a tombstone in this VM and set its\n-        // modification time to be older than the tombstone GC interval. This\n-        // means it could be in the process of being reaped by distributed-GC\n-        RegionEntry entry = CCRegion.getRegionEntry(\"cckey0\");\n-        VersionTag tag = entry.getVersionStamp().asVersionTag();\n-        assertTrue(tag.getEntryVersion() > 1);\n-        tag.setVersionTimeStamp(\n-            System.currentTimeMillis() - TombstoneService.REPLICATE_TOMBSTONE_TIMEOUT - 1000);\n-        entry.getVersionStamp().setVersionTimeStamp(tag.getVersionTimeStamp());\n-        try {\n-          entry.makeTombstone(CCRegion, tag);\n-        } catch (RegionClearedException e) {\n-          fail(\"region was mysteriously cleared during unit testing\", e);\n-        }\n+    vm0.invoke(\"Create Region\", createRegion);\n+    vm1.invoke(\"Create Region\", createRegion);\n+    vm1.invoke(\"Create local tombstone and adjust time\", () -> {\n+      // make the entry for cckey0 a tombstone in this VM and set its\n+      // modification time to be older than the tombstone GC interval. This\n+      // means it could be in the process of being reaped by distributed-GC\n+      RegionEntry entry = CCRegion.getRegionEntry(\"cckey0\");\n+      VersionTag tag = entry.getVersionStamp().asVersionTag();\n+      assertTrue(tag.getEntryVersion() > 1);\n+      tag.setVersionTimeStamp(\n+          System.currentTimeMillis() - TombstoneService.REPLICATE_TOMBSTONE_TIMEOUT - 1000);\n+      entry.getVersionStamp().setVersionTimeStamp(tag.getVersionTimeStamp());\n+      try {\n+        entry.makeTombstone(CCRegion, tag);\n+      } catch (RegionClearedException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEyOTgwMg==", "bodyText": "done", "url": "https://github.com/apache/geode/pull/4568#discussion_r368129802", "createdAt": "2020-01-17T20:47:47Z", "author": {"login": "mhansonp"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionCCEDUnitTest.java", "diffHunk": "@@ -163,78 +150,58 @@ public void testTombstones() {\n    */\n   @Test\n   public void testTombstoneExpirationRace() {\n-    VM vm0 = VM.getVM(0);\n-    VM vm1 = VM.getVM(1);\n \n     final String name = this.getUniqueName() + \"-CC\";\n-    SerializableRunnable createRegion = new SerializableRunnable(\"Create Region\") {\n+    SerializableRunnable createRegion = new SerializableRunnable() {\n       @Override\n       public void run() {\n         try {\n           RegionFactory f = getCache().createRegionFactory(getRegionAttributes());\n           CCRegion = (LocalRegion) f.create(name);\n+\n+          // noinspection OverwrittenKey\n           CCRegion.put(\"cckey0\", \"ccvalue\");\n+          // noinspection OverwrittenKey\n           CCRegion.put(\"cckey0\", \"ccvalue\"); // version number will end up at 4\n         } catch (CacheException ex) {\n           fail(\"While creating region\", ex);\n         }\n       }\n     };\n-    vm0.invoke(createRegion);\n-    vm1.invoke(createRegion);\n-    vm1.invoke(new SerializableRunnable(\"Create local tombstone and adjust time\") {\n-      @Override\n-      public void run() {\n-        // make the entry for cckey0 a tombstone in this VM and set its\n-        // modification time to be older than the tombstone GC interval. This\n-        // means it could be in the process of being reaped by distributed-GC\n-        RegionEntry entry = CCRegion.getRegionEntry(\"cckey0\");\n-        VersionTag tag = entry.getVersionStamp().asVersionTag();\n-        assertTrue(tag.getEntryVersion() > 1);\n-        tag.setVersionTimeStamp(\n-            System.currentTimeMillis() - TombstoneService.REPLICATE_TOMBSTONE_TIMEOUT - 1000);\n-        entry.getVersionStamp().setVersionTimeStamp(tag.getVersionTimeStamp());\n-        try {\n-          entry.makeTombstone(CCRegion, tag);\n-        } catch (RegionClearedException e) {\n-          fail(\"region was mysteriously cleared during unit testing\", e);\n-        }\n+    vm0.invoke(\"Create Region\", createRegion);\n+    vm1.invoke(\"Create Region\", createRegion);\n+    vm1.invoke(\"Create local tombstone and adjust time\", () -> {\n+      // make the entry for cckey0 a tombstone in this VM and set its\n+      // modification time to be older than the tombstone GC interval. This\n+      // means it could be in the process of being reaped by distributed-GC\n+      RegionEntry entry = CCRegion.getRegionEntry(\"cckey0\");\n+      VersionTag tag = entry.getVersionStamp().asVersionTag();\n+      assertTrue(tag.getEntryVersion() > 1);\n+      tag.setVersionTimeStamp(\n+          System.currentTimeMillis() - TombstoneService.REPLICATE_TOMBSTONE_TIMEOUT - 1000);\n+      entry.getVersionStamp().setVersionTimeStamp(tag.getVersionTimeStamp());\n+      try {\n+        entry.makeTombstone(CCRegion, tag);\n+      } catch (RegionClearedException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwMTkzNg=="}, "originalCommit": {"oid": "9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDU0NjcxOnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionCCEDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxOTozNDozOVrOFfDLFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QyMDo0OToxOFrOFfE5SQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwMjE2Nw==", "bodyText": "Replace this if and fail block with an assertion:\nassertThat(CCRegion.getRegionEntry(\"ckey0\")).isNull();", "url": "https://github.com/apache/geode/pull/4568#discussion_r368102167", "createdAt": "2020-01-17T19:34:39Z", "author": {"login": "kirklund"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionCCEDUnitTest.java", "diffHunk": "@@ -163,78 +150,58 @@ public void testTombstones() {\n    */\n   @Test\n   public void testTombstoneExpirationRace() {\n-    VM vm0 = VM.getVM(0);\n-    VM vm1 = VM.getVM(1);\n \n     final String name = this.getUniqueName() + \"-CC\";\n-    SerializableRunnable createRegion = new SerializableRunnable(\"Create Region\") {\n+    SerializableRunnable createRegion = new SerializableRunnable() {\n       @Override\n       public void run() {\n         try {\n           RegionFactory f = getCache().createRegionFactory(getRegionAttributes());\n           CCRegion = (LocalRegion) f.create(name);\n+\n+          // noinspection OverwrittenKey\n           CCRegion.put(\"cckey0\", \"ccvalue\");\n+          // noinspection OverwrittenKey\n           CCRegion.put(\"cckey0\", \"ccvalue\"); // version number will end up at 4\n         } catch (CacheException ex) {\n           fail(\"While creating region\", ex);\n         }\n       }\n     };\n-    vm0.invoke(createRegion);\n-    vm1.invoke(createRegion);\n-    vm1.invoke(new SerializableRunnable(\"Create local tombstone and adjust time\") {\n-      @Override\n-      public void run() {\n-        // make the entry for cckey0 a tombstone in this VM and set its\n-        // modification time to be older than the tombstone GC interval. This\n-        // means it could be in the process of being reaped by distributed-GC\n-        RegionEntry entry = CCRegion.getRegionEntry(\"cckey0\");\n-        VersionTag tag = entry.getVersionStamp().asVersionTag();\n-        assertTrue(tag.getEntryVersion() > 1);\n-        tag.setVersionTimeStamp(\n-            System.currentTimeMillis() - TombstoneService.REPLICATE_TOMBSTONE_TIMEOUT - 1000);\n-        entry.getVersionStamp().setVersionTimeStamp(tag.getVersionTimeStamp());\n-        try {\n-          entry.makeTombstone(CCRegion, tag);\n-        } catch (RegionClearedException e) {\n-          fail(\"region was mysteriously cleared during unit testing\", e);\n-        }\n+    vm0.invoke(\"Create Region\", createRegion);\n+    vm1.invoke(\"Create Region\", createRegion);\n+    vm1.invoke(\"Create local tombstone and adjust time\", () -> {\n+      // make the entry for cckey0 a tombstone in this VM and set its\n+      // modification time to be older than the tombstone GC interval. This\n+      // means it could be in the process of being reaped by distributed-GC\n+      RegionEntry entry = CCRegion.getRegionEntry(\"cckey0\");\n+      VersionTag tag = entry.getVersionStamp().asVersionTag();\n+      assertTrue(tag.getEntryVersion() > 1);\n+      tag.setVersionTimeStamp(\n+          System.currentTimeMillis() - TombstoneService.REPLICATE_TOMBSTONE_TIMEOUT - 1000);\n+      entry.getVersionStamp().setVersionTimeStamp(tag.getVersionTimeStamp());\n+      try {\n+        entry.makeTombstone(CCRegion, tag);\n+      } catch (RegionClearedException e) {\n+        fail(\"region was mysteriously cleared during unit testing\", e);\n       }\n     });\n     // now remove the entry on vm0, simulating that it initiated a GC, and\n     // perform a CREATE with a new version number\n-    vm0.invoke(localDestroyRunnable);\n-    vm1.invoke(new SerializableRunnable(\"Check that the create() was applied\") {\n-      @Override\n-      public void run() {\n-        RegionEntry entry = CCRegion.getRegionEntry(\"cckey0\");\n-        assertThat(entry.getVersionStamp().getEntryVersion()).isEqualTo(1);\n+    vm0.invoke(\"Locally destroy the entry and do a create that will be propagated with v1\", () -> {\n+      CCRegion.getRegionMap().removeEntry(\"cckey0\", CCRegion.getRegionEntry(\"cckey0\"), true);\n+      if (CCRegion.getRegionEntry(\"ckey0\") != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEzMDM3Nw==", "bodyText": "done", "url": "https://github.com/apache/geode/pull/4568#discussion_r368130377", "createdAt": "2020-01-17T20:49:18Z", "author": {"login": "mhansonp"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionCCEDUnitTest.java", "diffHunk": "@@ -163,78 +150,58 @@ public void testTombstones() {\n    */\n   @Test\n   public void testTombstoneExpirationRace() {\n-    VM vm0 = VM.getVM(0);\n-    VM vm1 = VM.getVM(1);\n \n     final String name = this.getUniqueName() + \"-CC\";\n-    SerializableRunnable createRegion = new SerializableRunnable(\"Create Region\") {\n+    SerializableRunnable createRegion = new SerializableRunnable() {\n       @Override\n       public void run() {\n         try {\n           RegionFactory f = getCache().createRegionFactory(getRegionAttributes());\n           CCRegion = (LocalRegion) f.create(name);\n+\n+          // noinspection OverwrittenKey\n           CCRegion.put(\"cckey0\", \"ccvalue\");\n+          // noinspection OverwrittenKey\n           CCRegion.put(\"cckey0\", \"ccvalue\"); // version number will end up at 4\n         } catch (CacheException ex) {\n           fail(\"While creating region\", ex);\n         }\n       }\n     };\n-    vm0.invoke(createRegion);\n-    vm1.invoke(createRegion);\n-    vm1.invoke(new SerializableRunnable(\"Create local tombstone and adjust time\") {\n-      @Override\n-      public void run() {\n-        // make the entry for cckey0 a tombstone in this VM and set its\n-        // modification time to be older than the tombstone GC interval. This\n-        // means it could be in the process of being reaped by distributed-GC\n-        RegionEntry entry = CCRegion.getRegionEntry(\"cckey0\");\n-        VersionTag tag = entry.getVersionStamp().asVersionTag();\n-        assertTrue(tag.getEntryVersion() > 1);\n-        tag.setVersionTimeStamp(\n-            System.currentTimeMillis() - TombstoneService.REPLICATE_TOMBSTONE_TIMEOUT - 1000);\n-        entry.getVersionStamp().setVersionTimeStamp(tag.getVersionTimeStamp());\n-        try {\n-          entry.makeTombstone(CCRegion, tag);\n-        } catch (RegionClearedException e) {\n-          fail(\"region was mysteriously cleared during unit testing\", e);\n-        }\n+    vm0.invoke(\"Create Region\", createRegion);\n+    vm1.invoke(\"Create Region\", createRegion);\n+    vm1.invoke(\"Create local tombstone and adjust time\", () -> {\n+      // make the entry for cckey0 a tombstone in this VM and set its\n+      // modification time to be older than the tombstone GC interval. This\n+      // means it could be in the process of being reaped by distributed-GC\n+      RegionEntry entry = CCRegion.getRegionEntry(\"cckey0\");\n+      VersionTag tag = entry.getVersionStamp().asVersionTag();\n+      assertTrue(tag.getEntryVersion() > 1);\n+      tag.setVersionTimeStamp(\n+          System.currentTimeMillis() - TombstoneService.REPLICATE_TOMBSTONE_TIMEOUT - 1000);\n+      entry.getVersionStamp().setVersionTimeStamp(tag.getVersionTimeStamp());\n+      try {\n+        entry.makeTombstone(CCRegion, tag);\n+      } catch (RegionClearedException e) {\n+        fail(\"region was mysteriously cleared during unit testing\", e);\n       }\n     });\n     // now remove the entry on vm0, simulating that it initiated a GC, and\n     // perform a CREATE with a new version number\n-    vm0.invoke(localDestroyRunnable);\n-    vm1.invoke(new SerializableRunnable(\"Check that the create() was applied\") {\n-      @Override\n-      public void run() {\n-        RegionEntry entry = CCRegion.getRegionEntry(\"cckey0\");\n-        assertThat(entry.getVersionStamp().getEntryVersion()).isEqualTo(1);\n+    vm0.invoke(\"Locally destroy the entry and do a create that will be propagated with v1\", () -> {\n+      CCRegion.getRegionMap().removeEntry(\"cckey0\", CCRegion.getRegionEntry(\"cckey0\"), true);\n+      if (CCRegion.getRegionEntry(\"ckey0\") != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwMjE2Nw=="}, "originalCommit": {"oid": "9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDU1MDUyOnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxOTozNjoxMlrOFfDNgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QyMDo1MDowNVrOFfE6RQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwMjc4NA==", "bodyText": "I don't think the code can ever reach lines 116 or 117", "url": "https://github.com/apache/geode/pull/4568#discussion_r368102784", "createdAt": "2020-01-17T19:36:12Z", "author": {"login": "kirklund"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionDUnitTest.java", "diffHunk": "@@ -71,71 +71,58 @@\n    */\n   @Test\n   public void testIncompatibleSubregions() throws CacheException {\n-\n-    VM vm0 = VM.getVM(0);\n-    VM vm1 = VM.getVM(1);\n-\n     // Scope.DISTRIBUTED_NO_ACK is illegal if there is any other cache\n     // in the distributed system that has the same region with\n     // Scope.GLOBAL\n \n     final String name = this.getUniqueName() + \"-GLOBAL\";\n-    vm0.invoke(new SerializableRunnable(\"Create GLOBAL Region\") {\n-      @Override\n-      public void run() {\n-        try {\n-          createRegion(name, \"INCOMPATIBLE_ROOT\", getRegionAttributes());\n-        } catch (CacheException ex) {\n-          fail(\"While creating GLOBAL region\", ex);\n-        }\n-        assertThat(getRootRegion(\"INCOMPATIBLE_ROOT\").getAttributes().getScope().isGlobal())\n-            .isTrue();\n+    vm0.invoke(\"Create GLOBAL Region\", () -> {\n+      try {\n+        createRegion(name, \"INCOMPATIBLE_ROOT\", getRegionAttributes());\n+      } catch (CacheException ex) {\n+        fail(\"While creating GLOBAL region\", ex);\n       }\n+      assertThat(getRootRegion(\"INCOMPATIBLE_ROOT\").getAttributes().getScope().isGlobal())\n+          .isTrue();\n     });\n \n-    vm1.invoke(new SerializableRunnable(\"Create NO ACK Region\") {\n-      @Override\n-      public void run() {\n+    vm1.invoke(\"Create NO ACK Region\", () -> {\n+      try {\n+        RegionFactory<Object, Object> factory =\n+            getCache().createRegionFactory(getRegionAttributes());\n+        factory.setScope(Scope.DISTRIBUTED_NO_ACK);\n         try {\n-          RegionFactory<Object, Object> factory =\n-              getCache().createRegionFactory(getRegionAttributes());\n-          factory.setScope(Scope.DISTRIBUTED_NO_ACK);\n-          try {\n-            assertThat(getRootRegion(\"INCOMPATIBLE_ROOT\")).isNull();\n-            createRegion(name, \"INCOMPATIBLE_ROOT\", factory);\n-\n-            fail(\"Should have thrown an IllegalStateException\");\n-          } catch (IllegalStateException ignored) {\n-            // pass...\n-          }\n+          assertThat(getRootRegion(\"INCOMPATIBLE_ROOT\")).isNull();\n+          createRegion(name, \"INCOMPATIBLE_ROOT\", factory);\n \n-        } catch (CacheException ex) {\n-          fail(\"While creating GLOBAL Region\", ex);\n+          fail(\"Should have thrown an IllegalStateException\");\n+        } catch (IllegalStateException ignored) {\n+          // pass...\n         }\n+\n+      } catch (CacheException ex) {\n+        fail(\"While creating GLOBAL Region\", ex);\n       }\n     });\n \n-    vm1.invoke(new SerializableRunnable(\"Create ACK Region\") {\n-      @Override\n-      public void run() {\n+    vm1.invoke(\"Create ACK Region\", () -> {\n+      try {\n+        RegionFactory<Object, Object> factory =\n+            getCache().createRegionFactory(getRegionAttributes());\n+        factory.setScope(Scope.DISTRIBUTED_ACK);\n         try {\n-          RegionFactory<Object, Object> factory =\n-              getCache().createRegionFactory(getRegionAttributes());\n-          factory.setScope(Scope.DISTRIBUTED_ACK);\n-          try {\n-            Region<Object, Object> rootRegion = factory.create(\"INCOMPATIBLE_ROOT\");\n-            fail(\"Should have thrown an IllegalStateException\");\n-            factory.createSubregion(rootRegion, name);\n-            fail(\"Should have thrown an IllegalStateException\");\n-\n-          } catch (IllegalStateException ex) {\n-            // pass...\n-            assertThat(getRootRegion()).isNull();\n-          }\n-\n-        } catch (CacheException ex) {\n-          fail(\"While creating GLOBAL Region\", ex);\n+          Region<Object, Object> rootRegion = factory.create(\"INCOMPATIBLE_ROOT\");\n+          fail(\"Should have thrown an IllegalStateException\");\n+          factory.createSubregion(rootRegion, name);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEzMDYyOQ==", "bodyText": "true. Deleted.", "url": "https://github.com/apache/geode/pull/4568#discussion_r368130629", "createdAt": "2020-01-17T20:50:05Z", "author": {"login": "mhansonp"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionDUnitTest.java", "diffHunk": "@@ -71,71 +71,58 @@\n    */\n   @Test\n   public void testIncompatibleSubregions() throws CacheException {\n-\n-    VM vm0 = VM.getVM(0);\n-    VM vm1 = VM.getVM(1);\n-\n     // Scope.DISTRIBUTED_NO_ACK is illegal if there is any other cache\n     // in the distributed system that has the same region with\n     // Scope.GLOBAL\n \n     final String name = this.getUniqueName() + \"-GLOBAL\";\n-    vm0.invoke(new SerializableRunnable(\"Create GLOBAL Region\") {\n-      @Override\n-      public void run() {\n-        try {\n-          createRegion(name, \"INCOMPATIBLE_ROOT\", getRegionAttributes());\n-        } catch (CacheException ex) {\n-          fail(\"While creating GLOBAL region\", ex);\n-        }\n-        assertThat(getRootRegion(\"INCOMPATIBLE_ROOT\").getAttributes().getScope().isGlobal())\n-            .isTrue();\n+    vm0.invoke(\"Create GLOBAL Region\", () -> {\n+      try {\n+        createRegion(name, \"INCOMPATIBLE_ROOT\", getRegionAttributes());\n+      } catch (CacheException ex) {\n+        fail(\"While creating GLOBAL region\", ex);\n       }\n+      assertThat(getRootRegion(\"INCOMPATIBLE_ROOT\").getAttributes().getScope().isGlobal())\n+          .isTrue();\n     });\n \n-    vm1.invoke(new SerializableRunnable(\"Create NO ACK Region\") {\n-      @Override\n-      public void run() {\n+    vm1.invoke(\"Create NO ACK Region\", () -> {\n+      try {\n+        RegionFactory<Object, Object> factory =\n+            getCache().createRegionFactory(getRegionAttributes());\n+        factory.setScope(Scope.DISTRIBUTED_NO_ACK);\n         try {\n-          RegionFactory<Object, Object> factory =\n-              getCache().createRegionFactory(getRegionAttributes());\n-          factory.setScope(Scope.DISTRIBUTED_NO_ACK);\n-          try {\n-            assertThat(getRootRegion(\"INCOMPATIBLE_ROOT\")).isNull();\n-            createRegion(name, \"INCOMPATIBLE_ROOT\", factory);\n-\n-            fail(\"Should have thrown an IllegalStateException\");\n-          } catch (IllegalStateException ignored) {\n-            // pass...\n-          }\n+          assertThat(getRootRegion(\"INCOMPATIBLE_ROOT\")).isNull();\n+          createRegion(name, \"INCOMPATIBLE_ROOT\", factory);\n \n-        } catch (CacheException ex) {\n-          fail(\"While creating GLOBAL Region\", ex);\n+          fail(\"Should have thrown an IllegalStateException\");\n+        } catch (IllegalStateException ignored) {\n+          // pass...\n         }\n+\n+      } catch (CacheException ex) {\n+        fail(\"While creating GLOBAL Region\", ex);\n       }\n     });\n \n-    vm1.invoke(new SerializableRunnable(\"Create ACK Region\") {\n-      @Override\n-      public void run() {\n+    vm1.invoke(\"Create ACK Region\", () -> {\n+      try {\n+        RegionFactory<Object, Object> factory =\n+            getCache().createRegionFactory(getRegionAttributes());\n+        factory.setScope(Scope.DISTRIBUTED_ACK);\n         try {\n-          RegionFactory<Object, Object> factory =\n-              getCache().createRegionFactory(getRegionAttributes());\n-          factory.setScope(Scope.DISTRIBUTED_ACK);\n-          try {\n-            Region<Object, Object> rootRegion = factory.create(\"INCOMPATIBLE_ROOT\");\n-            fail(\"Should have thrown an IllegalStateException\");\n-            factory.createSubregion(rootRegion, name);\n-            fail(\"Should have thrown an IllegalStateException\");\n-\n-          } catch (IllegalStateException ex) {\n-            // pass...\n-            assertThat(getRootRegion()).isNull();\n-          }\n-\n-        } catch (CacheException ex) {\n-          fail(\"While creating GLOBAL Region\", ex);\n+          Region<Object, Object> rootRegion = factory.create(\"INCOMPATIBLE_ROOT\");\n+          fail(\"Should have thrown an IllegalStateException\");\n+          factory.createSubregion(rootRegion, name);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwMjc4NA=="}, "originalCommit": {"oid": "9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDU1Njg0OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionDUnitTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxOTozODo0MVrOFfDRZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxOTozODo0MVrOFfDRZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwMzc4MQ==", "bodyText": "Optional: We should try to replace all testing Threads like these with use of ExecutorServiceRule. Spinning up our own Thread should be considered deprecated and replaced with Executors. The ExecutorServiceRule will report a failure if any thread is left running after the test or if any of these threads threw anything.", "url": "https://github.com/apache/geode/pull/4568#discussion_r368103781", "createdAt": "2020-01-17T19:38:41Z", "author": {"login": "kirklund"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionDUnitTest.java", "diffHunk": "@@ -240,80 +206,66 @@ public void uncaughtException(Thread t, Throwable e) {\n         };\n \n         Thread[] threads = new Thread[threadsPerVM];\n-        for (int i = 0; i < threadsPerVM; i++) {\n-          Thread thread = new Thread(group, new Runnable() {\n-            @Override\n-            public void run() {\n+        for (int i1 = 0; i1 < threadsPerVM; i1++) {\n+          Thread thread = new Thread(group, () -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6"}, "originalPosition": 230}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDU1ODk0OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxOTozOTozMVrOFfDStQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QyMDo1NTo0OVrOFfFCXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwNDExNw==", "bodyText": "Optional: Delete all catch blocks that catch Error or Throwable.", "url": "https://github.com/apache/geode/pull/4568#discussion_r368104117", "createdAt": "2020-01-17T19:39:31Z", "author": {"login": "kirklund"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionDUnitTest.java", "diffHunk": "@@ -240,80 +206,66 @@ public void uncaughtException(Thread t, Throwable e) {\n         };\n \n         Thread[] threads = new Thread[threadsPerVM];\n-        for (int i = 0; i < threadsPerVM; i++) {\n-          Thread thread = new Thread(group, new Runnable() {\n-            @Override\n-            public void run() {\n+        for (int i1 = 0; i1 < threadsPerVM; i1++) {\n+          Thread thread = new Thread(group, () -> {\n+            try {\n+              final Random rand = new Random(System.identityHashCode(this));\n               try {\n-                final Random rand = new Random(System.identityHashCode(this));\n-                try {\n-                  Region<Object, Integer> region = getRootRegion().getSubregion(name);\n-                  for (int j = 0; j < incrementsPerThread; j++) {\n-                    Thread.sleep(rand.nextInt(30) + 30);\n-\n-                    Lock lock = region.getDistributedLock(key);\n-                    assertThat(lock.tryLock(-1, TimeUnit.MILLISECONDS)).isTrue();\n-\n-                    Integer value = region.get(key);\n-                    Integer oldValue = value;\n-                    if (value == null) {\n-                      value = 1;\n-\n-                    } else {\n-                      Integer v = value;\n-                      value = v + 1;\n-                    }\n-\n-                    assertThat(oldValue).isEqualTo(region.get(key));\n-                    region.put(key, value);\n-                    assertThat(value).isEqualTo(region.get(key));\n-\n-                    lock.unlock();\n+                Region<Object, Integer> region = getRootRegion().getSubregion(name);\n+                for (int j = 0; j < incrementsPerThread; j++) {\n+                  Thread.sleep(rand.nextInt(30) + 30);\n+\n+                  Lock lock = region.getDistributedLock(key);\n+                  assertThat(lock.tryLock(-1, TimeUnit.MILLISECONDS)).isTrue();\n+\n+                  Integer value = region.get(key);\n+                  Integer oldValue = value;\n+                  if (value == null) {\n+                    value = 1;\n+\n+                  } else {\n+                    Integer v = value;\n+                    value = v + 1;\n                   }\n \n-                } catch (IllegalStateException | InterruptedException | CacheLoaderException\n-                    | CacheWriterException | TimeoutException ex) {\n-                  fail(\"While incrementing\", ex);\n+                  assertThat(oldValue).isEqualTo(region.get(key));\n+                  region.put(key, value);\n+                  assertThat(value).isEqualTo(region.get(key));\n+\n+                  lock.unlock();\n                 }\n-              } catch (VirtualMachineError e) {\n-                throw e;\n-              } catch (Throwable t) {\n-                logger\n-                    .info(\"testSynchronousIncrements.\" + this + \" caught Throwable\", t);\n+\n+              } catch (IllegalStateException | InterruptedException | CacheLoaderException\n+                  | CacheWriterException | TimeoutException ex) {\n+                fail(\"While incrementing\", ex);\n               }\n+            } catch (VirtualMachineError e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6"}, "originalPosition": 294}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEzMjcwMg==", "bodyText": "done", "url": "https://github.com/apache/geode/pull/4568#discussion_r368132702", "createdAt": "2020-01-17T20:55:49Z", "author": {"login": "mhansonp"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionDUnitTest.java", "diffHunk": "@@ -240,80 +206,66 @@ public void uncaughtException(Thread t, Throwable e) {\n         };\n \n         Thread[] threads = new Thread[threadsPerVM];\n-        for (int i = 0; i < threadsPerVM; i++) {\n-          Thread thread = new Thread(group, new Runnable() {\n-            @Override\n-            public void run() {\n+        for (int i1 = 0; i1 < threadsPerVM; i1++) {\n+          Thread thread = new Thread(group, () -> {\n+            try {\n+              final Random rand = new Random(System.identityHashCode(this));\n               try {\n-                final Random rand = new Random(System.identityHashCode(this));\n-                try {\n-                  Region<Object, Integer> region = getRootRegion().getSubregion(name);\n-                  for (int j = 0; j < incrementsPerThread; j++) {\n-                    Thread.sleep(rand.nextInt(30) + 30);\n-\n-                    Lock lock = region.getDistributedLock(key);\n-                    assertThat(lock.tryLock(-1, TimeUnit.MILLISECONDS)).isTrue();\n-\n-                    Integer value = region.get(key);\n-                    Integer oldValue = value;\n-                    if (value == null) {\n-                      value = 1;\n-\n-                    } else {\n-                      Integer v = value;\n-                      value = v + 1;\n-                    }\n-\n-                    assertThat(oldValue).isEqualTo(region.get(key));\n-                    region.put(key, value);\n-                    assertThat(value).isEqualTo(region.get(key));\n-\n-                    lock.unlock();\n+                Region<Object, Integer> region = getRootRegion().getSubregion(name);\n+                for (int j = 0; j < incrementsPerThread; j++) {\n+                  Thread.sleep(rand.nextInt(30) + 30);\n+\n+                  Lock lock = region.getDistributedLock(key);\n+                  assertThat(lock.tryLock(-1, TimeUnit.MILLISECONDS)).isTrue();\n+\n+                  Integer value = region.get(key);\n+                  Integer oldValue = value;\n+                  if (value == null) {\n+                    value = 1;\n+\n+                  } else {\n+                    Integer v = value;\n+                    value = v + 1;\n                   }\n \n-                } catch (IllegalStateException | InterruptedException | CacheLoaderException\n-                    | CacheWriterException | TimeoutException ex) {\n-                  fail(\"While incrementing\", ex);\n+                  assertThat(oldValue).isEqualTo(region.get(key));\n+                  region.put(key, value);\n+                  assertThat(value).isEqualTo(region.get(key));\n+\n+                  lock.unlock();\n                 }\n-              } catch (VirtualMachineError e) {\n-                throw e;\n-              } catch (Throwable t) {\n-                logger\n-                    .info(\"testSynchronousIncrements.\" + this + \" caught Throwable\", t);\n+\n+              } catch (IllegalStateException | InterruptedException | CacheLoaderException\n+                  | CacheWriterException | TimeoutException ex) {\n+                fail(\"While incrementing\", ex);\n               }\n+            } catch (VirtualMachineError e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwNDExNw=="}, "originalCommit": {"oid": "9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6"}, "originalPosition": 294}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDU1OTU2OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxOTozOTo0NFrOFfDTEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QyMTowMjo1NVrOFfFMCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwNDIxMQ==", "bodyText": "Optional: Remove catch block containing fail and add throws clause to method(s).", "url": "https://github.com/apache/geode/pull/4568#discussion_r368104211", "createdAt": "2020-01-17T19:39:44Z", "author": {"login": "kirklund"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionDUnitTest.java", "diffHunk": "@@ -240,80 +206,66 @@ public void uncaughtException(Thread t, Throwable e) {\n         };\n \n         Thread[] threads = new Thread[threadsPerVM];\n-        for (int i = 0; i < threadsPerVM; i++) {\n-          Thread thread = new Thread(group, new Runnable() {\n-            @Override\n-            public void run() {\n+        for (int i1 = 0; i1 < threadsPerVM; i1++) {\n+          Thread thread = new Thread(group, () -> {\n+            try {\n+              final Random rand = new Random(System.identityHashCode(this));\n               try {\n-                final Random rand = new Random(System.identityHashCode(this));\n-                try {\n-                  Region<Object, Integer> region = getRootRegion().getSubregion(name);\n-                  for (int j = 0; j < incrementsPerThread; j++) {\n-                    Thread.sleep(rand.nextInt(30) + 30);\n-\n-                    Lock lock = region.getDistributedLock(key);\n-                    assertThat(lock.tryLock(-1, TimeUnit.MILLISECONDS)).isTrue();\n-\n-                    Integer value = region.get(key);\n-                    Integer oldValue = value;\n-                    if (value == null) {\n-                      value = 1;\n-\n-                    } else {\n-                      Integer v = value;\n-                      value = v + 1;\n-                    }\n-\n-                    assertThat(oldValue).isEqualTo(region.get(key));\n-                    region.put(key, value);\n-                    assertThat(value).isEqualTo(region.get(key));\n-\n-                    lock.unlock();\n+                Region<Object, Integer> region = getRootRegion().getSubregion(name);\n+                for (int j = 0; j < incrementsPerThread; j++) {\n+                  Thread.sleep(rand.nextInt(30) + 30);\n+\n+                  Lock lock = region.getDistributedLock(key);\n+                  assertThat(lock.tryLock(-1, TimeUnit.MILLISECONDS)).isTrue();\n+\n+                  Integer value = region.get(key);\n+                  Integer oldValue = value;\n+                  if (value == null) {\n+                    value = 1;\n+\n+                  } else {\n+                    Integer v = value;\n+                    value = v + 1;\n                   }\n \n-                } catch (IllegalStateException | InterruptedException | CacheLoaderException\n-                    | CacheWriterException | TimeoutException ex) {\n-                  fail(\"While incrementing\", ex);\n+                  assertThat(oldValue).isEqualTo(region.get(key));\n+                  region.put(key, value);\n+                  assertThat(value).isEqualTo(region.get(key));\n+\n+                  lock.unlock();\n                 }\n-              } catch (VirtualMachineError e) {\n-                throw e;\n-              } catch (Throwable t) {\n-                logger\n-                    .info(\"testSynchronousIncrements.\" + this + \" caught Throwable\", t);\n+\n+              } catch (IllegalStateException | InterruptedException | CacheLoaderException", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6"}, "originalPosition": 290}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEzNTE3Ng==", "bodyText": "done", "url": "https://github.com/apache/geode/pull/4568#discussion_r368135176", "createdAt": "2020-01-17T21:02:55Z", "author": {"login": "mhansonp"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache30/GlobalRegionDUnitTest.java", "diffHunk": "@@ -240,80 +206,66 @@ public void uncaughtException(Thread t, Throwable e) {\n         };\n \n         Thread[] threads = new Thread[threadsPerVM];\n-        for (int i = 0; i < threadsPerVM; i++) {\n-          Thread thread = new Thread(group, new Runnable() {\n-            @Override\n-            public void run() {\n+        for (int i1 = 0; i1 < threadsPerVM; i1++) {\n+          Thread thread = new Thread(group, () -> {\n+            try {\n+              final Random rand = new Random(System.identityHashCode(this));\n               try {\n-                final Random rand = new Random(System.identityHashCode(this));\n-                try {\n-                  Region<Object, Integer> region = getRootRegion().getSubregion(name);\n-                  for (int j = 0; j < incrementsPerThread; j++) {\n-                    Thread.sleep(rand.nextInt(30) + 30);\n-\n-                    Lock lock = region.getDistributedLock(key);\n-                    assertThat(lock.tryLock(-1, TimeUnit.MILLISECONDS)).isTrue();\n-\n-                    Integer value = region.get(key);\n-                    Integer oldValue = value;\n-                    if (value == null) {\n-                      value = 1;\n-\n-                    } else {\n-                      Integer v = value;\n-                      value = v + 1;\n-                    }\n-\n-                    assertThat(oldValue).isEqualTo(region.get(key));\n-                    region.put(key, value);\n-                    assertThat(value).isEqualTo(region.get(key));\n-\n-                    lock.unlock();\n+                Region<Object, Integer> region = getRootRegion().getSubregion(name);\n+                for (int j = 0; j < incrementsPerThread; j++) {\n+                  Thread.sleep(rand.nextInt(30) + 30);\n+\n+                  Lock lock = region.getDistributedLock(key);\n+                  assertThat(lock.tryLock(-1, TimeUnit.MILLISECONDS)).isTrue();\n+\n+                  Integer value = region.get(key);\n+                  Integer oldValue = value;\n+                  if (value == null) {\n+                    value = 1;\n+\n+                  } else {\n+                    Integer v = value;\n+                    value = v + 1;\n                   }\n \n-                } catch (IllegalStateException | InterruptedException | CacheLoaderException\n-                    | CacheWriterException | TimeoutException ex) {\n-                  fail(\"While incrementing\", ex);\n+                  assertThat(oldValue).isEqualTo(region.get(key));\n+                  region.put(key, value);\n+                  assertThat(value).isEqualTo(region.get(key));\n+\n+                  lock.unlock();\n                 }\n-              } catch (VirtualMachineError e) {\n-                throw e;\n-              } catch (Throwable t) {\n-                logger\n-                    .info(\"testSynchronousIncrements.\" + this + \" caught Throwable\", t);\n+\n+              } catch (IllegalStateException | InterruptedException | CacheLoaderException", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwNDIxMQ=="}, "originalCommit": {"oid": "9a9cfad8f6eeccf7e9c15bd793b718bb30c68af6"}, "originalPosition": 290}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3797, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}