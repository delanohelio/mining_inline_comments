{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE4ODc0MTA5", "number": 5124, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNzoxOToxM1rOD95TuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMDo1Mzo0NlrOD-Bajg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjI4NjY0OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/PRCacheListenerDistributedTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNzoxOToxM1rOGXqoMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMToyMjo1NFrOGXzIIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ2ODg0OA==", "bodyText": "Should this line be uncommented or removed?", "url": "https://github.com/apache/geode/pull/5124#discussion_r427468848", "createdAt": "2020-05-19T17:19:13Z", "author": {"login": "jchen21"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/PRCacheListenerDistributedTest.java", "diffHunk": "@@ -38,28 +45,60 @@\n @SuppressWarnings(\"serial\")\n public class PRCacheListenerDistributedTest extends ReplicateCacheListenerDistributedTest {\n \n-  @Parameters(name = \"{index}: redundancy={0}\")\n-  public static Iterable<Integer> data() {\n-    return Arrays.asList(0, 3);\n+  @Parameters\n+  public static Collection<Object[]> data() {\n+    return Arrays.asList(new Object[][] {\n+        {1, Boolean.FALSE},\n+        // {3, Boolean.TRUE},", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYwODA5Ng==", "bodyText": "Good catch. Have uncommented the test param.", "url": "https://github.com/apache/geode/pull/5124#discussion_r427608096", "createdAt": "2020-05-19T21:22:54Z", "author": {"login": "agingade"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/PRCacheListenerDistributedTest.java", "diffHunk": "@@ -38,28 +45,60 @@\n @SuppressWarnings(\"serial\")\n public class PRCacheListenerDistributedTest extends ReplicateCacheListenerDistributedTest {\n \n-  @Parameters(name = \"{index}: redundancy={0}\")\n-  public static Iterable<Integer> data() {\n-    return Arrays.asList(0, 3);\n+  @Parameters\n+  public static Collection<Object[]> data() {\n+    return Arrays.asList(new Object[][] {\n+        {1, Boolean.FALSE},\n+        // {3, Boolean.TRUE},", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ2ODg0OA=="}, "originalCommit": {"oid": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjMzMjU2OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithExpirationDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNzozMDoxN1rOGXrEuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMTozNzo1N1rOGXzkwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3NjE1NQ==", "bodyText": "I am not sure why we need a new reference here.", "url": "https://github.com/apache/geode/pull/5124#discussion_r427476155", "createdAt": "2020-05-19T17:30:17Z", "author": {"login": "jchen21"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithExpirationDUnitTest.java", "diffHunk": "@@ -408,22 +394,21 @@ public void clearShouldFailWhenCoordinatorMemberIsBouncedAndExpirationTasksShoul\n   @TestCaseName(\"[{index}] {method}(Coordinator:{0}, RegionType:{1})\")\n   public void clearShouldSucceedAndRemoveRegisteredExpirationTasksWhenNonCoordinatorMemberIsBounced(\n       TestVM coordinatorVM, RegionShortcut regionShortcut) {\n-    final int entries = 1500;\n+    final int entries = 500;\n+\n+    RegionShortcut rs = regionShortcut;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxNTQyNQ==", "bodyText": "The lambda expression later in the code expects the passed parameters to be final.", "url": "https://github.com/apache/geode/pull/5124#discussion_r427615425", "createdAt": "2020-05-19T21:37:57Z", "author": {"login": "agingade"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithExpirationDUnitTest.java", "diffHunk": "@@ -408,22 +394,21 @@ public void clearShouldFailWhenCoordinatorMemberIsBouncedAndExpirationTasksShoul\n   @TestCaseName(\"[{index}] {method}(Coordinator:{0}, RegionType:{1})\")\n   public void clearShouldSucceedAndRemoveRegisteredExpirationTasksWhenNonCoordinatorMemberIsBounced(\n       TestVM coordinatorVM, RegionShortcut regionShortcut) {\n-    final int entries = 1500;\n+    final int entries = 500;\n+\n+    RegionShortcut rs = regionShortcut;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3NjE1NQ=="}, "originalCommit": {"oid": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjM0Mzg3OnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/cache/Region.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNzozMzowM1rOGXrL3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMTo0MTowMFrOGXzqIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3Nzk4MA==", "bodyText": "I think you mean It's instead of Its.", "url": "https://github.com/apache/geode/pull/5124#discussion_r427477980", "createdAt": "2020-05-19T17:33:03Z", "author": {"login": "jchen21"}, "path": "geode-core/src/main/java/org/apache/geode/cache/Region.java", "diffHunk": "@@ -1302,7 +1302,10 @@ Object selectValue(String queryPredicate) throws FunctionDomainException, TypeMi\n    * @see java.util.Map#clear()\n    * @see CacheListener#afterRegionClear\n    * @see CacheWriter#beforeRegionClear\n-   * @throws UnsupportedOperationException If the region is a partitioned region\n+   * @throws PartitionedRegionPartialClearException when data is partially cleared on partitioned\n+   *         region. Its caller responsibility to handle the partial data clear either by retrying", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxNjgwMQ==", "bodyText": "Fixed it.", "url": "https://github.com/apache/geode/pull/5124#discussion_r427616801", "createdAt": "2020-05-19T21:41:00Z", "author": {"login": "agingade"}, "path": "geode-core/src/main/java/org/apache/geode/cache/Region.java", "diffHunk": "@@ -1302,7 +1302,10 @@ Object selectValue(String queryPredicate) throws FunctionDomainException, TypeMi\n    * @see java.util.Map#clear()\n    * @see CacheListener#afterRegionClear\n    * @see CacheWriter#beforeRegionClear\n-   * @throws UnsupportedOperationException If the region is a partitioned region\n+   * @throws PartitionedRegionPartialClearException when data is partially cleared on partitioned\n+   *         region. Its caller responsibility to handle the partial data clear either by retrying", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3Nzk4MA=="}, "originalCommit": {"oid": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjM1OTYwOnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/BucketRegion.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNzozNjo1NFrOGXrVqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMTozOTo1MFrOGXzn3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ4MDQ5MQ==", "bodyText": "My understanding is if it is locked already, release the write locks for clear. I think the ! should be removed.", "url": "https://github.com/apache/geode/pull/5124#discussion_r427480491", "createdAt": "2020-05-19T17:36:54Z", "author": {"login": "jchen21"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/BucketRegion.java", "diffHunk": "@@ -575,16 +575,23 @@ public void cmnClearRegion(RegionEventImpl regionEvent, boolean cacheWrite, bool\n     // get rvvLock\n     Set<InternalDistributedMember> participants =\n         getCacheDistributionAdvisor().adviseInvalidateRegion();\n+    boolean isLockedAlready = this.partitionedRegion.getPartitionedRegionClear()\n+        .isLockedForListenerAndClientNotification();\n+\n     try {\n-      obtainWriteLocksForClear(regionEvent, participants);\n+      if (!isLockedAlready) {\n+        obtainWriteLocksForClear(regionEvent, participants);\n+      }\n       // no need to dominate my own rvv.\n       // Clear is on going here, there won't be GII for this member\n       clearRegionLocally(regionEvent, cacheWrite, null);\n       distributeClearOperation(regionEvent, rvv, participants);\n \n       // TODO: call reindexUserDataRegion if there're lucene indexes\n     } finally {\n-      releaseWriteLocksForClear(regionEvent, participants);\n+      if (!isLockedAlready) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxNjIyMg==", "bodyText": "If you look into the line where the lock is taken its based on the \"if(!isLockedAlready)\" the same logic is used to unlock the lock.", "url": "https://github.com/apache/geode/pull/5124#discussion_r427616222", "createdAt": "2020-05-19T21:39:50Z", "author": {"login": "agingade"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/BucketRegion.java", "diffHunk": "@@ -575,16 +575,23 @@ public void cmnClearRegion(RegionEventImpl regionEvent, boolean cacheWrite, bool\n     // get rvvLock\n     Set<InternalDistributedMember> participants =\n         getCacheDistributionAdvisor().adviseInvalidateRegion();\n+    boolean isLockedAlready = this.partitionedRegion.getPartitionedRegionClear()\n+        .isLockedForListenerAndClientNotification();\n+\n     try {\n-      obtainWriteLocksForClear(regionEvent, participants);\n+      if (!isLockedAlready) {\n+        obtainWriteLocksForClear(regionEvent, participants);\n+      }\n       // no need to dominate my own rvv.\n       // Clear is on going here, there won't be GII for this member\n       clearRegionLocally(regionEvent, cacheWrite, null);\n       distributeClearOperation(regionEvent, rvv, participants);\n \n       // TODO: call reindexUserDataRegion if there're lucene indexes\n     } finally {\n-      releaseWriteLocksForClear(regionEvent, participants);\n+      if (!isLockedAlready) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ4MDQ5MQ=="}, "originalCommit": {"oid": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjM5NzE4OnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/BucketRegion.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNzo0NjozMVrOGXrtfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMTo0NDoyMVrOGXzv0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ4NjU4OQ==", "bodyText": "LocalRegionDataView. checkSupportsRegionClear() does nothing. The other data views, including transactions related data views throw exception. Is it expected?", "url": "https://github.com/apache/geode/pull/5124#discussion_r427486589", "createdAt": "2020-05-19T17:46:31Z", "author": {"login": "jchen21"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/BucketRegion.java", "diffHunk": "@@ -2493,4 +2500,11 @@ void updateSenderIdMonitor() {\n   void checkSameSenderIdsAvailableOnAllNodes() {\n     // nothing needed on a bucket region\n   }\n+\n+  @Override\n+  protected void basicClear(RegionEventImpl regionEvent) {\n+    getDataView().checkSupportsRegionClear();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxODI1OA==", "bodyText": "For bucket region, we don't need it. Have removed it.", "url": "https://github.com/apache/geode/pull/5124#discussion_r427618258", "createdAt": "2020-05-19T21:44:21Z", "author": {"login": "agingade"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/BucketRegion.java", "diffHunk": "@@ -2493,4 +2500,11 @@ void updateSenderIdMonitor() {\n   void checkSameSenderIdsAvailableOnAllNodes() {\n     // nothing needed on a bucket region\n   }\n+\n+  @Override\n+  protected void basicClear(RegionEventImpl regionEvent) {\n+    getDataView().checkSupportsRegionClear();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ4NjU4OQ=="}, "originalCommit": {"oid": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjQ0NjM5OnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegion.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNzo1ODo1NFrOGXsM_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMTo1MjowNVrOGXz9iA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ5NDY1Mg==", "bodyText": "If this section of code is not used, it's better to remove it.", "url": "https://github.com/apache/geode/pull/5124#discussion_r427494652", "createdAt": "2020-05-19T17:58:54Z", "author": {"login": "jchen21"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegion.java", "diffHunk": "@@ -2148,69 +2150,71 @@ public void writeToDisk() {\n     throw new UnsupportedOperationException();\n   }\n \n-  @Override\n-  void basicClear(RegionEventImpl regionEvent, boolean cacheWrite) {\n-    final boolean isDebugEnabled = logger.isDebugEnabled();\n-    synchronized (clearLock) {\n-      final DistributedLockService lockService = getPartitionedRegionLockService();\n-      try {\n-        lockService.lock(\"_clearOperation\" + this.getFullPath().replace('/', '_'), -1, -1);\n-      } catch (IllegalStateException e) {\n-        lockCheckReadiness();\n-        throw e;\n-      }\n-      try {\n-        if (cache.isCacheAtShutdownAll()) {\n-          throw cache.getCacheClosedException(\"Cache is shutting down\");\n-        }\n-\n-        // do cacheWrite\n-        cacheWriteBeforeRegionClear(regionEvent);\n-\n-        // create ClearPRMessage per bucket\n-        List<ClearPRMessage> clearMsgList = createClearPRMessages(regionEvent.getEventId());\n-        for (ClearPRMessage clearPRMessage : clearMsgList) {\n-          int bucketId = clearPRMessage.getBucketId();\n-          checkReadiness();\n-          long sendMessagesStartTime = 0;\n-          if (isDebugEnabled) {\n-            sendMessagesStartTime = System.currentTimeMillis();\n-          }\n-          try {\n-            sendClearMsgByBucket(bucketId, clearPRMessage);\n-          } catch (PartitionOfflineException poe) {\n-            // TODO add a PartialResultException\n-            logger.info(\"PR.sendClearMsgByBucket encountered PartitionOfflineException at bucket \"\n-                + bucketId, poe);\n-          } catch (Exception e) {\n-            logger.info(\"PR.sendClearMsgByBucket encountered exception at bucket \" + bucketId, e);\n-          }\n-\n-          if (isDebugEnabled) {\n-            long now = System.currentTimeMillis();\n-            logger.debug(\"PR.sendClearMsgByBucket for bucket {} took {} ms\", bucketId,\n-                (now - sendMessagesStartTime));\n-          }\n-          // TODO add psStats\n-        }\n-      } finally {\n-        try {\n-          lockService.unlock(\"_clearOperation\" + this.getFullPath().replace('/', '_'));\n-        } catch (IllegalStateException e) {\n-          lockCheckReadiness();\n-        }\n-      }\n-\n-      // notify bridge clients at PR level\n-      regionEvent.setEventType(EnumListenerEvent.AFTER_REGION_CLEAR);\n-      boolean hasListener = hasListener();\n-      if (hasListener) {\n-        dispatchListenerEvent(EnumListenerEvent.AFTER_REGION_CLEAR, regionEvent);\n-      }\n-      notifyBridgeClients(regionEvent);\n-      logger.info(\"Partitioned region {} finsihed clear operation.\", this.getFullPath());\n-    }\n-  }\n+  /* @Override */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYyMTc2OA==", "bodyText": "removed.", "url": "https://github.com/apache/geode/pull/5124#discussion_r427621768", "createdAt": "2020-05-19T21:52:05Z", "author": {"login": "agingade"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegion.java", "diffHunk": "@@ -2148,69 +2150,71 @@ public void writeToDisk() {\n     throw new UnsupportedOperationException();\n   }\n \n-  @Override\n-  void basicClear(RegionEventImpl regionEvent, boolean cacheWrite) {\n-    final boolean isDebugEnabled = logger.isDebugEnabled();\n-    synchronized (clearLock) {\n-      final DistributedLockService lockService = getPartitionedRegionLockService();\n-      try {\n-        lockService.lock(\"_clearOperation\" + this.getFullPath().replace('/', '_'), -1, -1);\n-      } catch (IllegalStateException e) {\n-        lockCheckReadiness();\n-        throw e;\n-      }\n-      try {\n-        if (cache.isCacheAtShutdownAll()) {\n-          throw cache.getCacheClosedException(\"Cache is shutting down\");\n-        }\n-\n-        // do cacheWrite\n-        cacheWriteBeforeRegionClear(regionEvent);\n-\n-        // create ClearPRMessage per bucket\n-        List<ClearPRMessage> clearMsgList = createClearPRMessages(regionEvent.getEventId());\n-        for (ClearPRMessage clearPRMessage : clearMsgList) {\n-          int bucketId = clearPRMessage.getBucketId();\n-          checkReadiness();\n-          long sendMessagesStartTime = 0;\n-          if (isDebugEnabled) {\n-            sendMessagesStartTime = System.currentTimeMillis();\n-          }\n-          try {\n-            sendClearMsgByBucket(bucketId, clearPRMessage);\n-          } catch (PartitionOfflineException poe) {\n-            // TODO add a PartialResultException\n-            logger.info(\"PR.sendClearMsgByBucket encountered PartitionOfflineException at bucket \"\n-                + bucketId, poe);\n-          } catch (Exception e) {\n-            logger.info(\"PR.sendClearMsgByBucket encountered exception at bucket \" + bucketId, e);\n-          }\n-\n-          if (isDebugEnabled) {\n-            long now = System.currentTimeMillis();\n-            logger.debug(\"PR.sendClearMsgByBucket for bucket {} took {} ms\", bucketId,\n-                (now - sendMessagesStartTime));\n-          }\n-          // TODO add psStats\n-        }\n-      } finally {\n-        try {\n-          lockService.unlock(\"_clearOperation\" + this.getFullPath().replace('/', '_'));\n-        } catch (IllegalStateException e) {\n-          lockCheckReadiness();\n-        }\n-      }\n-\n-      // notify bridge clients at PR level\n-      regionEvent.setEventType(EnumListenerEvent.AFTER_REGION_CLEAR);\n-      boolean hasListener = hasListener();\n-      if (hasListener) {\n-        dispatchListenerEvent(EnumListenerEvent.AFTER_REGION_CLEAR, regionEvent);\n-      }\n-      notifyBridgeClients(regionEvent);\n-      logger.info(\"Partitioned region {} finsihed clear operation.\", this.getFullPath());\n-    }\n-  }\n+  /* @Override */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ5NDY1Mg=="}, "originalCommit": {"oid": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjQ2NTI5OnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegionClearMessage.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxODowMzo0MlrOGXsY2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxODowMzo0MlrOGXsY2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ5NzY5MA==", "bodyText": "This seems to be duplicate. The super class already has an ArrayList of recipients.", "url": "https://github.com/apache/geode/pull/5124#discussion_r427497690", "createdAt": "2020-05-19T18:03:42Z", "author": {"login": "jchen21"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegionClearMessage.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.cache;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.cache.CacheException;\n+import org.apache.geode.cache.Operation;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.DistributionMessage;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplyMessage;\n+import org.apache.geode.distributed.internal.ReplyProcessor21;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.Assert;\n+import org.apache.geode.internal.NanoTimer;\n+import org.apache.geode.internal.cache.partitioned.PartitionMessage;\n+import org.apache.geode.internal.logging.log4j.LogMarker;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class PartitionedRegionClearMessage extends PartitionMessage {\n+\n+  public enum OperationType {\n+    OP_LOCK_FOR_PR_CLEAR, OP_UNLOCK_FOR_PR_CLEAR, OP_PR_CLEAR,\n+  }\n+\n+  private Object cbArg;\n+\n+  private OperationType op;\n+\n+  private EventID eventID;\n+\n+  private PartitionedRegion partitionedRegion;\n+\n+  private Set<InternalDistributedMember> recipients;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjUwODUwOnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegionClearMessage.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxODoxNTowOVrOGXs0HA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMzoxODozNVrOGX14xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUwNDY2OA==", "bodyText": "The implementation can use super.toString() and append fields specific to this class.", "url": "https://github.com/apache/geode/pull/5124#discussion_r427504668", "createdAt": "2020-05-19T18:15:09Z", "author": {"login": "jchen21"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegionClearMessage.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.cache;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.cache.CacheException;\n+import org.apache.geode.cache.Operation;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.DistributionMessage;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplyMessage;\n+import org.apache.geode.distributed.internal.ReplyProcessor21;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.Assert;\n+import org.apache.geode.internal.NanoTimer;\n+import org.apache.geode.internal.cache.partitioned.PartitionMessage;\n+import org.apache.geode.internal.logging.log4j.LogMarker;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class PartitionedRegionClearMessage extends PartitionMessage {\n+\n+  public enum OperationType {\n+    OP_LOCK_FOR_PR_CLEAR, OP_UNLOCK_FOR_PR_CLEAR, OP_PR_CLEAR,\n+  }\n+\n+  private Object cbArg;\n+\n+  private OperationType op;\n+\n+  private EventID eventID;\n+\n+  private PartitionedRegion partitionedRegion;\n+\n+  private Set<InternalDistributedMember> recipients;\n+\n+  private ArrayList bucketsCleared;\n+\n+  @Override\n+  public EventID getEventID() {\n+    return eventID;\n+  }\n+\n+  public PartitionedRegionClearMessage() {}\n+\n+  PartitionedRegionClearMessage(Set recipients, PartitionedRegion region,\n+      ReplyProcessor21 processor, PartitionedRegionClearMessage.OperationType operationType,\n+      final RegionEventImpl event) {\n+    super(recipients, region.getPRId(), processor);\n+    this.recipients = recipients;\n+    partitionedRegion = region;\n+    op = operationType;\n+    cbArg = event.getRawCallbackArgument();\n+    eventID = event.getEventId();\n+  }\n+\n+  public OperationType getOp() {\n+    return op;\n+  }\n+\n+  public void send() {\n+    Assert.assertTrue(recipients != null, \"ClearMessage NULL recipients set\");\n+    setTransactionDistributed(partitionedRegion.getCache().getTxManager().isDistributed());\n+    partitionedRegion.getDistributionManager().putOutgoing(this);\n+  }\n+\n+  @Override\n+  protected Throwable processCheckForPR(PartitionedRegion pr,\n+      DistributionManager distributionManager) {\n+    if (pr != null && !pr.getDistributionAdvisor().isInitialized()) {\n+      Throwable thr = new ForceReattemptException(\n+          String.format(\"%s : could not find partitioned region with Id %s\",\n+              distributionManager.getDistributionManagerId(),\n+              pr.getRegionIdentifier()));\n+      return thr;\n+    }\n+    return null;\n+  }\n+\n+  @Override\n+  protected boolean operateOnPartitionedRegion(ClusterDistributionManager dm,\n+      PartitionedRegion partitionedRegion,\n+      long startTime) throws CacheException {\n+\n+    if (partitionedRegion == null) {\n+      return true;\n+    }\n+\n+    if (partitionedRegion.isDestroyed()) {\n+      return true;\n+    }\n+\n+    if (op == OperationType.OP_LOCK_FOR_PR_CLEAR) {\n+      partitionedRegion.getPartitionedRegionClear().obtainClearLockLocal(getSender());\n+    } else if (op == OperationType.OP_UNLOCK_FOR_PR_CLEAR) {\n+      partitionedRegion.getPartitionedRegionClear().releaseClearLockLocal();\n+    } else {\n+      RegionEventImpl event =\n+          new RegionEventImpl(partitionedRegion, Operation.REGION_CLEAR, this.cbArg, true,\n+              partitionedRegion.getMyId(),\n+              getEventID());\n+      bucketsCleared = partitionedRegion.getPartitionedRegionClear().clearRegionLocal(event);\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  protected void appendFields(StringBuilder buff) {\n+    super.appendFields(buff);\n+    buff.append(\" cbArg=\").append(this.cbArg).append(\" op=\").append(this.op);\n+  }\n+\n+  @Override\n+  public int getDSFID() {\n+    return CLEAR_PARTITIONED_REGION_MESSAGE;\n+  }\n+\n+  @Override\n+  public void fromData(DataInput in,\n+      DeserializationContext context) throws IOException, ClassNotFoundException {\n+    super.fromData(in, context);\n+    this.cbArg = DataSerializer.readObject(in);\n+    op = PartitionedRegionClearMessage.OperationType.values()[in.readByte()];\n+    eventID = DataSerializer.readObject(in);\n+  }\n+\n+  @Override\n+  public void toData(DataOutput out,\n+      SerializationContext context) throws IOException {\n+    super.toData(out, context);\n+    DataSerializer.writeObject(this.cbArg, out);\n+    out.writeByte(op.ordinal());\n+    DataSerializer.writeObject(eventID, out);\n+  }\n+\n+  /**\n+   * The response on which to wait for all the replies. This response ignores any exceptions\n+   * received from the \"far side\"\n+   */\n+  public static class PartitionedRegionClearResponse extends ReplyProcessor21 {\n+    CopyOnWriteArrayList bucketsCleared = new CopyOnWriteArrayList();\n+\n+    public PartitionedRegionClearResponse(InternalDistributedSystem system, Set initMembers) {\n+      super(system, initMembers);\n+    }\n+\n+    @Override\n+    public void process(DistributionMessage msg) {\n+      if (msg instanceof PartitionedRegionClearReplyMessage) {\n+        List buckets = ((PartitionedRegionClearReplyMessage) msg).bucketsCleared;\n+        if (buckets != null) {\n+          bucketsCleared.addAll(buckets);\n+        }\n+      }\n+      super.process(msg, true);\n+    }\n+  }\n+\n+  @Override\n+  protected void sendReply(InternalDistributedMember member, int processorId,\n+      DistributionManager distributionManager, ReplyException ex,\n+      PartitionedRegion partitionedRegion, long startTime) {\n+    if (partitionedRegion != null) {\n+      if (startTime > 0) {\n+        partitionedRegion.getPrStats().endPartitionMessagesProcessing(startTime);\n+      }\n+    }\n+    PartitionedRegionClearMessage.PartitionedRegionClearReplyMessage\n+        .send(member, processorId, getReplySender(distributionManager), op, bucketsCleared,\n+            ex);\n+  }\n+\n+  public static class PartitionedRegionClearReplyMessage extends ReplyMessage {\n+\n+    private ArrayList bucketsCleared;\n+\n+    private OperationType op;\n+\n+    @Override\n+    public boolean getInlineProcess() {\n+      return true;\n+    }\n+\n+    /**\n+     * Empty constructor to conform to DataSerializable interface\n+     */\n+    public PartitionedRegionClearReplyMessage() {}\n+\n+    private PartitionedRegionClearReplyMessage(int processorId, OperationType op,\n+        ArrayList bucketsCleared, ReplyException ex) {\n+      super();\n+      this.bucketsCleared = bucketsCleared;\n+      this.op = op;\n+      setProcessorId(processorId);\n+      setException(ex);\n+    }\n+\n+    /** Send an ack */\n+    public static void send(InternalDistributedMember recipient, int processorId, ReplySender dm,\n+        OperationType op, ArrayList bucketsCleared, ReplyException ex) {\n+\n+      Assert.assertTrue(recipient != null, \"partitionedRegionClearReplyMessage NULL reply message\");\n+\n+      PartitionedRegionClearMessage.PartitionedRegionClearReplyMessage m =\n+          new PartitionedRegionClearMessage.PartitionedRegionClearReplyMessage(processorId, op,\n+              bucketsCleared, ex);\n+\n+      m.setRecipient(recipient);\n+      dm.putOutgoing(m);\n+    }\n+\n+    /**\n+     * Processes this message. This method is invoked by the receiver of the message.\n+     *\n+     * @param dm the distribution manager that is processing the message.\n+     */\n+    @Override\n+    public void process(final DistributionManager dm, final ReplyProcessor21 rp) {\n+      final long startTime = getTimestamp();\n+\n+      if (rp == null) {\n+        if (LogService.getLogger().isTraceEnabled(LogMarker.DM_VERBOSE)) {\n+          LogService.getLogger().trace(LogMarker.DM_VERBOSE, \"{}: processor not found\", this);\n+        }\n+        return;\n+      }\n+\n+      rp.process(this);\n+\n+      dm.getStats().incReplyMessageTime(NanoTimer.getTime() - startTime);\n+    }\n+\n+    @Override\n+    public int getDSFID() {\n+      return CLEAR_PARTITIONED_REGION_REPLY_MESSAGE;\n+    }\n+\n+    @Override\n+    public void fromData(DataInput in,\n+        DeserializationContext context) throws IOException, ClassNotFoundException {\n+      super.fromData(in, context);\n+      op = PartitionedRegionClearMessage.OperationType.values()[in.readByte()];\n+      bucketsCleared = DataSerializer.readArrayList(in);\n+    }\n+\n+    @Override\n+    public void toData(DataOutput out,\n+        SerializationContext context) throws IOException {\n+      super.toData(out, context);\n+      out.writeByte(op.ordinal());\n+      DataSerializer.writeArrayList(bucketsCleared, out);\n+    }\n+\n+    @Override\n+    public String toString() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6"}, "originalPosition": 280}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxMzM5Nw==", "bodyText": "Thats not right; the class extending should be overriding the method and call super if any super fields needs to be included. If you look into other inheriting classes they have implemented their own toString().", "url": "https://github.com/apache/geode/pull/5124#discussion_r427613397", "createdAt": "2020-05-19T21:33:42Z", "author": {"login": "agingade"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegionClearMessage.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.cache;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.cache.CacheException;\n+import org.apache.geode.cache.Operation;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.DistributionMessage;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplyMessage;\n+import org.apache.geode.distributed.internal.ReplyProcessor21;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.Assert;\n+import org.apache.geode.internal.NanoTimer;\n+import org.apache.geode.internal.cache.partitioned.PartitionMessage;\n+import org.apache.geode.internal.logging.log4j.LogMarker;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class PartitionedRegionClearMessage extends PartitionMessage {\n+\n+  public enum OperationType {\n+    OP_LOCK_FOR_PR_CLEAR, OP_UNLOCK_FOR_PR_CLEAR, OP_PR_CLEAR,\n+  }\n+\n+  private Object cbArg;\n+\n+  private OperationType op;\n+\n+  private EventID eventID;\n+\n+  private PartitionedRegion partitionedRegion;\n+\n+  private Set<InternalDistributedMember> recipients;\n+\n+  private ArrayList bucketsCleared;\n+\n+  @Override\n+  public EventID getEventID() {\n+    return eventID;\n+  }\n+\n+  public PartitionedRegionClearMessage() {}\n+\n+  PartitionedRegionClearMessage(Set recipients, PartitionedRegion region,\n+      ReplyProcessor21 processor, PartitionedRegionClearMessage.OperationType operationType,\n+      final RegionEventImpl event) {\n+    super(recipients, region.getPRId(), processor);\n+    this.recipients = recipients;\n+    partitionedRegion = region;\n+    op = operationType;\n+    cbArg = event.getRawCallbackArgument();\n+    eventID = event.getEventId();\n+  }\n+\n+  public OperationType getOp() {\n+    return op;\n+  }\n+\n+  public void send() {\n+    Assert.assertTrue(recipients != null, \"ClearMessage NULL recipients set\");\n+    setTransactionDistributed(partitionedRegion.getCache().getTxManager().isDistributed());\n+    partitionedRegion.getDistributionManager().putOutgoing(this);\n+  }\n+\n+  @Override\n+  protected Throwable processCheckForPR(PartitionedRegion pr,\n+      DistributionManager distributionManager) {\n+    if (pr != null && !pr.getDistributionAdvisor().isInitialized()) {\n+      Throwable thr = new ForceReattemptException(\n+          String.format(\"%s : could not find partitioned region with Id %s\",\n+              distributionManager.getDistributionManagerId(),\n+              pr.getRegionIdentifier()));\n+      return thr;\n+    }\n+    return null;\n+  }\n+\n+  @Override\n+  protected boolean operateOnPartitionedRegion(ClusterDistributionManager dm,\n+      PartitionedRegion partitionedRegion,\n+      long startTime) throws CacheException {\n+\n+    if (partitionedRegion == null) {\n+      return true;\n+    }\n+\n+    if (partitionedRegion.isDestroyed()) {\n+      return true;\n+    }\n+\n+    if (op == OperationType.OP_LOCK_FOR_PR_CLEAR) {\n+      partitionedRegion.getPartitionedRegionClear().obtainClearLockLocal(getSender());\n+    } else if (op == OperationType.OP_UNLOCK_FOR_PR_CLEAR) {\n+      partitionedRegion.getPartitionedRegionClear().releaseClearLockLocal();\n+    } else {\n+      RegionEventImpl event =\n+          new RegionEventImpl(partitionedRegion, Operation.REGION_CLEAR, this.cbArg, true,\n+              partitionedRegion.getMyId(),\n+              getEventID());\n+      bucketsCleared = partitionedRegion.getPartitionedRegionClear().clearRegionLocal(event);\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  protected void appendFields(StringBuilder buff) {\n+    super.appendFields(buff);\n+    buff.append(\" cbArg=\").append(this.cbArg).append(\" op=\").append(this.op);\n+  }\n+\n+  @Override\n+  public int getDSFID() {\n+    return CLEAR_PARTITIONED_REGION_MESSAGE;\n+  }\n+\n+  @Override\n+  public void fromData(DataInput in,\n+      DeserializationContext context) throws IOException, ClassNotFoundException {\n+    super.fromData(in, context);\n+    this.cbArg = DataSerializer.readObject(in);\n+    op = PartitionedRegionClearMessage.OperationType.values()[in.readByte()];\n+    eventID = DataSerializer.readObject(in);\n+  }\n+\n+  @Override\n+  public void toData(DataOutput out,\n+      SerializationContext context) throws IOException {\n+    super.toData(out, context);\n+    DataSerializer.writeObject(this.cbArg, out);\n+    out.writeByte(op.ordinal());\n+    DataSerializer.writeObject(eventID, out);\n+  }\n+\n+  /**\n+   * The response on which to wait for all the replies. This response ignores any exceptions\n+   * received from the \"far side\"\n+   */\n+  public static class PartitionedRegionClearResponse extends ReplyProcessor21 {\n+    CopyOnWriteArrayList bucketsCleared = new CopyOnWriteArrayList();\n+\n+    public PartitionedRegionClearResponse(InternalDistributedSystem system, Set initMembers) {\n+      super(system, initMembers);\n+    }\n+\n+    @Override\n+    public void process(DistributionMessage msg) {\n+      if (msg instanceof PartitionedRegionClearReplyMessage) {\n+        List buckets = ((PartitionedRegionClearReplyMessage) msg).bucketsCleared;\n+        if (buckets != null) {\n+          bucketsCleared.addAll(buckets);\n+        }\n+      }\n+      super.process(msg, true);\n+    }\n+  }\n+\n+  @Override\n+  protected void sendReply(InternalDistributedMember member, int processorId,\n+      DistributionManager distributionManager, ReplyException ex,\n+      PartitionedRegion partitionedRegion, long startTime) {\n+    if (partitionedRegion != null) {\n+      if (startTime > 0) {\n+        partitionedRegion.getPrStats().endPartitionMessagesProcessing(startTime);\n+      }\n+    }\n+    PartitionedRegionClearMessage.PartitionedRegionClearReplyMessage\n+        .send(member, processorId, getReplySender(distributionManager), op, bucketsCleared,\n+            ex);\n+  }\n+\n+  public static class PartitionedRegionClearReplyMessage extends ReplyMessage {\n+\n+    private ArrayList bucketsCleared;\n+\n+    private OperationType op;\n+\n+    @Override\n+    public boolean getInlineProcess() {\n+      return true;\n+    }\n+\n+    /**\n+     * Empty constructor to conform to DataSerializable interface\n+     */\n+    public PartitionedRegionClearReplyMessage() {}\n+\n+    private PartitionedRegionClearReplyMessage(int processorId, OperationType op,\n+        ArrayList bucketsCleared, ReplyException ex) {\n+      super();\n+      this.bucketsCleared = bucketsCleared;\n+      this.op = op;\n+      setProcessorId(processorId);\n+      setException(ex);\n+    }\n+\n+    /** Send an ack */\n+    public static void send(InternalDistributedMember recipient, int processorId, ReplySender dm,\n+        OperationType op, ArrayList bucketsCleared, ReplyException ex) {\n+\n+      Assert.assertTrue(recipient != null, \"partitionedRegionClearReplyMessage NULL reply message\");\n+\n+      PartitionedRegionClearMessage.PartitionedRegionClearReplyMessage m =\n+          new PartitionedRegionClearMessage.PartitionedRegionClearReplyMessage(processorId, op,\n+              bucketsCleared, ex);\n+\n+      m.setRecipient(recipient);\n+      dm.putOutgoing(m);\n+    }\n+\n+    /**\n+     * Processes this message. This method is invoked by the receiver of the message.\n+     *\n+     * @param dm the distribution manager that is processing the message.\n+     */\n+    @Override\n+    public void process(final DistributionManager dm, final ReplyProcessor21 rp) {\n+      final long startTime = getTimestamp();\n+\n+      if (rp == null) {\n+        if (LogService.getLogger().isTraceEnabled(LogMarker.DM_VERBOSE)) {\n+          LogService.getLogger().trace(LogMarker.DM_VERBOSE, \"{}: processor not found\", this);\n+        }\n+        return;\n+      }\n+\n+      rp.process(this);\n+\n+      dm.getStats().incReplyMessageTime(NanoTimer.getTime() - startTime);\n+    }\n+\n+    @Override\n+    public int getDSFID() {\n+      return CLEAR_PARTITIONED_REGION_REPLY_MESSAGE;\n+    }\n+\n+    @Override\n+    public void fromData(DataInput in,\n+        DeserializationContext context) throws IOException, ClassNotFoundException {\n+      super.fromData(in, context);\n+      op = PartitionedRegionClearMessage.OperationType.values()[in.readByte()];\n+      bucketsCleared = DataSerializer.readArrayList(in);\n+    }\n+\n+    @Override\n+    public void toData(DataOutput out,\n+        SerializationContext context) throws IOException {\n+      super.toData(out, context);\n+      out.writeByte(op.ordinal());\n+      DataSerializer.writeArrayList(bucketsCleared, out);\n+    }\n+\n+    @Override\n+    public String toString() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUwNDY2OA=="}, "originalCommit": {"oid": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6"}, "originalPosition": 280}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY1MzMxOQ==", "bodyText": "This toString() actually is missing the sender field.\nThe super.toString() already contain the class name, procesorId and exception. Only bucketsCleared has to be added here.  I was trying to say something like:\n    @Override\n    public String toString() {\n      StringBuffer sb = new StringBuffer();\n      sb.append(super.toString());\n      sb.append(\" bucketsCleared \").append(this.bucketsCleared);\n      return sb.toString();\n    }", "url": "https://github.com/apache/geode/pull/5124#discussion_r427653319", "createdAt": "2020-05-19T23:18:35Z", "author": {"login": "jchen21"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegionClearMessage.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.cache;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.cache.CacheException;\n+import org.apache.geode.cache.Operation;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.DistributionMessage;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplyMessage;\n+import org.apache.geode.distributed.internal.ReplyProcessor21;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.Assert;\n+import org.apache.geode.internal.NanoTimer;\n+import org.apache.geode.internal.cache.partitioned.PartitionMessage;\n+import org.apache.geode.internal.logging.log4j.LogMarker;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class PartitionedRegionClearMessage extends PartitionMessage {\n+\n+  public enum OperationType {\n+    OP_LOCK_FOR_PR_CLEAR, OP_UNLOCK_FOR_PR_CLEAR, OP_PR_CLEAR,\n+  }\n+\n+  private Object cbArg;\n+\n+  private OperationType op;\n+\n+  private EventID eventID;\n+\n+  private PartitionedRegion partitionedRegion;\n+\n+  private Set<InternalDistributedMember> recipients;\n+\n+  private ArrayList bucketsCleared;\n+\n+  @Override\n+  public EventID getEventID() {\n+    return eventID;\n+  }\n+\n+  public PartitionedRegionClearMessage() {}\n+\n+  PartitionedRegionClearMessage(Set recipients, PartitionedRegion region,\n+      ReplyProcessor21 processor, PartitionedRegionClearMessage.OperationType operationType,\n+      final RegionEventImpl event) {\n+    super(recipients, region.getPRId(), processor);\n+    this.recipients = recipients;\n+    partitionedRegion = region;\n+    op = operationType;\n+    cbArg = event.getRawCallbackArgument();\n+    eventID = event.getEventId();\n+  }\n+\n+  public OperationType getOp() {\n+    return op;\n+  }\n+\n+  public void send() {\n+    Assert.assertTrue(recipients != null, \"ClearMessage NULL recipients set\");\n+    setTransactionDistributed(partitionedRegion.getCache().getTxManager().isDistributed());\n+    partitionedRegion.getDistributionManager().putOutgoing(this);\n+  }\n+\n+  @Override\n+  protected Throwable processCheckForPR(PartitionedRegion pr,\n+      DistributionManager distributionManager) {\n+    if (pr != null && !pr.getDistributionAdvisor().isInitialized()) {\n+      Throwable thr = new ForceReattemptException(\n+          String.format(\"%s : could not find partitioned region with Id %s\",\n+              distributionManager.getDistributionManagerId(),\n+              pr.getRegionIdentifier()));\n+      return thr;\n+    }\n+    return null;\n+  }\n+\n+  @Override\n+  protected boolean operateOnPartitionedRegion(ClusterDistributionManager dm,\n+      PartitionedRegion partitionedRegion,\n+      long startTime) throws CacheException {\n+\n+    if (partitionedRegion == null) {\n+      return true;\n+    }\n+\n+    if (partitionedRegion.isDestroyed()) {\n+      return true;\n+    }\n+\n+    if (op == OperationType.OP_LOCK_FOR_PR_CLEAR) {\n+      partitionedRegion.getPartitionedRegionClear().obtainClearLockLocal(getSender());\n+    } else if (op == OperationType.OP_UNLOCK_FOR_PR_CLEAR) {\n+      partitionedRegion.getPartitionedRegionClear().releaseClearLockLocal();\n+    } else {\n+      RegionEventImpl event =\n+          new RegionEventImpl(partitionedRegion, Operation.REGION_CLEAR, this.cbArg, true,\n+              partitionedRegion.getMyId(),\n+              getEventID());\n+      bucketsCleared = partitionedRegion.getPartitionedRegionClear().clearRegionLocal(event);\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  protected void appendFields(StringBuilder buff) {\n+    super.appendFields(buff);\n+    buff.append(\" cbArg=\").append(this.cbArg).append(\" op=\").append(this.op);\n+  }\n+\n+  @Override\n+  public int getDSFID() {\n+    return CLEAR_PARTITIONED_REGION_MESSAGE;\n+  }\n+\n+  @Override\n+  public void fromData(DataInput in,\n+      DeserializationContext context) throws IOException, ClassNotFoundException {\n+    super.fromData(in, context);\n+    this.cbArg = DataSerializer.readObject(in);\n+    op = PartitionedRegionClearMessage.OperationType.values()[in.readByte()];\n+    eventID = DataSerializer.readObject(in);\n+  }\n+\n+  @Override\n+  public void toData(DataOutput out,\n+      SerializationContext context) throws IOException {\n+    super.toData(out, context);\n+    DataSerializer.writeObject(this.cbArg, out);\n+    out.writeByte(op.ordinal());\n+    DataSerializer.writeObject(eventID, out);\n+  }\n+\n+  /**\n+   * The response on which to wait for all the replies. This response ignores any exceptions\n+   * received from the \"far side\"\n+   */\n+  public static class PartitionedRegionClearResponse extends ReplyProcessor21 {\n+    CopyOnWriteArrayList bucketsCleared = new CopyOnWriteArrayList();\n+\n+    public PartitionedRegionClearResponse(InternalDistributedSystem system, Set initMembers) {\n+      super(system, initMembers);\n+    }\n+\n+    @Override\n+    public void process(DistributionMessage msg) {\n+      if (msg instanceof PartitionedRegionClearReplyMessage) {\n+        List buckets = ((PartitionedRegionClearReplyMessage) msg).bucketsCleared;\n+        if (buckets != null) {\n+          bucketsCleared.addAll(buckets);\n+        }\n+      }\n+      super.process(msg, true);\n+    }\n+  }\n+\n+  @Override\n+  protected void sendReply(InternalDistributedMember member, int processorId,\n+      DistributionManager distributionManager, ReplyException ex,\n+      PartitionedRegion partitionedRegion, long startTime) {\n+    if (partitionedRegion != null) {\n+      if (startTime > 0) {\n+        partitionedRegion.getPrStats().endPartitionMessagesProcessing(startTime);\n+      }\n+    }\n+    PartitionedRegionClearMessage.PartitionedRegionClearReplyMessage\n+        .send(member, processorId, getReplySender(distributionManager), op, bucketsCleared,\n+            ex);\n+  }\n+\n+  public static class PartitionedRegionClearReplyMessage extends ReplyMessage {\n+\n+    private ArrayList bucketsCleared;\n+\n+    private OperationType op;\n+\n+    @Override\n+    public boolean getInlineProcess() {\n+      return true;\n+    }\n+\n+    /**\n+     * Empty constructor to conform to DataSerializable interface\n+     */\n+    public PartitionedRegionClearReplyMessage() {}\n+\n+    private PartitionedRegionClearReplyMessage(int processorId, OperationType op,\n+        ArrayList bucketsCleared, ReplyException ex) {\n+      super();\n+      this.bucketsCleared = bucketsCleared;\n+      this.op = op;\n+      setProcessorId(processorId);\n+      setException(ex);\n+    }\n+\n+    /** Send an ack */\n+    public static void send(InternalDistributedMember recipient, int processorId, ReplySender dm,\n+        OperationType op, ArrayList bucketsCleared, ReplyException ex) {\n+\n+      Assert.assertTrue(recipient != null, \"partitionedRegionClearReplyMessage NULL reply message\");\n+\n+      PartitionedRegionClearMessage.PartitionedRegionClearReplyMessage m =\n+          new PartitionedRegionClearMessage.PartitionedRegionClearReplyMessage(processorId, op,\n+              bucketsCleared, ex);\n+\n+      m.setRecipient(recipient);\n+      dm.putOutgoing(m);\n+    }\n+\n+    /**\n+     * Processes this message. This method is invoked by the receiver of the message.\n+     *\n+     * @param dm the distribution manager that is processing the message.\n+     */\n+    @Override\n+    public void process(final DistributionManager dm, final ReplyProcessor21 rp) {\n+      final long startTime = getTimestamp();\n+\n+      if (rp == null) {\n+        if (LogService.getLogger().isTraceEnabled(LogMarker.DM_VERBOSE)) {\n+          LogService.getLogger().trace(LogMarker.DM_VERBOSE, \"{}: processor not found\", this);\n+        }\n+        return;\n+      }\n+\n+      rp.process(this);\n+\n+      dm.getStats().incReplyMessageTime(NanoTimer.getTime() - startTime);\n+    }\n+\n+    @Override\n+    public int getDSFID() {\n+      return CLEAR_PARTITIONED_REGION_REPLY_MESSAGE;\n+    }\n+\n+    @Override\n+    public void fromData(DataInput in,\n+        DeserializationContext context) throws IOException, ClassNotFoundException {\n+      super.fromData(in, context);\n+      op = PartitionedRegionClearMessage.OperationType.values()[in.readByte()];\n+      bucketsCleared = DataSerializer.readArrayList(in);\n+    }\n+\n+    @Override\n+    public void toData(DataOutput out,\n+        SerializationContext context) throws IOException {\n+      super.toData(out, context);\n+      out.writeByte(op.ordinal());\n+      DataSerializer.writeArrayList(bucketsCleared, out);\n+    }\n+\n+    @Override\n+    public String toString() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUwNDY2OA=="}, "originalCommit": {"oid": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6"}, "originalPosition": 280}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjUzMzU0OnYy", "diffSide": "LEFT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/PartitionedRegionTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxODoyMTo0OFrOGXtEFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMToyOToxNFrOGXzUhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUwODc1Ng==", "bodyText": "Is the deleted test case covered else where? Or it no longer valid?", "url": "https://github.com/apache/geode/pull/5124#discussion_r427508756", "createdAt": "2020-05-19T18:21:48Z", "author": {"login": "jchen21"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/PartitionedRegionTest.java", "diffHunk": "@@ -221,22 +220,6 @@ public void clearShouldNotThrowUnsupportedOperationException() {\n     spyPartitionedRegion.clear();\n   }\n \n-  @Test(expected = CacheClosedException.class)\n-  public void clearShouldThrowCacheClosedExceptionIfShutdownAll() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxMTI3MQ==", "bodyText": "This is based on the earlier clear messaging. Thats not valid anymore.", "url": "https://github.com/apache/geode/pull/5124#discussion_r427611271", "createdAt": "2020-05-19T21:29:14Z", "author": {"login": "agingade"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/PartitionedRegionTest.java", "diffHunk": "@@ -221,22 +220,6 @@ public void clearShouldNotThrowUnsupportedOperationException() {\n     spyPartitionedRegion.clear();\n   }\n \n-  @Test(expected = CacheClosedException.class)\n-  public void clearShouldThrowCacheClosedExceptionIfShutdownAll() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUwODc1Ng=="}, "originalCommit": {"oid": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjUzNDEzOnYy", "diffSide": "LEFT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/PartitionedRegionTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxODoyMTo1N1rOGXtEcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMToyODowNlrOGXzSjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUwODg1MA==", "bodyText": "Is the deleted test case covered else where? Or it no longer valid?", "url": "https://github.com/apache/geode/pull/5124#discussion_r427508850", "createdAt": "2020-05-19T18:21:57Z", "author": {"login": "jchen21"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/PartitionedRegionTest.java", "diffHunk": "@@ -249,28 +232,6 @@ public void createClearPRMessagesShouldCreateMessagePerBucket() {\n     assertThat(msgs.size()).isEqualTo(3);\n   }\n \n-  @Test\n-  public void sendEachMessagePerBucket() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxMDc2NA==", "bodyText": "This is testing the old way of messaging; where message is sent per bucket. That is not true anymore.", "url": "https://github.com/apache/geode/pull/5124#discussion_r427610764", "createdAt": "2020-05-19T21:28:06Z", "author": {"login": "agingade"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/PartitionedRegionTest.java", "diffHunk": "@@ -249,28 +232,6 @@ public void createClearPRMessagesShouldCreateMessagePerBucket() {\n     assertThat(msgs.size()).isEqualTo(3);\n   }\n \n-  @Test\n-  public void sendEachMessagePerBucket() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUwODg1MA=="}, "originalCommit": {"oid": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjYxOTQ5OnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegionClearMessage.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxODo0NTozOFrOGXt6sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxODo0NTozOFrOGXt6sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUyMjczOA==", "bodyText": "This method never returns false. It always returns true. So there is no need to do the if check.", "url": "https://github.com/apache/geode/pull/5124#discussion_r427522738", "createdAt": "2020-05-19T18:45:38Z", "author": {"login": "jchen21"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegionClearMessage.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.cache;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.cache.CacheException;\n+import org.apache.geode.cache.Operation;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.DistributionMessage;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplyMessage;\n+import org.apache.geode.distributed.internal.ReplyProcessor21;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.Assert;\n+import org.apache.geode.internal.NanoTimer;\n+import org.apache.geode.internal.cache.partitioned.PartitionMessage;\n+import org.apache.geode.internal.logging.log4j.LogMarker;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class PartitionedRegionClearMessage extends PartitionMessage {\n+\n+  public enum OperationType {\n+    OP_LOCK_FOR_PR_CLEAR, OP_UNLOCK_FOR_PR_CLEAR, OP_PR_CLEAR,\n+  }\n+\n+  private Object cbArg;\n+\n+  private OperationType op;\n+\n+  private EventID eventID;\n+\n+  private PartitionedRegion partitionedRegion;\n+\n+  private Set<InternalDistributedMember> recipients;\n+\n+  private ArrayList bucketsCleared;\n+\n+  @Override\n+  public EventID getEventID() {\n+    return eventID;\n+  }\n+\n+  public PartitionedRegionClearMessage() {}\n+\n+  PartitionedRegionClearMessage(Set recipients, PartitionedRegion region,\n+      ReplyProcessor21 processor, PartitionedRegionClearMessage.OperationType operationType,\n+      final RegionEventImpl event) {\n+    super(recipients, region.getPRId(), processor);\n+    this.recipients = recipients;\n+    partitionedRegion = region;\n+    op = operationType;\n+    cbArg = event.getRawCallbackArgument();\n+    eventID = event.getEventId();\n+  }\n+\n+  public OperationType getOp() {\n+    return op;\n+  }\n+\n+  public void send() {\n+    Assert.assertTrue(recipients != null, \"ClearMessage NULL recipients set\");\n+    setTransactionDistributed(partitionedRegion.getCache().getTxManager().isDistributed());\n+    partitionedRegion.getDistributionManager().putOutgoing(this);\n+  }\n+\n+  @Override\n+  protected Throwable processCheckForPR(PartitionedRegion pr,\n+      DistributionManager distributionManager) {\n+    if (pr != null && !pr.getDistributionAdvisor().isInitialized()) {\n+      Throwable thr = new ForceReattemptException(\n+          String.format(\"%s : could not find partitioned region with Id %s\",\n+              distributionManager.getDistributionManagerId(),\n+              pr.getRegionIdentifier()));\n+      return thr;\n+    }\n+    return null;\n+  }\n+\n+  @Override\n+  protected boolean operateOnPartitionedRegion(ClusterDistributionManager dm,\n+      PartitionedRegion partitionedRegion,\n+      long startTime) throws CacheException {\n+\n+    if (partitionedRegion == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjYyMDA1OnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegionClearMessage.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxODo0NTo0NVrOGXt7CA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMToyNzowM1rOGXzQmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUyMjgyNA==", "bodyText": "This method never returns false. It always returns true. So there is no need to do the if check.", "url": "https://github.com/apache/geode/pull/5124#discussion_r427522824", "createdAt": "2020-05-19T18:45:45Z", "author": {"login": "jchen21"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegionClearMessage.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.cache;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.cache.CacheException;\n+import org.apache.geode.cache.Operation;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.DistributionMessage;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplyMessage;\n+import org.apache.geode.distributed.internal.ReplyProcessor21;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.Assert;\n+import org.apache.geode.internal.NanoTimer;\n+import org.apache.geode.internal.cache.partitioned.PartitionMessage;\n+import org.apache.geode.internal.logging.log4j.LogMarker;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class PartitionedRegionClearMessage extends PartitionMessage {\n+\n+  public enum OperationType {\n+    OP_LOCK_FOR_PR_CLEAR, OP_UNLOCK_FOR_PR_CLEAR, OP_PR_CLEAR,\n+  }\n+\n+  private Object cbArg;\n+\n+  private OperationType op;\n+\n+  private EventID eventID;\n+\n+  private PartitionedRegion partitionedRegion;\n+\n+  private Set<InternalDistributedMember> recipients;\n+\n+  private ArrayList bucketsCleared;\n+\n+  @Override\n+  public EventID getEventID() {\n+    return eventID;\n+  }\n+\n+  public PartitionedRegionClearMessage() {}\n+\n+  PartitionedRegionClearMessage(Set recipients, PartitionedRegion region,\n+      ReplyProcessor21 processor, PartitionedRegionClearMessage.OperationType operationType,\n+      final RegionEventImpl event) {\n+    super(recipients, region.getPRId(), processor);\n+    this.recipients = recipients;\n+    partitionedRegion = region;\n+    op = operationType;\n+    cbArg = event.getRawCallbackArgument();\n+    eventID = event.getEventId();\n+  }\n+\n+  public OperationType getOp() {\n+    return op;\n+  }\n+\n+  public void send() {\n+    Assert.assertTrue(recipients != null, \"ClearMessage NULL recipients set\");\n+    setTransactionDistributed(partitionedRegion.getCache().getTxManager().isDistributed());\n+    partitionedRegion.getDistributionManager().putOutgoing(this);\n+  }\n+\n+  @Override\n+  protected Throwable processCheckForPR(PartitionedRegion pr,\n+      DistributionManager distributionManager) {\n+    if (pr != null && !pr.getDistributionAdvisor().isInitialized()) {\n+      Throwable thr = new ForceReattemptException(\n+          String.format(\"%s : could not find partitioned region with Id %s\",\n+              distributionManager.getDistributionManagerId(),\n+              pr.getRegionIdentifier()));\n+      return thr;\n+    }\n+    return null;\n+  }\n+\n+  @Override\n+  protected boolean operateOnPartitionedRegion(ClusterDistributionManager dm,\n+      PartitionedRegion partitionedRegion,\n+      long startTime) throws CacheException {\n+\n+    if (partitionedRegion == null) {\n+      return true;\n+    }\n+\n+    if (partitionedRegion.isDestroyed()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxMDI2NA==", "bodyText": "Thats not true; if the region is not destroyed, it returns false. line#1892 in LocalRegion.java.", "url": "https://github.com/apache/geode/pull/5124#discussion_r427610264", "createdAt": "2020-05-19T21:27:03Z", "author": {"login": "agingade"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegionClearMessage.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.cache;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.cache.CacheException;\n+import org.apache.geode.cache.Operation;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.DistributionMessage;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplyMessage;\n+import org.apache.geode.distributed.internal.ReplyProcessor21;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.Assert;\n+import org.apache.geode.internal.NanoTimer;\n+import org.apache.geode.internal.cache.partitioned.PartitionMessage;\n+import org.apache.geode.internal.logging.log4j.LogMarker;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class PartitionedRegionClearMessage extends PartitionMessage {\n+\n+  public enum OperationType {\n+    OP_LOCK_FOR_PR_CLEAR, OP_UNLOCK_FOR_PR_CLEAR, OP_PR_CLEAR,\n+  }\n+\n+  private Object cbArg;\n+\n+  private OperationType op;\n+\n+  private EventID eventID;\n+\n+  private PartitionedRegion partitionedRegion;\n+\n+  private Set<InternalDistributedMember> recipients;\n+\n+  private ArrayList bucketsCleared;\n+\n+  @Override\n+  public EventID getEventID() {\n+    return eventID;\n+  }\n+\n+  public PartitionedRegionClearMessage() {}\n+\n+  PartitionedRegionClearMessage(Set recipients, PartitionedRegion region,\n+      ReplyProcessor21 processor, PartitionedRegionClearMessage.OperationType operationType,\n+      final RegionEventImpl event) {\n+    super(recipients, region.getPRId(), processor);\n+    this.recipients = recipients;\n+    partitionedRegion = region;\n+    op = operationType;\n+    cbArg = event.getRawCallbackArgument();\n+    eventID = event.getEventId();\n+  }\n+\n+  public OperationType getOp() {\n+    return op;\n+  }\n+\n+  public void send() {\n+    Assert.assertTrue(recipients != null, \"ClearMessage NULL recipients set\");\n+    setTransactionDistributed(partitionedRegion.getCache().getTxManager().isDistributed());\n+    partitionedRegion.getDistributionManager().putOutgoing(this);\n+  }\n+\n+  @Override\n+  protected Throwable processCheckForPR(PartitionedRegion pr,\n+      DistributionManager distributionManager) {\n+    if (pr != null && !pr.getDistributionAdvisor().isInitialized()) {\n+      Throwable thr = new ForceReattemptException(\n+          String.format(\"%s : could not find partitioned region with Id %s\",\n+              distributionManager.getDistributionManagerId(),\n+              pr.getRegionIdentifier()));\n+      return thr;\n+    }\n+    return null;\n+  }\n+\n+  @Override\n+  protected boolean operateOnPartitionedRegion(ClusterDistributionManager dm,\n+      PartitionedRegion partitionedRegion,\n+      long startTime) throws CacheException {\n+\n+    if (partitionedRegion == null) {\n+      return true;\n+    }\n+\n+    if (partitionedRegion.isDestroyed()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUyMjgyNA=="}, "originalCommit": {"oid": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MzYxNDg2OnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegionClearMessage.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMDo1Mzo0NlrOGX3oNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMToxNzo0M1rOGYeH8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY4MTg0Nw==", "bodyText": "The sender field is missing.", "url": "https://github.com/apache/geode/pull/5124#discussion_r427681847", "createdAt": "2020-05-20T00:53:46Z", "author": {"login": "jchen21"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegionClearMessage.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.cache;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.cache.CacheException;\n+import org.apache.geode.cache.Operation;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.DistributionMessage;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplyMessage;\n+import org.apache.geode.distributed.internal.ReplyProcessor21;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.Assert;\n+import org.apache.geode.internal.NanoTimer;\n+import org.apache.geode.internal.cache.partitioned.PartitionMessage;\n+import org.apache.geode.internal.logging.log4j.LogMarker;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class PartitionedRegionClearMessage extends PartitionMessage {\n+\n+  public enum OperationType {\n+    OP_LOCK_FOR_PR_CLEAR, OP_UNLOCK_FOR_PR_CLEAR, OP_PR_CLEAR,\n+  }\n+\n+  private Object cbArg;\n+\n+  private OperationType op;\n+\n+  private EventID eventID;\n+\n+  private PartitionedRegion partitionedRegion;\n+\n+  private ArrayList bucketsCleared;\n+\n+  @Override\n+  public EventID getEventID() {\n+    return eventID;\n+  }\n+\n+  public PartitionedRegionClearMessage() {}\n+\n+  PartitionedRegionClearMessage(Set recipients, PartitionedRegion region,\n+      ReplyProcessor21 processor, PartitionedRegionClearMessage.OperationType operationType,\n+      final RegionEventImpl event) {\n+    super(recipients, region.getPRId(), processor);\n+    partitionedRegion = region;\n+    op = operationType;\n+    cbArg = event.getRawCallbackArgument();\n+    eventID = event.getEventId();\n+  }\n+\n+  public OperationType getOp() {\n+    return op;\n+  }\n+\n+  public void send() {\n+    Assert.assertTrue(getRecipients() != null, \"ClearMessage NULL recipients set\");\n+    setTransactionDistributed(partitionedRegion.getCache().getTxManager().isDistributed());\n+    partitionedRegion.getDistributionManager().putOutgoing(this);\n+  }\n+\n+  @Override\n+  protected Throwable processCheckForPR(PartitionedRegion pr,\n+      DistributionManager distributionManager) {\n+    if (pr != null && !pr.getDistributionAdvisor().isInitialized()) {\n+      Throwable thr = new ForceReattemptException(\n+          String.format(\"%s : could not find partitioned region with Id %s\",\n+              distributionManager.getDistributionManagerId(),\n+              pr.getRegionIdentifier()));\n+      return thr;\n+    }\n+    return null;\n+  }\n+\n+  @Override\n+  protected boolean operateOnPartitionedRegion(ClusterDistributionManager dm,\n+      PartitionedRegion partitionedRegion,\n+      long startTime) throws CacheException {\n+\n+    if (partitionedRegion == null) {\n+      return true;\n+    }\n+\n+    if (partitionedRegion.isDestroyed()) {\n+      return true;\n+    }\n+\n+    if (op == OperationType.OP_LOCK_FOR_PR_CLEAR) {\n+      partitionedRegion.getPartitionedRegionClear().obtainClearLockLocal(getSender());\n+    } else if (op == OperationType.OP_UNLOCK_FOR_PR_CLEAR) {\n+      partitionedRegion.getPartitionedRegionClear().releaseClearLockLocal();\n+    } else {\n+      RegionEventImpl event =\n+          new RegionEventImpl(partitionedRegion, Operation.REGION_CLEAR, this.cbArg, true,\n+              partitionedRegion.getMyId(),\n+              getEventID());\n+      bucketsCleared = partitionedRegion.getPartitionedRegionClear().clearRegionLocal(event);\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  protected void appendFields(StringBuilder buff) {\n+    super.appendFields(buff);\n+    buff.append(\" cbArg=\").append(this.cbArg).append(\" op=\").append(this.op);\n+  }\n+\n+  @Override\n+  public int getDSFID() {\n+    return CLEAR_PARTITIONED_REGION_MESSAGE;\n+  }\n+\n+  @Override\n+  public void fromData(DataInput in,\n+      DeserializationContext context) throws IOException, ClassNotFoundException {\n+    super.fromData(in, context);\n+    this.cbArg = DataSerializer.readObject(in);\n+    op = PartitionedRegionClearMessage.OperationType.values()[in.readByte()];\n+    eventID = DataSerializer.readObject(in);\n+  }\n+\n+  @Override\n+  public void toData(DataOutput out,\n+      SerializationContext context) throws IOException {\n+    super.toData(out, context);\n+    DataSerializer.writeObject(this.cbArg, out);\n+    out.writeByte(op.ordinal());\n+    DataSerializer.writeObject(eventID, out);\n+  }\n+\n+  /**\n+   * The response on which to wait for all the replies. This response ignores any exceptions\n+   * received from the \"far side\"\n+   */\n+  public static class PartitionedRegionClearResponse extends ReplyProcessor21 {\n+    CopyOnWriteArrayList bucketsCleared = new CopyOnWriteArrayList();\n+\n+    public PartitionedRegionClearResponse(InternalDistributedSystem system, Set initMembers) {\n+      super(system, initMembers);\n+    }\n+\n+    @Override\n+    public void process(DistributionMessage msg) {\n+      if (msg instanceof PartitionedRegionClearReplyMessage) {\n+        List buckets = ((PartitionedRegionClearReplyMessage) msg).bucketsCleared;\n+        if (buckets != null) {\n+          bucketsCleared.addAll(buckets);\n+        }\n+      }\n+      super.process(msg, true);\n+    }\n+  }\n+\n+  @Override\n+  protected void sendReply(InternalDistributedMember member, int processorId,\n+      DistributionManager distributionManager, ReplyException ex,\n+      PartitionedRegion partitionedRegion, long startTime) {\n+    if (partitionedRegion != null) {\n+      if (startTime > 0) {\n+        partitionedRegion.getPrStats().endPartitionMessagesProcessing(startTime);\n+      }\n+    }\n+    PartitionedRegionClearMessage.PartitionedRegionClearReplyMessage\n+        .send(member, processorId, getReplySender(distributionManager), op, bucketsCleared,\n+            ex);\n+  }\n+\n+  public static class PartitionedRegionClearReplyMessage extends ReplyMessage {\n+\n+    private ArrayList bucketsCleared;\n+\n+    private OperationType op;\n+\n+    @Override\n+    public boolean getInlineProcess() {\n+      return true;\n+    }\n+\n+    /**\n+     * Empty constructor to conform to DataSerializable interface\n+     */\n+    public PartitionedRegionClearReplyMessage() {}\n+\n+    private PartitionedRegionClearReplyMessage(int processorId, OperationType op,\n+        ArrayList bucketsCleared, ReplyException ex) {\n+      super();\n+      this.bucketsCleared = bucketsCleared;\n+      this.op = op;\n+      setProcessorId(processorId);\n+      setException(ex);\n+    }\n+\n+    /** Send an ack */\n+    public static void send(InternalDistributedMember recipient, int processorId, ReplySender dm,\n+        OperationType op, ArrayList bucketsCleared, ReplyException ex) {\n+\n+      Assert.assertTrue(recipient != null, \"partitionedRegionClearReplyMessage NULL reply message\");\n+\n+      PartitionedRegionClearMessage.PartitionedRegionClearReplyMessage m =\n+          new PartitionedRegionClearMessage.PartitionedRegionClearReplyMessage(processorId, op,\n+              bucketsCleared, ex);\n+\n+      m.setRecipient(recipient);\n+      dm.putOutgoing(m);\n+    }\n+\n+    /**\n+     * Processes this message. This method is invoked by the receiver of the message.\n+     *\n+     * @param dm the distribution manager that is processing the message.\n+     */\n+    @Override\n+    public void process(final DistributionManager dm, final ReplyProcessor21 rp) {\n+      final long startTime = getTimestamp();\n+\n+      if (rp == null) {\n+        if (LogService.getLogger().isTraceEnabled(LogMarker.DM_VERBOSE)) {\n+          LogService.getLogger().trace(LogMarker.DM_VERBOSE, \"{}: processor not found\", this);\n+        }\n+        return;\n+      }\n+\n+      rp.process(this);\n+\n+      dm.getStats().incReplyMessageTime(NanoTimer.getTime() - startTime);\n+    }\n+\n+    @Override\n+    public int getDSFID() {\n+      return CLEAR_PARTITIONED_REGION_REPLY_MESSAGE;\n+    }\n+\n+    @Override\n+    public void fromData(DataInput in,\n+        DeserializationContext context) throws IOException, ClassNotFoundException {\n+      super.fromData(in, context);\n+      op = PartitionedRegionClearMessage.OperationType.values()[in.readByte()];\n+      bucketsCleared = DataSerializer.readArrayList(in);\n+    }\n+\n+    @Override\n+    public void toData(DataOutput out,\n+        SerializationContext context) throws IOException {\n+      super.toData(out, context);\n+      out.writeByte(op.ordinal());\n+      DataSerializer.writeArrayList(bucketsCleared, out);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      StringBuffer sb = new StringBuffer();\n+      sb.append(\"PartitionedRegionClearReplyMessage \").append(\"processorid=\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6316dbb74978e078b062da25c82ab5345ee4178a"}, "originalPosition": 279}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMxMjU2MA==", "bodyText": "Fixed.", "url": "https://github.com/apache/geode/pull/5124#discussion_r428312560", "createdAt": "2020-05-20T21:17:43Z", "author": {"login": "agingade"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegionClearMessage.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.cache;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.cache.CacheException;\n+import org.apache.geode.cache.Operation;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.DistributionMessage;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplyMessage;\n+import org.apache.geode.distributed.internal.ReplyProcessor21;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.Assert;\n+import org.apache.geode.internal.NanoTimer;\n+import org.apache.geode.internal.cache.partitioned.PartitionMessage;\n+import org.apache.geode.internal.logging.log4j.LogMarker;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class PartitionedRegionClearMessage extends PartitionMessage {\n+\n+  public enum OperationType {\n+    OP_LOCK_FOR_PR_CLEAR, OP_UNLOCK_FOR_PR_CLEAR, OP_PR_CLEAR,\n+  }\n+\n+  private Object cbArg;\n+\n+  private OperationType op;\n+\n+  private EventID eventID;\n+\n+  private PartitionedRegion partitionedRegion;\n+\n+  private ArrayList bucketsCleared;\n+\n+  @Override\n+  public EventID getEventID() {\n+    return eventID;\n+  }\n+\n+  public PartitionedRegionClearMessage() {}\n+\n+  PartitionedRegionClearMessage(Set recipients, PartitionedRegion region,\n+      ReplyProcessor21 processor, PartitionedRegionClearMessage.OperationType operationType,\n+      final RegionEventImpl event) {\n+    super(recipients, region.getPRId(), processor);\n+    partitionedRegion = region;\n+    op = operationType;\n+    cbArg = event.getRawCallbackArgument();\n+    eventID = event.getEventId();\n+  }\n+\n+  public OperationType getOp() {\n+    return op;\n+  }\n+\n+  public void send() {\n+    Assert.assertTrue(getRecipients() != null, \"ClearMessage NULL recipients set\");\n+    setTransactionDistributed(partitionedRegion.getCache().getTxManager().isDistributed());\n+    partitionedRegion.getDistributionManager().putOutgoing(this);\n+  }\n+\n+  @Override\n+  protected Throwable processCheckForPR(PartitionedRegion pr,\n+      DistributionManager distributionManager) {\n+    if (pr != null && !pr.getDistributionAdvisor().isInitialized()) {\n+      Throwable thr = new ForceReattemptException(\n+          String.format(\"%s : could not find partitioned region with Id %s\",\n+              distributionManager.getDistributionManagerId(),\n+              pr.getRegionIdentifier()));\n+      return thr;\n+    }\n+    return null;\n+  }\n+\n+  @Override\n+  protected boolean operateOnPartitionedRegion(ClusterDistributionManager dm,\n+      PartitionedRegion partitionedRegion,\n+      long startTime) throws CacheException {\n+\n+    if (partitionedRegion == null) {\n+      return true;\n+    }\n+\n+    if (partitionedRegion.isDestroyed()) {\n+      return true;\n+    }\n+\n+    if (op == OperationType.OP_LOCK_FOR_PR_CLEAR) {\n+      partitionedRegion.getPartitionedRegionClear().obtainClearLockLocal(getSender());\n+    } else if (op == OperationType.OP_UNLOCK_FOR_PR_CLEAR) {\n+      partitionedRegion.getPartitionedRegionClear().releaseClearLockLocal();\n+    } else {\n+      RegionEventImpl event =\n+          new RegionEventImpl(partitionedRegion, Operation.REGION_CLEAR, this.cbArg, true,\n+              partitionedRegion.getMyId(),\n+              getEventID());\n+      bucketsCleared = partitionedRegion.getPartitionedRegionClear().clearRegionLocal(event);\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  protected void appendFields(StringBuilder buff) {\n+    super.appendFields(buff);\n+    buff.append(\" cbArg=\").append(this.cbArg).append(\" op=\").append(this.op);\n+  }\n+\n+  @Override\n+  public int getDSFID() {\n+    return CLEAR_PARTITIONED_REGION_MESSAGE;\n+  }\n+\n+  @Override\n+  public void fromData(DataInput in,\n+      DeserializationContext context) throws IOException, ClassNotFoundException {\n+    super.fromData(in, context);\n+    this.cbArg = DataSerializer.readObject(in);\n+    op = PartitionedRegionClearMessage.OperationType.values()[in.readByte()];\n+    eventID = DataSerializer.readObject(in);\n+  }\n+\n+  @Override\n+  public void toData(DataOutput out,\n+      SerializationContext context) throws IOException {\n+    super.toData(out, context);\n+    DataSerializer.writeObject(this.cbArg, out);\n+    out.writeByte(op.ordinal());\n+    DataSerializer.writeObject(eventID, out);\n+  }\n+\n+  /**\n+   * The response on which to wait for all the replies. This response ignores any exceptions\n+   * received from the \"far side\"\n+   */\n+  public static class PartitionedRegionClearResponse extends ReplyProcessor21 {\n+    CopyOnWriteArrayList bucketsCleared = new CopyOnWriteArrayList();\n+\n+    public PartitionedRegionClearResponse(InternalDistributedSystem system, Set initMembers) {\n+      super(system, initMembers);\n+    }\n+\n+    @Override\n+    public void process(DistributionMessage msg) {\n+      if (msg instanceof PartitionedRegionClearReplyMessage) {\n+        List buckets = ((PartitionedRegionClearReplyMessage) msg).bucketsCleared;\n+        if (buckets != null) {\n+          bucketsCleared.addAll(buckets);\n+        }\n+      }\n+      super.process(msg, true);\n+    }\n+  }\n+\n+  @Override\n+  protected void sendReply(InternalDistributedMember member, int processorId,\n+      DistributionManager distributionManager, ReplyException ex,\n+      PartitionedRegion partitionedRegion, long startTime) {\n+    if (partitionedRegion != null) {\n+      if (startTime > 0) {\n+        partitionedRegion.getPrStats().endPartitionMessagesProcessing(startTime);\n+      }\n+    }\n+    PartitionedRegionClearMessage.PartitionedRegionClearReplyMessage\n+        .send(member, processorId, getReplySender(distributionManager), op, bucketsCleared,\n+            ex);\n+  }\n+\n+  public static class PartitionedRegionClearReplyMessage extends ReplyMessage {\n+\n+    private ArrayList bucketsCleared;\n+\n+    private OperationType op;\n+\n+    @Override\n+    public boolean getInlineProcess() {\n+      return true;\n+    }\n+\n+    /**\n+     * Empty constructor to conform to DataSerializable interface\n+     */\n+    public PartitionedRegionClearReplyMessage() {}\n+\n+    private PartitionedRegionClearReplyMessage(int processorId, OperationType op,\n+        ArrayList bucketsCleared, ReplyException ex) {\n+      super();\n+      this.bucketsCleared = bucketsCleared;\n+      this.op = op;\n+      setProcessorId(processorId);\n+      setException(ex);\n+    }\n+\n+    /** Send an ack */\n+    public static void send(InternalDistributedMember recipient, int processorId, ReplySender dm,\n+        OperationType op, ArrayList bucketsCleared, ReplyException ex) {\n+\n+      Assert.assertTrue(recipient != null, \"partitionedRegionClearReplyMessage NULL reply message\");\n+\n+      PartitionedRegionClearMessage.PartitionedRegionClearReplyMessage m =\n+          new PartitionedRegionClearMessage.PartitionedRegionClearReplyMessage(processorId, op,\n+              bucketsCleared, ex);\n+\n+      m.setRecipient(recipient);\n+      dm.putOutgoing(m);\n+    }\n+\n+    /**\n+     * Processes this message. This method is invoked by the receiver of the message.\n+     *\n+     * @param dm the distribution manager that is processing the message.\n+     */\n+    @Override\n+    public void process(final DistributionManager dm, final ReplyProcessor21 rp) {\n+      final long startTime = getTimestamp();\n+\n+      if (rp == null) {\n+        if (LogService.getLogger().isTraceEnabled(LogMarker.DM_VERBOSE)) {\n+          LogService.getLogger().trace(LogMarker.DM_VERBOSE, \"{}: processor not found\", this);\n+        }\n+        return;\n+      }\n+\n+      rp.process(this);\n+\n+      dm.getStats().incReplyMessageTime(NanoTimer.getTime() - startTime);\n+    }\n+\n+    @Override\n+    public int getDSFID() {\n+      return CLEAR_PARTITIONED_REGION_REPLY_MESSAGE;\n+    }\n+\n+    @Override\n+    public void fromData(DataInput in,\n+        DeserializationContext context) throws IOException, ClassNotFoundException {\n+      super.fromData(in, context);\n+      op = PartitionedRegionClearMessage.OperationType.values()[in.readByte()];\n+      bucketsCleared = DataSerializer.readArrayList(in);\n+    }\n+\n+    @Override\n+    public void toData(DataOutput out,\n+        SerializationContext context) throws IOException {\n+      super.toData(out, context);\n+      out.writeByte(op.ordinal());\n+      DataSerializer.writeArrayList(bucketsCleared, out);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      StringBuffer sb = new StringBuffer();\n+      sb.append(\"PartitionedRegionClearReplyMessage \").append(\"processorid=\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY4MTg0Nw=="}, "originalCommit": {"oid": "6316dbb74978e078b062da25c82ab5345ee4178a"}, "originalPosition": 279}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4070, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}