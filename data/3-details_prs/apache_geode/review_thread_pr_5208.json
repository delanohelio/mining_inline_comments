{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI3NDAwMDE2", "number": 5208, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDoyMzoyNFrOECuEMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMzo1OToyN1rOEDIEmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMjg3MzQ1OnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/PartitionedRegionClearTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDoyMzoyNFrOGfWeYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMzoyNjo0OFrOGfbRrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyNzI2Ng==", "bodyText": "Probably should use proper types for the Regions and Sets etc rather than raw types.", "url": "https://github.com/apache/geode/pull/5208#discussion_r435527266", "createdAt": "2020-06-04T20:23:24Z", "author": {"login": "mhansonp"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/PartitionedRegionClearTest.java", "diffHunk": "@@ -0,0 +1,594 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.catchThrowable;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.PartitionedRegionPartialClearException;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.distributed.internal.DMStats;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.MembershipListener;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.partitioned.RegionAdvisor;\n+import org.apache.geode.internal.cache.versions.RegionVersionVector;\n+\n+public class PartitionedRegionClearTest {\n+\n+  int numBuckets = 2;\n+  PartitionedRegionClear partitionedRegionClear;\n+  DistributionManager distributionManager;\n+  PartitionedRegion partitionedRegion;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cb8de5194b1ed5fe03b13c924936e57d2cdc2bf"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwNTkzNA==", "bodyText": "Addressed.", "url": "https://github.com/apache/geode/pull/5208#discussion_r435605934", "createdAt": "2020-06-04T23:26:48Z", "author": {"login": "agingade"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/PartitionedRegionClearTest.java", "diffHunk": "@@ -0,0 +1,594 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.catchThrowable;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.PartitionedRegionPartialClearException;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.distributed.internal.DMStats;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.MembershipListener;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.partitioned.RegionAdvisor;\n+import org.apache.geode.internal.cache.versions.RegionVersionVector;\n+\n+public class PartitionedRegionClearTest {\n+\n+  int numBuckets = 2;\n+  PartitionedRegionClear partitionedRegionClear;\n+  DistributionManager distributionManager;\n+  PartitionedRegion partitionedRegion;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyNzI2Ng=="}, "originalCommit": {"oid": "1cb8de5194b1ed5fe03b13c924936e57d2cdc2bf"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjI5MTY1OnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegion.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNzo1NTo0NFrOGf38pQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMDoyNjozN1rOGgAcyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3NTY4NQ==", "bodyText": "I hate the idea of adding methods like this to Regions. It has nothing to do with Region. Maybe Transaction or TransactionManager would be a better place for this method.", "url": "https://github.com/apache/geode/pull/5208#discussion_r436075685", "createdAt": "2020-06-05T17:55:44Z", "author": {"login": "kirklund"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegion.java", "diffHunk": "@@ -10269,4 +10269,8 @@ boolean hasAnyClientsInterested() {\n     return (getRegionAdvisor().hasPRServerWithInterest()\n         || getRegionAdvisor().hasPRServerWithCQs());\n   }\n+\n+  boolean isTransactionDistributed() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bf63222b8acb0c12e38469a7c05819d2b8e2fd0"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNDk4NA==", "bodyText": "Removed the change.", "url": "https://github.com/apache/geode/pull/5208#discussion_r436214984", "createdAt": "2020-06-06T00:26:37Z", "author": {"login": "agingade"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegion.java", "diffHunk": "@@ -10269,4 +10269,8 @@ boolean hasAnyClientsInterested() {\n     return (getRegionAdvisor().hasPRServerWithInterest()\n         || getRegionAdvisor().hasPRServerWithCQs());\n   }\n+\n+  boolean isTransactionDistributed() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3NTY4NQ=="}, "originalCommit": {"oid": "7bf63222b8acb0c12e38469a7c05819d2b8e2fd0"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjI5NTczOnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/PartitionedRegionClearTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNzo1Njo1N1rOGf3_Qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMDoyNjo1MlrOGgAc7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3NjM1NA==", "bodyText": "We should be declaring vars as the interface instead of the impl:\nSet<BucketRegion> bucketRegions = new HashSet<>();", "url": "https://github.com/apache/geode/pull/5208#discussion_r436076354", "createdAt": "2020-06-05T17:56:57Z", "author": {"login": "kirklund"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/PartitionedRegionClearTest.java", "diffHunk": "@@ -0,0 +1,598 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.catchThrowable;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.PartitionedRegionPartialClearException;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.distributed.internal.DMStats;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.MembershipListener;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.partitioned.RegionAdvisor;\n+import org.apache.geode.internal.cache.versions.RegionVersionVector;\n+\n+public class PartitionedRegionClearTest {\n+\n+\n+  private PartitionedRegionClear partitionedRegionClear;\n+  private DistributionManager distributionManager;\n+  private PartitionedRegion partitionedRegion;\n+\n+  @Before\n+  public void setUp() {\n+\n+    partitionedRegion = mock(PartitionedRegion.class);\n+    distributionManager = mock(DistributionManager.class);\n+\n+    when(partitionedRegion.getDistributionManager()).thenReturn(distributionManager);\n+    when(partitionedRegion.getName()).thenReturn(\"prRegion\");\n+\n+    partitionedRegionClear = new PartitionedRegionClear(partitionedRegion);\n+  }\n+\n+  private Set<BucketRegion> setupBucketRegions(\n+      PartitionedRegionDataStore partitionedRegionDataStore,\n+      BucketAdvisor bucketAdvisor) {\n+    final int numBuckets = 2;\n+    HashSet<BucketRegion> bucketRegions = new HashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bf63222b8acb0c12e38469a7c05819d2b8e2fd0"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNTAyMw==", "bodyText": "Modified in the latest checkin", "url": "https://github.com/apache/geode/pull/5208#discussion_r436215023", "createdAt": "2020-06-06T00:26:52Z", "author": {"login": "agingade"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/PartitionedRegionClearTest.java", "diffHunk": "@@ -0,0 +1,598 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.catchThrowable;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.PartitionedRegionPartialClearException;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.distributed.internal.DMStats;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.MembershipListener;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.partitioned.RegionAdvisor;\n+import org.apache.geode.internal.cache.versions.RegionVersionVector;\n+\n+public class PartitionedRegionClearTest {\n+\n+\n+  private PartitionedRegionClear partitionedRegionClear;\n+  private DistributionManager distributionManager;\n+  private PartitionedRegion partitionedRegion;\n+\n+  @Before\n+  public void setUp() {\n+\n+    partitionedRegion = mock(PartitionedRegion.class);\n+    distributionManager = mock(DistributionManager.class);\n+\n+    when(partitionedRegion.getDistributionManager()).thenReturn(distributionManager);\n+    when(partitionedRegion.getName()).thenReturn(\"prRegion\");\n+\n+    partitionedRegionClear = new PartitionedRegionClear(partitionedRegion);\n+  }\n+\n+  private Set<BucketRegion> setupBucketRegions(\n+      PartitionedRegionDataStore partitionedRegionDataStore,\n+      BucketAdvisor bucketAdvisor) {\n+    final int numBuckets = 2;\n+    HashSet<BucketRegion> bucketRegions = new HashSet<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3NjM1NA=="}, "originalCommit": {"oid": "7bf63222b8acb0c12e38469a7c05819d2b8e2fd0"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjMwMzM5OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/ReplicateCacheListenerDistributedTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNzo1OTowN1rOGf4EDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMDoyNzowOFrOGgAdAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3NzU4Mw==", "bodyText": "You typically want to avoid if-else blocks like this, and separate it into two different tests. One for PR and one for Replicate.\nThe test class is ReplicateCacheListenerDistributedTest. I can't find any PartitionedRegions being created in this test. Does this belong in PRCacheListenerDistributedTest instead?", "url": "https://github.com/apache/geode/pull/5208#discussion_r436077583", "createdAt": "2020-06-05T17:59:07Z", "author": {"login": "kirklund"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/ReplicateCacheListenerDistributedTest.java", "diffHunk": "@@ -179,7 +180,13 @@ public void afterRegionDestroyIsInvokedInEveryMember() {\n \n     region.destroyRegion();\n \n-    assertThat(sharedCountersRule.getTotal(REGION_DESTROY)).isEqualTo(expectedRegionDestroys());\n+    if (region instanceof PartitionedRegion) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bf63222b8acb0c12e38469a7c05819d2b8e2fd0"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNTA0Mw==", "bodyText": "Separated the PRCacheListenerDistributedTest", "url": "https://github.com/apache/geode/pull/5208#discussion_r436215043", "createdAt": "2020-06-06T00:27:08Z", "author": {"login": "agingade"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/ReplicateCacheListenerDistributedTest.java", "diffHunk": "@@ -179,7 +180,13 @@ public void afterRegionDestroyIsInvokedInEveryMember() {\n \n     region.destroyRegion();\n \n-    assertThat(sharedCountersRule.getTotal(REGION_DESTROY)).isEqualTo(expectedRegionDestroys());\n+    if (region instanceof PartitionedRegion) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3NzU4Mw=="}, "originalCommit": {"oid": "7bf63222b8acb0c12e38469a7c05819d2b8e2fd0"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzEzMTUxOnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/PartitionedRegionClearTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMzo1NjozNFrOGgAK5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMDozMzozN1rOGgAgLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxMDQwNQ==", "bodyText": "I think this should be releaseClearLockLocal() instead?", "url": "https://github.com/apache/geode/pull/5208#discussion_r436210405", "createdAt": "2020-06-05T23:56:34Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/PartitionedRegionClearTest.java", "diffHunk": "@@ -0,0 +1,598 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.catchThrowable;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.PartitionedRegionPartialClearException;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.distributed.internal.DMStats;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.MembershipListener;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.partitioned.RegionAdvisor;\n+import org.apache.geode.internal.cache.versions.RegionVersionVector;\n+\n+public class PartitionedRegionClearTest {\n+\n+\n+  private PartitionedRegionClear partitionedRegionClear;\n+  private DistributionManager distributionManager;\n+  private PartitionedRegion partitionedRegion;\n+\n+  @Before\n+  public void setUp() {\n+\n+    partitionedRegion = mock(PartitionedRegion.class);\n+    distributionManager = mock(DistributionManager.class);\n+\n+    when(partitionedRegion.getDistributionManager()).thenReturn(distributionManager);\n+    when(partitionedRegion.getName()).thenReturn(\"prRegion\");\n+\n+    partitionedRegionClear = new PartitionedRegionClear(partitionedRegion);\n+  }\n+\n+  private Set<BucketRegion> setupBucketRegions(\n+      PartitionedRegionDataStore partitionedRegionDataStore,\n+      BucketAdvisor bucketAdvisor) {\n+    final int numBuckets = 2;\n+    HashSet<BucketRegion> bucketRegions = new HashSet<>();\n+    for (int i = 0; i < numBuckets; i++) {\n+      BucketRegion bucketRegion = mock(BucketRegion.class);\n+      when(bucketRegion.getBucketAdvisor()).thenReturn(bucketAdvisor);\n+      when(bucketRegion.size()).thenReturn(1);\n+      when(bucketRegion.getId()).thenReturn(i);\n+      bucketRegions.add(bucketRegion);\n+    }\n+\n+    when(partitionedRegionDataStore.getAllLocalBucketRegions()).thenReturn(bucketRegions);\n+    when(partitionedRegionDataStore.getAllLocalPrimaryBucketRegions()).thenReturn(bucketRegions);\n+\n+    return bucketRegions;\n+  }\n+\n+  @Test\n+  public void isLockedForListenerAndClientNotificationReturnsTrueWhenLocked() {\n+    InternalDistributedMember internalDistributedMember = mock(InternalDistributedMember.class);\n+    when(distributionManager.isCurrentMember(internalDistributedMember)).thenReturn(true);\n+    partitionedRegionClear.obtainClearLockLocal(internalDistributedMember);\n+\n+    assertThat(partitionedRegionClear.isLockedForListenerAndClientNotification()).isTrue();\n+  }\n+\n+  @Test\n+  public void isLockedForListenerAndClientNotificationReturnsFalseWhenMemberNotInTheSystemRequestsLock() {\n+    InternalDistributedMember internalDistributedMember = mock(InternalDistributedMember.class);\n+    when(distributionManager.isCurrentMember(internalDistributedMember)).thenReturn(false);\n+\n+    assertThat(partitionedRegionClear.isLockedForListenerAndClientNotification()).isFalse();\n+  }\n+\n+  @Test\n+  public void acquireDistributedClearLockGetsDistributedLock() {\n+    DistributedLockService distributedLockService = mock(DistributedLockService.class);\n+    String lockName = PartitionedRegionClear.CLEAR_OPERATION + partitionedRegion.getName();\n+    when(partitionedRegion.getPartitionedRegionLockService()).thenReturn(distributedLockService);\n+\n+    partitionedRegionClear.acquireDistributedClearLock(lockName);\n+\n+    verify(distributedLockService, times(1)).lock(lockName, -1, -1);\n+  }\n+\n+  @Test\n+  public void releaseDistributedClearLockReleasesDistributedLock() {\n+    DistributedLockService distributedLockService = mock(DistributedLockService.class);\n+    String lockName = PartitionedRegionClear.CLEAR_OPERATION + partitionedRegion.getName();\n+    when(partitionedRegion.getPartitionedRegionLockService()).thenReturn(distributedLockService);\n+\n+    partitionedRegionClear.releaseDistributedClearLock(lockName);\n+\n+    verify(distributedLockService, times(1)).unlock(lockName);\n+  }\n+\n+  @Test\n+  public void obtainLockForClearGetsLocalLockAndSendsMessageForRemote() throws Exception {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(regionEvent.clone()).thenReturn(mock(RegionEventImpl.class));\n+    Region<String, PartitionRegionConfig> region = mock(Region.class);\n+    when(partitionedRegion.getPRRoot()).thenReturn(region);\n+    PartitionedRegionClear spyPartitionedRegionClear = spy(partitionedRegionClear);\n+    doReturn(Collections.EMPTY_LIST).when(spyPartitionedRegionClear)\n+        .attemptToSendPartitionedRegionClearMessage(regionEvent,\n+            PartitionedRegionClearMessage.OperationType.OP_LOCK_FOR_PR_CLEAR);\n+    InternalDistributedMember internalDistributedMember = mock(InternalDistributedMember.class);\n+    when(distributionManager.getId()).thenReturn(internalDistributedMember);\n+\n+    spyPartitionedRegionClear.obtainLockForClear(regionEvent);\n+\n+    verify(spyPartitionedRegionClear, times(1)).obtainClearLockLocal(internalDistributedMember);\n+    verify(spyPartitionedRegionClear, times(1)).sendPartitionedRegionClearMessage(regionEvent,\n+        PartitionedRegionClearMessage.OperationType.OP_LOCK_FOR_PR_CLEAR);\n+  }\n+\n+  @Test\n+  public void releaseLockForClearReleasesLocalLockAndSendsMessageForRemote() throws Exception {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(regionEvent.clone()).thenReturn(mock(RegionEventImpl.class));\n+    Region<String, PartitionRegionConfig> region = mock(Region.class);\n+    when(partitionedRegion.getPRRoot()).thenReturn(region);\n+    PartitionedRegionClear spyPartitionedRegionClear = spy(partitionedRegionClear);\n+    doReturn(Collections.EMPTY_LIST).when(spyPartitionedRegionClear)\n+        .attemptToSendPartitionedRegionClearMessage(regionEvent,\n+            PartitionedRegionClearMessage.OperationType.OP_UNLOCK_FOR_PR_CLEAR);\n+    InternalDistributedMember internalDistributedMember = mock(InternalDistributedMember.class);\n+    when(distributionManager.getId()).thenReturn(internalDistributedMember);\n+\n+    spyPartitionedRegionClear.releaseLockForClear(regionEvent);\n+\n+    verify(spyPartitionedRegionClear, times(1)).releaseClearLockLocal();\n+    verify(spyPartitionedRegionClear, times(1)).sendPartitionedRegionClearMessage(regionEvent,\n+        PartitionedRegionClearMessage.OperationType.OP_UNLOCK_FOR_PR_CLEAR);\n+  }\n+\n+  @Test\n+  public void clearRegionClearsLocalAndSendsMessageForRemote() throws Exception {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(regionEvent.clone()).thenReturn(mock(RegionEventImpl.class));\n+    Region<String, PartitionRegionConfig> region = mock(Region.class);\n+    when(partitionedRegion.getPRRoot()).thenReturn(region);\n+    PartitionedRegionClear spyPartitionedRegionClear = spy(partitionedRegionClear);\n+    doReturn(Collections.EMPTY_LIST).when(spyPartitionedRegionClear)\n+        .attemptToSendPartitionedRegionClearMessage(regionEvent,\n+            PartitionedRegionClearMessage.OperationType.OP_PR_CLEAR);\n+    InternalDistributedMember internalDistributedMember = mock(InternalDistributedMember.class);\n+    when(distributionManager.getId()).thenReturn(internalDistributedMember);\n+    RegionVersionVector regionVersionVector = mock(RegionVersionVector.class);\n+\n+    spyPartitionedRegionClear.clearRegion(regionEvent, false, regionVersionVector);\n+\n+    verify(spyPartitionedRegionClear, times(1)).clearRegionLocal(regionEvent);\n+    verify(spyPartitionedRegionClear, times(1)).sendPartitionedRegionClearMessage(regionEvent,\n+        PartitionedRegionClearMessage.OperationType.OP_PR_CLEAR);\n+  }\n+\n+  @Test\n+  public void waitForPrimaryReturnsAfterFindingAllPrimary() {\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    PartitionedRegion.RetryTimeKeeper retryTimer = mock(PartitionedRegion.RetryTimeKeeper.class);\n+\n+    partitionedRegionClear.waitForPrimary(retryTimer);\n+\n+    verify(retryTimer, times(0)).waitForBucketsRecovery();\n+  }\n+\n+  @Test\n+  public void waitForPrimaryReturnsAfterRetryForPrimary() {\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(false).thenReturn(true);\n+    setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    PartitionedRegion.RetryTimeKeeper retryTimer = mock(PartitionedRegion.RetryTimeKeeper.class);\n+\n+    partitionedRegionClear.waitForPrimary(retryTimer);\n+\n+    verify(retryTimer, times(1)).waitForBucketsRecovery();\n+  }\n+\n+  @Test\n+  public void waitForPrimaryThrowsPartitionedRegionPartialClearException() {\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    PartitionedRegion.RetryTimeKeeper retryTimer = mock(PartitionedRegion.RetryTimeKeeper.class);\n+    when(retryTimer.overMaximum()).thenReturn(true);\n+\n+    Throwable thrown = catchThrowable(() -> partitionedRegionClear.waitForPrimary(retryTimer));\n+\n+    assertThat(thrown)\n+        .isInstanceOf(PartitionedRegionPartialClearException.class)\n+        .hasMessage(\n+            \"Unable to find primary bucket region during clear operation for region: prRegion\");\n+    verify(retryTimer, times(0)).waitForBucketsRecovery();\n+  }\n+\n+  @Test\n+  public void clearRegionLocalCallsClearOnLocalPrimaryBucketRegions() {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    doNothing().when(partitionedRegionDataStore).lockBucketCreationForRegionClear();\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+\n+    List bucketsCleared = partitionedRegionClear.clearRegionLocal(regionEvent);\n+\n+    assertThat(bucketsCleared.size()).isEqualTo(buckets.size());\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(1)).clear();\n+    }\n+  }\n+\n+  @Test\n+  public void clearRegionLocalRetriesClearOnLocalPrimaryBucketRegions() {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    doNothing().when(partitionedRegionDataStore).lockBucketCreationForRegionClear();\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    PartitionedRegionClear spyPartitionedRegionClear = spy(partitionedRegionClear);\n+    when(spyPartitionedRegionClear.getMembershipChange()).thenReturn(true).thenReturn(false);\n+\n+    List bucketsCleared = spyPartitionedRegionClear.clearRegionLocal(regionEvent);\n+\n+    int expectedClears = buckets.size() * 2; /* clear is called twice on each bucket */\n+    assertThat(bucketsCleared.size()).isEqualTo(expectedClears);\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(2)).clear();\n+    }\n+  }\n+\n+  @Test\n+  public void doAfterClearCallsNotifyClientsWhenClientHaveInterests() {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(partitionedRegion.hasAnyClientsInterested()).thenReturn(true);\n+    FilterProfile filterProfile = mock(FilterProfile.class);\n+    FilterRoutingInfo filterRoutingInfo = mock(FilterRoutingInfo.class);\n+    when(filterProfile.getFilterRoutingInfoPart1(regionEvent, FilterProfile.NO_PROFILES,\n+        Collections.emptySet())).thenReturn(filterRoutingInfo);\n+    when(filterProfile.getFilterRoutingInfoPart2(filterRoutingInfo, regionEvent)).thenReturn(\n+        filterRoutingInfo);\n+    when(partitionedRegion.getFilterProfile()).thenReturn(filterProfile);\n+\n+    partitionedRegionClear.doAfterClear(regionEvent);\n+\n+    verify(regionEvent, times(1)).setLocalFilterInfo(any());\n+    verify(partitionedRegion, times(1)).notifyBridgeClients(regionEvent);\n+  }\n+\n+  @Test\n+  public void doAfterClearDispatchesListenerEvents() {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(partitionedRegion.hasListener()).thenReturn(true);\n+\n+    partitionedRegionClear.doAfterClear(regionEvent);\n+\n+    verify(partitionedRegion, times(1)).dispatchListenerEvent(\n+        EnumListenerEvent.AFTER_REGION_CLEAR, regionEvent);\n+  }\n+\n+  @Test\n+  public void obtainClearLockLocalGetsLockOnPrimaryBuckets() {\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    InternalDistributedMember member = mock(InternalDistributedMember.class);\n+    when(distributionManager.isCurrentMember(member)).thenReturn(true);\n+\n+    partitionedRegionClear.obtainClearLockLocal(member);\n+\n+    assertThat(partitionedRegionClear.lockForListenerAndClientNotification.getLockRequester())\n+        .isSameAs(member);\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(1)).lockLocallyForClear(partitionedRegion.getDistributionManager(),\n+          partitionedRegion.getMyId(), null);\n+    }\n+  }\n+\n+  @Test\n+  public void obtainClearLockLocalDoesNotGetLocksOnPrimaryBucketsWhenMemberIsNotCurrent() {\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    InternalDistributedMember member = mock(InternalDistributedMember.class);\n+    when(distributionManager.isCurrentMember(member)).thenReturn(false);\n+\n+    partitionedRegionClear.obtainClearLockLocal(member);\n+\n+    assertThat(partitionedRegionClear.lockForListenerAndClientNotification.getLockRequester())\n+        .isNull();\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(0)).lockLocallyForClear(partitionedRegion.getDistributionManager(),\n+          partitionedRegion.getMyId(), null);\n+    }\n+  }\n+\n+  @Test\n+  public void releaseClearLockLocalReleasesLockOnPrimaryBuckets() {\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    InternalDistributedMember member = mock(InternalDistributedMember.class);\n+    when(distributionManager.isCurrentMember(member)).thenReturn(true);\n+    partitionedRegionClear.lockForListenerAndClientNotification.setLocked(member);\n+\n+    partitionedRegionClear.releaseClearLockLocal();\n+\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(1)).releaseLockLocallyForClear(null);\n+    }\n+  }\n+\n+  @Test\n+  public void releaseClearLockLocalDoesNotReleaseLocksOnPrimaryBucketsWhenMemberIsNotCurrent() {\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    InternalDistributedMember member = mock(InternalDistributedMember.class);\n+\n+    partitionedRegionClear.obtainClearLockLocal(member);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bf63222b8acb0c12e38469a7c05819d2b8e2fd0"}, "originalPosition": 367}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNTg1NA==", "bodyText": "Good catch. Thanks.\nUpdated the test.", "url": "https://github.com/apache/geode/pull/5208#discussion_r436215854", "createdAt": "2020-06-06T00:33:37Z", "author": {"login": "agingade"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/PartitionedRegionClearTest.java", "diffHunk": "@@ -0,0 +1,598 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.catchThrowable;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.PartitionedRegionPartialClearException;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.distributed.internal.DMStats;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.MembershipListener;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.partitioned.RegionAdvisor;\n+import org.apache.geode.internal.cache.versions.RegionVersionVector;\n+\n+public class PartitionedRegionClearTest {\n+\n+\n+  private PartitionedRegionClear partitionedRegionClear;\n+  private DistributionManager distributionManager;\n+  private PartitionedRegion partitionedRegion;\n+\n+  @Before\n+  public void setUp() {\n+\n+    partitionedRegion = mock(PartitionedRegion.class);\n+    distributionManager = mock(DistributionManager.class);\n+\n+    when(partitionedRegion.getDistributionManager()).thenReturn(distributionManager);\n+    when(partitionedRegion.getName()).thenReturn(\"prRegion\");\n+\n+    partitionedRegionClear = new PartitionedRegionClear(partitionedRegion);\n+  }\n+\n+  private Set<BucketRegion> setupBucketRegions(\n+      PartitionedRegionDataStore partitionedRegionDataStore,\n+      BucketAdvisor bucketAdvisor) {\n+    final int numBuckets = 2;\n+    HashSet<BucketRegion> bucketRegions = new HashSet<>();\n+    for (int i = 0; i < numBuckets; i++) {\n+      BucketRegion bucketRegion = mock(BucketRegion.class);\n+      when(bucketRegion.getBucketAdvisor()).thenReturn(bucketAdvisor);\n+      when(bucketRegion.size()).thenReturn(1);\n+      when(bucketRegion.getId()).thenReturn(i);\n+      bucketRegions.add(bucketRegion);\n+    }\n+\n+    when(partitionedRegionDataStore.getAllLocalBucketRegions()).thenReturn(bucketRegions);\n+    when(partitionedRegionDataStore.getAllLocalPrimaryBucketRegions()).thenReturn(bucketRegions);\n+\n+    return bucketRegions;\n+  }\n+\n+  @Test\n+  public void isLockedForListenerAndClientNotificationReturnsTrueWhenLocked() {\n+    InternalDistributedMember internalDistributedMember = mock(InternalDistributedMember.class);\n+    when(distributionManager.isCurrentMember(internalDistributedMember)).thenReturn(true);\n+    partitionedRegionClear.obtainClearLockLocal(internalDistributedMember);\n+\n+    assertThat(partitionedRegionClear.isLockedForListenerAndClientNotification()).isTrue();\n+  }\n+\n+  @Test\n+  public void isLockedForListenerAndClientNotificationReturnsFalseWhenMemberNotInTheSystemRequestsLock() {\n+    InternalDistributedMember internalDistributedMember = mock(InternalDistributedMember.class);\n+    when(distributionManager.isCurrentMember(internalDistributedMember)).thenReturn(false);\n+\n+    assertThat(partitionedRegionClear.isLockedForListenerAndClientNotification()).isFalse();\n+  }\n+\n+  @Test\n+  public void acquireDistributedClearLockGetsDistributedLock() {\n+    DistributedLockService distributedLockService = mock(DistributedLockService.class);\n+    String lockName = PartitionedRegionClear.CLEAR_OPERATION + partitionedRegion.getName();\n+    when(partitionedRegion.getPartitionedRegionLockService()).thenReturn(distributedLockService);\n+\n+    partitionedRegionClear.acquireDistributedClearLock(lockName);\n+\n+    verify(distributedLockService, times(1)).lock(lockName, -1, -1);\n+  }\n+\n+  @Test\n+  public void releaseDistributedClearLockReleasesDistributedLock() {\n+    DistributedLockService distributedLockService = mock(DistributedLockService.class);\n+    String lockName = PartitionedRegionClear.CLEAR_OPERATION + partitionedRegion.getName();\n+    when(partitionedRegion.getPartitionedRegionLockService()).thenReturn(distributedLockService);\n+\n+    partitionedRegionClear.releaseDistributedClearLock(lockName);\n+\n+    verify(distributedLockService, times(1)).unlock(lockName);\n+  }\n+\n+  @Test\n+  public void obtainLockForClearGetsLocalLockAndSendsMessageForRemote() throws Exception {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(regionEvent.clone()).thenReturn(mock(RegionEventImpl.class));\n+    Region<String, PartitionRegionConfig> region = mock(Region.class);\n+    when(partitionedRegion.getPRRoot()).thenReturn(region);\n+    PartitionedRegionClear spyPartitionedRegionClear = spy(partitionedRegionClear);\n+    doReturn(Collections.EMPTY_LIST).when(spyPartitionedRegionClear)\n+        .attemptToSendPartitionedRegionClearMessage(regionEvent,\n+            PartitionedRegionClearMessage.OperationType.OP_LOCK_FOR_PR_CLEAR);\n+    InternalDistributedMember internalDistributedMember = mock(InternalDistributedMember.class);\n+    when(distributionManager.getId()).thenReturn(internalDistributedMember);\n+\n+    spyPartitionedRegionClear.obtainLockForClear(regionEvent);\n+\n+    verify(spyPartitionedRegionClear, times(1)).obtainClearLockLocal(internalDistributedMember);\n+    verify(spyPartitionedRegionClear, times(1)).sendPartitionedRegionClearMessage(regionEvent,\n+        PartitionedRegionClearMessage.OperationType.OP_LOCK_FOR_PR_CLEAR);\n+  }\n+\n+  @Test\n+  public void releaseLockForClearReleasesLocalLockAndSendsMessageForRemote() throws Exception {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(regionEvent.clone()).thenReturn(mock(RegionEventImpl.class));\n+    Region<String, PartitionRegionConfig> region = mock(Region.class);\n+    when(partitionedRegion.getPRRoot()).thenReturn(region);\n+    PartitionedRegionClear spyPartitionedRegionClear = spy(partitionedRegionClear);\n+    doReturn(Collections.EMPTY_LIST).when(spyPartitionedRegionClear)\n+        .attemptToSendPartitionedRegionClearMessage(regionEvent,\n+            PartitionedRegionClearMessage.OperationType.OP_UNLOCK_FOR_PR_CLEAR);\n+    InternalDistributedMember internalDistributedMember = mock(InternalDistributedMember.class);\n+    when(distributionManager.getId()).thenReturn(internalDistributedMember);\n+\n+    spyPartitionedRegionClear.releaseLockForClear(regionEvent);\n+\n+    verify(spyPartitionedRegionClear, times(1)).releaseClearLockLocal();\n+    verify(spyPartitionedRegionClear, times(1)).sendPartitionedRegionClearMessage(regionEvent,\n+        PartitionedRegionClearMessage.OperationType.OP_UNLOCK_FOR_PR_CLEAR);\n+  }\n+\n+  @Test\n+  public void clearRegionClearsLocalAndSendsMessageForRemote() throws Exception {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(regionEvent.clone()).thenReturn(mock(RegionEventImpl.class));\n+    Region<String, PartitionRegionConfig> region = mock(Region.class);\n+    when(partitionedRegion.getPRRoot()).thenReturn(region);\n+    PartitionedRegionClear spyPartitionedRegionClear = spy(partitionedRegionClear);\n+    doReturn(Collections.EMPTY_LIST).when(spyPartitionedRegionClear)\n+        .attemptToSendPartitionedRegionClearMessage(regionEvent,\n+            PartitionedRegionClearMessage.OperationType.OP_PR_CLEAR);\n+    InternalDistributedMember internalDistributedMember = mock(InternalDistributedMember.class);\n+    when(distributionManager.getId()).thenReturn(internalDistributedMember);\n+    RegionVersionVector regionVersionVector = mock(RegionVersionVector.class);\n+\n+    spyPartitionedRegionClear.clearRegion(regionEvent, false, regionVersionVector);\n+\n+    verify(spyPartitionedRegionClear, times(1)).clearRegionLocal(regionEvent);\n+    verify(spyPartitionedRegionClear, times(1)).sendPartitionedRegionClearMessage(regionEvent,\n+        PartitionedRegionClearMessage.OperationType.OP_PR_CLEAR);\n+  }\n+\n+  @Test\n+  public void waitForPrimaryReturnsAfterFindingAllPrimary() {\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    PartitionedRegion.RetryTimeKeeper retryTimer = mock(PartitionedRegion.RetryTimeKeeper.class);\n+\n+    partitionedRegionClear.waitForPrimary(retryTimer);\n+\n+    verify(retryTimer, times(0)).waitForBucketsRecovery();\n+  }\n+\n+  @Test\n+  public void waitForPrimaryReturnsAfterRetryForPrimary() {\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(false).thenReturn(true);\n+    setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    PartitionedRegion.RetryTimeKeeper retryTimer = mock(PartitionedRegion.RetryTimeKeeper.class);\n+\n+    partitionedRegionClear.waitForPrimary(retryTimer);\n+\n+    verify(retryTimer, times(1)).waitForBucketsRecovery();\n+  }\n+\n+  @Test\n+  public void waitForPrimaryThrowsPartitionedRegionPartialClearException() {\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    PartitionedRegion.RetryTimeKeeper retryTimer = mock(PartitionedRegion.RetryTimeKeeper.class);\n+    when(retryTimer.overMaximum()).thenReturn(true);\n+\n+    Throwable thrown = catchThrowable(() -> partitionedRegionClear.waitForPrimary(retryTimer));\n+\n+    assertThat(thrown)\n+        .isInstanceOf(PartitionedRegionPartialClearException.class)\n+        .hasMessage(\n+            \"Unable to find primary bucket region during clear operation for region: prRegion\");\n+    verify(retryTimer, times(0)).waitForBucketsRecovery();\n+  }\n+\n+  @Test\n+  public void clearRegionLocalCallsClearOnLocalPrimaryBucketRegions() {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    doNothing().when(partitionedRegionDataStore).lockBucketCreationForRegionClear();\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+\n+    List bucketsCleared = partitionedRegionClear.clearRegionLocal(regionEvent);\n+\n+    assertThat(bucketsCleared.size()).isEqualTo(buckets.size());\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(1)).clear();\n+    }\n+  }\n+\n+  @Test\n+  public void clearRegionLocalRetriesClearOnLocalPrimaryBucketRegions() {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    doNothing().when(partitionedRegionDataStore).lockBucketCreationForRegionClear();\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    PartitionedRegionClear spyPartitionedRegionClear = spy(partitionedRegionClear);\n+    when(spyPartitionedRegionClear.getMembershipChange()).thenReturn(true).thenReturn(false);\n+\n+    List bucketsCleared = spyPartitionedRegionClear.clearRegionLocal(regionEvent);\n+\n+    int expectedClears = buckets.size() * 2; /* clear is called twice on each bucket */\n+    assertThat(bucketsCleared.size()).isEqualTo(expectedClears);\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(2)).clear();\n+    }\n+  }\n+\n+  @Test\n+  public void doAfterClearCallsNotifyClientsWhenClientHaveInterests() {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(partitionedRegion.hasAnyClientsInterested()).thenReturn(true);\n+    FilterProfile filterProfile = mock(FilterProfile.class);\n+    FilterRoutingInfo filterRoutingInfo = mock(FilterRoutingInfo.class);\n+    when(filterProfile.getFilterRoutingInfoPart1(regionEvent, FilterProfile.NO_PROFILES,\n+        Collections.emptySet())).thenReturn(filterRoutingInfo);\n+    when(filterProfile.getFilterRoutingInfoPart2(filterRoutingInfo, regionEvent)).thenReturn(\n+        filterRoutingInfo);\n+    when(partitionedRegion.getFilterProfile()).thenReturn(filterProfile);\n+\n+    partitionedRegionClear.doAfterClear(regionEvent);\n+\n+    verify(regionEvent, times(1)).setLocalFilterInfo(any());\n+    verify(partitionedRegion, times(1)).notifyBridgeClients(regionEvent);\n+  }\n+\n+  @Test\n+  public void doAfterClearDispatchesListenerEvents() {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(partitionedRegion.hasListener()).thenReturn(true);\n+\n+    partitionedRegionClear.doAfterClear(regionEvent);\n+\n+    verify(partitionedRegion, times(1)).dispatchListenerEvent(\n+        EnumListenerEvent.AFTER_REGION_CLEAR, regionEvent);\n+  }\n+\n+  @Test\n+  public void obtainClearLockLocalGetsLockOnPrimaryBuckets() {\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    InternalDistributedMember member = mock(InternalDistributedMember.class);\n+    when(distributionManager.isCurrentMember(member)).thenReturn(true);\n+\n+    partitionedRegionClear.obtainClearLockLocal(member);\n+\n+    assertThat(partitionedRegionClear.lockForListenerAndClientNotification.getLockRequester())\n+        .isSameAs(member);\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(1)).lockLocallyForClear(partitionedRegion.getDistributionManager(),\n+          partitionedRegion.getMyId(), null);\n+    }\n+  }\n+\n+  @Test\n+  public void obtainClearLockLocalDoesNotGetLocksOnPrimaryBucketsWhenMemberIsNotCurrent() {\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    InternalDistributedMember member = mock(InternalDistributedMember.class);\n+    when(distributionManager.isCurrentMember(member)).thenReturn(false);\n+\n+    partitionedRegionClear.obtainClearLockLocal(member);\n+\n+    assertThat(partitionedRegionClear.lockForListenerAndClientNotification.getLockRequester())\n+        .isNull();\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(0)).lockLocallyForClear(partitionedRegion.getDistributionManager(),\n+          partitionedRegion.getMyId(), null);\n+    }\n+  }\n+\n+  @Test\n+  public void releaseClearLockLocalReleasesLockOnPrimaryBuckets() {\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    InternalDistributedMember member = mock(InternalDistributedMember.class);\n+    when(distributionManager.isCurrentMember(member)).thenReturn(true);\n+    partitionedRegionClear.lockForListenerAndClientNotification.setLocked(member);\n+\n+    partitionedRegionClear.releaseClearLockLocal();\n+\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(1)).releaseLockLocallyForClear(null);\n+    }\n+  }\n+\n+  @Test\n+  public void releaseClearLockLocalDoesNotReleaseLocksOnPrimaryBucketsWhenMemberIsNotCurrent() {\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    InternalDistributedMember member = mock(InternalDistributedMember.class);\n+\n+    partitionedRegionClear.obtainClearLockLocal(member);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxMDQwNQ=="}, "originalCommit": {"oid": "7bf63222b8acb0c12e38469a7c05819d2b8e2fd0"}, "originalPosition": 367}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzEzNDM1OnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/PartitionedRegionClearTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMzo1OToyN1rOGgAMkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMDozNDowMlrOGgAgYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxMDgzMw==", "bodyText": "Small suggestion; you can instead use Set<InternalDistributedMember> prNodes = Collections.singleton(member); and Set<Node> configNodes = Collections.singleton(node); to condense the code a little.", "url": "https://github.com/apache/geode/pull/5208#discussion_r436210833", "createdAt": "2020-06-05T23:59:27Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/PartitionedRegionClearTest.java", "diffHunk": "@@ -0,0 +1,598 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.catchThrowable;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.PartitionedRegionPartialClearException;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.distributed.internal.DMStats;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.MembershipListener;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.partitioned.RegionAdvisor;\n+import org.apache.geode.internal.cache.versions.RegionVersionVector;\n+\n+public class PartitionedRegionClearTest {\n+\n+\n+  private PartitionedRegionClear partitionedRegionClear;\n+  private DistributionManager distributionManager;\n+  private PartitionedRegion partitionedRegion;\n+\n+  @Before\n+  public void setUp() {\n+\n+    partitionedRegion = mock(PartitionedRegion.class);\n+    distributionManager = mock(DistributionManager.class);\n+\n+    when(partitionedRegion.getDistributionManager()).thenReturn(distributionManager);\n+    when(partitionedRegion.getName()).thenReturn(\"prRegion\");\n+\n+    partitionedRegionClear = new PartitionedRegionClear(partitionedRegion);\n+  }\n+\n+  private Set<BucketRegion> setupBucketRegions(\n+      PartitionedRegionDataStore partitionedRegionDataStore,\n+      BucketAdvisor bucketAdvisor) {\n+    final int numBuckets = 2;\n+    HashSet<BucketRegion> bucketRegions = new HashSet<>();\n+    for (int i = 0; i < numBuckets; i++) {\n+      BucketRegion bucketRegion = mock(BucketRegion.class);\n+      when(bucketRegion.getBucketAdvisor()).thenReturn(bucketAdvisor);\n+      when(bucketRegion.size()).thenReturn(1);\n+      when(bucketRegion.getId()).thenReturn(i);\n+      bucketRegions.add(bucketRegion);\n+    }\n+\n+    when(partitionedRegionDataStore.getAllLocalBucketRegions()).thenReturn(bucketRegions);\n+    when(partitionedRegionDataStore.getAllLocalPrimaryBucketRegions()).thenReturn(bucketRegions);\n+\n+    return bucketRegions;\n+  }\n+\n+  @Test\n+  public void isLockedForListenerAndClientNotificationReturnsTrueWhenLocked() {\n+    InternalDistributedMember internalDistributedMember = mock(InternalDistributedMember.class);\n+    when(distributionManager.isCurrentMember(internalDistributedMember)).thenReturn(true);\n+    partitionedRegionClear.obtainClearLockLocal(internalDistributedMember);\n+\n+    assertThat(partitionedRegionClear.isLockedForListenerAndClientNotification()).isTrue();\n+  }\n+\n+  @Test\n+  public void isLockedForListenerAndClientNotificationReturnsFalseWhenMemberNotInTheSystemRequestsLock() {\n+    InternalDistributedMember internalDistributedMember = mock(InternalDistributedMember.class);\n+    when(distributionManager.isCurrentMember(internalDistributedMember)).thenReturn(false);\n+\n+    assertThat(partitionedRegionClear.isLockedForListenerAndClientNotification()).isFalse();\n+  }\n+\n+  @Test\n+  public void acquireDistributedClearLockGetsDistributedLock() {\n+    DistributedLockService distributedLockService = mock(DistributedLockService.class);\n+    String lockName = PartitionedRegionClear.CLEAR_OPERATION + partitionedRegion.getName();\n+    when(partitionedRegion.getPartitionedRegionLockService()).thenReturn(distributedLockService);\n+\n+    partitionedRegionClear.acquireDistributedClearLock(lockName);\n+\n+    verify(distributedLockService, times(1)).lock(lockName, -1, -1);\n+  }\n+\n+  @Test\n+  public void releaseDistributedClearLockReleasesDistributedLock() {\n+    DistributedLockService distributedLockService = mock(DistributedLockService.class);\n+    String lockName = PartitionedRegionClear.CLEAR_OPERATION + partitionedRegion.getName();\n+    when(partitionedRegion.getPartitionedRegionLockService()).thenReturn(distributedLockService);\n+\n+    partitionedRegionClear.releaseDistributedClearLock(lockName);\n+\n+    verify(distributedLockService, times(1)).unlock(lockName);\n+  }\n+\n+  @Test\n+  public void obtainLockForClearGetsLocalLockAndSendsMessageForRemote() throws Exception {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(regionEvent.clone()).thenReturn(mock(RegionEventImpl.class));\n+    Region<String, PartitionRegionConfig> region = mock(Region.class);\n+    when(partitionedRegion.getPRRoot()).thenReturn(region);\n+    PartitionedRegionClear spyPartitionedRegionClear = spy(partitionedRegionClear);\n+    doReturn(Collections.EMPTY_LIST).when(spyPartitionedRegionClear)\n+        .attemptToSendPartitionedRegionClearMessage(regionEvent,\n+            PartitionedRegionClearMessage.OperationType.OP_LOCK_FOR_PR_CLEAR);\n+    InternalDistributedMember internalDistributedMember = mock(InternalDistributedMember.class);\n+    when(distributionManager.getId()).thenReturn(internalDistributedMember);\n+\n+    spyPartitionedRegionClear.obtainLockForClear(regionEvent);\n+\n+    verify(spyPartitionedRegionClear, times(1)).obtainClearLockLocal(internalDistributedMember);\n+    verify(spyPartitionedRegionClear, times(1)).sendPartitionedRegionClearMessage(regionEvent,\n+        PartitionedRegionClearMessage.OperationType.OP_LOCK_FOR_PR_CLEAR);\n+  }\n+\n+  @Test\n+  public void releaseLockForClearReleasesLocalLockAndSendsMessageForRemote() throws Exception {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(regionEvent.clone()).thenReturn(mock(RegionEventImpl.class));\n+    Region<String, PartitionRegionConfig> region = mock(Region.class);\n+    when(partitionedRegion.getPRRoot()).thenReturn(region);\n+    PartitionedRegionClear spyPartitionedRegionClear = spy(partitionedRegionClear);\n+    doReturn(Collections.EMPTY_LIST).when(spyPartitionedRegionClear)\n+        .attemptToSendPartitionedRegionClearMessage(regionEvent,\n+            PartitionedRegionClearMessage.OperationType.OP_UNLOCK_FOR_PR_CLEAR);\n+    InternalDistributedMember internalDistributedMember = mock(InternalDistributedMember.class);\n+    when(distributionManager.getId()).thenReturn(internalDistributedMember);\n+\n+    spyPartitionedRegionClear.releaseLockForClear(regionEvent);\n+\n+    verify(spyPartitionedRegionClear, times(1)).releaseClearLockLocal();\n+    verify(spyPartitionedRegionClear, times(1)).sendPartitionedRegionClearMessage(regionEvent,\n+        PartitionedRegionClearMessage.OperationType.OP_UNLOCK_FOR_PR_CLEAR);\n+  }\n+\n+  @Test\n+  public void clearRegionClearsLocalAndSendsMessageForRemote() throws Exception {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(regionEvent.clone()).thenReturn(mock(RegionEventImpl.class));\n+    Region<String, PartitionRegionConfig> region = mock(Region.class);\n+    when(partitionedRegion.getPRRoot()).thenReturn(region);\n+    PartitionedRegionClear spyPartitionedRegionClear = spy(partitionedRegionClear);\n+    doReturn(Collections.EMPTY_LIST).when(spyPartitionedRegionClear)\n+        .attemptToSendPartitionedRegionClearMessage(regionEvent,\n+            PartitionedRegionClearMessage.OperationType.OP_PR_CLEAR);\n+    InternalDistributedMember internalDistributedMember = mock(InternalDistributedMember.class);\n+    when(distributionManager.getId()).thenReturn(internalDistributedMember);\n+    RegionVersionVector regionVersionVector = mock(RegionVersionVector.class);\n+\n+    spyPartitionedRegionClear.clearRegion(regionEvent, false, regionVersionVector);\n+\n+    verify(spyPartitionedRegionClear, times(1)).clearRegionLocal(regionEvent);\n+    verify(spyPartitionedRegionClear, times(1)).sendPartitionedRegionClearMessage(regionEvent,\n+        PartitionedRegionClearMessage.OperationType.OP_PR_CLEAR);\n+  }\n+\n+  @Test\n+  public void waitForPrimaryReturnsAfterFindingAllPrimary() {\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    PartitionedRegion.RetryTimeKeeper retryTimer = mock(PartitionedRegion.RetryTimeKeeper.class);\n+\n+    partitionedRegionClear.waitForPrimary(retryTimer);\n+\n+    verify(retryTimer, times(0)).waitForBucketsRecovery();\n+  }\n+\n+  @Test\n+  public void waitForPrimaryReturnsAfterRetryForPrimary() {\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(false).thenReturn(true);\n+    setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    PartitionedRegion.RetryTimeKeeper retryTimer = mock(PartitionedRegion.RetryTimeKeeper.class);\n+\n+    partitionedRegionClear.waitForPrimary(retryTimer);\n+\n+    verify(retryTimer, times(1)).waitForBucketsRecovery();\n+  }\n+\n+  @Test\n+  public void waitForPrimaryThrowsPartitionedRegionPartialClearException() {\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    PartitionedRegion.RetryTimeKeeper retryTimer = mock(PartitionedRegion.RetryTimeKeeper.class);\n+    when(retryTimer.overMaximum()).thenReturn(true);\n+\n+    Throwable thrown = catchThrowable(() -> partitionedRegionClear.waitForPrimary(retryTimer));\n+\n+    assertThat(thrown)\n+        .isInstanceOf(PartitionedRegionPartialClearException.class)\n+        .hasMessage(\n+            \"Unable to find primary bucket region during clear operation for region: prRegion\");\n+    verify(retryTimer, times(0)).waitForBucketsRecovery();\n+  }\n+\n+  @Test\n+  public void clearRegionLocalCallsClearOnLocalPrimaryBucketRegions() {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    doNothing().when(partitionedRegionDataStore).lockBucketCreationForRegionClear();\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+\n+    List bucketsCleared = partitionedRegionClear.clearRegionLocal(regionEvent);\n+\n+    assertThat(bucketsCleared.size()).isEqualTo(buckets.size());\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(1)).clear();\n+    }\n+  }\n+\n+  @Test\n+  public void clearRegionLocalRetriesClearOnLocalPrimaryBucketRegions() {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    doNothing().when(partitionedRegionDataStore).lockBucketCreationForRegionClear();\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    PartitionedRegionClear spyPartitionedRegionClear = spy(partitionedRegionClear);\n+    when(spyPartitionedRegionClear.getMembershipChange()).thenReturn(true).thenReturn(false);\n+\n+    List bucketsCleared = spyPartitionedRegionClear.clearRegionLocal(regionEvent);\n+\n+    int expectedClears = buckets.size() * 2; /* clear is called twice on each bucket */\n+    assertThat(bucketsCleared.size()).isEqualTo(expectedClears);\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(2)).clear();\n+    }\n+  }\n+\n+  @Test\n+  public void doAfterClearCallsNotifyClientsWhenClientHaveInterests() {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(partitionedRegion.hasAnyClientsInterested()).thenReturn(true);\n+    FilterProfile filterProfile = mock(FilterProfile.class);\n+    FilterRoutingInfo filterRoutingInfo = mock(FilterRoutingInfo.class);\n+    when(filterProfile.getFilterRoutingInfoPart1(regionEvent, FilterProfile.NO_PROFILES,\n+        Collections.emptySet())).thenReturn(filterRoutingInfo);\n+    when(filterProfile.getFilterRoutingInfoPart2(filterRoutingInfo, regionEvent)).thenReturn(\n+        filterRoutingInfo);\n+    when(partitionedRegion.getFilterProfile()).thenReturn(filterProfile);\n+\n+    partitionedRegionClear.doAfterClear(regionEvent);\n+\n+    verify(regionEvent, times(1)).setLocalFilterInfo(any());\n+    verify(partitionedRegion, times(1)).notifyBridgeClients(regionEvent);\n+  }\n+\n+  @Test\n+  public void doAfterClearDispatchesListenerEvents() {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(partitionedRegion.hasListener()).thenReturn(true);\n+\n+    partitionedRegionClear.doAfterClear(regionEvent);\n+\n+    verify(partitionedRegion, times(1)).dispatchListenerEvent(\n+        EnumListenerEvent.AFTER_REGION_CLEAR, regionEvent);\n+  }\n+\n+  @Test\n+  public void obtainClearLockLocalGetsLockOnPrimaryBuckets() {\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    InternalDistributedMember member = mock(InternalDistributedMember.class);\n+    when(distributionManager.isCurrentMember(member)).thenReturn(true);\n+\n+    partitionedRegionClear.obtainClearLockLocal(member);\n+\n+    assertThat(partitionedRegionClear.lockForListenerAndClientNotification.getLockRequester())\n+        .isSameAs(member);\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(1)).lockLocallyForClear(partitionedRegion.getDistributionManager(),\n+          partitionedRegion.getMyId(), null);\n+    }\n+  }\n+\n+  @Test\n+  public void obtainClearLockLocalDoesNotGetLocksOnPrimaryBucketsWhenMemberIsNotCurrent() {\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    InternalDistributedMember member = mock(InternalDistributedMember.class);\n+    when(distributionManager.isCurrentMember(member)).thenReturn(false);\n+\n+    partitionedRegionClear.obtainClearLockLocal(member);\n+\n+    assertThat(partitionedRegionClear.lockForListenerAndClientNotification.getLockRequester())\n+        .isNull();\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(0)).lockLocallyForClear(partitionedRegion.getDistributionManager(),\n+          partitionedRegion.getMyId(), null);\n+    }\n+  }\n+\n+  @Test\n+  public void releaseClearLockLocalReleasesLockOnPrimaryBuckets() {\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    InternalDistributedMember member = mock(InternalDistributedMember.class);\n+    when(distributionManager.isCurrentMember(member)).thenReturn(true);\n+    partitionedRegionClear.lockForListenerAndClientNotification.setLocked(member);\n+\n+    partitionedRegionClear.releaseClearLockLocal();\n+\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(1)).releaseLockLocallyForClear(null);\n+    }\n+  }\n+\n+  @Test\n+  public void releaseClearLockLocalDoesNotReleaseLocksOnPrimaryBucketsWhenMemberIsNotCurrent() {\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    InternalDistributedMember member = mock(InternalDistributedMember.class);\n+\n+    partitionedRegionClear.obtainClearLockLocal(member);\n+\n+    assertThat(partitionedRegionClear.lockForListenerAndClientNotification.getLockRequester())\n+        .isNull();\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(0)).releaseLockLocallyForClear(null);\n+    }\n+  }\n+\n+  @Test\n+  public void sendPartitionedRegionClearMessageSendsClearMessageToPRNodes() {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(regionEvent.clone()).thenReturn(mock(RegionEventImpl.class));\n+    Region<String, PartitionRegionConfig> prRoot = mock(Region.class);\n+    when(partitionedRegion.getPRRoot()).thenReturn(prRoot);\n+    InternalDistributedMember member = mock(InternalDistributedMember.class);\n+    RegionAdvisor regionAdvisor = mock(RegionAdvisor.class);\n+    Set<InternalDistributedMember> prNodes = new HashSet<>();\n+    prNodes.add(member);\n+    Node node = mock(Node.class);\n+    when(node.getMemberId()).thenReturn(member);\n+    Set<Node> configNodes = new HashSet<>();\n+    configNodes.add(node);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bf63222b8acb0c12e38469a7c05819d2b8e2fd0"}, "originalPosition": 389}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNTkwNg==", "bodyText": "Good suggestion. Looks little tidy.", "url": "https://github.com/apache/geode/pull/5208#discussion_r436215906", "createdAt": "2020-06-06T00:34:02Z", "author": {"login": "agingade"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/PartitionedRegionClearTest.java", "diffHunk": "@@ -0,0 +1,598 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.catchThrowable;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.PartitionedRegionPartialClearException;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.distributed.internal.DMStats;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.MembershipListener;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.partitioned.RegionAdvisor;\n+import org.apache.geode.internal.cache.versions.RegionVersionVector;\n+\n+public class PartitionedRegionClearTest {\n+\n+\n+  private PartitionedRegionClear partitionedRegionClear;\n+  private DistributionManager distributionManager;\n+  private PartitionedRegion partitionedRegion;\n+\n+  @Before\n+  public void setUp() {\n+\n+    partitionedRegion = mock(PartitionedRegion.class);\n+    distributionManager = mock(DistributionManager.class);\n+\n+    when(partitionedRegion.getDistributionManager()).thenReturn(distributionManager);\n+    when(partitionedRegion.getName()).thenReturn(\"prRegion\");\n+\n+    partitionedRegionClear = new PartitionedRegionClear(partitionedRegion);\n+  }\n+\n+  private Set<BucketRegion> setupBucketRegions(\n+      PartitionedRegionDataStore partitionedRegionDataStore,\n+      BucketAdvisor bucketAdvisor) {\n+    final int numBuckets = 2;\n+    HashSet<BucketRegion> bucketRegions = new HashSet<>();\n+    for (int i = 0; i < numBuckets; i++) {\n+      BucketRegion bucketRegion = mock(BucketRegion.class);\n+      when(bucketRegion.getBucketAdvisor()).thenReturn(bucketAdvisor);\n+      when(bucketRegion.size()).thenReturn(1);\n+      when(bucketRegion.getId()).thenReturn(i);\n+      bucketRegions.add(bucketRegion);\n+    }\n+\n+    when(partitionedRegionDataStore.getAllLocalBucketRegions()).thenReturn(bucketRegions);\n+    when(partitionedRegionDataStore.getAllLocalPrimaryBucketRegions()).thenReturn(bucketRegions);\n+\n+    return bucketRegions;\n+  }\n+\n+  @Test\n+  public void isLockedForListenerAndClientNotificationReturnsTrueWhenLocked() {\n+    InternalDistributedMember internalDistributedMember = mock(InternalDistributedMember.class);\n+    when(distributionManager.isCurrentMember(internalDistributedMember)).thenReturn(true);\n+    partitionedRegionClear.obtainClearLockLocal(internalDistributedMember);\n+\n+    assertThat(partitionedRegionClear.isLockedForListenerAndClientNotification()).isTrue();\n+  }\n+\n+  @Test\n+  public void isLockedForListenerAndClientNotificationReturnsFalseWhenMemberNotInTheSystemRequestsLock() {\n+    InternalDistributedMember internalDistributedMember = mock(InternalDistributedMember.class);\n+    when(distributionManager.isCurrentMember(internalDistributedMember)).thenReturn(false);\n+\n+    assertThat(partitionedRegionClear.isLockedForListenerAndClientNotification()).isFalse();\n+  }\n+\n+  @Test\n+  public void acquireDistributedClearLockGetsDistributedLock() {\n+    DistributedLockService distributedLockService = mock(DistributedLockService.class);\n+    String lockName = PartitionedRegionClear.CLEAR_OPERATION + partitionedRegion.getName();\n+    when(partitionedRegion.getPartitionedRegionLockService()).thenReturn(distributedLockService);\n+\n+    partitionedRegionClear.acquireDistributedClearLock(lockName);\n+\n+    verify(distributedLockService, times(1)).lock(lockName, -1, -1);\n+  }\n+\n+  @Test\n+  public void releaseDistributedClearLockReleasesDistributedLock() {\n+    DistributedLockService distributedLockService = mock(DistributedLockService.class);\n+    String lockName = PartitionedRegionClear.CLEAR_OPERATION + partitionedRegion.getName();\n+    when(partitionedRegion.getPartitionedRegionLockService()).thenReturn(distributedLockService);\n+\n+    partitionedRegionClear.releaseDistributedClearLock(lockName);\n+\n+    verify(distributedLockService, times(1)).unlock(lockName);\n+  }\n+\n+  @Test\n+  public void obtainLockForClearGetsLocalLockAndSendsMessageForRemote() throws Exception {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(regionEvent.clone()).thenReturn(mock(RegionEventImpl.class));\n+    Region<String, PartitionRegionConfig> region = mock(Region.class);\n+    when(partitionedRegion.getPRRoot()).thenReturn(region);\n+    PartitionedRegionClear spyPartitionedRegionClear = spy(partitionedRegionClear);\n+    doReturn(Collections.EMPTY_LIST).when(spyPartitionedRegionClear)\n+        .attemptToSendPartitionedRegionClearMessage(regionEvent,\n+            PartitionedRegionClearMessage.OperationType.OP_LOCK_FOR_PR_CLEAR);\n+    InternalDistributedMember internalDistributedMember = mock(InternalDistributedMember.class);\n+    when(distributionManager.getId()).thenReturn(internalDistributedMember);\n+\n+    spyPartitionedRegionClear.obtainLockForClear(regionEvent);\n+\n+    verify(spyPartitionedRegionClear, times(1)).obtainClearLockLocal(internalDistributedMember);\n+    verify(spyPartitionedRegionClear, times(1)).sendPartitionedRegionClearMessage(regionEvent,\n+        PartitionedRegionClearMessage.OperationType.OP_LOCK_FOR_PR_CLEAR);\n+  }\n+\n+  @Test\n+  public void releaseLockForClearReleasesLocalLockAndSendsMessageForRemote() throws Exception {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(regionEvent.clone()).thenReturn(mock(RegionEventImpl.class));\n+    Region<String, PartitionRegionConfig> region = mock(Region.class);\n+    when(partitionedRegion.getPRRoot()).thenReturn(region);\n+    PartitionedRegionClear spyPartitionedRegionClear = spy(partitionedRegionClear);\n+    doReturn(Collections.EMPTY_LIST).when(spyPartitionedRegionClear)\n+        .attemptToSendPartitionedRegionClearMessage(regionEvent,\n+            PartitionedRegionClearMessage.OperationType.OP_UNLOCK_FOR_PR_CLEAR);\n+    InternalDistributedMember internalDistributedMember = mock(InternalDistributedMember.class);\n+    when(distributionManager.getId()).thenReturn(internalDistributedMember);\n+\n+    spyPartitionedRegionClear.releaseLockForClear(regionEvent);\n+\n+    verify(spyPartitionedRegionClear, times(1)).releaseClearLockLocal();\n+    verify(spyPartitionedRegionClear, times(1)).sendPartitionedRegionClearMessage(regionEvent,\n+        PartitionedRegionClearMessage.OperationType.OP_UNLOCK_FOR_PR_CLEAR);\n+  }\n+\n+  @Test\n+  public void clearRegionClearsLocalAndSendsMessageForRemote() throws Exception {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(regionEvent.clone()).thenReturn(mock(RegionEventImpl.class));\n+    Region<String, PartitionRegionConfig> region = mock(Region.class);\n+    when(partitionedRegion.getPRRoot()).thenReturn(region);\n+    PartitionedRegionClear spyPartitionedRegionClear = spy(partitionedRegionClear);\n+    doReturn(Collections.EMPTY_LIST).when(spyPartitionedRegionClear)\n+        .attemptToSendPartitionedRegionClearMessage(regionEvent,\n+            PartitionedRegionClearMessage.OperationType.OP_PR_CLEAR);\n+    InternalDistributedMember internalDistributedMember = mock(InternalDistributedMember.class);\n+    when(distributionManager.getId()).thenReturn(internalDistributedMember);\n+    RegionVersionVector regionVersionVector = mock(RegionVersionVector.class);\n+\n+    spyPartitionedRegionClear.clearRegion(regionEvent, false, regionVersionVector);\n+\n+    verify(spyPartitionedRegionClear, times(1)).clearRegionLocal(regionEvent);\n+    verify(spyPartitionedRegionClear, times(1)).sendPartitionedRegionClearMessage(regionEvent,\n+        PartitionedRegionClearMessage.OperationType.OP_PR_CLEAR);\n+  }\n+\n+  @Test\n+  public void waitForPrimaryReturnsAfterFindingAllPrimary() {\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    PartitionedRegion.RetryTimeKeeper retryTimer = mock(PartitionedRegion.RetryTimeKeeper.class);\n+\n+    partitionedRegionClear.waitForPrimary(retryTimer);\n+\n+    verify(retryTimer, times(0)).waitForBucketsRecovery();\n+  }\n+\n+  @Test\n+  public void waitForPrimaryReturnsAfterRetryForPrimary() {\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(false).thenReturn(true);\n+    setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    PartitionedRegion.RetryTimeKeeper retryTimer = mock(PartitionedRegion.RetryTimeKeeper.class);\n+\n+    partitionedRegionClear.waitForPrimary(retryTimer);\n+\n+    verify(retryTimer, times(1)).waitForBucketsRecovery();\n+  }\n+\n+  @Test\n+  public void waitForPrimaryThrowsPartitionedRegionPartialClearException() {\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    PartitionedRegion.RetryTimeKeeper retryTimer = mock(PartitionedRegion.RetryTimeKeeper.class);\n+    when(retryTimer.overMaximum()).thenReturn(true);\n+\n+    Throwable thrown = catchThrowable(() -> partitionedRegionClear.waitForPrimary(retryTimer));\n+\n+    assertThat(thrown)\n+        .isInstanceOf(PartitionedRegionPartialClearException.class)\n+        .hasMessage(\n+            \"Unable to find primary bucket region during clear operation for region: prRegion\");\n+    verify(retryTimer, times(0)).waitForBucketsRecovery();\n+  }\n+\n+  @Test\n+  public void clearRegionLocalCallsClearOnLocalPrimaryBucketRegions() {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    doNothing().when(partitionedRegionDataStore).lockBucketCreationForRegionClear();\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+\n+    List bucketsCleared = partitionedRegionClear.clearRegionLocal(regionEvent);\n+\n+    assertThat(bucketsCleared.size()).isEqualTo(buckets.size());\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(1)).clear();\n+    }\n+  }\n+\n+  @Test\n+  public void clearRegionLocalRetriesClearOnLocalPrimaryBucketRegions() {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    doNothing().when(partitionedRegionDataStore).lockBucketCreationForRegionClear();\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    PartitionedRegionClear spyPartitionedRegionClear = spy(partitionedRegionClear);\n+    when(spyPartitionedRegionClear.getMembershipChange()).thenReturn(true).thenReturn(false);\n+\n+    List bucketsCleared = spyPartitionedRegionClear.clearRegionLocal(regionEvent);\n+\n+    int expectedClears = buckets.size() * 2; /* clear is called twice on each bucket */\n+    assertThat(bucketsCleared.size()).isEqualTo(expectedClears);\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(2)).clear();\n+    }\n+  }\n+\n+  @Test\n+  public void doAfterClearCallsNotifyClientsWhenClientHaveInterests() {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(partitionedRegion.hasAnyClientsInterested()).thenReturn(true);\n+    FilterProfile filterProfile = mock(FilterProfile.class);\n+    FilterRoutingInfo filterRoutingInfo = mock(FilterRoutingInfo.class);\n+    when(filterProfile.getFilterRoutingInfoPart1(regionEvent, FilterProfile.NO_PROFILES,\n+        Collections.emptySet())).thenReturn(filterRoutingInfo);\n+    when(filterProfile.getFilterRoutingInfoPart2(filterRoutingInfo, regionEvent)).thenReturn(\n+        filterRoutingInfo);\n+    when(partitionedRegion.getFilterProfile()).thenReturn(filterProfile);\n+\n+    partitionedRegionClear.doAfterClear(regionEvent);\n+\n+    verify(regionEvent, times(1)).setLocalFilterInfo(any());\n+    verify(partitionedRegion, times(1)).notifyBridgeClients(regionEvent);\n+  }\n+\n+  @Test\n+  public void doAfterClearDispatchesListenerEvents() {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(partitionedRegion.hasListener()).thenReturn(true);\n+\n+    partitionedRegionClear.doAfterClear(regionEvent);\n+\n+    verify(partitionedRegion, times(1)).dispatchListenerEvent(\n+        EnumListenerEvent.AFTER_REGION_CLEAR, regionEvent);\n+  }\n+\n+  @Test\n+  public void obtainClearLockLocalGetsLockOnPrimaryBuckets() {\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    InternalDistributedMember member = mock(InternalDistributedMember.class);\n+    when(distributionManager.isCurrentMember(member)).thenReturn(true);\n+\n+    partitionedRegionClear.obtainClearLockLocal(member);\n+\n+    assertThat(partitionedRegionClear.lockForListenerAndClientNotification.getLockRequester())\n+        .isSameAs(member);\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(1)).lockLocallyForClear(partitionedRegion.getDistributionManager(),\n+          partitionedRegion.getMyId(), null);\n+    }\n+  }\n+\n+  @Test\n+  public void obtainClearLockLocalDoesNotGetLocksOnPrimaryBucketsWhenMemberIsNotCurrent() {\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    InternalDistributedMember member = mock(InternalDistributedMember.class);\n+    when(distributionManager.isCurrentMember(member)).thenReturn(false);\n+\n+    partitionedRegionClear.obtainClearLockLocal(member);\n+\n+    assertThat(partitionedRegionClear.lockForListenerAndClientNotification.getLockRequester())\n+        .isNull();\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(0)).lockLocallyForClear(partitionedRegion.getDistributionManager(),\n+          partitionedRegion.getMyId(), null);\n+    }\n+  }\n+\n+  @Test\n+  public void releaseClearLockLocalReleasesLockOnPrimaryBuckets() {\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    InternalDistributedMember member = mock(InternalDistributedMember.class);\n+    when(distributionManager.isCurrentMember(member)).thenReturn(true);\n+    partitionedRegionClear.lockForListenerAndClientNotification.setLocked(member);\n+\n+    partitionedRegionClear.releaseClearLockLocal();\n+\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(1)).releaseLockLocallyForClear(null);\n+    }\n+  }\n+\n+  @Test\n+  public void releaseClearLockLocalDoesNotReleaseLocksOnPrimaryBucketsWhenMemberIsNotCurrent() {\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    InternalDistributedMember member = mock(InternalDistributedMember.class);\n+\n+    partitionedRegionClear.obtainClearLockLocal(member);\n+\n+    assertThat(partitionedRegionClear.lockForListenerAndClientNotification.getLockRequester())\n+        .isNull();\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(0)).releaseLockLocallyForClear(null);\n+    }\n+  }\n+\n+  @Test\n+  public void sendPartitionedRegionClearMessageSendsClearMessageToPRNodes() {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(regionEvent.clone()).thenReturn(mock(RegionEventImpl.class));\n+    Region<String, PartitionRegionConfig> prRoot = mock(Region.class);\n+    when(partitionedRegion.getPRRoot()).thenReturn(prRoot);\n+    InternalDistributedMember member = mock(InternalDistributedMember.class);\n+    RegionAdvisor regionAdvisor = mock(RegionAdvisor.class);\n+    Set<InternalDistributedMember> prNodes = new HashSet<>();\n+    prNodes.add(member);\n+    Node node = mock(Node.class);\n+    when(node.getMemberId()).thenReturn(member);\n+    Set<Node> configNodes = new HashSet<>();\n+    configNodes.add(node);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxMDgzMw=="}, "originalCommit": {"oid": "7bf63222b8acb0c12e38469a7c05819d2b8e2fd0"}, "originalPosition": 389}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3960, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}