{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg2MzE4MzQw", "number": 5509, "title": "GEODE-8491: Do not store dropped events in stopped primary gateway se\u2026", "bodyText": "\u2026nder when possible\nInstead of storing dropped events in tmpDroppedEvents to later send batch\nremoval messages when the primary gateway sender is not started, try to send\nthe batch removal message when the event to be dropped is received.\nThat way, when the sender is stopped for a long time and there are events\ncoming, the memory of the AbstractGatewaySender will not grow with entries\nin the tmpDroppedEvents member.\nIn order to send the batch removal message directly, the eventProcessor for\nthe AbstractGatewaySender must have been created.\nIf it is not yet created because the sender was created with manual start\nset to true, while receiving events to be dropped, they will be stored in\ntmpDroppedEvents as there is no other choice. Nevertheless,\nin order to consume less memory, the event stored could be a simplified event\ncontaining only the necessary information to handle it.\nThank you for submitting a contribution to Apache Geode.\nIn order to streamline the review of the contribution we ask you\nto ensure the following steps have been taken:\nFor all changes:\n\n\n Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?\n\n\n Has your PR been rebased against the latest commit within the target branch (typically develop)?\n\n\n Is your initial contribution a single, squashed commit?\n\n\n Does gradlew build run cleanly?\n\n\n Have you written or updated unit tests to verify your changes?\n\n\n If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under ASF 2.0?\n\n\nNote:\nPlease ensure that once the PR is submitted, check Concourse for build issues and\nsubmit an update to your PR as soon as possible. If you need help, please send an\nemail to dev@geode.apache.org.", "createdAt": "2020-09-14T04:28:41Z", "url": "https://github.com/apache/geode/pull/5509", "merged": true, "mergeCommit": {"oid": "169ca6add2887c6560f30a5ad12ceb088411e973"}, "closed": true, "closedAt": "2020-09-29T06:07:41Z", "author": {"login": "albertogpz"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdIt_GogH2gAyNDg2MzE4MzQwOjZiNjc3YTYyZGExMWQ0NWYzYmQwMGEzODFmYzg1ZjQ1NzU2YjZiYjk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdNh4eMAFqTQ5ODEyMDIwNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "6b677a62da11d45f3bd00a381fc85f45756b6bb9", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/6b677a62da11d45f3bd00a381fc85f45756b6bb9", "committedDate": "2020-09-14T07:23:17Z", "message": "GEODE-8491: Do not store dropped events in stopped primary gateway sender when possible\n\nInstead of storing dropped events in tmpDroppedEvents to later send batch\nremoval messages when the primary gateway sender is not started, try to send\nthe batch removal message when the event to be dropped is received.\nThat way, when the sender is stopped for a long time and there are events\ncoming, the memory of the AbstractGatewaySender will not grow with entries\nin the tmpDroppedEvents member.\n\nIn order to send the batch removal message directly, the eventProcessor for\nthe AbstractGatewaySender must have been created.\nIf it is not yet created because the sender was created with manual start\nset to true, while receiving events to be dropped, they will be stored in\ntmpDroppedEvents as there is no other choice. Nevertheless,\nin order to consume less memory, the event stored could be a simplified event\ncontaining only the necessary information to handle it."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c5aef5755e3a22f4566068402600085add7e7767", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/c5aef5755e3a22f4566068402600085add7e7767", "committedDate": "2020-09-14T04:23:45Z", "message": "GEODE-8491: Do not store dropped events in stopped primary gateway sender when possible\n\nInstead of storing dropped events in tmpDroppedEvents to later send batch\nremoval messages when the primary gateway sender is not started, try to send\nthe batch removal message when the event to be dropped is received.\nThat way, when the sender is stopped for a long time and there are events\ncoming, the memory of the AbstractGatewaySender will not grow with entries\nin the tmpDroppedEvents member.\n\nIn order to send the batch removal message directly, the eventProcessor for\nthe AbstractGatewaySender must have been created.\nIf it is not yet created because the sender was created with manual start\nset to true, while receiving events to be dropped, they will be stored in\ntmpDroppedEvents as there is no other choice. Nevertheless,\nin order to consume less memory, the event stored could be a simplified event\ncontaining only the necessary information to handle it."}, "afterCommit": {"oid": "6b677a62da11d45f3bd00a381fc85f45756b6bb9", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/6b677a62da11d45f3bd00a381fc85f45756b6bb9", "committedDate": "2020-09-14T07:23:17Z", "message": "GEODE-8491: Do not store dropped events in stopped primary gateway sender when possible\n\nInstead of storing dropped events in tmpDroppedEvents to later send batch\nremoval messages when the primary gateway sender is not started, try to send\nthe batch removal message when the event to be dropped is received.\nThat way, when the sender is stopped for a long time and there are events\ncoming, the memory of the AbstractGatewaySender will not grow with entries\nin the tmpDroppedEvents member.\n\nIn order to send the batch removal message directly, the eventProcessor for\nthe AbstractGatewaySender must have been created.\nIf it is not yet created because the sender was created with manual start\nset to true, while receiving events to be dropped, they will be stored in\ntmpDroppedEvents as there is no other choice. Nevertheless,\nin order to consume less memory, the event stored could be a simplified event\ncontaining only the necessary information to handle it."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3OTExODY5", "url": "https://github.com/apache/geode/pull/5509#pullrequestreview-487911869", "createdAt": "2020-09-14T15:49:10Z", "commit": {"oid": "6b677a62da11d45f3bd00a381fc85f45756b6bb9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNTo0OToxMFrOHRbjng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNTo0OToxMFrOHRbjng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAzOTMyNg==", "bodyText": "Again, don't clone a new event. In the new code change, the \"else\" will only be executed in very very small time windows.\nYou have proved that when the sender is shutdown, the eventProcessor will be kept. So enqueue will not go to the \"else\". We will never worry about the tmpDroppedEvents become too big.", "url": "https://github.com/apache/geode/pull/5509#discussion_r488039326", "createdAt": "2020-09-14T15:49:10Z", "author": {"login": "gesterzhou"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/AbstractGatewaySender.java", "diffHunk": "@@ -1118,6 +1115,24 @@ public void distribute(EnumListenerEvent operation, EntryEventImpl event,\n     }\n   }\n \n+  private void recordDroppedEvent(EntryEventImpl event) {\n+    final boolean isDebugEnabled = logger.isDebugEnabled();\n+    if (this.eventProcessor != null) {\n+      this.eventProcessor.registerEventDroppedInPrimaryQueue(event);\n+    } else {\n+      // Add empty event so that in case the event stays for long in\n+      // tmpDroppedEvents it takes as little space as possible.\n+      // No need to have all the contents of the event for a dropped one.\n+      EntryEventImpl emptyEvent = new EntryEventImpl(event.getKey(), false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b677a62da11d45f3bd00a381fc85f45756b6bb9"}, "originalPosition": 24}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fcc1967afb0469d8c6fd38492c9de9ec71fff627", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/fcc1967afb0469d8c6fd38492c9de9ec71fff627", "committedDate": "2020-09-14T16:02:08Z", "message": "GEODE-8491: Remove cloning of dropped event before putting it in tmpDroppedEvents"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4MDI4MDI3", "url": "https://github.com/apache/geode/pull/5509#pullrequestreview-488028027", "createdAt": "2020-09-14T18:17:05Z", "commit": {"oid": "fcc1967afb0469d8c6fd38492c9de9ec71fff627"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxODoxNzowNVrOHRhJGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxODo1NjoyN1rOHRid5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEzMDg0MA==", "bodyText": "The IDE warnings here can be resolved by using List<AsyncInvocation<Void>>.", "url": "https://github.com/apache/geode/pull/5509#discussion_r488130840", "createdAt": "2020-09-14T18:17:05Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -1646,6 +1646,20 @@ public static void resumeSender(String senderId) {\n     }\n   }\n \n+  public static void stopSenderInVMsAsync(String senderId, VM... vms) {\n+    List<AsyncInvocation> tasks = new LinkedList<>();\n+    for (VM vm : vms) {\n+      tasks.add(vm.invokeAsync(() -> stopSender(senderId)));\n+    }\n+    for (AsyncInvocation invocation : tasks) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc1967afb0469d8c6fd38492c9de9ec71fff627"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEzNDg4Nw==", "bodyText": "The IDE warning here can be resolved by using List<AsyncInvocation<Void>>.", "url": "https://github.com/apache/geode/pull/5509#discussion_r488134887", "createdAt": "2020-09-14T18:24:18Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANPropagationLoopBackDUnitTest.java", "diffHunk": "@@ -370,69 +371,312 @@ public void testParallelPropagationLoopBack3SitesNtoNTopologyPutFromOneDS() {\n    */\n   @Test\n   public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() throws Exception {\n-    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n-    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n \n     // create receiver on site-ln and site-ny\n     createCacheInVMs(lnPort, vm2, vm4);\n     createReceiverInVMs(vm2, vm4);\n     createCacheInVMs(nyPort, vm3, vm5);\n     createReceiverInVMs(vm3, vm5);\n \n-    // create senders on site-ln, Note: sender-id is its destination, i.e. ny\n+    // create senders on site-ny, Note: sender-id is its destination, i.e. ny\n     vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n     vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n \n-    // create senders on site-ny, Note: sender-id is its destination, i.e. ln\n+    // create senders on site-ln, Note: sender-id is its destination, i.e. ln\n     vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n     vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n \n-    // create PR on site-ln\n+    // create PR on site-ny\n     vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n         isOffHeap()));\n     vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n         isOffHeap()));\n \n-    // create PR on site-ny\n+    // create PR on site-ln\n     vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n         isOffHeap()));\n     vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n         isOffHeap()));\n \n-    // start sender on site-ln\n+    // start sender on site-ny\n     startSenderInVMs(\"ny\", vm2, vm4);\n-    // Do 100 puts on site-ln\n-    vm2.invoke(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 100));\n \n-    // verify site-ny received the 100 events\n+    // do 100 puts on site-ln\n+    vm3.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 0, 100));\n+\n+    // verify site-ny have 100 entries\n     vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n     vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n \n-    // verify tmpDroppedEvents should be 0 at site-ny\n-    vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n-    vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n-\n-    // do next 100 puts on site-ny\n-    vm3.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 100, 200));\n-\n-    // verify site-ny have 200 entries\n-    vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 200));\n-    vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 200));\n-\n-    // verify tmpDroppedEvents should be 100 at site-ny, because the sender is not started yet\n+    // verify tmpDroppedEvents should be 100 at site-ln, because the sender is not started yet\n     vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 100));\n     vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 100));\n \n     // verify site-ln has not received the events from site-ny yet\n-    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n-    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n \n-    // start sender on site-ny\n+    // start sender on site-ln\n     startSenderInVMsAsync(\"ln\", vm3, vm5);\n \n     // verify tmpDroppedEvents should be 0 now at site-ny\n     vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n     vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n+\n+    vm3.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+    vm5.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+  }\n+\n+  /**\n+   * Test that gateway sender's secondary queues do not keep dropped events\n+   * by the primary gateway sender received while it was starting but was not\n+   * started yet, after the primary finishes starting.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=true\n+   * LN site's sender's manual-start=true\n+   *\n+   * put some events from LN and start the sender in NY simultaneously\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void startedSenderReceivingEventsWhileStartingShouldDrainQueues()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    AsyncInvocation inv =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc1967afb0469d8c6fd38492c9de9ec71fff627"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEzNTA4Ng==", "bodyText": "The IDE warning here can be resolved by using List<AsyncInvocation<Void>>.", "url": "https://github.com/apache/geode/pull/5509#discussion_r488135086", "createdAt": "2020-09-14T18:24:42Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANPropagationLoopBackDUnitTest.java", "diffHunk": "@@ -370,69 +371,312 @@ public void testParallelPropagationLoopBack3SitesNtoNTopologyPutFromOneDS() {\n    */\n   @Test\n   public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() throws Exception {\n-    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n-    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n \n     // create receiver on site-ln and site-ny\n     createCacheInVMs(lnPort, vm2, vm4);\n     createReceiverInVMs(vm2, vm4);\n     createCacheInVMs(nyPort, vm3, vm5);\n     createReceiverInVMs(vm3, vm5);\n \n-    // create senders on site-ln, Note: sender-id is its destination, i.e. ny\n+    // create senders on site-ny, Note: sender-id is its destination, i.e. ny\n     vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n     vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n \n-    // create senders on site-ny, Note: sender-id is its destination, i.e. ln\n+    // create senders on site-ln, Note: sender-id is its destination, i.e. ln\n     vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n     vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n \n-    // create PR on site-ln\n+    // create PR on site-ny\n     vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n         isOffHeap()));\n     vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n         isOffHeap()));\n \n-    // create PR on site-ny\n+    // create PR on site-ln\n     vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n         isOffHeap()));\n     vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n         isOffHeap()));\n \n-    // start sender on site-ln\n+    // start sender on site-ny\n     startSenderInVMs(\"ny\", vm2, vm4);\n-    // Do 100 puts on site-ln\n-    vm2.invoke(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 100));\n \n-    // verify site-ny received the 100 events\n+    // do 100 puts on site-ln\n+    vm3.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 0, 100));\n+\n+    // verify site-ny have 100 entries\n     vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n     vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n \n-    // verify tmpDroppedEvents should be 0 at site-ny\n-    vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n-    vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n-\n-    // do next 100 puts on site-ny\n-    vm3.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 100, 200));\n-\n-    // verify site-ny have 200 entries\n-    vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 200));\n-    vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 200));\n-\n-    // verify tmpDroppedEvents should be 100 at site-ny, because the sender is not started yet\n+    // verify tmpDroppedEvents should be 100 at site-ln, because the sender is not started yet\n     vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 100));\n     vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 100));\n \n     // verify site-ln has not received the events from site-ny yet\n-    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n-    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n \n-    // start sender on site-ny\n+    // start sender on site-ln\n     startSenderInVMsAsync(\"ln\", vm3, vm5);\n \n     // verify tmpDroppedEvents should be 0 now at site-ny\n     vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n     vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n+\n+    vm3.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+    vm5.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+  }\n+\n+  /**\n+   * Test that gateway sender's secondary queues do not keep dropped events\n+   * by the primary gateway sender received while it was starting but was not\n+   * started yet, after the primary finishes starting.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=true\n+   * LN site's sender's manual-start=true\n+   *\n+   * put some events from LN and start the sender in NY simultaneously\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void startedSenderReceivingEventsWhileStartingShouldDrainQueues()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    AsyncInvocation inv =\n+        vm2.invokeAsync(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 1000));\n+    startSenderInVMsAsync(\"ny\", vm2, vm4);\n+    inv.join();\n+\n+    vm2.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+    vm4.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+\n+    vm2.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+    vm4.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n   }\n \n+  /**\n+   * Test that gateway sender's secondary queues do not keep dropped events\n+   * by the primary gateway sender received while it was stopping after it is started again.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=false\n+   * LN site's sender's manual-start=false\n+   *\n+   * put some events from LN and stop the sender in NY simultaneously\n+   * Start the sender in NY.\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void startedSenderReceivingEventsWhileStoppingShouldDrainQueues()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, false));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, false));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, false));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, false));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    AsyncInvocation inv =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc1967afb0469d8c6fd38492c9de9ec71fff627"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE0MDI2Nw==", "bodyText": "The AsyncInvocation.join() method is deprecated. It should be replaced with AsyncInvocation.await().", "url": "https://github.com/apache/geode/pull/5509#discussion_r488140267", "createdAt": "2020-09-14T18:34:10Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANPropagationLoopBackDUnitTest.java", "diffHunk": "@@ -370,69 +371,312 @@ public void testParallelPropagationLoopBack3SitesNtoNTopologyPutFromOneDS() {\n    */\n   @Test\n   public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() throws Exception {\n-    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n-    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n \n     // create receiver on site-ln and site-ny\n     createCacheInVMs(lnPort, vm2, vm4);\n     createReceiverInVMs(vm2, vm4);\n     createCacheInVMs(nyPort, vm3, vm5);\n     createReceiverInVMs(vm3, vm5);\n \n-    // create senders on site-ln, Note: sender-id is its destination, i.e. ny\n+    // create senders on site-ny, Note: sender-id is its destination, i.e. ny\n     vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n     vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n \n-    // create senders on site-ny, Note: sender-id is its destination, i.e. ln\n+    // create senders on site-ln, Note: sender-id is its destination, i.e. ln\n     vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n     vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n \n-    // create PR on site-ln\n+    // create PR on site-ny\n     vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n         isOffHeap()));\n     vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n         isOffHeap()));\n \n-    // create PR on site-ny\n+    // create PR on site-ln\n     vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n         isOffHeap()));\n     vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n         isOffHeap()));\n \n-    // start sender on site-ln\n+    // start sender on site-ny\n     startSenderInVMs(\"ny\", vm2, vm4);\n-    // Do 100 puts on site-ln\n-    vm2.invoke(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 100));\n \n-    // verify site-ny received the 100 events\n+    // do 100 puts on site-ln\n+    vm3.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 0, 100));\n+\n+    // verify site-ny have 100 entries\n     vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n     vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n \n-    // verify tmpDroppedEvents should be 0 at site-ny\n-    vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n-    vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n-\n-    // do next 100 puts on site-ny\n-    vm3.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 100, 200));\n-\n-    // verify site-ny have 200 entries\n-    vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 200));\n-    vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 200));\n-\n-    // verify tmpDroppedEvents should be 100 at site-ny, because the sender is not started yet\n+    // verify tmpDroppedEvents should be 100 at site-ln, because the sender is not started yet\n     vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 100));\n     vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 100));\n \n     // verify site-ln has not received the events from site-ny yet\n-    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n-    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n \n-    // start sender on site-ny\n+    // start sender on site-ln\n     startSenderInVMsAsync(\"ln\", vm3, vm5);\n \n     // verify tmpDroppedEvents should be 0 now at site-ny\n     vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n     vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n+\n+    vm3.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+    vm5.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+  }\n+\n+  /**\n+   * Test that gateway sender's secondary queues do not keep dropped events\n+   * by the primary gateway sender received while it was starting but was not\n+   * started yet, after the primary finishes starting.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=true\n+   * LN site's sender's manual-start=true\n+   *\n+   * put some events from LN and start the sender in NY simultaneously\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void startedSenderReceivingEventsWhileStartingShouldDrainQueues()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    AsyncInvocation inv =\n+        vm2.invokeAsync(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 1000));\n+    startSenderInVMsAsync(\"ny\", vm2, vm4);\n+    inv.join();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc1967afb0469d8c6fd38492c9de9ec71fff627"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE0MTM5Mg==", "bodyText": "The AsyncInvocation.join() method is deprecated. It should be replaced with AsyncInvocation.await().", "url": "https://github.com/apache/geode/pull/5509#discussion_r488141392", "createdAt": "2020-09-14T18:36:05Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANPropagationLoopBackDUnitTest.java", "diffHunk": "@@ -370,69 +371,312 @@ public void testParallelPropagationLoopBack3SitesNtoNTopologyPutFromOneDS() {\n    */\n   @Test\n   public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() throws Exception {\n-    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n-    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n \n     // create receiver on site-ln and site-ny\n     createCacheInVMs(lnPort, vm2, vm4);\n     createReceiverInVMs(vm2, vm4);\n     createCacheInVMs(nyPort, vm3, vm5);\n     createReceiverInVMs(vm3, vm5);\n \n-    // create senders on site-ln, Note: sender-id is its destination, i.e. ny\n+    // create senders on site-ny, Note: sender-id is its destination, i.e. ny\n     vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n     vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n \n-    // create senders on site-ny, Note: sender-id is its destination, i.e. ln\n+    // create senders on site-ln, Note: sender-id is its destination, i.e. ln\n     vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n     vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n \n-    // create PR on site-ln\n+    // create PR on site-ny\n     vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n         isOffHeap()));\n     vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n         isOffHeap()));\n \n-    // create PR on site-ny\n+    // create PR on site-ln\n     vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n         isOffHeap()));\n     vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n         isOffHeap()));\n \n-    // start sender on site-ln\n+    // start sender on site-ny\n     startSenderInVMs(\"ny\", vm2, vm4);\n-    // Do 100 puts on site-ln\n-    vm2.invoke(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 100));\n \n-    // verify site-ny received the 100 events\n+    // do 100 puts on site-ln\n+    vm3.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 0, 100));\n+\n+    // verify site-ny have 100 entries\n     vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n     vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n \n-    // verify tmpDroppedEvents should be 0 at site-ny\n-    vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n-    vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n-\n-    // do next 100 puts on site-ny\n-    vm3.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 100, 200));\n-\n-    // verify site-ny have 200 entries\n-    vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 200));\n-    vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 200));\n-\n-    // verify tmpDroppedEvents should be 100 at site-ny, because the sender is not started yet\n+    // verify tmpDroppedEvents should be 100 at site-ln, because the sender is not started yet\n     vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 100));\n     vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 100));\n \n     // verify site-ln has not received the events from site-ny yet\n-    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n-    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n \n-    // start sender on site-ny\n+    // start sender on site-ln\n     startSenderInVMsAsync(\"ln\", vm3, vm5);\n \n     // verify tmpDroppedEvents should be 0 now at site-ny\n     vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n     vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n+\n+    vm3.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+    vm5.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+  }\n+\n+  /**\n+   * Test that gateway sender's secondary queues do not keep dropped events\n+   * by the primary gateway sender received while it was starting but was not\n+   * started yet, after the primary finishes starting.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=true\n+   * LN site's sender's manual-start=true\n+   *\n+   * put some events from LN and start the sender in NY simultaneously\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void startedSenderReceivingEventsWhileStartingShouldDrainQueues()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    AsyncInvocation inv =\n+        vm2.invokeAsync(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 1000));\n+    startSenderInVMsAsync(\"ny\", vm2, vm4);\n+    inv.join();\n+\n+    vm2.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+    vm4.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+\n+    vm2.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+    vm4.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n   }\n \n+  /**\n+   * Test that gateway sender's secondary queues do not keep dropped events\n+   * by the primary gateway sender received while it was stopping after it is started again.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=false\n+   * LN site's sender's manual-start=false\n+   *\n+   * put some events from LN and stop the sender in NY simultaneously\n+   * Start the sender in NY.\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void startedSenderReceivingEventsWhileStoppingShouldDrainQueues()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, false));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, false));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, false));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, false));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    AsyncInvocation inv =\n+        vm2.invokeAsync(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 1000));\n+    stopSenderInVMsAsync(\"ny\", vm2, vm4);\n+    inv.join();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc1967afb0469d8c6fd38492c9de9ec71fff627"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE0MTY3MQ==", "bodyText": "An exception is never thrown from this method, so this can be removed.", "url": "https://github.com/apache/geode/pull/5509#discussion_r488141671", "createdAt": "2020-09-14T18:36:35Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANPropagationLoopBackDUnitTest.java", "diffHunk": "@@ -370,69 +371,312 @@ public void testParallelPropagationLoopBack3SitesNtoNTopologyPutFromOneDS() {\n    */\n   @Test\n   public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() throws Exception {\n-    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n-    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n \n     // create receiver on site-ln and site-ny\n     createCacheInVMs(lnPort, vm2, vm4);\n     createReceiverInVMs(vm2, vm4);\n     createCacheInVMs(nyPort, vm3, vm5);\n     createReceiverInVMs(vm3, vm5);\n \n-    // create senders on site-ln, Note: sender-id is its destination, i.e. ny\n+    // create senders on site-ny, Note: sender-id is its destination, i.e. ny\n     vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n     vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n \n-    // create senders on site-ny, Note: sender-id is its destination, i.e. ln\n+    // create senders on site-ln, Note: sender-id is its destination, i.e. ln\n     vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n     vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n \n-    // create PR on site-ln\n+    // create PR on site-ny\n     vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n         isOffHeap()));\n     vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n         isOffHeap()));\n \n-    // create PR on site-ny\n+    // create PR on site-ln\n     vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n         isOffHeap()));\n     vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n         isOffHeap()));\n \n-    // start sender on site-ln\n+    // start sender on site-ny\n     startSenderInVMs(\"ny\", vm2, vm4);\n-    // Do 100 puts on site-ln\n-    vm2.invoke(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 100));\n \n-    // verify site-ny received the 100 events\n+    // do 100 puts on site-ln\n+    vm3.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 0, 100));\n+\n+    // verify site-ny have 100 entries\n     vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n     vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n \n-    // verify tmpDroppedEvents should be 0 at site-ny\n-    vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n-    vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n-\n-    // do next 100 puts on site-ny\n-    vm3.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 100, 200));\n-\n-    // verify site-ny have 200 entries\n-    vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 200));\n-    vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 200));\n-\n-    // verify tmpDroppedEvents should be 100 at site-ny, because the sender is not started yet\n+    // verify tmpDroppedEvents should be 100 at site-ln, because the sender is not started yet\n     vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 100));\n     vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 100));\n \n     // verify site-ln has not received the events from site-ny yet\n-    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n-    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n \n-    // start sender on site-ny\n+    // start sender on site-ln\n     startSenderInVMsAsync(\"ln\", vm3, vm5);\n \n     // verify tmpDroppedEvents should be 0 now at site-ny\n     vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n     vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n+\n+    vm3.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+    vm5.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+  }\n+\n+  /**\n+   * Test that gateway sender's secondary queues do not keep dropped events\n+   * by the primary gateway sender received while it was starting but was not\n+   * started yet, after the primary finishes starting.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=true\n+   * LN site's sender's manual-start=true\n+   *\n+   * put some events from LN and start the sender in NY simultaneously\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void startedSenderReceivingEventsWhileStartingShouldDrainQueues()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    AsyncInvocation inv =\n+        vm2.invokeAsync(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 1000));\n+    startSenderInVMsAsync(\"ny\", vm2, vm4);\n+    inv.join();\n+\n+    vm2.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+    vm4.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+\n+    vm2.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+    vm4.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n   }\n \n+  /**\n+   * Test that gateway sender's secondary queues do not keep dropped events\n+   * by the primary gateway sender received while it was stopping after it is started again.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=false\n+   * LN site's sender's manual-start=false\n+   *\n+   * put some events from LN and stop the sender in NY simultaneously\n+   * Start the sender in NY.\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void startedSenderReceivingEventsWhileStoppingShouldDrainQueues()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, false));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, false));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, false));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, false));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    AsyncInvocation inv =\n+        vm2.invokeAsync(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 1000));\n+    stopSenderInVMsAsync(\"ny\", vm2, vm4);\n+    inv.join();\n+\n+    startSenderInVMsAsync(\"ny\", vm2, vm4);\n+\n+    vm2.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+    vm4.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+\n+    vm2.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+    vm4.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+  }\n+\n+  /**\n+   * Test that a stopped gateway sender receiving events\n+   * does not store them in tmpDroppedEvents but after started\n+   * does not leave any event in the\n+   * gateway sender's secondary queues.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=false\n+   * LN site's sender's manual-start=false\n+   *\n+   * put some events from LN and stop the sender in NY simultaneously\n+   * Start the sender in NY.\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void stoppedSenderShouldNotAddEventsToTmpDroppedEventsButStillDrainQueuesWhenStarted()\n+      throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc1967afb0469d8c6fd38492c9de9ec71fff627"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE0MjEwMw==", "bodyText": "An exception is never thrown from this method, so this can be removed.", "url": "https://github.com/apache/geode/pull/5509#discussion_r488142103", "createdAt": "2020-09-14T18:37:26Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANPropagationLoopBackDUnitTest.java", "diffHunk": "@@ -370,69 +371,312 @@ public void testParallelPropagationLoopBack3SitesNtoNTopologyPutFromOneDS() {\n    */\n   @Test\n   public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() throws Exception {\n-    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n-    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n \n     // create receiver on site-ln and site-ny\n     createCacheInVMs(lnPort, vm2, vm4);\n     createReceiverInVMs(vm2, vm4);\n     createCacheInVMs(nyPort, vm3, vm5);\n     createReceiverInVMs(vm3, vm5);\n \n-    // create senders on site-ln, Note: sender-id is its destination, i.e. ny\n+    // create senders on site-ny, Note: sender-id is its destination, i.e. ny\n     vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n     vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n \n-    // create senders on site-ny, Note: sender-id is its destination, i.e. ln\n+    // create senders on site-ln, Note: sender-id is its destination, i.e. ln\n     vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n     vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n \n-    // create PR on site-ln\n+    // create PR on site-ny\n     vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n         isOffHeap()));\n     vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n         isOffHeap()));\n \n-    // create PR on site-ny\n+    // create PR on site-ln\n     vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n         isOffHeap()));\n     vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n         isOffHeap()));\n \n-    // start sender on site-ln\n+    // start sender on site-ny\n     startSenderInVMs(\"ny\", vm2, vm4);\n-    // Do 100 puts on site-ln\n-    vm2.invoke(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 100));\n \n-    // verify site-ny received the 100 events\n+    // do 100 puts on site-ln\n+    vm3.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 0, 100));\n+\n+    // verify site-ny have 100 entries\n     vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n     vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n \n-    // verify tmpDroppedEvents should be 0 at site-ny\n-    vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n-    vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n-\n-    // do next 100 puts on site-ny\n-    vm3.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 100, 200));\n-\n-    // verify site-ny have 200 entries\n-    vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 200));\n-    vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 200));\n-\n-    // verify tmpDroppedEvents should be 100 at site-ny, because the sender is not started yet\n+    // verify tmpDroppedEvents should be 100 at site-ln, because the sender is not started yet\n     vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 100));\n     vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 100));\n \n     // verify site-ln has not received the events from site-ny yet\n-    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n-    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n \n-    // start sender on site-ny\n+    // start sender on site-ln\n     startSenderInVMsAsync(\"ln\", vm3, vm5);\n \n     // verify tmpDroppedEvents should be 0 now at site-ny\n     vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n     vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n+\n+    vm3.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+    vm5.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+  }\n+\n+  /**\n+   * Test that gateway sender's secondary queues do not keep dropped events\n+   * by the primary gateway sender received while it was starting but was not\n+   * started yet, after the primary finishes starting.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=true\n+   * LN site's sender's manual-start=true\n+   *\n+   * put some events from LN and start the sender in NY simultaneously\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void startedSenderReceivingEventsWhileStartingShouldDrainQueues()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, true));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, true));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    AsyncInvocation inv =\n+        vm2.invokeAsync(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 1000));\n+    startSenderInVMsAsync(\"ny\", vm2, vm4);\n+    inv.join();\n+\n+    vm2.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+    vm4.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+\n+    vm2.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+    vm4.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n   }\n \n+  /**\n+   * Test that gateway sender's secondary queues do not keep dropped events\n+   * by the primary gateway sender received while it was stopping after it is started again.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=false\n+   * LN site's sender's manual-start=false\n+   *\n+   * put some events from LN and stop the sender in NY simultaneously\n+   * Start the sender in NY.\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void startedSenderReceivingEventsWhileStoppingShouldDrainQueues()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, false));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, false));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, false));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, false));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    AsyncInvocation inv =\n+        vm2.invokeAsync(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 1000));\n+    stopSenderInVMsAsync(\"ny\", vm2, vm4);\n+    inv.join();\n+\n+    startSenderInVMsAsync(\"ny\", vm2, vm4);\n+\n+    vm2.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+    vm4.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+\n+    vm2.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+    vm4.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+  }\n+\n+  /**\n+   * Test that a stopped gateway sender receiving events\n+   * does not store them in tmpDroppedEvents but after started\n+   * does not leave any event in the\n+   * gateway sender's secondary queues.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=false\n+   * LN site's sender's manual-start=false\n+   *\n+   * put some events from LN and stop the sender in NY simultaneously\n+   * Start the sender in NY.\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void stoppedSenderShouldNotAddEventsToTmpDroppedEventsButStillDrainQueuesWhenStarted()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, false));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, true, 100, 10, false, false, null, false));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, false));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, true, 100, 10, false, false, null, false));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    stopSenderInVMsAsync(\"ny\", vm2, vm4);\n+\n+    vm2.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 0, 100));\n+\n+    // verify tmpDroppedEvents is 0 at site-ny\n+    vm2.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+    vm4.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+\n+    vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+    vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+\n+\n+    startSenderInVMsAsync(\"ny\", vm2, vm4);\n+\n+    vm2.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 100, 1000));\n+\n+    vm2.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+    vm4.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 1000));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 1000));\n+\n+    vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 900));\n+    vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 900));\n+\n+    // verify the secondary's queues are drained at site-ny\n+    vm2.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+    vm4.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+  }\n+\n+  /**\n+   * Test that a stopped primary gateway sender receiving events\n+   * does not store them in tmpDroppedEvents but after started\n+   * does not leave any event in the\n+   * gateway sender's secondary queues.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=false\n+   * LN site's sender's manual-start=false\n+   *\n+   * put some events from LN and stop one instance of the sender in NY simultaneously\n+   * Start the stopped instance of the sender in NY.\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void stoppedPrimarySenderShouldNotAddEventsToTmpDroppedEventsButStillDrainQueuesWhenStarted()\n+      throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc1967afb0469d8c6fd38492c9de9ec71fff627"}, "originalPosition": 289}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE0NTc0MQ==", "bodyText": "An exception is never thrown from this method, so this \"throws\" can be removed.", "url": "https://github.com/apache/geode/pull/5509#discussion_r488145741", "createdAt": "2020-09-14T18:44:10Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java", "diffHunk": "@@ -297,4 +298,322 @@ public void testReplicatedSerialPropagationWithFilter_AfterAck() throws Exceptio\n     vm4.invoke(() -> WANTestBase.waitForConcurrentSerialSenderQueueToDrain(\"ln\"));\n     vm5.invoke(() -> WANTestBase.waitForConcurrentSerialSenderQueueToDrain(\"ln\"));\n   }\n+\n+  /**\n+   * Test unstarted sender\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=true\n+   *\n+   * Make sure the events are sent from LN to NY and will not be added into tmpDroppedEvents\n+   * while normal events put from NY site can still be added to tmpDroppedEvents\n+   * Start the sender, make sure the events in tmpDroppedEvents are sent to LN finally\n+   */\n+  @Test\n+  public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc1967afb0469d8c6fd38492c9de9ec71fff627"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE0NzA4Ng==", "bodyText": "The IDE warning here can be resolved by using List<AsyncInvocation<Void>>.", "url": "https://github.com/apache/geode/pull/5509#discussion_r488147086", "createdAt": "2020-09-14T18:46:39Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java", "diffHunk": "@@ -297,4 +298,322 @@ public void testReplicatedSerialPropagationWithFilter_AfterAck() throws Exceptio\n     vm4.invoke(() -> WANTestBase.waitForConcurrentSerialSenderQueueToDrain(\"ln\"));\n     vm5.invoke(() -> WANTestBase.waitForConcurrentSerialSenderQueueToDrain(\"ln\"));\n   }\n+\n+  /**\n+   * Test unstarted sender\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=true\n+   *\n+   * Make sure the events are sent from LN to NY and will not be added into tmpDroppedEvents\n+   * while normal events put from NY site can still be added to tmpDroppedEvents\n+   * Start the sender, make sure the events in tmpDroppedEvents are sent to LN finally\n+   */\n+  @Test\n+  public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    // create receiver on site-ln and site-ny\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    // create senders on site-ny, Note: sender-id is its destination, i.e. ny\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+\n+    // create senders on site-ln, Note: sender-id is its destination, i.e. ln\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+\n+    // create PR on site-ny\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    // create PR on site-ln\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    // start sender on site-ny\n+    startSenderInVMs(\"ny\", vm2, vm4);\n+\n+    // do 100 puts on site-ln\n+    vm3.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 0, 100));\n+\n+    // verify site-ny have 100 entries\n+    vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+    vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+\n+    // verify site-ln has not received the events from site-ny yet\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+\n+    // start sender on site-ln\n+    startSenderInVMsAsync(\"ln\", vm3, vm5);\n+\n+    // verify tmpDroppedEvents should be 0 now at site-ny\n+    vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n+    vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n+\n+    vm3.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+    vm5.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+  }\n+\n+  /**\n+   * Test that gateway sender's secondary queues do not keep dropped events\n+   * by the primary gateway sender received while it was starting but was not\n+   * started yet, after the primary finishes starting.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=true\n+   * LN site's sender's manual-start=true\n+   *\n+   * put some events from LN and start the sender in NY simultaneously\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void startedSenderReceivingEventsWhileStartingShouldDrainQueues()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    AsyncInvocation inv =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc1967afb0469d8c6fd38492c9de9ec71fff627"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE0NzEwNw==", "bodyText": "The AsyncInvocation.join() method is deprecated. It should be replaced with AsyncInvocation.await().", "url": "https://github.com/apache/geode/pull/5509#discussion_r488147107", "createdAt": "2020-09-14T18:46:41Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java", "diffHunk": "@@ -297,4 +298,322 @@ public void testReplicatedSerialPropagationWithFilter_AfterAck() throws Exceptio\n     vm4.invoke(() -> WANTestBase.waitForConcurrentSerialSenderQueueToDrain(\"ln\"));\n     vm5.invoke(() -> WANTestBase.waitForConcurrentSerialSenderQueueToDrain(\"ln\"));\n   }\n+\n+  /**\n+   * Test unstarted sender\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=true\n+   *\n+   * Make sure the events are sent from LN to NY and will not be added into tmpDroppedEvents\n+   * while normal events put from NY site can still be added to tmpDroppedEvents\n+   * Start the sender, make sure the events in tmpDroppedEvents are sent to LN finally\n+   */\n+  @Test\n+  public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    // create receiver on site-ln and site-ny\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    // create senders on site-ny, Note: sender-id is its destination, i.e. ny\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+\n+    // create senders on site-ln, Note: sender-id is its destination, i.e. ln\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+\n+    // create PR on site-ny\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    // create PR on site-ln\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    // start sender on site-ny\n+    startSenderInVMs(\"ny\", vm2, vm4);\n+\n+    // do 100 puts on site-ln\n+    vm3.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 0, 100));\n+\n+    // verify site-ny have 100 entries\n+    vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+    vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+\n+    // verify site-ln has not received the events from site-ny yet\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+\n+    // start sender on site-ln\n+    startSenderInVMsAsync(\"ln\", vm3, vm5);\n+\n+    // verify tmpDroppedEvents should be 0 now at site-ny\n+    vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n+    vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n+\n+    vm3.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+    vm5.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+  }\n+\n+  /**\n+   * Test that gateway sender's secondary queues do not keep dropped events\n+   * by the primary gateway sender received while it was starting but was not\n+   * started yet, after the primary finishes starting.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=true\n+   * LN site's sender's manual-start=true\n+   *\n+   * put some events from LN and start the sender in NY simultaneously\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void startedSenderReceivingEventsWhileStartingShouldDrainQueues()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    AsyncInvocation inv =\n+        vm2.invokeAsync(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 1000));\n+    startSenderInVMsAsync(\"ny\", vm2, vm4);\n+    inv.join();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc1967afb0469d8c6fd38492c9de9ec71fff627"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE0NzM1NA==", "bodyText": "The AsyncInvocation.join() method is deprecated. It should be replaced with AsyncInvocation.await().", "url": "https://github.com/apache/geode/pull/5509#discussion_r488147354", "createdAt": "2020-09-14T18:47:10Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java", "diffHunk": "@@ -297,4 +298,322 @@ public void testReplicatedSerialPropagationWithFilter_AfterAck() throws Exceptio\n     vm4.invoke(() -> WANTestBase.waitForConcurrentSerialSenderQueueToDrain(\"ln\"));\n     vm5.invoke(() -> WANTestBase.waitForConcurrentSerialSenderQueueToDrain(\"ln\"));\n   }\n+\n+  /**\n+   * Test unstarted sender\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=true\n+   *\n+   * Make sure the events are sent from LN to NY and will not be added into tmpDroppedEvents\n+   * while normal events put from NY site can still be added to tmpDroppedEvents\n+   * Start the sender, make sure the events in tmpDroppedEvents are sent to LN finally\n+   */\n+  @Test\n+  public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    // create receiver on site-ln and site-ny\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    // create senders on site-ny, Note: sender-id is its destination, i.e. ny\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+\n+    // create senders on site-ln, Note: sender-id is its destination, i.e. ln\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+\n+    // create PR on site-ny\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    // create PR on site-ln\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    // start sender on site-ny\n+    startSenderInVMs(\"ny\", vm2, vm4);\n+\n+    // do 100 puts on site-ln\n+    vm3.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 0, 100));\n+\n+    // verify site-ny have 100 entries\n+    vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+    vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+\n+    // verify site-ln has not received the events from site-ny yet\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+\n+    // start sender on site-ln\n+    startSenderInVMsAsync(\"ln\", vm3, vm5);\n+\n+    // verify tmpDroppedEvents should be 0 now at site-ny\n+    vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n+    vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n+\n+    vm3.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+    vm5.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+  }\n+\n+  /**\n+   * Test that gateway sender's secondary queues do not keep dropped events\n+   * by the primary gateway sender received while it was starting but was not\n+   * started yet, after the primary finishes starting.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=true\n+   * LN site's sender's manual-start=true\n+   *\n+   * put some events from LN and start the sender in NY simultaneously\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void startedSenderReceivingEventsWhileStartingShouldDrainQueues()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    AsyncInvocation inv =\n+        vm2.invokeAsync(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 1000));\n+    startSenderInVMsAsync(\"ny\", vm2, vm4);\n+    inv.join();\n+\n+    vm2.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+    vm4.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+\n+    vm2.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+    vm4.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+  }\n+\n+  /**\n+   * Test that gateway sender's secondary queues do not keep dropped events\n+   * by the primary gateway sender received while it was stopping after it is started again.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=false\n+   * LN site's sender's manual-start=false\n+   *\n+   * put some events from LN and stop the sender in NY simultaneously\n+   * Start the sender in NY.\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void startedSenderReceivingEventsWhileStoppingShouldDrainQueues()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, false));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, false));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, false));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, false));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    AsyncInvocation inv =\n+        vm2.invokeAsync(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 1000));\n+    stopSenderInVMsAsync(\"ny\", vm2, vm4);\n+    inv.join();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc1967afb0469d8c6fd38492c9de9ec71fff627"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE0NzQ3Mw==", "bodyText": "The IDE warning here can be resolved by using List<AsyncInvocation<Void>>.", "url": "https://github.com/apache/geode/pull/5509#discussion_r488147473", "createdAt": "2020-09-14T18:47:22Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java", "diffHunk": "@@ -297,4 +298,322 @@ public void testReplicatedSerialPropagationWithFilter_AfterAck() throws Exceptio\n     vm4.invoke(() -> WANTestBase.waitForConcurrentSerialSenderQueueToDrain(\"ln\"));\n     vm5.invoke(() -> WANTestBase.waitForConcurrentSerialSenderQueueToDrain(\"ln\"));\n   }\n+\n+  /**\n+   * Test unstarted sender\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=true\n+   *\n+   * Make sure the events are sent from LN to NY and will not be added into tmpDroppedEvents\n+   * while normal events put from NY site can still be added to tmpDroppedEvents\n+   * Start the sender, make sure the events in tmpDroppedEvents are sent to LN finally\n+   */\n+  @Test\n+  public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    // create receiver on site-ln and site-ny\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    // create senders on site-ny, Note: sender-id is its destination, i.e. ny\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+\n+    // create senders on site-ln, Note: sender-id is its destination, i.e. ln\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+\n+    // create PR on site-ny\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    // create PR on site-ln\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    // start sender on site-ny\n+    startSenderInVMs(\"ny\", vm2, vm4);\n+\n+    // do 100 puts on site-ln\n+    vm3.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 0, 100));\n+\n+    // verify site-ny have 100 entries\n+    vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+    vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+\n+    // verify site-ln has not received the events from site-ny yet\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+\n+    // start sender on site-ln\n+    startSenderInVMsAsync(\"ln\", vm3, vm5);\n+\n+    // verify tmpDroppedEvents should be 0 now at site-ny\n+    vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n+    vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n+\n+    vm3.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+    vm5.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+  }\n+\n+  /**\n+   * Test that gateway sender's secondary queues do not keep dropped events\n+   * by the primary gateway sender received while it was starting but was not\n+   * started yet, after the primary finishes starting.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=true\n+   * LN site's sender's manual-start=true\n+   *\n+   * put some events from LN and start the sender in NY simultaneously\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void startedSenderReceivingEventsWhileStartingShouldDrainQueues()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    AsyncInvocation inv =\n+        vm2.invokeAsync(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 1000));\n+    startSenderInVMsAsync(\"ny\", vm2, vm4);\n+    inv.join();\n+\n+    vm2.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+    vm4.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+\n+    vm2.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+    vm4.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+  }\n+\n+  /**\n+   * Test that gateway sender's secondary queues do not keep dropped events\n+   * by the primary gateway sender received while it was stopping after it is started again.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=false\n+   * LN site's sender's manual-start=false\n+   *\n+   * put some events from LN and stop the sender in NY simultaneously\n+   * Start the sender in NY.\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void startedSenderReceivingEventsWhileStoppingShouldDrainQueues()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, false));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, false));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, false));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, false));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    AsyncInvocation inv =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc1967afb0469d8c6fd38492c9de9ec71fff627"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE0NzcxOQ==", "bodyText": "An exception is never thrown from this method, so this \"throws\" can be removed.", "url": "https://github.com/apache/geode/pull/5509#discussion_r488147719", "createdAt": "2020-09-14T18:47:51Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java", "diffHunk": "@@ -297,4 +298,322 @@ public void testReplicatedSerialPropagationWithFilter_AfterAck() throws Exceptio\n     vm4.invoke(() -> WANTestBase.waitForConcurrentSerialSenderQueueToDrain(\"ln\"));\n     vm5.invoke(() -> WANTestBase.waitForConcurrentSerialSenderQueueToDrain(\"ln\"));\n   }\n+\n+  /**\n+   * Test unstarted sender\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=true\n+   *\n+   * Make sure the events are sent from LN to NY and will not be added into tmpDroppedEvents\n+   * while normal events put from NY site can still be added to tmpDroppedEvents\n+   * Start the sender, make sure the events in tmpDroppedEvents are sent to LN finally\n+   */\n+  @Test\n+  public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    // create receiver on site-ln and site-ny\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    // create senders on site-ny, Note: sender-id is its destination, i.e. ny\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+\n+    // create senders on site-ln, Note: sender-id is its destination, i.e. ln\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+\n+    // create PR on site-ny\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    // create PR on site-ln\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    // start sender on site-ny\n+    startSenderInVMs(\"ny\", vm2, vm4);\n+\n+    // do 100 puts on site-ln\n+    vm3.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 0, 100));\n+\n+    // verify site-ny have 100 entries\n+    vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+    vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+\n+    // verify site-ln has not received the events from site-ny yet\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+\n+    // start sender on site-ln\n+    startSenderInVMsAsync(\"ln\", vm3, vm5);\n+\n+    // verify tmpDroppedEvents should be 0 now at site-ny\n+    vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n+    vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n+\n+    vm3.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+    vm5.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+  }\n+\n+  /**\n+   * Test that gateway sender's secondary queues do not keep dropped events\n+   * by the primary gateway sender received while it was starting but was not\n+   * started yet, after the primary finishes starting.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=true\n+   * LN site's sender's manual-start=true\n+   *\n+   * put some events from LN and start the sender in NY simultaneously\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void startedSenderReceivingEventsWhileStartingShouldDrainQueues()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    AsyncInvocation inv =\n+        vm2.invokeAsync(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 1000));\n+    startSenderInVMsAsync(\"ny\", vm2, vm4);\n+    inv.join();\n+\n+    vm2.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+    vm4.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+\n+    vm2.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+    vm4.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+  }\n+\n+  /**\n+   * Test that gateway sender's secondary queues do not keep dropped events\n+   * by the primary gateway sender received while it was stopping after it is started again.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=false\n+   * LN site's sender's manual-start=false\n+   *\n+   * put some events from LN and stop the sender in NY simultaneously\n+   * Start the sender in NY.\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void startedSenderReceivingEventsWhileStoppingShouldDrainQueues()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, false));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, false));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, false));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, false));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    AsyncInvocation inv =\n+        vm2.invokeAsync(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 1000));\n+    stopSenderInVMsAsync(\"ny\", vm2, vm4);\n+    inv.join();\n+\n+    startSenderInVMsAsync(\"ny\", vm2, vm4);\n+\n+    vm2.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+    vm4.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+\n+    vm2.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+    vm4.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+  }\n+\n+  /**\n+   * Test that a stopped gateway sender receiving events\n+   * does not store them in tmpDroppedEvents but after started\n+   * does not leave any event in the\n+   * gateway sender's secondary queues.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=false\n+   * LN site's sender's manual-start=false\n+   *\n+   * put some events from LN and stop the sender in NY simultaneously\n+   * Start the sender in NY.\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void stoppedSenderShouldNotAddEventsToTmpDroppedEventsButStillDrainQueuesWhenStarted()\n+      throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc1967afb0469d8c6fd38492c9de9ec71fff627"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE0ODA1MQ==", "bodyText": "An exception is never thrown from this method, so this \"throws\" can be removed.", "url": "https://github.com/apache/geode/pull/5509#discussion_r488148051", "createdAt": "2020-09-14T18:48:28Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANPropagationsFeatureDUnitTest.java", "diffHunk": "@@ -297,4 +298,322 @@ public void testReplicatedSerialPropagationWithFilter_AfterAck() throws Exceptio\n     vm4.invoke(() -> WANTestBase.waitForConcurrentSerialSenderQueueToDrain(\"ln\"));\n     vm5.invoke(() -> WANTestBase.waitForConcurrentSerialSenderQueueToDrain(\"ln\"));\n   }\n+\n+  /**\n+   * Test unstarted sender\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=true\n+   *\n+   * Make sure the events are sent from LN to NY and will not be added into tmpDroppedEvents\n+   * while normal events put from NY site can still be added to tmpDroppedEvents\n+   * Start the sender, make sure the events in tmpDroppedEvents are sent to LN finally\n+   */\n+  @Test\n+  public void unstartedSenderShouldNotAddReceivedEventsIntoTmpDropped() throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    // create receiver on site-ln and site-ny\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    // create senders on site-ny, Note: sender-id is its destination, i.e. ny\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+\n+    // create senders on site-ln, Note: sender-id is its destination, i.e. ln\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+\n+    // create PR on site-ny\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    // create PR on site-ln\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    // start sender on site-ny\n+    startSenderInVMs(\"ny\", vm2, vm4);\n+\n+    // do 100 puts on site-ln\n+    vm3.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 0, 100));\n+\n+    // verify site-ny have 100 entries\n+    vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+    vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+\n+    // verify site-ln has not received the events from site-ny yet\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+\n+    // start sender on site-ln\n+    startSenderInVMsAsync(\"ln\", vm3, vm5);\n+\n+    // verify tmpDroppedEvents should be 0 now at site-ny\n+    vm3.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n+    vm5.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ln\", 0));\n+\n+    vm3.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+    vm5.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ln\"));\n+  }\n+\n+  /**\n+   * Test that gateway sender's secondary queues do not keep dropped events\n+   * by the primary gateway sender received while it was starting but was not\n+   * started yet, after the primary finishes starting.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=true\n+   * LN site's sender's manual-start=true\n+   *\n+   * put some events from LN and start the sender in NY simultaneously\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void startedSenderReceivingEventsWhileStartingShouldDrainQueues()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, true));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    AsyncInvocation inv =\n+        vm2.invokeAsync(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 1000));\n+    startSenderInVMsAsync(\"ny\", vm2, vm4);\n+    inv.join();\n+\n+    vm2.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+    vm4.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+\n+    vm2.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+    vm4.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+  }\n+\n+  /**\n+   * Test that gateway sender's secondary queues do not keep dropped events\n+   * by the primary gateway sender received while it was stopping after it is started again.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=false\n+   * LN site's sender's manual-start=false\n+   *\n+   * put some events from LN and stop the sender in NY simultaneously\n+   * Start the sender in NY.\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void startedSenderReceivingEventsWhileStoppingShouldDrainQueues()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, false));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, false));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, false));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, false));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    AsyncInvocation inv =\n+        vm2.invokeAsync(() -> WANTestBase.doPuts(getTestMethodName() + \"_PR\", 1000));\n+    stopSenderInVMsAsync(\"ny\", vm2, vm4);\n+    inv.join();\n+\n+    startSenderInVMsAsync(\"ny\", vm2, vm4);\n+\n+    vm2.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+    vm4.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+\n+    vm2.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+    vm4.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+  }\n+\n+  /**\n+   * Test that a stopped gateway sender receiving events\n+   * does not store them in tmpDroppedEvents but after started\n+   * does not leave any event in the\n+   * gateway sender's secondary queues.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=false\n+   * LN site's sender's manual-start=false\n+   *\n+   * put some events from LN and stop the sender in NY simultaneously\n+   * Start the sender in NY.\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void stoppedSenderShouldNotAddEventsToTmpDroppedEventsButStillDrainQueuesWhenStarted()\n+      throws Exception {\n+    Integer lnPort = vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(2));\n+    Integer nyPort = vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(1, lnPort));\n+\n+    createCacheInVMs(lnPort, vm2, vm4);\n+    createReceiverInVMs(vm2, vm4);\n+    createCacheInVMs(nyPort, vm3, vm5);\n+    createReceiverInVMs(vm3, vm5);\n+\n+    vm2.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, false));\n+    vm4.invoke(() -> WANTestBase.createSender(\"ny\", 1, false, 100, 10, false, false, null, false));\n+\n+    vm3.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, false));\n+    vm5.invoke(() -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, false));\n+\n+    vm2.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+    vm4.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ny\", 1, 100,\n+        isOffHeap()));\n+\n+    vm3.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createPartitionedRegion(getTestMethodName() + \"_PR\", \"ln\", 1, 100,\n+        isOffHeap()));\n+\n+    stopSenderInVMsAsync(\"ny\", vm2, vm4);\n+\n+    vm2.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 0, 100));\n+\n+    // verify tmpDroppedEvents is 0 at site-ny\n+    vm2.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+    vm4.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 100));\n+\n+    vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+    vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 0));\n+\n+\n+    startSenderInVMsAsync(\"ny\", vm2, vm4);\n+\n+    vm2.invoke(() -> WANTestBase.doPutsFrom(getTestMethodName() + \"_PR\", 100, 1000));\n+\n+    vm2.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+    vm4.invoke(() -> WANTestBase.verifyTmpDroppedEventSize(\"ny\", 0));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 1000));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 1000));\n+\n+    vm3.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 900));\n+    vm5.invoke(() -> WANTestBase.validateRegionSize(getTestMethodName() + \"_PR\", 900));\n+\n+    // verify the secondary's queues are drained at site-ny\n+    vm2.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+    vm4.invoke(() -> WANTestBase.validateParallelSenderQueueAllBucketsDrained(\"ny\"));\n+  }\n+\n+  /**\n+   * Test that a stopped primary gateway sender receiving events\n+   * does not store them in tmpDroppedEvents but after started\n+   * does not leave any event in the\n+   * gateway sender's secondary queues.\n+   * Site-LN: dsid=2: senderId=\"ny\": vm2, vm4\n+   * Site-NY: dsid=1: senderId=\"ln\": vm3, vm6\n+   * NY site's sender's manual-start=false\n+   * LN site's sender's manual-start=false\n+   *\n+   * put some events from LN and stop one instance of the sender in NY simultaneously\n+   * Start the stopped instance of the sender in NY.\n+   * Make sure there are no events in tmpDroppedEvents and the queues are drained.\n+   */\n+  @Test\n+  public void stoppedPrimarySenderShouldNotAddEventsToTmpDroppedEventsButStillDrainQueuesWhenStarted()\n+      throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc1967afb0469d8c6fd38492c9de9ec71fff627"}, "originalPosition": 273}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE1MjU0OA==", "bodyText": "This line could be moved to immediately before the if (isDebugEnabled) check so that it's only executed if necessary rather than unnecessarily in the case that this.eventProcessor != null evaluates to true.", "url": "https://github.com/apache/geode/pull/5509#discussion_r488152548", "createdAt": "2020-09-14T18:56:27Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/AbstractGatewaySender.java", "diffHunk": "@@ -1118,6 +1115,18 @@ public void distribute(EnumListenerEvent operation, EntryEventImpl event,\n     }\n   }\n \n+  private void recordDroppedEvent(EntryEventImpl event) {\n+    final boolean isDebugEnabled = logger.isDebugEnabled();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc1967afb0469d8c6fd38492c9de9ec71fff627"}, "originalPosition": 17}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa901e3db98277d940ef3d049b46dd0835f35b30", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/aa901e3db98277d940ef3d049b46dd0835f35b30", "committedDate": "2020-09-15T07:08:23Z", "message": "GEODE-8491: Some code cleanup after review"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5MTgzMDMy", "url": "https://github.com/apache/geode/pull/5509#pullrequestreview-489183032", "createdAt": "2020-09-15T23:54:00Z", "commit": {"oid": "aa901e3db98277d940ef3d049b46dd0835f35b30"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMzo1NDowMVrOHSbKbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMzo1NDowMVrOHSbKbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA4MTQ1Mw==", "bodyText": "In ConcurrentParallelGatewaySenderEventProcessor.registerEventDroppedInPrimaryQueue instead of calling sendQueueRemovalMesssageForDroppedEvent to send a ParallelQueueRemovalMessage inline, can you call ParallelGatewaySenderQueue.addRemovedEvent and let the BatchRemovalThread handle sending the message?\nSomething like:\n...\nint bucketId = PartitionedRegionHelper.getHashKey((EntryOperation) droppedEvent);\nboolean isPrimary = prQ.getRegionAdvisor().getBucketAdvisor(bucketId).isPrimary();\nif (isPrimary) {\n  long shadowKey = droppedEvent.getTailKey();\n  ParallelGatewaySenderQueue pgsq = (ParallelGatewaySenderQueue) cpgsq.getQueueByBucket(bucketId);\n  pgsq.addRemovedEvent(prQ, bucketId, shadowKey);\n  this.sender.getStatistics().incEventsDroppedDueToPrimarySenderNotRunning();\n...\n``\nI didn't try this, but it seems like it should work.\n\nI'm not sure if the same idea would work for SerialGatewaySenderEventProcessor.sendBatchDestroyOperationForDroppedEvent since it has a different implementation.\n\nbtw - sendQueueRemovalMesssageForDroppedEvent has an extra 's'.", "url": "https://github.com/apache/geode/pull/5509#discussion_r489081453", "createdAt": "2020-09-15T23:54:01Z", "author": {"login": "boglesby"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/AbstractGatewaySender.java", "diffHunk": "@@ -1118,6 +1115,17 @@ public void distribute(EnumListenerEvent operation, EntryEventImpl event,\n     }\n   }\n \n+  private void recordDroppedEvent(EntryEventImpl event) {\n+    if (this.eventProcessor != null) {\n+      this.eventProcessor.registerEventDroppedInPrimaryQueue(event);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa901e3db98277d940ef3d049b46dd0835f35b30"}, "originalPosition": 18}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "142b7aa3a71a97cf13d27072cf43068a86c2a839", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/142b7aa3a71a97cf13d27072cf43068a86c2a839", "committedDate": "2020-09-16T08:32:49Z", "message": "GEODE-8491: Call removeEvent instead of sending batch removal message directly for ParallelGatewaySender"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5NzQ2NzY1", "url": "https://github.com/apache/geode/pull/5509#pullrequestreview-489746765", "createdAt": "2020-09-16T15:29:14Z", "commit": {"oid": "142b7aa3a71a97cf13d27072cf43068a86c2a839"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5af588b8df1b9af8d7b54bc3d2381f2ed49765a", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/c5af588b8df1b9af8d7b54bc3d2381f2ed49765a", "committedDate": "2020-09-21T12:06:27Z", "message": "Revert \"GEODE-8491: Call removeEvent instead of sending batch removal message directly for ParallelGatewaySender\"\n\nThis reverts commit 142b7aa3a71a97cf13d27072cf43068a86c2a839."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3Nzg2OTEw", "url": "https://github.com/apache/geode/pull/5509#pullrequestreview-497786910", "createdAt": "2020-09-28T18:23:01Z", "commit": {"oid": "c5af588b8df1b9af8d7b54bc3d2381f2ed49765a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4MTIwMjA2", "url": "https://github.com/apache/geode/pull/5509#pullrequestreview-498120206", "createdAt": "2020-09-29T06:06:48Z", "commit": {"oid": "c5af588b8df1b9af8d7b54bc3d2381f2ed49765a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4209, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}