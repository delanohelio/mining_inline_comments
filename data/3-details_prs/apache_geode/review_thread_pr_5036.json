{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDExOTY0OTQ0", "number": 5036, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNDoyODoyNlrOD5bd9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNDozNDoxMlrOD5boEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNTQ1NDYwOnYy", "diffSide": "RIGHT", "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/executors/ExpireDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNDoyODoyNlrOGQsH0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNToxNzozMlrOGQuaeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE1MzI5OQ==", "bodyText": "this is the same as the one above except for the extra.  Can we combine them, or have mutually exclusive asserts?", "url": "https://github.com/apache/geode/pull/5036#discussion_r420153299", "createdAt": "2020-05-05T14:28:26Z", "author": {"login": "prettyClouds"}, "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/executors/ExpireDUnitTest.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis.executors;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.MAX_WAIT_TIME_RECONNECT;\n+import static org.apache.geode.distributed.ConfigurationProperties.REDIS_BIND_ADDRESS;\n+import static org.apache.geode.distributed.ConfigurationProperties.REDIS_PORT;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.Properties;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import redis.clients.jedis.Jedis;\n+\n+import org.apache.geode.internal.AvailablePortHelper;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.redis.internal.ByteArrayWrapper;\n+import org.apache.geode.redis.internal.GeodeRedisService;\n+import org.apache.geode.redis.internal.executor.TTLExecutor;\n+import org.apache.geode.test.awaitility.GeodeAwaitility;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+\n+@Ignore(\"GEODE-8058: this test needs to pass to have feature parity with native redis\")\n+public class ExpireDUnitTest {\n+\n+  @ClassRule\n+  public static ClusterStartupRule clusterStartUp = new ClusterStartupRule(4);\n+\n+  static final String LOCAL_HOST = \"127.0.0.1\";\n+  static int[] availablePorts;\n+  private static final int JEDIS_TIMEOUT =\n+      Math.toIntExact(GeodeAwaitility.getTimeout().toMillis());\n+  static Jedis jedis1;\n+  static Jedis jedis2;\n+  static Jedis jedis3;\n+\n+  static Properties locatorProperties;\n+  static Properties serverProperties1;\n+  static Properties serverProperties2;\n+  static Properties serverProperties3;\n+\n+  static MemberVM locator;\n+  static MemberVM server1;\n+  static MemberVM server2;\n+  static MemberVM server3;\n+\n+  @BeforeClass\n+  public static void classSetup() {\n+\n+    availablePorts = AvailablePortHelper.getRandomAvailableTCPPorts(3);\n+\n+    locatorProperties = new Properties();\n+    serverProperties1 = new Properties();\n+    serverProperties2 = new Properties();\n+    serverProperties3 = new Properties();\n+\n+    locatorProperties.setProperty(MAX_WAIT_TIME_RECONNECT, \"15000\");\n+\n+    serverProperties1.setProperty(REDIS_PORT, Integer.toString(availablePorts[0]));\n+    serverProperties1.setProperty(REDIS_BIND_ADDRESS, LOCAL_HOST);\n+\n+    serverProperties2.setProperty(REDIS_PORT, Integer.toString(availablePorts[1]));\n+    serverProperties2.setProperty(REDIS_BIND_ADDRESS, LOCAL_HOST);\n+\n+    serverProperties3.setProperty(REDIS_PORT, Integer.toString(availablePorts[2]));\n+    serverProperties3.setProperty(REDIS_BIND_ADDRESS, LOCAL_HOST);\n+\n+    locator = clusterStartUp.startLocatorVM(0, locatorProperties);\n+    server1 = clusterStartUp.startServerVM(1, serverProperties1, locator.getPort());\n+    server2 = clusterStartUp.startServerVM(2, serverProperties2, locator.getPort());\n+    server3 = clusterStartUp.startServerVM(3, serverProperties3, locator.getPort());\n+\n+    jedis1 = new Jedis(LOCAL_HOST, availablePorts[0], JEDIS_TIMEOUT);\n+    jedis2 = new Jedis(LOCAL_HOST, availablePorts[1], JEDIS_TIMEOUT);\n+    jedis3 = new Jedis(LOCAL_HOST, availablePorts[2], JEDIS_TIMEOUT);\n+  }\n+\n+  @After\n+  public void testCleanUp() {\n+    jedis1.flushAll();\n+  }\n+\n+  @AfterClass\n+  public static void tearDown() {\n+    jedis1.disconnect();\n+    jedis2.disconnect();\n+    jedis3.disconnect();\n+\n+    server1.stop();\n+    server2.stop();\n+    server3.stop();\n+  }\n+\n+  @Test\n+  public void expireOnOneServer_shouldPropagateToAllServers() {\n+    String key = \"key\";\n+\n+    jedis1.set(key, \"value\");\n+    jedis1.expire(key, 20);\n+\n+    assertThat(jedis2.ttl(key)).isGreaterThan(0);\n+  }\n+\n+  @Test\n+  public void expireOnOneServer_shouldResultInKeyRemovalFromOtherServer() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fd5ef50bdc3a15750c8e63ed5dac945d5e3ea66"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE5MDg0Mg==", "bodyText": "They're a little different since one checks to make sure the key is removed after expiration, but we could remove the duplicate assert.", "url": "https://github.com/apache/geode/pull/5036#discussion_r420190842", "createdAt": "2020-05-05T15:17:32Z", "author": {"login": "sabbey37"}, "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/executors/ExpireDUnitTest.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis.executors;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.MAX_WAIT_TIME_RECONNECT;\n+import static org.apache.geode.distributed.ConfigurationProperties.REDIS_BIND_ADDRESS;\n+import static org.apache.geode.distributed.ConfigurationProperties.REDIS_PORT;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.Properties;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import redis.clients.jedis.Jedis;\n+\n+import org.apache.geode.internal.AvailablePortHelper;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.redis.internal.ByteArrayWrapper;\n+import org.apache.geode.redis.internal.GeodeRedisService;\n+import org.apache.geode.redis.internal.executor.TTLExecutor;\n+import org.apache.geode.test.awaitility.GeodeAwaitility;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+\n+@Ignore(\"GEODE-8058: this test needs to pass to have feature parity with native redis\")\n+public class ExpireDUnitTest {\n+\n+  @ClassRule\n+  public static ClusterStartupRule clusterStartUp = new ClusterStartupRule(4);\n+\n+  static final String LOCAL_HOST = \"127.0.0.1\";\n+  static int[] availablePorts;\n+  private static final int JEDIS_TIMEOUT =\n+      Math.toIntExact(GeodeAwaitility.getTimeout().toMillis());\n+  static Jedis jedis1;\n+  static Jedis jedis2;\n+  static Jedis jedis3;\n+\n+  static Properties locatorProperties;\n+  static Properties serverProperties1;\n+  static Properties serverProperties2;\n+  static Properties serverProperties3;\n+\n+  static MemberVM locator;\n+  static MemberVM server1;\n+  static MemberVM server2;\n+  static MemberVM server3;\n+\n+  @BeforeClass\n+  public static void classSetup() {\n+\n+    availablePorts = AvailablePortHelper.getRandomAvailableTCPPorts(3);\n+\n+    locatorProperties = new Properties();\n+    serverProperties1 = new Properties();\n+    serverProperties2 = new Properties();\n+    serverProperties3 = new Properties();\n+\n+    locatorProperties.setProperty(MAX_WAIT_TIME_RECONNECT, \"15000\");\n+\n+    serverProperties1.setProperty(REDIS_PORT, Integer.toString(availablePorts[0]));\n+    serverProperties1.setProperty(REDIS_BIND_ADDRESS, LOCAL_HOST);\n+\n+    serverProperties2.setProperty(REDIS_PORT, Integer.toString(availablePorts[1]));\n+    serverProperties2.setProperty(REDIS_BIND_ADDRESS, LOCAL_HOST);\n+\n+    serverProperties3.setProperty(REDIS_PORT, Integer.toString(availablePorts[2]));\n+    serverProperties3.setProperty(REDIS_BIND_ADDRESS, LOCAL_HOST);\n+\n+    locator = clusterStartUp.startLocatorVM(0, locatorProperties);\n+    server1 = clusterStartUp.startServerVM(1, serverProperties1, locator.getPort());\n+    server2 = clusterStartUp.startServerVM(2, serverProperties2, locator.getPort());\n+    server3 = clusterStartUp.startServerVM(3, serverProperties3, locator.getPort());\n+\n+    jedis1 = new Jedis(LOCAL_HOST, availablePorts[0], JEDIS_TIMEOUT);\n+    jedis2 = new Jedis(LOCAL_HOST, availablePorts[1], JEDIS_TIMEOUT);\n+    jedis3 = new Jedis(LOCAL_HOST, availablePorts[2], JEDIS_TIMEOUT);\n+  }\n+\n+  @After\n+  public void testCleanUp() {\n+    jedis1.flushAll();\n+  }\n+\n+  @AfterClass\n+  public static void tearDown() {\n+    jedis1.disconnect();\n+    jedis2.disconnect();\n+    jedis3.disconnect();\n+\n+    server1.stop();\n+    server2.stop();\n+    server3.stop();\n+  }\n+\n+  @Test\n+  public void expireOnOneServer_shouldPropagateToAllServers() {\n+    String key = \"key\";\n+\n+    jedis1.set(key, \"value\");\n+    jedis1.expire(key, 20);\n+\n+    assertThat(jedis2.ttl(key)).isGreaterThan(0);\n+  }\n+\n+  @Test\n+  public void expireOnOneServer_shouldResultInKeyRemovalFromOtherServer() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE1MzI5OQ=="}, "originalCommit": {"oid": "7fd5ef50bdc3a15750c8e63ed5dac945d5e3ea66"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNTQ2NTk3OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/executors/ExpireDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNDozMDo0NlrOGQsO9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNToxOTozMlrOGQugGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE1NTEyNw==", "bodyText": "why do we need to check the internal state in the integration test?  everything else operates at the external, jedis level.", "url": "https://github.com/apache/geode/pull/5036#discussion_r420155127", "createdAt": "2020-05-05T14:30:46Z", "author": {"login": "prettyClouds"}, "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/executors/ExpireDUnitTest.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis.executors;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.MAX_WAIT_TIME_RECONNECT;\n+import static org.apache.geode.distributed.ConfigurationProperties.REDIS_BIND_ADDRESS;\n+import static org.apache.geode.distributed.ConfigurationProperties.REDIS_PORT;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.Properties;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import redis.clients.jedis.Jedis;\n+\n+import org.apache.geode.internal.AvailablePortHelper;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.redis.internal.ByteArrayWrapper;\n+import org.apache.geode.redis.internal.GeodeRedisService;\n+import org.apache.geode.redis.internal.executor.TTLExecutor;\n+import org.apache.geode.test.awaitility.GeodeAwaitility;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+\n+@Ignore(\"GEODE-8058: this test needs to pass to have feature parity with native redis\")\n+public class ExpireDUnitTest {\n+\n+  @ClassRule\n+  public static ClusterStartupRule clusterStartUp = new ClusterStartupRule(4);\n+\n+  static final String LOCAL_HOST = \"127.0.0.1\";\n+  static int[] availablePorts;\n+  private static final int JEDIS_TIMEOUT =\n+      Math.toIntExact(GeodeAwaitility.getTimeout().toMillis());\n+  static Jedis jedis1;\n+  static Jedis jedis2;\n+  static Jedis jedis3;\n+\n+  static Properties locatorProperties;\n+  static Properties serverProperties1;\n+  static Properties serverProperties2;\n+  static Properties serverProperties3;\n+\n+  static MemberVM locator;\n+  static MemberVM server1;\n+  static MemberVM server2;\n+  static MemberVM server3;\n+\n+  @BeforeClass\n+  public static void classSetup() {\n+\n+    availablePorts = AvailablePortHelper.getRandomAvailableTCPPorts(3);\n+\n+    locatorProperties = new Properties();\n+    serverProperties1 = new Properties();\n+    serverProperties2 = new Properties();\n+    serverProperties3 = new Properties();\n+\n+    locatorProperties.setProperty(MAX_WAIT_TIME_RECONNECT, \"15000\");\n+\n+    serverProperties1.setProperty(REDIS_PORT, Integer.toString(availablePorts[0]));\n+    serverProperties1.setProperty(REDIS_BIND_ADDRESS, LOCAL_HOST);\n+\n+    serverProperties2.setProperty(REDIS_PORT, Integer.toString(availablePorts[1]));\n+    serverProperties2.setProperty(REDIS_BIND_ADDRESS, LOCAL_HOST);\n+\n+    serverProperties3.setProperty(REDIS_PORT, Integer.toString(availablePorts[2]));\n+    serverProperties3.setProperty(REDIS_BIND_ADDRESS, LOCAL_HOST);\n+\n+    locator = clusterStartUp.startLocatorVM(0, locatorProperties);\n+    server1 = clusterStartUp.startServerVM(1, serverProperties1, locator.getPort());\n+    server2 = clusterStartUp.startServerVM(2, serverProperties2, locator.getPort());\n+    server3 = clusterStartUp.startServerVM(3, serverProperties3, locator.getPort());\n+\n+    jedis1 = new Jedis(LOCAL_HOST, availablePorts[0], JEDIS_TIMEOUT);\n+    jedis2 = new Jedis(LOCAL_HOST, availablePorts[1], JEDIS_TIMEOUT);\n+    jedis3 = new Jedis(LOCAL_HOST, availablePorts[2], JEDIS_TIMEOUT);\n+  }\n+\n+  @After\n+  public void testCleanUp() {\n+    jedis1.flushAll();\n+  }\n+\n+  @AfterClass\n+  public static void tearDown() {\n+    jedis1.disconnect();\n+    jedis2.disconnect();\n+    jedis3.disconnect();\n+\n+    server1.stop();\n+    server2.stop();\n+    server3.stop();\n+  }\n+\n+  @Test\n+  public void expireOnOneServer_shouldPropagateToAllServers() {\n+    String key = \"key\";\n+\n+    jedis1.set(key, \"value\");\n+    jedis1.expire(key, 20);\n+\n+    assertThat(jedis2.ttl(key)).isGreaterThan(0);\n+  }\n+\n+  @Test\n+  public void expireOnOneServer_shouldResultInKeyRemovalFromOtherServer() {\n+    String key = \"key\";\n+\n+    jedis1.set(key, \"value\");\n+    jedis1.expire(key, 2);\n+\n+    assertThat(jedis2.ttl(key)).isGreaterThan(0);\n+    GeodeAwaitility.await().until(() -> jedis2.ttl(key) == TTLExecutor.NOT_EXISTS);\n+  }\n+\n+  @Test\n+  public void whenExpirationIsSet_andIsUpdatedOnAnotherServer_itIsReflectedOnFirstServer() {\n+    String key = \"key\";\n+\n+    jedis1.set(key, \"value\");\n+    jedis1.expire(key, 20);\n+    jedis2.expire(key, 10000);\n+\n+    assertThat(jedis1.ttl(key)).isGreaterThan(20L);\n+  }\n+\n+  @Test\n+  public void whenExpirationIsSet_andKeyIsResetOnAnotherServer_ttlIsRemovedOnFirstServer() {\n+    String key = \"key\";\n+\n+    jedis1.set(key, \"value\");\n+    jedis1.expire(key, 20);\n+    jedis2.set(key, \"newValue\");\n+\n+    assertThat(jedis1.ttl(key)).isEqualTo(TTLExecutor.NO_TIMEOUT);\n+  }\n+\n+  @Test\n+  public void whenExpirationIsSet_andKeyIsPersistedOnAnotherServer_ttlIsRemovedOnFirstServer() {\n+    String key = \"key\";\n+\n+    jedis1.set(key, \"value\");\n+    jedis1.expire(key, 20);\n+    jedis2.persist(key);\n+\n+    assertThat(jedis1.ttl(key)).isEqualTo(TTLExecutor.NO_TIMEOUT);\n+  }\n+\n+  @Test\n+  public void whenExpirationIsSet_andKeyIsDeletedOnAnotherServer_ttlReflectsChanges() {\n+    String key = \"key\";\n+\n+    jedis1.set(key, \"value\");\n+    jedis1.expire(key, 20);\n+    jedis2.del(key);\n+\n+    server1.invoke(() -> {\n+      InternalCache cache = ClusterStartupRule.getCache();\n+      GeodeRedisService redisService = cache.getService(GeodeRedisService.class);\n+      boolean hasExpiration = redisService.getGeodeRedisServer().getRegionCache()\n+          .hasExpiration(new ByteArrayWrapper(key.getBytes()));\n+      assertThat(hasExpiration).as(\"expiration should not be set\").isFalse();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fd5ef50bdc3a15750c8e63ed5dac945d5e3ea66"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE5MjI4MQ==", "bodyText": "Good point.  The TTL was returning non-existent for server1, but internally the region still has an expiration set.  Updated it so we reset the key on server2 and check the TTL without looking into the region cache.", "url": "https://github.com/apache/geode/pull/5036#discussion_r420192281", "createdAt": "2020-05-05T15:19:32Z", "author": {"login": "sabbey37"}, "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/executors/ExpireDUnitTest.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis.executors;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.MAX_WAIT_TIME_RECONNECT;\n+import static org.apache.geode.distributed.ConfigurationProperties.REDIS_BIND_ADDRESS;\n+import static org.apache.geode.distributed.ConfigurationProperties.REDIS_PORT;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.Properties;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import redis.clients.jedis.Jedis;\n+\n+import org.apache.geode.internal.AvailablePortHelper;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.redis.internal.ByteArrayWrapper;\n+import org.apache.geode.redis.internal.GeodeRedisService;\n+import org.apache.geode.redis.internal.executor.TTLExecutor;\n+import org.apache.geode.test.awaitility.GeodeAwaitility;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+\n+@Ignore(\"GEODE-8058: this test needs to pass to have feature parity with native redis\")\n+public class ExpireDUnitTest {\n+\n+  @ClassRule\n+  public static ClusterStartupRule clusterStartUp = new ClusterStartupRule(4);\n+\n+  static final String LOCAL_HOST = \"127.0.0.1\";\n+  static int[] availablePorts;\n+  private static final int JEDIS_TIMEOUT =\n+      Math.toIntExact(GeodeAwaitility.getTimeout().toMillis());\n+  static Jedis jedis1;\n+  static Jedis jedis2;\n+  static Jedis jedis3;\n+\n+  static Properties locatorProperties;\n+  static Properties serverProperties1;\n+  static Properties serverProperties2;\n+  static Properties serverProperties3;\n+\n+  static MemberVM locator;\n+  static MemberVM server1;\n+  static MemberVM server2;\n+  static MemberVM server3;\n+\n+  @BeforeClass\n+  public static void classSetup() {\n+\n+    availablePorts = AvailablePortHelper.getRandomAvailableTCPPorts(3);\n+\n+    locatorProperties = new Properties();\n+    serverProperties1 = new Properties();\n+    serverProperties2 = new Properties();\n+    serverProperties3 = new Properties();\n+\n+    locatorProperties.setProperty(MAX_WAIT_TIME_RECONNECT, \"15000\");\n+\n+    serverProperties1.setProperty(REDIS_PORT, Integer.toString(availablePorts[0]));\n+    serverProperties1.setProperty(REDIS_BIND_ADDRESS, LOCAL_HOST);\n+\n+    serverProperties2.setProperty(REDIS_PORT, Integer.toString(availablePorts[1]));\n+    serverProperties2.setProperty(REDIS_BIND_ADDRESS, LOCAL_HOST);\n+\n+    serverProperties3.setProperty(REDIS_PORT, Integer.toString(availablePorts[2]));\n+    serverProperties3.setProperty(REDIS_BIND_ADDRESS, LOCAL_HOST);\n+\n+    locator = clusterStartUp.startLocatorVM(0, locatorProperties);\n+    server1 = clusterStartUp.startServerVM(1, serverProperties1, locator.getPort());\n+    server2 = clusterStartUp.startServerVM(2, serverProperties2, locator.getPort());\n+    server3 = clusterStartUp.startServerVM(3, serverProperties3, locator.getPort());\n+\n+    jedis1 = new Jedis(LOCAL_HOST, availablePorts[0], JEDIS_TIMEOUT);\n+    jedis2 = new Jedis(LOCAL_HOST, availablePorts[1], JEDIS_TIMEOUT);\n+    jedis3 = new Jedis(LOCAL_HOST, availablePorts[2], JEDIS_TIMEOUT);\n+  }\n+\n+  @After\n+  public void testCleanUp() {\n+    jedis1.flushAll();\n+  }\n+\n+  @AfterClass\n+  public static void tearDown() {\n+    jedis1.disconnect();\n+    jedis2.disconnect();\n+    jedis3.disconnect();\n+\n+    server1.stop();\n+    server2.stop();\n+    server3.stop();\n+  }\n+\n+  @Test\n+  public void expireOnOneServer_shouldPropagateToAllServers() {\n+    String key = \"key\";\n+\n+    jedis1.set(key, \"value\");\n+    jedis1.expire(key, 20);\n+\n+    assertThat(jedis2.ttl(key)).isGreaterThan(0);\n+  }\n+\n+  @Test\n+  public void expireOnOneServer_shouldResultInKeyRemovalFromOtherServer() {\n+    String key = \"key\";\n+\n+    jedis1.set(key, \"value\");\n+    jedis1.expire(key, 2);\n+\n+    assertThat(jedis2.ttl(key)).isGreaterThan(0);\n+    GeodeAwaitility.await().until(() -> jedis2.ttl(key) == TTLExecutor.NOT_EXISTS);\n+  }\n+\n+  @Test\n+  public void whenExpirationIsSet_andIsUpdatedOnAnotherServer_itIsReflectedOnFirstServer() {\n+    String key = \"key\";\n+\n+    jedis1.set(key, \"value\");\n+    jedis1.expire(key, 20);\n+    jedis2.expire(key, 10000);\n+\n+    assertThat(jedis1.ttl(key)).isGreaterThan(20L);\n+  }\n+\n+  @Test\n+  public void whenExpirationIsSet_andKeyIsResetOnAnotherServer_ttlIsRemovedOnFirstServer() {\n+    String key = \"key\";\n+\n+    jedis1.set(key, \"value\");\n+    jedis1.expire(key, 20);\n+    jedis2.set(key, \"newValue\");\n+\n+    assertThat(jedis1.ttl(key)).isEqualTo(TTLExecutor.NO_TIMEOUT);\n+  }\n+\n+  @Test\n+  public void whenExpirationIsSet_andKeyIsPersistedOnAnotherServer_ttlIsRemovedOnFirstServer() {\n+    String key = \"key\";\n+\n+    jedis1.set(key, \"value\");\n+    jedis1.expire(key, 20);\n+    jedis2.persist(key);\n+\n+    assertThat(jedis1.ttl(key)).isEqualTo(TTLExecutor.NO_TIMEOUT);\n+  }\n+\n+  @Test\n+  public void whenExpirationIsSet_andKeyIsDeletedOnAnotherServer_ttlReflectsChanges() {\n+    String key = \"key\";\n+\n+    jedis1.set(key, \"value\");\n+    jedis1.expire(key, 20);\n+    jedis2.del(key);\n+\n+    server1.invoke(() -> {\n+      InternalCache cache = ClusterStartupRule.getCache();\n+      GeodeRedisService redisService = cache.getService(GeodeRedisService.class);\n+      boolean hasExpiration = redisService.getGeodeRedisServer().getRegionCache()\n+          .hasExpiration(new ByteArrayWrapper(key.getBytes()));\n+      assertThat(hasExpiration).as(\"expiration should not be set\").isFalse();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE1NTEyNw=="}, "originalCommit": {"oid": "7fd5ef50bdc3a15750c8e63ed5dac945d5e3ea66"}, "originalPosition": 180}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNTQ3NTk0OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/GeodeRedisService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNDozMzoxMFrOGQsVww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNToxOTo0MFrOGQuggQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE1Njg2Nw==", "bodyText": "if we remove that internal check mentioned above, we don't need this getter.", "url": "https://github.com/apache/geode/pull/5036#discussion_r420156867", "createdAt": "2020-05-05T14:33:10Z", "author": {"login": "prettyClouds"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/GeodeRedisService.java", "diffHunk": "@@ -87,4 +88,9 @@ private void stopRedisServer() {\n   public CacheServiceMBeanBase getMBean() {\n     return null;\n   }\n+\n+  @VisibleForTesting\n+  public GeodeRedisServer getGeodeRedisServer() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fd5ef50bdc3a15750c8e63ed5dac945d5e3ea66"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE5MjM4NQ==", "bodyText": "Truth.", "url": "https://github.com/apache/geode/pull/5036#discussion_r420192385", "createdAt": "2020-05-05T15:19:40Z", "author": {"login": "sabbey37"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/GeodeRedisService.java", "diffHunk": "@@ -87,4 +88,9 @@ private void stopRedisServer() {\n   public CacheServiceMBeanBase getMBean() {\n     return null;\n   }\n+\n+  @VisibleForTesting\n+  public GeodeRedisServer getGeodeRedisServer() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE1Njg2Nw=="}, "originalCommit": {"oid": "7fd5ef50bdc3a15750c8e63ed5dac945d5e3ea66"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNTQ4MDQ5OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/executors/ExpireDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNDozNDoxMlrOGQsYug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNToyMDoxMFrOGQuiFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE1NzYyNg==", "bodyText": "i thought this wasn't working...did we change expiration to make these distributed scenarios work?", "url": "https://github.com/apache/geode/pull/5036#discussion_r420157626", "createdAt": "2020-05-05T14:34:12Z", "author": {"login": "prettyClouds"}, "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/executors/ExpireDUnitTest.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis.executors;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.MAX_WAIT_TIME_RECONNECT;\n+import static org.apache.geode.distributed.ConfigurationProperties.REDIS_BIND_ADDRESS;\n+import static org.apache.geode.distributed.ConfigurationProperties.REDIS_PORT;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.Properties;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import redis.clients.jedis.Jedis;\n+\n+import org.apache.geode.internal.AvailablePortHelper;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.redis.internal.ByteArrayWrapper;\n+import org.apache.geode.redis.internal.GeodeRedisService;\n+import org.apache.geode.redis.internal.executor.TTLExecutor;\n+import org.apache.geode.test.awaitility.GeodeAwaitility;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+\n+@Ignore(\"GEODE-8058: this test needs to pass to have feature parity with native redis\")\n+public class ExpireDUnitTest {\n+\n+  @ClassRule\n+  public static ClusterStartupRule clusterStartUp = new ClusterStartupRule(4);\n+\n+  static final String LOCAL_HOST = \"127.0.0.1\";\n+  static int[] availablePorts;\n+  private static final int JEDIS_TIMEOUT =\n+      Math.toIntExact(GeodeAwaitility.getTimeout().toMillis());\n+  static Jedis jedis1;\n+  static Jedis jedis2;\n+  static Jedis jedis3;\n+\n+  static Properties locatorProperties;\n+  static Properties serverProperties1;\n+  static Properties serverProperties2;\n+  static Properties serverProperties3;\n+\n+  static MemberVM locator;\n+  static MemberVM server1;\n+  static MemberVM server2;\n+  static MemberVM server3;\n+\n+  @BeforeClass\n+  public static void classSetup() {\n+\n+    availablePorts = AvailablePortHelper.getRandomAvailableTCPPorts(3);\n+\n+    locatorProperties = new Properties();\n+    serverProperties1 = new Properties();\n+    serverProperties2 = new Properties();\n+    serverProperties3 = new Properties();\n+\n+    locatorProperties.setProperty(MAX_WAIT_TIME_RECONNECT, \"15000\");\n+\n+    serverProperties1.setProperty(REDIS_PORT, Integer.toString(availablePorts[0]));\n+    serverProperties1.setProperty(REDIS_BIND_ADDRESS, LOCAL_HOST);\n+\n+    serverProperties2.setProperty(REDIS_PORT, Integer.toString(availablePorts[1]));\n+    serverProperties2.setProperty(REDIS_BIND_ADDRESS, LOCAL_HOST);\n+\n+    serverProperties3.setProperty(REDIS_PORT, Integer.toString(availablePorts[2]));\n+    serverProperties3.setProperty(REDIS_BIND_ADDRESS, LOCAL_HOST);\n+\n+    locator = clusterStartUp.startLocatorVM(0, locatorProperties);\n+    server1 = clusterStartUp.startServerVM(1, serverProperties1, locator.getPort());\n+    server2 = clusterStartUp.startServerVM(2, serverProperties2, locator.getPort());\n+    server3 = clusterStartUp.startServerVM(3, serverProperties3, locator.getPort());\n+\n+    jedis1 = new Jedis(LOCAL_HOST, availablePorts[0], JEDIS_TIMEOUT);\n+    jedis2 = new Jedis(LOCAL_HOST, availablePorts[1], JEDIS_TIMEOUT);\n+    jedis3 = new Jedis(LOCAL_HOST, availablePorts[2], JEDIS_TIMEOUT);\n+  }\n+\n+  @After\n+  public void testCleanUp() {\n+    jedis1.flushAll();\n+  }\n+\n+  @AfterClass\n+  public static void tearDown() {\n+    jedis1.disconnect();\n+    jedis2.disconnect();\n+    jedis3.disconnect();\n+\n+    server1.stop();\n+    server2.stop();\n+    server3.stop();\n+  }\n+\n+  @Test\n+  public void expireOnOneServer_shouldPropagateToAllServers() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fd5ef50bdc3a15750c8e63ed5dac945d5e3ea66"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE5Mjc5MQ==", "bodyText": "Yeah, they don't actually work yet (there is another story for that), so we ignored the entire class.", "url": "https://github.com/apache/geode/pull/5036#discussion_r420192791", "createdAt": "2020-05-05T15:20:10Z", "author": {"login": "sabbey37"}, "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/executors/ExpireDUnitTest.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis.executors;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.MAX_WAIT_TIME_RECONNECT;\n+import static org.apache.geode.distributed.ConfigurationProperties.REDIS_BIND_ADDRESS;\n+import static org.apache.geode.distributed.ConfigurationProperties.REDIS_PORT;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.Properties;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import redis.clients.jedis.Jedis;\n+\n+import org.apache.geode.internal.AvailablePortHelper;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.redis.internal.ByteArrayWrapper;\n+import org.apache.geode.redis.internal.GeodeRedisService;\n+import org.apache.geode.redis.internal.executor.TTLExecutor;\n+import org.apache.geode.test.awaitility.GeodeAwaitility;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+\n+@Ignore(\"GEODE-8058: this test needs to pass to have feature parity with native redis\")\n+public class ExpireDUnitTest {\n+\n+  @ClassRule\n+  public static ClusterStartupRule clusterStartUp = new ClusterStartupRule(4);\n+\n+  static final String LOCAL_HOST = \"127.0.0.1\";\n+  static int[] availablePorts;\n+  private static final int JEDIS_TIMEOUT =\n+      Math.toIntExact(GeodeAwaitility.getTimeout().toMillis());\n+  static Jedis jedis1;\n+  static Jedis jedis2;\n+  static Jedis jedis3;\n+\n+  static Properties locatorProperties;\n+  static Properties serverProperties1;\n+  static Properties serverProperties2;\n+  static Properties serverProperties3;\n+\n+  static MemberVM locator;\n+  static MemberVM server1;\n+  static MemberVM server2;\n+  static MemberVM server3;\n+\n+  @BeforeClass\n+  public static void classSetup() {\n+\n+    availablePorts = AvailablePortHelper.getRandomAvailableTCPPorts(3);\n+\n+    locatorProperties = new Properties();\n+    serverProperties1 = new Properties();\n+    serverProperties2 = new Properties();\n+    serverProperties3 = new Properties();\n+\n+    locatorProperties.setProperty(MAX_WAIT_TIME_RECONNECT, \"15000\");\n+\n+    serverProperties1.setProperty(REDIS_PORT, Integer.toString(availablePorts[0]));\n+    serverProperties1.setProperty(REDIS_BIND_ADDRESS, LOCAL_HOST);\n+\n+    serverProperties2.setProperty(REDIS_PORT, Integer.toString(availablePorts[1]));\n+    serverProperties2.setProperty(REDIS_BIND_ADDRESS, LOCAL_HOST);\n+\n+    serverProperties3.setProperty(REDIS_PORT, Integer.toString(availablePorts[2]));\n+    serverProperties3.setProperty(REDIS_BIND_ADDRESS, LOCAL_HOST);\n+\n+    locator = clusterStartUp.startLocatorVM(0, locatorProperties);\n+    server1 = clusterStartUp.startServerVM(1, serverProperties1, locator.getPort());\n+    server2 = clusterStartUp.startServerVM(2, serverProperties2, locator.getPort());\n+    server3 = clusterStartUp.startServerVM(3, serverProperties3, locator.getPort());\n+\n+    jedis1 = new Jedis(LOCAL_HOST, availablePorts[0], JEDIS_TIMEOUT);\n+    jedis2 = new Jedis(LOCAL_HOST, availablePorts[1], JEDIS_TIMEOUT);\n+    jedis3 = new Jedis(LOCAL_HOST, availablePorts[2], JEDIS_TIMEOUT);\n+  }\n+\n+  @After\n+  public void testCleanUp() {\n+    jedis1.flushAll();\n+  }\n+\n+  @AfterClass\n+  public static void tearDown() {\n+    jedis1.disconnect();\n+    jedis2.disconnect();\n+    jedis3.disconnect();\n+\n+    server1.stop();\n+    server2.stop();\n+    server3.stop();\n+  }\n+\n+  @Test\n+  public void expireOnOneServer_shouldPropagateToAllServers() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE1NzYyNg=="}, "originalCommit": {"oid": "7fd5ef50bdc3a15750c8e63ed5dac945d5e3ea66"}, "originalPosition": 114}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4153, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}