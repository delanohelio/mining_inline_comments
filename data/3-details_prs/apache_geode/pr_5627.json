{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAzNTk5Nzg1", "number": 5627, "title": "GEODE-8585: Redis SCAN, HSCAN, and SSCAN do not detect illegal parameters", "bodyText": "Add integration tests and functionality to match native Redis.", "createdAt": "2020-10-14T19:44:49Z", "url": "https://github.com/apache/geode/pull/5627", "merged": true, "mergeCommit": {"oid": "f5dabd2561ff430f55d2bb8fa8ead050ba84d52f"}, "closed": true, "closedAt": "2020-10-16T17:22:01Z", "author": {"login": "sabbey37"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdS38WRAFqTUwOTc5MDMxMw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdTJtmcgFqTUxMDY2MjM3Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5NzkwMzEz", "url": "https://github.com/apache/geode/pull/5627#pullrequestreview-509790313", "createdAt": "2020-10-15T20:38:33Z", "commit": {"oid": "7cbf856077d42e0c805820936d00636d284997ed"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDozODozM1rOHiZQxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDozODozM1rOHiZQxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyNzUyNw==", "bodyText": "I think it would be better to have this return a Pair<BigInteger, List<Object>> - that way it's not hiding the fact that the zero-th element is special.", "url": "https://github.com/apache/geode/pull/5627#discussion_r505827527", "createdAt": "2020-10-15T20:38:33Z", "author": {"login": "jdeppe-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/key/ScanExecutor.java", "diffHunk": "@@ -36,91 +39,87 @@\n   public RedisResponse executeCommand(Command command, ExecutionHandlerContext context) {\n     List<byte[]> commandElems = command.getProcessedCommand();\n \n-    if (commandElems.size() < 2) {\n-      return RedisResponse.error(ArityDef.SCAN);\n-    }\n-\n     String cursorString = command.getStringKey();\n-    int cursor = 0;\n-    Pattern matchPattern = null;\n-    String globMatchString = null;\n+    BigInteger cursor;\n+    Pattern matchPattern;\n+    String globPattern = null;\n     int count = DEFAULT_COUNT;\n+\n     try {\n-      cursor = Integer.parseInt(cursorString);\n+      cursor = new BigInteger(cursorString).abs();\n     } catch (NumberFormatException e) {\n       return RedisResponse.error(ERROR_CURSOR);\n     }\n-    if (cursor < 0) {\n+\n+    if (cursor.compareTo(UNSIGNED_LONG_CAPACITY) > 0) {\n       return RedisResponse.error(ERROR_CURSOR);\n     }\n \n-    if (commandElems.size() > 3) {\n-      try {\n-        byte[] bytes = commandElems.get(2);\n-        String tmp = Coder.bytesToString(bytes);\n-        if (tmp.equalsIgnoreCase(\"MATCH\")) {\n-          bytes = commandElems.get(3);\n-          globMatchString = Coder.bytesToString(bytes);\n-        } else if (tmp.equalsIgnoreCase(\"COUNT\")) {\n-          bytes = commandElems.get(3);\n-          count = Coder.bytesToInt(bytes);\n-        }\n-      } catch (NumberFormatException e) {\n-        return RedisResponse.error(ERROR_COUNT);\n-      }\n+    if (!cursor.equals(context.getScanCursor())) {\n+      cursor = new BigInteger(\"0\");\n     }\n \n-    if (commandElems.size() > 5) {\n-      try {\n-        byte[] bytes = commandElems.get(4);\n-        String tmp = Coder.bytesToString(bytes);\n-        if (tmp.equalsIgnoreCase(\"COUNT\")) {\n-          bytes = commandElems.get(5);\n-          count = Coder.bytesToInt(bytes);\n+    for (int i = 2; i < commandElems.size(); i = i + 2) {\n+      byte[] commandElemBytes = commandElems.get(i);\n+      String keyword = Coder.bytesToString(commandElemBytes);\n+      if (keyword.equalsIgnoreCase(\"MATCH\")) {\n+        commandElemBytes = commandElems.get(i + 1);\n+        globPattern = Coder.bytesToString(commandElemBytes);\n+\n+      } else if (keyword.equalsIgnoreCase(\"COUNT\")) {\n+        commandElemBytes = commandElems.get(i + 1);\n+        try {\n+          count = Coder.bytesToInt(commandElemBytes);\n+        } catch (NumberFormatException e) {\n+          return RedisResponse.error(ERROR_NOT_INTEGER);\n+        }\n+\n+        if (count < 1) {\n+          return RedisResponse.error(ERROR_SYNTAX);\n         }\n-      } catch (NumberFormatException e) {\n-        return RedisResponse.error(ERROR_COUNT);\n-      }\n-    }\n \n-    if (count < 0) {\n-      return RedisResponse.error(ERROR_COUNT);\n+      } else {\n+        return RedisResponse.error(ERROR_SYNTAX);\n+      }\n     }\n \n     try {\n-      matchPattern = convertGlobToRegex(globMatchString);\n+      matchPattern = convertGlobToRegex(globPattern);\n     } catch (PatternSyntaxException e) {\n-      return RedisResponse.error(ERROR_ILLEGAL_GLOB);\n+      LogService.getLogger().warn(\n+          \"Could not compile the pattern: '{}' due to the following exception: '{}'. SCAN will return an empty list.\",\n+          globPattern, e.getMessage());\n+      return RedisResponse.emptyScan();\n     }\n \n-    List<String> returnList = getIteration(getDataRegion(context).keySet(), matchPattern, count,\n+    List<Object> returnList = scan(getDataRegion(context).keySet(), matchPattern, count,\n         cursor);\n+    context.setScanCursor(new BigInteger((String) returnList.get(0)));\n \n     return RedisResponse.scan(returnList);\n   }\n \n-  private List<String> getIteration(Collection<ByteArrayWrapper> list, Pattern matchPattern,\n-      int count, int cursor) {\n-    List<String> returnList = new ArrayList<>();\n+  private List<Object> scan(Collection<ByteArrayWrapper> list, Pattern matchPattern,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7cbf856077d42e0c805820936d00636d284997ed"}, "originalPosition": 127}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "483d686ba4189f6c31d276485eda4b8a42fad8a8", "author": {"user": {"login": "sabbey37", "name": "Sarah"}}, "url": "https://github.com/apache/geode/commit/483d686ba4189f6c31d276485eda4b8a42fad8a8", "committedDate": "2020-10-16T13:09:48Z", "message": "GEODE-8585: Redis SCAN, HSCAN, and SSCAN do not detect illegal parameters"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e614c7b4330c7cd9fcb54075c20fa4205b3f038e", "author": {"user": {"login": "sabbey37", "name": "Sarah"}}, "url": "https://github.com/apache/geode/commit/e614c7b4330c7cd9fcb54075c20fa4205b3f038e", "committedDate": "2020-10-15T21:31:40Z", "message": "PR review changes"}, "afterCommit": {"oid": "483d686ba4189f6c31d276485eda4b8a42fad8a8", "author": {"user": {"login": "sabbey37", "name": "Sarah"}}, "url": "https://github.com/apache/geode/commit/483d686ba4189f6c31d276485eda4b8a42fad8a8", "committedDate": "2020-10-16T13:09:48Z", "message": "GEODE-8585: Redis SCAN, HSCAN, and SSCAN do not detect illegal parameters"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "681e73630254e9db9800d86663411e06b28749a0", "author": {"user": {"login": "sabbey37", "name": "Sarah"}}, "url": "https://github.com/apache/geode/commit/681e73630254e9db9800d86663411e06b28749a0", "committedDate": "2020-10-16T13:37:46Z", "message": "PR review changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1397805bd43cf009a19df5f46bf0f9149dfb52b", "author": {"user": {"login": "sabbey37", "name": "Sarah"}}, "url": "https://github.com/apache/geode/commit/e1397805bd43cf009a19df5f46bf0f9149dfb52b", "committedDate": "2020-10-16T15:02:58Z", "message": "Removes null check since values will never be null"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjYyMzc2", "url": "https://github.com/apache/geode/pull/5627#pullrequestreview-510662376", "createdAt": "2020-10-16T17:20:45Z", "commit": {"oid": "e1397805bd43cf009a19df5f46bf0f9149dfb52b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4108, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}