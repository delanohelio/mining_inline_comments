{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI4MTM0MTM3", "number": 5216, "title": "GEODE-8303: refactor Redis (String)SetExecutor", "bodyText": "Thank you for submitting a contribution to Apache Geode.\nIn order to streamline the review of the contribution we ask you\nto ensure the following steps have been taken:\nFor all changes:\n\n\n Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?\n\n\n Has your PR been rebased against the latest commit within the target branch (typically develop)?\n\n\n Is your initial contribution a single, squashed commit?\n\n\n Does gradlew build run cleanly?\n\n\n Have you written or updated unit tests to verify your changes?\n\n\n If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under ASF 2.0?\n\n\nNote:\nPlease ensure that once the PR is submitted, check Concourse for build issues and\nsubmit an update to your PR as soon as possible. If you need help, please send an\nemail to dev@geode.apache.org.", "createdAt": "2020-06-04T23:06:08Z", "url": "https://github.com/apache/geode/pull/5216", "merged": true, "mergeCommit": {"oid": "f84e9e8442a537ea01b663b7eef1e15b14bb74a4"}, "closed": true, "closedAt": "2020-06-26T17:14:13Z", "author": {"login": "jhutchison"}, "timelineItems": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcoHJ4hgFqTQyNDkxMDgxNA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcu4dX9AFqTQzNzk1MDQ5NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0OTEwODE0", "url": "https://github.com/apache/geode/pull/5216#pullrequestreview-424910814", "createdAt": "2020-06-04T23:50:06Z", "commit": {"oid": "d52ff497d17a27652a5bdc573b49474e446c7a92"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMzo1MDowNlrOGfcCJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwMDowMjo1N1rOGfcPbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxODM0MQ==", "bodyText": "Please convert this back to SECONDS.toMillis(expirationTimeLong). It is a standard part of the jdk and makes clear what units we are converting from and to.", "url": "https://github.com/apache/geode/pull/5216#discussion_r435618341", "createdAt": "2020-06-04T23:50:06Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "diffHunk": "@@ -68,72 +75,141 @@ private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n     return new ByteArrayWrapper(value);\n   }\n \n+  private SetOptions parseOptionalParameters(List<byte[]> optionalParameterBytes)\n+      throws IllegalArgumentException {\n \n-  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {\n     boolean keepTTL = false;\n     SetOptions.Exists existsOption = SetOptions.Exists.NONE;\n     long expiration = 0L;\n \n-    for (int i = 3; i < commandElems.size(); i++) {\n-      String current_arg = Coder.bytesToString(commandElems.get(i)).toUpperCase();\n-      switch (current_arg) {\n-        case \"KEEPTTL\":\n-          keepTTL = true;\n-          break;\n-        case \"EX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          expiration = SECONDS.toMillis(expiration);\n-          break;\n-        case \"PX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          break;\n-        case \"NX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.NX;\n-          break;\n-        case \"XX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.XX;\n-          break;\n-        default:\n-          throw new IllegalArgumentException(ERROR_SYNTAX);\n+    List<String> optionalParametersStrings =\n+        optionalParameterBytes.stream()\n+            .map(item -> Coder.bytesToString(item).toUpperCase())\n+            .collect(Collectors.toList());\n+\n+    throwExceptionIfUnknownParameter(optionalParametersStrings);\n+    throwExceptionIfIncompatableParamaterOptions(optionalParametersStrings);\n+\n+    if (optionalParametersStrings.contains(\"KEEPTL\")) {\n+      keepTTL = true;\n+    }\n+\n+    if (optionalParametersStrings.contains(\"PX\")) {\n+      int index = optionalParametersStrings.indexOf(\"PX\");\n+\n+      if (optionalParametersStrings.size() <= index + 1) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+\n+      String expirationTime = optionalParametersStrings.get(index + 1);\n+      expiration = parseExpirationTime(\"PX\", expirationTime);\n+\n+    } else if (optionalParametersStrings.contains(\"EX\")) {\n+      int index = optionalParametersStrings.indexOf(\"EX\");\n+\n+      if (optionalParametersStrings.size() <= index + 1) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n       }\n+\n+      String expirationTime = optionalParametersStrings.get(index + 1);\n+      expiration = parseExpirationTime(\"EX\", expirationTime);\n+    }\n+\n+    if (optionalParametersStrings.contains(\"NX\")) {\n+      existsOption = SetOptions.Exists.NX;\n+    } else if (optionalParametersStrings.contains(\"XX\")) {\n+      existsOption = SetOptions.Exists.XX;\n     }\n \n     return new SetOptions(existsOption, expiration, keepTTL);\n   }\n \n-  private long parseExpirationTime(int index, List<byte[]> commandElems)\n-      throws IllegalArgumentException {\n-    String expirationString;\n \n-    try {\n-      expirationString = Coder.bytesToString(commandElems.get(index));\n-    } catch (IndexOutOfBoundsException e) {\n+  private void throwExceptionIfUnknownParameter(List<String> optionalParameters) {\n+    List<String> validOptionalParamaters = Arrays.asList(\"EX\", \"PX\", \"NX\", \"XX\", \"KEEPTL\");\n+\n+    List<String> parametersInQuestion =\n+        optionalParameters\n+            .stream()\n+            .filter(parameter -> (!validOptionalParamaters.contains(parameter)))\n+            .collect(Collectors.toList());\n+\n+    parametersInQuestion.forEach(parameter -> throwErrorIfNotANumberInExpectedPosition(\n+        parameter,\n+        optionalParameters));\n+  }\n+\n+\n+  private void throwErrorIfNotANumberInExpectedPosition(\n+      String parameter,\n+      List<String> optionalParameters) {\n+\n+    if (previousOptionIsValidAndExpectsANumber(parameter, optionalParameters)) {\n+      convertToLongOrThrowException(parameter);\n+    } else {\n       throw new IllegalArgumentException(ERROR_SYNTAX);\n     }\n \n+  }\n+\n+\n+  private boolean previousOptionIsValidAndExpectsANumber(String paramter,\n+      List<String> optionalParameters) {\n+    List<String> validParamaters = Arrays.asList(\"EX\", \"PX\");\n+\n+    if (optionalParameters.size() < 2) {\n+      return false;\n+    }\n+\n+    int indexOfParameter = optionalParameters.indexOf(paramter);\n+    String previousParameter = optionalParameters.get(indexOfParameter - 1);\n+\n+    return validParamaters.contains(previousParameter);\n+  }\n+\n+\n+  private void throwExceptionIfIncompatableParamaterOptions(List<String> passedParametersStrings) {\n+\n+    if (passedParametersStrings.contains(\"PX\")\n+        && passedParametersStrings.contains(\"EX\")) {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+\n+    if (passedParametersStrings.contains(\"XX\")\n+        && passedParametersStrings.contains(\"NX\")) {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+  }\n+\n+  private long parseExpirationTime(String expirationParameter, String expirationTimeString)\n+      throws IllegalArgumentException {\n+\n+    long expirationTimeLong =\n+        convertToLongOrThrowException(expirationTimeString);\n+\n+    isExpirationTimeLegal(expirationTimeLong);\n+\n+    if (expirationParameter.equals(\"EX\")) {\n+      expirationTimeLong *= 1000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d52ff497d17a27652a5bdc573b49474e446c7a92"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxOTMxNA==", "bodyText": "This is not the correct exception here. You actually have an integer but the parameter was not one of EX or PX. I wold argue that you should not even pass expirationParameter into this method. Let the caller that knows he is EX convert the value returned from this method to milliseconds. So less responsibility for this method.", "url": "https://github.com/apache/geode/pull/5216#discussion_r435619314", "createdAt": "2020-06-04T23:53:52Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "diffHunk": "@@ -68,72 +75,141 @@ private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n     return new ByteArrayWrapper(value);\n   }\n \n+  private SetOptions parseOptionalParameters(List<byte[]> optionalParameterBytes)\n+      throws IllegalArgumentException {\n \n-  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {\n     boolean keepTTL = false;\n     SetOptions.Exists existsOption = SetOptions.Exists.NONE;\n     long expiration = 0L;\n \n-    for (int i = 3; i < commandElems.size(); i++) {\n-      String current_arg = Coder.bytesToString(commandElems.get(i)).toUpperCase();\n-      switch (current_arg) {\n-        case \"KEEPTTL\":\n-          keepTTL = true;\n-          break;\n-        case \"EX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          expiration = SECONDS.toMillis(expiration);\n-          break;\n-        case \"PX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          break;\n-        case \"NX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.NX;\n-          break;\n-        case \"XX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.XX;\n-          break;\n-        default:\n-          throw new IllegalArgumentException(ERROR_SYNTAX);\n+    List<String> optionalParametersStrings =\n+        optionalParameterBytes.stream()\n+            .map(item -> Coder.bytesToString(item).toUpperCase())\n+            .collect(Collectors.toList());\n+\n+    throwExceptionIfUnknownParameter(optionalParametersStrings);\n+    throwExceptionIfIncompatableParamaterOptions(optionalParametersStrings);\n+\n+    if (optionalParametersStrings.contains(\"KEEPTL\")) {\n+      keepTTL = true;\n+    }\n+\n+    if (optionalParametersStrings.contains(\"PX\")) {\n+      int index = optionalParametersStrings.indexOf(\"PX\");\n+\n+      if (optionalParametersStrings.size() <= index + 1) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+\n+      String expirationTime = optionalParametersStrings.get(index + 1);\n+      expiration = parseExpirationTime(\"PX\", expirationTime);\n+\n+    } else if (optionalParametersStrings.contains(\"EX\")) {\n+      int index = optionalParametersStrings.indexOf(\"EX\");\n+\n+      if (optionalParametersStrings.size() <= index + 1) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n       }\n+\n+      String expirationTime = optionalParametersStrings.get(index + 1);\n+      expiration = parseExpirationTime(\"EX\", expirationTime);\n+    }\n+\n+    if (optionalParametersStrings.contains(\"NX\")) {\n+      existsOption = SetOptions.Exists.NX;\n+    } else if (optionalParametersStrings.contains(\"XX\")) {\n+      existsOption = SetOptions.Exists.XX;\n     }\n \n     return new SetOptions(existsOption, expiration, keepTTL);\n   }\n \n-  private long parseExpirationTime(int index, List<byte[]> commandElems)\n-      throws IllegalArgumentException {\n-    String expirationString;\n \n-    try {\n-      expirationString = Coder.bytesToString(commandElems.get(index));\n-    } catch (IndexOutOfBoundsException e) {\n+  private void throwExceptionIfUnknownParameter(List<String> optionalParameters) {\n+    List<String> validOptionalParamaters = Arrays.asList(\"EX\", \"PX\", \"NX\", \"XX\", \"KEEPTL\");\n+\n+    List<String> parametersInQuestion =\n+        optionalParameters\n+            .stream()\n+            .filter(parameter -> (!validOptionalParamaters.contains(parameter)))\n+            .collect(Collectors.toList());\n+\n+    parametersInQuestion.forEach(parameter -> throwErrorIfNotANumberInExpectedPosition(\n+        parameter,\n+        optionalParameters));\n+  }\n+\n+\n+  private void throwErrorIfNotANumberInExpectedPosition(\n+      String parameter,\n+      List<String> optionalParameters) {\n+\n+    if (previousOptionIsValidAndExpectsANumber(parameter, optionalParameters)) {\n+      convertToLongOrThrowException(parameter);\n+    } else {\n       throw new IllegalArgumentException(ERROR_SYNTAX);\n     }\n \n+  }\n+\n+\n+  private boolean previousOptionIsValidAndExpectsANumber(String paramter,\n+      List<String> optionalParameters) {\n+    List<String> validParamaters = Arrays.asList(\"EX\", \"PX\");\n+\n+    if (optionalParameters.size() < 2) {\n+      return false;\n+    }\n+\n+    int indexOfParameter = optionalParameters.indexOf(paramter);\n+    String previousParameter = optionalParameters.get(indexOfParameter - 1);\n+\n+    return validParamaters.contains(previousParameter);\n+  }\n+\n+\n+  private void throwExceptionIfIncompatableParamaterOptions(List<String> passedParametersStrings) {\n+\n+    if (passedParametersStrings.contains(\"PX\")\n+        && passedParametersStrings.contains(\"EX\")) {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+\n+    if (passedParametersStrings.contains(\"XX\")\n+        && passedParametersStrings.contains(\"NX\")) {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+  }\n+\n+  private long parseExpirationTime(String expirationParameter, String expirationTimeString)\n+      throws IllegalArgumentException {\n+\n+    long expirationTimeLong =\n+        convertToLongOrThrowException(expirationTimeString);\n+\n+    isExpirationTimeLegal(expirationTimeLong);\n+\n+    if (expirationParameter.equals(\"EX\")) {\n+      expirationTimeLong *= 1000;\n+    } else if (!expirationParameter.equals(\"PX\")) {\n+      throw new IllegalArgumentException(ERROR_NOT_INTEGER);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d52ff497d17a27652a5bdc573b49474e446c7a92"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYyMTc0Mw==", "bodyText": "consider having a method called getNextParameter(\"PX\") which would do the indexOf, the size check and the get and return it. Then this type of code could look like:\nif (optionalParametersStrings.contains(\"PX\")) {\nString expirationTime = getNextParameter(optionalParametersStrings, \"PX\");", "url": "https://github.com/apache/geode/pull/5216#discussion_r435621743", "createdAt": "2020-06-05T00:02:57Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "diffHunk": "@@ -68,72 +75,141 @@ private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n     return new ByteArrayWrapper(value);\n   }\n \n+  private SetOptions parseOptionalParameters(List<byte[]> optionalParameterBytes)\n+      throws IllegalArgumentException {\n \n-  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {\n     boolean keepTTL = false;\n     SetOptions.Exists existsOption = SetOptions.Exists.NONE;\n     long expiration = 0L;\n \n-    for (int i = 3; i < commandElems.size(); i++) {\n-      String current_arg = Coder.bytesToString(commandElems.get(i)).toUpperCase();\n-      switch (current_arg) {\n-        case \"KEEPTTL\":\n-          keepTTL = true;\n-          break;\n-        case \"EX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          expiration = SECONDS.toMillis(expiration);\n-          break;\n-        case \"PX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          break;\n-        case \"NX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.NX;\n-          break;\n-        case \"XX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.XX;\n-          break;\n-        default:\n-          throw new IllegalArgumentException(ERROR_SYNTAX);\n+    List<String> optionalParametersStrings =\n+        optionalParameterBytes.stream()\n+            .map(item -> Coder.bytesToString(item).toUpperCase())\n+            .collect(Collectors.toList());\n+\n+    throwExceptionIfUnknownParameter(optionalParametersStrings);\n+    throwExceptionIfIncompatableParamaterOptions(optionalParametersStrings);\n+\n+    if (optionalParametersStrings.contains(\"KEEPTL\")) {\n+      keepTTL = true;\n+    }\n+\n+    if (optionalParametersStrings.contains(\"PX\")) {\n+      int index = optionalParametersStrings.indexOf(\"PX\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d52ff497d17a27652a5bdc573b49474e446c7a92"}, "originalPosition": 105}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NDgyMjI3", "url": "https://github.com/apache/geode/pull/5216#pullrequestreview-425482227", "createdAt": "2020-06-05T17:18:12Z", "commit": {"oid": "d52ff497d17a27652a5bdc573b49474e446c7a92"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNzoxODoxM1rOGf2wJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNzoxODoxM1rOGf2wJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1NjEwMA==", "bodyText": "This could be simplified to:\nkeepTTL = optionalParametersStrings.contains(\"KEEPTL\");", "url": "https://github.com/apache/geode/pull/5216#discussion_r436056100", "createdAt": "2020-06-05T17:18:13Z", "author": {"login": "jdeppe-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "diffHunk": "@@ -68,72 +75,141 @@ private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n     return new ByteArrayWrapper(value);\n   }\n \n+  private SetOptions parseOptionalParameters(List<byte[]> optionalParameterBytes)\n+      throws IllegalArgumentException {\n \n-  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {\n     boolean keepTTL = false;\n     SetOptions.Exists existsOption = SetOptions.Exists.NONE;\n     long expiration = 0L;\n \n-    for (int i = 3; i < commandElems.size(); i++) {\n-      String current_arg = Coder.bytesToString(commandElems.get(i)).toUpperCase();\n-      switch (current_arg) {\n-        case \"KEEPTTL\":\n-          keepTTL = true;\n-          break;\n-        case \"EX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          expiration = SECONDS.toMillis(expiration);\n-          break;\n-        case \"PX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          break;\n-        case \"NX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.NX;\n-          break;\n-        case \"XX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.XX;\n-          break;\n-        default:\n-          throw new IllegalArgumentException(ERROR_SYNTAX);\n+    List<String> optionalParametersStrings =\n+        optionalParameterBytes.stream()\n+            .map(item -> Coder.bytesToString(item).toUpperCase())\n+            .collect(Collectors.toList());\n+\n+    throwExceptionIfUnknownParameter(optionalParametersStrings);\n+    throwExceptionIfIncompatableParamaterOptions(optionalParametersStrings);\n+\n+    if (optionalParametersStrings.contains(\"KEEPTL\")) {\n+      keepTTL = true;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d52ff497d17a27652a5bdc573b49474e446c7a92"}, "originalPosition": 102}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d543a7e1c6b15959122a31266cf1337740ef4a1c", "author": {"user": {"login": "jhutchison", "name": "John Hutchison"}}, "url": "https://github.com/apache/geode/commit/d543a7e1c6b15959122a31266cf1337740ef4a1c", "committedDate": "2020-06-09T22:35:45Z", "message": "switch px/ex logic in redis set executor"}, "afterCommit": {"oid": "929cc7b519f07dab2e9ef6c57d8a9c56c42f2bc5", "author": {"user": {"login": "jhutchison", "name": "John Hutchison"}}, "url": "https://github.com/apache/geode/commit/929cc7b519f07dab2e9ef6c57d8a9c56c42f2bc5", "committedDate": "2020-06-10T18:30:29Z", "message": "refactor SetExecutor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4NDg3MjQ3", "url": "https://github.com/apache/geode/pull/5216#pullrequestreview-428487247", "createdAt": "2020-06-10T23:06:55Z", "commit": {"oid": "3d1ac779762f879de28bbee4a8f9ad0803357b7c"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzowNjo1NlrOGiJKNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzoyNDoxM1rOGiJezA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1NDgzOQ==", "bodyText": "Change \"KEEPTL\" to \"KEEPTTL\"", "url": "https://github.com/apache/geode/pull/5216#discussion_r438454839", "createdAt": "2020-06-10T23:06:56Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "diffHunk": "@@ -35,105 +37,182 @@\n   public RedisResponse executeCommandWithResponse(Command command,\n       ExecutionHandlerContext context) {\n \n-    List<byte[]> commandElems = command.getProcessedCommand();\n     ByteArrayWrapper keyToSet = command.getKey();\n-    ByteArrayWrapper valueToSet = getValueToSet(commandElems);\n-\n+    List<byte[]> commandElementsBytes = command.getProcessedCommand();\n+    List<byte[]> optionalParameterBytes = getOptionalParameters(commandElementsBytes);\n+    ByteArrayWrapper valueToSet = getValueToSet(commandElementsBytes);\n     RedisStringCommands redisStringCommands = getRedisStringCommands(context);\n     SetOptions setOptions;\n+\n     try {\n-      setOptions = parseCommandElems(commandElems);\n+      setOptions = parseOptionalParameters(optionalParameterBytes);\n     } catch (IllegalArgumentException ex) {\n       return RedisResponse.error(ex.getMessage());\n     }\n \n-    return doSet(command, context, keyToSet, valueToSet, redisStringCommands, setOptions);\n+    return doSet(keyToSet, valueToSet, redisStringCommands, setOptions);\n+  }\n+\n+  private List<byte[]> getOptionalParameters(List<byte[]> commandElementsBytes) {\n+    return commandElementsBytes.subList(3, commandElementsBytes.size());\n   }\n \n-  private RedisResponse doSet(Command command, ExecutionHandlerContext context,\n-      ByteArrayWrapper key,\n-      ByteArrayWrapper value, RedisStringCommands redisStringCommands, SetOptions setOptions) {\n+  private RedisResponse doSet(ByteArrayWrapper key,\n+      ByteArrayWrapper value,\n+      RedisStringCommands redisStringCommands,\n+      SetOptions setOptions) {\n \n-    boolean result = redisStringCommands.set(key, value, setOptions);\n+    boolean setCompletedSuccessfully = redisStringCommands.set(key, value, setOptions);\n \n-    if (result) {\n+    if (setCompletedSuccessfully) {\n       return RedisResponse.string(SUCCESS);\n+    } else {\n+      return RedisResponse.nil();\n     }\n-\n-    return RedisResponse.nil();\n   }\n \n   private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n     byte[] value = commandElems.get(2);\n     return new ByteArrayWrapper(value);\n   }\n \n+  private SetOptions parseOptionalParameters(List<byte[]> optionalParameterBytes)\n+      throws IllegalArgumentException {\n \n-  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {\n     boolean keepTTL = false;\n     SetOptions.Exists existsOption = SetOptions.Exists.NONE;\n     long expiration = 0L;\n \n-    for (int i = 3; i < commandElems.size(); i++) {\n-      String current_arg = Coder.bytesToString(commandElems.get(i)).toUpperCase();\n-      switch (current_arg) {\n-        case \"KEEPTTL\":\n-          keepTTL = true;\n-          break;\n-        case \"EX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          expiration = SECONDS.toMillis(expiration);\n-          break;\n-        case \"PX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          break;\n-        case \"NX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.NX;\n-          break;\n-        case \"XX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.XX;\n-          break;\n-        default:\n-          throw new IllegalArgumentException(ERROR_SYNTAX);\n+    List<String> optionalParametersStrings =\n+        optionalParameterBytes.stream()\n+            .map(item -> Coder.bytesToString(item).toUpperCase())\n+            .collect(Collectors.toList());\n+\n+    throwExceptionIfUnknownParameter(optionalParametersStrings);\n+    throwExceptionIfIncompatableParamaterOptions(optionalParametersStrings);\n+    keepTTL = optionalParametersStrings.contains(\"KEEPTL\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d1ac779762f879de28bbee4a8f9ad0803357b7c"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1NTc2MQ==", "bodyText": "change \"KEEPTL\" to \"KEEPTTL\"", "url": "https://github.com/apache/geode/pull/5216#discussion_r438455761", "createdAt": "2020-06-10T23:09:50Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "diffHunk": "@@ -35,105 +37,182 @@\n   public RedisResponse executeCommandWithResponse(Command command,\n       ExecutionHandlerContext context) {\n \n-    List<byte[]> commandElems = command.getProcessedCommand();\n     ByteArrayWrapper keyToSet = command.getKey();\n-    ByteArrayWrapper valueToSet = getValueToSet(commandElems);\n-\n+    List<byte[]> commandElementsBytes = command.getProcessedCommand();\n+    List<byte[]> optionalParameterBytes = getOptionalParameters(commandElementsBytes);\n+    ByteArrayWrapper valueToSet = getValueToSet(commandElementsBytes);\n     RedisStringCommands redisStringCommands = getRedisStringCommands(context);\n     SetOptions setOptions;\n+\n     try {\n-      setOptions = parseCommandElems(commandElems);\n+      setOptions = parseOptionalParameters(optionalParameterBytes);\n     } catch (IllegalArgumentException ex) {\n       return RedisResponse.error(ex.getMessage());\n     }\n \n-    return doSet(command, context, keyToSet, valueToSet, redisStringCommands, setOptions);\n+    return doSet(keyToSet, valueToSet, redisStringCommands, setOptions);\n+  }\n+\n+  private List<byte[]> getOptionalParameters(List<byte[]> commandElementsBytes) {\n+    return commandElementsBytes.subList(3, commandElementsBytes.size());\n   }\n \n-  private RedisResponse doSet(Command command, ExecutionHandlerContext context,\n-      ByteArrayWrapper key,\n-      ByteArrayWrapper value, RedisStringCommands redisStringCommands, SetOptions setOptions) {\n+  private RedisResponse doSet(ByteArrayWrapper key,\n+      ByteArrayWrapper value,\n+      RedisStringCommands redisStringCommands,\n+      SetOptions setOptions) {\n \n-    boolean result = redisStringCommands.set(key, value, setOptions);\n+    boolean setCompletedSuccessfully = redisStringCommands.set(key, value, setOptions);\n \n-    if (result) {\n+    if (setCompletedSuccessfully) {\n       return RedisResponse.string(SUCCESS);\n+    } else {\n+      return RedisResponse.nil();\n     }\n-\n-    return RedisResponse.nil();\n   }\n \n   private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n     byte[] value = commandElems.get(2);\n     return new ByteArrayWrapper(value);\n   }\n \n+  private SetOptions parseOptionalParameters(List<byte[]> optionalParameterBytes)\n+      throws IllegalArgumentException {\n \n-  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {\n     boolean keepTTL = false;\n     SetOptions.Exists existsOption = SetOptions.Exists.NONE;\n     long expiration = 0L;\n \n-    for (int i = 3; i < commandElems.size(); i++) {\n-      String current_arg = Coder.bytesToString(commandElems.get(i)).toUpperCase();\n-      switch (current_arg) {\n-        case \"KEEPTTL\":\n-          keepTTL = true;\n-          break;\n-        case \"EX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          expiration = SECONDS.toMillis(expiration);\n-          break;\n-        case \"PX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          break;\n-        case \"NX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.NX;\n-          break;\n-        case \"XX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.XX;\n-          break;\n-        default:\n-          throw new IllegalArgumentException(ERROR_SYNTAX);\n+    List<String> optionalParametersStrings =\n+        optionalParameterBytes.stream()\n+            .map(item -> Coder.bytesToString(item).toUpperCase())\n+            .collect(Collectors.toList());\n+\n+    throwExceptionIfUnknownParameter(optionalParametersStrings);\n+    throwExceptionIfIncompatableParamaterOptions(optionalParametersStrings);\n+    keepTTL = optionalParametersStrings.contains(\"KEEPTL\");\n+\n+    if (optionalParametersStrings.contains(\"PX\")) {\n+      String nextParameter =\n+          getNextParameter(\"PX\", optionalParametersStrings);\n+\n+      if (!isANumber(nextParameter)) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+\n+      expiration = parseExpirationTime(\"PX\", nextParameter);\n+      if (expiration <= 0) {\n+        throw new IllegalArgumentException(ERROR_INVALID_EXPIRE_TIME);\n+      }\n+\n+    } else if (optionalParametersStrings.contains(\"EX\")) {\n+      String nextParameter =\n+          getNextParameter(\"EX\", optionalParametersStrings);\n+      if (!isANumber(nextParameter)) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+      expiration = parseExpirationTime(\"EX\", nextParameter);\n+      if (expiration <= 0) {\n+        throw new IllegalArgumentException(ERROR_INVALID_EXPIRE_TIME);\n       }\n     }\n \n+    if (optionalParametersStrings.contains(\"NX\")) {\n+      existsOption = SetOptions.Exists.NX;\n+    } else if (optionalParametersStrings.contains(\"XX\")) {\n+      existsOption = SetOptions.Exists.XX;\n+    }\n     return new SetOptions(existsOption, expiration, keepTTL);\n   }\n \n-  private long parseExpirationTime(int index, List<byte[]> commandElems)\n-      throws IllegalArgumentException {\n-    String expirationString;\n+  private String getNextParameter(String currentParameter,\n+      List<String> optionalParametersStrings) {\n+    int index = optionalParametersStrings.indexOf(currentParameter);\n+    if (optionalParametersStrings.size() <= index + 1) {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+    return optionalParametersStrings.get(index + 1);\n+  }\n+\n+  private void throwExceptionIfUnknownParameter(List<String> optionalParameters) {\n+    List<String> validOptionalParamaters = Arrays.asList(\"EX\", \"PX\", \"NX\", \"XX\", \"KEEPTL\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d1ac779762f879de28bbee4a8f9ad0803357b7c"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1NzU5NA==", "bodyText": "I don't like that we now call parseLong twice. Once in isANumber and once in parseExpirationTime. Just have parseExpirationTime handle NumberFormatException and throw IllegalArgumentException(ERROR_NOT_INTEGER)", "url": "https://github.com/apache/geode/pull/5216#discussion_r438457594", "createdAt": "2020-06-10T23:15:44Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "diffHunk": "@@ -35,105 +37,182 @@\n   public RedisResponse executeCommandWithResponse(Command command,\n       ExecutionHandlerContext context) {\n \n-    List<byte[]> commandElems = command.getProcessedCommand();\n     ByteArrayWrapper keyToSet = command.getKey();\n-    ByteArrayWrapper valueToSet = getValueToSet(commandElems);\n-\n+    List<byte[]> commandElementsBytes = command.getProcessedCommand();\n+    List<byte[]> optionalParameterBytes = getOptionalParameters(commandElementsBytes);\n+    ByteArrayWrapper valueToSet = getValueToSet(commandElementsBytes);\n     RedisStringCommands redisStringCommands = getRedisStringCommands(context);\n     SetOptions setOptions;\n+\n     try {\n-      setOptions = parseCommandElems(commandElems);\n+      setOptions = parseOptionalParameters(optionalParameterBytes);\n     } catch (IllegalArgumentException ex) {\n       return RedisResponse.error(ex.getMessage());\n     }\n \n-    return doSet(command, context, keyToSet, valueToSet, redisStringCommands, setOptions);\n+    return doSet(keyToSet, valueToSet, redisStringCommands, setOptions);\n+  }\n+\n+  private List<byte[]> getOptionalParameters(List<byte[]> commandElementsBytes) {\n+    return commandElementsBytes.subList(3, commandElementsBytes.size());\n   }\n \n-  private RedisResponse doSet(Command command, ExecutionHandlerContext context,\n-      ByteArrayWrapper key,\n-      ByteArrayWrapper value, RedisStringCommands redisStringCommands, SetOptions setOptions) {\n+  private RedisResponse doSet(ByteArrayWrapper key,\n+      ByteArrayWrapper value,\n+      RedisStringCommands redisStringCommands,\n+      SetOptions setOptions) {\n \n-    boolean result = redisStringCommands.set(key, value, setOptions);\n+    boolean setCompletedSuccessfully = redisStringCommands.set(key, value, setOptions);\n \n-    if (result) {\n+    if (setCompletedSuccessfully) {\n       return RedisResponse.string(SUCCESS);\n+    } else {\n+      return RedisResponse.nil();\n     }\n-\n-    return RedisResponse.nil();\n   }\n \n   private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n     byte[] value = commandElems.get(2);\n     return new ByteArrayWrapper(value);\n   }\n \n+  private SetOptions parseOptionalParameters(List<byte[]> optionalParameterBytes)\n+      throws IllegalArgumentException {\n \n-  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {\n     boolean keepTTL = false;\n     SetOptions.Exists existsOption = SetOptions.Exists.NONE;\n     long expiration = 0L;\n \n-    for (int i = 3; i < commandElems.size(); i++) {\n-      String current_arg = Coder.bytesToString(commandElems.get(i)).toUpperCase();\n-      switch (current_arg) {\n-        case \"KEEPTTL\":\n-          keepTTL = true;\n-          break;\n-        case \"EX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          expiration = SECONDS.toMillis(expiration);\n-          break;\n-        case \"PX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          break;\n-        case \"NX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.NX;\n-          break;\n-        case \"XX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.XX;\n-          break;\n-        default:\n-          throw new IllegalArgumentException(ERROR_SYNTAX);\n+    List<String> optionalParametersStrings =\n+        optionalParameterBytes.stream()\n+            .map(item -> Coder.bytesToString(item).toUpperCase())\n+            .collect(Collectors.toList());\n+\n+    throwExceptionIfUnknownParameter(optionalParametersStrings);\n+    throwExceptionIfIncompatableParamaterOptions(optionalParametersStrings);\n+    keepTTL = optionalParametersStrings.contains(\"KEEPTL\");\n+\n+    if (optionalParametersStrings.contains(\"PX\")) {\n+      String nextParameter =\n+          getNextParameter(\"PX\", optionalParametersStrings);\n+\n+      if (!isANumber(nextParameter)) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+\n+      expiration = parseExpirationTime(\"PX\", nextParameter);\n+      if (expiration <= 0) {\n+        throw new IllegalArgumentException(ERROR_INVALID_EXPIRE_TIME);\n+      }\n+\n+    } else if (optionalParametersStrings.contains(\"EX\")) {\n+      String nextParameter =\n+          getNextParameter(\"EX\", optionalParametersStrings);\n+      if (!isANumber(nextParameter)) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+      expiration = parseExpirationTime(\"EX\", nextParameter);\n+      if (expiration <= 0) {\n+        throw new IllegalArgumentException(ERROR_INVALID_EXPIRE_TIME);\n       }\n     }\n \n+    if (optionalParametersStrings.contains(\"NX\")) {\n+      existsOption = SetOptions.Exists.NX;\n+    } else if (optionalParametersStrings.contains(\"XX\")) {\n+      existsOption = SetOptions.Exists.XX;\n+    }\n     return new SetOptions(existsOption, expiration, keepTTL);\n   }\n \n-  private long parseExpirationTime(int index, List<byte[]> commandElems)\n-      throws IllegalArgumentException {\n-    String expirationString;\n+  private String getNextParameter(String currentParameter,\n+      List<String> optionalParametersStrings) {\n+    int index = optionalParametersStrings.indexOf(currentParameter);\n+    if (optionalParametersStrings.size() <= index + 1) {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+    return optionalParametersStrings.get(index + 1);\n+  }\n+\n+  private void throwExceptionIfUnknownParameter(List<String> optionalParameters) {\n+    List<String> validOptionalParamaters = Arrays.asList(\"EX\", \"PX\", \"NX\", \"XX\", \"KEEPTL\");\n+\n+    List<String> parametersInQuestion =\n+        optionalParameters\n+            .stream()\n+            .filter(parameter -> (!validOptionalParamaters.contains(parameter)))\n+            .collect(Collectors.toList());\n+\n+    parametersInQuestion.forEach(parameter -> throwErrorIfNotANumberInExpectedPosition(\n+        parameter,\n+        optionalParameters));\n+  }\n+\n+  private void throwErrorIfNotANumberInExpectedPosition(\n+      String parameter,\n+      List<String> optionalParameters) {\n+\n+    if (previousOptionIsValidAndExpectsANumber(parameter, optionalParameters)) {\n+      convertToLongOrThrowException(parameter);\n+    } else {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+  }\n \n+  private boolean isANumber(String parameter) {\n     try {\n-      expirationString = Coder.bytesToString(commandElems.get(index));\n-    } catch (IndexOutOfBoundsException e) {\n+      Long.parseLong(parameter);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d1ac779762f879de28bbee4a8f9ad0803357b7c"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1Nzc3Nw==", "bodyText": "The old code used ERROR_NOT_INTEGER if it was not a number. You have changed that to ERROR_SYNTAX", "url": "https://github.com/apache/geode/pull/5216#discussion_r438457777", "createdAt": "2020-06-10T23:16:19Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "diffHunk": "@@ -35,105 +37,182 @@\n   public RedisResponse executeCommandWithResponse(Command command,\n       ExecutionHandlerContext context) {\n \n-    List<byte[]> commandElems = command.getProcessedCommand();\n     ByteArrayWrapper keyToSet = command.getKey();\n-    ByteArrayWrapper valueToSet = getValueToSet(commandElems);\n-\n+    List<byte[]> commandElementsBytes = command.getProcessedCommand();\n+    List<byte[]> optionalParameterBytes = getOptionalParameters(commandElementsBytes);\n+    ByteArrayWrapper valueToSet = getValueToSet(commandElementsBytes);\n     RedisStringCommands redisStringCommands = getRedisStringCommands(context);\n     SetOptions setOptions;\n+\n     try {\n-      setOptions = parseCommandElems(commandElems);\n+      setOptions = parseOptionalParameters(optionalParameterBytes);\n     } catch (IllegalArgumentException ex) {\n       return RedisResponse.error(ex.getMessage());\n     }\n \n-    return doSet(command, context, keyToSet, valueToSet, redisStringCommands, setOptions);\n+    return doSet(keyToSet, valueToSet, redisStringCommands, setOptions);\n+  }\n+\n+  private List<byte[]> getOptionalParameters(List<byte[]> commandElementsBytes) {\n+    return commandElementsBytes.subList(3, commandElementsBytes.size());\n   }\n \n-  private RedisResponse doSet(Command command, ExecutionHandlerContext context,\n-      ByteArrayWrapper key,\n-      ByteArrayWrapper value, RedisStringCommands redisStringCommands, SetOptions setOptions) {\n+  private RedisResponse doSet(ByteArrayWrapper key,\n+      ByteArrayWrapper value,\n+      RedisStringCommands redisStringCommands,\n+      SetOptions setOptions) {\n \n-    boolean result = redisStringCommands.set(key, value, setOptions);\n+    boolean setCompletedSuccessfully = redisStringCommands.set(key, value, setOptions);\n \n-    if (result) {\n+    if (setCompletedSuccessfully) {\n       return RedisResponse.string(SUCCESS);\n+    } else {\n+      return RedisResponse.nil();\n     }\n-\n-    return RedisResponse.nil();\n   }\n \n   private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n     byte[] value = commandElems.get(2);\n     return new ByteArrayWrapper(value);\n   }\n \n+  private SetOptions parseOptionalParameters(List<byte[]> optionalParameterBytes)\n+      throws IllegalArgumentException {\n \n-  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {\n     boolean keepTTL = false;\n     SetOptions.Exists existsOption = SetOptions.Exists.NONE;\n     long expiration = 0L;\n \n-    for (int i = 3; i < commandElems.size(); i++) {\n-      String current_arg = Coder.bytesToString(commandElems.get(i)).toUpperCase();\n-      switch (current_arg) {\n-        case \"KEEPTTL\":\n-          keepTTL = true;\n-          break;\n-        case \"EX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          expiration = SECONDS.toMillis(expiration);\n-          break;\n-        case \"PX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          break;\n-        case \"NX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.NX;\n-          break;\n-        case \"XX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.XX;\n-          break;\n-        default:\n-          throw new IllegalArgumentException(ERROR_SYNTAX);\n+    List<String> optionalParametersStrings =\n+        optionalParameterBytes.stream()\n+            .map(item -> Coder.bytesToString(item).toUpperCase())\n+            .collect(Collectors.toList());\n+\n+    throwExceptionIfUnknownParameter(optionalParametersStrings);\n+    throwExceptionIfIncompatableParamaterOptions(optionalParametersStrings);\n+    keepTTL = optionalParametersStrings.contains(\"KEEPTL\");\n+\n+    if (optionalParametersStrings.contains(\"PX\")) {\n+      String nextParameter =\n+          getNextParameter(\"PX\", optionalParametersStrings);\n+\n+      if (!isANumber(nextParameter)) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+\n+      expiration = parseExpirationTime(\"PX\", nextParameter);\n+      if (expiration <= 0) {\n+        throw new IllegalArgumentException(ERROR_INVALID_EXPIRE_TIME);\n+      }\n+\n+    } else if (optionalParametersStrings.contains(\"EX\")) {\n+      String nextParameter =\n+          getNextParameter(\"EX\", optionalParametersStrings);\n+      if (!isANumber(nextParameter)) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d1ac779762f879de28bbee4a8f9ad0803357b7c"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1ODc3NQ==", "bodyText": "I think it would be better to do this in the caller that does this for EX. Then you don't need to pass expirationParameter to this method. Its job is just parsing.", "url": "https://github.com/apache/geode/pull/5216#discussion_r438458775", "createdAt": "2020-06-10T23:19:46Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "diffHunk": "@@ -35,105 +37,182 @@\n   public RedisResponse executeCommandWithResponse(Command command,\n       ExecutionHandlerContext context) {\n \n-    List<byte[]> commandElems = command.getProcessedCommand();\n     ByteArrayWrapper keyToSet = command.getKey();\n-    ByteArrayWrapper valueToSet = getValueToSet(commandElems);\n-\n+    List<byte[]> commandElementsBytes = command.getProcessedCommand();\n+    List<byte[]> optionalParameterBytes = getOptionalParameters(commandElementsBytes);\n+    ByteArrayWrapper valueToSet = getValueToSet(commandElementsBytes);\n     RedisStringCommands redisStringCommands = getRedisStringCommands(context);\n     SetOptions setOptions;\n+\n     try {\n-      setOptions = parseCommandElems(commandElems);\n+      setOptions = parseOptionalParameters(optionalParameterBytes);\n     } catch (IllegalArgumentException ex) {\n       return RedisResponse.error(ex.getMessage());\n     }\n \n-    return doSet(command, context, keyToSet, valueToSet, redisStringCommands, setOptions);\n+    return doSet(keyToSet, valueToSet, redisStringCommands, setOptions);\n+  }\n+\n+  private List<byte[]> getOptionalParameters(List<byte[]> commandElementsBytes) {\n+    return commandElementsBytes.subList(3, commandElementsBytes.size());\n   }\n \n-  private RedisResponse doSet(Command command, ExecutionHandlerContext context,\n-      ByteArrayWrapper key,\n-      ByteArrayWrapper value, RedisStringCommands redisStringCommands, SetOptions setOptions) {\n+  private RedisResponse doSet(ByteArrayWrapper key,\n+      ByteArrayWrapper value,\n+      RedisStringCommands redisStringCommands,\n+      SetOptions setOptions) {\n \n-    boolean result = redisStringCommands.set(key, value, setOptions);\n+    boolean setCompletedSuccessfully = redisStringCommands.set(key, value, setOptions);\n \n-    if (result) {\n+    if (setCompletedSuccessfully) {\n       return RedisResponse.string(SUCCESS);\n+    } else {\n+      return RedisResponse.nil();\n     }\n-\n-    return RedisResponse.nil();\n   }\n \n   private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n     byte[] value = commandElems.get(2);\n     return new ByteArrayWrapper(value);\n   }\n \n+  private SetOptions parseOptionalParameters(List<byte[]> optionalParameterBytes)\n+      throws IllegalArgumentException {\n \n-  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {\n     boolean keepTTL = false;\n     SetOptions.Exists existsOption = SetOptions.Exists.NONE;\n     long expiration = 0L;\n \n-    for (int i = 3; i < commandElems.size(); i++) {\n-      String current_arg = Coder.bytesToString(commandElems.get(i)).toUpperCase();\n-      switch (current_arg) {\n-        case \"KEEPTTL\":\n-          keepTTL = true;\n-          break;\n-        case \"EX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          expiration = SECONDS.toMillis(expiration);\n-          break;\n-        case \"PX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          break;\n-        case \"NX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.NX;\n-          break;\n-        case \"XX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.XX;\n-          break;\n-        default:\n-          throw new IllegalArgumentException(ERROR_SYNTAX);\n+    List<String> optionalParametersStrings =\n+        optionalParameterBytes.stream()\n+            .map(item -> Coder.bytesToString(item).toUpperCase())\n+            .collect(Collectors.toList());\n+\n+    throwExceptionIfUnknownParameter(optionalParametersStrings);\n+    throwExceptionIfIncompatableParamaterOptions(optionalParametersStrings);\n+    keepTTL = optionalParametersStrings.contains(\"KEEPTL\");\n+\n+    if (optionalParametersStrings.contains(\"PX\")) {\n+      String nextParameter =\n+          getNextParameter(\"PX\", optionalParametersStrings);\n+\n+      if (!isANumber(nextParameter)) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+\n+      expiration = parseExpirationTime(\"PX\", nextParameter);\n+      if (expiration <= 0) {\n+        throw new IllegalArgumentException(ERROR_INVALID_EXPIRE_TIME);\n+      }\n+\n+    } else if (optionalParametersStrings.contains(\"EX\")) {\n+      String nextParameter =\n+          getNextParameter(\"EX\", optionalParametersStrings);\n+      if (!isANumber(nextParameter)) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+      expiration = parseExpirationTime(\"EX\", nextParameter);\n+      if (expiration <= 0) {\n+        throw new IllegalArgumentException(ERROR_INVALID_EXPIRE_TIME);\n       }\n     }\n \n+    if (optionalParametersStrings.contains(\"NX\")) {\n+      existsOption = SetOptions.Exists.NX;\n+    } else if (optionalParametersStrings.contains(\"XX\")) {\n+      existsOption = SetOptions.Exists.XX;\n+    }\n     return new SetOptions(existsOption, expiration, keepTTL);\n   }\n \n-  private long parseExpirationTime(int index, List<byte[]> commandElems)\n-      throws IllegalArgumentException {\n-    String expirationString;\n+  private String getNextParameter(String currentParameter,\n+      List<String> optionalParametersStrings) {\n+    int index = optionalParametersStrings.indexOf(currentParameter);\n+    if (optionalParametersStrings.size() <= index + 1) {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+    return optionalParametersStrings.get(index + 1);\n+  }\n+\n+  private void throwExceptionIfUnknownParameter(List<String> optionalParameters) {\n+    List<String> validOptionalParamaters = Arrays.asList(\"EX\", \"PX\", \"NX\", \"XX\", \"KEEPTL\");\n+\n+    List<String> parametersInQuestion =\n+        optionalParameters\n+            .stream()\n+            .filter(parameter -> (!validOptionalParamaters.contains(parameter)))\n+            .collect(Collectors.toList());\n+\n+    parametersInQuestion.forEach(parameter -> throwErrorIfNotANumberInExpectedPosition(\n+        parameter,\n+        optionalParameters));\n+  }\n+\n+  private void throwErrorIfNotANumberInExpectedPosition(\n+      String parameter,\n+      List<String> optionalParameters) {\n+\n+    if (previousOptionIsValidAndExpectsANumber(parameter, optionalParameters)) {\n+      convertToLongOrThrowException(parameter);\n+    } else {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+  }\n \n+  private boolean isANumber(String parameter) {\n     try {\n-      expirationString = Coder.bytesToString(commandElems.get(index));\n-    } catch (IndexOutOfBoundsException e) {\n+      Long.parseLong(parameter);\n+      return true;\n+    } catch (NumberFormatException e) {\n+      return false;\n+    }\n+  }\n+\n+  private boolean previousOptionIsValidAndExpectsANumber(String paramter,\n+      List<String> optionalParameters) {\n+\n+    List<String> validParamaters = Arrays.asList(\"EX\", \"PX\");\n+    if (optionalParameters.size() < 2) {\n+      return false;\n+    }\n+\n+    int indexOfParameter = optionalParameters.indexOf(paramter);\n+    String previousParameter = optionalParameters.get(indexOfParameter - 1);\n+\n+    return validParamaters.contains(previousParameter);\n+  }\n+\n+\n+  private void throwExceptionIfIncompatableParamaterOptions(List<String> passedParametersStrings) {\n+\n+    if (passedParametersStrings.contains(\"PX\")\n+        && passedParametersStrings.contains(\"EX\")) {\n       throw new IllegalArgumentException(ERROR_SYNTAX);\n     }\n \n+    if (passedParametersStrings.contains(\"XX\")\n+        && passedParametersStrings.contains(\"NX\")) {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+  }\n+\n+  private long parseExpirationTime(String expirationParameter, String timeUntilExpiration) {\n+\n+    long millisecondsUntilExpirationLong =\n+        Long.parseLong(timeUntilExpiration);\n+\n+    if (expirationParameter.equals(\"EX\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d1ac779762f879de28bbee4a8f9ad0803357b7c"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2MDEwOA==", "bodyText": "so actually it parses the long three times! If you are going to do it here then you should have it also fill a HashMap whose keys are the option that expects a number and whose value is the number. Then this could be used later instead of parsing again.", "url": "https://github.com/apache/geode/pull/5216#discussion_r438460108", "createdAt": "2020-06-10T23:24:13Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/SetExecutor.java", "diffHunk": "@@ -35,105 +37,182 @@\n   public RedisResponse executeCommandWithResponse(Command command,\n       ExecutionHandlerContext context) {\n \n-    List<byte[]> commandElems = command.getProcessedCommand();\n     ByteArrayWrapper keyToSet = command.getKey();\n-    ByteArrayWrapper valueToSet = getValueToSet(commandElems);\n-\n+    List<byte[]> commandElementsBytes = command.getProcessedCommand();\n+    List<byte[]> optionalParameterBytes = getOptionalParameters(commandElementsBytes);\n+    ByteArrayWrapper valueToSet = getValueToSet(commandElementsBytes);\n     RedisStringCommands redisStringCommands = getRedisStringCommands(context);\n     SetOptions setOptions;\n+\n     try {\n-      setOptions = parseCommandElems(commandElems);\n+      setOptions = parseOptionalParameters(optionalParameterBytes);\n     } catch (IllegalArgumentException ex) {\n       return RedisResponse.error(ex.getMessage());\n     }\n \n-    return doSet(command, context, keyToSet, valueToSet, redisStringCommands, setOptions);\n+    return doSet(keyToSet, valueToSet, redisStringCommands, setOptions);\n+  }\n+\n+  private List<byte[]> getOptionalParameters(List<byte[]> commandElementsBytes) {\n+    return commandElementsBytes.subList(3, commandElementsBytes.size());\n   }\n \n-  private RedisResponse doSet(Command command, ExecutionHandlerContext context,\n-      ByteArrayWrapper key,\n-      ByteArrayWrapper value, RedisStringCommands redisStringCommands, SetOptions setOptions) {\n+  private RedisResponse doSet(ByteArrayWrapper key,\n+      ByteArrayWrapper value,\n+      RedisStringCommands redisStringCommands,\n+      SetOptions setOptions) {\n \n-    boolean result = redisStringCommands.set(key, value, setOptions);\n+    boolean setCompletedSuccessfully = redisStringCommands.set(key, value, setOptions);\n \n-    if (result) {\n+    if (setCompletedSuccessfully) {\n       return RedisResponse.string(SUCCESS);\n+    } else {\n+      return RedisResponse.nil();\n     }\n-\n-    return RedisResponse.nil();\n   }\n \n   private ByteArrayWrapper getValueToSet(List<byte[]> commandElems) {\n     byte[] value = commandElems.get(2);\n     return new ByteArrayWrapper(value);\n   }\n \n+  private SetOptions parseOptionalParameters(List<byte[]> optionalParameterBytes)\n+      throws IllegalArgumentException {\n \n-  private SetOptions parseCommandElems(List<byte[]> commandElems) throws IllegalArgumentException {\n     boolean keepTTL = false;\n     SetOptions.Exists existsOption = SetOptions.Exists.NONE;\n     long expiration = 0L;\n \n-    for (int i = 3; i < commandElems.size(); i++) {\n-      String current_arg = Coder.bytesToString(commandElems.get(i)).toUpperCase();\n-      switch (current_arg) {\n-        case \"KEEPTTL\":\n-          keepTTL = true;\n-          break;\n-        case \"EX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          expiration = SECONDS.toMillis(expiration);\n-          break;\n-        case \"PX\":\n-          if (expiration != 0) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          i++;\n-          expiration = parseExpirationTime(i, commandElems);\n-          break;\n-        case \"NX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.NX;\n-          break;\n-        case \"XX\":\n-          if (existsOption != SetOptions.Exists.NONE) {\n-            throw new IllegalArgumentException(ERROR_SYNTAX);\n-          }\n-          existsOption = SetOptions.Exists.XX;\n-          break;\n-        default:\n-          throw new IllegalArgumentException(ERROR_SYNTAX);\n+    List<String> optionalParametersStrings =\n+        optionalParameterBytes.stream()\n+            .map(item -> Coder.bytesToString(item).toUpperCase())\n+            .collect(Collectors.toList());\n+\n+    throwExceptionIfUnknownParameter(optionalParametersStrings);\n+    throwExceptionIfIncompatableParamaterOptions(optionalParametersStrings);\n+    keepTTL = optionalParametersStrings.contains(\"KEEPTL\");\n+\n+    if (optionalParametersStrings.contains(\"PX\")) {\n+      String nextParameter =\n+          getNextParameter(\"PX\", optionalParametersStrings);\n+\n+      if (!isANumber(nextParameter)) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+\n+      expiration = parseExpirationTime(\"PX\", nextParameter);\n+      if (expiration <= 0) {\n+        throw new IllegalArgumentException(ERROR_INVALID_EXPIRE_TIME);\n+      }\n+\n+    } else if (optionalParametersStrings.contains(\"EX\")) {\n+      String nextParameter =\n+          getNextParameter(\"EX\", optionalParametersStrings);\n+      if (!isANumber(nextParameter)) {\n+        throw new IllegalArgumentException(ERROR_SYNTAX);\n+      }\n+      expiration = parseExpirationTime(\"EX\", nextParameter);\n+      if (expiration <= 0) {\n+        throw new IllegalArgumentException(ERROR_INVALID_EXPIRE_TIME);\n       }\n     }\n \n+    if (optionalParametersStrings.contains(\"NX\")) {\n+      existsOption = SetOptions.Exists.NX;\n+    } else if (optionalParametersStrings.contains(\"XX\")) {\n+      existsOption = SetOptions.Exists.XX;\n+    }\n     return new SetOptions(existsOption, expiration, keepTTL);\n   }\n \n-  private long parseExpirationTime(int index, List<byte[]> commandElems)\n-      throws IllegalArgumentException {\n-    String expirationString;\n+  private String getNextParameter(String currentParameter,\n+      List<String> optionalParametersStrings) {\n+    int index = optionalParametersStrings.indexOf(currentParameter);\n+    if (optionalParametersStrings.size() <= index + 1) {\n+      throw new IllegalArgumentException(ERROR_SYNTAX);\n+    }\n+    return optionalParametersStrings.get(index + 1);\n+  }\n+\n+  private void throwExceptionIfUnknownParameter(List<String> optionalParameters) {\n+    List<String> validOptionalParamaters = Arrays.asList(\"EX\", \"PX\", \"NX\", \"XX\", \"KEEPTL\");\n+\n+    List<String> parametersInQuestion =\n+        optionalParameters\n+            .stream()\n+            .filter(parameter -> (!validOptionalParamaters.contains(parameter)))\n+            .collect(Collectors.toList());\n+\n+    parametersInQuestion.forEach(parameter -> throwErrorIfNotANumberInExpectedPosition(\n+        parameter,\n+        optionalParameters));\n+  }\n+\n+  private void throwErrorIfNotANumberInExpectedPosition(\n+      String parameter,\n+      List<String> optionalParameters) {\n+\n+    if (previousOptionIsValidAndExpectsANumber(parameter, optionalParameters)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d1ac779762f879de28bbee4a8f9ad0803357b7c"}, "originalPosition": 180}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3d1ac779762f879de28bbee4a8f9ad0803357b7c", "author": {"user": {"login": "jhutchison", "name": "John Hutchison"}}, "url": "https://github.com/apache/geode/commit/3d1ac779762f879de28bbee4a8f9ad0803357b7c", "committedDate": "2020-06-10T20:33:39Z", "message": "trigger ci"}, "afterCommit": {"oid": "d732d3182b9bf82b303a6d835fe611b40f56e31d", "author": {"user": {"login": "jhutchison", "name": "John Hutchison"}}, "url": "https://github.com/apache/geode/commit/d732d3182b9bf82b303a6d835fe611b40f56e31d", "committedDate": "2020-06-11T22:08:29Z", "message": "add additional changes in setExecutor suggested in review"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwODY3ODIw", "url": "https://github.com/apache/geode/pull/5216#pullrequestreview-430867820", "createdAt": "2020-06-15T17:54:06Z", "commit": {"oid": "d732d3182b9bf82b303a6d835fe611b40f56e31d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNzo1NDowNlrOGj8q_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNzo1NDowNlrOGj8q_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0NzM5MQ==", "bodyText": "The changes here look like an incorrect merge perhaps.", "url": "https://github.com/apache/geode/pull/5216#discussion_r440347391", "createdAt": "2020-06-15T17:54:06Z", "author": {"login": "jdeppe-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/key/RenameExecutor.java", "diffHunk": "@@ -16,34 +16,35 @@\n \n package org.apache.geode.redis.internal.executor.key;\n \n-import static org.apache.geode.redis.internal.RedisConstants.ERROR_NO_SUCH_KEY;\n-\n import java.util.List;\n \n+import org.apache.geode.redis.internal.RedisConstants;\n import org.apache.geode.redis.internal.data.ByteArrayWrapper;\n import org.apache.geode.redis.internal.executor.AbstractExecutor;\n-import org.apache.geode.redis.internal.executor.RedisResponse;\n+import org.apache.geode.redis.internal.netty.Coder;\n import org.apache.geode.redis.internal.netty.Command;\n import org.apache.geode.redis.internal.netty.ExecutionHandlerContext;\n \n public class RenameExecutor extends AbstractExecutor {\n-\n   @Override\n-  public RedisResponse executeCommand(Command command,\n-      ExecutionHandlerContext context) {\n+  public void executeCommand(Command command, ExecutionHandlerContext context) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d732d3182b9bf82b303a6d835fe611b40f56e31d"}, "originalPosition": 21}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d732d3182b9bf82b303a6d835fe611b40f56e31d", "author": {"user": {"login": "jhutchison", "name": "John Hutchison"}}, "url": "https://github.com/apache/geode/commit/d732d3182b9bf82b303a6d835fe611b40f56e31d", "committedDate": "2020-06-11T22:08:29Z", "message": "add additional changes in setExecutor suggested in review"}, "afterCommit": {"oid": "27bda5ccf373665dccee5dfa10fd17bb4eb8ef4a", "author": {"user": {"login": "jhutchison", "name": "John Hutchison"}}, "url": "https://github.com/apache/geode/commit/27bda5ccf373665dccee5dfa10fd17bb4eb8ef4a", "committedDate": "2020-06-15T20:51:53Z", "message": "add additional changes in setExecutor suggested in review"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "35fb45d2cd277cddb4655a6c40d0e2f96d220e6a", "author": {"user": {"login": "jhutchison", "name": "John Hutchison"}}, "url": "https://github.com/apache/geode/commit/35fb45d2cd277cddb4655a6c40d0e2f96d220e6a", "committedDate": "2020-06-15T21:23:36Z", "message": "correct merge error"}, "afterCommit": {"oid": "bb8aecfa37b3d69213218765cf6f0315f8cdb463", "author": {"user": {"login": "jhutchison", "name": "John Hutchison"}}, "url": "https://github.com/apache/geode/commit/bb8aecfa37b3d69213218765cf6f0315f8cdb463", "committedDate": "2020-06-17T17:47:14Z", "message": "correct merge error"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bb8aecfa37b3d69213218765cf6f0315f8cdb463", "author": {"user": {"login": "jhutchison", "name": "John Hutchison"}}, "url": "https://github.com/apache/geode/commit/bb8aecfa37b3d69213218765cf6f0315f8cdb463", "committedDate": "2020-06-17T17:47:14Z", "message": "correct merge error"}, "afterCommit": {"oid": "b43c69b645b9547b836907c3de0b498d73f53646", "author": {"user": {"login": "jhutchison", "name": "John Hutchison"}}, "url": "https://github.com/apache/geode/commit/b43c69b645b9547b836907c3de0b498d73f53646", "committedDate": "2020-06-18T18:24:35Z", "message": "resolve merge conflict"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzU0MDc4", "url": "https://github.com/apache/geode/pull/5216#pullrequestreview-433754078", "createdAt": "2020-06-19T01:55:07Z", "commit": {"oid": "b43c69b645b9547b836907c3de0b498d73f53646"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b43c69b645b9547b836907c3de0b498d73f53646", "author": {"user": {"login": "jhutchison", "name": "John Hutchison"}}, "url": "https://github.com/apache/geode/commit/b43c69b645b9547b836907c3de0b498d73f53646", "committedDate": "2020-06-18T18:24:35Z", "message": "resolve merge conflict"}, "afterCommit": {"oid": "a445d1550e80682e969ab8770b7f9ce88924779d", "author": {"user": {"login": "jhutchison", "name": "John Hutchison"}}, "url": "https://github.com/apache/geode/commit/a445d1550e80682e969ab8770b7f9ce88924779d", "committedDate": "2020-06-19T23:11:57Z", "message": "add requested test; change code to make test pass"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a445d1550e80682e969ab8770b7f9ce88924779d", "author": {"user": {"login": "jhutchison", "name": "John Hutchison"}}, "url": "https://github.com/apache/geode/commit/a445d1550e80682e969ab8770b7f9ce88924779d", "committedDate": "2020-06-19T23:11:57Z", "message": "add requested test; change code to make test pass"}, "afterCommit": {"oid": "2026a5f7bab748cc1f4daef606276ff2e868f206", "author": {"user": {"login": "jhutchison", "name": "John Hutchison"}}, "url": "https://github.com/apache/geode/commit/2026a5f7bab748cc1f4daef606276ff2e868f206", "committedDate": "2020-06-22T18:36:43Z", "message": "add requested test; change code to make test pass"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2OTMwNDk3", "url": "https://github.com/apache/geode/pull/5216#pullrequestreview-436930497", "createdAt": "2020-06-24T19:09:42Z", "commit": {"oid": "2026a5f7bab748cc1f4daef606276ff2e868f206"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxOTowOTo0MlrOGofdXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxOToxMTo1NVrOGofiDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTExMTY0Nw==", "bodyText": "It looks like you may have actually brought StringsIntegrationTest back to life. I think it has been removed from develop and split up into multiple, command focused tests. We now have a SetIntegrationTest so amy tests for SET that you added to this class should now be added to it instead.", "url": "https://github.com/apache/geode/pull/5216#discussion_r445111647", "createdAt": "2020-06-24T19:09:42Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/integrationTest/java/org/apache/geode/redis/internal/executor/string/StringsIntegrationTest.java", "diffHunk": "@@ -0,0 +1,1637 @@\n+/*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2026a5f7bab748cc1f4daef606276ff2e868f206"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTExMjg0NA==", "bodyText": "I'm not sure these tests should be added here. If you added them instead to SetIntegrationTest then I'd feel better because they would also run against native redis.", "url": "https://github.com/apache/geode/pull/5216#discussion_r445112844", "createdAt": "2020-06-24T19:11:55Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/test/java/org/apache/geode/redis/internal/executor/string/StringSetExecutorJUnitTest.java", "diffHunk": "@@ -213,4 +229,34 @@ public void testSET_XXandNX_inSameCommand_ReturnsError() {\n     assertThat(response.toString()).contains(RedisConstants.ERROR_SYNTAX);\n   }\n \n+  @Test\n+  public void testSET_unknownOption_ReturnsError() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2026a5f7bab748cc1f4daef606276ff2e868f206"}, "originalPosition": 59}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2026a5f7bab748cc1f4daef606276ff2e868f206", "author": {"user": {"login": "jhutchison", "name": "John Hutchison"}}, "url": "https://github.com/apache/geode/commit/2026a5f7bab748cc1f4daef606276ff2e868f206", "committedDate": "2020-06-22T18:36:43Z", "message": "add requested test; change code to make test pass"}, "afterCommit": {"oid": "6962ca222c835a6d59fafc9d6447c19d35f22fd6", "author": {"user": {"login": "jhutchison", "name": "John Hutchison"}}, "url": "https://github.com/apache/geode/commit/6962ca222c835a6d59fafc9d6447c19d35f22fd6", "committedDate": "2020-06-24T22:21:12Z", "message": "tests moved to strings/setintegrationTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f8913ed3e490b59eea20be630539fae9335800e8", "author": {"user": {"login": "jhutchison", "name": "John Hutchison"}}, "url": "https://github.com/apache/geode/commit/f8913ed3e490b59eea20be630539fae9335800e8", "committedDate": "2020-06-25T18:23:52Z", "message": "refactor SetExecutor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5914019b99d1a9239d8ffa9d13bcb38f69506b59", "author": {"user": {"login": "jhutchison", "name": "John Hutchison"}}, "url": "https://github.com/apache/geode/commit/5914019b99d1a9239d8ffa9d13bcb38f69506b59", "committedDate": "2020-06-25T18:23:52Z", "message": "add additional changes in setExecutor suggested in review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5521fe07c537e6f8db39022e32938018a9a3ef53", "author": {"user": {"login": "jhutchison", "name": "John Hutchison"}}, "url": "https://github.com/apache/geode/commit/5521fe07c537e6f8db39022e32938018a9a3ef53", "committedDate": "2020-06-25T18:23:52Z", "message": "correct merge error"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "49e7f7a9de0faab173d2dff96c35e5572be5ff8a", "author": {"user": {"login": "jhutchison", "name": "John Hutchison"}}, "url": "https://github.com/apache/geode/commit/49e7f7a9de0faab173d2dff96c35e5572be5ff8a", "committedDate": "2020-06-25T18:23:52Z", "message": "resolve merge conflict"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68475af8cc1bf259f66eba377606edbd361ae494", "author": {"user": {"login": "jhutchison", "name": "John Hutchison"}}, "url": "https://github.com/apache/geode/commit/68475af8cc1bf259f66eba377606edbd361ae494", "committedDate": "2020-06-25T18:23:52Z", "message": "add requested test; change code to make test pass"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "67830fe248f71923cdfab7c91f6a730ced1e71cc", "author": {"user": {"login": "jhutchison", "name": "John Hutchison"}}, "url": "https://github.com/apache/geode/commit/67830fe248f71923cdfab7c91f6a730ced1e71cc", "committedDate": "2020-06-25T18:23:52Z", "message": "tests moved to strings/setintegrationTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d00b08c438a3480e477a09a48774d3a918ad6456", "author": {"user": {"login": "jhutchison", "name": "John Hutchison"}}, "url": "https://github.com/apache/geode/commit/d00b08c438a3480e477a09a48774d3a918ad6456", "committedDate": "2020-06-25T18:24:36Z", "message": "retrigger ci after unrelated flaky test failure"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6962ca222c835a6d59fafc9d6447c19d35f22fd6", "author": {"user": {"login": "jhutchison", "name": "John Hutchison"}}, "url": "https://github.com/apache/geode/commit/6962ca222c835a6d59fafc9d6447c19d35f22fd6", "committedDate": "2020-06-24T22:21:12Z", "message": "tests moved to strings/setintegrationTest"}, "afterCommit": {"oid": "d00b08c438a3480e477a09a48774d3a918ad6456", "author": {"user": {"login": "jhutchison", "name": "John Hutchison"}}, "url": "https://github.com/apache/geode/commit/d00b08c438a3480e477a09a48774d3a918ad6456", "committedDate": "2020-06-25T18:24:36Z", "message": "retrigger ci after unrelated flaky test failure"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3OTM3NjMz", "url": "https://github.com/apache/geode/pull/5216#pullrequestreview-437937633", "createdAt": "2020-06-26T00:08:14Z", "commit": {"oid": "d00b08c438a3480e477a09a48774d3a918ad6456"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3OTUwNDk1", "url": "https://github.com/apache/geode/pull/5216#pullrequestreview-437950495", "createdAt": "2020-06-26T00:53:22Z", "commit": {"oid": "d00b08c438a3480e477a09a48774d3a918ad6456"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4433, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}