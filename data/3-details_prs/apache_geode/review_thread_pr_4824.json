{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkwNDg3Nzk0", "number": 4824, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNzo1Mjo1MVrODrw6rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMzoyODo1M1rODvV4aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MjE2ODE0OnYy", "diffSide": "RIGHT", "path": "geode-core/src/integrationTest/java/org/apache/geode/cache/client/internal/ConnectionPoolImplJUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNzo1Mjo1MVrOF8TQNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxODoyNDoyNFrOF8UmYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc3NDMyNg==", "bodyText": "why is this timeout needed?", "url": "https://github.com/apache/geode/pull/4824#discussion_r398774326", "createdAt": "2020-03-26T17:52:51Z", "author": {"login": "bschuchardt"}, "path": "geode-core/src/integrationTest/java/org/apache/geode/cache/client/internal/ConnectionPoolImplJUnitTest.java", "diffHunk": "@@ -168,7 +168,7 @@ public void testCacheClose() throws Exception {\n     assertTrue(pool2.isDestroyed());\n   }\n \n-  @Test\n+  @Test(timeout = 5000)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0968b2e9bf7e6a3f3b46cf0f779cff3f8bc2dcac"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc5NjM4Ng==", "bodyText": "This test case enters in a infinite loop, I still have to fix it. This timeout is a temporary workaround to make it fail, so the CI can at least finish.", "url": "https://github.com/apache/geode/pull/4824#discussion_r398796386", "createdAt": "2020-03-26T18:24:24Z", "author": {"login": "alb3rtobr"}, "path": "geode-core/src/integrationTest/java/org/apache/geode/cache/client/internal/ConnectionPoolImplJUnitTest.java", "diffHunk": "@@ -168,7 +168,7 @@ public void testCacheClose() throws Exception {\n     assertTrue(pool2.isDestroyed());\n   }\n \n-  @Test\n+  @Test(timeout = 5000)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc3NDMyNg=="}, "originalCommit": {"oid": "0968b2e9bf7e6a3f3b46cf0f779cff3f8bc2dcac"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3NTY4NTgyOnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/cache/client/internal/EndpointManagerImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNDo1MzoxNFrOF80uGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNTozODoyMFrOF82slA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMyMjY1MQ==", "bodyText": "This is what is causing the ConnectionPoolImplJUnitTest failure.  That test creates two servers and a pool in the same JVM, so both servers have the same membership ID.  If you delete that test and replace it with a distributedTest that creates the servers in different JVMs it ought to pass.", "url": "https://github.com/apache/geode/pull/4824#discussion_r399322651", "createdAt": "2020-03-27T14:53:14Z", "author": {"login": "bschuchardt"}, "path": "geode-core/src/main/java/org/apache/geode/cache/client/internal/EndpointManagerImpl.java", "diffHunk": "@@ -56,17 +56,17 @@ public EndpointManagerImpl(String poolName, DistributedSystem ds, CancelCriterio\n \n   @Override\n   public Endpoint referenceEndpoint(ServerLocation server, DistributedMember memberId) {\n-    Endpoint endpoint = endpointMap.get(server);\n+    Endpoint endpoint = endpointMap.get(memberId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8b6d0699de08c5ef9962e1614a692eb54e76a72"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM1NTAyOA==", "bodyText": "Actually I think this is a problem that needs to be brought to the dev email list.  Either the PR needs to change or we need to disallow creating multiple CacheServers in the same cache.", "url": "https://github.com/apache/geode/pull/4824#discussion_r399355028", "createdAt": "2020-03-27T15:38:20Z", "author": {"login": "bschuchardt"}, "path": "geode-core/src/main/java/org/apache/geode/cache/client/internal/EndpointManagerImpl.java", "diffHunk": "@@ -56,17 +56,17 @@ public EndpointManagerImpl(String poolName, DistributedSystem ds, CancelCriterio\n \n   @Override\n   public Endpoint referenceEndpoint(ServerLocation server, DistributedMember memberId) {\n-    Endpoint endpoint = endpointMap.get(server);\n+    Endpoint endpoint = endpointMap.get(memberId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMyMjY1MQ=="}, "originalCommit": {"oid": "d8b6d0699de08c5ef9962e1614a692eb54e76a72"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwOTYzNzU4OnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/LocatorLoadSnapshot.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMzowOToxM1rOGBtLLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMDozNToxOVrOGB9Zhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ0MTkwMA==", "bodyText": "It looks like this is only used by tests, is that right? It might be better to remove this method, which uses and incorrect memberId of \"\"", "url": "https://github.com/apache/geode/pull/4824#discussion_r404441900", "createdAt": "2020-04-06T23:09:13Z", "author": {"login": "upthewaterspout"}, "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/LocatorLoadSnapshot.java", "diffHunk": "@@ -85,49 +86,52 @@ public LocatorLoadSnapshot() {\n   }\n \n   public void addServer(ServerLocation location, String[] groups, ServerLoad initialLoad) {\n-    addServer(location, groups, initialLoad, 30000);\n+    addServer(location, \"\", groups, initialLoad, 30000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "517d6f6a3046fe08778aedacf9a8f88365e75799"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcwNzcxOA==", "bodyText": "I have just added a commit to fix this.", "url": "https://github.com/apache/geode/pull/4824#discussion_r404707718", "createdAt": "2020-04-07T10:35:19Z", "author": {"login": "alb3rtobr"}, "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/LocatorLoadSnapshot.java", "diffHunk": "@@ -85,49 +86,52 @@ public LocatorLoadSnapshot() {\n   }\n \n   public void addServer(ServerLocation location, String[] groups, ServerLoad initialLoad) {\n-    addServer(location, groups, initialLoad, 30000);\n+    addServer(location, \"\", groups, initialLoad, 30000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ0MTkwMA=="}, "originalCommit": {"oid": "517d6f6a3046fe08778aedacf9a8f88365e75799"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwOTY3NTYzOnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/LocatorLoadSnapshot.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMzoyNjowMlrOGBth5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMzoxNTo0MVrOGHfluw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ0NzcxNg==", "bodyText": "I'm wondering about how this method is handling excludedServers. If the hostname-for-senders of all of the servers is the same, doesn't that mean that as soon as one server is in this excluded server list, no results will be returned?", "url": "https://github.com/apache/geode/pull/4824#discussion_r404447716", "createdAt": "2020-04-06T23:26:02Z", "author": {"login": "upthewaterspout"}, "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/LocatorLoadSnapshot.java", "diffHunk": "@@ -448,6 +489,65 @@ private void updateMap(Map map, ServerLocation location, float load, float loadP\n     }\n   }\n \n+  private void updateMap(Map map, ServerLocation location, String memberId, float load,\n+      float loadPerConnection) {\n+    Map groupMap = (Map) map.get(null);\n+    ServerLocationAndMemberId locationAndMemberId =\n+        new ServerLocationAndMemberId(location, memberId);\n+    LoadHolder holder =\n+        (LoadHolder) groupMap.get(locationAndMemberId);\n+\n+    if (holder != null) {\n+      holder.setLoad(load, loadPerConnection);\n+    }\n+  }\n+\n+  /**\n+   *\n+   * @param groupServers the servers to consider\n+   * @param excludedServers servers to exclude\n+   * @param count how many you want. a negative number means all of them in order of best to worst\n+   * @return a list of best...worst server LoadHolders\n+   */\n+  private List<LoadHolder> findBestServersUsingMemberId(\n+      Map<ServerLocationAndMemberId, LoadHolder> groupServers,\n+      Set<ServerLocation> excludedServers, int count) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "517d6f6a3046fe08778aedacf9a8f88365e75799"}, "originalPosition": 265}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYxNDcwNA==", "bodyText": "You are right, the excluded servers should have the member id into account\nEdit: Im going to check it because I thought the behavior will be as you said, but in that case, we should see all the receivers down when one of them is down, which is not happening.", "url": "https://github.com/apache/geode/pull/4824#discussion_r404614704", "createdAt": "2020-04-07T08:04:14Z", "author": {"login": "alb3rtobr"}, "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/LocatorLoadSnapshot.java", "diffHunk": "@@ -448,6 +489,65 @@ private void updateMap(Map map, ServerLocation location, float load, float loadP\n     }\n   }\n \n+  private void updateMap(Map map, ServerLocation location, String memberId, float load,\n+      float loadPerConnection) {\n+    Map groupMap = (Map) map.get(null);\n+    ServerLocationAndMemberId locationAndMemberId =\n+        new ServerLocationAndMemberId(location, memberId);\n+    LoadHolder holder =\n+        (LoadHolder) groupMap.get(locationAndMemberId);\n+\n+    if (holder != null) {\n+      holder.setLoad(load, loadPerConnection);\n+    }\n+  }\n+\n+  /**\n+   *\n+   * @param groupServers the servers to consider\n+   * @param excludedServers servers to exclude\n+   * @param count how many you want. a negative number means all of them in order of best to worst\n+   * @return a list of best...worst server LoadHolders\n+   */\n+  private List<LoadHolder> findBestServersUsingMemberId(\n+      Map<ServerLocationAndMemberId, LoadHolder> groupServers,\n+      Set<ServerLocation> excludedServers, int count) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ0NzcxNg=="}, "originalCommit": {"oid": "517d6f6a3046fe08778aedacf9a8f88365e75799"}, "originalPosition": 265}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY2NjA0MA==", "bodyText": "Ok, the method is not involved in the receiver failover, I was wrong. So, you are right about the behavior of the method. And in the case of configuring same host and port for all the receivers it doesn't seem to be an issue.", "url": "https://github.com/apache/geode/pull/4824#discussion_r404666040", "createdAt": "2020-04-07T09:25:37Z", "author": {"login": "alb3rtobr"}, "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/LocatorLoadSnapshot.java", "diffHunk": "@@ -448,6 +489,65 @@ private void updateMap(Map map, ServerLocation location, float load, float loadP\n     }\n   }\n \n+  private void updateMap(Map map, ServerLocation location, String memberId, float load,\n+      float loadPerConnection) {\n+    Map groupMap = (Map) map.get(null);\n+    ServerLocationAndMemberId locationAndMemberId =\n+        new ServerLocationAndMemberId(location, memberId);\n+    LoadHolder holder =\n+        (LoadHolder) groupMap.get(locationAndMemberId);\n+\n+    if (holder != null) {\n+      holder.setLoad(load, loadPerConnection);\n+    }\n+  }\n+\n+  /**\n+   *\n+   * @param groupServers the servers to consider\n+   * @param excludedServers servers to exclude\n+   * @param count how many you want. a negative number means all of them in order of best to worst\n+   * @return a list of best...worst server LoadHolders\n+   */\n+  private List<LoadHolder> findBestServersUsingMemberId(\n+      Map<ServerLocationAndMemberId, LoadHolder> groupServers,\n+      Set<ServerLocation> excludedServers, int count) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ0NzcxNg=="}, "originalCommit": {"oid": "517d6f6a3046fe08778aedacf9a8f88365e75799"}, "originalPosition": 265}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkxNzM1OQ==", "bodyText": "I'm digging through the code a bit more. I think this method does get called, but maybe we are retrying at a higher level so it doesn't matter for the gateway code.", "url": "https://github.com/apache/geode/pull/4824#discussion_r409917359", "createdAt": "2020-04-17T00:04:39Z", "author": {"login": "upthewaterspout"}, "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/LocatorLoadSnapshot.java", "diffHunk": "@@ -448,6 +489,65 @@ private void updateMap(Map map, ServerLocation location, float load, float loadP\n     }\n   }\n \n+  private void updateMap(Map map, ServerLocation location, String memberId, float load,\n+      float loadPerConnection) {\n+    Map groupMap = (Map) map.get(null);\n+    ServerLocationAndMemberId locationAndMemberId =\n+        new ServerLocationAndMemberId(location, memberId);\n+    LoadHolder holder =\n+        (LoadHolder) groupMap.get(locationAndMemberId);\n+\n+    if (holder != null) {\n+      holder.setLoad(load, loadPerConnection);\n+    }\n+  }\n+\n+  /**\n+   *\n+   * @param groupServers the servers to consider\n+   * @param excludedServers servers to exclude\n+   * @param count how many you want. a negative number means all of them in order of best to worst\n+   * @return a list of best...worst server LoadHolders\n+   */\n+  private List<LoadHolder> findBestServersUsingMemberId(\n+      Map<ServerLocationAndMemberId, LoadHolder> groupServers,\n+      Set<ServerLocation> excludedServers, int count) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ0NzcxNg=="}, "originalCommit": {"oid": "517d6f6a3046fe08778aedacf9a8f88365e75799"}, "originalPosition": 265}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxMDc3OQ==", "bodyText": "I think it's possible to call this method, but it does look like the WAN will retry and come back with an empty excluded servers set. So I think you're right, it will be ok for the WAN case.", "url": "https://github.com/apache/geode/pull/4824#discussion_r410510779", "createdAt": "2020-04-17T23:15:41Z", "author": {"login": "upthewaterspout"}, "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/LocatorLoadSnapshot.java", "diffHunk": "@@ -448,6 +489,65 @@ private void updateMap(Map map, ServerLocation location, float load, float loadP\n     }\n   }\n \n+  private void updateMap(Map map, ServerLocation location, String memberId, float load,\n+      float loadPerConnection) {\n+    Map groupMap = (Map) map.get(null);\n+    ServerLocationAndMemberId locationAndMemberId =\n+        new ServerLocationAndMemberId(location, memberId);\n+    LoadHolder holder =\n+        (LoadHolder) groupMap.get(locationAndMemberId);\n+\n+    if (holder != null) {\n+      holder.setLoad(load, loadPerConnection);\n+    }\n+  }\n+\n+  /**\n+   *\n+   * @param groupServers the servers to consider\n+   * @param excludedServers servers to exclude\n+   * @param count how many you want. a negative number means all of them in order of best to worst\n+   * @return a list of best...worst server LoadHolders\n+   */\n+  private List<LoadHolder> findBestServersUsingMemberId(\n+      Map<ServerLocationAndMemberId, LoadHolder> groupServers,\n+      Set<ServerLocation> excludedServers, int count) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ0NzcxNg=="}, "originalCommit": {"oid": "517d6f6a3046fe08778aedacf9a8f88365e75799"}, "originalPosition": 265}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwOTY4MTcxOnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/tier/sockets/command/Ping.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMzoyODo1M1rOGBtlig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNzoyMjoyNVrOGCOJzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ0ODY1MA==", "bodyText": "Does this need to take into account the version of the member that is being pinged? Could we be pinging a member with an older version and it will fail to deserialize this message? Or are we assuming all of the receivers will be upgraded before we start getting pings that need to be forwarded to the correct server.", "url": "https://github.com/apache/geode/pull/4824#discussion_r404448650", "createdAt": "2020-04-06T23:28:53Z", "author": {"login": "upthewaterspout"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/tier/sockets/command/Ping.java", "diffHunk": "@@ -60,6 +78,29 @@ public void cmdExecute(final Message clientMessage, final ServerConnection serve\n     }\n   }\n \n+  /**\n+   * Process a ping request that was sent to the wrong server\n+   */\n+  protected void pingCorrectServer(Message clientMessage, DistributedMember targetServer,\n+      ServerConnection serverConnection)\n+      throws IOException {\n+    if (logger.isDebugEnabled()) {\n+      logger.debug(\"Received a Ping request from {} intended for {}.  Forwarding the ping...\");\n+    }\n+    if (!serverConnection.getCache().getDistributionManager().isCurrentMember(targetServer)) {\n+      logger.warn(\"Unable to ping non-member {} for client {}\", targetServer,\n+          serverConnection.getProxyID());\n+      writeErrorResponse(clientMessage, MessageType.PING, serverConnection);\n+      serverConnection.setAsTrue(RESPONDED);\n+    } else {\n+      // send a ping message to the server. This is a one-way message that doesn't send a reply\n+      final DistributedPingMessage distributedPingMessage =\n+          new DistributedPingMessage(targetServer, serverConnection.getProxyID());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "517d6f6a3046fe08778aedacf9a8f88365e75799"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY4ODE4MQ==", "bodyText": "In our case its ok if the ping is not working while the upgrade of all members is not finished", "url": "https://github.com/apache/geode/pull/4824#discussion_r404688181", "createdAt": "2020-04-07T10:01:29Z", "author": {"login": "alb3rtobr"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/tier/sockets/command/Ping.java", "diffHunk": "@@ -60,6 +78,29 @@ public void cmdExecute(final Message clientMessage, final ServerConnection serve\n     }\n   }\n \n+  /**\n+   * Process a ping request that was sent to the wrong server\n+   */\n+  protected void pingCorrectServer(Message clientMessage, DistributedMember targetServer,\n+      ServerConnection serverConnection)\n+      throws IOException {\n+    if (logger.isDebugEnabled()) {\n+      logger.debug(\"Received a Ping request from {} intended for {}.  Forwarding the ping...\");\n+    }\n+    if (!serverConnection.getCache().getDistributionManager().isCurrentMember(targetServer)) {\n+      logger.warn(\"Unable to ping non-member {} for client {}\", targetServer,\n+          serverConnection.getProxyID());\n+      writeErrorResponse(clientMessage, MessageType.PING, serverConnection);\n+      serverConnection.setAsTrue(RESPONDED);\n+    } else {\n+      // send a ping message to the server. This is a one-way message that doesn't send a reply\n+      final DistributedPingMessage distributedPingMessage =\n+          new DistributedPingMessage(targetServer, serverConnection.getProxyID());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ0ODY1MA=="}, "originalCommit": {"oid": "517d6f6a3046fe08778aedacf9a8f88365e75799"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg3NTg4Mg==", "bodyText": "I don't think Ping needs to check the version of the recipient of the DistributedPingMessage.  Only  new clients will include the new targetServer message part, and all servers should be upgraded before new clients come on-line.", "url": "https://github.com/apache/geode/pull/4824#discussion_r404875882", "createdAt": "2020-04-07T14:56:48Z", "author": {"login": "bschuchardt"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/tier/sockets/command/Ping.java", "diffHunk": "@@ -60,6 +78,29 @@ public void cmdExecute(final Message clientMessage, final ServerConnection serve\n     }\n   }\n \n+  /**\n+   * Process a ping request that was sent to the wrong server\n+   */\n+  protected void pingCorrectServer(Message clientMessage, DistributedMember targetServer,\n+      ServerConnection serverConnection)\n+      throws IOException {\n+    if (logger.isDebugEnabled()) {\n+      logger.debug(\"Received a Ping request from {} intended for {}.  Forwarding the ping...\");\n+    }\n+    if (!serverConnection.getCache().getDistributionManager().isCurrentMember(targetServer)) {\n+      logger.warn(\"Unable to ping non-member {} for client {}\", targetServer,\n+          serverConnection.getProxyID());\n+      writeErrorResponse(clientMessage, MessageType.PING, serverConnection);\n+      serverConnection.setAsTrue(RESPONDED);\n+    } else {\n+      // send a ping message to the server. This is a one-way message that doesn't send a reply\n+      final DistributedPingMessage distributedPingMessage =\n+          new DistributedPingMessage(targetServer, serverConnection.getProxyID());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ0ODY1MA=="}, "originalCommit": {"oid": "517d6f6a3046fe08778aedacf9a8f88365e75799"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk4MjIyMQ==", "bodyText": "Ok, makes sense. Thanks Bruce.", "url": "https://github.com/apache/geode/pull/4824#discussion_r404982221", "createdAt": "2020-04-07T17:22:25Z", "author": {"login": "upthewaterspout"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/tier/sockets/command/Ping.java", "diffHunk": "@@ -60,6 +78,29 @@ public void cmdExecute(final Message clientMessage, final ServerConnection serve\n     }\n   }\n \n+  /**\n+   * Process a ping request that was sent to the wrong server\n+   */\n+  protected void pingCorrectServer(Message clientMessage, DistributedMember targetServer,\n+      ServerConnection serverConnection)\n+      throws IOException {\n+    if (logger.isDebugEnabled()) {\n+      logger.debug(\"Received a Ping request from {} intended for {}.  Forwarding the ping...\");\n+    }\n+    if (!serverConnection.getCache().getDistributionManager().isCurrentMember(targetServer)) {\n+      logger.warn(\"Unable to ping non-member {} for client {}\", targetServer,\n+          serverConnection.getProxyID());\n+      writeErrorResponse(clientMessage, MessageType.PING, serverConnection);\n+      serverConnection.setAsTrue(RESPONDED);\n+    } else {\n+      // send a ping message to the server. This is a one-way message that doesn't send a reply\n+      final DistributedPingMessage distributedPingMessage =\n+          new DistributedPingMessage(targetServer, serverConnection.getProxyID());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ0ODY1MA=="}, "originalCommit": {"oid": "517d6f6a3046fe08778aedacf9a8f88365e75799"}, "originalPosition": 62}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4397, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}