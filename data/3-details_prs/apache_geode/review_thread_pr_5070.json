{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE0ODE1MDU5", "number": 5070, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxOToyNDo1MFrOD6Y0rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMDoxNDowOVrOD6Z11Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNTUwNzAyOnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/DistributedRegion.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxOToyNDo1MFrOGSM8SQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNjo0NjowN1rOGSsDXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTczOTU5Mw==", "bodyText": "I'm a bit confused regarding the use of AsynchronousEventDispatcher in the parameter comment and the method name. Is that just a grouping of GatewaySender and AsyncEventListener?", "url": "https://github.com/apache/geode/pull/5070#discussion_r421739593", "createdAt": "2020-05-07T19:24:50Z", "author": {"login": "boglesby"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/DistributedRegion.java", "diffHunk": "@@ -1013,34 +1016,38 @@ public Lock getDistributedLock(Object key) throws IllegalStateException {\n     return new DistributedLock(key);\n   }\n \n-  @Override\n-  public void preInitialize() {\n-    Set<String> allGatewaySenderIds = getAllGatewaySenderIds();\n-\n-    if (!allGatewaySenderIds.isEmpty()) {\n-      for (GatewaySender sender : cache.getAllGatewaySenders()) {\n-        if (sender.isParallel() && allGatewaySenderIds.contains(sender.getId())) {\n-          // Once decided to support REPLICATED regions with parallel\n-          // gateway-sender/asynchronous-event-queue, ShadowPartitionedRegionForUserRR should be\n-          // called and this validation should be removed.\n-          if (sender.getId().contains(AsyncEventQueueImpl.ASYNC_EVENT_QUEUE_PREFIX)) {\n-            throw new AsyncEventQueueConfigurationException(\n-                String.format(\n-                    \"Parallel Async Event Queue %s can not be used with replicated region %s\",\n-\n-                    AsyncEventQueueImpl.getAsyncEventQueueIdFromSenderId(sender.getId()),\n-                    getFullPath()));\n-          } else {\n-            throw new GatewaySenderConfigurationException(\n-                String.format(\n-                    \"Parallel gateway sender %s can not be used with replicated region %s\",\n-                    sender.getId(), getFullPath()));\n-          }\n+  /**\n+   * Validates that the GatewaySender/AsyncEventQueue referenced by the {@param asyncDispatcherId}\n+   * can be attached to this region; that is, verifies that the dispatcher is not configured as\n+   * parallel.\n+   *\n+   * @param asyncDispatcherId Id of the AsynchronousEventDispatcher to validate.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e06789324d2561f739b341da63a6b9dc1c9d4453"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAxMjY3Mg==", "bodyText": "Yep, you got it right, the name is basically to group both types of async event dispatchers we currently have (gateway-sender and async-event-listener). I'm happy to change it, though, if a better name comes up \ud83d\udc4d", "url": "https://github.com/apache/geode/pull/5070#discussion_r422012672", "createdAt": "2020-05-08T08:19:45Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/DistributedRegion.java", "diffHunk": "@@ -1013,34 +1016,38 @@ public Lock getDistributedLock(Object key) throws IllegalStateException {\n     return new DistributedLock(key);\n   }\n \n-  @Override\n-  public void preInitialize() {\n-    Set<String> allGatewaySenderIds = getAllGatewaySenderIds();\n-\n-    if (!allGatewaySenderIds.isEmpty()) {\n-      for (GatewaySender sender : cache.getAllGatewaySenders()) {\n-        if (sender.isParallel() && allGatewaySenderIds.contains(sender.getId())) {\n-          // Once decided to support REPLICATED regions with parallel\n-          // gateway-sender/asynchronous-event-queue, ShadowPartitionedRegionForUserRR should be\n-          // called and this validation should be removed.\n-          if (sender.getId().contains(AsyncEventQueueImpl.ASYNC_EVENT_QUEUE_PREFIX)) {\n-            throw new AsyncEventQueueConfigurationException(\n-                String.format(\n-                    \"Parallel Async Event Queue %s can not be used with replicated region %s\",\n-\n-                    AsyncEventQueueImpl.getAsyncEventQueueIdFromSenderId(sender.getId()),\n-                    getFullPath()));\n-          } else {\n-            throw new GatewaySenderConfigurationException(\n-                String.format(\n-                    \"Parallel gateway sender %s can not be used with replicated region %s\",\n-                    sender.getId(), getFullPath()));\n-          }\n+  /**\n+   * Validates that the GatewaySender/AsyncEventQueue referenced by the {@param asyncDispatcherId}\n+   * can be attached to this region; that is, verifies that the dispatcher is not configured as\n+   * parallel.\n+   *\n+   * @param asyncDispatcherId Id of the AsynchronousEventDispatcher to validate.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTczOTU5Mw=="}, "originalCommit": {"oid": "e06789324d2561f739b341da63a6b9dc1c9d4453"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI0OTMwOQ==", "bodyText": "Thanks for the clarification.", "url": "https://github.com/apache/geode/pull/5070#discussion_r422249309", "createdAt": "2020-05-08T16:46:07Z", "author": {"login": "boglesby"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/DistributedRegion.java", "diffHunk": "@@ -1013,34 +1016,38 @@ public Lock getDistributedLock(Object key) throws IllegalStateException {\n     return new DistributedLock(key);\n   }\n \n-  @Override\n-  public void preInitialize() {\n-    Set<String> allGatewaySenderIds = getAllGatewaySenderIds();\n-\n-    if (!allGatewaySenderIds.isEmpty()) {\n-      for (GatewaySender sender : cache.getAllGatewaySenders()) {\n-        if (sender.isParallel() && allGatewaySenderIds.contains(sender.getId())) {\n-          // Once decided to support REPLICATED regions with parallel\n-          // gateway-sender/asynchronous-event-queue, ShadowPartitionedRegionForUserRR should be\n-          // called and this validation should be removed.\n-          if (sender.getId().contains(AsyncEventQueueImpl.ASYNC_EVENT_QUEUE_PREFIX)) {\n-            throw new AsyncEventQueueConfigurationException(\n-                String.format(\n-                    \"Parallel Async Event Queue %s can not be used with replicated region %s\",\n-\n-                    AsyncEventQueueImpl.getAsyncEventQueueIdFromSenderId(sender.getId()),\n-                    getFullPath()));\n-          } else {\n-            throw new GatewaySenderConfigurationException(\n-                String.format(\n-                    \"Parallel gateway sender %s can not be used with replicated region %s\",\n-                    sender.getId(), getFullPath()));\n-          }\n+  /**\n+   * Validates that the GatewaySender/AsyncEventQueue referenced by the {@param asyncDispatcherId}\n+   * can be attached to this region; that is, verifies that the dispatcher is not configured as\n+   * parallel.\n+   *\n+   * @param asyncDispatcherId Id of the AsynchronousEventDispatcher to validate.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTczOTU5Mw=="}, "originalCommit": {"oid": "e06789324d2561f739b341da63a6b9dc1c9d4453"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNTYxNjc0OnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/DistributedRegionTest.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxOTo1NjoxNVrOGSOAww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNjowMzowMlrOGSqt_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc1NzEyMw==", "bodyText": "Would it be possible to have a spy DistributedRegion instead of a mock here? While using doCallRealMethod() works now because the validateAsynchronousEventDispatcher() method is entirely self-contained, if at some point in the future it's modified to access a field of DistributedRegion or call some other method in the class, the test will either fail, or pass despite not actually testing the true behaviour of the method.", "url": "https://github.com/apache/geode/pull/5070#discussion_r421757123", "createdAt": "2020-05-07T19:56:15Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/DistributedRegionTest.java", "diffHunk": "@@ -180,4 +189,75 @@ public void regionSyncNotInvokedInPerformSynchronizeForLostMemberTaskIfRegionNot\n \n     verify(distributedRegion, never()).synchronizeForLostMember(member, lostMemberVersionID);\n   }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldDoNothingWhenDispatcherIdCanNotBeFound() {\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders())\n+        .thenReturn(Collections.singleton(mock(GatewaySender.class)));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e06789324d2561f739b341da63a6b9dc1c9d4453"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAyNzM0Ng==", "bodyText": "It might be possible but it will require some effort as the DistributedRegion class doesn't have a default constructor and the initialisation logic is not trivial (I tried to do it but need to mock a lot of other objects to avoid getting all kind of exceptions)... I can do it if it becomes a blocker to merge this PR, otherwise I prefer to use the same approach the rest of this test class is using.", "url": "https://github.com/apache/geode/pull/5070#discussion_r422027346", "createdAt": "2020-05-08T08:52:30Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/DistributedRegionTest.java", "diffHunk": "@@ -180,4 +189,75 @@ public void regionSyncNotInvokedInPerformSynchronizeForLostMemberTaskIfRegionNot\n \n     verify(distributedRegion, never()).synchronizeForLostMember(member, lostMemberVersionID);\n   }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldDoNothingWhenDispatcherIdCanNotBeFound() {\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders())\n+        .thenReturn(Collections.singleton(mock(GatewaySender.class)));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc1NzEyMw=="}, "originalCommit": {"oid": "e06789324d2561f739b341da63a6b9dc1c9d4453"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIyNjQ3NA==", "bodyText": "Having looked at the constructor for DistributedRegion I can see that it would be way, way too much work to create a spy. The current approach is fine.", "url": "https://github.com/apache/geode/pull/5070#discussion_r422226474", "createdAt": "2020-05-08T16:01:08Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/DistributedRegionTest.java", "diffHunk": "@@ -180,4 +189,75 @@ public void regionSyncNotInvokedInPerformSynchronizeForLostMemberTaskIfRegionNot\n \n     verify(distributedRegion, never()).synchronizeForLostMember(member, lostMemberVersionID);\n   }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldDoNothingWhenDispatcherIdCanNotBeFound() {\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders())\n+        .thenReturn(Collections.singleton(mock(GatewaySender.class)));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc1NzEyMw=="}, "originalCommit": {"oid": "e06789324d2561f739b341da63a6b9dc1c9d4453"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIyNzQ1NA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/apache/geode/pull/5070#discussion_r422227454", "createdAt": "2020-05-08T16:03:02Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/DistributedRegionTest.java", "diffHunk": "@@ -180,4 +189,75 @@ public void regionSyncNotInvokedInPerformSynchronizeForLostMemberTaskIfRegionNot\n \n     verify(distributedRegion, never()).synchronizeForLostMember(member, lostMemberVersionID);\n   }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldDoNothingWhenDispatcherIdCanNotBeFound() {\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders())\n+        .thenReturn(Collections.singleton(mock(GatewaySender.class)));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc1NzEyMw=="}, "originalCommit": {"oid": "e06789324d2561f739b341da63a6b9dc1c9d4453"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNTYyMTg4OnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/DistributedRegionTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxOTo1Nzo0NFrOGSOEFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwODo1MjozM1rOGSegbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc1Nzk3NA==", "bodyText": "Would it be possible to use a spy rather than a mock here?", "url": "https://github.com/apache/geode/pull/5070#discussion_r421757974", "createdAt": "2020-05-07T19:57:44Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/DistributedRegionTest.java", "diffHunk": "@@ -180,4 +189,75 @@ public void regionSyncNotInvokedInPerformSynchronizeForLostMemberTaskIfRegionNot\n \n     verify(distributedRegion, never()).synchronizeForLostMember(member, lostMemberVersionID);\n   }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldDoNothingWhenDispatcherIdCanNotBeFound() {\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders())\n+        .thenReturn(Collections.singleton(mock(GatewaySender.class)));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);\n+    when(distributedRegion.getCache()).thenReturn(internalCache);\n+    doCallRealMethod().when(distributedRegion).validateAsynchronousEventDispatcher(anyString());\n+\n+    distributedRegion.validateAsynchronousEventDispatcher(\"nonExistingDispatcher\");\n+  }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldDoNothingWhenFoundDispatcherIsSerial() {\n+    String senderId = \"mySender\";\n+    GatewaySender serialSender = mock(GatewaySender.class);\n+    when(serialSender.isParallel()).thenReturn(false);\n+    when(serialSender.getId()).thenReturn(senderId);\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders()).thenReturn(Collections.singleton(serialSender));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e06789324d2561f739b341da63a6b9dc1c9d4453"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAyNzM3NA==", "bodyText": "See my comments above.", "url": "https://github.com/apache/geode/pull/5070#discussion_r422027374", "createdAt": "2020-05-08T08:52:33Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/DistributedRegionTest.java", "diffHunk": "@@ -180,4 +189,75 @@ public void regionSyncNotInvokedInPerformSynchronizeForLostMemberTaskIfRegionNot\n \n     verify(distributedRegion, never()).synchronizeForLostMember(member, lostMemberVersionID);\n   }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldDoNothingWhenDispatcherIdCanNotBeFound() {\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders())\n+        .thenReturn(Collections.singleton(mock(GatewaySender.class)));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);\n+    when(distributedRegion.getCache()).thenReturn(internalCache);\n+    doCallRealMethod().when(distributedRegion).validateAsynchronousEventDispatcher(anyString());\n+\n+    distributedRegion.validateAsynchronousEventDispatcher(\"nonExistingDispatcher\");\n+  }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldDoNothingWhenFoundDispatcherIsSerial() {\n+    String senderId = \"mySender\";\n+    GatewaySender serialSender = mock(GatewaySender.class);\n+    when(serialSender.isParallel()).thenReturn(false);\n+    when(serialSender.getId()).thenReturn(senderId);\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders()).thenReturn(Collections.singleton(serialSender));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc1Nzk3NA=="}, "originalCommit": {"oid": "e06789324d2561f739b341da63a6b9dc1c9d4453"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNTYyODc5OnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/DistributedRegionTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxOTo1OTozNlrOGSOIeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwODo1MjozNlrOGSegfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc1OTA5Ng==", "bodyText": "Would it be possible to use a spy rather than a mock here?", "url": "https://github.com/apache/geode/pull/5070#discussion_r421759096", "createdAt": "2020-05-07T19:59:36Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/DistributedRegionTest.java", "diffHunk": "@@ -180,4 +189,75 @@ public void regionSyncNotInvokedInPerformSynchronizeForLostMemberTaskIfRegionNot\n \n     verify(distributedRegion, never()).synchronizeForLostMember(member, lostMemberVersionID);\n   }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldDoNothingWhenDispatcherIdCanNotBeFound() {\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders())\n+        .thenReturn(Collections.singleton(mock(GatewaySender.class)));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);\n+    when(distributedRegion.getCache()).thenReturn(internalCache);\n+    doCallRealMethod().when(distributedRegion).validateAsynchronousEventDispatcher(anyString());\n+\n+    distributedRegion.validateAsynchronousEventDispatcher(\"nonExistingDispatcher\");\n+  }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldDoNothingWhenFoundDispatcherIsSerial() {\n+    String senderId = \"mySender\";\n+    GatewaySender serialSender = mock(GatewaySender.class);\n+    when(serialSender.isParallel()).thenReturn(false);\n+    when(serialSender.getId()).thenReturn(senderId);\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders()).thenReturn(Collections.singleton(serialSender));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);\n+    when(distributedRegion.getCache()).thenReturn(internalCache);\n+    doCallRealMethod().when(distributedRegion).validateAsynchronousEventDispatcher(anyString());\n+\n+    distributedRegion.validateAsynchronousEventDispatcher(senderId);\n+  }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldThrowExceptionWhenDispatcherIdMatchesAnExistingParallelAsyncEventQueue() {\n+    String senderId = \"senderId\";\n+    String regionPath = \"thisRegion\";\n+    String internalSenderId = getSenderIdFromAsyncEventQueueId(senderId);\n+    GatewaySender parallelAsyncEventQueue = mock(GatewaySender.class);\n+    when(parallelAsyncEventQueue.isParallel()).thenReturn(true);\n+    when(parallelAsyncEventQueue.getId()).thenReturn(internalSenderId);\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders())\n+        .thenReturn(Collections.singleton(parallelAsyncEventQueue));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e06789324d2561f739b341da63a6b9dc1c9d4453"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAyNzM5MQ==", "bodyText": "See my comments above.", "url": "https://github.com/apache/geode/pull/5070#discussion_r422027391", "createdAt": "2020-05-08T08:52:36Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/DistributedRegionTest.java", "diffHunk": "@@ -180,4 +189,75 @@ public void regionSyncNotInvokedInPerformSynchronizeForLostMemberTaskIfRegionNot\n \n     verify(distributedRegion, never()).synchronizeForLostMember(member, lostMemberVersionID);\n   }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldDoNothingWhenDispatcherIdCanNotBeFound() {\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders())\n+        .thenReturn(Collections.singleton(mock(GatewaySender.class)));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);\n+    when(distributedRegion.getCache()).thenReturn(internalCache);\n+    doCallRealMethod().when(distributedRegion).validateAsynchronousEventDispatcher(anyString());\n+\n+    distributedRegion.validateAsynchronousEventDispatcher(\"nonExistingDispatcher\");\n+  }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldDoNothingWhenFoundDispatcherIsSerial() {\n+    String senderId = \"mySender\";\n+    GatewaySender serialSender = mock(GatewaySender.class);\n+    when(serialSender.isParallel()).thenReturn(false);\n+    when(serialSender.getId()).thenReturn(senderId);\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders()).thenReturn(Collections.singleton(serialSender));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);\n+    when(distributedRegion.getCache()).thenReturn(internalCache);\n+    doCallRealMethod().when(distributedRegion).validateAsynchronousEventDispatcher(anyString());\n+\n+    distributedRegion.validateAsynchronousEventDispatcher(senderId);\n+  }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldThrowExceptionWhenDispatcherIdMatchesAnExistingParallelAsyncEventQueue() {\n+    String senderId = \"senderId\";\n+    String regionPath = \"thisRegion\";\n+    String internalSenderId = getSenderIdFromAsyncEventQueueId(senderId);\n+    GatewaySender parallelAsyncEventQueue = mock(GatewaySender.class);\n+    when(parallelAsyncEventQueue.isParallel()).thenReturn(true);\n+    when(parallelAsyncEventQueue.getId()).thenReturn(internalSenderId);\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders())\n+        .thenReturn(Collections.singleton(parallelAsyncEventQueue));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc1OTA5Ng=="}, "originalCommit": {"oid": "e06789324d2561f739b341da63a6b9dc1c9d4453"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNTYyOTIwOnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/DistributedRegionTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxOTo1OTo0MlrOGSOIrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwODo1Mjo1MFrOGSeg5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc1OTE1MQ==", "bodyText": "Would it be possible to use a spy rather than a mock here?", "url": "https://github.com/apache/geode/pull/5070#discussion_r421759151", "createdAt": "2020-05-07T19:59:42Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/DistributedRegionTest.java", "diffHunk": "@@ -180,4 +189,75 @@ public void regionSyncNotInvokedInPerformSynchronizeForLostMemberTaskIfRegionNot\n \n     verify(distributedRegion, never()).synchronizeForLostMember(member, lostMemberVersionID);\n   }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldDoNothingWhenDispatcherIdCanNotBeFound() {\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders())\n+        .thenReturn(Collections.singleton(mock(GatewaySender.class)));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);\n+    when(distributedRegion.getCache()).thenReturn(internalCache);\n+    doCallRealMethod().when(distributedRegion).validateAsynchronousEventDispatcher(anyString());\n+\n+    distributedRegion.validateAsynchronousEventDispatcher(\"nonExistingDispatcher\");\n+  }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldDoNothingWhenFoundDispatcherIsSerial() {\n+    String senderId = \"mySender\";\n+    GatewaySender serialSender = mock(GatewaySender.class);\n+    when(serialSender.isParallel()).thenReturn(false);\n+    when(serialSender.getId()).thenReturn(senderId);\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders()).thenReturn(Collections.singleton(serialSender));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);\n+    when(distributedRegion.getCache()).thenReturn(internalCache);\n+    doCallRealMethod().when(distributedRegion).validateAsynchronousEventDispatcher(anyString());\n+\n+    distributedRegion.validateAsynchronousEventDispatcher(senderId);\n+  }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldThrowExceptionWhenDispatcherIdMatchesAnExistingParallelAsyncEventQueue() {\n+    String senderId = \"senderId\";\n+    String regionPath = \"thisRegion\";\n+    String internalSenderId = getSenderIdFromAsyncEventQueueId(senderId);\n+    GatewaySender parallelAsyncEventQueue = mock(GatewaySender.class);\n+    when(parallelAsyncEventQueue.isParallel()).thenReturn(true);\n+    when(parallelAsyncEventQueue.getId()).thenReturn(internalSenderId);\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders())\n+        .thenReturn(Collections.singleton(parallelAsyncEventQueue));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);\n+    when(distributedRegion.getCache()).thenReturn(internalCache);\n+    when(distributedRegion.getFullPath()).thenReturn(regionPath);\n+    doCallRealMethod().when(distributedRegion).validateAsynchronousEventDispatcher(anyString());\n+\n+    assertThatThrownBy(\n+        () -> distributedRegion.validateAsynchronousEventDispatcher(internalSenderId))\n+            .isInstanceOf(AsyncEventQueueConfigurationException.class)\n+            .hasMessage(\"Parallel Async Event Queue \" + senderId\n+                + \" can not be used with replicated region \" + regionPath);\n+  }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldThrowExceptionWhenDispatcherIdMatchesAnExistingParallelGatewaySender() {\n+    String senderId = \"senderId\";\n+    String regionPath = \"thisRegion\";\n+    GatewaySender parallelGatewaySender = mock(GatewaySender.class);\n+    when(parallelGatewaySender.isParallel()).thenReturn(true);\n+    when(parallelGatewaySender.getId()).thenReturn(senderId);\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders())\n+        .thenReturn(Collections.singleton(parallelGatewaySender));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e06789324d2561f739b341da63a6b9dc1c9d4453"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAyNzQ5Mg==", "bodyText": "See my comments above.", "url": "https://github.com/apache/geode/pull/5070#discussion_r422027492", "createdAt": "2020-05-08T08:52:50Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/DistributedRegionTest.java", "diffHunk": "@@ -180,4 +189,75 @@ public void regionSyncNotInvokedInPerformSynchronizeForLostMemberTaskIfRegionNot\n \n     verify(distributedRegion, never()).synchronizeForLostMember(member, lostMemberVersionID);\n   }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldDoNothingWhenDispatcherIdCanNotBeFound() {\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders())\n+        .thenReturn(Collections.singleton(mock(GatewaySender.class)));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);\n+    when(distributedRegion.getCache()).thenReturn(internalCache);\n+    doCallRealMethod().when(distributedRegion).validateAsynchronousEventDispatcher(anyString());\n+\n+    distributedRegion.validateAsynchronousEventDispatcher(\"nonExistingDispatcher\");\n+  }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldDoNothingWhenFoundDispatcherIsSerial() {\n+    String senderId = \"mySender\";\n+    GatewaySender serialSender = mock(GatewaySender.class);\n+    when(serialSender.isParallel()).thenReturn(false);\n+    when(serialSender.getId()).thenReturn(senderId);\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders()).thenReturn(Collections.singleton(serialSender));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);\n+    when(distributedRegion.getCache()).thenReturn(internalCache);\n+    doCallRealMethod().when(distributedRegion).validateAsynchronousEventDispatcher(anyString());\n+\n+    distributedRegion.validateAsynchronousEventDispatcher(senderId);\n+  }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldThrowExceptionWhenDispatcherIdMatchesAnExistingParallelAsyncEventQueue() {\n+    String senderId = \"senderId\";\n+    String regionPath = \"thisRegion\";\n+    String internalSenderId = getSenderIdFromAsyncEventQueueId(senderId);\n+    GatewaySender parallelAsyncEventQueue = mock(GatewaySender.class);\n+    when(parallelAsyncEventQueue.isParallel()).thenReturn(true);\n+    when(parallelAsyncEventQueue.getId()).thenReturn(internalSenderId);\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders())\n+        .thenReturn(Collections.singleton(parallelAsyncEventQueue));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);\n+    when(distributedRegion.getCache()).thenReturn(internalCache);\n+    when(distributedRegion.getFullPath()).thenReturn(regionPath);\n+    doCallRealMethod().when(distributedRegion).validateAsynchronousEventDispatcher(anyString());\n+\n+    assertThatThrownBy(\n+        () -> distributedRegion.validateAsynchronousEventDispatcher(internalSenderId))\n+            .isInstanceOf(AsyncEventQueueConfigurationException.class)\n+            .hasMessage(\"Parallel Async Event Queue \" + senderId\n+                + \" can not be used with replicated region \" + regionPath);\n+  }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldThrowExceptionWhenDispatcherIdMatchesAnExistingParallelGatewaySender() {\n+    String senderId = \"senderId\";\n+    String regionPath = \"thisRegion\";\n+    GatewaySender parallelGatewaySender = mock(GatewaySender.class);\n+    when(parallelGatewaySender.isParallel()).thenReturn(true);\n+    when(parallelGatewaySender.getId()).thenReturn(senderId);\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders())\n+        .thenReturn(Collections.singleton(parallelGatewaySender));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc1OTE1MQ=="}, "originalCommit": {"oid": "e06789324d2561f739b341da63a6b9dc1c9d4453"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNTY2OTMzOnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/management/internal/cli/commands/AlterRegionCommandDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMDoxMjo0NVrOGSOiUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwODo1Mjo1NFrOGSeg-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc2NTcxNQ==", "bodyText": "Could these tests use CommandStringBuilder to generate their gfsh commands? I find it makes things a little more readable.", "url": "https://github.com/apache/geode/pull/5070#discussion_r421765715", "createdAt": "2020-05-07T20:12:45Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/management/internal/cli/commands/AlterRegionCommandDUnitTest.java", "diffHunk": "@@ -343,4 +346,76 @@ public void alterPartitionPersistentRegionWithParallelNonPersistentGatewaySender\n       assertThat(regionConfig.getRegionAttributes().getGatewaySenderIds()).isBlank();\n     });\n   }\n+\n+  @Test\n+  public void alterReplicateRegionWithParallelGatewaySenderShouldFailAndDoNotPersistChangesIntoTheClusterConfigurationService() {\n+    addIgnoredException(GatewaySenderConfigurationException.class);\n+    addIgnoredException(\"could not get remote locator information\");\n+    String regionName = testName.getMethodName();\n+    String gatewaySenderId = testName.getMethodName() + \"_parallelGatewaySender\";\n+\n+    gfsh.executeAndAssertThat(\n+        \"create gateway-sender --parallel=true --enable-persistence=false --remote-distributed-system-id=2 --id=\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e06789324d2561f739b341da63a6b9dc1c9d4453"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAyNzUxMg==", "bodyText": "Done!.", "url": "https://github.com/apache/geode/pull/5070#discussion_r422027512", "createdAt": "2020-05-08T08:52:54Z", "author": {"login": "jujoramos"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/management/internal/cli/commands/AlterRegionCommandDUnitTest.java", "diffHunk": "@@ -343,4 +346,76 @@ public void alterPartitionPersistentRegionWithParallelNonPersistentGatewaySender\n       assertThat(regionConfig.getRegionAttributes().getGatewaySenderIds()).isBlank();\n     });\n   }\n+\n+  @Test\n+  public void alterReplicateRegionWithParallelGatewaySenderShouldFailAndDoNotPersistChangesIntoTheClusterConfigurationService() {\n+    addIgnoredException(GatewaySenderConfigurationException.class);\n+    addIgnoredException(\"could not get remote locator information\");\n+    String regionName = testName.getMethodName();\n+    String gatewaySenderId = testName.getMethodName() + \"_parallelGatewaySender\";\n+\n+    gfsh.executeAndAssertThat(\n+        \"create gateway-sender --parallel=true --enable-persistence=false --remote-distributed-system-id=2 --id=\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc2NTcxNQ=="}, "originalCommit": {"oid": "e06789324d2561f739b341da63a6b9dc1c9d4453"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNTY3MTk4OnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/management/internal/cli/commands/AlterRegionCommandDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMDoxMzozNlrOGSOkCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwODo1Mjo1N1rOGSehCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc2NjE1Mg==", "bodyText": "Another place to possibly use CommandStringBuilder.", "url": "https://github.com/apache/geode/pull/5070#discussion_r421766152", "createdAt": "2020-05-07T20:13:36Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/management/internal/cli/commands/AlterRegionCommandDUnitTest.java", "diffHunk": "@@ -343,4 +346,76 @@ public void alterPartitionPersistentRegionWithParallelNonPersistentGatewaySender\n       assertThat(regionConfig.getRegionAttributes().getGatewaySenderIds()).isBlank();\n     });\n   }\n+\n+  @Test\n+  public void alterReplicateRegionWithParallelGatewaySenderShouldFailAndDoNotPersistChangesIntoTheClusterConfigurationService() {\n+    addIgnoredException(GatewaySenderConfigurationException.class);\n+    addIgnoredException(\"could not get remote locator information\");\n+    String regionName = testName.getMethodName();\n+    String gatewaySenderId = testName.getMethodName() + \"_parallelGatewaySender\";\n+\n+    gfsh.executeAndAssertThat(\n+        \"create gateway-sender --parallel=true --enable-persistence=false --remote-distributed-system-id=2 --id=\"\n+            + gatewaySenderId)\n+        .statusIsSuccess().doesNotContainOutput(\"Did not complete waiting\");\n+    gfsh.executeAndAssertThat(\"create region --type=REPLICATE --name=\" + regionName)\n+        .statusIsSuccess();\n+    locator.waitUntilRegionIsReadyOnExactlyThisManyServers(SEPARATOR + regionName, 1);\n+\n+    // Associate the gateway-sender\n+    gfsh.executeAndAssertThat(\n+        \"alter region --name=\" + regionName + \" --gateway-sender-id=\" + gatewaySenderId)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e06789324d2561f739b341da63a6b9dc1c9d4453"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAyNzUyOQ==", "bodyText": "Done!.", "url": "https://github.com/apache/geode/pull/5070#discussion_r422027529", "createdAt": "2020-05-08T08:52:57Z", "author": {"login": "jujoramos"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/management/internal/cli/commands/AlterRegionCommandDUnitTest.java", "diffHunk": "@@ -343,4 +346,76 @@ public void alterPartitionPersistentRegionWithParallelNonPersistentGatewaySender\n       assertThat(regionConfig.getRegionAttributes().getGatewaySenderIds()).isBlank();\n     });\n   }\n+\n+  @Test\n+  public void alterReplicateRegionWithParallelGatewaySenderShouldFailAndDoNotPersistChangesIntoTheClusterConfigurationService() {\n+    addIgnoredException(GatewaySenderConfigurationException.class);\n+    addIgnoredException(\"could not get remote locator information\");\n+    String regionName = testName.getMethodName();\n+    String gatewaySenderId = testName.getMethodName() + \"_parallelGatewaySender\";\n+\n+    gfsh.executeAndAssertThat(\n+        \"create gateway-sender --parallel=true --enable-persistence=false --remote-distributed-system-id=2 --id=\"\n+            + gatewaySenderId)\n+        .statusIsSuccess().doesNotContainOutput(\"Did not complete waiting\");\n+    gfsh.executeAndAssertThat(\"create region --type=REPLICATE --name=\" + regionName)\n+        .statusIsSuccess();\n+    locator.waitUntilRegionIsReadyOnExactlyThisManyServers(SEPARATOR + regionName, 1);\n+\n+    // Associate the gateway-sender\n+    gfsh.executeAndAssertThat(\n+        \"alter region --name=\" + regionName + \" --gateway-sender-id=\" + gatewaySenderId)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc2NjE1Mg=="}, "originalCommit": {"oid": "e06789324d2561f739b341da63a6b9dc1c9d4453"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNTY3MjU4OnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/management/internal/cli/commands/AlterRegionCommandDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMDoxMzo0N1rOGSOkXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwODo1MzowMVrOGSehJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc2NjIzNg==", "bodyText": "Another place to possibly use CommandStringBuilder.", "url": "https://github.com/apache/geode/pull/5070#discussion_r421766236", "createdAt": "2020-05-07T20:13:47Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/management/internal/cli/commands/AlterRegionCommandDUnitTest.java", "diffHunk": "@@ -343,4 +346,76 @@ public void alterPartitionPersistentRegionWithParallelNonPersistentGatewaySender\n       assertThat(regionConfig.getRegionAttributes().getGatewaySenderIds()).isBlank();\n     });\n   }\n+\n+  @Test\n+  public void alterReplicateRegionWithParallelGatewaySenderShouldFailAndDoNotPersistChangesIntoTheClusterConfigurationService() {\n+    addIgnoredException(GatewaySenderConfigurationException.class);\n+    addIgnoredException(\"could not get remote locator information\");\n+    String regionName = testName.getMethodName();\n+    String gatewaySenderId = testName.getMethodName() + \"_parallelGatewaySender\";\n+\n+    gfsh.executeAndAssertThat(\n+        \"create gateway-sender --parallel=true --enable-persistence=false --remote-distributed-system-id=2 --id=\"\n+            + gatewaySenderId)\n+        .statusIsSuccess().doesNotContainOutput(\"Did not complete waiting\");\n+    gfsh.executeAndAssertThat(\"create region --type=REPLICATE --name=\" + regionName)\n+        .statusIsSuccess();\n+    locator.waitUntilRegionIsReadyOnExactlyThisManyServers(SEPARATOR + regionName, 1);\n+\n+    // Associate the gateway-sender\n+    gfsh.executeAndAssertThat(\n+        \"alter region --name=\" + regionName + \" --gateway-sender-id=\" + gatewaySenderId)\n+        .statusIsError().containsOutput(\"server-1\", \"Parallel Gateway Sender \" + gatewaySenderId\n+            + \" can not be used with replicated region \" + SEPARATOR + regionName);\n+\n+    // Check the cluster configuration service.\n+    locator.invoke(() -> {\n+      InternalLocator internalLocator = ClusterStartupRule.getLocator();\n+      assertThat(internalLocator).isNotNull();\n+      CacheConfig config =\n+          internalLocator.getConfigurationPersistenceService().getCacheConfig(\"cluster\");\n+\n+      RegionConfig regionConfig = find(config.getRegions(), regionName);\n+      assertThat(regionConfig).isNotNull();\n+      assertThat(regionConfig.getRegionAttributes()).isNotNull();\n+      assertThat(regionConfig.getRegionAttributes().getGatewaySenderIds()).isNull();\n+    });\n+  }\n+\n+  @Test\n+  public void alterReplicateRegionWithParallelAsynchronousEventQueueShouldFailAndDoNotPersistChangesIntoTheClusterConfigurationService() {\n+    addIgnoredException(AsyncEventQueueConfigurationException.class);\n+    String regionName = testName.getMethodName();\n+    String asyncEventQueueName = testName.getMethodName() + \"_asyncEventQueue\";\n+\n+    gfsh.executeAndAssertThat(\n+        \"create async-event-queue --parallel=true --persistent=false --listener=org.apache.geode.internal.cache.wan.MyAsyncEventListener --id=\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e06789324d2561f739b341da63a6b9dc1c9d4453"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAyNzU1OQ==", "bodyText": "Done!.", "url": "https://github.com/apache/geode/pull/5070#discussion_r422027559", "createdAt": "2020-05-08T08:53:01Z", "author": {"login": "jujoramos"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/management/internal/cli/commands/AlterRegionCommandDUnitTest.java", "diffHunk": "@@ -343,4 +346,76 @@ public void alterPartitionPersistentRegionWithParallelNonPersistentGatewaySender\n       assertThat(regionConfig.getRegionAttributes().getGatewaySenderIds()).isBlank();\n     });\n   }\n+\n+  @Test\n+  public void alterReplicateRegionWithParallelGatewaySenderShouldFailAndDoNotPersistChangesIntoTheClusterConfigurationService() {\n+    addIgnoredException(GatewaySenderConfigurationException.class);\n+    addIgnoredException(\"could not get remote locator information\");\n+    String regionName = testName.getMethodName();\n+    String gatewaySenderId = testName.getMethodName() + \"_parallelGatewaySender\";\n+\n+    gfsh.executeAndAssertThat(\n+        \"create gateway-sender --parallel=true --enable-persistence=false --remote-distributed-system-id=2 --id=\"\n+            + gatewaySenderId)\n+        .statusIsSuccess().doesNotContainOutput(\"Did not complete waiting\");\n+    gfsh.executeAndAssertThat(\"create region --type=REPLICATE --name=\" + regionName)\n+        .statusIsSuccess();\n+    locator.waitUntilRegionIsReadyOnExactlyThisManyServers(SEPARATOR + regionName, 1);\n+\n+    // Associate the gateway-sender\n+    gfsh.executeAndAssertThat(\n+        \"alter region --name=\" + regionName + \" --gateway-sender-id=\" + gatewaySenderId)\n+        .statusIsError().containsOutput(\"server-1\", \"Parallel Gateway Sender \" + gatewaySenderId\n+            + \" can not be used with replicated region \" + SEPARATOR + regionName);\n+\n+    // Check the cluster configuration service.\n+    locator.invoke(() -> {\n+      InternalLocator internalLocator = ClusterStartupRule.getLocator();\n+      assertThat(internalLocator).isNotNull();\n+      CacheConfig config =\n+          internalLocator.getConfigurationPersistenceService().getCacheConfig(\"cluster\");\n+\n+      RegionConfig regionConfig = find(config.getRegions(), regionName);\n+      assertThat(regionConfig).isNotNull();\n+      assertThat(regionConfig.getRegionAttributes()).isNotNull();\n+      assertThat(regionConfig.getRegionAttributes().getGatewaySenderIds()).isNull();\n+    });\n+  }\n+\n+  @Test\n+  public void alterReplicateRegionWithParallelAsynchronousEventQueueShouldFailAndDoNotPersistChangesIntoTheClusterConfigurationService() {\n+    addIgnoredException(AsyncEventQueueConfigurationException.class);\n+    String regionName = testName.getMethodName();\n+    String asyncEventQueueName = testName.getMethodName() + \"_asyncEventQueue\";\n+\n+    gfsh.executeAndAssertThat(\n+        \"create async-event-queue --parallel=true --persistent=false --listener=org.apache.geode.internal.cache.wan.MyAsyncEventListener --id=\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc2NjIzNg=="}, "originalCommit": {"oid": "e06789324d2561f739b341da63a6b9dc1c9d4453"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNTY3MzgxOnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/management/internal/cli/commands/AlterRegionCommandDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMDoxNDowOVrOGSOlIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwODo1MzowM1rOGSehNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc2NjQzNQ==", "bodyText": "Another place to possibly use CommandStringBuilder.", "url": "https://github.com/apache/geode/pull/5070#discussion_r421766435", "createdAt": "2020-05-07T20:14:09Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/management/internal/cli/commands/AlterRegionCommandDUnitTest.java", "diffHunk": "@@ -343,4 +346,76 @@ public void alterPartitionPersistentRegionWithParallelNonPersistentGatewaySender\n       assertThat(regionConfig.getRegionAttributes().getGatewaySenderIds()).isBlank();\n     });\n   }\n+\n+  @Test\n+  public void alterReplicateRegionWithParallelGatewaySenderShouldFailAndDoNotPersistChangesIntoTheClusterConfigurationService() {\n+    addIgnoredException(GatewaySenderConfigurationException.class);\n+    addIgnoredException(\"could not get remote locator information\");\n+    String regionName = testName.getMethodName();\n+    String gatewaySenderId = testName.getMethodName() + \"_parallelGatewaySender\";\n+\n+    gfsh.executeAndAssertThat(\n+        \"create gateway-sender --parallel=true --enable-persistence=false --remote-distributed-system-id=2 --id=\"\n+            + gatewaySenderId)\n+        .statusIsSuccess().doesNotContainOutput(\"Did not complete waiting\");\n+    gfsh.executeAndAssertThat(\"create region --type=REPLICATE --name=\" + regionName)\n+        .statusIsSuccess();\n+    locator.waitUntilRegionIsReadyOnExactlyThisManyServers(SEPARATOR + regionName, 1);\n+\n+    // Associate the gateway-sender\n+    gfsh.executeAndAssertThat(\n+        \"alter region --name=\" + regionName + \" --gateway-sender-id=\" + gatewaySenderId)\n+        .statusIsError().containsOutput(\"server-1\", \"Parallel Gateway Sender \" + gatewaySenderId\n+            + \" can not be used with replicated region \" + SEPARATOR + regionName);\n+\n+    // Check the cluster configuration service.\n+    locator.invoke(() -> {\n+      InternalLocator internalLocator = ClusterStartupRule.getLocator();\n+      assertThat(internalLocator).isNotNull();\n+      CacheConfig config =\n+          internalLocator.getConfigurationPersistenceService().getCacheConfig(\"cluster\");\n+\n+      RegionConfig regionConfig = find(config.getRegions(), regionName);\n+      assertThat(regionConfig).isNotNull();\n+      assertThat(regionConfig.getRegionAttributes()).isNotNull();\n+      assertThat(regionConfig.getRegionAttributes().getGatewaySenderIds()).isNull();\n+    });\n+  }\n+\n+  @Test\n+  public void alterReplicateRegionWithParallelAsynchronousEventQueueShouldFailAndDoNotPersistChangesIntoTheClusterConfigurationService() {\n+    addIgnoredException(AsyncEventQueueConfigurationException.class);\n+    String regionName = testName.getMethodName();\n+    String asyncEventQueueName = testName.getMethodName() + \"_asyncEventQueue\";\n+\n+    gfsh.executeAndAssertThat(\n+        \"create async-event-queue --parallel=true --persistent=false --listener=org.apache.geode.internal.cache.wan.MyAsyncEventListener --id=\"\n+            + asyncEventQueueName)\n+        .statusIsSuccess();\n+    locator.waitUntilAsyncEventQueuesAreReadyOnExactlyThisManyServers(asyncEventQueueName, 1);\n+\n+    gfsh.executeAndAssertThat(\"create region --type=REPLICATE --name=\" + regionName)\n+        .statusIsSuccess();\n+    locator.waitUntilRegionIsReadyOnExactlyThisManyServers(SEPARATOR + regionName, 1);\n+\n+    // Associate the async-event-queue\n+    gfsh.executeAndAssertThat(\n+        \"alter region --name=\" + regionName + \" --async-event-queue-id=\" + asyncEventQueueName)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e06789324d2561f739b341da63a6b9dc1c9d4453"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAyNzU3NQ==", "bodyText": "Done!.", "url": "https://github.com/apache/geode/pull/5070#discussion_r422027575", "createdAt": "2020-05-08T08:53:03Z", "author": {"login": "jujoramos"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/management/internal/cli/commands/AlterRegionCommandDUnitTest.java", "diffHunk": "@@ -343,4 +346,76 @@ public void alterPartitionPersistentRegionWithParallelNonPersistentGatewaySender\n       assertThat(regionConfig.getRegionAttributes().getGatewaySenderIds()).isBlank();\n     });\n   }\n+\n+  @Test\n+  public void alterReplicateRegionWithParallelGatewaySenderShouldFailAndDoNotPersistChangesIntoTheClusterConfigurationService() {\n+    addIgnoredException(GatewaySenderConfigurationException.class);\n+    addIgnoredException(\"could not get remote locator information\");\n+    String regionName = testName.getMethodName();\n+    String gatewaySenderId = testName.getMethodName() + \"_parallelGatewaySender\";\n+\n+    gfsh.executeAndAssertThat(\n+        \"create gateway-sender --parallel=true --enable-persistence=false --remote-distributed-system-id=2 --id=\"\n+            + gatewaySenderId)\n+        .statusIsSuccess().doesNotContainOutput(\"Did not complete waiting\");\n+    gfsh.executeAndAssertThat(\"create region --type=REPLICATE --name=\" + regionName)\n+        .statusIsSuccess();\n+    locator.waitUntilRegionIsReadyOnExactlyThisManyServers(SEPARATOR + regionName, 1);\n+\n+    // Associate the gateway-sender\n+    gfsh.executeAndAssertThat(\n+        \"alter region --name=\" + regionName + \" --gateway-sender-id=\" + gatewaySenderId)\n+        .statusIsError().containsOutput(\"server-1\", \"Parallel Gateway Sender \" + gatewaySenderId\n+            + \" can not be used with replicated region \" + SEPARATOR + regionName);\n+\n+    // Check the cluster configuration service.\n+    locator.invoke(() -> {\n+      InternalLocator internalLocator = ClusterStartupRule.getLocator();\n+      assertThat(internalLocator).isNotNull();\n+      CacheConfig config =\n+          internalLocator.getConfigurationPersistenceService().getCacheConfig(\"cluster\");\n+\n+      RegionConfig regionConfig = find(config.getRegions(), regionName);\n+      assertThat(regionConfig).isNotNull();\n+      assertThat(regionConfig.getRegionAttributes()).isNotNull();\n+      assertThat(regionConfig.getRegionAttributes().getGatewaySenderIds()).isNull();\n+    });\n+  }\n+\n+  @Test\n+  public void alterReplicateRegionWithParallelAsynchronousEventQueueShouldFailAndDoNotPersistChangesIntoTheClusterConfigurationService() {\n+    addIgnoredException(AsyncEventQueueConfigurationException.class);\n+    String regionName = testName.getMethodName();\n+    String asyncEventQueueName = testName.getMethodName() + \"_asyncEventQueue\";\n+\n+    gfsh.executeAndAssertThat(\n+        \"create async-event-queue --parallel=true --persistent=false --listener=org.apache.geode.internal.cache.wan.MyAsyncEventListener --id=\"\n+            + asyncEventQueueName)\n+        .statusIsSuccess();\n+    locator.waitUntilAsyncEventQueuesAreReadyOnExactlyThisManyServers(asyncEventQueueName, 1);\n+\n+    gfsh.executeAndAssertThat(\"create region --type=REPLICATE --name=\" + regionName)\n+        .statusIsSuccess();\n+    locator.waitUntilRegionIsReadyOnExactlyThisManyServers(SEPARATOR + regionName, 1);\n+\n+    // Associate the async-event-queue\n+    gfsh.executeAndAssertThat(\n+        \"alter region --name=\" + regionName + \" --async-event-queue-id=\" + asyncEventQueueName)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc2NjQzNQ=="}, "originalCommit": {"oid": "e06789324d2561f739b341da63a6b9dc1c9d4453"}, "originalPosition": 127}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4199, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}