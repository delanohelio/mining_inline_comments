{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE3NjE2ODEz", "number": 5111, "title": "GEODE-8078: log and report error at the correct place.", "bodyText": "For get operation, if cache is not ready, just don't report any runtime information\nWe would still log errors in case the stack trace is useful.\n\nThank you for submitting a contribution to Apache Geode.\nIn order to streamline the review of the contribution we ask you\nto ensure the following steps have been taken:\nFor all changes:\n\n\n Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?\n\n\n Has your PR been rebased against the latest commit within the target branch (typically develop)?\n\n\n Is your initial contribution a single, squashed commit?\n\n\n Does gradlew build run cleanly?\n\n\n Have you written or updated unit tests to verify your changes?\n\n\n If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under ASF 2.0?\n\n\nNote:\nPlease ensure that once the PR is submitted, check Concourse for build issues and\nsubmit an update to your PR as soon as possible. If you need help, please send an\nemail to dev@geode.apache.org.", "createdAt": "2020-05-13T21:15:29Z", "url": "https://github.com/apache/geode/pull/5111", "merged": true, "mergeCommit": {"oid": "a235c7c4ea2474d6fe347326ef888c7c10daffb6"}, "closed": true, "closedAt": "2020-05-15T15:09:20Z", "author": {"login": "jinmeiliao"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABchBXvQgH2gAyNDE3NjE2ODEzOmFiYWQxNzAyOTM4N2ZmMDg0M2MwMTEzMzQ4MTlhNDIyNTQ3MmY0NTg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABchXXj2AFqTQxMjI4MDc2Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "abad17029387ff0843c011334819a4225472f458", "author": {"user": {"login": "jinmeiliao", "name": "Jinmei Liao"}}, "url": "https://github.com/apache/geode/commit/abad17029387ff0843c011334819a4225472f458", "committedDate": "2020-05-13T23:21:25Z", "message": "GEODE-8078: log and report error at the correct place.\n\n* For get operation, if cache is not ready, just don't report any runtime information\n* do not log the CacheClosedException"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "52dd9ca69c0d3c374accdfc1635aec4db0fa73a9", "author": {"user": {"login": "jinmeiliao", "name": "Jinmei Liao"}}, "url": "https://github.com/apache/geode/commit/52dd9ca69c0d3c374accdfc1635aec4db0fa73a9", "committedDate": "2020-05-13T21:14:12Z", "message": "GEODE-8078: log and report error at the correct place.\n\n* For get operation, if cache is not ready, just don't report any runtime information\n* We would still log errors in case the stack trace is useful."}, "afterCommit": {"oid": "abad17029387ff0843c011334819a4225472f458", "author": {"user": {"login": "jinmeiliao", "name": "Jinmei Liao"}}, "url": "https://github.com/apache/geode/commit/abad17029387ff0843c011334819a4225472f458", "committedDate": "2020-05-13T23:21:25Z", "message": "GEODE-8078: log and report error at the correct place.\n\n* For get operation, if cache is not ready, just don't report any runtime information\n* do not log the CacheClosedException"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyMTc1MDAx", "url": "https://github.com/apache/geode/pull/5111#pullrequestreview-412175001", "createdAt": "2020-05-14T20:51:56Z", "commit": {"oid": "abad17029387ff0843c011334819a4225472f458"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQyMDo1MTo1NlrOGVtv7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQyMToxODo0MFrOGVuldw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQyMjgyOA==", "bodyText": "I recommend annotating with @VisibleForTesting because the method would probably be private if we didn't need to call it directly for testing.", "url": "https://github.com/apache/geode/pull/5111#discussion_r425422828", "createdAt": "2020-05-14T20:51:56Z", "author": {"login": "kirklund"}, "path": "geode-core/src/main/java/org/apache/geode/management/internal/functions/CacheRealizationFunction.java", "diffHunk": "@@ -78,24 +79,44 @@\n   public void execute(FunctionContext<List> context) {\n     AbstractConfiguration cacheElement = (AbstractConfiguration) context.getArguments().get(0);\n     CacheElementOperation operation = (CacheElementOperation) context.getArguments().get(1);\n-    RemoteInputStream jarStream = (RemoteInputStream) context.getArguments().get(2);\n \n-    InternalCache cache = (InternalCache) context.getCache();\n-    try {\n-      if (operation == CacheElementOperation.GET) {\n+    // for get operation, caller is expecting RuntimeInfo\n+    if (operation == CacheElementOperation.GET) {\n+      try {\n+        InternalCache cache = (InternalCache) context.getCache();\n         context.getResultSender().lastResult(executeGet(context, cache, cacheElement));\n-      } else {\n+      } catch (CacheClosedException e) {\n+        // cache not ready or closed already, no need to log and do not return any runtime info\n+        context.getResultSender().lastResult(null);\n+      } catch (Exception e) {\n+        logError(\"Unable to gather runtime information on this member. \", e);\n+        context.getResultSender().lastResult(null);\n+      }\n+    }\n+    // for other operations, caller is expecting RealizationResult\n+    else {\n+      try {\n+        RemoteInputStream jarStream = (RemoteInputStream) context.getArguments().get(2);\n+        InternalCache cache = (InternalCache) context.getCache();\n         context.getResultSender()\n             .lastResult(executeUpdate(context, cache, cacheElement, operation, jarStream));\n+      } catch (CacheClosedException e) {\n+        // cache not ready or closed already, no need to log it\n+        context.getResultSender().lastResult(new RealizationResult()\n+            .setSuccess(false)\n+            .setMessage(e.getMessage()));\n+      } catch (Exception e) {\n+        logError(\"unable to update cache with the configuration.\", e);\n+        context.getResultSender().lastResult(new RealizationResult()\n+            .setSuccess(false)\n+            .setMemberName(context.getMemberName())\n+            .setMessage(e.getMessage()));\n       }\n-    } catch (Exception e) {\n-      logger.error(e.getMessage(), e);\n-      context.getResultSender().lastResult(new RealizationResult()\n-          .setSuccess(false)\n-          .setMemberName(context.getMemberName())\n-          .setMessage(e.getMessage()));\n     }\n+  }\n \n+  void logError(String s, Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abad17029387ff0843c011334819a4225472f458"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQyOTkzMA==", "bodyText": "I recommend using GeodeAwaitility instead of a while-loop without timeout (I realize that ConcurrencyRule is ultimately providing the cancellation):\nawait()\n  .ignoreException(ClusterManagementException.class)\n  .until(() -> client.get(server0) != null);", "url": "https://github.com/apache/geode/pull/5111#discussion_r425429930", "createdAt": "2020-05-14T21:05:19Z", "author": {"login": "kirklund"}, "path": "geode-web-management/src/distributedTest/java/org/apache/geode/management/client/GetStartingMemberTest.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.management.client;\n+\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.context.ContextConfiguration;\n+import org.springframework.test.context.junit4.SpringRunner;\n+import org.springframework.test.context.web.WebAppConfiguration;\n+import org.springframework.web.client.RestTemplate;\n+import org.springframework.web.context.WebApplicationContext;\n+\n+import org.apache.geode.management.api.ClusterManagementException;\n+import org.apache.geode.management.api.ClusterManagementGetResult;\n+import org.apache.geode.management.api.ClusterManagementService;\n+import org.apache.geode.management.api.RestTemplateClusterManagementServiceTransport;\n+import org.apache.geode.management.configuration.Member;\n+import org.apache.geode.management.internal.rest.LocatorWebContext;\n+import org.apache.geode.management.internal.rest.PlainLocatorContextLoader;\n+import org.apache.geode.management.runtime.MemberInformation;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.junit.rules.ConcurrencyRule;\n+\n+@RunWith(SpringRunner.class)\n+@ContextConfiguration(locations = {\"classpath*:WEB-INF/management-servlet.xml\"},\n+    loader = PlainLocatorContextLoader.class)\n+@WebAppConfiguration\n+@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_CLASS)\n+public class GetStartingMemberTest {\n+\n+  @Autowired\n+  private WebApplicationContext webApplicationContext;\n+\n+  @Rule\n+  public ClusterStartupRule cluster = new ClusterStartupRule(1);\n+\n+  @Rule\n+  public ConcurrencyRule concurrency = new ConcurrencyRule();\n+\n+  private ClusterManagementService client;\n+  private LocatorWebContext webContext;\n+\n+  @Before\n+  public void before() {\n+    cluster.setSkipLocalDistributedSystemCleanup(true);\n+    webContext = new LocatorWebContext(webApplicationContext);\n+    client = new ClusterManagementServiceBuilder().setTransport(\n+        new RestTemplateClusterManagementServiceTransport(\n+            new RestTemplate(webContext.getRequestFactory())))\n+        .build();\n+  }\n+\n+  @Test\n+  public void getStartingMember() throws Exception {\n+    Member server0 = new Member();\n+    server0.setId(\"server-0\");\n+    concurrency.add(() -> cluster.startServerVM(0, webContext.getLocator().getPort()));\n+    concurrency.add(() -> {\n+      ClusterManagementGetResult<Member, MemberInformation> result = null;\n+      while (result == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abad17029387ff0843c011334819a4225472f458"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQzNjUzNQ==", "bodyText": "ExecutorServiceRule would really clean this up and I think we should look into merging these two rules. In general, I think ExecutorServiceRule is preferable (I can explain outside of PR). If you switch to ExecutorServiceRule the test could use an assertion in await and seems much more readable to me:\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\nimport static org.apache.geode.test.awaitility.GeodeAwaitility.await;\nimport static org.assertj.core.api.Assertions.assertThat;\n\n  @Rule\n  public ExecutorServiceRule executorServiceRule = new ExecutorServiceRule();\n\n  @Test\n  public void getStartingMember() throws Exception {\n    Member server0 = new Member();\n    server0.setId(\"server-0\");\n\n    Future<Void> startServer = executorServiceRule.submit(() -> {\n      cluster.startServerVM(0, webContext.getLocator().getPort());\n    });\n\n    await()\n        .ignoreException(ClusterManagementException.class)\n        .untilAsserted(() -> assertThat(client.get(server0)).isNotNull());\n\n    startServer.get(getTimeout().toMillis(), MILLISECONDS);\n  }", "url": "https://github.com/apache/geode/pull/5111#discussion_r425436535", "createdAt": "2020-05-14T21:18:40Z", "author": {"login": "kirklund"}, "path": "geode-web-management/src/distributedTest/java/org/apache/geode/management/client/GetStartingMemberTest.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.management.client;\n+\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.context.ContextConfiguration;\n+import org.springframework.test.context.junit4.SpringRunner;\n+import org.springframework.test.context.web.WebAppConfiguration;\n+import org.springframework.web.client.RestTemplate;\n+import org.springframework.web.context.WebApplicationContext;\n+\n+import org.apache.geode.management.api.ClusterManagementException;\n+import org.apache.geode.management.api.ClusterManagementGetResult;\n+import org.apache.geode.management.api.ClusterManagementService;\n+import org.apache.geode.management.api.RestTemplateClusterManagementServiceTransport;\n+import org.apache.geode.management.configuration.Member;\n+import org.apache.geode.management.internal.rest.LocatorWebContext;\n+import org.apache.geode.management.internal.rest.PlainLocatorContextLoader;\n+import org.apache.geode.management.runtime.MemberInformation;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.junit.rules.ConcurrencyRule;\n+\n+@RunWith(SpringRunner.class)\n+@ContextConfiguration(locations = {\"classpath*:WEB-INF/management-servlet.xml\"},\n+    loader = PlainLocatorContextLoader.class)\n+@WebAppConfiguration\n+@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_CLASS)\n+public class GetStartingMemberTest {\n+\n+  @Autowired\n+  private WebApplicationContext webApplicationContext;\n+\n+  @Rule\n+  public ClusterStartupRule cluster = new ClusterStartupRule(1);\n+\n+  @Rule\n+  public ConcurrencyRule concurrency = new ConcurrencyRule();\n+\n+  private ClusterManagementService client;\n+  private LocatorWebContext webContext;\n+\n+  @Before\n+  public void before() {\n+    cluster.setSkipLocalDistributedSystemCleanup(true);\n+    webContext = new LocatorWebContext(webApplicationContext);\n+    client = new ClusterManagementServiceBuilder().setTransport(\n+        new RestTemplateClusterManagementServiceTransport(\n+            new RestTemplate(webContext.getRequestFactory())))\n+        .build();\n+  }\n+\n+  @Test\n+  public void getStartingMember() throws Exception {\n+    Member server0 = new Member();\n+    server0.setId(\"server-0\");\n+    concurrency.add(() -> cluster.startServerVM(0, webContext.getLocator().getPort()));\n+    concurrency.add(() -> {\n+      ClusterManagementGetResult<Member, MemberInformation> result = null;\n+      while (result == null) {\n+        try {\n+          result = client.get(server0);\n+        } catch (ClusterManagementException e) {\n+          // this is expected for the first several tries\n+        }\n+      }\n+      return result;\n+    });\n+    concurrency.executeInParallel();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abad17029387ff0843c011334819a4225472f458"}, "originalPosition": 87}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2efa6bbdf21583a1fbf4095cc85acc9655ee5c8b", "author": {"user": {"login": "jinmeiliao", "name": "Jinmei Liao"}}, "url": "https://github.com/apache/geode/commit/2efa6bbdf21583a1fbf4095cc85acc9655ee5c8b", "committedDate": "2020-05-14T23:16:23Z", "message": "review changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyMjU4MzQy", "url": "https://github.com/apache/geode/pull/5111#pullrequestreview-412258342", "createdAt": "2020-05-14T23:47:39Z", "commit": {"oid": "2efa6bbdf21583a1fbf4095cc85acc9655ee5c8b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyMjgwNzY2", "url": "https://github.com/apache/geode/pull/5111#pullrequestreview-412280766", "createdAt": "2020-05-15T00:59:07Z", "commit": {"oid": "abad17029387ff0843c011334819a4225472f458"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwMDo1OTowOFrOGVzCzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwMDo1OTowOFrOGVzCzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUwOTU4Mg==", "bodyText": "I am not sure the CacheClosedException in the JIRA is thrown this function. This function does not call ResultSender.sendException() to the caller. How can the caller LocatorClusterManagementService get the CacheClosedException and then ClassCastException?", "url": "https://github.com/apache/geode/pull/5111#discussion_r425509582", "createdAt": "2020-05-15T00:59:08Z", "author": {"login": "jchen21"}, "path": "geode-core/src/main/java/org/apache/geode/management/internal/functions/CacheRealizationFunction.java", "diffHunk": "@@ -78,24 +79,44 @@\n   public void execute(FunctionContext<List> context) {\n     AbstractConfiguration cacheElement = (AbstractConfiguration) context.getArguments().get(0);\n     CacheElementOperation operation = (CacheElementOperation) context.getArguments().get(1);\n-    RemoteInputStream jarStream = (RemoteInputStream) context.getArguments().get(2);\n \n-    InternalCache cache = (InternalCache) context.getCache();\n-    try {\n-      if (operation == CacheElementOperation.GET) {\n+    // for get operation, caller is expecting RuntimeInfo\n+    if (operation == CacheElementOperation.GET) {\n+      try {\n+        InternalCache cache = (InternalCache) context.getCache();\n         context.getResultSender().lastResult(executeGet(context, cache, cacheElement));\n-      } else {\n+      } catch (CacheClosedException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abad17029387ff0843c011334819a4225472f458"}, "originalPosition": 23}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4525, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}