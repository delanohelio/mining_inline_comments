{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc0MDI3NDcz", "number": 4691, "reviewThreads": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwMToxMjo0MFrODfBIVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjowMjoyMVrODfWRtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODUwOTY3OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwMToxMjo0MFrOFoeyHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxOToyMTowM1rOFpgckg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk5MTcxMQ==", "bodyText": "Where the code change happened for the latch.", "url": "https://github.com/apache/geode/pull/4691#discussion_r377991711", "createdAt": "2020-02-12T01:12:40Z", "author": {"login": "mhansonp"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "diffHunk": "@@ -1134,15 +1082,18 @@ public void doTestHook(final SPOTS spot, final DefaultQuery _ignored,\n         case BEFORE_QUERY_EXECUTION:\n           try {\n             if (!latch.await(8, SECONDS)) {\n-              fail(\"query was never unlatched\");\n+              logger.warn(\"doTestHook latch took to long to release\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ed0a384c8e21e943e638f8b23b9b5eb9e372d6b"}, "originalPosition": 326}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA2NzUzOA==", "bodyText": "Done.", "url": "https://github.com/apache/geode/pull/4691#discussion_r379067538", "createdAt": "2020-02-13T19:21:03Z", "author": {"login": "mhansonp"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "diffHunk": "@@ -1134,15 +1082,18 @@ public void doTestHook(final SPOTS spot, final DefaultQuery _ignored,\n         case BEFORE_QUERY_EXECUTION:\n           try {\n             if (!latch.await(8, SECONDS)) {\n-              fail(\"query was never unlatched\");\n+              logger.warn(\"doTestHook latch took to long to release\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk5MTcxMQ=="}, "originalCommit": {"oid": "4ed0a384c8e21e943e638f8b23b9b5eb9e372d6b"}, "originalPosition": 326}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MTk1MTIwOnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMTo1NDowOFrOFo_7qA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxOTowNToxNFrOFpf9pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzNDgyNA==", "bodyText": "I recommend changing the 60 seconds to:\nqueryExecution1.get(GeodeAwaitility.getTimeout().getValueInMS(), MILLISECONDS)", "url": "https://github.com/apache/geode/pull/4691#discussion_r378534824", "createdAt": "2020-02-12T21:54:08Z", "author": {"login": "kirklund"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "diffHunk": "@@ -134,606 +126,525 @@ public Object call() throws Exception {\n       irm.getHeapMonitor().setTestMaxMemoryBytes(0);\n       HeapMemoryMonitor.setTestDisableMemoryUpdates(false);\n       return null;\n-    }\n-  };\n-\n-  private SerializableCallable resetQueryMonitor = new SerializableCallable() {\n-    @Override\n-    public Object call() throws Exception {\n-      InternalCache cache = getCache();\n-      if (cache.getQueryMonitor() != null) {\n-        cache.getQueryMonitor().setLowMemory(false, 0);\n-      }\n-      DefaultQuery.testHook = null;\n-      return null;\n-    }\n-  };\n+    });\n+  }\n \n   @Test\n-  public void testRMAndNoTimeoutSet() throws Exception {\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSet() {\n+    doCriticalMemoryHitTest(false, false, -1, true);\n   }\n \n   @Test\n-  public void testRMAndNoTimeoutSetParReg() throws Exception {\n-    doCriticalMemoryHitTest(\"portfolios\", true, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSetParReg() {\n+    doCriticalMemoryHitTest(true, false, -1, true);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSet() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSet() {\n     // verify that timeout is not set and that a query can execute properly\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, -1, true);\n+    doCriticalMemoryHitTest(false, true, -1, true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSet() throws Exception {\n-    // verify that we still receive critical heap cancelation\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, TEST_QUERY_TIMEOUT,\n+  public void testRMAndTimeoutSet() {\n+    // verify that we still receive critical heap cancellation\n+    doCriticalMemoryHitTest(false, true, TEST_QUERY_TIMEOUT,\n         true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSetAndQueryTimesoutInstead() throws Exception {\n+  public void testRMAndTimeoutSetAndQueryTimeoutInstead() {\n     // verify that timeout is set correctly and cancel query\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, TEST_QUERY_TIMEOUT,\n+    doCriticalMemoryHitTest(false, true, TEST_QUERY_TIMEOUT,\n         false);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSet() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSet() {\n     // verify that timeout is still working properly\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, TEST_QUERY_TIMEOUT,\n+    doCriticalMemoryHitTest(false, true, TEST_QUERY_TIMEOUT,\n         true);\n   }\n \n   // Query directly on member with RM and QM set\n   @Test\n-  public void testRMAndNoTimeoutSetOnServer() throws Exception {\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSetOnServer() {\n+    doCriticalMemoryHitTestOnServer(false, false, -1, true);\n   }\n \n   // Query directly on member with RM and QM set\n   @Test\n-  public void whenTimeoutIsSetAndAQueryIsExecutedThenTimeoutMustStopTheQueryBeforeCriticalMemory()\n-      throws Exception {\n+  public void whenTimeoutIsSetAndAQueryIsExecutedThenTimeoutMustStopTheQueryBeforeCriticalMemory() {\n     // Timeout is set along with critical heap but it be called after the timeout expires\n     // Timeout is set to 1ms which is very unrealistic time period for a query to be able to fetch\n     // 200 entries from the region successfully, hence a timeout is expected.\n-    executeQueryWithTimeoutSetAndCriticalThreshold(\"portfolios\", false, 85/* crit threshold */,\n-        false, 1, true);\n+    // create region on the server\n+    final VM server = VM.getVM(0);\n+    try {\n+      final int port = AvailablePortHelper.getRandomAvailableTCPPort();\n+      startCacheServer(server, port, false, 1,\n+          false);\n+      populateData(server);\n+      executeQueryWithCriticalHeapCalledAfterTimeout(server, server);\n+      vmRecoversFromCriticalHeap(server);\n+\n+    } finally {\n+      stopServer(server);\n+    }\n   }\n \n   @Test\n-  public void whenTimeoutIsSetAndAQueryIsExecutedFromClientThenTimeoutMustStopTheQueryBeforeCriticalMemory()\n-      throws Exception {\n+  public void whenTimeoutIsSetAndAQueryIsExecutedFromClientThenTimeoutMustStopTheQueryBeforeCriticalMemory() {\n     // Timeout is set along with critical heap but it be called after the timeout expires\n     // Timeout is set to 1ms which is very unrealistic time period for a query to be able to fetch\n     // 200 entries from the region successfully, hence a timeout is expected.\n-    executeQueryFromClientWithTimeoutSetAndCriticalThreshold(\"portfolios\", false,\n-        85/* crit threshold */, false, 1, true);\n+    // create region on the server\n+    final VM server = VM.getVM(0);\n+    final VM client = VM.getVM(1);\n+    try {\n+      final int port = AvailablePortHelper.getRandomAvailableTCPPort();\n+      startCacheServer(server, port, false, 1,\n+          false);\n+      startClient(client, port);\n+      populateData(server);\n+      executeQueryWithCriticalHeapCalledAfterTimeout(server, client);\n+      vmRecoversFromCriticalHeap(server);\n+\n+    } finally {\n+      stopServer(server);\n+    }\n   }\n \n   @Test\n-  public void testRMAndNoTimeoutSetParRegOnServer() throws Exception {\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", true, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSetParRegOnServer() {\n+    doCriticalMemoryHitTestOnServer(true, false, -1, true);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSetOnServer() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSetOnServer() {\n     // verify that timeout is not set and that a query can execute properly\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true, -1, true);\n+    doCriticalMemoryHitTestOnServer(false, true, -1, true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSetOnServer() throws Exception {\n-    // verify that we still receive critical heap cancelation\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true,\n+  public void testRMAndTimeoutSetOnServer() {\n+    // verify that we still receive critical heap cancellation\n+    doCriticalMemoryHitTestOnServer(false, true,\n         TEST_QUERY_TIMEOUT, true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSetAndQueryTimesoutInsteadOnServer() throws Exception {\n+  public void testRMAndTimeoutSetAndQueryTimeoutInsteadOnServer() {\n     // verify that timeout is set correctly and cancel query\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true,\n+    doCriticalMemoryHitTestOnServer(false, true,\n         TEST_QUERY_TIMEOUT, false);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSetOnServer() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSetOnServer() {\n     // verify that timeout is still working properly\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true,\n+    doCriticalMemoryHitTestOnServer(false, true,\n         TEST_QUERY_TIMEOUT, true);\n   }\n \n   @Test\n-  public void testPRGatherCancellation() throws Exception {\n-    doCriticalMemoryHitTestWithMultipleServers(\"portfolios\", true, 85/* crit threshold */, false,\n-        -1, true);\n-  }\n-\n-  @Test\n-  public void testPRGatherCancellationWhileGatheringResults() throws Exception {\n-    doCriticalMemoryHitDuringGatherTestWithMultipleServers(\"portfolios\", true,\n-        85/* crit threshold */, false, -1, true);\n-  }\n+  public void testPRGatherCancellation() throws Throwable {\n+    // create region on the server\n+    final VM server1 = VM.getVM(0);\n+    final VM server2 = VM.getVM(1);\n+    final VM client = VM.getVM(2);\n+    final int numObjects = 200;\n+    final VM controller = VM.getController();\n+    try {\n+      final int[] port = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n+      startCacheServer(server1, port[0], false,\n+          -1, true);\n+      startCacheServer(server2, port[1], true, -1, true);\n+\n+      startClient(client, port[0]);\n+      populateData(server2);\n+      server1.invoke(\"create latch test Hook\", () -> {\n+        DefaultQuery.testHook = getPauseHook(true, controller);\n+      });\n+      // remove from here to ....\n+      AsyncInvocation queryExecution1 = executeQueryOnClient(client);\n \n-  @Test\n-  public void testPRGatherCancellationWhileAddingResults() throws Exception {\n-    doCriticalMemoryHitAddResultsTestWithMultipleServers(\"portfolios\", true, 85/* crit threshold */,\n-        false, -1, true);\n-  }\n+      // Gives async invocation a chance to start\n+      Thread.sleep(1000);\n+      // We simulate a low memory/critical heap percentage hit\n+      setHeapToCriticalAndReleaseLatch(server1);\n+      assertThat(queryExecution1.get(60, SECONDS)).isEqualTo(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40db9bd39c00a0468aa08ddc4541cd0d26d2f2b9"}, "originalPosition": 346}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA1OTYyMw==", "bodyText": "Done", "url": "https://github.com/apache/geode/pull/4691#discussion_r379059623", "createdAt": "2020-02-13T19:05:14Z", "author": {"login": "mhansonp"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "diffHunk": "@@ -134,606 +126,525 @@ public Object call() throws Exception {\n       irm.getHeapMonitor().setTestMaxMemoryBytes(0);\n       HeapMemoryMonitor.setTestDisableMemoryUpdates(false);\n       return null;\n-    }\n-  };\n-\n-  private SerializableCallable resetQueryMonitor = new SerializableCallable() {\n-    @Override\n-    public Object call() throws Exception {\n-      InternalCache cache = getCache();\n-      if (cache.getQueryMonitor() != null) {\n-        cache.getQueryMonitor().setLowMemory(false, 0);\n-      }\n-      DefaultQuery.testHook = null;\n-      return null;\n-    }\n-  };\n+    });\n+  }\n \n   @Test\n-  public void testRMAndNoTimeoutSet() throws Exception {\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSet() {\n+    doCriticalMemoryHitTest(false, false, -1, true);\n   }\n \n   @Test\n-  public void testRMAndNoTimeoutSetParReg() throws Exception {\n-    doCriticalMemoryHitTest(\"portfolios\", true, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSetParReg() {\n+    doCriticalMemoryHitTest(true, false, -1, true);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSet() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSet() {\n     // verify that timeout is not set and that a query can execute properly\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, -1, true);\n+    doCriticalMemoryHitTest(false, true, -1, true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSet() throws Exception {\n-    // verify that we still receive critical heap cancelation\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, TEST_QUERY_TIMEOUT,\n+  public void testRMAndTimeoutSet() {\n+    // verify that we still receive critical heap cancellation\n+    doCriticalMemoryHitTest(false, true, TEST_QUERY_TIMEOUT,\n         true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSetAndQueryTimesoutInstead() throws Exception {\n+  public void testRMAndTimeoutSetAndQueryTimeoutInstead() {\n     // verify that timeout is set correctly and cancel query\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, TEST_QUERY_TIMEOUT,\n+    doCriticalMemoryHitTest(false, true, TEST_QUERY_TIMEOUT,\n         false);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSet() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSet() {\n     // verify that timeout is still working properly\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, TEST_QUERY_TIMEOUT,\n+    doCriticalMemoryHitTest(false, true, TEST_QUERY_TIMEOUT,\n         true);\n   }\n \n   // Query directly on member with RM and QM set\n   @Test\n-  public void testRMAndNoTimeoutSetOnServer() throws Exception {\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSetOnServer() {\n+    doCriticalMemoryHitTestOnServer(false, false, -1, true);\n   }\n \n   // Query directly on member with RM and QM set\n   @Test\n-  public void whenTimeoutIsSetAndAQueryIsExecutedThenTimeoutMustStopTheQueryBeforeCriticalMemory()\n-      throws Exception {\n+  public void whenTimeoutIsSetAndAQueryIsExecutedThenTimeoutMustStopTheQueryBeforeCriticalMemory() {\n     // Timeout is set along with critical heap but it be called after the timeout expires\n     // Timeout is set to 1ms which is very unrealistic time period for a query to be able to fetch\n     // 200 entries from the region successfully, hence a timeout is expected.\n-    executeQueryWithTimeoutSetAndCriticalThreshold(\"portfolios\", false, 85/* crit threshold */,\n-        false, 1, true);\n+    // create region on the server\n+    final VM server = VM.getVM(0);\n+    try {\n+      final int port = AvailablePortHelper.getRandomAvailableTCPPort();\n+      startCacheServer(server, port, false, 1,\n+          false);\n+      populateData(server);\n+      executeQueryWithCriticalHeapCalledAfterTimeout(server, server);\n+      vmRecoversFromCriticalHeap(server);\n+\n+    } finally {\n+      stopServer(server);\n+    }\n   }\n \n   @Test\n-  public void whenTimeoutIsSetAndAQueryIsExecutedFromClientThenTimeoutMustStopTheQueryBeforeCriticalMemory()\n-      throws Exception {\n+  public void whenTimeoutIsSetAndAQueryIsExecutedFromClientThenTimeoutMustStopTheQueryBeforeCriticalMemory() {\n     // Timeout is set along with critical heap but it be called after the timeout expires\n     // Timeout is set to 1ms which is very unrealistic time period for a query to be able to fetch\n     // 200 entries from the region successfully, hence a timeout is expected.\n-    executeQueryFromClientWithTimeoutSetAndCriticalThreshold(\"portfolios\", false,\n-        85/* crit threshold */, false, 1, true);\n+    // create region on the server\n+    final VM server = VM.getVM(0);\n+    final VM client = VM.getVM(1);\n+    try {\n+      final int port = AvailablePortHelper.getRandomAvailableTCPPort();\n+      startCacheServer(server, port, false, 1,\n+          false);\n+      startClient(client, port);\n+      populateData(server);\n+      executeQueryWithCriticalHeapCalledAfterTimeout(server, client);\n+      vmRecoversFromCriticalHeap(server);\n+\n+    } finally {\n+      stopServer(server);\n+    }\n   }\n \n   @Test\n-  public void testRMAndNoTimeoutSetParRegOnServer() throws Exception {\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", true, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSetParRegOnServer() {\n+    doCriticalMemoryHitTestOnServer(true, false, -1, true);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSetOnServer() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSetOnServer() {\n     // verify that timeout is not set and that a query can execute properly\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true, -1, true);\n+    doCriticalMemoryHitTestOnServer(false, true, -1, true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSetOnServer() throws Exception {\n-    // verify that we still receive critical heap cancelation\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true,\n+  public void testRMAndTimeoutSetOnServer() {\n+    // verify that we still receive critical heap cancellation\n+    doCriticalMemoryHitTestOnServer(false, true,\n         TEST_QUERY_TIMEOUT, true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSetAndQueryTimesoutInsteadOnServer() throws Exception {\n+  public void testRMAndTimeoutSetAndQueryTimeoutInsteadOnServer() {\n     // verify that timeout is set correctly and cancel query\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true,\n+    doCriticalMemoryHitTestOnServer(false, true,\n         TEST_QUERY_TIMEOUT, false);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSetOnServer() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSetOnServer() {\n     // verify that timeout is still working properly\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true,\n+    doCriticalMemoryHitTestOnServer(false, true,\n         TEST_QUERY_TIMEOUT, true);\n   }\n \n   @Test\n-  public void testPRGatherCancellation() throws Exception {\n-    doCriticalMemoryHitTestWithMultipleServers(\"portfolios\", true, 85/* crit threshold */, false,\n-        -1, true);\n-  }\n-\n-  @Test\n-  public void testPRGatherCancellationWhileGatheringResults() throws Exception {\n-    doCriticalMemoryHitDuringGatherTestWithMultipleServers(\"portfolios\", true,\n-        85/* crit threshold */, false, -1, true);\n-  }\n+  public void testPRGatherCancellation() throws Throwable {\n+    // create region on the server\n+    final VM server1 = VM.getVM(0);\n+    final VM server2 = VM.getVM(1);\n+    final VM client = VM.getVM(2);\n+    final int numObjects = 200;\n+    final VM controller = VM.getController();\n+    try {\n+      final int[] port = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n+      startCacheServer(server1, port[0], false,\n+          -1, true);\n+      startCacheServer(server2, port[1], true, -1, true);\n+\n+      startClient(client, port[0]);\n+      populateData(server2);\n+      server1.invoke(\"create latch test Hook\", () -> {\n+        DefaultQuery.testHook = getPauseHook(true, controller);\n+      });\n+      // remove from here to ....\n+      AsyncInvocation queryExecution1 = executeQueryOnClient(client);\n \n-  @Test\n-  public void testPRGatherCancellationWhileAddingResults() throws Exception {\n-    doCriticalMemoryHitAddResultsTestWithMultipleServers(\"portfolios\", true, 85/* crit threshold */,\n-        false, -1, true);\n-  }\n+      // Gives async invocation a chance to start\n+      Thread.sleep(1000);\n+      // We simulate a low memory/critical heap percentage hit\n+      setHeapToCriticalAndReleaseLatch(server1);\n+      assertThat(queryExecution1.get(60, SECONDS)).isEqualTo(0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzNDgyNA=="}, "originalCommit": {"oid": "40db9bd39c00a0468aa08ddc4541cd0d26d2f2b9"}, "originalPosition": 346}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MTk1MjU2OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMTo1NDozNVrOFo_8eA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxOTowNToyM1rOFpf95Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzNTAzMg==", "bodyText": "I would delete the catch-block and remove the fail(\"\")", "url": "https://github.com/apache/geode/pull/4691#discussion_r378535032", "createdAt": "2020-02-12T21:54:35Z", "author": {"login": "kirklund"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "diffHunk": "@@ -134,606 +126,525 @@ public Object call() throws Exception {\n       irm.getHeapMonitor().setTestMaxMemoryBytes(0);\n       HeapMemoryMonitor.setTestDisableMemoryUpdates(false);\n       return null;\n-    }\n-  };\n-\n-  private SerializableCallable resetQueryMonitor = new SerializableCallable() {\n-    @Override\n-    public Object call() throws Exception {\n-      InternalCache cache = getCache();\n-      if (cache.getQueryMonitor() != null) {\n-        cache.getQueryMonitor().setLowMemory(false, 0);\n-      }\n-      DefaultQuery.testHook = null;\n-      return null;\n-    }\n-  };\n+    });\n+  }\n \n   @Test\n-  public void testRMAndNoTimeoutSet() throws Exception {\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSet() {\n+    doCriticalMemoryHitTest(false, false, -1, true);\n   }\n \n   @Test\n-  public void testRMAndNoTimeoutSetParReg() throws Exception {\n-    doCriticalMemoryHitTest(\"portfolios\", true, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSetParReg() {\n+    doCriticalMemoryHitTest(true, false, -1, true);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSet() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSet() {\n     // verify that timeout is not set and that a query can execute properly\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, -1, true);\n+    doCriticalMemoryHitTest(false, true, -1, true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSet() throws Exception {\n-    // verify that we still receive critical heap cancelation\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, TEST_QUERY_TIMEOUT,\n+  public void testRMAndTimeoutSet() {\n+    // verify that we still receive critical heap cancellation\n+    doCriticalMemoryHitTest(false, true, TEST_QUERY_TIMEOUT,\n         true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSetAndQueryTimesoutInstead() throws Exception {\n+  public void testRMAndTimeoutSetAndQueryTimeoutInstead() {\n     // verify that timeout is set correctly and cancel query\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, TEST_QUERY_TIMEOUT,\n+    doCriticalMemoryHitTest(false, true, TEST_QUERY_TIMEOUT,\n         false);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSet() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSet() {\n     // verify that timeout is still working properly\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, TEST_QUERY_TIMEOUT,\n+    doCriticalMemoryHitTest(false, true, TEST_QUERY_TIMEOUT,\n         true);\n   }\n \n   // Query directly on member with RM and QM set\n   @Test\n-  public void testRMAndNoTimeoutSetOnServer() throws Exception {\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSetOnServer() {\n+    doCriticalMemoryHitTestOnServer(false, false, -1, true);\n   }\n \n   // Query directly on member with RM and QM set\n   @Test\n-  public void whenTimeoutIsSetAndAQueryIsExecutedThenTimeoutMustStopTheQueryBeforeCriticalMemory()\n-      throws Exception {\n+  public void whenTimeoutIsSetAndAQueryIsExecutedThenTimeoutMustStopTheQueryBeforeCriticalMemory() {\n     // Timeout is set along with critical heap but it be called after the timeout expires\n     // Timeout is set to 1ms which is very unrealistic time period for a query to be able to fetch\n     // 200 entries from the region successfully, hence a timeout is expected.\n-    executeQueryWithTimeoutSetAndCriticalThreshold(\"portfolios\", false, 85/* crit threshold */,\n-        false, 1, true);\n+    // create region on the server\n+    final VM server = VM.getVM(0);\n+    try {\n+      final int port = AvailablePortHelper.getRandomAvailableTCPPort();\n+      startCacheServer(server, port, false, 1,\n+          false);\n+      populateData(server);\n+      executeQueryWithCriticalHeapCalledAfterTimeout(server, server);\n+      vmRecoversFromCriticalHeap(server);\n+\n+    } finally {\n+      stopServer(server);\n+    }\n   }\n \n   @Test\n-  public void whenTimeoutIsSetAndAQueryIsExecutedFromClientThenTimeoutMustStopTheQueryBeforeCriticalMemory()\n-      throws Exception {\n+  public void whenTimeoutIsSetAndAQueryIsExecutedFromClientThenTimeoutMustStopTheQueryBeforeCriticalMemory() {\n     // Timeout is set along with critical heap but it be called after the timeout expires\n     // Timeout is set to 1ms which is very unrealistic time period for a query to be able to fetch\n     // 200 entries from the region successfully, hence a timeout is expected.\n-    executeQueryFromClientWithTimeoutSetAndCriticalThreshold(\"portfolios\", false,\n-        85/* crit threshold */, false, 1, true);\n+    // create region on the server\n+    final VM server = VM.getVM(0);\n+    final VM client = VM.getVM(1);\n+    try {\n+      final int port = AvailablePortHelper.getRandomAvailableTCPPort();\n+      startCacheServer(server, port, false, 1,\n+          false);\n+      startClient(client, port);\n+      populateData(server);\n+      executeQueryWithCriticalHeapCalledAfterTimeout(server, client);\n+      vmRecoversFromCriticalHeap(server);\n+\n+    } finally {\n+      stopServer(server);\n+    }\n   }\n \n   @Test\n-  public void testRMAndNoTimeoutSetParRegOnServer() throws Exception {\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", true, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSetParRegOnServer() {\n+    doCriticalMemoryHitTestOnServer(true, false, -1, true);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSetOnServer() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSetOnServer() {\n     // verify that timeout is not set and that a query can execute properly\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true, -1, true);\n+    doCriticalMemoryHitTestOnServer(false, true, -1, true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSetOnServer() throws Exception {\n-    // verify that we still receive critical heap cancelation\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true,\n+  public void testRMAndTimeoutSetOnServer() {\n+    // verify that we still receive critical heap cancellation\n+    doCriticalMemoryHitTestOnServer(false, true,\n         TEST_QUERY_TIMEOUT, true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSetAndQueryTimesoutInsteadOnServer() throws Exception {\n+  public void testRMAndTimeoutSetAndQueryTimeoutInsteadOnServer() {\n     // verify that timeout is set correctly and cancel query\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true,\n+    doCriticalMemoryHitTestOnServer(false, true,\n         TEST_QUERY_TIMEOUT, false);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSetOnServer() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSetOnServer() {\n     // verify that timeout is still working properly\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true,\n+    doCriticalMemoryHitTestOnServer(false, true,\n         TEST_QUERY_TIMEOUT, true);\n   }\n \n   @Test\n-  public void testPRGatherCancellation() throws Exception {\n-    doCriticalMemoryHitTestWithMultipleServers(\"portfolios\", true, 85/* crit threshold */, false,\n-        -1, true);\n-  }\n-\n-  @Test\n-  public void testPRGatherCancellationWhileGatheringResults() throws Exception {\n-    doCriticalMemoryHitDuringGatherTestWithMultipleServers(\"portfolios\", true,\n-        85/* crit threshold */, false, -1, true);\n-  }\n+  public void testPRGatherCancellation() throws Throwable {\n+    // create region on the server\n+    final VM server1 = VM.getVM(0);\n+    final VM server2 = VM.getVM(1);\n+    final VM client = VM.getVM(2);\n+    final int numObjects = 200;\n+    final VM controller = VM.getController();\n+    try {\n+      final int[] port = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n+      startCacheServer(server1, port[0], false,\n+          -1, true);\n+      startCacheServer(server2, port[1], true, -1, true);\n+\n+      startClient(client, port[0]);\n+      populateData(server2);\n+      server1.invoke(\"create latch test Hook\", () -> {\n+        DefaultQuery.testHook = getPauseHook(true, controller);\n+      });\n+      // remove from here to ....\n+      AsyncInvocation queryExecution1 = executeQueryOnClient(client);\n \n-  @Test\n-  public void testPRGatherCancellationWhileAddingResults() throws Exception {\n-    doCriticalMemoryHitAddResultsTestWithMultipleServers(\"portfolios\", true, 85/* crit threshold */,\n-        false, -1, true);\n-  }\n+      // Gives async invocation a chance to start\n+      Thread.sleep(1000);\n+      // We simulate a low memory/critical heap percentage hit\n+      setHeapToCriticalAndReleaseLatch(server1);\n+      assertThat(queryExecution1.get(60, SECONDS)).isEqualTo(0);\n+      verifyDroppedObjectsAndSetHeapToNormal(server1);\n \n-  @Test\n-  public void testIndexCreationCancellationPR() throws Exception {\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", true, 85/* crit threshold */, false, -1, true,\n-        \"compact\");\n-  }\n+      // to here....\n+      // Check to see if query execution is ok under \"normal\" or \"healthy\" conditions\n+      client.invoke(\"Executing query when system is 'Normal'\", () -> {\n+        try {\n+          Query query = getCache().getQueryService().newQuery(\"Select * From /\" + \"portfolios\");\n+          SelectResults results = (SelectResults) query.execute();\n+          assertThat(results.size()).isEqualTo(numObjects);\n+        } catch (QueryInvocationTargetException | FunctionDomainException | TypeMismatchException", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40db9bd39c00a0468aa08ddc4541cd0d26d2f2b9"}, "originalPosition": 361}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA1OTY4NQ==", "bodyText": "Done", "url": "https://github.com/apache/geode/pull/4691#discussion_r379059685", "createdAt": "2020-02-13T19:05:23Z", "author": {"login": "mhansonp"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "diffHunk": "@@ -134,606 +126,525 @@ public Object call() throws Exception {\n       irm.getHeapMonitor().setTestMaxMemoryBytes(0);\n       HeapMemoryMonitor.setTestDisableMemoryUpdates(false);\n       return null;\n-    }\n-  };\n-\n-  private SerializableCallable resetQueryMonitor = new SerializableCallable() {\n-    @Override\n-    public Object call() throws Exception {\n-      InternalCache cache = getCache();\n-      if (cache.getQueryMonitor() != null) {\n-        cache.getQueryMonitor().setLowMemory(false, 0);\n-      }\n-      DefaultQuery.testHook = null;\n-      return null;\n-    }\n-  };\n+    });\n+  }\n \n   @Test\n-  public void testRMAndNoTimeoutSet() throws Exception {\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSet() {\n+    doCriticalMemoryHitTest(false, false, -1, true);\n   }\n \n   @Test\n-  public void testRMAndNoTimeoutSetParReg() throws Exception {\n-    doCriticalMemoryHitTest(\"portfolios\", true, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSetParReg() {\n+    doCriticalMemoryHitTest(true, false, -1, true);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSet() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSet() {\n     // verify that timeout is not set and that a query can execute properly\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, -1, true);\n+    doCriticalMemoryHitTest(false, true, -1, true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSet() throws Exception {\n-    // verify that we still receive critical heap cancelation\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, TEST_QUERY_TIMEOUT,\n+  public void testRMAndTimeoutSet() {\n+    // verify that we still receive critical heap cancellation\n+    doCriticalMemoryHitTest(false, true, TEST_QUERY_TIMEOUT,\n         true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSetAndQueryTimesoutInstead() throws Exception {\n+  public void testRMAndTimeoutSetAndQueryTimeoutInstead() {\n     // verify that timeout is set correctly and cancel query\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, TEST_QUERY_TIMEOUT,\n+    doCriticalMemoryHitTest(false, true, TEST_QUERY_TIMEOUT,\n         false);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSet() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSet() {\n     // verify that timeout is still working properly\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, TEST_QUERY_TIMEOUT,\n+    doCriticalMemoryHitTest(false, true, TEST_QUERY_TIMEOUT,\n         true);\n   }\n \n   // Query directly on member with RM and QM set\n   @Test\n-  public void testRMAndNoTimeoutSetOnServer() throws Exception {\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSetOnServer() {\n+    doCriticalMemoryHitTestOnServer(false, false, -1, true);\n   }\n \n   // Query directly on member with RM and QM set\n   @Test\n-  public void whenTimeoutIsSetAndAQueryIsExecutedThenTimeoutMustStopTheQueryBeforeCriticalMemory()\n-      throws Exception {\n+  public void whenTimeoutIsSetAndAQueryIsExecutedThenTimeoutMustStopTheQueryBeforeCriticalMemory() {\n     // Timeout is set along with critical heap but it be called after the timeout expires\n     // Timeout is set to 1ms which is very unrealistic time period for a query to be able to fetch\n     // 200 entries from the region successfully, hence a timeout is expected.\n-    executeQueryWithTimeoutSetAndCriticalThreshold(\"portfolios\", false, 85/* crit threshold */,\n-        false, 1, true);\n+    // create region on the server\n+    final VM server = VM.getVM(0);\n+    try {\n+      final int port = AvailablePortHelper.getRandomAvailableTCPPort();\n+      startCacheServer(server, port, false, 1,\n+          false);\n+      populateData(server);\n+      executeQueryWithCriticalHeapCalledAfterTimeout(server, server);\n+      vmRecoversFromCriticalHeap(server);\n+\n+    } finally {\n+      stopServer(server);\n+    }\n   }\n \n   @Test\n-  public void whenTimeoutIsSetAndAQueryIsExecutedFromClientThenTimeoutMustStopTheQueryBeforeCriticalMemory()\n-      throws Exception {\n+  public void whenTimeoutIsSetAndAQueryIsExecutedFromClientThenTimeoutMustStopTheQueryBeforeCriticalMemory() {\n     // Timeout is set along with critical heap but it be called after the timeout expires\n     // Timeout is set to 1ms which is very unrealistic time period for a query to be able to fetch\n     // 200 entries from the region successfully, hence a timeout is expected.\n-    executeQueryFromClientWithTimeoutSetAndCriticalThreshold(\"portfolios\", false,\n-        85/* crit threshold */, false, 1, true);\n+    // create region on the server\n+    final VM server = VM.getVM(0);\n+    final VM client = VM.getVM(1);\n+    try {\n+      final int port = AvailablePortHelper.getRandomAvailableTCPPort();\n+      startCacheServer(server, port, false, 1,\n+          false);\n+      startClient(client, port);\n+      populateData(server);\n+      executeQueryWithCriticalHeapCalledAfterTimeout(server, client);\n+      vmRecoversFromCriticalHeap(server);\n+\n+    } finally {\n+      stopServer(server);\n+    }\n   }\n \n   @Test\n-  public void testRMAndNoTimeoutSetParRegOnServer() throws Exception {\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", true, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSetParRegOnServer() {\n+    doCriticalMemoryHitTestOnServer(true, false, -1, true);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSetOnServer() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSetOnServer() {\n     // verify that timeout is not set and that a query can execute properly\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true, -1, true);\n+    doCriticalMemoryHitTestOnServer(false, true, -1, true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSetOnServer() throws Exception {\n-    // verify that we still receive critical heap cancelation\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true,\n+  public void testRMAndTimeoutSetOnServer() {\n+    // verify that we still receive critical heap cancellation\n+    doCriticalMemoryHitTestOnServer(false, true,\n         TEST_QUERY_TIMEOUT, true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSetAndQueryTimesoutInsteadOnServer() throws Exception {\n+  public void testRMAndTimeoutSetAndQueryTimeoutInsteadOnServer() {\n     // verify that timeout is set correctly and cancel query\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true,\n+    doCriticalMemoryHitTestOnServer(false, true,\n         TEST_QUERY_TIMEOUT, false);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSetOnServer() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSetOnServer() {\n     // verify that timeout is still working properly\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true,\n+    doCriticalMemoryHitTestOnServer(false, true,\n         TEST_QUERY_TIMEOUT, true);\n   }\n \n   @Test\n-  public void testPRGatherCancellation() throws Exception {\n-    doCriticalMemoryHitTestWithMultipleServers(\"portfolios\", true, 85/* crit threshold */, false,\n-        -1, true);\n-  }\n-\n-  @Test\n-  public void testPRGatherCancellationWhileGatheringResults() throws Exception {\n-    doCriticalMemoryHitDuringGatherTestWithMultipleServers(\"portfolios\", true,\n-        85/* crit threshold */, false, -1, true);\n-  }\n+  public void testPRGatherCancellation() throws Throwable {\n+    // create region on the server\n+    final VM server1 = VM.getVM(0);\n+    final VM server2 = VM.getVM(1);\n+    final VM client = VM.getVM(2);\n+    final int numObjects = 200;\n+    final VM controller = VM.getController();\n+    try {\n+      final int[] port = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n+      startCacheServer(server1, port[0], false,\n+          -1, true);\n+      startCacheServer(server2, port[1], true, -1, true);\n+\n+      startClient(client, port[0]);\n+      populateData(server2);\n+      server1.invoke(\"create latch test Hook\", () -> {\n+        DefaultQuery.testHook = getPauseHook(true, controller);\n+      });\n+      // remove from here to ....\n+      AsyncInvocation queryExecution1 = executeQueryOnClient(client);\n \n-  @Test\n-  public void testPRGatherCancellationWhileAddingResults() throws Exception {\n-    doCriticalMemoryHitAddResultsTestWithMultipleServers(\"portfolios\", true, 85/* crit threshold */,\n-        false, -1, true);\n-  }\n+      // Gives async invocation a chance to start\n+      Thread.sleep(1000);\n+      // We simulate a low memory/critical heap percentage hit\n+      setHeapToCriticalAndReleaseLatch(server1);\n+      assertThat(queryExecution1.get(60, SECONDS)).isEqualTo(0);\n+      verifyDroppedObjectsAndSetHeapToNormal(server1);\n \n-  @Test\n-  public void testIndexCreationCancellationPR() throws Exception {\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", true, 85/* crit threshold */, false, -1, true,\n-        \"compact\");\n-  }\n+      // to here....\n+      // Check to see if query execution is ok under \"normal\" or \"healthy\" conditions\n+      client.invoke(\"Executing query when system is 'Normal'\", () -> {\n+        try {\n+          Query query = getCache().getQueryService().newQuery(\"Select * From /\" + \"portfolios\");\n+          SelectResults results = (SelectResults) query.execute();\n+          assertThat(results.size()).isEqualTo(numObjects);\n+        } catch (QueryInvocationTargetException | FunctionDomainException | TypeMismatchException", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzNTAzMg=="}, "originalCommit": {"oid": "40db9bd39c00a0468aa08ddc4541cd0d26d2f2b9"}, "originalPosition": 361}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MTk1MzQ2OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMTo1NDo1NVrOFo_9Cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxOTowNjo1NFrOFpgA-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzNTE3OA==", "bodyText": "Change 60 seconds to GeodeAwaitility.getTimeout().", "url": "https://github.com/apache/geode/pull/4691#discussion_r378535178", "createdAt": "2020-02-12T21:54:55Z", "author": {"login": "kirklund"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "diffHunk": "@@ -134,606 +126,525 @@ public Object call() throws Exception {\n       irm.getHeapMonitor().setTestMaxMemoryBytes(0);\n       HeapMemoryMonitor.setTestDisableMemoryUpdates(false);\n       return null;\n-    }\n-  };\n-\n-  private SerializableCallable resetQueryMonitor = new SerializableCallable() {\n-    @Override\n-    public Object call() throws Exception {\n-      InternalCache cache = getCache();\n-      if (cache.getQueryMonitor() != null) {\n-        cache.getQueryMonitor().setLowMemory(false, 0);\n-      }\n-      DefaultQuery.testHook = null;\n-      return null;\n-    }\n-  };\n+    });\n+  }\n \n   @Test\n-  public void testRMAndNoTimeoutSet() throws Exception {\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSet() {\n+    doCriticalMemoryHitTest(false, false, -1, true);\n   }\n \n   @Test\n-  public void testRMAndNoTimeoutSetParReg() throws Exception {\n-    doCriticalMemoryHitTest(\"portfolios\", true, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSetParReg() {\n+    doCriticalMemoryHitTest(true, false, -1, true);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSet() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSet() {\n     // verify that timeout is not set and that a query can execute properly\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, -1, true);\n+    doCriticalMemoryHitTest(false, true, -1, true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSet() throws Exception {\n-    // verify that we still receive critical heap cancelation\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, TEST_QUERY_TIMEOUT,\n+  public void testRMAndTimeoutSet() {\n+    // verify that we still receive critical heap cancellation\n+    doCriticalMemoryHitTest(false, true, TEST_QUERY_TIMEOUT,\n         true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSetAndQueryTimesoutInstead() throws Exception {\n+  public void testRMAndTimeoutSetAndQueryTimeoutInstead() {\n     // verify that timeout is set correctly and cancel query\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, TEST_QUERY_TIMEOUT,\n+    doCriticalMemoryHitTest(false, true, TEST_QUERY_TIMEOUT,\n         false);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSet() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSet() {\n     // verify that timeout is still working properly\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, TEST_QUERY_TIMEOUT,\n+    doCriticalMemoryHitTest(false, true, TEST_QUERY_TIMEOUT,\n         true);\n   }\n \n   // Query directly on member with RM and QM set\n   @Test\n-  public void testRMAndNoTimeoutSetOnServer() throws Exception {\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSetOnServer() {\n+    doCriticalMemoryHitTestOnServer(false, false, -1, true);\n   }\n \n   // Query directly on member with RM and QM set\n   @Test\n-  public void whenTimeoutIsSetAndAQueryIsExecutedThenTimeoutMustStopTheQueryBeforeCriticalMemory()\n-      throws Exception {\n+  public void whenTimeoutIsSetAndAQueryIsExecutedThenTimeoutMustStopTheQueryBeforeCriticalMemory() {\n     // Timeout is set along with critical heap but it be called after the timeout expires\n     // Timeout is set to 1ms which is very unrealistic time period for a query to be able to fetch\n     // 200 entries from the region successfully, hence a timeout is expected.\n-    executeQueryWithTimeoutSetAndCriticalThreshold(\"portfolios\", false, 85/* crit threshold */,\n-        false, 1, true);\n+    // create region on the server\n+    final VM server = VM.getVM(0);\n+    try {\n+      final int port = AvailablePortHelper.getRandomAvailableTCPPort();\n+      startCacheServer(server, port, false, 1,\n+          false);\n+      populateData(server);\n+      executeQueryWithCriticalHeapCalledAfterTimeout(server, server);\n+      vmRecoversFromCriticalHeap(server);\n+\n+    } finally {\n+      stopServer(server);\n+    }\n   }\n \n   @Test\n-  public void whenTimeoutIsSetAndAQueryIsExecutedFromClientThenTimeoutMustStopTheQueryBeforeCriticalMemory()\n-      throws Exception {\n+  public void whenTimeoutIsSetAndAQueryIsExecutedFromClientThenTimeoutMustStopTheQueryBeforeCriticalMemory() {\n     // Timeout is set along with critical heap but it be called after the timeout expires\n     // Timeout is set to 1ms which is very unrealistic time period for a query to be able to fetch\n     // 200 entries from the region successfully, hence a timeout is expected.\n-    executeQueryFromClientWithTimeoutSetAndCriticalThreshold(\"portfolios\", false,\n-        85/* crit threshold */, false, 1, true);\n+    // create region on the server\n+    final VM server = VM.getVM(0);\n+    final VM client = VM.getVM(1);\n+    try {\n+      final int port = AvailablePortHelper.getRandomAvailableTCPPort();\n+      startCacheServer(server, port, false, 1,\n+          false);\n+      startClient(client, port);\n+      populateData(server);\n+      executeQueryWithCriticalHeapCalledAfterTimeout(server, client);\n+      vmRecoversFromCriticalHeap(server);\n+\n+    } finally {\n+      stopServer(server);\n+    }\n   }\n \n   @Test\n-  public void testRMAndNoTimeoutSetParRegOnServer() throws Exception {\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", true, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSetParRegOnServer() {\n+    doCriticalMemoryHitTestOnServer(true, false, -1, true);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSetOnServer() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSetOnServer() {\n     // verify that timeout is not set and that a query can execute properly\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true, -1, true);\n+    doCriticalMemoryHitTestOnServer(false, true, -1, true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSetOnServer() throws Exception {\n-    // verify that we still receive critical heap cancelation\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true,\n+  public void testRMAndTimeoutSetOnServer() {\n+    // verify that we still receive critical heap cancellation\n+    doCriticalMemoryHitTestOnServer(false, true,\n         TEST_QUERY_TIMEOUT, true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSetAndQueryTimesoutInsteadOnServer() throws Exception {\n+  public void testRMAndTimeoutSetAndQueryTimeoutInsteadOnServer() {\n     // verify that timeout is set correctly and cancel query\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true,\n+    doCriticalMemoryHitTestOnServer(false, true,\n         TEST_QUERY_TIMEOUT, false);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSetOnServer() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSetOnServer() {\n     // verify that timeout is still working properly\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true,\n+    doCriticalMemoryHitTestOnServer(false, true,\n         TEST_QUERY_TIMEOUT, true);\n   }\n \n   @Test\n-  public void testPRGatherCancellation() throws Exception {\n-    doCriticalMemoryHitTestWithMultipleServers(\"portfolios\", true, 85/* crit threshold */, false,\n-        -1, true);\n-  }\n-\n-  @Test\n-  public void testPRGatherCancellationWhileGatheringResults() throws Exception {\n-    doCriticalMemoryHitDuringGatherTestWithMultipleServers(\"portfolios\", true,\n-        85/* crit threshold */, false, -1, true);\n-  }\n+  public void testPRGatherCancellation() throws Throwable {\n+    // create region on the server\n+    final VM server1 = VM.getVM(0);\n+    final VM server2 = VM.getVM(1);\n+    final VM client = VM.getVM(2);\n+    final int numObjects = 200;\n+    final VM controller = VM.getController();\n+    try {\n+      final int[] port = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n+      startCacheServer(server1, port[0], false,\n+          -1, true);\n+      startCacheServer(server2, port[1], true, -1, true);\n+\n+      startClient(client, port[0]);\n+      populateData(server2);\n+      server1.invoke(\"create latch test Hook\", () -> {\n+        DefaultQuery.testHook = getPauseHook(true, controller);\n+      });\n+      // remove from here to ....\n+      AsyncInvocation queryExecution1 = executeQueryOnClient(client);\n \n-  @Test\n-  public void testPRGatherCancellationWhileAddingResults() throws Exception {\n-    doCriticalMemoryHitAddResultsTestWithMultipleServers(\"portfolios\", true, 85/* crit threshold */,\n-        false, -1, true);\n-  }\n+      // Gives async invocation a chance to start\n+      Thread.sleep(1000);\n+      // We simulate a low memory/critical heap percentage hit\n+      setHeapToCriticalAndReleaseLatch(server1);\n+      assertThat(queryExecution1.get(60, SECONDS)).isEqualTo(0);\n+      verifyDroppedObjectsAndSetHeapToNormal(server1);\n \n-  @Test\n-  public void testIndexCreationCancellationPR() throws Exception {\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", true, 85/* crit threshold */, false, -1, true,\n-        \"compact\");\n-  }\n+      // to here....\n+      // Check to see if query execution is ok under \"normal\" or \"healthy\" conditions\n+      client.invoke(\"Executing query when system is 'Normal'\", () -> {\n+        try {\n+          Query query = getCache().getQueryService().newQuery(\"Select * From /\" + \"portfolios\");\n+          SelectResults results = (SelectResults) query.execute();\n+          assertThat(results.size()).isEqualTo(numObjects);\n+        } catch (QueryInvocationTargetException | FunctionDomainException | TypeMismatchException\n+            | NameResolutionException e) {\n+          fail(\"\");\n+        }\n+      });\n+      // We simulate a low memory/critical heap percentage hit\n+      setHeapToCriticalAndReleaseLatch(server1);\n+      AsyncInvocation queryExecution = executeQueryOnClient(client);\n+      assertThat(queryExecution.get(60, SECONDS)).isEqualTo(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40db9bd39c00a0468aa08ddc4541cd0d26d2f2b9"}, "originalPosition": 369}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA2MDQ3NA==", "bodyText": "Done.", "url": "https://github.com/apache/geode/pull/4691#discussion_r379060474", "createdAt": "2020-02-13T19:06:54Z", "author": {"login": "mhansonp"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "diffHunk": "@@ -134,606 +126,525 @@ public Object call() throws Exception {\n       irm.getHeapMonitor().setTestMaxMemoryBytes(0);\n       HeapMemoryMonitor.setTestDisableMemoryUpdates(false);\n       return null;\n-    }\n-  };\n-\n-  private SerializableCallable resetQueryMonitor = new SerializableCallable() {\n-    @Override\n-    public Object call() throws Exception {\n-      InternalCache cache = getCache();\n-      if (cache.getQueryMonitor() != null) {\n-        cache.getQueryMonitor().setLowMemory(false, 0);\n-      }\n-      DefaultQuery.testHook = null;\n-      return null;\n-    }\n-  };\n+    });\n+  }\n \n   @Test\n-  public void testRMAndNoTimeoutSet() throws Exception {\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSet() {\n+    doCriticalMemoryHitTest(false, false, -1, true);\n   }\n \n   @Test\n-  public void testRMAndNoTimeoutSetParReg() throws Exception {\n-    doCriticalMemoryHitTest(\"portfolios\", true, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSetParReg() {\n+    doCriticalMemoryHitTest(true, false, -1, true);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSet() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSet() {\n     // verify that timeout is not set and that a query can execute properly\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, -1, true);\n+    doCriticalMemoryHitTest(false, true, -1, true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSet() throws Exception {\n-    // verify that we still receive critical heap cancelation\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, TEST_QUERY_TIMEOUT,\n+  public void testRMAndTimeoutSet() {\n+    // verify that we still receive critical heap cancellation\n+    doCriticalMemoryHitTest(false, true, TEST_QUERY_TIMEOUT,\n         true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSetAndQueryTimesoutInstead() throws Exception {\n+  public void testRMAndTimeoutSetAndQueryTimeoutInstead() {\n     // verify that timeout is set correctly and cancel query\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, TEST_QUERY_TIMEOUT,\n+    doCriticalMemoryHitTest(false, true, TEST_QUERY_TIMEOUT,\n         false);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSet() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSet() {\n     // verify that timeout is still working properly\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, TEST_QUERY_TIMEOUT,\n+    doCriticalMemoryHitTest(false, true, TEST_QUERY_TIMEOUT,\n         true);\n   }\n \n   // Query directly on member with RM and QM set\n   @Test\n-  public void testRMAndNoTimeoutSetOnServer() throws Exception {\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSetOnServer() {\n+    doCriticalMemoryHitTestOnServer(false, false, -1, true);\n   }\n \n   // Query directly on member with RM and QM set\n   @Test\n-  public void whenTimeoutIsSetAndAQueryIsExecutedThenTimeoutMustStopTheQueryBeforeCriticalMemory()\n-      throws Exception {\n+  public void whenTimeoutIsSetAndAQueryIsExecutedThenTimeoutMustStopTheQueryBeforeCriticalMemory() {\n     // Timeout is set along with critical heap but it be called after the timeout expires\n     // Timeout is set to 1ms which is very unrealistic time period for a query to be able to fetch\n     // 200 entries from the region successfully, hence a timeout is expected.\n-    executeQueryWithTimeoutSetAndCriticalThreshold(\"portfolios\", false, 85/* crit threshold */,\n-        false, 1, true);\n+    // create region on the server\n+    final VM server = VM.getVM(0);\n+    try {\n+      final int port = AvailablePortHelper.getRandomAvailableTCPPort();\n+      startCacheServer(server, port, false, 1,\n+          false);\n+      populateData(server);\n+      executeQueryWithCriticalHeapCalledAfterTimeout(server, server);\n+      vmRecoversFromCriticalHeap(server);\n+\n+    } finally {\n+      stopServer(server);\n+    }\n   }\n \n   @Test\n-  public void whenTimeoutIsSetAndAQueryIsExecutedFromClientThenTimeoutMustStopTheQueryBeforeCriticalMemory()\n-      throws Exception {\n+  public void whenTimeoutIsSetAndAQueryIsExecutedFromClientThenTimeoutMustStopTheQueryBeforeCriticalMemory() {\n     // Timeout is set along with critical heap but it be called after the timeout expires\n     // Timeout is set to 1ms which is very unrealistic time period for a query to be able to fetch\n     // 200 entries from the region successfully, hence a timeout is expected.\n-    executeQueryFromClientWithTimeoutSetAndCriticalThreshold(\"portfolios\", false,\n-        85/* crit threshold */, false, 1, true);\n+    // create region on the server\n+    final VM server = VM.getVM(0);\n+    final VM client = VM.getVM(1);\n+    try {\n+      final int port = AvailablePortHelper.getRandomAvailableTCPPort();\n+      startCacheServer(server, port, false, 1,\n+          false);\n+      startClient(client, port);\n+      populateData(server);\n+      executeQueryWithCriticalHeapCalledAfterTimeout(server, client);\n+      vmRecoversFromCriticalHeap(server);\n+\n+    } finally {\n+      stopServer(server);\n+    }\n   }\n \n   @Test\n-  public void testRMAndNoTimeoutSetParRegOnServer() throws Exception {\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", true, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSetParRegOnServer() {\n+    doCriticalMemoryHitTestOnServer(true, false, -1, true);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSetOnServer() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSetOnServer() {\n     // verify that timeout is not set and that a query can execute properly\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true, -1, true);\n+    doCriticalMemoryHitTestOnServer(false, true, -1, true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSetOnServer() throws Exception {\n-    // verify that we still receive critical heap cancelation\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true,\n+  public void testRMAndTimeoutSetOnServer() {\n+    // verify that we still receive critical heap cancellation\n+    doCriticalMemoryHitTestOnServer(false, true,\n         TEST_QUERY_TIMEOUT, true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSetAndQueryTimesoutInsteadOnServer() throws Exception {\n+  public void testRMAndTimeoutSetAndQueryTimeoutInsteadOnServer() {\n     // verify that timeout is set correctly and cancel query\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true,\n+    doCriticalMemoryHitTestOnServer(false, true,\n         TEST_QUERY_TIMEOUT, false);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSetOnServer() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSetOnServer() {\n     // verify that timeout is still working properly\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true,\n+    doCriticalMemoryHitTestOnServer(false, true,\n         TEST_QUERY_TIMEOUT, true);\n   }\n \n   @Test\n-  public void testPRGatherCancellation() throws Exception {\n-    doCriticalMemoryHitTestWithMultipleServers(\"portfolios\", true, 85/* crit threshold */, false,\n-        -1, true);\n-  }\n-\n-  @Test\n-  public void testPRGatherCancellationWhileGatheringResults() throws Exception {\n-    doCriticalMemoryHitDuringGatherTestWithMultipleServers(\"portfolios\", true,\n-        85/* crit threshold */, false, -1, true);\n-  }\n+  public void testPRGatherCancellation() throws Throwable {\n+    // create region on the server\n+    final VM server1 = VM.getVM(0);\n+    final VM server2 = VM.getVM(1);\n+    final VM client = VM.getVM(2);\n+    final int numObjects = 200;\n+    final VM controller = VM.getController();\n+    try {\n+      final int[] port = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n+      startCacheServer(server1, port[0], false,\n+          -1, true);\n+      startCacheServer(server2, port[1], true, -1, true);\n+\n+      startClient(client, port[0]);\n+      populateData(server2);\n+      server1.invoke(\"create latch test Hook\", () -> {\n+        DefaultQuery.testHook = getPauseHook(true, controller);\n+      });\n+      // remove from here to ....\n+      AsyncInvocation queryExecution1 = executeQueryOnClient(client);\n \n-  @Test\n-  public void testPRGatherCancellationWhileAddingResults() throws Exception {\n-    doCriticalMemoryHitAddResultsTestWithMultipleServers(\"portfolios\", true, 85/* crit threshold */,\n-        false, -1, true);\n-  }\n+      // Gives async invocation a chance to start\n+      Thread.sleep(1000);\n+      // We simulate a low memory/critical heap percentage hit\n+      setHeapToCriticalAndReleaseLatch(server1);\n+      assertThat(queryExecution1.get(60, SECONDS)).isEqualTo(0);\n+      verifyDroppedObjectsAndSetHeapToNormal(server1);\n \n-  @Test\n-  public void testIndexCreationCancellationPR() throws Exception {\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", true, 85/* crit threshold */, false, -1, true,\n-        \"compact\");\n-  }\n+      // to here....\n+      // Check to see if query execution is ok under \"normal\" or \"healthy\" conditions\n+      client.invoke(\"Executing query when system is 'Normal'\", () -> {\n+        try {\n+          Query query = getCache().getQueryService().newQuery(\"Select * From /\" + \"portfolios\");\n+          SelectResults results = (SelectResults) query.execute();\n+          assertThat(results.size()).isEqualTo(numObjects);\n+        } catch (QueryInvocationTargetException | FunctionDomainException | TypeMismatchException\n+            | NameResolutionException e) {\n+          fail(\"\");\n+        }\n+      });\n+      // We simulate a low memory/critical heap percentage hit\n+      setHeapToCriticalAndReleaseLatch(server1);\n+      AsyncInvocation queryExecution = executeQueryOnClient(client);\n+      assertThat(queryExecution.get(60, SECONDS)).isEqualTo(0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzNTE3OA=="}, "originalCommit": {"oid": "40db9bd39c00a0468aa08ddc4541cd0d26d2f2b9"}, "originalPosition": 369}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MTk1NjA5OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMTo1NTo1MVrOFo_-qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxOTowNzozMlrOFpgCNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzNTU5NQ==", "bodyText": "Another useless catch-block that should probably be deleted.", "url": "https://github.com/apache/geode/pull/4691#discussion_r378535595", "createdAt": "2020-02-12T21:55:51Z", "author": {"login": "kirklund"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "diffHunk": "@@ -134,606 +126,525 @@ public Object call() throws Exception {\n       irm.getHeapMonitor().setTestMaxMemoryBytes(0);\n       HeapMemoryMonitor.setTestDisableMemoryUpdates(false);\n       return null;\n-    }\n-  };\n-\n-  private SerializableCallable resetQueryMonitor = new SerializableCallable() {\n-    @Override\n-    public Object call() throws Exception {\n-      InternalCache cache = getCache();\n-      if (cache.getQueryMonitor() != null) {\n-        cache.getQueryMonitor().setLowMemory(false, 0);\n-      }\n-      DefaultQuery.testHook = null;\n-      return null;\n-    }\n-  };\n+    });\n+  }\n \n   @Test\n-  public void testRMAndNoTimeoutSet() throws Exception {\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSet() {\n+    doCriticalMemoryHitTest(false, false, -1, true);\n   }\n \n   @Test\n-  public void testRMAndNoTimeoutSetParReg() throws Exception {\n-    doCriticalMemoryHitTest(\"portfolios\", true, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSetParReg() {\n+    doCriticalMemoryHitTest(true, false, -1, true);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSet() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSet() {\n     // verify that timeout is not set and that a query can execute properly\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, -1, true);\n+    doCriticalMemoryHitTest(false, true, -1, true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSet() throws Exception {\n-    // verify that we still receive critical heap cancelation\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, TEST_QUERY_TIMEOUT,\n+  public void testRMAndTimeoutSet() {\n+    // verify that we still receive critical heap cancellation\n+    doCriticalMemoryHitTest(false, true, TEST_QUERY_TIMEOUT,\n         true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSetAndQueryTimesoutInstead() throws Exception {\n+  public void testRMAndTimeoutSetAndQueryTimeoutInstead() {\n     // verify that timeout is set correctly and cancel query\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, TEST_QUERY_TIMEOUT,\n+    doCriticalMemoryHitTest(false, true, TEST_QUERY_TIMEOUT,\n         false);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSet() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSet() {\n     // verify that timeout is still working properly\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, TEST_QUERY_TIMEOUT,\n+    doCriticalMemoryHitTest(false, true, TEST_QUERY_TIMEOUT,\n         true);\n   }\n \n   // Query directly on member with RM and QM set\n   @Test\n-  public void testRMAndNoTimeoutSetOnServer() throws Exception {\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSetOnServer() {\n+    doCriticalMemoryHitTestOnServer(false, false, -1, true);\n   }\n \n   // Query directly on member with RM and QM set\n   @Test\n-  public void whenTimeoutIsSetAndAQueryIsExecutedThenTimeoutMustStopTheQueryBeforeCriticalMemory()\n-      throws Exception {\n+  public void whenTimeoutIsSetAndAQueryIsExecutedThenTimeoutMustStopTheQueryBeforeCriticalMemory() {\n     // Timeout is set along with critical heap but it be called after the timeout expires\n     // Timeout is set to 1ms which is very unrealistic time period for a query to be able to fetch\n     // 200 entries from the region successfully, hence a timeout is expected.\n-    executeQueryWithTimeoutSetAndCriticalThreshold(\"portfolios\", false, 85/* crit threshold */,\n-        false, 1, true);\n+    // create region on the server\n+    final VM server = VM.getVM(0);\n+    try {\n+      final int port = AvailablePortHelper.getRandomAvailableTCPPort();\n+      startCacheServer(server, port, false, 1,\n+          false);\n+      populateData(server);\n+      executeQueryWithCriticalHeapCalledAfterTimeout(server, server);\n+      vmRecoversFromCriticalHeap(server);\n+\n+    } finally {\n+      stopServer(server);\n+    }\n   }\n \n   @Test\n-  public void whenTimeoutIsSetAndAQueryIsExecutedFromClientThenTimeoutMustStopTheQueryBeforeCriticalMemory()\n-      throws Exception {\n+  public void whenTimeoutIsSetAndAQueryIsExecutedFromClientThenTimeoutMustStopTheQueryBeforeCriticalMemory() {\n     // Timeout is set along with critical heap but it be called after the timeout expires\n     // Timeout is set to 1ms which is very unrealistic time period for a query to be able to fetch\n     // 200 entries from the region successfully, hence a timeout is expected.\n-    executeQueryFromClientWithTimeoutSetAndCriticalThreshold(\"portfolios\", false,\n-        85/* crit threshold */, false, 1, true);\n+    // create region on the server\n+    final VM server = VM.getVM(0);\n+    final VM client = VM.getVM(1);\n+    try {\n+      final int port = AvailablePortHelper.getRandomAvailableTCPPort();\n+      startCacheServer(server, port, false, 1,\n+          false);\n+      startClient(client, port);\n+      populateData(server);\n+      executeQueryWithCriticalHeapCalledAfterTimeout(server, client);\n+      vmRecoversFromCriticalHeap(server);\n+\n+    } finally {\n+      stopServer(server);\n+    }\n   }\n \n   @Test\n-  public void testRMAndNoTimeoutSetParRegOnServer() throws Exception {\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", true, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSetParRegOnServer() {\n+    doCriticalMemoryHitTestOnServer(true, false, -1, true);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSetOnServer() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSetOnServer() {\n     // verify that timeout is not set and that a query can execute properly\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true, -1, true);\n+    doCriticalMemoryHitTestOnServer(false, true, -1, true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSetOnServer() throws Exception {\n-    // verify that we still receive critical heap cancelation\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true,\n+  public void testRMAndTimeoutSetOnServer() {\n+    // verify that we still receive critical heap cancellation\n+    doCriticalMemoryHitTestOnServer(false, true,\n         TEST_QUERY_TIMEOUT, true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSetAndQueryTimesoutInsteadOnServer() throws Exception {\n+  public void testRMAndTimeoutSetAndQueryTimeoutInsteadOnServer() {\n     // verify that timeout is set correctly and cancel query\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true,\n+    doCriticalMemoryHitTestOnServer(false, true,\n         TEST_QUERY_TIMEOUT, false);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSetOnServer() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSetOnServer() {\n     // verify that timeout is still working properly\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true,\n+    doCriticalMemoryHitTestOnServer(false, true,\n         TEST_QUERY_TIMEOUT, true);\n   }\n \n   @Test\n-  public void testPRGatherCancellation() throws Exception {\n-    doCriticalMemoryHitTestWithMultipleServers(\"portfolios\", true, 85/* crit threshold */, false,\n-        -1, true);\n-  }\n-\n-  @Test\n-  public void testPRGatherCancellationWhileGatheringResults() throws Exception {\n-    doCriticalMemoryHitDuringGatherTestWithMultipleServers(\"portfolios\", true,\n-        85/* crit threshold */, false, -1, true);\n-  }\n+  public void testPRGatherCancellation() throws Throwable {\n+    // create region on the server\n+    final VM server1 = VM.getVM(0);\n+    final VM server2 = VM.getVM(1);\n+    final VM client = VM.getVM(2);\n+    final int numObjects = 200;\n+    final VM controller = VM.getController();\n+    try {\n+      final int[] port = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n+      startCacheServer(server1, port[0], false,\n+          -1, true);\n+      startCacheServer(server2, port[1], true, -1, true);\n+\n+      startClient(client, port[0]);\n+      populateData(server2);\n+      server1.invoke(\"create latch test Hook\", () -> {\n+        DefaultQuery.testHook = getPauseHook(true, controller);\n+      });\n+      // remove from here to ....\n+      AsyncInvocation queryExecution1 = executeQueryOnClient(client);\n \n-  @Test\n-  public void testPRGatherCancellationWhileAddingResults() throws Exception {\n-    doCriticalMemoryHitAddResultsTestWithMultipleServers(\"portfolios\", true, 85/* crit threshold */,\n-        false, -1, true);\n-  }\n+      // Gives async invocation a chance to start\n+      Thread.sleep(1000);\n+      // We simulate a low memory/critical heap percentage hit\n+      setHeapToCriticalAndReleaseLatch(server1);\n+      assertThat(queryExecution1.get(60, SECONDS)).isEqualTo(0);\n+      verifyDroppedObjectsAndSetHeapToNormal(server1);\n \n-  @Test\n-  public void testIndexCreationCancellationPR() throws Exception {\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", true, 85/* crit threshold */, false, -1, true,\n-        \"compact\");\n-  }\n+      // to here....\n+      // Check to see if query execution is ok under \"normal\" or \"healthy\" conditions\n+      client.invoke(\"Executing query when system is 'Normal'\", () -> {\n+        try {\n+          Query query = getCache().getQueryService().newQuery(\"Select * From /\" + \"portfolios\");\n+          SelectResults results = (SelectResults) query.execute();\n+          assertThat(results.size()).isEqualTo(numObjects);\n+        } catch (QueryInvocationTargetException | FunctionDomainException | TypeMismatchException\n+            | NameResolutionException e) {\n+          fail(\"\");\n+        }\n+      });\n+      // We simulate a low memory/critical heap percentage hit\n+      setHeapToCriticalAndReleaseLatch(server1);\n+      AsyncInvocation queryExecution = executeQueryOnClient(client);\n+      assertThat(queryExecution.get(60, SECONDS)).isEqualTo(0);\n+      verifyDroppedObjectsAndSetHeapToNormal(server1);\n \n-  @Test\n-  public void testIndexCreationCancellation() throws Exception {\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", false, 85/* crit threshold */, false, -1, true,\n-        \"compact\");\n+    } finally {\n+      stopServer(server1);\n+      stopServer(server2);\n+    }\n   }\n \n-  @Test\n-  public void testIndexCreationNoCancellationPR() throws Exception {\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", true, 85/* crit threshold */, true, -1, true,\n-        \"compact\");\n+  private AsyncInvocation executeQueryOnClient(VM client) {\n+    return client.invokeAsync(\"execute query from client\", () -> {\n+      try {\n+        Query query1 = getCache().getQueryService().newQuery(\"Select * From /\" + \"portfolios\");\n+        query1.execute();\n+        throw new CacheException(\"Exception should have been thrown due to low memory\") {};\n+      } catch (Exception e2) {\n+        handleException(e2, true, false, -1);\n+      }\n+      return 0;\n+    });\n   }\n \n-  @Test\n-  public void testHashIndexCreationCancellationPR() throws Exception {\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", true, 85/* crit threshold */, false, -1, true,\n-        \"hash\");\n+  private void setHeapToCriticalAndReleaseLatch(VM server1) {\n+    server1.invoke(\"vm hits critical heap and counts down latch.\", () -> {\n+      InternalResourceManager resourceManager =\n+          (InternalResourceManager) getCache().getResourceManager();\n+      resourceManager.getHeapMonitor().updateStateAndSendEvent(CRITICAL_HEAP_USED, \"test\");\n+      await()\n+          .until(() -> resourceManager.getHeapMonitor().getState() == EVICTION_DISABLED_CRITICAL);\n+      Thread.sleep(MAX_TEST_QUERY_TIMEOUT);\n+      // release the hook to have the query throw either a low memory or query timeout\n+      // unless otherwise configured\n+      PauseTestHook hook = (PauseTestHook) DefaultQuery.testHook;\n+      hook.countDown();\n+    });\n   }\n \n-  @Test\n-  public void testHashIndexCreationCancellation() throws Exception {\n-    // need to add hook to canceled result set and very it is triggered for multiple servers\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", false, 85/* crit threshold */, false, -1, true,\n-        \"hash\");\n+  private void verifyDroppedObjectsAndSetHeapToNormal(VM server1) {\n+    server1.invoke(\"verify dropped objects\", () -> {\n+      if (DefaultQuery.testHook instanceof RejectedObjectsInterface) {\n+        RejectedObjectsInterface rejectedObjectsInterface =\n+            (RejectedObjectsInterface) DefaultQuery.testHook;\n+        await()\n+            .untilAsserted(() -> assertThat(rejectedObjectsInterface.rejectedObjects).isTrue());\n+      }\n+      InternalResourceManager resourceManager =\n+          (InternalResourceManager) getCache().getResourceManager();\n+      resourceManager.getHeapMonitor().updateStateAndSendEvent(NORMAL_HEAP_USED, \"test\");\n+      await().until(() -> resourceManager.getHeapMonitor().getState() == EVICTION_DISABLED);\n+    });\n   }\n \n   @Test\n-  public void testHashIndexCreationNoCancellationPR() throws Exception {\n-    // need to add hook to canceled result set and very it is triggered for multiple servers\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", true, 85/* crit threshold */, true, -1, true,\n-        \"hash\");\n-  }\n-\n-  private void doCriticalMemoryHitTest(final String regionName, boolean createPR,\n-      final int criticalThreshold,\n-      final boolean disabledQueryMonitorForLowMem,\n-      final int queryTimeout, final boolean hitCriticalThreshold)\n-      throws Exception {\n+  public void testPRGatherCancellationWhileGatheringResults() {\n     // create region on the server\n-    final VM server = VM.getVM(0);\n-    final VM client = VM.getVM(1);\n+    final VM server1 = VM.getVM(0);\n+    final VM server2 = VM.getVM(1);\n+    final VM client = VM.getVM(2);\n     final int numObjects = 200;\n     try {\n-      final int port = AvailablePortHelper.getRandomAvailableTCPPort();\n-      startCacheServer(server, port, criticalThreshold, disabledQueryMonitorForLowMem, queryTimeout,\n-          regionName, createPR, 0);\n+      final int[] port = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n+      startCacheServer(server1, port[0], false,\n+          -1, true);\n+      startCacheServer(server2, port[1], true, -1, true);\n \n-      startClient(client, server, port, regionName);\n-      populateData(server, regionName, numObjects);\n+      startClient(client, port[0]);\n+      populateData(server2);\n \n-      doTestCriticalHeapAndQueryTimeout(server, client, regionName, disabledQueryMonitorForLowMem,\n-          queryTimeout, hitCriticalThreshold);\n+      createCancelDuringGatherTestHook(server1, VM.getController());\n+      client.invoke(\"executing query to be canceled by gather\", () -> {\n+        QueryService qs;\n+        try {\n+          qs = getCache().getQueryService();\n+          Query query = qs.newQuery(\"Select * From /\" + \"portfolios\");\n+          query.execute();\n+        } catch (ServerOperationException soe) {\n+          if (soe.getRootCause() instanceof QueryException) {\n+            QueryException e = (QueryException) soe.getRootCause();\n+            if (!isExceptionDueToLowMemory(e)) {\n+              throw new CacheException(soe) {};\n+            } else {\n+              return 0;\n+            }\n+          }\n+        } catch (Exception e) {\n+          throw new CacheException(e) {};\n+        }\n+        // assertTrue(((CancelDuringGatherHook)DefaultQuery.testHook).triggeredOOME);\n+        throw new CacheException(\"should have hit low memory\") {};\n+      });\n \n-      // Pause for a second and then let's recover\n-      try {\n-        Thread.sleep(1000);\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n+      verifyRejectedObjects(server1);\n \n       // Recover from critical heap\n-      if (hitCriticalThreshold) {\n-        vmRecoversFromCriticalHeap(server);\n-      }\n+      vmRecoversFromCriticalHeap(server1);\n \n       // Check to see if query execution is ok under \"normal\" or \"healthy\" conditions\n-      client.invoke(new CacheSerializableRunnable(\"Executing query when system is 'Normal'\") {\n-        @Override\n-        public void run2() {\n-          try {\n-            QueryService qs = getCache().getQueryService();\n-            Query query = qs.newQuery(\"Select * From /\" + regionName);\n-            SelectResults results = (SelectResults) query.execute();\n-            assertEquals(numObjects, results.size());\n-          } catch (QueryInvocationTargetException e) {\n-            assertFalse(true);\n-          } catch (NameResolutionException e) {\n-            assertFalse(true);\n-          } catch (TypeMismatchException e) {\n-            assertFalse(true);\n-          } catch (FunctionDomainException e) {\n-            assertFalse(true);\n-          }\n+      client.invoke(\"Executing query when system is 'Normal'\", () -> {\n+        try {\n+          QueryService qs = getCache().getQueryService();\n+          Query query = qs.newQuery(\"Select * From /\" + \"portfolios\");\n+          SelectResults results = (SelectResults) query.execute();\n+          assertThat(results.size()).isEqualTo(numObjects);\n+        } catch (QueryInvocationTargetException | FunctionDomainException | TypeMismatchException", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40db9bd39c00a0468aa08ddc4541cd0d26d2f2b9"}, "originalPosition": 535}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA2MDc5MQ==", "bodyText": "Done.", "url": "https://github.com/apache/geode/pull/4691#discussion_r379060791", "createdAt": "2020-02-13T19:07:32Z", "author": {"login": "mhansonp"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "diffHunk": "@@ -134,606 +126,525 @@ public Object call() throws Exception {\n       irm.getHeapMonitor().setTestMaxMemoryBytes(0);\n       HeapMemoryMonitor.setTestDisableMemoryUpdates(false);\n       return null;\n-    }\n-  };\n-\n-  private SerializableCallable resetQueryMonitor = new SerializableCallable() {\n-    @Override\n-    public Object call() throws Exception {\n-      InternalCache cache = getCache();\n-      if (cache.getQueryMonitor() != null) {\n-        cache.getQueryMonitor().setLowMemory(false, 0);\n-      }\n-      DefaultQuery.testHook = null;\n-      return null;\n-    }\n-  };\n+    });\n+  }\n \n   @Test\n-  public void testRMAndNoTimeoutSet() throws Exception {\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSet() {\n+    doCriticalMemoryHitTest(false, false, -1, true);\n   }\n \n   @Test\n-  public void testRMAndNoTimeoutSetParReg() throws Exception {\n-    doCriticalMemoryHitTest(\"portfolios\", true, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSetParReg() {\n+    doCriticalMemoryHitTest(true, false, -1, true);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSet() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSet() {\n     // verify that timeout is not set and that a query can execute properly\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, -1, true);\n+    doCriticalMemoryHitTest(false, true, -1, true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSet() throws Exception {\n-    // verify that we still receive critical heap cancelation\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, TEST_QUERY_TIMEOUT,\n+  public void testRMAndTimeoutSet() {\n+    // verify that we still receive critical heap cancellation\n+    doCriticalMemoryHitTest(false, true, TEST_QUERY_TIMEOUT,\n         true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSetAndQueryTimesoutInstead() throws Exception {\n+  public void testRMAndTimeoutSetAndQueryTimeoutInstead() {\n     // verify that timeout is set correctly and cancel query\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, TEST_QUERY_TIMEOUT,\n+    doCriticalMemoryHitTest(false, true, TEST_QUERY_TIMEOUT,\n         false);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSet() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSet() {\n     // verify that timeout is still working properly\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, TEST_QUERY_TIMEOUT,\n+    doCriticalMemoryHitTest(false, true, TEST_QUERY_TIMEOUT,\n         true);\n   }\n \n   // Query directly on member with RM and QM set\n   @Test\n-  public void testRMAndNoTimeoutSetOnServer() throws Exception {\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSetOnServer() {\n+    doCriticalMemoryHitTestOnServer(false, false, -1, true);\n   }\n \n   // Query directly on member with RM and QM set\n   @Test\n-  public void whenTimeoutIsSetAndAQueryIsExecutedThenTimeoutMustStopTheQueryBeforeCriticalMemory()\n-      throws Exception {\n+  public void whenTimeoutIsSetAndAQueryIsExecutedThenTimeoutMustStopTheQueryBeforeCriticalMemory() {\n     // Timeout is set along with critical heap but it be called after the timeout expires\n     // Timeout is set to 1ms which is very unrealistic time period for a query to be able to fetch\n     // 200 entries from the region successfully, hence a timeout is expected.\n-    executeQueryWithTimeoutSetAndCriticalThreshold(\"portfolios\", false, 85/* crit threshold */,\n-        false, 1, true);\n+    // create region on the server\n+    final VM server = VM.getVM(0);\n+    try {\n+      final int port = AvailablePortHelper.getRandomAvailableTCPPort();\n+      startCacheServer(server, port, false, 1,\n+          false);\n+      populateData(server);\n+      executeQueryWithCriticalHeapCalledAfterTimeout(server, server);\n+      vmRecoversFromCriticalHeap(server);\n+\n+    } finally {\n+      stopServer(server);\n+    }\n   }\n \n   @Test\n-  public void whenTimeoutIsSetAndAQueryIsExecutedFromClientThenTimeoutMustStopTheQueryBeforeCriticalMemory()\n-      throws Exception {\n+  public void whenTimeoutIsSetAndAQueryIsExecutedFromClientThenTimeoutMustStopTheQueryBeforeCriticalMemory() {\n     // Timeout is set along with critical heap but it be called after the timeout expires\n     // Timeout is set to 1ms which is very unrealistic time period for a query to be able to fetch\n     // 200 entries from the region successfully, hence a timeout is expected.\n-    executeQueryFromClientWithTimeoutSetAndCriticalThreshold(\"portfolios\", false,\n-        85/* crit threshold */, false, 1, true);\n+    // create region on the server\n+    final VM server = VM.getVM(0);\n+    final VM client = VM.getVM(1);\n+    try {\n+      final int port = AvailablePortHelper.getRandomAvailableTCPPort();\n+      startCacheServer(server, port, false, 1,\n+          false);\n+      startClient(client, port);\n+      populateData(server);\n+      executeQueryWithCriticalHeapCalledAfterTimeout(server, client);\n+      vmRecoversFromCriticalHeap(server);\n+\n+    } finally {\n+      stopServer(server);\n+    }\n   }\n \n   @Test\n-  public void testRMAndNoTimeoutSetParRegOnServer() throws Exception {\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", true, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSetParRegOnServer() {\n+    doCriticalMemoryHitTestOnServer(true, false, -1, true);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSetOnServer() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSetOnServer() {\n     // verify that timeout is not set and that a query can execute properly\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true, -1, true);\n+    doCriticalMemoryHitTestOnServer(false, true, -1, true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSetOnServer() throws Exception {\n-    // verify that we still receive critical heap cancelation\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true,\n+  public void testRMAndTimeoutSetOnServer() {\n+    // verify that we still receive critical heap cancellation\n+    doCriticalMemoryHitTestOnServer(false, true,\n         TEST_QUERY_TIMEOUT, true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSetAndQueryTimesoutInsteadOnServer() throws Exception {\n+  public void testRMAndTimeoutSetAndQueryTimeoutInsteadOnServer() {\n     // verify that timeout is set correctly and cancel query\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true,\n+    doCriticalMemoryHitTestOnServer(false, true,\n         TEST_QUERY_TIMEOUT, false);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSetOnServer() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSetOnServer() {\n     // verify that timeout is still working properly\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true,\n+    doCriticalMemoryHitTestOnServer(false, true,\n         TEST_QUERY_TIMEOUT, true);\n   }\n \n   @Test\n-  public void testPRGatherCancellation() throws Exception {\n-    doCriticalMemoryHitTestWithMultipleServers(\"portfolios\", true, 85/* crit threshold */, false,\n-        -1, true);\n-  }\n-\n-  @Test\n-  public void testPRGatherCancellationWhileGatheringResults() throws Exception {\n-    doCriticalMemoryHitDuringGatherTestWithMultipleServers(\"portfolios\", true,\n-        85/* crit threshold */, false, -1, true);\n-  }\n+  public void testPRGatherCancellation() throws Throwable {\n+    // create region on the server\n+    final VM server1 = VM.getVM(0);\n+    final VM server2 = VM.getVM(1);\n+    final VM client = VM.getVM(2);\n+    final int numObjects = 200;\n+    final VM controller = VM.getController();\n+    try {\n+      final int[] port = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n+      startCacheServer(server1, port[0], false,\n+          -1, true);\n+      startCacheServer(server2, port[1], true, -1, true);\n+\n+      startClient(client, port[0]);\n+      populateData(server2);\n+      server1.invoke(\"create latch test Hook\", () -> {\n+        DefaultQuery.testHook = getPauseHook(true, controller);\n+      });\n+      // remove from here to ....\n+      AsyncInvocation queryExecution1 = executeQueryOnClient(client);\n \n-  @Test\n-  public void testPRGatherCancellationWhileAddingResults() throws Exception {\n-    doCriticalMemoryHitAddResultsTestWithMultipleServers(\"portfolios\", true, 85/* crit threshold */,\n-        false, -1, true);\n-  }\n+      // Gives async invocation a chance to start\n+      Thread.sleep(1000);\n+      // We simulate a low memory/critical heap percentage hit\n+      setHeapToCriticalAndReleaseLatch(server1);\n+      assertThat(queryExecution1.get(60, SECONDS)).isEqualTo(0);\n+      verifyDroppedObjectsAndSetHeapToNormal(server1);\n \n-  @Test\n-  public void testIndexCreationCancellationPR() throws Exception {\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", true, 85/* crit threshold */, false, -1, true,\n-        \"compact\");\n-  }\n+      // to here....\n+      // Check to see if query execution is ok under \"normal\" or \"healthy\" conditions\n+      client.invoke(\"Executing query when system is 'Normal'\", () -> {\n+        try {\n+          Query query = getCache().getQueryService().newQuery(\"Select * From /\" + \"portfolios\");\n+          SelectResults results = (SelectResults) query.execute();\n+          assertThat(results.size()).isEqualTo(numObjects);\n+        } catch (QueryInvocationTargetException | FunctionDomainException | TypeMismatchException\n+            | NameResolutionException e) {\n+          fail(\"\");\n+        }\n+      });\n+      // We simulate a low memory/critical heap percentage hit\n+      setHeapToCriticalAndReleaseLatch(server1);\n+      AsyncInvocation queryExecution = executeQueryOnClient(client);\n+      assertThat(queryExecution.get(60, SECONDS)).isEqualTo(0);\n+      verifyDroppedObjectsAndSetHeapToNormal(server1);\n \n-  @Test\n-  public void testIndexCreationCancellation() throws Exception {\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", false, 85/* crit threshold */, false, -1, true,\n-        \"compact\");\n+    } finally {\n+      stopServer(server1);\n+      stopServer(server2);\n+    }\n   }\n \n-  @Test\n-  public void testIndexCreationNoCancellationPR() throws Exception {\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", true, 85/* crit threshold */, true, -1, true,\n-        \"compact\");\n+  private AsyncInvocation executeQueryOnClient(VM client) {\n+    return client.invokeAsync(\"execute query from client\", () -> {\n+      try {\n+        Query query1 = getCache().getQueryService().newQuery(\"Select * From /\" + \"portfolios\");\n+        query1.execute();\n+        throw new CacheException(\"Exception should have been thrown due to low memory\") {};\n+      } catch (Exception e2) {\n+        handleException(e2, true, false, -1);\n+      }\n+      return 0;\n+    });\n   }\n \n-  @Test\n-  public void testHashIndexCreationCancellationPR() throws Exception {\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", true, 85/* crit threshold */, false, -1, true,\n-        \"hash\");\n+  private void setHeapToCriticalAndReleaseLatch(VM server1) {\n+    server1.invoke(\"vm hits critical heap and counts down latch.\", () -> {\n+      InternalResourceManager resourceManager =\n+          (InternalResourceManager) getCache().getResourceManager();\n+      resourceManager.getHeapMonitor().updateStateAndSendEvent(CRITICAL_HEAP_USED, \"test\");\n+      await()\n+          .until(() -> resourceManager.getHeapMonitor().getState() == EVICTION_DISABLED_CRITICAL);\n+      Thread.sleep(MAX_TEST_QUERY_TIMEOUT);\n+      // release the hook to have the query throw either a low memory or query timeout\n+      // unless otherwise configured\n+      PauseTestHook hook = (PauseTestHook) DefaultQuery.testHook;\n+      hook.countDown();\n+    });\n   }\n \n-  @Test\n-  public void testHashIndexCreationCancellation() throws Exception {\n-    // need to add hook to canceled result set and very it is triggered for multiple servers\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", false, 85/* crit threshold */, false, -1, true,\n-        \"hash\");\n+  private void verifyDroppedObjectsAndSetHeapToNormal(VM server1) {\n+    server1.invoke(\"verify dropped objects\", () -> {\n+      if (DefaultQuery.testHook instanceof RejectedObjectsInterface) {\n+        RejectedObjectsInterface rejectedObjectsInterface =\n+            (RejectedObjectsInterface) DefaultQuery.testHook;\n+        await()\n+            .untilAsserted(() -> assertThat(rejectedObjectsInterface.rejectedObjects).isTrue());\n+      }\n+      InternalResourceManager resourceManager =\n+          (InternalResourceManager) getCache().getResourceManager();\n+      resourceManager.getHeapMonitor().updateStateAndSendEvent(NORMAL_HEAP_USED, \"test\");\n+      await().until(() -> resourceManager.getHeapMonitor().getState() == EVICTION_DISABLED);\n+    });\n   }\n \n   @Test\n-  public void testHashIndexCreationNoCancellationPR() throws Exception {\n-    // need to add hook to canceled result set and very it is triggered for multiple servers\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", true, 85/* crit threshold */, true, -1, true,\n-        \"hash\");\n-  }\n-\n-  private void doCriticalMemoryHitTest(final String regionName, boolean createPR,\n-      final int criticalThreshold,\n-      final boolean disabledQueryMonitorForLowMem,\n-      final int queryTimeout, final boolean hitCriticalThreshold)\n-      throws Exception {\n+  public void testPRGatherCancellationWhileGatheringResults() {\n     // create region on the server\n-    final VM server = VM.getVM(0);\n-    final VM client = VM.getVM(1);\n+    final VM server1 = VM.getVM(0);\n+    final VM server2 = VM.getVM(1);\n+    final VM client = VM.getVM(2);\n     final int numObjects = 200;\n     try {\n-      final int port = AvailablePortHelper.getRandomAvailableTCPPort();\n-      startCacheServer(server, port, criticalThreshold, disabledQueryMonitorForLowMem, queryTimeout,\n-          regionName, createPR, 0);\n+      final int[] port = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n+      startCacheServer(server1, port[0], false,\n+          -1, true);\n+      startCacheServer(server2, port[1], true, -1, true);\n \n-      startClient(client, server, port, regionName);\n-      populateData(server, regionName, numObjects);\n+      startClient(client, port[0]);\n+      populateData(server2);\n \n-      doTestCriticalHeapAndQueryTimeout(server, client, regionName, disabledQueryMonitorForLowMem,\n-          queryTimeout, hitCriticalThreshold);\n+      createCancelDuringGatherTestHook(server1, VM.getController());\n+      client.invoke(\"executing query to be canceled by gather\", () -> {\n+        QueryService qs;\n+        try {\n+          qs = getCache().getQueryService();\n+          Query query = qs.newQuery(\"Select * From /\" + \"portfolios\");\n+          query.execute();\n+        } catch (ServerOperationException soe) {\n+          if (soe.getRootCause() instanceof QueryException) {\n+            QueryException e = (QueryException) soe.getRootCause();\n+            if (!isExceptionDueToLowMemory(e)) {\n+              throw new CacheException(soe) {};\n+            } else {\n+              return 0;\n+            }\n+          }\n+        } catch (Exception e) {\n+          throw new CacheException(e) {};\n+        }\n+        // assertTrue(((CancelDuringGatherHook)DefaultQuery.testHook).triggeredOOME);\n+        throw new CacheException(\"should have hit low memory\") {};\n+      });\n \n-      // Pause for a second and then let's recover\n-      try {\n-        Thread.sleep(1000);\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n+      verifyRejectedObjects(server1);\n \n       // Recover from critical heap\n-      if (hitCriticalThreshold) {\n-        vmRecoversFromCriticalHeap(server);\n-      }\n+      vmRecoversFromCriticalHeap(server1);\n \n       // Check to see if query execution is ok under \"normal\" or \"healthy\" conditions\n-      client.invoke(new CacheSerializableRunnable(\"Executing query when system is 'Normal'\") {\n-        @Override\n-        public void run2() {\n-          try {\n-            QueryService qs = getCache().getQueryService();\n-            Query query = qs.newQuery(\"Select * From /\" + regionName);\n-            SelectResults results = (SelectResults) query.execute();\n-            assertEquals(numObjects, results.size());\n-          } catch (QueryInvocationTargetException e) {\n-            assertFalse(true);\n-          } catch (NameResolutionException e) {\n-            assertFalse(true);\n-          } catch (TypeMismatchException e) {\n-            assertFalse(true);\n-          } catch (FunctionDomainException e) {\n-            assertFalse(true);\n-          }\n+      client.invoke(\"Executing query when system is 'Normal'\", () -> {\n+        try {\n+          QueryService qs = getCache().getQueryService();\n+          Query query = qs.newQuery(\"Select * From /\" + \"portfolios\");\n+          SelectResults results = (SelectResults) query.execute();\n+          assertThat(results.size()).isEqualTo(numObjects);\n+        } catch (QueryInvocationTargetException | FunctionDomainException | TypeMismatchException", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzNTU5NQ=="}, "originalCommit": {"oid": "40db9bd39c00a0468aa08ddc4541cd0d26d2f2b9"}, "originalPosition": 535}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MTk1NzE3OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMTo1NjoxMlrOFo__VQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxOToyMDoxOFrOFpgbBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzNTc2NQ==", "bodyText": "Another catch-block to delete.", "url": "https://github.com/apache/geode/pull/4691#discussion_r378535765", "createdAt": "2020-02-12T21:56:12Z", "author": {"login": "kirklund"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "diffHunk": "@@ -134,606 +126,525 @@ public Object call() throws Exception {\n       irm.getHeapMonitor().setTestMaxMemoryBytes(0);\n       HeapMemoryMonitor.setTestDisableMemoryUpdates(false);\n       return null;\n-    }\n-  };\n-\n-  private SerializableCallable resetQueryMonitor = new SerializableCallable() {\n-    @Override\n-    public Object call() throws Exception {\n-      InternalCache cache = getCache();\n-      if (cache.getQueryMonitor() != null) {\n-        cache.getQueryMonitor().setLowMemory(false, 0);\n-      }\n-      DefaultQuery.testHook = null;\n-      return null;\n-    }\n-  };\n+    });\n+  }\n \n   @Test\n-  public void testRMAndNoTimeoutSet() throws Exception {\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSet() {\n+    doCriticalMemoryHitTest(false, false, -1, true);\n   }\n \n   @Test\n-  public void testRMAndNoTimeoutSetParReg() throws Exception {\n-    doCriticalMemoryHitTest(\"portfolios\", true, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSetParReg() {\n+    doCriticalMemoryHitTest(true, false, -1, true);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSet() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSet() {\n     // verify that timeout is not set and that a query can execute properly\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, -1, true);\n+    doCriticalMemoryHitTest(false, true, -1, true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSet() throws Exception {\n-    // verify that we still receive critical heap cancelation\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, TEST_QUERY_TIMEOUT,\n+  public void testRMAndTimeoutSet() {\n+    // verify that we still receive critical heap cancellation\n+    doCriticalMemoryHitTest(false, true, TEST_QUERY_TIMEOUT,\n         true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSetAndQueryTimesoutInstead() throws Exception {\n+  public void testRMAndTimeoutSetAndQueryTimeoutInstead() {\n     // verify that timeout is set correctly and cancel query\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, TEST_QUERY_TIMEOUT,\n+    doCriticalMemoryHitTest(false, true, TEST_QUERY_TIMEOUT,\n         false);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSet() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSet() {\n     // verify that timeout is still working properly\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, TEST_QUERY_TIMEOUT,\n+    doCriticalMemoryHitTest(false, true, TEST_QUERY_TIMEOUT,\n         true);\n   }\n \n   // Query directly on member with RM and QM set\n   @Test\n-  public void testRMAndNoTimeoutSetOnServer() throws Exception {\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSetOnServer() {\n+    doCriticalMemoryHitTestOnServer(false, false, -1, true);\n   }\n \n   // Query directly on member with RM and QM set\n   @Test\n-  public void whenTimeoutIsSetAndAQueryIsExecutedThenTimeoutMustStopTheQueryBeforeCriticalMemory()\n-      throws Exception {\n+  public void whenTimeoutIsSetAndAQueryIsExecutedThenTimeoutMustStopTheQueryBeforeCriticalMemory() {\n     // Timeout is set along with critical heap but it be called after the timeout expires\n     // Timeout is set to 1ms which is very unrealistic time period for a query to be able to fetch\n     // 200 entries from the region successfully, hence a timeout is expected.\n-    executeQueryWithTimeoutSetAndCriticalThreshold(\"portfolios\", false, 85/* crit threshold */,\n-        false, 1, true);\n+    // create region on the server\n+    final VM server = VM.getVM(0);\n+    try {\n+      final int port = AvailablePortHelper.getRandomAvailableTCPPort();\n+      startCacheServer(server, port, false, 1,\n+          false);\n+      populateData(server);\n+      executeQueryWithCriticalHeapCalledAfterTimeout(server, server);\n+      vmRecoversFromCriticalHeap(server);\n+\n+    } finally {\n+      stopServer(server);\n+    }\n   }\n \n   @Test\n-  public void whenTimeoutIsSetAndAQueryIsExecutedFromClientThenTimeoutMustStopTheQueryBeforeCriticalMemory()\n-      throws Exception {\n+  public void whenTimeoutIsSetAndAQueryIsExecutedFromClientThenTimeoutMustStopTheQueryBeforeCriticalMemory() {\n     // Timeout is set along with critical heap but it be called after the timeout expires\n     // Timeout is set to 1ms which is very unrealistic time period for a query to be able to fetch\n     // 200 entries from the region successfully, hence a timeout is expected.\n-    executeQueryFromClientWithTimeoutSetAndCriticalThreshold(\"portfolios\", false,\n-        85/* crit threshold */, false, 1, true);\n+    // create region on the server\n+    final VM server = VM.getVM(0);\n+    final VM client = VM.getVM(1);\n+    try {\n+      final int port = AvailablePortHelper.getRandomAvailableTCPPort();\n+      startCacheServer(server, port, false, 1,\n+          false);\n+      startClient(client, port);\n+      populateData(server);\n+      executeQueryWithCriticalHeapCalledAfterTimeout(server, client);\n+      vmRecoversFromCriticalHeap(server);\n+\n+    } finally {\n+      stopServer(server);\n+    }\n   }\n \n   @Test\n-  public void testRMAndNoTimeoutSetParRegOnServer() throws Exception {\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", true, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSetParRegOnServer() {\n+    doCriticalMemoryHitTestOnServer(true, false, -1, true);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSetOnServer() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSetOnServer() {\n     // verify that timeout is not set and that a query can execute properly\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true, -1, true);\n+    doCriticalMemoryHitTestOnServer(false, true, -1, true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSetOnServer() throws Exception {\n-    // verify that we still receive critical heap cancelation\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true,\n+  public void testRMAndTimeoutSetOnServer() {\n+    // verify that we still receive critical heap cancellation\n+    doCriticalMemoryHitTestOnServer(false, true,\n         TEST_QUERY_TIMEOUT, true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSetAndQueryTimesoutInsteadOnServer() throws Exception {\n+  public void testRMAndTimeoutSetAndQueryTimeoutInsteadOnServer() {\n     // verify that timeout is set correctly and cancel query\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true,\n+    doCriticalMemoryHitTestOnServer(false, true,\n         TEST_QUERY_TIMEOUT, false);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSetOnServer() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSetOnServer() {\n     // verify that timeout is still working properly\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true,\n+    doCriticalMemoryHitTestOnServer(false, true,\n         TEST_QUERY_TIMEOUT, true);\n   }\n \n   @Test\n-  public void testPRGatherCancellation() throws Exception {\n-    doCriticalMemoryHitTestWithMultipleServers(\"portfolios\", true, 85/* crit threshold */, false,\n-        -1, true);\n-  }\n-\n-  @Test\n-  public void testPRGatherCancellationWhileGatheringResults() throws Exception {\n-    doCriticalMemoryHitDuringGatherTestWithMultipleServers(\"portfolios\", true,\n-        85/* crit threshold */, false, -1, true);\n-  }\n+  public void testPRGatherCancellation() throws Throwable {\n+    // create region on the server\n+    final VM server1 = VM.getVM(0);\n+    final VM server2 = VM.getVM(1);\n+    final VM client = VM.getVM(2);\n+    final int numObjects = 200;\n+    final VM controller = VM.getController();\n+    try {\n+      final int[] port = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n+      startCacheServer(server1, port[0], false,\n+          -1, true);\n+      startCacheServer(server2, port[1], true, -1, true);\n+\n+      startClient(client, port[0]);\n+      populateData(server2);\n+      server1.invoke(\"create latch test Hook\", () -> {\n+        DefaultQuery.testHook = getPauseHook(true, controller);\n+      });\n+      // remove from here to ....\n+      AsyncInvocation queryExecution1 = executeQueryOnClient(client);\n \n-  @Test\n-  public void testPRGatherCancellationWhileAddingResults() throws Exception {\n-    doCriticalMemoryHitAddResultsTestWithMultipleServers(\"portfolios\", true, 85/* crit threshold */,\n-        false, -1, true);\n-  }\n+      // Gives async invocation a chance to start\n+      Thread.sleep(1000);\n+      // We simulate a low memory/critical heap percentage hit\n+      setHeapToCriticalAndReleaseLatch(server1);\n+      assertThat(queryExecution1.get(60, SECONDS)).isEqualTo(0);\n+      verifyDroppedObjectsAndSetHeapToNormal(server1);\n \n-  @Test\n-  public void testIndexCreationCancellationPR() throws Exception {\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", true, 85/* crit threshold */, false, -1, true,\n-        \"compact\");\n-  }\n+      // to here....\n+      // Check to see if query execution is ok under \"normal\" or \"healthy\" conditions\n+      client.invoke(\"Executing query when system is 'Normal'\", () -> {\n+        try {\n+          Query query = getCache().getQueryService().newQuery(\"Select * From /\" + \"portfolios\");\n+          SelectResults results = (SelectResults) query.execute();\n+          assertThat(results.size()).isEqualTo(numObjects);\n+        } catch (QueryInvocationTargetException | FunctionDomainException | TypeMismatchException\n+            | NameResolutionException e) {\n+          fail(\"\");\n+        }\n+      });\n+      // We simulate a low memory/critical heap percentage hit\n+      setHeapToCriticalAndReleaseLatch(server1);\n+      AsyncInvocation queryExecution = executeQueryOnClient(client);\n+      assertThat(queryExecution.get(60, SECONDS)).isEqualTo(0);\n+      verifyDroppedObjectsAndSetHeapToNormal(server1);\n \n-  @Test\n-  public void testIndexCreationCancellation() throws Exception {\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", false, 85/* crit threshold */, false, -1, true,\n-        \"compact\");\n+    } finally {\n+      stopServer(server1);\n+      stopServer(server2);\n+    }\n   }\n \n-  @Test\n-  public void testIndexCreationNoCancellationPR() throws Exception {\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", true, 85/* crit threshold */, true, -1, true,\n-        \"compact\");\n+  private AsyncInvocation executeQueryOnClient(VM client) {\n+    return client.invokeAsync(\"execute query from client\", () -> {\n+      try {\n+        Query query1 = getCache().getQueryService().newQuery(\"Select * From /\" + \"portfolios\");\n+        query1.execute();\n+        throw new CacheException(\"Exception should have been thrown due to low memory\") {};\n+      } catch (Exception e2) {\n+        handleException(e2, true, false, -1);\n+      }\n+      return 0;\n+    });\n   }\n \n-  @Test\n-  public void testHashIndexCreationCancellationPR() throws Exception {\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", true, 85/* crit threshold */, false, -1, true,\n-        \"hash\");\n+  private void setHeapToCriticalAndReleaseLatch(VM server1) {\n+    server1.invoke(\"vm hits critical heap and counts down latch.\", () -> {\n+      InternalResourceManager resourceManager =\n+          (InternalResourceManager) getCache().getResourceManager();\n+      resourceManager.getHeapMonitor().updateStateAndSendEvent(CRITICAL_HEAP_USED, \"test\");\n+      await()\n+          .until(() -> resourceManager.getHeapMonitor().getState() == EVICTION_DISABLED_CRITICAL);\n+      Thread.sleep(MAX_TEST_QUERY_TIMEOUT);\n+      // release the hook to have the query throw either a low memory or query timeout\n+      // unless otherwise configured\n+      PauseTestHook hook = (PauseTestHook) DefaultQuery.testHook;\n+      hook.countDown();\n+    });\n   }\n \n-  @Test\n-  public void testHashIndexCreationCancellation() throws Exception {\n-    // need to add hook to canceled result set and very it is triggered for multiple servers\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", false, 85/* crit threshold */, false, -1, true,\n-        \"hash\");\n+  private void verifyDroppedObjectsAndSetHeapToNormal(VM server1) {\n+    server1.invoke(\"verify dropped objects\", () -> {\n+      if (DefaultQuery.testHook instanceof RejectedObjectsInterface) {\n+        RejectedObjectsInterface rejectedObjectsInterface =\n+            (RejectedObjectsInterface) DefaultQuery.testHook;\n+        await()\n+            .untilAsserted(() -> assertThat(rejectedObjectsInterface.rejectedObjects).isTrue());\n+      }\n+      InternalResourceManager resourceManager =\n+          (InternalResourceManager) getCache().getResourceManager();\n+      resourceManager.getHeapMonitor().updateStateAndSendEvent(NORMAL_HEAP_USED, \"test\");\n+      await().until(() -> resourceManager.getHeapMonitor().getState() == EVICTION_DISABLED);\n+    });\n   }\n \n   @Test\n-  public void testHashIndexCreationNoCancellationPR() throws Exception {\n-    // need to add hook to canceled result set and very it is triggered for multiple servers\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", true, 85/* crit threshold */, true, -1, true,\n-        \"hash\");\n-  }\n-\n-  private void doCriticalMemoryHitTest(final String regionName, boolean createPR,\n-      final int criticalThreshold,\n-      final boolean disabledQueryMonitorForLowMem,\n-      final int queryTimeout, final boolean hitCriticalThreshold)\n-      throws Exception {\n+  public void testPRGatherCancellationWhileGatheringResults() {\n     // create region on the server\n-    final VM server = VM.getVM(0);\n-    final VM client = VM.getVM(1);\n+    final VM server1 = VM.getVM(0);\n+    final VM server2 = VM.getVM(1);\n+    final VM client = VM.getVM(2);\n     final int numObjects = 200;\n     try {\n-      final int port = AvailablePortHelper.getRandomAvailableTCPPort();\n-      startCacheServer(server, port, criticalThreshold, disabledQueryMonitorForLowMem, queryTimeout,\n-          regionName, createPR, 0);\n+      final int[] port = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n+      startCacheServer(server1, port[0], false,\n+          -1, true);\n+      startCacheServer(server2, port[1], true, -1, true);\n \n-      startClient(client, server, port, regionName);\n-      populateData(server, regionName, numObjects);\n+      startClient(client, port[0]);\n+      populateData(server2);\n \n-      doTestCriticalHeapAndQueryTimeout(server, client, regionName, disabledQueryMonitorForLowMem,\n-          queryTimeout, hitCriticalThreshold);\n+      createCancelDuringGatherTestHook(server1, VM.getController());\n+      client.invoke(\"executing query to be canceled by gather\", () -> {\n+        QueryService qs;\n+        try {\n+          qs = getCache().getQueryService();\n+          Query query = qs.newQuery(\"Select * From /\" + \"portfolios\");\n+          query.execute();\n+        } catch (ServerOperationException soe) {\n+          if (soe.getRootCause() instanceof QueryException) {\n+            QueryException e = (QueryException) soe.getRootCause();\n+            if (!isExceptionDueToLowMemory(e)) {\n+              throw new CacheException(soe) {};\n+            } else {\n+              return 0;\n+            }\n+          }\n+        } catch (Exception e) {\n+          throw new CacheException(e) {};\n+        }\n+        // assertTrue(((CancelDuringGatherHook)DefaultQuery.testHook).triggeredOOME);\n+        throw new CacheException(\"should have hit low memory\") {};\n+      });\n \n-      // Pause for a second and then let's recover\n-      try {\n-        Thread.sleep(1000);\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n+      verifyRejectedObjects(server1);\n \n       // Recover from critical heap\n-      if (hitCriticalThreshold) {\n-        vmRecoversFromCriticalHeap(server);\n-      }\n+      vmRecoversFromCriticalHeap(server1);\n \n       // Check to see if query execution is ok under \"normal\" or \"healthy\" conditions\n-      client.invoke(new CacheSerializableRunnable(\"Executing query when system is 'Normal'\") {\n-        @Override\n-        public void run2() {\n-          try {\n-            QueryService qs = getCache().getQueryService();\n-            Query query = qs.newQuery(\"Select * From /\" + regionName);\n-            SelectResults results = (SelectResults) query.execute();\n-            assertEquals(numObjects, results.size());\n-          } catch (QueryInvocationTargetException e) {\n-            assertFalse(true);\n-          } catch (NameResolutionException e) {\n-            assertFalse(true);\n-          } catch (TypeMismatchException e) {\n-            assertFalse(true);\n-          } catch (FunctionDomainException e) {\n-            assertFalse(true);\n-          }\n+      client.invoke(\"Executing query when system is 'Normal'\", () -> {\n+        try {\n+          QueryService qs = getCache().getQueryService();\n+          Query query = qs.newQuery(\"Select * From /\" + \"portfolios\");\n+          SelectResults results = (SelectResults) query.execute();\n+          assertThat(results.size()).isEqualTo(numObjects);\n+        } catch (QueryInvocationTargetException | FunctionDomainException | TypeMismatchException\n+            | NameResolutionException e) {\n+          fail(\"\");\n         }\n       });\n \n-      // Execute a critical heap event/ query timeout test again\n-      doTestCriticalHeapAndQueryTimeout(server, client, regionName, disabledQueryMonitorForLowMem,\n-          queryTimeout, hitCriticalThreshold);\n       // Recover from critical heap\n-      if (hitCriticalThreshold) {\n-        vmRecoversFromCriticalHeap(server);\n-      }\n-    } finally {\n-      stopServer(server);\n-    }\n-  }\n-\n-  // test to verify what happens during index creation if memory threshold is hit\n-  private void doCriticalMemoryHitWithIndexTest(final String regionName, boolean createPR,\n-      final int criticalThreshold,\n-      final boolean disabledQueryMonitorForLowMem,\n-      final int queryTimeout,\n-      final boolean hitCriticalThreshold,\n-      final String indexType)\n-      throws Exception {\n-    // create region on the server\n-    final VM server1 = VM.getVM(0);\n-    final VM server2 = VM.getVM(2);\n-    final VM client = VM.getVM(1);\n-    final int numObjects = 200;\n-    try {\n-      final int[] port = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n-      startCacheServer(server1, port[0], criticalThreshold, disabledQueryMonitorForLowMem,\n-          queryTimeout, regionName, createPR, 0);\n-      startCacheServer(server2, port[1], criticalThreshold, true, -1, regionName, createPR, 0);\n-\n-      startClient(client, server1, port[0], regionName);\n-      populateData(server1, regionName, numObjects);\n-\n-      createCancelDuringGatherTestHook(server1);\n-      server1.invoke(new SerializableCallable(\"create index\") {\n-        @Override\n-        public Object call() {\n-          QueryService qs = null;\n-          try {\n-            qs = getCache().getQueryService();\n-            Index index = null;\n-            if (indexType.equals(\"compact\")) {\n-              index = qs.createIndex(\"newIndex\", \"ID\", \"/\" + regionName);\n-            } else if (indexType.equals(\"hash\")) {\n-              index = qs.createHashIndex(\"newIndex\", \"ID\", \"/\" + regionName);\n-            }\n-            assertNotNull(index);\n-            assertTrue(((CancelDuringGatherHook) DefaultQuery.testHook).triggeredOOME);\n-\n-            if (hitCriticalThreshold && !disabledQueryMonitorForLowMem) {\n-              throw new CacheException(\"Should have hit low memory\") {};\n-            }\n-            assertEquals(1, qs.getIndexes().size());\n-          } catch (Exception e) {\n-            if (e instanceof IndexInvalidException) {\n-              if (!hitCriticalThreshold || disabledQueryMonitorForLowMem) {\n-                throw new CacheException(\"Should not have run into low memory exception\") {};\n-              }\n-            } else {\n-              throw new CacheException(e) {};\n-            }\n-          }\n-          return 0;\n-        }\n-      });\n+      vmRecoversFromCriticalHeap(server1);\n     } finally {\n       stopServer(server1);\n       stopServer(server2);\n     }\n   }\n \n-  private void doCriticalMemoryHitAddResultsTestWithMultipleServers(final String regionName,\n-      boolean createPR,\n-      final int criticalThreshold,\n-      final boolean disabledQueryMonitorForLowMem,\n-      final int queryTimeout,\n-      final boolean hitCriticalThreshold)\n-      throws Exception {\n+  @Test\n+  public void testPRGatherCancellationWhileAddingResults() {\n     // create region on the server\n     final VM server1 = VM.getVM(0);\n     final VM server2 = VM.getVM(1);\n     final VM client = VM.getVM(2);\n     final int numObjects = 200;\n     try {\n       final int[] port = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n-      startCacheServer(server1, port[0], criticalThreshold, disabledQueryMonitorForLowMem,\n-          queryTimeout, regionName, createPR, 0);\n-      startCacheServer(server2, port[1], criticalThreshold, true, -1, regionName, createPR, 0);\n+      startCacheServer(server1, port[0], false,\n+          -1, true);\n+      startCacheServer(server2, port[1], true, -1, true);\n \n-      startClient(client, server1, port[0], regionName);\n-      populateData(server2, regionName, numObjects);\n+      startClient(client, port[0]);\n+      populateData(server2);\n \n       createCancelDuringAddResultsTestHook(server1);\n-      client.invoke(new SerializableCallable(\"executing query to be canceled during add results\") {\n-        @Override\n-        public Object call() {\n-          QueryService qs = null;\n-          try {\n-            qs = getCache().getQueryService();\n-            Query query = qs.newQuery(\"Select * From /\" + regionName);\n-            SelectResults results = (SelectResults) query.execute();\n-            if (hitCriticalThreshold && disabledQueryMonitorForLowMem == false) {\n-              throw new CacheException(\"should have hit low memory\") {};\n-            }\n-          } catch (Exception e) {\n-            handleException(e, hitCriticalThreshold, disabledQueryMonitorForLowMem, queryTimeout);\n-          }\n-          return 0;\n+      client.invoke(\"executing query to be canceled during add results\", () -> {\n+        QueryService qs;\n+        try {\n+          qs = getCache().getQueryService();\n+          Query query = qs.newQuery(\"Select * From /\" + \"portfolios\");\n+          query.execute();\n+          throw new CacheException(\"should have hit low memory\") {};\n+        } catch (Exception e) {\n+          handleException(e, true, false, -1);\n         }\n+        return 0;\n       });\n \n-      verifyRejectedObjects(server1, disabledQueryMonitorForLowMem, queryTimeout,\n-          hitCriticalThreshold);\n-      // Pause for a second and then let's recover\n-      try {\n-        Thread.sleep(1000);\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n+      verifyRejectedObjects(server1);\n \n       // Recover from critical heap\n-      if (hitCriticalThreshold) {\n-        vmRecoversFromCriticalHeap(server1);\n-      }\n+      vmRecoversFromCriticalHeap(server1);\n \n       // Check to see if query execution is ok under \"normal\" or \"healthy\" conditions\n-      client.invoke(new CacheSerializableRunnable(\"Executing query when system is 'Normal'\") {\n-        @Override\n-        public void run2() {\n-          try {\n-            QueryService qs = getCache().getQueryService();\n-            Query query = qs.newQuery(\"Select * From /\" + regionName);\n-            SelectResults results = (SelectResults) query.execute();\n-            assertEquals(numObjects, results.size());\n-          } catch (QueryInvocationTargetException e) {\n-            assertFalse(true);\n-          } catch (NameResolutionException e) {\n-            assertFalse(true);\n-          } catch (TypeMismatchException e) {\n-            assertFalse(true);\n-          } catch (FunctionDomainException e) {\n-            assertFalse(true);\n-          }\n+      client.invoke(\"Executing query when system is 'Normal'\", () -> {\n+        try {\n+          QueryService qs = getCache().getQueryService();\n+          Query query = qs.newQuery(\"Select * From /\" + \"portfolios\");\n+          SelectResults results = (SelectResults) query.execute();\n+          assertThat(results.size()).isEqualTo(numObjects);\n+        } catch (QueryInvocationTargetException | FunctionDomainException | TypeMismatchException", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40db9bd39c00a0468aa08ddc4541cd0d26d2f2b9"}, "originalPosition": 711}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA2NzE0MA==", "bodyText": "Done.", "url": "https://github.com/apache/geode/pull/4691#discussion_r379067140", "createdAt": "2020-02-13T19:20:18Z", "author": {"login": "mhansonp"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "diffHunk": "@@ -134,606 +126,525 @@ public Object call() throws Exception {\n       irm.getHeapMonitor().setTestMaxMemoryBytes(0);\n       HeapMemoryMonitor.setTestDisableMemoryUpdates(false);\n       return null;\n-    }\n-  };\n-\n-  private SerializableCallable resetQueryMonitor = new SerializableCallable() {\n-    @Override\n-    public Object call() throws Exception {\n-      InternalCache cache = getCache();\n-      if (cache.getQueryMonitor() != null) {\n-        cache.getQueryMonitor().setLowMemory(false, 0);\n-      }\n-      DefaultQuery.testHook = null;\n-      return null;\n-    }\n-  };\n+    });\n+  }\n \n   @Test\n-  public void testRMAndNoTimeoutSet() throws Exception {\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSet() {\n+    doCriticalMemoryHitTest(false, false, -1, true);\n   }\n \n   @Test\n-  public void testRMAndNoTimeoutSetParReg() throws Exception {\n-    doCriticalMemoryHitTest(\"portfolios\", true, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSetParReg() {\n+    doCriticalMemoryHitTest(true, false, -1, true);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSet() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSet() {\n     // verify that timeout is not set and that a query can execute properly\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, -1, true);\n+    doCriticalMemoryHitTest(false, true, -1, true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSet() throws Exception {\n-    // verify that we still receive critical heap cancelation\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, TEST_QUERY_TIMEOUT,\n+  public void testRMAndTimeoutSet() {\n+    // verify that we still receive critical heap cancellation\n+    doCriticalMemoryHitTest(false, true, TEST_QUERY_TIMEOUT,\n         true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSetAndQueryTimesoutInstead() throws Exception {\n+  public void testRMAndTimeoutSetAndQueryTimeoutInstead() {\n     // verify that timeout is set correctly and cancel query\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, TEST_QUERY_TIMEOUT,\n+    doCriticalMemoryHitTest(false, true, TEST_QUERY_TIMEOUT,\n         false);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSet() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSet() {\n     // verify that timeout is still working properly\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, TEST_QUERY_TIMEOUT,\n+    doCriticalMemoryHitTest(false, true, TEST_QUERY_TIMEOUT,\n         true);\n   }\n \n   // Query directly on member with RM and QM set\n   @Test\n-  public void testRMAndNoTimeoutSetOnServer() throws Exception {\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSetOnServer() {\n+    doCriticalMemoryHitTestOnServer(false, false, -1, true);\n   }\n \n   // Query directly on member with RM and QM set\n   @Test\n-  public void whenTimeoutIsSetAndAQueryIsExecutedThenTimeoutMustStopTheQueryBeforeCriticalMemory()\n-      throws Exception {\n+  public void whenTimeoutIsSetAndAQueryIsExecutedThenTimeoutMustStopTheQueryBeforeCriticalMemory() {\n     // Timeout is set along with critical heap but it be called after the timeout expires\n     // Timeout is set to 1ms which is very unrealistic time period for a query to be able to fetch\n     // 200 entries from the region successfully, hence a timeout is expected.\n-    executeQueryWithTimeoutSetAndCriticalThreshold(\"portfolios\", false, 85/* crit threshold */,\n-        false, 1, true);\n+    // create region on the server\n+    final VM server = VM.getVM(0);\n+    try {\n+      final int port = AvailablePortHelper.getRandomAvailableTCPPort();\n+      startCacheServer(server, port, false, 1,\n+          false);\n+      populateData(server);\n+      executeQueryWithCriticalHeapCalledAfterTimeout(server, server);\n+      vmRecoversFromCriticalHeap(server);\n+\n+    } finally {\n+      stopServer(server);\n+    }\n   }\n \n   @Test\n-  public void whenTimeoutIsSetAndAQueryIsExecutedFromClientThenTimeoutMustStopTheQueryBeforeCriticalMemory()\n-      throws Exception {\n+  public void whenTimeoutIsSetAndAQueryIsExecutedFromClientThenTimeoutMustStopTheQueryBeforeCriticalMemory() {\n     // Timeout is set along with critical heap but it be called after the timeout expires\n     // Timeout is set to 1ms which is very unrealistic time period for a query to be able to fetch\n     // 200 entries from the region successfully, hence a timeout is expected.\n-    executeQueryFromClientWithTimeoutSetAndCriticalThreshold(\"portfolios\", false,\n-        85/* crit threshold */, false, 1, true);\n+    // create region on the server\n+    final VM server = VM.getVM(0);\n+    final VM client = VM.getVM(1);\n+    try {\n+      final int port = AvailablePortHelper.getRandomAvailableTCPPort();\n+      startCacheServer(server, port, false, 1,\n+          false);\n+      startClient(client, port);\n+      populateData(server);\n+      executeQueryWithCriticalHeapCalledAfterTimeout(server, client);\n+      vmRecoversFromCriticalHeap(server);\n+\n+    } finally {\n+      stopServer(server);\n+    }\n   }\n \n   @Test\n-  public void testRMAndNoTimeoutSetParRegOnServer() throws Exception {\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", true, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSetParRegOnServer() {\n+    doCriticalMemoryHitTestOnServer(true, false, -1, true);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSetOnServer() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSetOnServer() {\n     // verify that timeout is not set and that a query can execute properly\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true, -1, true);\n+    doCriticalMemoryHitTestOnServer(false, true, -1, true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSetOnServer() throws Exception {\n-    // verify that we still receive critical heap cancelation\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true,\n+  public void testRMAndTimeoutSetOnServer() {\n+    // verify that we still receive critical heap cancellation\n+    doCriticalMemoryHitTestOnServer(false, true,\n         TEST_QUERY_TIMEOUT, true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSetAndQueryTimesoutInsteadOnServer() throws Exception {\n+  public void testRMAndTimeoutSetAndQueryTimeoutInsteadOnServer() {\n     // verify that timeout is set correctly and cancel query\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true,\n+    doCriticalMemoryHitTestOnServer(false, true,\n         TEST_QUERY_TIMEOUT, false);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSetOnServer() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSetOnServer() {\n     // verify that timeout is still working properly\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true,\n+    doCriticalMemoryHitTestOnServer(false, true,\n         TEST_QUERY_TIMEOUT, true);\n   }\n \n   @Test\n-  public void testPRGatherCancellation() throws Exception {\n-    doCriticalMemoryHitTestWithMultipleServers(\"portfolios\", true, 85/* crit threshold */, false,\n-        -1, true);\n-  }\n-\n-  @Test\n-  public void testPRGatherCancellationWhileGatheringResults() throws Exception {\n-    doCriticalMemoryHitDuringGatherTestWithMultipleServers(\"portfolios\", true,\n-        85/* crit threshold */, false, -1, true);\n-  }\n+  public void testPRGatherCancellation() throws Throwable {\n+    // create region on the server\n+    final VM server1 = VM.getVM(0);\n+    final VM server2 = VM.getVM(1);\n+    final VM client = VM.getVM(2);\n+    final int numObjects = 200;\n+    final VM controller = VM.getController();\n+    try {\n+      final int[] port = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n+      startCacheServer(server1, port[0], false,\n+          -1, true);\n+      startCacheServer(server2, port[1], true, -1, true);\n+\n+      startClient(client, port[0]);\n+      populateData(server2);\n+      server1.invoke(\"create latch test Hook\", () -> {\n+        DefaultQuery.testHook = getPauseHook(true, controller);\n+      });\n+      // remove from here to ....\n+      AsyncInvocation queryExecution1 = executeQueryOnClient(client);\n \n-  @Test\n-  public void testPRGatherCancellationWhileAddingResults() throws Exception {\n-    doCriticalMemoryHitAddResultsTestWithMultipleServers(\"portfolios\", true, 85/* crit threshold */,\n-        false, -1, true);\n-  }\n+      // Gives async invocation a chance to start\n+      Thread.sleep(1000);\n+      // We simulate a low memory/critical heap percentage hit\n+      setHeapToCriticalAndReleaseLatch(server1);\n+      assertThat(queryExecution1.get(60, SECONDS)).isEqualTo(0);\n+      verifyDroppedObjectsAndSetHeapToNormal(server1);\n \n-  @Test\n-  public void testIndexCreationCancellationPR() throws Exception {\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", true, 85/* crit threshold */, false, -1, true,\n-        \"compact\");\n-  }\n+      // to here....\n+      // Check to see if query execution is ok under \"normal\" or \"healthy\" conditions\n+      client.invoke(\"Executing query when system is 'Normal'\", () -> {\n+        try {\n+          Query query = getCache().getQueryService().newQuery(\"Select * From /\" + \"portfolios\");\n+          SelectResults results = (SelectResults) query.execute();\n+          assertThat(results.size()).isEqualTo(numObjects);\n+        } catch (QueryInvocationTargetException | FunctionDomainException | TypeMismatchException\n+            | NameResolutionException e) {\n+          fail(\"\");\n+        }\n+      });\n+      // We simulate a low memory/critical heap percentage hit\n+      setHeapToCriticalAndReleaseLatch(server1);\n+      AsyncInvocation queryExecution = executeQueryOnClient(client);\n+      assertThat(queryExecution.get(60, SECONDS)).isEqualTo(0);\n+      verifyDroppedObjectsAndSetHeapToNormal(server1);\n \n-  @Test\n-  public void testIndexCreationCancellation() throws Exception {\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", false, 85/* crit threshold */, false, -1, true,\n-        \"compact\");\n+    } finally {\n+      stopServer(server1);\n+      stopServer(server2);\n+    }\n   }\n \n-  @Test\n-  public void testIndexCreationNoCancellationPR() throws Exception {\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", true, 85/* crit threshold */, true, -1, true,\n-        \"compact\");\n+  private AsyncInvocation executeQueryOnClient(VM client) {\n+    return client.invokeAsync(\"execute query from client\", () -> {\n+      try {\n+        Query query1 = getCache().getQueryService().newQuery(\"Select * From /\" + \"portfolios\");\n+        query1.execute();\n+        throw new CacheException(\"Exception should have been thrown due to low memory\") {};\n+      } catch (Exception e2) {\n+        handleException(e2, true, false, -1);\n+      }\n+      return 0;\n+    });\n   }\n \n-  @Test\n-  public void testHashIndexCreationCancellationPR() throws Exception {\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", true, 85/* crit threshold */, false, -1, true,\n-        \"hash\");\n+  private void setHeapToCriticalAndReleaseLatch(VM server1) {\n+    server1.invoke(\"vm hits critical heap and counts down latch.\", () -> {\n+      InternalResourceManager resourceManager =\n+          (InternalResourceManager) getCache().getResourceManager();\n+      resourceManager.getHeapMonitor().updateStateAndSendEvent(CRITICAL_HEAP_USED, \"test\");\n+      await()\n+          .until(() -> resourceManager.getHeapMonitor().getState() == EVICTION_DISABLED_CRITICAL);\n+      Thread.sleep(MAX_TEST_QUERY_TIMEOUT);\n+      // release the hook to have the query throw either a low memory or query timeout\n+      // unless otherwise configured\n+      PauseTestHook hook = (PauseTestHook) DefaultQuery.testHook;\n+      hook.countDown();\n+    });\n   }\n \n-  @Test\n-  public void testHashIndexCreationCancellation() throws Exception {\n-    // need to add hook to canceled result set and very it is triggered for multiple servers\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", false, 85/* crit threshold */, false, -1, true,\n-        \"hash\");\n+  private void verifyDroppedObjectsAndSetHeapToNormal(VM server1) {\n+    server1.invoke(\"verify dropped objects\", () -> {\n+      if (DefaultQuery.testHook instanceof RejectedObjectsInterface) {\n+        RejectedObjectsInterface rejectedObjectsInterface =\n+            (RejectedObjectsInterface) DefaultQuery.testHook;\n+        await()\n+            .untilAsserted(() -> assertThat(rejectedObjectsInterface.rejectedObjects).isTrue());\n+      }\n+      InternalResourceManager resourceManager =\n+          (InternalResourceManager) getCache().getResourceManager();\n+      resourceManager.getHeapMonitor().updateStateAndSendEvent(NORMAL_HEAP_USED, \"test\");\n+      await().until(() -> resourceManager.getHeapMonitor().getState() == EVICTION_DISABLED);\n+    });\n   }\n \n   @Test\n-  public void testHashIndexCreationNoCancellationPR() throws Exception {\n-    // need to add hook to canceled result set and very it is triggered for multiple servers\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", true, 85/* crit threshold */, true, -1, true,\n-        \"hash\");\n-  }\n-\n-  private void doCriticalMemoryHitTest(final String regionName, boolean createPR,\n-      final int criticalThreshold,\n-      final boolean disabledQueryMonitorForLowMem,\n-      final int queryTimeout, final boolean hitCriticalThreshold)\n-      throws Exception {\n+  public void testPRGatherCancellationWhileGatheringResults() {\n     // create region on the server\n-    final VM server = VM.getVM(0);\n-    final VM client = VM.getVM(1);\n+    final VM server1 = VM.getVM(0);\n+    final VM server2 = VM.getVM(1);\n+    final VM client = VM.getVM(2);\n     final int numObjects = 200;\n     try {\n-      final int port = AvailablePortHelper.getRandomAvailableTCPPort();\n-      startCacheServer(server, port, criticalThreshold, disabledQueryMonitorForLowMem, queryTimeout,\n-          regionName, createPR, 0);\n+      final int[] port = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n+      startCacheServer(server1, port[0], false,\n+          -1, true);\n+      startCacheServer(server2, port[1], true, -1, true);\n \n-      startClient(client, server, port, regionName);\n-      populateData(server, regionName, numObjects);\n+      startClient(client, port[0]);\n+      populateData(server2);\n \n-      doTestCriticalHeapAndQueryTimeout(server, client, regionName, disabledQueryMonitorForLowMem,\n-          queryTimeout, hitCriticalThreshold);\n+      createCancelDuringGatherTestHook(server1, VM.getController());\n+      client.invoke(\"executing query to be canceled by gather\", () -> {\n+        QueryService qs;\n+        try {\n+          qs = getCache().getQueryService();\n+          Query query = qs.newQuery(\"Select * From /\" + \"portfolios\");\n+          query.execute();\n+        } catch (ServerOperationException soe) {\n+          if (soe.getRootCause() instanceof QueryException) {\n+            QueryException e = (QueryException) soe.getRootCause();\n+            if (!isExceptionDueToLowMemory(e)) {\n+              throw new CacheException(soe) {};\n+            } else {\n+              return 0;\n+            }\n+          }\n+        } catch (Exception e) {\n+          throw new CacheException(e) {};\n+        }\n+        // assertTrue(((CancelDuringGatherHook)DefaultQuery.testHook).triggeredOOME);\n+        throw new CacheException(\"should have hit low memory\") {};\n+      });\n \n-      // Pause for a second and then let's recover\n-      try {\n-        Thread.sleep(1000);\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n+      verifyRejectedObjects(server1);\n \n       // Recover from critical heap\n-      if (hitCriticalThreshold) {\n-        vmRecoversFromCriticalHeap(server);\n-      }\n+      vmRecoversFromCriticalHeap(server1);\n \n       // Check to see if query execution is ok under \"normal\" or \"healthy\" conditions\n-      client.invoke(new CacheSerializableRunnable(\"Executing query when system is 'Normal'\") {\n-        @Override\n-        public void run2() {\n-          try {\n-            QueryService qs = getCache().getQueryService();\n-            Query query = qs.newQuery(\"Select * From /\" + regionName);\n-            SelectResults results = (SelectResults) query.execute();\n-            assertEquals(numObjects, results.size());\n-          } catch (QueryInvocationTargetException e) {\n-            assertFalse(true);\n-          } catch (NameResolutionException e) {\n-            assertFalse(true);\n-          } catch (TypeMismatchException e) {\n-            assertFalse(true);\n-          } catch (FunctionDomainException e) {\n-            assertFalse(true);\n-          }\n+      client.invoke(\"Executing query when system is 'Normal'\", () -> {\n+        try {\n+          QueryService qs = getCache().getQueryService();\n+          Query query = qs.newQuery(\"Select * From /\" + \"portfolios\");\n+          SelectResults results = (SelectResults) query.execute();\n+          assertThat(results.size()).isEqualTo(numObjects);\n+        } catch (QueryInvocationTargetException | FunctionDomainException | TypeMismatchException\n+            | NameResolutionException e) {\n+          fail(\"\");\n         }\n       });\n \n-      // Execute a critical heap event/ query timeout test again\n-      doTestCriticalHeapAndQueryTimeout(server, client, regionName, disabledQueryMonitorForLowMem,\n-          queryTimeout, hitCriticalThreshold);\n       // Recover from critical heap\n-      if (hitCriticalThreshold) {\n-        vmRecoversFromCriticalHeap(server);\n-      }\n-    } finally {\n-      stopServer(server);\n-    }\n-  }\n-\n-  // test to verify what happens during index creation if memory threshold is hit\n-  private void doCriticalMemoryHitWithIndexTest(final String regionName, boolean createPR,\n-      final int criticalThreshold,\n-      final boolean disabledQueryMonitorForLowMem,\n-      final int queryTimeout,\n-      final boolean hitCriticalThreshold,\n-      final String indexType)\n-      throws Exception {\n-    // create region on the server\n-    final VM server1 = VM.getVM(0);\n-    final VM server2 = VM.getVM(2);\n-    final VM client = VM.getVM(1);\n-    final int numObjects = 200;\n-    try {\n-      final int[] port = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n-      startCacheServer(server1, port[0], criticalThreshold, disabledQueryMonitorForLowMem,\n-          queryTimeout, regionName, createPR, 0);\n-      startCacheServer(server2, port[1], criticalThreshold, true, -1, regionName, createPR, 0);\n-\n-      startClient(client, server1, port[0], regionName);\n-      populateData(server1, regionName, numObjects);\n-\n-      createCancelDuringGatherTestHook(server1);\n-      server1.invoke(new SerializableCallable(\"create index\") {\n-        @Override\n-        public Object call() {\n-          QueryService qs = null;\n-          try {\n-            qs = getCache().getQueryService();\n-            Index index = null;\n-            if (indexType.equals(\"compact\")) {\n-              index = qs.createIndex(\"newIndex\", \"ID\", \"/\" + regionName);\n-            } else if (indexType.equals(\"hash\")) {\n-              index = qs.createHashIndex(\"newIndex\", \"ID\", \"/\" + regionName);\n-            }\n-            assertNotNull(index);\n-            assertTrue(((CancelDuringGatherHook) DefaultQuery.testHook).triggeredOOME);\n-\n-            if (hitCriticalThreshold && !disabledQueryMonitorForLowMem) {\n-              throw new CacheException(\"Should have hit low memory\") {};\n-            }\n-            assertEquals(1, qs.getIndexes().size());\n-          } catch (Exception e) {\n-            if (e instanceof IndexInvalidException) {\n-              if (!hitCriticalThreshold || disabledQueryMonitorForLowMem) {\n-                throw new CacheException(\"Should not have run into low memory exception\") {};\n-              }\n-            } else {\n-              throw new CacheException(e) {};\n-            }\n-          }\n-          return 0;\n-        }\n-      });\n+      vmRecoversFromCriticalHeap(server1);\n     } finally {\n       stopServer(server1);\n       stopServer(server2);\n     }\n   }\n \n-  private void doCriticalMemoryHitAddResultsTestWithMultipleServers(final String regionName,\n-      boolean createPR,\n-      final int criticalThreshold,\n-      final boolean disabledQueryMonitorForLowMem,\n-      final int queryTimeout,\n-      final boolean hitCriticalThreshold)\n-      throws Exception {\n+  @Test\n+  public void testPRGatherCancellationWhileAddingResults() {\n     // create region on the server\n     final VM server1 = VM.getVM(0);\n     final VM server2 = VM.getVM(1);\n     final VM client = VM.getVM(2);\n     final int numObjects = 200;\n     try {\n       final int[] port = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n-      startCacheServer(server1, port[0], criticalThreshold, disabledQueryMonitorForLowMem,\n-          queryTimeout, regionName, createPR, 0);\n-      startCacheServer(server2, port[1], criticalThreshold, true, -1, regionName, createPR, 0);\n+      startCacheServer(server1, port[0], false,\n+          -1, true);\n+      startCacheServer(server2, port[1], true, -1, true);\n \n-      startClient(client, server1, port[0], regionName);\n-      populateData(server2, regionName, numObjects);\n+      startClient(client, port[0]);\n+      populateData(server2);\n \n       createCancelDuringAddResultsTestHook(server1);\n-      client.invoke(new SerializableCallable(\"executing query to be canceled during add results\") {\n-        @Override\n-        public Object call() {\n-          QueryService qs = null;\n-          try {\n-            qs = getCache().getQueryService();\n-            Query query = qs.newQuery(\"Select * From /\" + regionName);\n-            SelectResults results = (SelectResults) query.execute();\n-            if (hitCriticalThreshold && disabledQueryMonitorForLowMem == false) {\n-              throw new CacheException(\"should have hit low memory\") {};\n-            }\n-          } catch (Exception e) {\n-            handleException(e, hitCriticalThreshold, disabledQueryMonitorForLowMem, queryTimeout);\n-          }\n-          return 0;\n+      client.invoke(\"executing query to be canceled during add results\", () -> {\n+        QueryService qs;\n+        try {\n+          qs = getCache().getQueryService();\n+          Query query = qs.newQuery(\"Select * From /\" + \"portfolios\");\n+          query.execute();\n+          throw new CacheException(\"should have hit low memory\") {};\n+        } catch (Exception e) {\n+          handleException(e, true, false, -1);\n         }\n+        return 0;\n       });\n \n-      verifyRejectedObjects(server1, disabledQueryMonitorForLowMem, queryTimeout,\n-          hitCriticalThreshold);\n-      // Pause for a second and then let's recover\n-      try {\n-        Thread.sleep(1000);\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n+      verifyRejectedObjects(server1);\n \n       // Recover from critical heap\n-      if (hitCriticalThreshold) {\n-        vmRecoversFromCriticalHeap(server1);\n-      }\n+      vmRecoversFromCriticalHeap(server1);\n \n       // Check to see if query execution is ok under \"normal\" or \"healthy\" conditions\n-      client.invoke(new CacheSerializableRunnable(\"Executing query when system is 'Normal'\") {\n-        @Override\n-        public void run2() {\n-          try {\n-            QueryService qs = getCache().getQueryService();\n-            Query query = qs.newQuery(\"Select * From /\" + regionName);\n-            SelectResults results = (SelectResults) query.execute();\n-            assertEquals(numObjects, results.size());\n-          } catch (QueryInvocationTargetException e) {\n-            assertFalse(true);\n-          } catch (NameResolutionException e) {\n-            assertFalse(true);\n-          } catch (TypeMismatchException e) {\n-            assertFalse(true);\n-          } catch (FunctionDomainException e) {\n-            assertFalse(true);\n-          }\n+      client.invoke(\"Executing query when system is 'Normal'\", () -> {\n+        try {\n+          QueryService qs = getCache().getQueryService();\n+          Query query = qs.newQuery(\"Select * From /\" + \"portfolios\");\n+          SelectResults results = (SelectResults) query.execute();\n+          assertThat(results.size()).isEqualTo(numObjects);\n+        } catch (QueryInvocationTargetException | FunctionDomainException | TypeMismatchException", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzNTc2NQ=="}, "originalCommit": {"oid": "40db9bd39c00a0468aa08ddc4541cd0d26d2f2b9"}, "originalPosition": 711}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MTk1Nzk4OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMTo1NjozMlrOFo__9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMTo1NjozMlrOFo__9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzNTkyNQ==", "bodyText": "Another catch-block to delete.", "url": "https://github.com/apache/geode/pull/4691#discussion_r378535925", "createdAt": "2020-02-12T21:56:32Z", "author": {"login": "kirklund"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "diffHunk": "@@ -134,606 +126,525 @@ public Object call() throws Exception {\n       irm.getHeapMonitor().setTestMaxMemoryBytes(0);\n       HeapMemoryMonitor.setTestDisableMemoryUpdates(false);\n       return null;\n-    }\n-  };\n-\n-  private SerializableCallable resetQueryMonitor = new SerializableCallable() {\n-    @Override\n-    public Object call() throws Exception {\n-      InternalCache cache = getCache();\n-      if (cache.getQueryMonitor() != null) {\n-        cache.getQueryMonitor().setLowMemory(false, 0);\n-      }\n-      DefaultQuery.testHook = null;\n-      return null;\n-    }\n-  };\n+    });\n+  }\n \n   @Test\n-  public void testRMAndNoTimeoutSet() throws Exception {\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSet() {\n+    doCriticalMemoryHitTest(false, false, -1, true);\n   }\n \n   @Test\n-  public void testRMAndNoTimeoutSetParReg() throws Exception {\n-    doCriticalMemoryHitTest(\"portfolios\", true, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSetParReg() {\n+    doCriticalMemoryHitTest(true, false, -1, true);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSet() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSet() {\n     // verify that timeout is not set and that a query can execute properly\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, -1, true);\n+    doCriticalMemoryHitTest(false, true, -1, true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSet() throws Exception {\n-    // verify that we still receive critical heap cancelation\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, TEST_QUERY_TIMEOUT,\n+  public void testRMAndTimeoutSet() {\n+    // verify that we still receive critical heap cancellation\n+    doCriticalMemoryHitTest(false, true, TEST_QUERY_TIMEOUT,\n         true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSetAndQueryTimesoutInstead() throws Exception {\n+  public void testRMAndTimeoutSetAndQueryTimeoutInstead() {\n     // verify that timeout is set correctly and cancel query\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, TEST_QUERY_TIMEOUT,\n+    doCriticalMemoryHitTest(false, true, TEST_QUERY_TIMEOUT,\n         false);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSet() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSet() {\n     // verify that timeout is still working properly\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, TEST_QUERY_TIMEOUT,\n+    doCriticalMemoryHitTest(false, true, TEST_QUERY_TIMEOUT,\n         true);\n   }\n \n   // Query directly on member with RM and QM set\n   @Test\n-  public void testRMAndNoTimeoutSetOnServer() throws Exception {\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSetOnServer() {\n+    doCriticalMemoryHitTestOnServer(false, false, -1, true);\n   }\n \n   // Query directly on member with RM and QM set\n   @Test\n-  public void whenTimeoutIsSetAndAQueryIsExecutedThenTimeoutMustStopTheQueryBeforeCriticalMemory()\n-      throws Exception {\n+  public void whenTimeoutIsSetAndAQueryIsExecutedThenTimeoutMustStopTheQueryBeforeCriticalMemory() {\n     // Timeout is set along with critical heap but it be called after the timeout expires\n     // Timeout is set to 1ms which is very unrealistic time period for a query to be able to fetch\n     // 200 entries from the region successfully, hence a timeout is expected.\n-    executeQueryWithTimeoutSetAndCriticalThreshold(\"portfolios\", false, 85/* crit threshold */,\n-        false, 1, true);\n+    // create region on the server\n+    final VM server = VM.getVM(0);\n+    try {\n+      final int port = AvailablePortHelper.getRandomAvailableTCPPort();\n+      startCacheServer(server, port, false, 1,\n+          false);\n+      populateData(server);\n+      executeQueryWithCriticalHeapCalledAfterTimeout(server, server);\n+      vmRecoversFromCriticalHeap(server);\n+\n+    } finally {\n+      stopServer(server);\n+    }\n   }\n \n   @Test\n-  public void whenTimeoutIsSetAndAQueryIsExecutedFromClientThenTimeoutMustStopTheQueryBeforeCriticalMemory()\n-      throws Exception {\n+  public void whenTimeoutIsSetAndAQueryIsExecutedFromClientThenTimeoutMustStopTheQueryBeforeCriticalMemory() {\n     // Timeout is set along with critical heap but it be called after the timeout expires\n     // Timeout is set to 1ms which is very unrealistic time period for a query to be able to fetch\n     // 200 entries from the region successfully, hence a timeout is expected.\n-    executeQueryFromClientWithTimeoutSetAndCriticalThreshold(\"portfolios\", false,\n-        85/* crit threshold */, false, 1, true);\n+    // create region on the server\n+    final VM server = VM.getVM(0);\n+    final VM client = VM.getVM(1);\n+    try {\n+      final int port = AvailablePortHelper.getRandomAvailableTCPPort();\n+      startCacheServer(server, port, false, 1,\n+          false);\n+      startClient(client, port);\n+      populateData(server);\n+      executeQueryWithCriticalHeapCalledAfterTimeout(server, client);\n+      vmRecoversFromCriticalHeap(server);\n+\n+    } finally {\n+      stopServer(server);\n+    }\n   }\n \n   @Test\n-  public void testRMAndNoTimeoutSetParRegOnServer() throws Exception {\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", true, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSetParRegOnServer() {\n+    doCriticalMemoryHitTestOnServer(true, false, -1, true);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSetOnServer() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSetOnServer() {\n     // verify that timeout is not set and that a query can execute properly\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true, -1, true);\n+    doCriticalMemoryHitTestOnServer(false, true, -1, true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSetOnServer() throws Exception {\n-    // verify that we still receive critical heap cancelation\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true,\n+  public void testRMAndTimeoutSetOnServer() {\n+    // verify that we still receive critical heap cancellation\n+    doCriticalMemoryHitTestOnServer(false, true,\n         TEST_QUERY_TIMEOUT, true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSetAndQueryTimesoutInsteadOnServer() throws Exception {\n+  public void testRMAndTimeoutSetAndQueryTimeoutInsteadOnServer() {\n     // verify that timeout is set correctly and cancel query\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true,\n+    doCriticalMemoryHitTestOnServer(false, true,\n         TEST_QUERY_TIMEOUT, false);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSetOnServer() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSetOnServer() {\n     // verify that timeout is still working properly\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true,\n+    doCriticalMemoryHitTestOnServer(false, true,\n         TEST_QUERY_TIMEOUT, true);\n   }\n \n   @Test\n-  public void testPRGatherCancellation() throws Exception {\n-    doCriticalMemoryHitTestWithMultipleServers(\"portfolios\", true, 85/* crit threshold */, false,\n-        -1, true);\n-  }\n-\n-  @Test\n-  public void testPRGatherCancellationWhileGatheringResults() throws Exception {\n-    doCriticalMemoryHitDuringGatherTestWithMultipleServers(\"portfolios\", true,\n-        85/* crit threshold */, false, -1, true);\n-  }\n+  public void testPRGatherCancellation() throws Throwable {\n+    // create region on the server\n+    final VM server1 = VM.getVM(0);\n+    final VM server2 = VM.getVM(1);\n+    final VM client = VM.getVM(2);\n+    final int numObjects = 200;\n+    final VM controller = VM.getController();\n+    try {\n+      final int[] port = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n+      startCacheServer(server1, port[0], false,\n+          -1, true);\n+      startCacheServer(server2, port[1], true, -1, true);\n+\n+      startClient(client, port[0]);\n+      populateData(server2);\n+      server1.invoke(\"create latch test Hook\", () -> {\n+        DefaultQuery.testHook = getPauseHook(true, controller);\n+      });\n+      // remove from here to ....\n+      AsyncInvocation queryExecution1 = executeQueryOnClient(client);\n \n-  @Test\n-  public void testPRGatherCancellationWhileAddingResults() throws Exception {\n-    doCriticalMemoryHitAddResultsTestWithMultipleServers(\"portfolios\", true, 85/* crit threshold */,\n-        false, -1, true);\n-  }\n+      // Gives async invocation a chance to start\n+      Thread.sleep(1000);\n+      // We simulate a low memory/critical heap percentage hit\n+      setHeapToCriticalAndReleaseLatch(server1);\n+      assertThat(queryExecution1.get(60, SECONDS)).isEqualTo(0);\n+      verifyDroppedObjectsAndSetHeapToNormal(server1);\n \n-  @Test\n-  public void testIndexCreationCancellationPR() throws Exception {\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", true, 85/* crit threshold */, false, -1, true,\n-        \"compact\");\n-  }\n+      // to here....\n+      // Check to see if query execution is ok under \"normal\" or \"healthy\" conditions\n+      client.invoke(\"Executing query when system is 'Normal'\", () -> {\n+        try {\n+          Query query = getCache().getQueryService().newQuery(\"Select * From /\" + \"portfolios\");\n+          SelectResults results = (SelectResults) query.execute();\n+          assertThat(results.size()).isEqualTo(numObjects);\n+        } catch (QueryInvocationTargetException | FunctionDomainException | TypeMismatchException\n+            | NameResolutionException e) {\n+          fail(\"\");\n+        }\n+      });\n+      // We simulate a low memory/critical heap percentage hit\n+      setHeapToCriticalAndReleaseLatch(server1);\n+      AsyncInvocation queryExecution = executeQueryOnClient(client);\n+      assertThat(queryExecution.get(60, SECONDS)).isEqualTo(0);\n+      verifyDroppedObjectsAndSetHeapToNormal(server1);\n \n-  @Test\n-  public void testIndexCreationCancellation() throws Exception {\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", false, 85/* crit threshold */, false, -1, true,\n-        \"compact\");\n+    } finally {\n+      stopServer(server1);\n+      stopServer(server2);\n+    }\n   }\n \n-  @Test\n-  public void testIndexCreationNoCancellationPR() throws Exception {\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", true, 85/* crit threshold */, true, -1, true,\n-        \"compact\");\n+  private AsyncInvocation executeQueryOnClient(VM client) {\n+    return client.invokeAsync(\"execute query from client\", () -> {\n+      try {\n+        Query query1 = getCache().getQueryService().newQuery(\"Select * From /\" + \"portfolios\");\n+        query1.execute();\n+        throw new CacheException(\"Exception should have been thrown due to low memory\") {};\n+      } catch (Exception e2) {\n+        handleException(e2, true, false, -1);\n+      }\n+      return 0;\n+    });\n   }\n \n-  @Test\n-  public void testHashIndexCreationCancellationPR() throws Exception {\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", true, 85/* crit threshold */, false, -1, true,\n-        \"hash\");\n+  private void setHeapToCriticalAndReleaseLatch(VM server1) {\n+    server1.invoke(\"vm hits critical heap and counts down latch.\", () -> {\n+      InternalResourceManager resourceManager =\n+          (InternalResourceManager) getCache().getResourceManager();\n+      resourceManager.getHeapMonitor().updateStateAndSendEvent(CRITICAL_HEAP_USED, \"test\");\n+      await()\n+          .until(() -> resourceManager.getHeapMonitor().getState() == EVICTION_DISABLED_CRITICAL);\n+      Thread.sleep(MAX_TEST_QUERY_TIMEOUT);\n+      // release the hook to have the query throw either a low memory or query timeout\n+      // unless otherwise configured\n+      PauseTestHook hook = (PauseTestHook) DefaultQuery.testHook;\n+      hook.countDown();\n+    });\n   }\n \n-  @Test\n-  public void testHashIndexCreationCancellation() throws Exception {\n-    // need to add hook to canceled result set and very it is triggered for multiple servers\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", false, 85/* crit threshold */, false, -1, true,\n-        \"hash\");\n+  private void verifyDroppedObjectsAndSetHeapToNormal(VM server1) {\n+    server1.invoke(\"verify dropped objects\", () -> {\n+      if (DefaultQuery.testHook instanceof RejectedObjectsInterface) {\n+        RejectedObjectsInterface rejectedObjectsInterface =\n+            (RejectedObjectsInterface) DefaultQuery.testHook;\n+        await()\n+            .untilAsserted(() -> assertThat(rejectedObjectsInterface.rejectedObjects).isTrue());\n+      }\n+      InternalResourceManager resourceManager =\n+          (InternalResourceManager) getCache().getResourceManager();\n+      resourceManager.getHeapMonitor().updateStateAndSendEvent(NORMAL_HEAP_USED, \"test\");\n+      await().until(() -> resourceManager.getHeapMonitor().getState() == EVICTION_DISABLED);\n+    });\n   }\n \n   @Test\n-  public void testHashIndexCreationNoCancellationPR() throws Exception {\n-    // need to add hook to canceled result set and very it is triggered for multiple servers\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", true, 85/* crit threshold */, true, -1, true,\n-        \"hash\");\n-  }\n-\n-  private void doCriticalMemoryHitTest(final String regionName, boolean createPR,\n-      final int criticalThreshold,\n-      final boolean disabledQueryMonitorForLowMem,\n-      final int queryTimeout, final boolean hitCriticalThreshold)\n-      throws Exception {\n+  public void testPRGatherCancellationWhileGatheringResults() {\n     // create region on the server\n-    final VM server = VM.getVM(0);\n-    final VM client = VM.getVM(1);\n+    final VM server1 = VM.getVM(0);\n+    final VM server2 = VM.getVM(1);\n+    final VM client = VM.getVM(2);\n     final int numObjects = 200;\n     try {\n-      final int port = AvailablePortHelper.getRandomAvailableTCPPort();\n-      startCacheServer(server, port, criticalThreshold, disabledQueryMonitorForLowMem, queryTimeout,\n-          regionName, createPR, 0);\n+      final int[] port = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n+      startCacheServer(server1, port[0], false,\n+          -1, true);\n+      startCacheServer(server2, port[1], true, -1, true);\n \n-      startClient(client, server, port, regionName);\n-      populateData(server, regionName, numObjects);\n+      startClient(client, port[0]);\n+      populateData(server2);\n \n-      doTestCriticalHeapAndQueryTimeout(server, client, regionName, disabledQueryMonitorForLowMem,\n-          queryTimeout, hitCriticalThreshold);\n+      createCancelDuringGatherTestHook(server1, VM.getController());\n+      client.invoke(\"executing query to be canceled by gather\", () -> {\n+        QueryService qs;\n+        try {\n+          qs = getCache().getQueryService();\n+          Query query = qs.newQuery(\"Select * From /\" + \"portfolios\");\n+          query.execute();\n+        } catch (ServerOperationException soe) {\n+          if (soe.getRootCause() instanceof QueryException) {\n+            QueryException e = (QueryException) soe.getRootCause();\n+            if (!isExceptionDueToLowMemory(e)) {\n+              throw new CacheException(soe) {};\n+            } else {\n+              return 0;\n+            }\n+          }\n+        } catch (Exception e) {\n+          throw new CacheException(e) {};\n+        }\n+        // assertTrue(((CancelDuringGatherHook)DefaultQuery.testHook).triggeredOOME);\n+        throw new CacheException(\"should have hit low memory\") {};\n+      });\n \n-      // Pause for a second and then let's recover\n-      try {\n-        Thread.sleep(1000);\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n+      verifyRejectedObjects(server1);\n \n       // Recover from critical heap\n-      if (hitCriticalThreshold) {\n-        vmRecoversFromCriticalHeap(server);\n-      }\n+      vmRecoversFromCriticalHeap(server1);\n \n       // Check to see if query execution is ok under \"normal\" or \"healthy\" conditions\n-      client.invoke(new CacheSerializableRunnable(\"Executing query when system is 'Normal'\") {\n-        @Override\n-        public void run2() {\n-          try {\n-            QueryService qs = getCache().getQueryService();\n-            Query query = qs.newQuery(\"Select * From /\" + regionName);\n-            SelectResults results = (SelectResults) query.execute();\n-            assertEquals(numObjects, results.size());\n-          } catch (QueryInvocationTargetException e) {\n-            assertFalse(true);\n-          } catch (NameResolutionException e) {\n-            assertFalse(true);\n-          } catch (TypeMismatchException e) {\n-            assertFalse(true);\n-          } catch (FunctionDomainException e) {\n-            assertFalse(true);\n-          }\n+      client.invoke(\"Executing query when system is 'Normal'\", () -> {\n+        try {\n+          QueryService qs = getCache().getQueryService();\n+          Query query = qs.newQuery(\"Select * From /\" + \"portfolios\");\n+          SelectResults results = (SelectResults) query.execute();\n+          assertThat(results.size()).isEqualTo(numObjects);\n+        } catch (QueryInvocationTargetException | FunctionDomainException | TypeMismatchException\n+            | NameResolutionException e) {\n+          fail(\"\");\n         }\n       });\n \n-      // Execute a critical heap event/ query timeout test again\n-      doTestCriticalHeapAndQueryTimeout(server, client, regionName, disabledQueryMonitorForLowMem,\n-          queryTimeout, hitCriticalThreshold);\n       // Recover from critical heap\n-      if (hitCriticalThreshold) {\n-        vmRecoversFromCriticalHeap(server);\n-      }\n-    } finally {\n-      stopServer(server);\n-    }\n-  }\n-\n-  // test to verify what happens during index creation if memory threshold is hit\n-  private void doCriticalMemoryHitWithIndexTest(final String regionName, boolean createPR,\n-      final int criticalThreshold,\n-      final boolean disabledQueryMonitorForLowMem,\n-      final int queryTimeout,\n-      final boolean hitCriticalThreshold,\n-      final String indexType)\n-      throws Exception {\n-    // create region on the server\n-    final VM server1 = VM.getVM(0);\n-    final VM server2 = VM.getVM(2);\n-    final VM client = VM.getVM(1);\n-    final int numObjects = 200;\n-    try {\n-      final int[] port = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n-      startCacheServer(server1, port[0], criticalThreshold, disabledQueryMonitorForLowMem,\n-          queryTimeout, regionName, createPR, 0);\n-      startCacheServer(server2, port[1], criticalThreshold, true, -1, regionName, createPR, 0);\n-\n-      startClient(client, server1, port[0], regionName);\n-      populateData(server1, regionName, numObjects);\n-\n-      createCancelDuringGatherTestHook(server1);\n-      server1.invoke(new SerializableCallable(\"create index\") {\n-        @Override\n-        public Object call() {\n-          QueryService qs = null;\n-          try {\n-            qs = getCache().getQueryService();\n-            Index index = null;\n-            if (indexType.equals(\"compact\")) {\n-              index = qs.createIndex(\"newIndex\", \"ID\", \"/\" + regionName);\n-            } else if (indexType.equals(\"hash\")) {\n-              index = qs.createHashIndex(\"newIndex\", \"ID\", \"/\" + regionName);\n-            }\n-            assertNotNull(index);\n-            assertTrue(((CancelDuringGatherHook) DefaultQuery.testHook).triggeredOOME);\n-\n-            if (hitCriticalThreshold && !disabledQueryMonitorForLowMem) {\n-              throw new CacheException(\"Should have hit low memory\") {};\n-            }\n-            assertEquals(1, qs.getIndexes().size());\n-          } catch (Exception e) {\n-            if (e instanceof IndexInvalidException) {\n-              if (!hitCriticalThreshold || disabledQueryMonitorForLowMem) {\n-                throw new CacheException(\"Should not have run into low memory exception\") {};\n-              }\n-            } else {\n-              throw new CacheException(e) {};\n-            }\n-          }\n-          return 0;\n-        }\n-      });\n+      vmRecoversFromCriticalHeap(server1);\n     } finally {\n       stopServer(server1);\n       stopServer(server2);\n     }\n   }\n \n-  private void doCriticalMemoryHitAddResultsTestWithMultipleServers(final String regionName,\n-      boolean createPR,\n-      final int criticalThreshold,\n-      final boolean disabledQueryMonitorForLowMem,\n-      final int queryTimeout,\n-      final boolean hitCriticalThreshold)\n-      throws Exception {\n+  @Test\n+  public void testPRGatherCancellationWhileAddingResults() {\n     // create region on the server\n     final VM server1 = VM.getVM(0);\n     final VM server2 = VM.getVM(1);\n     final VM client = VM.getVM(2);\n     final int numObjects = 200;\n     try {\n       final int[] port = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n-      startCacheServer(server1, port[0], criticalThreshold, disabledQueryMonitorForLowMem,\n-          queryTimeout, regionName, createPR, 0);\n-      startCacheServer(server2, port[1], criticalThreshold, true, -1, regionName, createPR, 0);\n+      startCacheServer(server1, port[0], false,\n+          -1, true);\n+      startCacheServer(server2, port[1], true, -1, true);\n \n-      startClient(client, server1, port[0], regionName);\n-      populateData(server2, regionName, numObjects);\n+      startClient(client, port[0]);\n+      populateData(server2);\n \n       createCancelDuringAddResultsTestHook(server1);\n-      client.invoke(new SerializableCallable(\"executing query to be canceled during add results\") {\n-        @Override\n-        public Object call() {\n-          QueryService qs = null;\n-          try {\n-            qs = getCache().getQueryService();\n-            Query query = qs.newQuery(\"Select * From /\" + regionName);\n-            SelectResults results = (SelectResults) query.execute();\n-            if (hitCriticalThreshold && disabledQueryMonitorForLowMem == false) {\n-              throw new CacheException(\"should have hit low memory\") {};\n-            }\n-          } catch (Exception e) {\n-            handleException(e, hitCriticalThreshold, disabledQueryMonitorForLowMem, queryTimeout);\n-          }\n-          return 0;\n+      client.invoke(\"executing query to be canceled during add results\", () -> {\n+        QueryService qs;\n+        try {\n+          qs = getCache().getQueryService();\n+          Query query = qs.newQuery(\"Select * From /\" + \"portfolios\");\n+          query.execute();\n+          throw new CacheException(\"should have hit low memory\") {};\n+        } catch (Exception e) {\n+          handleException(e, true, false, -1);\n         }\n+        return 0;\n       });\n \n-      verifyRejectedObjects(server1, disabledQueryMonitorForLowMem, queryTimeout,\n-          hitCriticalThreshold);\n-      // Pause for a second and then let's recover\n-      try {\n-        Thread.sleep(1000);\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n+      verifyRejectedObjects(server1);\n \n       // Recover from critical heap\n-      if (hitCriticalThreshold) {\n-        vmRecoversFromCriticalHeap(server1);\n-      }\n+      vmRecoversFromCriticalHeap(server1);\n \n       // Check to see if query execution is ok under \"normal\" or \"healthy\" conditions\n-      client.invoke(new CacheSerializableRunnable(\"Executing query when system is 'Normal'\") {\n-        @Override\n-        public void run2() {\n-          try {\n-            QueryService qs = getCache().getQueryService();\n-            Query query = qs.newQuery(\"Select * From /\" + regionName);\n-            SelectResults results = (SelectResults) query.execute();\n-            assertEquals(numObjects, results.size());\n-          } catch (QueryInvocationTargetException e) {\n-            assertFalse(true);\n-          } catch (NameResolutionException e) {\n-            assertFalse(true);\n-          } catch (TypeMismatchException e) {\n-            assertFalse(true);\n-          } catch (FunctionDomainException e) {\n-            assertFalse(true);\n-          }\n+      client.invoke(\"Executing query when system is 'Normal'\", () -> {\n+        try {\n+          QueryService qs = getCache().getQueryService();\n+          Query query = qs.newQuery(\"Select * From /\" + \"portfolios\");\n+          SelectResults results = (SelectResults) query.execute();\n+          assertThat(results.size()).isEqualTo(numObjects);\n+        } catch (QueryInvocationTargetException | FunctionDomainException | TypeMismatchException\n+            | NameResolutionException e) {\n+          fail(\"\");\n         }\n       });\n \n       // Recover from critical heap\n-      if (hitCriticalThreshold) {\n-        vmRecoversFromCriticalHeap(server1);\n-      }\n+      vmRecoversFromCriticalHeap(server1);\n     } finally {\n       stopServer(server1);\n       stopServer(server2);\n     }\n   }\n \n-  // tests low memory hit while gathering partition region results\n-  private void doCriticalMemoryHitDuringGatherTestWithMultipleServers(final String regionName,\n-      boolean createPR,\n-      final int criticalThreshold,\n+  @Test\n+  public void testIndexCreationCancellationPR() {\n+    doCriticalMemoryHitWithIndexTest(true, false,\n+        \"compact\");\n+  }\n+\n+  @Test\n+  public void testIndexCreationCancellation() {\n+    doCriticalMemoryHitWithIndexTest(false, false,\n+        \"compact\");\n+  }\n+\n+  @Test\n+  public void testIndexCreationNoCancellationPR() {\n+    doCriticalMemoryHitWithIndexTest(true, true,\n+        \"compact\");\n+  }\n+\n+  @Test\n+  public void testHashIndexCreationCancellationPR() {\n+    doCriticalMemoryHitWithIndexTest(true, false,\n+        \"hash\");\n+  }\n+\n+  @Test\n+  public void testHashIndexCreationCancellation() {\n+    // need to add hook to canceled result set and very it is triggered for multiple servers\n+    doCriticalMemoryHitWithIndexTest(false, false,\n+        \"hash\");\n+  }\n+\n+  @Test\n+  public void testHashIndexCreationNoCancellationPR() {\n+    // need to add hook to canceled result set and very it is triggered for multiple servers\n+    doCriticalMemoryHitWithIndexTest(true, true,\n+        \"hash\");\n+  }\n+\n+  private void doCriticalMemoryHitTest(boolean createPR,\n       final boolean disabledQueryMonitorForLowMem,\n-      final int queryTimeout,\n-      final boolean hitCriticalThreshold)\n-      throws Exception {\n+      final int queryTimeout, final boolean hitCriticalThreshold) {\n     // create region on the server\n-    final VM server1 = VM.getVM(0);\n-    final VM server2 = VM.getVM(1);\n-    final VM client = VM.getVM(2);\n+    final VM server = VM.getVM(0);\n+    final VM client = VM.getVM(1);\n     final int numObjects = 200;\n     try {\n-      final int[] port = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n-      startCacheServer(server1, port[0], criticalThreshold, disabledQueryMonitorForLowMem,\n-          queryTimeout, regionName, createPR, 0);\n-      startCacheServer(server2, port[1], criticalThreshold, true, -1, regionName, createPR, 0);\n-\n-      startClient(client, server1, port[0], regionName);\n-      populateData(server2, regionName, numObjects);\n-\n-      createCancelDuringGatherTestHook(server1);\n-      client.invoke(new SerializableCallable(\"executing query to be canceled by gather\") {\n-        @Override\n-        public Object call() {\n-          QueryService qs = null;\n-          try {\n-            qs = getCache().getQueryService();\n-            Query query = qs.newQuery(\"Select * From /\" + regionName);\n-            query.execute();\n-          } catch (ServerOperationException soe) {\n-            if (soe.getRootCause() instanceof QueryException) {\n-              QueryException e = (QueryException) soe.getRootCause();\n-              if (!isExceptionDueToLowMemory(e, CRITICAL_HEAP_USED)) {\n-                throw new CacheException(soe) {};\n-              } else {\n-                return 0;\n-              }\n-            }\n-          } catch (Exception e) {\n-            throw new CacheException(e) {};\n-          }\n-          // assertTrue(((CancelDuringGatherHook)DefaultQuery.testHook).triggeredOOME);\n-          throw new CacheException(\"should have hit low memory\") {};\n-        }\n-      });\n+      final int port = AvailablePortHelper.getRandomAvailableTCPPort();\n+      startCacheServer(server, port, disabledQueryMonitorForLowMem, queryTimeout,\n+          createPR);\n \n-      verifyRejectedObjects(server1, disabledQueryMonitorForLowMem, queryTimeout,\n-          hitCriticalThreshold);\n-      // Pause for a second and then let's recover\n-      try {\n-        Thread.sleep(1000);\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n+      startClient(client, port);\n+      populateData(server);\n+\n+      doTestCriticalHeapAndQueryTimeout(server, client, disabledQueryMonitorForLowMem,\n+          queryTimeout, hitCriticalThreshold);\n \n       // Recover from critical heap\n       if (hitCriticalThreshold) {\n-        vmRecoversFromCriticalHeap(server1);\n+        vmRecoversFromCriticalHeap(server);\n+        await().until(() -> vmCheckCritcalHeap(server) == EVICTION_DISABLED);\n       }\n \n       // Check to see if query execution is ok under \"normal\" or \"healthy\" conditions\n-      client.invoke(new CacheSerializableRunnable(\"Executing query when system is 'Normal'\") {\n-        @Override\n-        public void run2() {\n-          try {\n-            QueryService qs = getCache().getQueryService();\n-            Query query = qs.newQuery(\"Select * From /\" + regionName);\n-            SelectResults results = (SelectResults) query.execute();\n-            assertEquals(numObjects, results.size());\n-          } catch (QueryInvocationTargetException e) {\n-            assertFalse(true);\n-          } catch (NameResolutionException e) {\n-            assertFalse(true);\n-          } catch (TypeMismatchException e) {\n-            assertFalse(true);\n-          } catch (FunctionDomainException e) {\n-            assertFalse(true);\n-          }\n+      client.invoke(\"Executing query when system is 'Normal'\", () -> {\n+        try {\n+          QueryService qs = getCache().getQueryService();\n+          Query query = qs.newQuery(\"Select * From /\" + \"portfolios\");\n+          SelectResults results = (SelectResults) query.execute();\n+          assertThat(results.size()).isEqualTo(numObjects);\n+        } catch (QueryInvocationTargetException | FunctionDomainException | TypeMismatchException", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40db9bd39c00a0468aa08ddc4541cd0d26d2f2b9"}, "originalPosition": 866}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MTk1OTE4OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMTo1Njo1OVrOFpAAwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxOToyMDoyNVrOFpgbOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzNjEzMA==", "bodyText": "Another catch-block to delete.", "url": "https://github.com/apache/geode/pull/4691#discussion_r378536130", "createdAt": "2020-02-12T21:56:59Z", "author": {"login": "kirklund"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "diffHunk": "@@ -134,606 +126,525 @@ public Object call() throws Exception {\n       irm.getHeapMonitor().setTestMaxMemoryBytes(0);\n       HeapMemoryMonitor.setTestDisableMemoryUpdates(false);\n       return null;\n-    }\n-  };\n-\n-  private SerializableCallable resetQueryMonitor = new SerializableCallable() {\n-    @Override\n-    public Object call() throws Exception {\n-      InternalCache cache = getCache();\n-      if (cache.getQueryMonitor() != null) {\n-        cache.getQueryMonitor().setLowMemory(false, 0);\n-      }\n-      DefaultQuery.testHook = null;\n-      return null;\n-    }\n-  };\n+    });\n+  }\n \n   @Test\n-  public void testRMAndNoTimeoutSet() throws Exception {\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSet() {\n+    doCriticalMemoryHitTest(false, false, -1, true);\n   }\n \n   @Test\n-  public void testRMAndNoTimeoutSetParReg() throws Exception {\n-    doCriticalMemoryHitTest(\"portfolios\", true, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSetParReg() {\n+    doCriticalMemoryHitTest(true, false, -1, true);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSet() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSet() {\n     // verify that timeout is not set and that a query can execute properly\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, -1, true);\n+    doCriticalMemoryHitTest(false, true, -1, true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSet() throws Exception {\n-    // verify that we still receive critical heap cancelation\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, TEST_QUERY_TIMEOUT,\n+  public void testRMAndTimeoutSet() {\n+    // verify that we still receive critical heap cancellation\n+    doCriticalMemoryHitTest(false, true, TEST_QUERY_TIMEOUT,\n         true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSetAndQueryTimesoutInstead() throws Exception {\n+  public void testRMAndTimeoutSetAndQueryTimeoutInstead() {\n     // verify that timeout is set correctly and cancel query\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, TEST_QUERY_TIMEOUT,\n+    doCriticalMemoryHitTest(false, true, TEST_QUERY_TIMEOUT,\n         false);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSet() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSet() {\n     // verify that timeout is still working properly\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, TEST_QUERY_TIMEOUT,\n+    doCriticalMemoryHitTest(false, true, TEST_QUERY_TIMEOUT,\n         true);\n   }\n \n   // Query directly on member with RM and QM set\n   @Test\n-  public void testRMAndNoTimeoutSetOnServer() throws Exception {\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSetOnServer() {\n+    doCriticalMemoryHitTestOnServer(false, false, -1, true);\n   }\n \n   // Query directly on member with RM and QM set\n   @Test\n-  public void whenTimeoutIsSetAndAQueryIsExecutedThenTimeoutMustStopTheQueryBeforeCriticalMemory()\n-      throws Exception {\n+  public void whenTimeoutIsSetAndAQueryIsExecutedThenTimeoutMustStopTheQueryBeforeCriticalMemory() {\n     // Timeout is set along with critical heap but it be called after the timeout expires\n     // Timeout is set to 1ms which is very unrealistic time period for a query to be able to fetch\n     // 200 entries from the region successfully, hence a timeout is expected.\n-    executeQueryWithTimeoutSetAndCriticalThreshold(\"portfolios\", false, 85/* crit threshold */,\n-        false, 1, true);\n+    // create region on the server\n+    final VM server = VM.getVM(0);\n+    try {\n+      final int port = AvailablePortHelper.getRandomAvailableTCPPort();\n+      startCacheServer(server, port, false, 1,\n+          false);\n+      populateData(server);\n+      executeQueryWithCriticalHeapCalledAfterTimeout(server, server);\n+      vmRecoversFromCriticalHeap(server);\n+\n+    } finally {\n+      stopServer(server);\n+    }\n   }\n \n   @Test\n-  public void whenTimeoutIsSetAndAQueryIsExecutedFromClientThenTimeoutMustStopTheQueryBeforeCriticalMemory()\n-      throws Exception {\n+  public void whenTimeoutIsSetAndAQueryIsExecutedFromClientThenTimeoutMustStopTheQueryBeforeCriticalMemory() {\n     // Timeout is set along with critical heap but it be called after the timeout expires\n     // Timeout is set to 1ms which is very unrealistic time period for a query to be able to fetch\n     // 200 entries from the region successfully, hence a timeout is expected.\n-    executeQueryFromClientWithTimeoutSetAndCriticalThreshold(\"portfolios\", false,\n-        85/* crit threshold */, false, 1, true);\n+    // create region on the server\n+    final VM server = VM.getVM(0);\n+    final VM client = VM.getVM(1);\n+    try {\n+      final int port = AvailablePortHelper.getRandomAvailableTCPPort();\n+      startCacheServer(server, port, false, 1,\n+          false);\n+      startClient(client, port);\n+      populateData(server);\n+      executeQueryWithCriticalHeapCalledAfterTimeout(server, client);\n+      vmRecoversFromCriticalHeap(server);\n+\n+    } finally {\n+      stopServer(server);\n+    }\n   }\n \n   @Test\n-  public void testRMAndNoTimeoutSetParRegOnServer() throws Exception {\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", true, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSetParRegOnServer() {\n+    doCriticalMemoryHitTestOnServer(true, false, -1, true);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSetOnServer() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSetOnServer() {\n     // verify that timeout is not set and that a query can execute properly\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true, -1, true);\n+    doCriticalMemoryHitTestOnServer(false, true, -1, true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSetOnServer() throws Exception {\n-    // verify that we still receive critical heap cancelation\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true,\n+  public void testRMAndTimeoutSetOnServer() {\n+    // verify that we still receive critical heap cancellation\n+    doCriticalMemoryHitTestOnServer(false, true,\n         TEST_QUERY_TIMEOUT, true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSetAndQueryTimesoutInsteadOnServer() throws Exception {\n+  public void testRMAndTimeoutSetAndQueryTimeoutInsteadOnServer() {\n     // verify that timeout is set correctly and cancel query\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true,\n+    doCriticalMemoryHitTestOnServer(false, true,\n         TEST_QUERY_TIMEOUT, false);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSetOnServer() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSetOnServer() {\n     // verify that timeout is still working properly\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true,\n+    doCriticalMemoryHitTestOnServer(false, true,\n         TEST_QUERY_TIMEOUT, true);\n   }\n \n   @Test\n-  public void testPRGatherCancellation() throws Exception {\n-    doCriticalMemoryHitTestWithMultipleServers(\"portfolios\", true, 85/* crit threshold */, false,\n-        -1, true);\n-  }\n-\n-  @Test\n-  public void testPRGatherCancellationWhileGatheringResults() throws Exception {\n-    doCriticalMemoryHitDuringGatherTestWithMultipleServers(\"portfolios\", true,\n-        85/* crit threshold */, false, -1, true);\n-  }\n+  public void testPRGatherCancellation() throws Throwable {\n+    // create region on the server\n+    final VM server1 = VM.getVM(0);\n+    final VM server2 = VM.getVM(1);\n+    final VM client = VM.getVM(2);\n+    final int numObjects = 200;\n+    final VM controller = VM.getController();\n+    try {\n+      final int[] port = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n+      startCacheServer(server1, port[0], false,\n+          -1, true);\n+      startCacheServer(server2, port[1], true, -1, true);\n+\n+      startClient(client, port[0]);\n+      populateData(server2);\n+      server1.invoke(\"create latch test Hook\", () -> {\n+        DefaultQuery.testHook = getPauseHook(true, controller);\n+      });\n+      // remove from here to ....\n+      AsyncInvocation queryExecution1 = executeQueryOnClient(client);\n \n-  @Test\n-  public void testPRGatherCancellationWhileAddingResults() throws Exception {\n-    doCriticalMemoryHitAddResultsTestWithMultipleServers(\"portfolios\", true, 85/* crit threshold */,\n-        false, -1, true);\n-  }\n+      // Gives async invocation a chance to start\n+      Thread.sleep(1000);\n+      // We simulate a low memory/critical heap percentage hit\n+      setHeapToCriticalAndReleaseLatch(server1);\n+      assertThat(queryExecution1.get(60, SECONDS)).isEqualTo(0);\n+      verifyDroppedObjectsAndSetHeapToNormal(server1);\n \n-  @Test\n-  public void testIndexCreationCancellationPR() throws Exception {\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", true, 85/* crit threshold */, false, -1, true,\n-        \"compact\");\n-  }\n+      // to here....\n+      // Check to see if query execution is ok under \"normal\" or \"healthy\" conditions\n+      client.invoke(\"Executing query when system is 'Normal'\", () -> {\n+        try {\n+          Query query = getCache().getQueryService().newQuery(\"Select * From /\" + \"portfolios\");\n+          SelectResults results = (SelectResults) query.execute();\n+          assertThat(results.size()).isEqualTo(numObjects);\n+        } catch (QueryInvocationTargetException | FunctionDomainException | TypeMismatchException\n+            | NameResolutionException e) {\n+          fail(\"\");\n+        }\n+      });\n+      // We simulate a low memory/critical heap percentage hit\n+      setHeapToCriticalAndReleaseLatch(server1);\n+      AsyncInvocation queryExecution = executeQueryOnClient(client);\n+      assertThat(queryExecution.get(60, SECONDS)).isEqualTo(0);\n+      verifyDroppedObjectsAndSetHeapToNormal(server1);\n \n-  @Test\n-  public void testIndexCreationCancellation() throws Exception {\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", false, 85/* crit threshold */, false, -1, true,\n-        \"compact\");\n+    } finally {\n+      stopServer(server1);\n+      stopServer(server2);\n+    }\n   }\n \n-  @Test\n-  public void testIndexCreationNoCancellationPR() throws Exception {\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", true, 85/* crit threshold */, true, -1, true,\n-        \"compact\");\n+  private AsyncInvocation executeQueryOnClient(VM client) {\n+    return client.invokeAsync(\"execute query from client\", () -> {\n+      try {\n+        Query query1 = getCache().getQueryService().newQuery(\"Select * From /\" + \"portfolios\");\n+        query1.execute();\n+        throw new CacheException(\"Exception should have been thrown due to low memory\") {};\n+      } catch (Exception e2) {\n+        handleException(e2, true, false, -1);\n+      }\n+      return 0;\n+    });\n   }\n \n-  @Test\n-  public void testHashIndexCreationCancellationPR() throws Exception {\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", true, 85/* crit threshold */, false, -1, true,\n-        \"hash\");\n+  private void setHeapToCriticalAndReleaseLatch(VM server1) {\n+    server1.invoke(\"vm hits critical heap and counts down latch.\", () -> {\n+      InternalResourceManager resourceManager =\n+          (InternalResourceManager) getCache().getResourceManager();\n+      resourceManager.getHeapMonitor().updateStateAndSendEvent(CRITICAL_HEAP_USED, \"test\");\n+      await()\n+          .until(() -> resourceManager.getHeapMonitor().getState() == EVICTION_DISABLED_CRITICAL);\n+      Thread.sleep(MAX_TEST_QUERY_TIMEOUT);\n+      // release the hook to have the query throw either a low memory or query timeout\n+      // unless otherwise configured\n+      PauseTestHook hook = (PauseTestHook) DefaultQuery.testHook;\n+      hook.countDown();\n+    });\n   }\n \n-  @Test\n-  public void testHashIndexCreationCancellation() throws Exception {\n-    // need to add hook to canceled result set and very it is triggered for multiple servers\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", false, 85/* crit threshold */, false, -1, true,\n-        \"hash\");\n+  private void verifyDroppedObjectsAndSetHeapToNormal(VM server1) {\n+    server1.invoke(\"verify dropped objects\", () -> {\n+      if (DefaultQuery.testHook instanceof RejectedObjectsInterface) {\n+        RejectedObjectsInterface rejectedObjectsInterface =\n+            (RejectedObjectsInterface) DefaultQuery.testHook;\n+        await()\n+            .untilAsserted(() -> assertThat(rejectedObjectsInterface.rejectedObjects).isTrue());\n+      }\n+      InternalResourceManager resourceManager =\n+          (InternalResourceManager) getCache().getResourceManager();\n+      resourceManager.getHeapMonitor().updateStateAndSendEvent(NORMAL_HEAP_USED, \"test\");\n+      await().until(() -> resourceManager.getHeapMonitor().getState() == EVICTION_DISABLED);\n+    });\n   }\n \n   @Test\n-  public void testHashIndexCreationNoCancellationPR() throws Exception {\n-    // need to add hook to canceled result set and very it is triggered for multiple servers\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", true, 85/* crit threshold */, true, -1, true,\n-        \"hash\");\n-  }\n-\n-  private void doCriticalMemoryHitTest(final String regionName, boolean createPR,\n-      final int criticalThreshold,\n-      final boolean disabledQueryMonitorForLowMem,\n-      final int queryTimeout, final boolean hitCriticalThreshold)\n-      throws Exception {\n+  public void testPRGatherCancellationWhileGatheringResults() {\n     // create region on the server\n-    final VM server = VM.getVM(0);\n-    final VM client = VM.getVM(1);\n+    final VM server1 = VM.getVM(0);\n+    final VM server2 = VM.getVM(1);\n+    final VM client = VM.getVM(2);\n     final int numObjects = 200;\n     try {\n-      final int port = AvailablePortHelper.getRandomAvailableTCPPort();\n-      startCacheServer(server, port, criticalThreshold, disabledQueryMonitorForLowMem, queryTimeout,\n-          regionName, createPR, 0);\n+      final int[] port = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n+      startCacheServer(server1, port[0], false,\n+          -1, true);\n+      startCacheServer(server2, port[1], true, -1, true);\n \n-      startClient(client, server, port, regionName);\n-      populateData(server, regionName, numObjects);\n+      startClient(client, port[0]);\n+      populateData(server2);\n \n-      doTestCriticalHeapAndQueryTimeout(server, client, regionName, disabledQueryMonitorForLowMem,\n-          queryTimeout, hitCriticalThreshold);\n+      createCancelDuringGatherTestHook(server1, VM.getController());\n+      client.invoke(\"executing query to be canceled by gather\", () -> {\n+        QueryService qs;\n+        try {\n+          qs = getCache().getQueryService();\n+          Query query = qs.newQuery(\"Select * From /\" + \"portfolios\");\n+          query.execute();\n+        } catch (ServerOperationException soe) {\n+          if (soe.getRootCause() instanceof QueryException) {\n+            QueryException e = (QueryException) soe.getRootCause();\n+            if (!isExceptionDueToLowMemory(e)) {\n+              throw new CacheException(soe) {};\n+            } else {\n+              return 0;\n+            }\n+          }\n+        } catch (Exception e) {\n+          throw new CacheException(e) {};\n+        }\n+        // assertTrue(((CancelDuringGatherHook)DefaultQuery.testHook).triggeredOOME);\n+        throw new CacheException(\"should have hit low memory\") {};\n+      });\n \n-      // Pause for a second and then let's recover\n-      try {\n-        Thread.sleep(1000);\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n+      verifyRejectedObjects(server1);\n \n       // Recover from critical heap\n-      if (hitCriticalThreshold) {\n-        vmRecoversFromCriticalHeap(server);\n-      }\n+      vmRecoversFromCriticalHeap(server1);\n \n       // Check to see if query execution is ok under \"normal\" or \"healthy\" conditions\n-      client.invoke(new CacheSerializableRunnable(\"Executing query when system is 'Normal'\") {\n-        @Override\n-        public void run2() {\n-          try {\n-            QueryService qs = getCache().getQueryService();\n-            Query query = qs.newQuery(\"Select * From /\" + regionName);\n-            SelectResults results = (SelectResults) query.execute();\n-            assertEquals(numObjects, results.size());\n-          } catch (QueryInvocationTargetException e) {\n-            assertFalse(true);\n-          } catch (NameResolutionException e) {\n-            assertFalse(true);\n-          } catch (TypeMismatchException e) {\n-            assertFalse(true);\n-          } catch (FunctionDomainException e) {\n-            assertFalse(true);\n-          }\n+      client.invoke(\"Executing query when system is 'Normal'\", () -> {\n+        try {\n+          QueryService qs = getCache().getQueryService();\n+          Query query = qs.newQuery(\"Select * From /\" + \"portfolios\");\n+          SelectResults results = (SelectResults) query.execute();\n+          assertThat(results.size()).isEqualTo(numObjects);\n+        } catch (QueryInvocationTargetException | FunctionDomainException | TypeMismatchException\n+            | NameResolutionException e) {\n+          fail(\"\");\n         }\n       });\n \n-      // Execute a critical heap event/ query timeout test again\n-      doTestCriticalHeapAndQueryTimeout(server, client, regionName, disabledQueryMonitorForLowMem,\n-          queryTimeout, hitCriticalThreshold);\n       // Recover from critical heap\n-      if (hitCriticalThreshold) {\n-        vmRecoversFromCriticalHeap(server);\n-      }\n-    } finally {\n-      stopServer(server);\n-    }\n-  }\n-\n-  // test to verify what happens during index creation if memory threshold is hit\n-  private void doCriticalMemoryHitWithIndexTest(final String regionName, boolean createPR,\n-      final int criticalThreshold,\n-      final boolean disabledQueryMonitorForLowMem,\n-      final int queryTimeout,\n-      final boolean hitCriticalThreshold,\n-      final String indexType)\n-      throws Exception {\n-    // create region on the server\n-    final VM server1 = VM.getVM(0);\n-    final VM server2 = VM.getVM(2);\n-    final VM client = VM.getVM(1);\n-    final int numObjects = 200;\n-    try {\n-      final int[] port = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n-      startCacheServer(server1, port[0], criticalThreshold, disabledQueryMonitorForLowMem,\n-          queryTimeout, regionName, createPR, 0);\n-      startCacheServer(server2, port[1], criticalThreshold, true, -1, regionName, createPR, 0);\n-\n-      startClient(client, server1, port[0], regionName);\n-      populateData(server1, regionName, numObjects);\n-\n-      createCancelDuringGatherTestHook(server1);\n-      server1.invoke(new SerializableCallable(\"create index\") {\n-        @Override\n-        public Object call() {\n-          QueryService qs = null;\n-          try {\n-            qs = getCache().getQueryService();\n-            Index index = null;\n-            if (indexType.equals(\"compact\")) {\n-              index = qs.createIndex(\"newIndex\", \"ID\", \"/\" + regionName);\n-            } else if (indexType.equals(\"hash\")) {\n-              index = qs.createHashIndex(\"newIndex\", \"ID\", \"/\" + regionName);\n-            }\n-            assertNotNull(index);\n-            assertTrue(((CancelDuringGatherHook) DefaultQuery.testHook).triggeredOOME);\n-\n-            if (hitCriticalThreshold && !disabledQueryMonitorForLowMem) {\n-              throw new CacheException(\"Should have hit low memory\") {};\n-            }\n-            assertEquals(1, qs.getIndexes().size());\n-          } catch (Exception e) {\n-            if (e instanceof IndexInvalidException) {\n-              if (!hitCriticalThreshold || disabledQueryMonitorForLowMem) {\n-                throw new CacheException(\"Should not have run into low memory exception\") {};\n-              }\n-            } else {\n-              throw new CacheException(e) {};\n-            }\n-          }\n-          return 0;\n-        }\n-      });\n+      vmRecoversFromCriticalHeap(server1);\n     } finally {\n       stopServer(server1);\n       stopServer(server2);\n     }\n   }\n \n-  private void doCriticalMemoryHitAddResultsTestWithMultipleServers(final String regionName,\n-      boolean createPR,\n-      final int criticalThreshold,\n-      final boolean disabledQueryMonitorForLowMem,\n-      final int queryTimeout,\n-      final boolean hitCriticalThreshold)\n-      throws Exception {\n+  @Test\n+  public void testPRGatherCancellationWhileAddingResults() {\n     // create region on the server\n     final VM server1 = VM.getVM(0);\n     final VM server2 = VM.getVM(1);\n     final VM client = VM.getVM(2);\n     final int numObjects = 200;\n     try {\n       final int[] port = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n-      startCacheServer(server1, port[0], criticalThreshold, disabledQueryMonitorForLowMem,\n-          queryTimeout, regionName, createPR, 0);\n-      startCacheServer(server2, port[1], criticalThreshold, true, -1, regionName, createPR, 0);\n+      startCacheServer(server1, port[0], false,\n+          -1, true);\n+      startCacheServer(server2, port[1], true, -1, true);\n \n-      startClient(client, server1, port[0], regionName);\n-      populateData(server2, regionName, numObjects);\n+      startClient(client, port[0]);\n+      populateData(server2);\n \n       createCancelDuringAddResultsTestHook(server1);\n-      client.invoke(new SerializableCallable(\"executing query to be canceled during add results\") {\n-        @Override\n-        public Object call() {\n-          QueryService qs = null;\n-          try {\n-            qs = getCache().getQueryService();\n-            Query query = qs.newQuery(\"Select * From /\" + regionName);\n-            SelectResults results = (SelectResults) query.execute();\n-            if (hitCriticalThreshold && disabledQueryMonitorForLowMem == false) {\n-              throw new CacheException(\"should have hit low memory\") {};\n-            }\n-          } catch (Exception e) {\n-            handleException(e, hitCriticalThreshold, disabledQueryMonitorForLowMem, queryTimeout);\n-          }\n-          return 0;\n+      client.invoke(\"executing query to be canceled during add results\", () -> {\n+        QueryService qs;\n+        try {\n+          qs = getCache().getQueryService();\n+          Query query = qs.newQuery(\"Select * From /\" + \"portfolios\");\n+          query.execute();\n+          throw new CacheException(\"should have hit low memory\") {};\n+        } catch (Exception e) {\n+          handleException(e, true, false, -1);\n         }\n+        return 0;\n       });\n \n-      verifyRejectedObjects(server1, disabledQueryMonitorForLowMem, queryTimeout,\n-          hitCriticalThreshold);\n-      // Pause for a second and then let's recover\n-      try {\n-        Thread.sleep(1000);\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n+      verifyRejectedObjects(server1);\n \n       // Recover from critical heap\n-      if (hitCriticalThreshold) {\n-        vmRecoversFromCriticalHeap(server1);\n-      }\n+      vmRecoversFromCriticalHeap(server1);\n \n       // Check to see if query execution is ok under \"normal\" or \"healthy\" conditions\n-      client.invoke(new CacheSerializableRunnable(\"Executing query when system is 'Normal'\") {\n-        @Override\n-        public void run2() {\n-          try {\n-            QueryService qs = getCache().getQueryService();\n-            Query query = qs.newQuery(\"Select * From /\" + regionName);\n-            SelectResults results = (SelectResults) query.execute();\n-            assertEquals(numObjects, results.size());\n-          } catch (QueryInvocationTargetException e) {\n-            assertFalse(true);\n-          } catch (NameResolutionException e) {\n-            assertFalse(true);\n-          } catch (TypeMismatchException e) {\n-            assertFalse(true);\n-          } catch (FunctionDomainException e) {\n-            assertFalse(true);\n-          }\n+      client.invoke(\"Executing query when system is 'Normal'\", () -> {\n+        try {\n+          QueryService qs = getCache().getQueryService();\n+          Query query = qs.newQuery(\"Select * From /\" + \"portfolios\");\n+          SelectResults results = (SelectResults) query.execute();\n+          assertThat(results.size()).isEqualTo(numObjects);\n+        } catch (QueryInvocationTargetException | FunctionDomainException | TypeMismatchException\n+            | NameResolutionException e) {\n+          fail(\"\");\n         }\n       });\n \n       // Recover from critical heap\n-      if (hitCriticalThreshold) {\n-        vmRecoversFromCriticalHeap(server1);\n-      }\n+      vmRecoversFromCriticalHeap(server1);\n     } finally {\n       stopServer(server1);\n       stopServer(server2);\n     }\n   }\n \n-  // tests low memory hit while gathering partition region results\n-  private void doCriticalMemoryHitDuringGatherTestWithMultipleServers(final String regionName,\n-      boolean createPR,\n-      final int criticalThreshold,\n+  @Test\n+  public void testIndexCreationCancellationPR() {\n+    doCriticalMemoryHitWithIndexTest(true, false,\n+        \"compact\");\n+  }\n+\n+  @Test\n+  public void testIndexCreationCancellation() {\n+    doCriticalMemoryHitWithIndexTest(false, false,\n+        \"compact\");\n+  }\n+\n+  @Test\n+  public void testIndexCreationNoCancellationPR() {\n+    doCriticalMemoryHitWithIndexTest(true, true,\n+        \"compact\");\n+  }\n+\n+  @Test\n+  public void testHashIndexCreationCancellationPR() {\n+    doCriticalMemoryHitWithIndexTest(true, false,\n+        \"hash\");\n+  }\n+\n+  @Test\n+  public void testHashIndexCreationCancellation() {\n+    // need to add hook to canceled result set and very it is triggered for multiple servers\n+    doCriticalMemoryHitWithIndexTest(false, false,\n+        \"hash\");\n+  }\n+\n+  @Test\n+  public void testHashIndexCreationNoCancellationPR() {\n+    // need to add hook to canceled result set and very it is triggered for multiple servers\n+    doCriticalMemoryHitWithIndexTest(true, true,\n+        \"hash\");\n+  }\n+\n+  private void doCriticalMemoryHitTest(boolean createPR,\n       final boolean disabledQueryMonitorForLowMem,\n-      final int queryTimeout,\n-      final boolean hitCriticalThreshold)\n-      throws Exception {\n+      final int queryTimeout, final boolean hitCriticalThreshold) {\n     // create region on the server\n-    final VM server1 = VM.getVM(0);\n-    final VM server2 = VM.getVM(1);\n-    final VM client = VM.getVM(2);\n+    final VM server = VM.getVM(0);\n+    final VM client = VM.getVM(1);\n     final int numObjects = 200;\n     try {\n-      final int[] port = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n-      startCacheServer(server1, port[0], criticalThreshold, disabledQueryMonitorForLowMem,\n-          queryTimeout, regionName, createPR, 0);\n-      startCacheServer(server2, port[1], criticalThreshold, true, -1, regionName, createPR, 0);\n-\n-      startClient(client, server1, port[0], regionName);\n-      populateData(server2, regionName, numObjects);\n-\n-      createCancelDuringGatherTestHook(server1);\n-      client.invoke(new SerializableCallable(\"executing query to be canceled by gather\") {\n-        @Override\n-        public Object call() {\n-          QueryService qs = null;\n-          try {\n-            qs = getCache().getQueryService();\n-            Query query = qs.newQuery(\"Select * From /\" + regionName);\n-            query.execute();\n-          } catch (ServerOperationException soe) {\n-            if (soe.getRootCause() instanceof QueryException) {\n-              QueryException e = (QueryException) soe.getRootCause();\n-              if (!isExceptionDueToLowMemory(e, CRITICAL_HEAP_USED)) {\n-                throw new CacheException(soe) {};\n-              } else {\n-                return 0;\n-              }\n-            }\n-          } catch (Exception e) {\n-            throw new CacheException(e) {};\n-          }\n-          // assertTrue(((CancelDuringGatherHook)DefaultQuery.testHook).triggeredOOME);\n-          throw new CacheException(\"should have hit low memory\") {};\n-        }\n-      });\n+      final int port = AvailablePortHelper.getRandomAvailableTCPPort();\n+      startCacheServer(server, port, disabledQueryMonitorForLowMem, queryTimeout,\n+          createPR);\n \n-      verifyRejectedObjects(server1, disabledQueryMonitorForLowMem, queryTimeout,\n-          hitCriticalThreshold);\n-      // Pause for a second and then let's recover\n-      try {\n-        Thread.sleep(1000);\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n+      startClient(client, port);\n+      populateData(server);\n+\n+      doTestCriticalHeapAndQueryTimeout(server, client, disabledQueryMonitorForLowMem,\n+          queryTimeout, hitCriticalThreshold);\n \n       // Recover from critical heap\n       if (hitCriticalThreshold) {\n-        vmRecoversFromCriticalHeap(server1);\n+        vmRecoversFromCriticalHeap(server);\n+        await().until(() -> vmCheckCritcalHeap(server) == EVICTION_DISABLED);\n       }\n \n       // Check to see if query execution is ok under \"normal\" or \"healthy\" conditions\n-      client.invoke(new CacheSerializableRunnable(\"Executing query when system is 'Normal'\") {\n-        @Override\n-        public void run2() {\n-          try {\n-            QueryService qs = getCache().getQueryService();\n-            Query query = qs.newQuery(\"Select * From /\" + regionName);\n-            SelectResults results = (SelectResults) query.execute();\n-            assertEquals(numObjects, results.size());\n-          } catch (QueryInvocationTargetException e) {\n-            assertFalse(true);\n-          } catch (NameResolutionException e) {\n-            assertFalse(true);\n-          } catch (TypeMismatchException e) {\n-            assertFalse(true);\n-          } catch (FunctionDomainException e) {\n-            assertFalse(true);\n-          }\n+      client.invoke(\"Executing query when system is 'Normal'\", () -> {\n+        try {\n+          QueryService qs = getCache().getQueryService();\n+          Query query = qs.newQuery(\"Select * From /\" + \"portfolios\");\n+          SelectResults results = (SelectResults) query.execute();\n+          assertThat(results.size()).isEqualTo(numObjects);\n+        } catch (QueryInvocationTargetException | FunctionDomainException | TypeMismatchException\n+            | NameResolutionException e) {\n+          fail(\"\");\n         }\n       });\n \n+      // Execute a critical heap event/ query timeout test again\n+      doTestCriticalHeapAndQueryTimeout(server, client, disabledQueryMonitorForLowMem,\n+          queryTimeout, hitCriticalThreshold);\n       // Recover from critical heap\n       if (hitCriticalThreshold) {\n-        vmRecoversFromCriticalHeap(server1);\n+        vmRecoversFromCriticalHeap(server);\n+        await().until(() -> vmCheckCritcalHeap(server) == EVICTION_DISABLED);\n       }\n     } finally {\n-      stopServer(server1);\n-      stopServer(server2);\n+      stopServer(server);\n     }\n   }\n \n-  // Executes on client cache with multiple configured servers\n-  private void doCriticalMemoryHitTestWithMultipleServers(final String regionName, boolean createPR,\n-      final int criticalThreshold,\n+  // test to verify what happens during index creation if memory threshold is hit\n+  private void doCriticalMemoryHitWithIndexTest(boolean createPR,\n       final boolean disabledQueryMonitorForLowMem,\n-      final int queryTimeout,\n-      final boolean hitCriticalThreshold)\n-      throws Exception {\n+      final String indexType) {\n     // create region on the server\n     final VM server1 = VM.getVM(0);\n-    final VM server2 = VM.getVM(1);\n-    final VM client = VM.getVM(2);\n-    final int numObjects = 200;\n+    final VM server2 = VM.getVM(2);\n+    final VM client = VM.getVM(1);\n \n     try {\n       final int[] port = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n-      startCacheServer(server1, port[0], criticalThreshold, disabledQueryMonitorForLowMem,\n-          queryTimeout, regionName, createPR, 0);\n-      startCacheServer(server2, port[1], criticalThreshold, true, -1, regionName, createPR, 0);\n+      startCacheServer(server1, port[0], disabledQueryMonitorForLowMem,\n+          -1, createPR);\n+      startCacheServer(server2, port[1], true, -1, createPR);\n \n-      startClient(client, server1, port[0], regionName);\n-      populateData(server2, regionName, numObjects);\n+      startClient(client, port[0]);\n+      populateData(server1);\n \n-      doTestCriticalHeapAndQueryTimeout(server1, client, regionName, disabledQueryMonitorForLowMem,\n-          queryTimeout, hitCriticalThreshold);\n-      verifyRejectedObjects(server1, disabledQueryMonitorForLowMem, queryTimeout,\n-          hitCriticalThreshold);\n-      // Pause for a second and then let's recover\n-      try {\n-        Thread.sleep(1000);\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n-\n-      // Recover from critical heap\n-      if (hitCriticalThreshold) {\n-        vmRecoversFromCriticalHeap(server1);\n-      }\n+      createCancelDuringGatherTestHook(server1, VM.getController());\n+      server1.invoke(\"create index\", () -> {\n+        QueryService qs;\n+        try {\n+          qs = getCache().getQueryService();\n+          Index index = null;\n+          if (indexType.equals(\"compact\")) {\n+            index = qs.createIndex(\"newIndex\", \"ID\", \"/\" + \"portfolios\");\n+          } else if (indexType.equals(\"hash\")) {\n+            index = qs.createIndex(\"newIndex\", \"ID\", \"/\" + \"portfolios\");\n+          }\n+          assertThat(index).isNotNull();\n+          assertThat(((CancelDuringGatherHook) DefaultQuery.testHook).triggeredOOME).isTrue();\n \n-      // Check to see if query execution is ok under \"normal\" or \"healthy\" conditions\n-      client.invoke(new CacheSerializableRunnable(\"Executing query when system is 'Normal'\") {\n-        @Override\n-        public void run2() {\n-          try {\n-            QueryService qs = getCache().getQueryService();\n-            Query query = qs.newQuery(\"Select * From /\" + regionName);\n-            SelectResults results = (SelectResults) query.execute();\n-            assertEquals(numObjects, results.size());\n-          } catch (QueryInvocationTargetException e) {\n-            assertFalse(true);\n-          } catch (NameResolutionException e) {\n-            assertFalse(true);\n-          } catch (TypeMismatchException e) {\n-            assertFalse(true);\n-          } catch (FunctionDomainException e) {\n-            assertFalse(true);\n+          if (!disabledQueryMonitorForLowMem) {\n+            throw new CacheException(\"Should have hit low memory\") {};\n+          }\n+          assertThat(qs.getIndexes().size()).isEqualTo(1);\n+        } catch (Exception e) {\n+          if (e instanceof IndexInvalidException) {\n+            if (disabledQueryMonitorForLowMem) {\n+              throw new CacheException(\"Should not have run into low memory exception\") {};\n+            }\n+          } else {\n+            throw new CacheException(e) {};\n           }\n         }\n+        return 0;\n       });\n-\n-      // Execute a critical heap event/ query timeout test again\n-      doTestCriticalHeapAndQueryTimeout(server1, client, regionName, disabledQueryMonitorForLowMem,\n-          queryTimeout, hitCriticalThreshold);\n-      verifyRejectedObjects(server1, disabledQueryMonitorForLowMem, queryTimeout,\n-          hitCriticalThreshold);\n-      // Recover from critical heap\n-      if (hitCriticalThreshold) {\n-        vmRecoversFromCriticalHeap(server1);\n-      }\n     } finally {\n       stopServer(server1);\n       stopServer(server2);\n     }\n   }\n \n+  private static CountDownLatch criticalMemoryCountDownLatch;\n+\n   // Executes the query on the server with the RM and QM configured\n-  private void doCriticalMemoryHitTestOnServer(final String regionName, boolean createPR,\n-      final int criticalThreshold,\n+  private void doCriticalMemoryHitTestOnServer(boolean createPR,\n       final boolean disabledQueryMonitorForLowMem,\n       final int queryTimeout,\n-      final boolean hitCriticalThreshold)\n-      throws Exception {\n+      final boolean hitCriticalThreshold) {\n     // create region on the server\n     final VM server = VM.getVM(0);\n     final int numObjects = 200;\n     try {\n       final int port = AvailablePortHelper.getRandomAvailableTCPPort();\n-      startCacheServer(server, port, criticalThreshold, disabledQueryMonitorForLowMem, queryTimeout,\n-          regionName, createPR, 0);\n+      startCacheServer(server, port, disabledQueryMonitorForLowMem, queryTimeout,\n+          createPR);\n \n-      // startPeerClient(client, server, port, regionName);\n-      populateData(server, regionName, numObjects);\n+      populateData(server);\n \n-      doTestCriticalHeapAndQueryTimeout(server, server, regionName, disabledQueryMonitorForLowMem,\n+      doTestCriticalHeapAndQueryTimeout(server, server, disabledQueryMonitorForLowMem,\n           queryTimeout, hitCriticalThreshold);\n \n-      // Pause for a second and then let's recover\n-      try {\n-        Thread.sleep(1000);\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n-\n       // Recover from critical heap\n       if (hitCriticalThreshold) {\n         vmRecoversFromCriticalHeap(server);\n       }\n \n       // Check to see if query execution is ok under \"normal\" or \"healthy\" conditions\n-      server.invoke(new CacheSerializableRunnable(\"Executing query when system is 'Normal'\") {\n-        @Override\n-        public void run2() {\n-          try {\n-            QueryService qs = getCache().getQueryService();\n-            Query query = qs.newQuery(\"Select * From /\" + regionName);\n-            SelectResults results = (SelectResults) query.execute();\n-            assertEquals(numObjects, results.size());\n-          } catch (QueryInvocationTargetException e) {\n-            assertFalse(true);\n-          } catch (NameResolutionException e) {\n-            assertFalse(true);\n-          } catch (TypeMismatchException e) {\n-            assertFalse(true);\n-          } catch (FunctionDomainException e) {\n-            assertFalse(true);\n-          }\n+      server.invoke(\"Executing query when system is 'Normal'\", () -> {\n+        try {\n+          QueryService qs = getCache().getQueryService();\n+          Query query = qs.newQuery(\"Select * From /\" + \"portfolios\");\n+          SelectResults results = (SelectResults) query.execute();\n+          assertThat(results.size()).isEqualTo(numObjects);\n+        } catch (QueryInvocationTargetException | FunctionDomainException | TypeMismatchException", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40db9bd39c00a0468aa08ddc4541cd0d26d2f2b9"}, "originalPosition": 1062}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA2NzE5Mw==", "bodyText": "Done.", "url": "https://github.com/apache/geode/pull/4691#discussion_r379067193", "createdAt": "2020-02-13T19:20:25Z", "author": {"login": "mhansonp"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "diffHunk": "@@ -134,606 +126,525 @@ public Object call() throws Exception {\n       irm.getHeapMonitor().setTestMaxMemoryBytes(0);\n       HeapMemoryMonitor.setTestDisableMemoryUpdates(false);\n       return null;\n-    }\n-  };\n-\n-  private SerializableCallable resetQueryMonitor = new SerializableCallable() {\n-    @Override\n-    public Object call() throws Exception {\n-      InternalCache cache = getCache();\n-      if (cache.getQueryMonitor() != null) {\n-        cache.getQueryMonitor().setLowMemory(false, 0);\n-      }\n-      DefaultQuery.testHook = null;\n-      return null;\n-    }\n-  };\n+    });\n+  }\n \n   @Test\n-  public void testRMAndNoTimeoutSet() throws Exception {\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSet() {\n+    doCriticalMemoryHitTest(false, false, -1, true);\n   }\n \n   @Test\n-  public void testRMAndNoTimeoutSetParReg() throws Exception {\n-    doCriticalMemoryHitTest(\"portfolios\", true, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSetParReg() {\n+    doCriticalMemoryHitTest(true, false, -1, true);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSet() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSet() {\n     // verify that timeout is not set and that a query can execute properly\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, -1, true);\n+    doCriticalMemoryHitTest(false, true, -1, true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSet() throws Exception {\n-    // verify that we still receive critical heap cancelation\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, TEST_QUERY_TIMEOUT,\n+  public void testRMAndTimeoutSet() {\n+    // verify that we still receive critical heap cancellation\n+    doCriticalMemoryHitTest(false, true, TEST_QUERY_TIMEOUT,\n         true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSetAndQueryTimesoutInstead() throws Exception {\n+  public void testRMAndTimeoutSetAndQueryTimeoutInstead() {\n     // verify that timeout is set correctly and cancel query\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, TEST_QUERY_TIMEOUT,\n+    doCriticalMemoryHitTest(false, true, TEST_QUERY_TIMEOUT,\n         false);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSet() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSet() {\n     // verify that timeout is still working properly\n-    doCriticalMemoryHitTest(\"portfolios\", false, 85/* crit threshold */, true, TEST_QUERY_TIMEOUT,\n+    doCriticalMemoryHitTest(false, true, TEST_QUERY_TIMEOUT,\n         true);\n   }\n \n   // Query directly on member with RM and QM set\n   @Test\n-  public void testRMAndNoTimeoutSetOnServer() throws Exception {\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSetOnServer() {\n+    doCriticalMemoryHitTestOnServer(false, false, -1, true);\n   }\n \n   // Query directly on member with RM and QM set\n   @Test\n-  public void whenTimeoutIsSetAndAQueryIsExecutedThenTimeoutMustStopTheQueryBeforeCriticalMemory()\n-      throws Exception {\n+  public void whenTimeoutIsSetAndAQueryIsExecutedThenTimeoutMustStopTheQueryBeforeCriticalMemory() {\n     // Timeout is set along with critical heap but it be called after the timeout expires\n     // Timeout is set to 1ms which is very unrealistic time period for a query to be able to fetch\n     // 200 entries from the region successfully, hence a timeout is expected.\n-    executeQueryWithTimeoutSetAndCriticalThreshold(\"portfolios\", false, 85/* crit threshold */,\n-        false, 1, true);\n+    // create region on the server\n+    final VM server = VM.getVM(0);\n+    try {\n+      final int port = AvailablePortHelper.getRandomAvailableTCPPort();\n+      startCacheServer(server, port, false, 1,\n+          false);\n+      populateData(server);\n+      executeQueryWithCriticalHeapCalledAfterTimeout(server, server);\n+      vmRecoversFromCriticalHeap(server);\n+\n+    } finally {\n+      stopServer(server);\n+    }\n   }\n \n   @Test\n-  public void whenTimeoutIsSetAndAQueryIsExecutedFromClientThenTimeoutMustStopTheQueryBeforeCriticalMemory()\n-      throws Exception {\n+  public void whenTimeoutIsSetAndAQueryIsExecutedFromClientThenTimeoutMustStopTheQueryBeforeCriticalMemory() {\n     // Timeout is set along with critical heap but it be called after the timeout expires\n     // Timeout is set to 1ms which is very unrealistic time period for a query to be able to fetch\n     // 200 entries from the region successfully, hence a timeout is expected.\n-    executeQueryFromClientWithTimeoutSetAndCriticalThreshold(\"portfolios\", false,\n-        85/* crit threshold */, false, 1, true);\n+    // create region on the server\n+    final VM server = VM.getVM(0);\n+    final VM client = VM.getVM(1);\n+    try {\n+      final int port = AvailablePortHelper.getRandomAvailableTCPPort();\n+      startCacheServer(server, port, false, 1,\n+          false);\n+      startClient(client, port);\n+      populateData(server);\n+      executeQueryWithCriticalHeapCalledAfterTimeout(server, client);\n+      vmRecoversFromCriticalHeap(server);\n+\n+    } finally {\n+      stopServer(server);\n+    }\n   }\n \n   @Test\n-  public void testRMAndNoTimeoutSetParRegOnServer() throws Exception {\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", true, 85/* crit threshold */, false, -1, true);\n+  public void testRMAndNoTimeoutSetParRegOnServer() {\n+    doCriticalMemoryHitTestOnServer(true, false, -1, true);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSetOnServer() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndNoTimeoutSetOnServer() {\n     // verify that timeout is not set and that a query can execute properly\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true, -1, true);\n+    doCriticalMemoryHitTestOnServer(false, true, -1, true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSetOnServer() throws Exception {\n-    // verify that we still receive critical heap cancelation\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true,\n+  public void testRMAndTimeoutSetOnServer() {\n+    // verify that we still receive critical heap cancellation\n+    doCriticalMemoryHitTestOnServer(false, true,\n         TEST_QUERY_TIMEOUT, true);\n   }\n \n   @Test\n-  public void testRMAndTimeoutSetAndQueryTimesoutInsteadOnServer() throws Exception {\n+  public void testRMAndTimeoutSetAndQueryTimeoutInsteadOnServer() {\n     // verify that timeout is set correctly and cancel query\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true,\n+    doCriticalMemoryHitTestOnServer(false, true,\n         TEST_QUERY_TIMEOUT, false);\n   }\n \n   @Test\n-  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSetOnServer() throws Exception {\n+  public void testRMButDisabledQueryMonitorForLowMemAndTimeoutSetOnServer() {\n     // verify that timeout is still working properly\n-    doCriticalMemoryHitTestOnServer(\"portfolios\", false, 85/* crit threshold */, true,\n+    doCriticalMemoryHitTestOnServer(false, true,\n         TEST_QUERY_TIMEOUT, true);\n   }\n \n   @Test\n-  public void testPRGatherCancellation() throws Exception {\n-    doCriticalMemoryHitTestWithMultipleServers(\"portfolios\", true, 85/* crit threshold */, false,\n-        -1, true);\n-  }\n-\n-  @Test\n-  public void testPRGatherCancellationWhileGatheringResults() throws Exception {\n-    doCriticalMemoryHitDuringGatherTestWithMultipleServers(\"portfolios\", true,\n-        85/* crit threshold */, false, -1, true);\n-  }\n+  public void testPRGatherCancellation() throws Throwable {\n+    // create region on the server\n+    final VM server1 = VM.getVM(0);\n+    final VM server2 = VM.getVM(1);\n+    final VM client = VM.getVM(2);\n+    final int numObjects = 200;\n+    final VM controller = VM.getController();\n+    try {\n+      final int[] port = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n+      startCacheServer(server1, port[0], false,\n+          -1, true);\n+      startCacheServer(server2, port[1], true, -1, true);\n+\n+      startClient(client, port[0]);\n+      populateData(server2);\n+      server1.invoke(\"create latch test Hook\", () -> {\n+        DefaultQuery.testHook = getPauseHook(true, controller);\n+      });\n+      // remove from here to ....\n+      AsyncInvocation queryExecution1 = executeQueryOnClient(client);\n \n-  @Test\n-  public void testPRGatherCancellationWhileAddingResults() throws Exception {\n-    doCriticalMemoryHitAddResultsTestWithMultipleServers(\"portfolios\", true, 85/* crit threshold */,\n-        false, -1, true);\n-  }\n+      // Gives async invocation a chance to start\n+      Thread.sleep(1000);\n+      // We simulate a low memory/critical heap percentage hit\n+      setHeapToCriticalAndReleaseLatch(server1);\n+      assertThat(queryExecution1.get(60, SECONDS)).isEqualTo(0);\n+      verifyDroppedObjectsAndSetHeapToNormal(server1);\n \n-  @Test\n-  public void testIndexCreationCancellationPR() throws Exception {\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", true, 85/* crit threshold */, false, -1, true,\n-        \"compact\");\n-  }\n+      // to here....\n+      // Check to see if query execution is ok under \"normal\" or \"healthy\" conditions\n+      client.invoke(\"Executing query when system is 'Normal'\", () -> {\n+        try {\n+          Query query = getCache().getQueryService().newQuery(\"Select * From /\" + \"portfolios\");\n+          SelectResults results = (SelectResults) query.execute();\n+          assertThat(results.size()).isEqualTo(numObjects);\n+        } catch (QueryInvocationTargetException | FunctionDomainException | TypeMismatchException\n+            | NameResolutionException e) {\n+          fail(\"\");\n+        }\n+      });\n+      // We simulate a low memory/critical heap percentage hit\n+      setHeapToCriticalAndReleaseLatch(server1);\n+      AsyncInvocation queryExecution = executeQueryOnClient(client);\n+      assertThat(queryExecution.get(60, SECONDS)).isEqualTo(0);\n+      verifyDroppedObjectsAndSetHeapToNormal(server1);\n \n-  @Test\n-  public void testIndexCreationCancellation() throws Exception {\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", false, 85/* crit threshold */, false, -1, true,\n-        \"compact\");\n+    } finally {\n+      stopServer(server1);\n+      stopServer(server2);\n+    }\n   }\n \n-  @Test\n-  public void testIndexCreationNoCancellationPR() throws Exception {\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", true, 85/* crit threshold */, true, -1, true,\n-        \"compact\");\n+  private AsyncInvocation executeQueryOnClient(VM client) {\n+    return client.invokeAsync(\"execute query from client\", () -> {\n+      try {\n+        Query query1 = getCache().getQueryService().newQuery(\"Select * From /\" + \"portfolios\");\n+        query1.execute();\n+        throw new CacheException(\"Exception should have been thrown due to low memory\") {};\n+      } catch (Exception e2) {\n+        handleException(e2, true, false, -1);\n+      }\n+      return 0;\n+    });\n   }\n \n-  @Test\n-  public void testHashIndexCreationCancellationPR() throws Exception {\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", true, 85/* crit threshold */, false, -1, true,\n-        \"hash\");\n+  private void setHeapToCriticalAndReleaseLatch(VM server1) {\n+    server1.invoke(\"vm hits critical heap and counts down latch.\", () -> {\n+      InternalResourceManager resourceManager =\n+          (InternalResourceManager) getCache().getResourceManager();\n+      resourceManager.getHeapMonitor().updateStateAndSendEvent(CRITICAL_HEAP_USED, \"test\");\n+      await()\n+          .until(() -> resourceManager.getHeapMonitor().getState() == EVICTION_DISABLED_CRITICAL);\n+      Thread.sleep(MAX_TEST_QUERY_TIMEOUT);\n+      // release the hook to have the query throw either a low memory or query timeout\n+      // unless otherwise configured\n+      PauseTestHook hook = (PauseTestHook) DefaultQuery.testHook;\n+      hook.countDown();\n+    });\n   }\n \n-  @Test\n-  public void testHashIndexCreationCancellation() throws Exception {\n-    // need to add hook to canceled result set and very it is triggered for multiple servers\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", false, 85/* crit threshold */, false, -1, true,\n-        \"hash\");\n+  private void verifyDroppedObjectsAndSetHeapToNormal(VM server1) {\n+    server1.invoke(\"verify dropped objects\", () -> {\n+      if (DefaultQuery.testHook instanceof RejectedObjectsInterface) {\n+        RejectedObjectsInterface rejectedObjectsInterface =\n+            (RejectedObjectsInterface) DefaultQuery.testHook;\n+        await()\n+            .untilAsserted(() -> assertThat(rejectedObjectsInterface.rejectedObjects).isTrue());\n+      }\n+      InternalResourceManager resourceManager =\n+          (InternalResourceManager) getCache().getResourceManager();\n+      resourceManager.getHeapMonitor().updateStateAndSendEvent(NORMAL_HEAP_USED, \"test\");\n+      await().until(() -> resourceManager.getHeapMonitor().getState() == EVICTION_DISABLED);\n+    });\n   }\n \n   @Test\n-  public void testHashIndexCreationNoCancellationPR() throws Exception {\n-    // need to add hook to canceled result set and very it is triggered for multiple servers\n-    doCriticalMemoryHitWithIndexTest(\"portfolios\", true, 85/* crit threshold */, true, -1, true,\n-        \"hash\");\n-  }\n-\n-  private void doCriticalMemoryHitTest(final String regionName, boolean createPR,\n-      final int criticalThreshold,\n-      final boolean disabledQueryMonitorForLowMem,\n-      final int queryTimeout, final boolean hitCriticalThreshold)\n-      throws Exception {\n+  public void testPRGatherCancellationWhileGatheringResults() {\n     // create region on the server\n-    final VM server = VM.getVM(0);\n-    final VM client = VM.getVM(1);\n+    final VM server1 = VM.getVM(0);\n+    final VM server2 = VM.getVM(1);\n+    final VM client = VM.getVM(2);\n     final int numObjects = 200;\n     try {\n-      final int port = AvailablePortHelper.getRandomAvailableTCPPort();\n-      startCacheServer(server, port, criticalThreshold, disabledQueryMonitorForLowMem, queryTimeout,\n-          regionName, createPR, 0);\n+      final int[] port = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n+      startCacheServer(server1, port[0], false,\n+          -1, true);\n+      startCacheServer(server2, port[1], true, -1, true);\n \n-      startClient(client, server, port, regionName);\n-      populateData(server, regionName, numObjects);\n+      startClient(client, port[0]);\n+      populateData(server2);\n \n-      doTestCriticalHeapAndQueryTimeout(server, client, regionName, disabledQueryMonitorForLowMem,\n-          queryTimeout, hitCriticalThreshold);\n+      createCancelDuringGatherTestHook(server1, VM.getController());\n+      client.invoke(\"executing query to be canceled by gather\", () -> {\n+        QueryService qs;\n+        try {\n+          qs = getCache().getQueryService();\n+          Query query = qs.newQuery(\"Select * From /\" + \"portfolios\");\n+          query.execute();\n+        } catch (ServerOperationException soe) {\n+          if (soe.getRootCause() instanceof QueryException) {\n+            QueryException e = (QueryException) soe.getRootCause();\n+            if (!isExceptionDueToLowMemory(e)) {\n+              throw new CacheException(soe) {};\n+            } else {\n+              return 0;\n+            }\n+          }\n+        } catch (Exception e) {\n+          throw new CacheException(e) {};\n+        }\n+        // assertTrue(((CancelDuringGatherHook)DefaultQuery.testHook).triggeredOOME);\n+        throw new CacheException(\"should have hit low memory\") {};\n+      });\n \n-      // Pause for a second and then let's recover\n-      try {\n-        Thread.sleep(1000);\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n+      verifyRejectedObjects(server1);\n \n       // Recover from critical heap\n-      if (hitCriticalThreshold) {\n-        vmRecoversFromCriticalHeap(server);\n-      }\n+      vmRecoversFromCriticalHeap(server1);\n \n       // Check to see if query execution is ok under \"normal\" or \"healthy\" conditions\n-      client.invoke(new CacheSerializableRunnable(\"Executing query when system is 'Normal'\") {\n-        @Override\n-        public void run2() {\n-          try {\n-            QueryService qs = getCache().getQueryService();\n-            Query query = qs.newQuery(\"Select * From /\" + regionName);\n-            SelectResults results = (SelectResults) query.execute();\n-            assertEquals(numObjects, results.size());\n-          } catch (QueryInvocationTargetException e) {\n-            assertFalse(true);\n-          } catch (NameResolutionException e) {\n-            assertFalse(true);\n-          } catch (TypeMismatchException e) {\n-            assertFalse(true);\n-          } catch (FunctionDomainException e) {\n-            assertFalse(true);\n-          }\n+      client.invoke(\"Executing query when system is 'Normal'\", () -> {\n+        try {\n+          QueryService qs = getCache().getQueryService();\n+          Query query = qs.newQuery(\"Select * From /\" + \"portfolios\");\n+          SelectResults results = (SelectResults) query.execute();\n+          assertThat(results.size()).isEqualTo(numObjects);\n+        } catch (QueryInvocationTargetException | FunctionDomainException | TypeMismatchException\n+            | NameResolutionException e) {\n+          fail(\"\");\n         }\n       });\n \n-      // Execute a critical heap event/ query timeout test again\n-      doTestCriticalHeapAndQueryTimeout(server, client, regionName, disabledQueryMonitorForLowMem,\n-          queryTimeout, hitCriticalThreshold);\n       // Recover from critical heap\n-      if (hitCriticalThreshold) {\n-        vmRecoversFromCriticalHeap(server);\n-      }\n-    } finally {\n-      stopServer(server);\n-    }\n-  }\n-\n-  // test to verify what happens during index creation if memory threshold is hit\n-  private void doCriticalMemoryHitWithIndexTest(final String regionName, boolean createPR,\n-      final int criticalThreshold,\n-      final boolean disabledQueryMonitorForLowMem,\n-      final int queryTimeout,\n-      final boolean hitCriticalThreshold,\n-      final String indexType)\n-      throws Exception {\n-    // create region on the server\n-    final VM server1 = VM.getVM(0);\n-    final VM server2 = VM.getVM(2);\n-    final VM client = VM.getVM(1);\n-    final int numObjects = 200;\n-    try {\n-      final int[] port = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n-      startCacheServer(server1, port[0], criticalThreshold, disabledQueryMonitorForLowMem,\n-          queryTimeout, regionName, createPR, 0);\n-      startCacheServer(server2, port[1], criticalThreshold, true, -1, regionName, createPR, 0);\n-\n-      startClient(client, server1, port[0], regionName);\n-      populateData(server1, regionName, numObjects);\n-\n-      createCancelDuringGatherTestHook(server1);\n-      server1.invoke(new SerializableCallable(\"create index\") {\n-        @Override\n-        public Object call() {\n-          QueryService qs = null;\n-          try {\n-            qs = getCache().getQueryService();\n-            Index index = null;\n-            if (indexType.equals(\"compact\")) {\n-              index = qs.createIndex(\"newIndex\", \"ID\", \"/\" + regionName);\n-            } else if (indexType.equals(\"hash\")) {\n-              index = qs.createHashIndex(\"newIndex\", \"ID\", \"/\" + regionName);\n-            }\n-            assertNotNull(index);\n-            assertTrue(((CancelDuringGatherHook) DefaultQuery.testHook).triggeredOOME);\n-\n-            if (hitCriticalThreshold && !disabledQueryMonitorForLowMem) {\n-              throw new CacheException(\"Should have hit low memory\") {};\n-            }\n-            assertEquals(1, qs.getIndexes().size());\n-          } catch (Exception e) {\n-            if (e instanceof IndexInvalidException) {\n-              if (!hitCriticalThreshold || disabledQueryMonitorForLowMem) {\n-                throw new CacheException(\"Should not have run into low memory exception\") {};\n-              }\n-            } else {\n-              throw new CacheException(e) {};\n-            }\n-          }\n-          return 0;\n-        }\n-      });\n+      vmRecoversFromCriticalHeap(server1);\n     } finally {\n       stopServer(server1);\n       stopServer(server2);\n     }\n   }\n \n-  private void doCriticalMemoryHitAddResultsTestWithMultipleServers(final String regionName,\n-      boolean createPR,\n-      final int criticalThreshold,\n-      final boolean disabledQueryMonitorForLowMem,\n-      final int queryTimeout,\n-      final boolean hitCriticalThreshold)\n-      throws Exception {\n+  @Test\n+  public void testPRGatherCancellationWhileAddingResults() {\n     // create region on the server\n     final VM server1 = VM.getVM(0);\n     final VM server2 = VM.getVM(1);\n     final VM client = VM.getVM(2);\n     final int numObjects = 200;\n     try {\n       final int[] port = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n-      startCacheServer(server1, port[0], criticalThreshold, disabledQueryMonitorForLowMem,\n-          queryTimeout, regionName, createPR, 0);\n-      startCacheServer(server2, port[1], criticalThreshold, true, -1, regionName, createPR, 0);\n+      startCacheServer(server1, port[0], false,\n+          -1, true);\n+      startCacheServer(server2, port[1], true, -1, true);\n \n-      startClient(client, server1, port[0], regionName);\n-      populateData(server2, regionName, numObjects);\n+      startClient(client, port[0]);\n+      populateData(server2);\n \n       createCancelDuringAddResultsTestHook(server1);\n-      client.invoke(new SerializableCallable(\"executing query to be canceled during add results\") {\n-        @Override\n-        public Object call() {\n-          QueryService qs = null;\n-          try {\n-            qs = getCache().getQueryService();\n-            Query query = qs.newQuery(\"Select * From /\" + regionName);\n-            SelectResults results = (SelectResults) query.execute();\n-            if (hitCriticalThreshold && disabledQueryMonitorForLowMem == false) {\n-              throw new CacheException(\"should have hit low memory\") {};\n-            }\n-          } catch (Exception e) {\n-            handleException(e, hitCriticalThreshold, disabledQueryMonitorForLowMem, queryTimeout);\n-          }\n-          return 0;\n+      client.invoke(\"executing query to be canceled during add results\", () -> {\n+        QueryService qs;\n+        try {\n+          qs = getCache().getQueryService();\n+          Query query = qs.newQuery(\"Select * From /\" + \"portfolios\");\n+          query.execute();\n+          throw new CacheException(\"should have hit low memory\") {};\n+        } catch (Exception e) {\n+          handleException(e, true, false, -1);\n         }\n+        return 0;\n       });\n \n-      verifyRejectedObjects(server1, disabledQueryMonitorForLowMem, queryTimeout,\n-          hitCriticalThreshold);\n-      // Pause for a second and then let's recover\n-      try {\n-        Thread.sleep(1000);\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n+      verifyRejectedObjects(server1);\n \n       // Recover from critical heap\n-      if (hitCriticalThreshold) {\n-        vmRecoversFromCriticalHeap(server1);\n-      }\n+      vmRecoversFromCriticalHeap(server1);\n \n       // Check to see if query execution is ok under \"normal\" or \"healthy\" conditions\n-      client.invoke(new CacheSerializableRunnable(\"Executing query when system is 'Normal'\") {\n-        @Override\n-        public void run2() {\n-          try {\n-            QueryService qs = getCache().getQueryService();\n-            Query query = qs.newQuery(\"Select * From /\" + regionName);\n-            SelectResults results = (SelectResults) query.execute();\n-            assertEquals(numObjects, results.size());\n-          } catch (QueryInvocationTargetException e) {\n-            assertFalse(true);\n-          } catch (NameResolutionException e) {\n-            assertFalse(true);\n-          } catch (TypeMismatchException e) {\n-            assertFalse(true);\n-          } catch (FunctionDomainException e) {\n-            assertFalse(true);\n-          }\n+      client.invoke(\"Executing query when system is 'Normal'\", () -> {\n+        try {\n+          QueryService qs = getCache().getQueryService();\n+          Query query = qs.newQuery(\"Select * From /\" + \"portfolios\");\n+          SelectResults results = (SelectResults) query.execute();\n+          assertThat(results.size()).isEqualTo(numObjects);\n+        } catch (QueryInvocationTargetException | FunctionDomainException | TypeMismatchException\n+            | NameResolutionException e) {\n+          fail(\"\");\n         }\n       });\n \n       // Recover from critical heap\n-      if (hitCriticalThreshold) {\n-        vmRecoversFromCriticalHeap(server1);\n-      }\n+      vmRecoversFromCriticalHeap(server1);\n     } finally {\n       stopServer(server1);\n       stopServer(server2);\n     }\n   }\n \n-  // tests low memory hit while gathering partition region results\n-  private void doCriticalMemoryHitDuringGatherTestWithMultipleServers(final String regionName,\n-      boolean createPR,\n-      final int criticalThreshold,\n+  @Test\n+  public void testIndexCreationCancellationPR() {\n+    doCriticalMemoryHitWithIndexTest(true, false,\n+        \"compact\");\n+  }\n+\n+  @Test\n+  public void testIndexCreationCancellation() {\n+    doCriticalMemoryHitWithIndexTest(false, false,\n+        \"compact\");\n+  }\n+\n+  @Test\n+  public void testIndexCreationNoCancellationPR() {\n+    doCriticalMemoryHitWithIndexTest(true, true,\n+        \"compact\");\n+  }\n+\n+  @Test\n+  public void testHashIndexCreationCancellationPR() {\n+    doCriticalMemoryHitWithIndexTest(true, false,\n+        \"hash\");\n+  }\n+\n+  @Test\n+  public void testHashIndexCreationCancellation() {\n+    // need to add hook to canceled result set and very it is triggered for multiple servers\n+    doCriticalMemoryHitWithIndexTest(false, false,\n+        \"hash\");\n+  }\n+\n+  @Test\n+  public void testHashIndexCreationNoCancellationPR() {\n+    // need to add hook to canceled result set and very it is triggered for multiple servers\n+    doCriticalMemoryHitWithIndexTest(true, true,\n+        \"hash\");\n+  }\n+\n+  private void doCriticalMemoryHitTest(boolean createPR,\n       final boolean disabledQueryMonitorForLowMem,\n-      final int queryTimeout,\n-      final boolean hitCriticalThreshold)\n-      throws Exception {\n+      final int queryTimeout, final boolean hitCriticalThreshold) {\n     // create region on the server\n-    final VM server1 = VM.getVM(0);\n-    final VM server2 = VM.getVM(1);\n-    final VM client = VM.getVM(2);\n+    final VM server = VM.getVM(0);\n+    final VM client = VM.getVM(1);\n     final int numObjects = 200;\n     try {\n-      final int[] port = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n-      startCacheServer(server1, port[0], criticalThreshold, disabledQueryMonitorForLowMem,\n-          queryTimeout, regionName, createPR, 0);\n-      startCacheServer(server2, port[1], criticalThreshold, true, -1, regionName, createPR, 0);\n-\n-      startClient(client, server1, port[0], regionName);\n-      populateData(server2, regionName, numObjects);\n-\n-      createCancelDuringGatherTestHook(server1);\n-      client.invoke(new SerializableCallable(\"executing query to be canceled by gather\") {\n-        @Override\n-        public Object call() {\n-          QueryService qs = null;\n-          try {\n-            qs = getCache().getQueryService();\n-            Query query = qs.newQuery(\"Select * From /\" + regionName);\n-            query.execute();\n-          } catch (ServerOperationException soe) {\n-            if (soe.getRootCause() instanceof QueryException) {\n-              QueryException e = (QueryException) soe.getRootCause();\n-              if (!isExceptionDueToLowMemory(e, CRITICAL_HEAP_USED)) {\n-                throw new CacheException(soe) {};\n-              } else {\n-                return 0;\n-              }\n-            }\n-          } catch (Exception e) {\n-            throw new CacheException(e) {};\n-          }\n-          // assertTrue(((CancelDuringGatherHook)DefaultQuery.testHook).triggeredOOME);\n-          throw new CacheException(\"should have hit low memory\") {};\n-        }\n-      });\n+      final int port = AvailablePortHelper.getRandomAvailableTCPPort();\n+      startCacheServer(server, port, disabledQueryMonitorForLowMem, queryTimeout,\n+          createPR);\n \n-      verifyRejectedObjects(server1, disabledQueryMonitorForLowMem, queryTimeout,\n-          hitCriticalThreshold);\n-      // Pause for a second and then let's recover\n-      try {\n-        Thread.sleep(1000);\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n+      startClient(client, port);\n+      populateData(server);\n+\n+      doTestCriticalHeapAndQueryTimeout(server, client, disabledQueryMonitorForLowMem,\n+          queryTimeout, hitCriticalThreshold);\n \n       // Recover from critical heap\n       if (hitCriticalThreshold) {\n-        vmRecoversFromCriticalHeap(server1);\n+        vmRecoversFromCriticalHeap(server);\n+        await().until(() -> vmCheckCritcalHeap(server) == EVICTION_DISABLED);\n       }\n \n       // Check to see if query execution is ok under \"normal\" or \"healthy\" conditions\n-      client.invoke(new CacheSerializableRunnable(\"Executing query when system is 'Normal'\") {\n-        @Override\n-        public void run2() {\n-          try {\n-            QueryService qs = getCache().getQueryService();\n-            Query query = qs.newQuery(\"Select * From /\" + regionName);\n-            SelectResults results = (SelectResults) query.execute();\n-            assertEquals(numObjects, results.size());\n-          } catch (QueryInvocationTargetException e) {\n-            assertFalse(true);\n-          } catch (NameResolutionException e) {\n-            assertFalse(true);\n-          } catch (TypeMismatchException e) {\n-            assertFalse(true);\n-          } catch (FunctionDomainException e) {\n-            assertFalse(true);\n-          }\n+      client.invoke(\"Executing query when system is 'Normal'\", () -> {\n+        try {\n+          QueryService qs = getCache().getQueryService();\n+          Query query = qs.newQuery(\"Select * From /\" + \"portfolios\");\n+          SelectResults results = (SelectResults) query.execute();\n+          assertThat(results.size()).isEqualTo(numObjects);\n+        } catch (QueryInvocationTargetException | FunctionDomainException | TypeMismatchException\n+            | NameResolutionException e) {\n+          fail(\"\");\n         }\n       });\n \n+      // Execute a critical heap event/ query timeout test again\n+      doTestCriticalHeapAndQueryTimeout(server, client, disabledQueryMonitorForLowMem,\n+          queryTimeout, hitCriticalThreshold);\n       // Recover from critical heap\n       if (hitCriticalThreshold) {\n-        vmRecoversFromCriticalHeap(server1);\n+        vmRecoversFromCriticalHeap(server);\n+        await().until(() -> vmCheckCritcalHeap(server) == EVICTION_DISABLED);\n       }\n     } finally {\n-      stopServer(server1);\n-      stopServer(server2);\n+      stopServer(server);\n     }\n   }\n \n-  // Executes on client cache with multiple configured servers\n-  private void doCriticalMemoryHitTestWithMultipleServers(final String regionName, boolean createPR,\n-      final int criticalThreshold,\n+  // test to verify what happens during index creation if memory threshold is hit\n+  private void doCriticalMemoryHitWithIndexTest(boolean createPR,\n       final boolean disabledQueryMonitorForLowMem,\n-      final int queryTimeout,\n-      final boolean hitCriticalThreshold)\n-      throws Exception {\n+      final String indexType) {\n     // create region on the server\n     final VM server1 = VM.getVM(0);\n-    final VM server2 = VM.getVM(1);\n-    final VM client = VM.getVM(2);\n-    final int numObjects = 200;\n+    final VM server2 = VM.getVM(2);\n+    final VM client = VM.getVM(1);\n \n     try {\n       final int[] port = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n-      startCacheServer(server1, port[0], criticalThreshold, disabledQueryMonitorForLowMem,\n-          queryTimeout, regionName, createPR, 0);\n-      startCacheServer(server2, port[1], criticalThreshold, true, -1, regionName, createPR, 0);\n+      startCacheServer(server1, port[0], disabledQueryMonitorForLowMem,\n+          -1, createPR);\n+      startCacheServer(server2, port[1], true, -1, createPR);\n \n-      startClient(client, server1, port[0], regionName);\n-      populateData(server2, regionName, numObjects);\n+      startClient(client, port[0]);\n+      populateData(server1);\n \n-      doTestCriticalHeapAndQueryTimeout(server1, client, regionName, disabledQueryMonitorForLowMem,\n-          queryTimeout, hitCriticalThreshold);\n-      verifyRejectedObjects(server1, disabledQueryMonitorForLowMem, queryTimeout,\n-          hitCriticalThreshold);\n-      // Pause for a second and then let's recover\n-      try {\n-        Thread.sleep(1000);\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n-\n-      // Recover from critical heap\n-      if (hitCriticalThreshold) {\n-        vmRecoversFromCriticalHeap(server1);\n-      }\n+      createCancelDuringGatherTestHook(server1, VM.getController());\n+      server1.invoke(\"create index\", () -> {\n+        QueryService qs;\n+        try {\n+          qs = getCache().getQueryService();\n+          Index index = null;\n+          if (indexType.equals(\"compact\")) {\n+            index = qs.createIndex(\"newIndex\", \"ID\", \"/\" + \"portfolios\");\n+          } else if (indexType.equals(\"hash\")) {\n+            index = qs.createIndex(\"newIndex\", \"ID\", \"/\" + \"portfolios\");\n+          }\n+          assertThat(index).isNotNull();\n+          assertThat(((CancelDuringGatherHook) DefaultQuery.testHook).triggeredOOME).isTrue();\n \n-      // Check to see if query execution is ok under \"normal\" or \"healthy\" conditions\n-      client.invoke(new CacheSerializableRunnable(\"Executing query when system is 'Normal'\") {\n-        @Override\n-        public void run2() {\n-          try {\n-            QueryService qs = getCache().getQueryService();\n-            Query query = qs.newQuery(\"Select * From /\" + regionName);\n-            SelectResults results = (SelectResults) query.execute();\n-            assertEquals(numObjects, results.size());\n-          } catch (QueryInvocationTargetException e) {\n-            assertFalse(true);\n-          } catch (NameResolutionException e) {\n-            assertFalse(true);\n-          } catch (TypeMismatchException e) {\n-            assertFalse(true);\n-          } catch (FunctionDomainException e) {\n-            assertFalse(true);\n+          if (!disabledQueryMonitorForLowMem) {\n+            throw new CacheException(\"Should have hit low memory\") {};\n+          }\n+          assertThat(qs.getIndexes().size()).isEqualTo(1);\n+        } catch (Exception e) {\n+          if (e instanceof IndexInvalidException) {\n+            if (disabledQueryMonitorForLowMem) {\n+              throw new CacheException(\"Should not have run into low memory exception\") {};\n+            }\n+          } else {\n+            throw new CacheException(e) {};\n           }\n         }\n+        return 0;\n       });\n-\n-      // Execute a critical heap event/ query timeout test again\n-      doTestCriticalHeapAndQueryTimeout(server1, client, regionName, disabledQueryMonitorForLowMem,\n-          queryTimeout, hitCriticalThreshold);\n-      verifyRejectedObjects(server1, disabledQueryMonitorForLowMem, queryTimeout,\n-          hitCriticalThreshold);\n-      // Recover from critical heap\n-      if (hitCriticalThreshold) {\n-        vmRecoversFromCriticalHeap(server1);\n-      }\n     } finally {\n       stopServer(server1);\n       stopServer(server2);\n     }\n   }\n \n+  private static CountDownLatch criticalMemoryCountDownLatch;\n+\n   // Executes the query on the server with the RM and QM configured\n-  private void doCriticalMemoryHitTestOnServer(final String regionName, boolean createPR,\n-      final int criticalThreshold,\n+  private void doCriticalMemoryHitTestOnServer(boolean createPR,\n       final boolean disabledQueryMonitorForLowMem,\n       final int queryTimeout,\n-      final boolean hitCriticalThreshold)\n-      throws Exception {\n+      final boolean hitCriticalThreshold) {\n     // create region on the server\n     final VM server = VM.getVM(0);\n     final int numObjects = 200;\n     try {\n       final int port = AvailablePortHelper.getRandomAvailableTCPPort();\n-      startCacheServer(server, port, criticalThreshold, disabledQueryMonitorForLowMem, queryTimeout,\n-          regionName, createPR, 0);\n+      startCacheServer(server, port, disabledQueryMonitorForLowMem, queryTimeout,\n+          createPR);\n \n-      // startPeerClient(client, server, port, regionName);\n-      populateData(server, regionName, numObjects);\n+      populateData(server);\n \n-      doTestCriticalHeapAndQueryTimeout(server, server, regionName, disabledQueryMonitorForLowMem,\n+      doTestCriticalHeapAndQueryTimeout(server, server, disabledQueryMonitorForLowMem,\n           queryTimeout, hitCriticalThreshold);\n \n-      // Pause for a second and then let's recover\n-      try {\n-        Thread.sleep(1000);\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n-\n       // Recover from critical heap\n       if (hitCriticalThreshold) {\n         vmRecoversFromCriticalHeap(server);\n       }\n \n       // Check to see if query execution is ok under \"normal\" or \"healthy\" conditions\n-      server.invoke(new CacheSerializableRunnable(\"Executing query when system is 'Normal'\") {\n-        @Override\n-        public void run2() {\n-          try {\n-            QueryService qs = getCache().getQueryService();\n-            Query query = qs.newQuery(\"Select * From /\" + regionName);\n-            SelectResults results = (SelectResults) query.execute();\n-            assertEquals(numObjects, results.size());\n-          } catch (QueryInvocationTargetException e) {\n-            assertFalse(true);\n-          } catch (NameResolutionException e) {\n-            assertFalse(true);\n-          } catch (TypeMismatchException e) {\n-            assertFalse(true);\n-          } catch (FunctionDomainException e) {\n-            assertFalse(true);\n-          }\n+      server.invoke(\"Executing query when system is 'Normal'\", () -> {\n+        try {\n+          QueryService qs = getCache().getQueryService();\n+          Query query = qs.newQuery(\"Select * From /\" + \"portfolios\");\n+          SelectResults results = (SelectResults) query.execute();\n+          assertThat(results.size()).isEqualTo(numObjects);\n+        } catch (QueryInvocationTargetException | FunctionDomainException | TypeMismatchException", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzNjEzMA=="}, "originalCommit": {"oid": "40db9bd39c00a0468aa08ddc4541cd0d26d2f2b9"}, "originalPosition": 1062}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MTk2MDc4OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMTo1NzozOVrOFpAB7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxOToyMDozNVrOFpgbjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzNjQyOQ==", "bodyText": "Delete the surrounding try-catch and add throws InterruptedException to the method.", "url": "https://github.com/apache/geode/pull/4691#discussion_r378536429", "createdAt": "2020-02-12T21:57:39Z", "author": {"login": "kirklund"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "diffHunk": "@@ -809,186 +666,182 @@ private void executeQueryWithTimeoutSetAndCriticalThreshold(final String regionN\n   // If timeout is disabled/not set, then the query should execute just fine\n   // The last part of the test is to execute another query with the system under duress and have it\n   // be rejected/cancelled if rm and qm are in use\n-  private void doTestCriticalHeapAndQueryTimeout(VM server, VM client, final String regionName,\n+  private void doTestCriticalHeapAndQueryTimeout(VM server, VM client,\n       final boolean disabledQueryMonitorForLowMem,\n       final int queryTimeout,\n       final boolean hitCriticalThreshold) {\n-    createLatchTestHook(server);\n+    createLatchTestHook(server, hitCriticalThreshold, VM.getController());\n \n-    AsyncInvocation queryExecution = invokeClientQuery(client, regionName,\n-        disabledQueryMonitorForLowMem, queryTimeout, hitCriticalThreshold);\n+    AsyncInvocation queryExecution = invokeClientQuery(client,\n+        disabledQueryMonitorForLowMem, queryTimeout, hitCriticalThreshold, VM.getController());\n \n     try {\n-      Thread.sleep(1000);\n+      criticalMemoryCountDownLatch.await();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40db9bd39c00a0468aa08ddc4541cd0d26d2f2b9"}, "originalPosition": 1154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA2NzI3Ng==", "bodyText": "Done.", "url": "https://github.com/apache/geode/pull/4691#discussion_r379067276", "createdAt": "2020-02-13T19:20:35Z", "author": {"login": "mhansonp"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "diffHunk": "@@ -809,186 +666,182 @@ private void executeQueryWithTimeoutSetAndCriticalThreshold(final String regionN\n   // If timeout is disabled/not set, then the query should execute just fine\n   // The last part of the test is to execute another query with the system under duress and have it\n   // be rejected/cancelled if rm and qm are in use\n-  private void doTestCriticalHeapAndQueryTimeout(VM server, VM client, final String regionName,\n+  private void doTestCriticalHeapAndQueryTimeout(VM server, VM client,\n       final boolean disabledQueryMonitorForLowMem,\n       final int queryTimeout,\n       final boolean hitCriticalThreshold) {\n-    createLatchTestHook(server);\n+    createLatchTestHook(server, hitCriticalThreshold, VM.getController());\n \n-    AsyncInvocation queryExecution = invokeClientQuery(client, regionName,\n-        disabledQueryMonitorForLowMem, queryTimeout, hitCriticalThreshold);\n+    AsyncInvocation queryExecution = invokeClientQuery(client,\n+        disabledQueryMonitorForLowMem, queryTimeout, hitCriticalThreshold, VM.getController());\n \n     try {\n-      Thread.sleep(1000);\n+      criticalMemoryCountDownLatch.await();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzNjQyOQ=="}, "originalCommit": {"oid": "40db9bd39c00a0468aa08ddc4541cd0d26d2f2b9"}, "originalPosition": 1154}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MTk2Mjg1OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMTo1ODoyNlrOFpADSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxOToxNTozNlrOFpgRwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzNjc3Nw==", "bodyText": "Just delete all of the try-catch blocks in here and let the Exceptions be thrown.", "url": "https://github.com/apache/geode/pull/4691#discussion_r378536777", "createdAt": "2020-02-12T21:58:26Z", "author": {"login": "kirklund"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "diffHunk": "@@ -809,186 +666,182 @@ private void executeQueryWithTimeoutSetAndCriticalThreshold(final String regionN\n   // If timeout is disabled/not set, then the query should execute just fine\n   // The last part of the test is to execute another query with the system under duress and have it\n   // be rejected/cancelled if rm and qm are in use\n-  private void doTestCriticalHeapAndQueryTimeout(VM server, VM client, final String regionName,\n+  private void doTestCriticalHeapAndQueryTimeout(VM server, VM client,\n       final boolean disabledQueryMonitorForLowMem,\n       final int queryTimeout,\n       final boolean hitCriticalThreshold) {\n-    createLatchTestHook(server);\n+    createLatchTestHook(server, hitCriticalThreshold, VM.getController());\n \n-    AsyncInvocation queryExecution = invokeClientQuery(client, regionName,\n-        disabledQueryMonitorForLowMem, queryTimeout, hitCriticalThreshold);\n+    AsyncInvocation queryExecution = invokeClientQuery(client,\n+        disabledQueryMonitorForLowMem, queryTimeout, hitCriticalThreshold, VM.getController());\n \n     try {\n-      Thread.sleep(1000);\n+      criticalMemoryCountDownLatch.await();\n     } catch (InterruptedException e) {\n-      Thread.currentThread().interrupt();\n+      e.printStackTrace();\n     }\n+\n     // We simulate a low memory/critical heap percentage hit\n     if (hitCriticalThreshold) {\n       vmHitsCriticalHeap(server);\n+      await().until(() -> vmCheckCritcalHeap(server) == EVICTION_DISABLED_CRITICAL);\n     }\n \n     // Pause until query would time out if low memory was ignored\n     try {\n       Thread.sleep(MAX_TEST_QUERY_TIMEOUT);\n-    } catch (InterruptedException e) {\n+    } catch (InterruptedException e1) {\n       Thread.currentThread().interrupt();\n     }\n \n     // release the hook to have the query throw either a low memory or query timeout\n     // unless otherwise configured\n     releaseHook(server);\n \n-    ThreadUtils.join(queryExecution, 60000);\n-    // Make sure no exceptions were thrown during query testing\n     try {\n-      assertEquals(0, queryExecution.getResult());\n+      assertThat(queryExecution.get(60, SECONDS)).isEqualTo(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40db9bd39c00a0468aa08ddc4541cd0d26d2f2b9"}, "originalPosition": 1182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA2NDc2OQ==", "bodyText": "Done.", "url": "https://github.com/apache/geode/pull/4691#discussion_r379064769", "createdAt": "2020-02-13T19:15:36Z", "author": {"login": "mhansonp"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "diffHunk": "@@ -809,186 +666,182 @@ private void executeQueryWithTimeoutSetAndCriticalThreshold(final String regionN\n   // If timeout is disabled/not set, then the query should execute just fine\n   // The last part of the test is to execute another query with the system under duress and have it\n   // be rejected/cancelled if rm and qm are in use\n-  private void doTestCriticalHeapAndQueryTimeout(VM server, VM client, final String regionName,\n+  private void doTestCriticalHeapAndQueryTimeout(VM server, VM client,\n       final boolean disabledQueryMonitorForLowMem,\n       final int queryTimeout,\n       final boolean hitCriticalThreshold) {\n-    createLatchTestHook(server);\n+    createLatchTestHook(server, hitCriticalThreshold, VM.getController());\n \n-    AsyncInvocation queryExecution = invokeClientQuery(client, regionName,\n-        disabledQueryMonitorForLowMem, queryTimeout, hitCriticalThreshold);\n+    AsyncInvocation queryExecution = invokeClientQuery(client,\n+        disabledQueryMonitorForLowMem, queryTimeout, hitCriticalThreshold, VM.getController());\n \n     try {\n-      Thread.sleep(1000);\n+      criticalMemoryCountDownLatch.await();\n     } catch (InterruptedException e) {\n-      Thread.currentThread().interrupt();\n+      e.printStackTrace();\n     }\n+\n     // We simulate a low memory/critical heap percentage hit\n     if (hitCriticalThreshold) {\n       vmHitsCriticalHeap(server);\n+      await().until(() -> vmCheckCritcalHeap(server) == EVICTION_DISABLED_CRITICAL);\n     }\n \n     // Pause until query would time out if low memory was ignored\n     try {\n       Thread.sleep(MAX_TEST_QUERY_TIMEOUT);\n-    } catch (InterruptedException e) {\n+    } catch (InterruptedException e1) {\n       Thread.currentThread().interrupt();\n     }\n \n     // release the hook to have the query throw either a low memory or query timeout\n     // unless otherwise configured\n     releaseHook(server);\n \n-    ThreadUtils.join(queryExecution, 60000);\n-    // Make sure no exceptions were thrown during query testing\n     try {\n-      assertEquals(0, queryExecution.getResult());\n+      assertThat(queryExecution.get(60, SECONDS)).isEqualTo(0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzNjc3Nw=="}, "originalCommit": {"oid": "40db9bd39c00a0468aa08ddc4541cd0d26d2f2b9"}, "originalPosition": 1182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MTk2NDMzOnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMTo1ODo1NlrOFpAEPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxOToxNToyOVrOFpgRmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzNzAyMw==", "bodyText": "Another 60 seconds to replace with GeodeAwaitility.getTimeout(). And surrounding try-catch to delete.", "url": "https://github.com/apache/geode/pull/4691#discussion_r378537023", "createdAt": "2020-02-12T21:58:56Z", "author": {"login": "kirklund"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "diffHunk": "@@ -809,186 +666,182 @@ private void executeQueryWithTimeoutSetAndCriticalThreshold(final String regionN\n   // If timeout is disabled/not set, then the query should execute just fine\n   // The last part of the test is to execute another query with the system under duress and have it\n   // be rejected/cancelled if rm and qm are in use\n-  private void doTestCriticalHeapAndQueryTimeout(VM server, VM client, final String regionName,\n+  private void doTestCriticalHeapAndQueryTimeout(VM server, VM client,\n       final boolean disabledQueryMonitorForLowMem,\n       final int queryTimeout,\n       final boolean hitCriticalThreshold) {\n-    createLatchTestHook(server);\n+    createLatchTestHook(server, hitCriticalThreshold, VM.getController());\n \n-    AsyncInvocation queryExecution = invokeClientQuery(client, regionName,\n-        disabledQueryMonitorForLowMem, queryTimeout, hitCriticalThreshold);\n+    AsyncInvocation queryExecution = invokeClientQuery(client,\n+        disabledQueryMonitorForLowMem, queryTimeout, hitCriticalThreshold, VM.getController());\n \n     try {\n-      Thread.sleep(1000);\n+      criticalMemoryCountDownLatch.await();\n     } catch (InterruptedException e) {\n-      Thread.currentThread().interrupt();\n+      e.printStackTrace();\n     }\n+\n     // We simulate a low memory/critical heap percentage hit\n     if (hitCriticalThreshold) {\n       vmHitsCriticalHeap(server);\n+      await().until(() -> vmCheckCritcalHeap(server) == EVICTION_DISABLED_CRITICAL);\n     }\n \n     // Pause until query would time out if low memory was ignored\n     try {\n       Thread.sleep(MAX_TEST_QUERY_TIMEOUT);\n-    } catch (InterruptedException e) {\n+    } catch (InterruptedException e1) {\n       Thread.currentThread().interrupt();\n     }\n \n     // release the hook to have the query throw either a low memory or query timeout\n     // unless otherwise configured\n     releaseHook(server);\n \n-    ThreadUtils.join(queryExecution, 60000);\n-    // Make sure no exceptions were thrown during query testing\n     try {\n-      assertEquals(0, queryExecution.getResult());\n+      assertThat(queryExecution.get(60, SECONDS)).isEqualTo(0);\n     } catch (Throwable e) {\n       e.printStackTrace();\n       fail(\"queryExecution.getResult() threw Exception \" + e.toString());\n     }\n   }\n \n-  private void executeQueryWithCriticalHeapCalledAfterTimeout(VM server, VM client,\n-      final String regionName,\n-      final int queryTimeout,\n-      final boolean hitCriticalThreshold) {\n-    createLatchTestHook(server);\n-    AsyncInvocation queryExecution = executeQueryWithTimeout(client, regionName, queryTimeout);\n+  private void executeQueryWithCriticalHeapCalledAfterTimeout(VM server, VM client) {\n+    createLatchTestHook(server, false, VM.getController());\n+    AsyncInvocation queryExecution = executeQueryWithTimeout(client);\n \n     // Wait till the timeout expires on the query\n     try {\n-      Thread.sleep(queryTimeout + 1000);\n+      Thread.sleep(1 + TEST_QUERY_TIMEOUT);\n     } catch (InterruptedException e) {\n       Thread.currentThread().interrupt();\n     }\n     // We simulate a low memory/critical heap percentage hit\n     // But by design of this test the query must have been already terminated because of a 1ms\n     // timeout\n-    if (hitCriticalThreshold) {\n-      vmHitsCriticalHeap(server);\n-    }\n+    vmHitsCriticalHeap(server);\n \n     releaseHook(server);\n \n-    ThreadUtils.join(queryExecution, 60000);\n     // Make sure no exceptions were thrown during query testing\n     try {\n-      assertEquals(0, queryExecution.getResult());\n+      assertThat(queryExecution.get(60, SECONDS)).isEqualTo(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40db9bd39c00a0468aa08ddc4541cd0d26d2f2b9"}, "originalPosition": 1220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA2NDcyOQ==", "bodyText": "Done.", "url": "https://github.com/apache/geode/pull/4691#discussion_r379064729", "createdAt": "2020-02-13T19:15:29Z", "author": {"login": "mhansonp"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "diffHunk": "@@ -809,186 +666,182 @@ private void executeQueryWithTimeoutSetAndCriticalThreshold(final String regionN\n   // If timeout is disabled/not set, then the query should execute just fine\n   // The last part of the test is to execute another query with the system under duress and have it\n   // be rejected/cancelled if rm and qm are in use\n-  private void doTestCriticalHeapAndQueryTimeout(VM server, VM client, final String regionName,\n+  private void doTestCriticalHeapAndQueryTimeout(VM server, VM client,\n       final boolean disabledQueryMonitorForLowMem,\n       final int queryTimeout,\n       final boolean hitCriticalThreshold) {\n-    createLatchTestHook(server);\n+    createLatchTestHook(server, hitCriticalThreshold, VM.getController());\n \n-    AsyncInvocation queryExecution = invokeClientQuery(client, regionName,\n-        disabledQueryMonitorForLowMem, queryTimeout, hitCriticalThreshold);\n+    AsyncInvocation queryExecution = invokeClientQuery(client,\n+        disabledQueryMonitorForLowMem, queryTimeout, hitCriticalThreshold, VM.getController());\n \n     try {\n-      Thread.sleep(1000);\n+      criticalMemoryCountDownLatch.await();\n     } catch (InterruptedException e) {\n-      Thread.currentThread().interrupt();\n+      e.printStackTrace();\n     }\n+\n     // We simulate a low memory/critical heap percentage hit\n     if (hitCriticalThreshold) {\n       vmHitsCriticalHeap(server);\n+      await().until(() -> vmCheckCritcalHeap(server) == EVICTION_DISABLED_CRITICAL);\n     }\n \n     // Pause until query would time out if low memory was ignored\n     try {\n       Thread.sleep(MAX_TEST_QUERY_TIMEOUT);\n-    } catch (InterruptedException e) {\n+    } catch (InterruptedException e1) {\n       Thread.currentThread().interrupt();\n     }\n \n     // release the hook to have the query throw either a low memory or query timeout\n     // unless otherwise configured\n     releaseHook(server);\n \n-    ThreadUtils.join(queryExecution, 60000);\n-    // Make sure no exceptions were thrown during query testing\n     try {\n-      assertEquals(0, queryExecution.getResult());\n+      assertThat(queryExecution.get(60, SECONDS)).isEqualTo(0);\n     } catch (Throwable e) {\n       e.printStackTrace();\n       fail(\"queryExecution.getResult() threw Exception \" + e.toString());\n     }\n   }\n \n-  private void executeQueryWithCriticalHeapCalledAfterTimeout(VM server, VM client,\n-      final String regionName,\n-      final int queryTimeout,\n-      final boolean hitCriticalThreshold) {\n-    createLatchTestHook(server);\n-    AsyncInvocation queryExecution = executeQueryWithTimeout(client, regionName, queryTimeout);\n+  private void executeQueryWithCriticalHeapCalledAfterTimeout(VM server, VM client) {\n+    createLatchTestHook(server, false, VM.getController());\n+    AsyncInvocation queryExecution = executeQueryWithTimeout(client);\n \n     // Wait till the timeout expires on the query\n     try {\n-      Thread.sleep(queryTimeout + 1000);\n+      Thread.sleep(1 + TEST_QUERY_TIMEOUT);\n     } catch (InterruptedException e) {\n       Thread.currentThread().interrupt();\n     }\n     // We simulate a low memory/critical heap percentage hit\n     // But by design of this test the query must have been already terminated because of a 1ms\n     // timeout\n-    if (hitCriticalThreshold) {\n-      vmHitsCriticalHeap(server);\n-    }\n+    vmHitsCriticalHeap(server);\n \n     releaseHook(server);\n \n-    ThreadUtils.join(queryExecution, 60000);\n     // Make sure no exceptions were thrown during query testing\n     try {\n-      assertEquals(0, queryExecution.getResult());\n+      assertThat(queryExecution.get(60, SECONDS)).isEqualTo(0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzNzAyMw=="}, "originalCommit": {"oid": "40db9bd39c00a0468aa08ddc4541cd0d26d2f2b9"}, "originalPosition": 1220}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MTk2OTg1OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjowMDo1MlrOFpAHxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxOToyMDowM1rOFpgahg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzNzkyNA==", "bodyText": "Or:\nassertThat(region).isInstanceOf(PartitionedRegion.class);\n\nAlthough I would just delete this whole if-else block because the assertions are worthless.", "url": "https://github.com/apache/geode/pull/4691#discussion_r378537924", "createdAt": "2020-02-12T22:00:52Z", "author": {"login": "kirklund"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "diffHunk": "@@ -997,274 +850,185 @@ private void handleException(Exception e, boolean hitCriticalThreshold,\n       } else {\n         throw new CacheException(e) {};\n       }\n-    } else if (e instanceof ServerOperationException) {\n-      ServerOperationException soe = (ServerOperationException) e;\n-      if (soe.getRootCause() instanceof QueryExecutionLowMemoryException) {\n-        if (!(hitCriticalThreshold && disabledQueryMonitorForLowMem == false)) {\n-          // meaning the query should not be canceled due to low memory\n-          throw new CacheException(\"Query should not have been canceled due to memory\") {};\n-        }\n-      } else if (soe.getRootCause() instanceof QueryException) {\n-        QueryException qe = (QueryException) soe.getRootCause();\n-        if (isExceptionDueToLowMemory(qe, CRITICAL_HEAP_USED)) {\n-          if (!(hitCriticalThreshold && disabledQueryMonitorForLowMem == false)) {\n-            // meaning the query should not be canceled due to low memory\n-            throw new CacheException(\"Query should not have been canceled due to memory\") {};\n-          }\n-        } else if (isExceptionDueToTimeout(qe)) {\n-          if (queryTimeout == -1) {\n-            e.printStackTrace();\n-            // no time out set, this should not be thrown\n-            throw new CacheException(\n-                \"Query failed due to unexplained reason, should not have been a time out or low memory\") {};\n-          }\n-        } else {\n-          throw new CacheException(soe) {};\n-        }\n-      } else if (soe.getRootCause() instanceof QueryExecutionTimeoutException) {\n-        // if we have a queryTimeout set\n-        if (queryTimeout == -1) {\n-          // no time out set, this should not be thrown\n-          throw new CacheException(\n-              \"Query failed due to unexplained reason, should not have been a time out or low memory \"\n-                  + DefaultQuery.testHook.getClass().getName() + \" \" + soe.getRootCause()) {};\n-        }\n-      } else {\n-        throw new CacheException(soe) {};\n-      }\n     } else {\n       throw new CacheException(e) {};\n     }\n   }\n \n-\n   private void vmHitsCriticalHeap(VM vm) {\n-    vm.invoke(new CacheSerializableRunnable(\"vm hits critical heap\") {\n-      @Override\n-      public void run2() {\n-        InternalResourceManager resourceManager =\n-            (InternalResourceManager) getCache().getResourceManager();\n-        resourceManager.getHeapMonitor().updateStateAndSendEvent(CRITICAL_HEAP_USED, \"test\");\n-      }\n+    vm.invoke(\"vm hits critical heap\", () -> {\n+      InternalResourceManager resourceManager =\n+          (InternalResourceManager) getCache().getResourceManager();\n+      resourceManager.getHeapMonitor().updateStateAndSendEvent(CRITICAL_HEAP_USED, \"test\");\n     });\n   }\n \n+\n   private void vmRecoversFromCriticalHeap(VM vm) {\n-    vm.invoke(new CacheSerializableRunnable(\"vm hits critical heap\") {\n-      @Override\n-      public void run2() {\n-        InternalResourceManager resourceManager =\n-            (InternalResourceManager) getCache().getResourceManager();\n-        resourceManager.getHeapMonitor().updateStateAndSendEvent(NORMAL_HEAP_USED, \"test\");\n-      }\n+    vm.invoke(\"vm recovers from critical heap\", () -> {\n+      InternalResourceManager resourceManager =\n+          (InternalResourceManager) getCache().getResourceManager();\n+      resourceManager.getHeapMonitor().updateStateAndSendEvent(NORMAL_HEAP_USED, \"test\");\n     });\n   }\n \n-  private void createLatchTestHook(VM vm) {\n-    vm.invoke(new CacheSerializableRunnable(\"create latch test Hook\") {\n-      @Override\n-      public void run2() {\n-        DefaultQuery.TestHook hook = getPauseHook();\n-        DefaultQuery.testHook = hook;\n-      }\n+  private MemoryThresholds.MemoryState vmCheckCritcalHeap(VM vm) {\n+    return vm.invoke(\"vm check critical heap\", () -> {\n+      InternalResourceManager resourceManager =\n+          (InternalResourceManager) getCache().getResourceManager();\n+      return resourceManager.getHeapMonitor().getState();\n     });\n   }\n \n-  private void createCancelDuringGatherTestHook(VM vm) {\n-    vm.invoke(new CacheSerializableRunnable(\"create cancel during gather test Hook\") {\n-      @Override\n-      public void run2() {\n-        DefaultQuery.TestHook hook = getCancelDuringGatherHook();\n-        DefaultQuery.testHook = hook;\n-      }\n+  private static MemoryThresholds.MemoryState vmCheckCritcalHeap() {\n+    InternalResourceManager resourceManager =\n+        (InternalResourceManager) basicGetCache().getResourceManager();\n+    return resourceManager.getHeapMonitor().getState();\n+  }\n+\n+  private void createLatchTestHook(VM vm, boolean hitCriticalThreshold,\n+      VM vmToCallBack) {\n+    vm.invoke(\"create latch test Hook\", () -> {\n+      DefaultQuery.testHook = getPauseHook(hitCriticalThreshold, vmToCallBack);\n+    });\n+  }\n+\n+  private void createCancelDuringGatherTestHook(VM vm,\n+      VM vmToCallback) {\n+    vm.invoke(\"create cancel during gather test Hook\", () -> {\n+      DefaultQuery.testHook = getCancelDuringGatherHook(vmToCallback);\n     });\n   }\n \n   private void createCancelDuringAddResultsTestHook(VM vm) {\n-    vm.invoke(new CacheSerializableRunnable(\"create cancel during gather test Hook\") {\n-      @Override\n-      public void run2() {\n-        DefaultQuery.TestHook hook = getCancelDuringAddResultsHook();\n-        DefaultQuery.testHook = hook;\n-      }\n+    vm.invoke(\"create cancel during gather test Hook\", () -> {\n+      DefaultQuery.testHook = getCancelDuringAddResultsHook();\n     });\n   }\n \n \n   private void releaseHook(VM vm) {\n-    vm.invoke(new CacheSerializableRunnable(\"release latch Hook\") {\n-      @Override\n-      public void run2() {\n-        PauseTestHook hook = (PauseTestHook) DefaultQuery.testHook;\n-        hook.countDown();\n-      }\n+    vm.invoke(\"release latch Hook\", () -> {\n+      PauseTestHook hook = (PauseTestHook) DefaultQuery.testHook;\n+      hook.countDown();\n     });\n   }\n \n   // Verify that PRQueryEvaluator dropped objects if low memory\n-  private void verifyRejectedObjects(VM vm, final boolean disabledQueryMonitorForLowMem,\n-      final int queryTimeout, final boolean hitCriticalThreshold) {\n-    vm.invoke(new CacheSerializableRunnable(\"verify dropped objects\") {\n-      @Override\n-      public void run2() {\n-        if ((disabledQueryMonitorForLowMem == false && hitCriticalThreshold)) {\n-          if (DefaultQuery.testHook instanceof PauseTestHook) {\n-            PauseTestHook hook = (PauseTestHook) DefaultQuery.testHook;\n-            assertTrue(hook.rejectedObjects);\n-          } else if (DefaultQuery.testHook instanceof CancelDuringGatherHook) {\n-            CancelDuringGatherHook hook = (CancelDuringGatherHook) DefaultQuery.testHook;\n-            assertTrue(hook.rejectedObjects);\n-          } else if (DefaultQuery.testHook instanceof CancelDuringAddResultsHook) {\n-            CancelDuringAddResultsHook hook = (CancelDuringAddResultsHook) DefaultQuery.testHook;\n-            assertTrue(hook.rejectedObjects);\n-          }\n-        }\n+  private void verifyRejectedObjects(VM vm) {\n+    vm.invoke(\"verify dropped objects\", () -> {\n+      if (DefaultQuery.testHook instanceof PauseTestHook) {\n+        PauseTestHook hook = (PauseTestHook) DefaultQuery.testHook;\n+        assertThat(hook.rejectedObjects).isTrue();\n+      } else if (DefaultQuery.testHook instanceof CancelDuringGatherHook) {\n+        CancelDuringGatherHook hook = (CancelDuringGatherHook) DefaultQuery.testHook;\n+        assertThat(hook.rejectedObjects).isTrue();\n+      } else if (DefaultQuery.testHook instanceof CancelDuringAddResultsHook) {\n+        CancelDuringAddResultsHook hook = (CancelDuringAddResultsHook) DefaultQuery.testHook;\n+        assertThat(hook.rejectedObjects).isTrue();\n       }\n-\n     });\n   }\n \n-  private void populateData(VM vm, final String regionName, final int numObjects) {\n-    vm.invoke(new CacheSerializableRunnable(\"populate data for \" + regionName) {\n-      @Override\n-      public void run2() {\n-        Region region = getCache().getRegion(regionName);\n-        for (int i = 0; i < numObjects; i++) {\n-          region.put(\"key_\" + i, new Portfolio(i));\n-        }\n+  private void populateData(VM vm) {\n+    vm.invoke(\"populate data for \" + \"portfolios\", () -> {\n+      Region<String, Portfolio> region = getCache().getRegion(\"portfolios\");\n+      for (int i = 0; i < 200; i++) {\n+        region.put(\"key_\" + i, new Portfolio(i));\n       }\n     });\n   }\n \n   private void stopServer(VM server) {\n-    server.invoke(new SerializableCallable() {\n-      @Override\n-      public Object call() throws Exception {\n-        GemFireCacheImpl cache = (GemFireCacheImpl) getCache();\n-        cache.MAX_QUERY_EXECUTION_TIME = -1;\n-        return null;\n-      }\n+    server.invoke(() -> {\n+      GemFireCacheImpl cache = (GemFireCacheImpl) getCache();\n+      cache.MAX_QUERY_EXECUTION_TIME = -1;\n+      return null;\n     });\n   }\n \n-  private void startCacheServer(VM server, final int port, final int criticalThreshold,\n+  private void startCacheServer(VM server, final int port,\n       final boolean disableQueryMonitorForLowMemory,\n       final int queryTimeout,\n-      final String regionName, final boolean createPR,\n-      final int prRedundancy) throws Exception {\n-\n-    server.invoke(new SerializableCallable() {\n-      @Override\n-      public Object call() throws Exception {\n-        getSystem(getServerProperties(disableQueryMonitorForLowMemory, queryTimeout));\n-        if (disableQueryMonitorForLowMemory == true) {\n-          System.setProperty(\n-              GeodeGlossary.GEMFIRE_PREFIX + \"Cache.DISABLE_QUERY_MONITOR_FOR_LOW_MEMORY\",\n-              \"true\");\n-        } else {\n-          System.clearProperty(\n-              GeodeGlossary.GEMFIRE_PREFIX + \"Cache.DISABLE_QUERY_MONITOR_FOR_LOW_MEMORY\");\n-        }\n+      final boolean createPR) {\n+\n+    server.invoke(() -> {\n+      getSystem(getServerProperties());\n+      if (disableQueryMonitorForLowMemory) {\n+        System.setProperty(\n+            GeodeGlossary.GEMFIRE_PREFIX + \"Cache.DISABLE_QUERY_MONITOR_FOR_LOW_MEMORY\",\n+            \"true\");\n+      } else {\n+        System.clearProperty(\n+            GeodeGlossary.GEMFIRE_PREFIX + \"Cache.DISABLE_QUERY_MONITOR_FOR_LOW_MEMORY\");\n+      }\n \n-        GemFireCacheImpl cache = (GemFireCacheImpl) getCache();\n+      GemFireCacheImpl cache = (GemFireCacheImpl) getCache();\n \n-        if (queryTimeout != -1) {\n-          cache.MAX_QUERY_EXECUTION_TIME = queryTimeout;\n-        } else {\n-          cache.MAX_QUERY_EXECUTION_TIME = -1;\n-        }\n+      cache.MAX_QUERY_EXECUTION_TIME = queryTimeout;\n \n-        if (criticalThreshold != 0) {\n-          InternalResourceManager resourceManager =\n-              (InternalResourceManager) cache.getResourceManager();\n-          HeapMemoryMonitor heapMonitor = resourceManager.getHeapMonitor();\n-          heapMonitor.setTestMaxMemoryBytes(1000);\n-          HeapMemoryMonitor.setTestBytesUsedForThresholdSet(NORMAL_HEAP_USED);\n-          resourceManager.setCriticalHeapPercentage(criticalThreshold);\n-        }\n+      InternalResourceManager resourceManager =\n+          (InternalResourceManager) cache.getResourceManager();\n+      HeapMemoryMonitor heapMonitor = resourceManager.getHeapMonitor();\n+      heapMonitor.setTestMaxMemoryBytes(1000);\n+      HeapMemoryMonitor.setTestBytesUsedForThresholdSet(NORMAL_HEAP_USED);\n+      resourceManager.setCriticalHeapPercentage(85);\n \n-        AttributesFactory factory = new AttributesFactory();\n-        if (createPR) {\n-          PartitionAttributesFactory paf = new PartitionAttributesFactory();\n-          paf.setRedundantCopies(prRedundancy);\n-          paf.setTotalNumBuckets(11);\n-          factory.setPartitionAttributes(paf.create());\n-        } else {\n-          factory.setScope(Scope.DISTRIBUTED_ACK);\n-          factory.setDataPolicy(DataPolicy.REPLICATE);\n-        }\n-        Region region = createRootRegion(regionName, factory.create());\n-        if (createPR) {\n-          assertTrue(region instanceof PartitionedRegion);\n-        } else {\n-          assertTrue(region instanceof DistributedRegion);\n-        }\n-        CacheServer cacheServer = getCache().addCacheServer();\n-        cacheServer.setPort(port);\n-        cacheServer.start();\n-\n-        return null;\n+      RegionFactory<String, Portfolio> factory = cache.createRegionFactory();\n+      if (createPR) {\n+        PartitionAttributesFactory paf = new PartitionAttributesFactory();\n+        paf.setRedundantCopies(0);\n+        paf.setTotalNumBuckets(11);\n+        factory.setPartitionAttributes(paf.create());\n+      } else {\n+        factory.setScope(Scope.DISTRIBUTED_ACK);\n+        factory.setDataPolicy(DataPolicy.REPLICATE);\n       }\n-    });\n-  }\n-\n-  private void startClient(VM client, final VM server, final int port, final String regionName) {\n-\n-    client.invoke(new CacheSerializableRunnable(\"Start client\") {\n-      @Override\n-      public void run2() throws CacheException {\n-        Properties props = getClientProps();\n-        getSystem(props);\n-\n-        final ClientCacheFactory ccf = new ClientCacheFactory(props);\n-        ccf.addPoolServer(NetworkUtils.getServerHostName(server.getHost()), port);\n-        ClientCache cache = (ClientCache) getClientCache(ccf);\n+      Region region = createRootRegion(\"portfolios\", factory);\n+      if (createPR) {\n+        assertThat(region instanceof PartitionedRegion).isTrue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40db9bd39c00a0468aa08ddc4541cd0d26d2f2b9"}, "originalPosition": 1727}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA2NzAxNA==", "bodyText": "Done.", "url": "https://github.com/apache/geode/pull/4691#discussion_r379067014", "createdAt": "2020-02-13T19:20:03Z", "author": {"login": "mhansonp"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "diffHunk": "@@ -997,274 +850,185 @@ private void handleException(Exception e, boolean hitCriticalThreshold,\n       } else {\n         throw new CacheException(e) {};\n       }\n-    } else if (e instanceof ServerOperationException) {\n-      ServerOperationException soe = (ServerOperationException) e;\n-      if (soe.getRootCause() instanceof QueryExecutionLowMemoryException) {\n-        if (!(hitCriticalThreshold && disabledQueryMonitorForLowMem == false)) {\n-          // meaning the query should not be canceled due to low memory\n-          throw new CacheException(\"Query should not have been canceled due to memory\") {};\n-        }\n-      } else if (soe.getRootCause() instanceof QueryException) {\n-        QueryException qe = (QueryException) soe.getRootCause();\n-        if (isExceptionDueToLowMemory(qe, CRITICAL_HEAP_USED)) {\n-          if (!(hitCriticalThreshold && disabledQueryMonitorForLowMem == false)) {\n-            // meaning the query should not be canceled due to low memory\n-            throw new CacheException(\"Query should not have been canceled due to memory\") {};\n-          }\n-        } else if (isExceptionDueToTimeout(qe)) {\n-          if (queryTimeout == -1) {\n-            e.printStackTrace();\n-            // no time out set, this should not be thrown\n-            throw new CacheException(\n-                \"Query failed due to unexplained reason, should not have been a time out or low memory\") {};\n-          }\n-        } else {\n-          throw new CacheException(soe) {};\n-        }\n-      } else if (soe.getRootCause() instanceof QueryExecutionTimeoutException) {\n-        // if we have a queryTimeout set\n-        if (queryTimeout == -1) {\n-          // no time out set, this should not be thrown\n-          throw new CacheException(\n-              \"Query failed due to unexplained reason, should not have been a time out or low memory \"\n-                  + DefaultQuery.testHook.getClass().getName() + \" \" + soe.getRootCause()) {};\n-        }\n-      } else {\n-        throw new CacheException(soe) {};\n-      }\n     } else {\n       throw new CacheException(e) {};\n     }\n   }\n \n-\n   private void vmHitsCriticalHeap(VM vm) {\n-    vm.invoke(new CacheSerializableRunnable(\"vm hits critical heap\") {\n-      @Override\n-      public void run2() {\n-        InternalResourceManager resourceManager =\n-            (InternalResourceManager) getCache().getResourceManager();\n-        resourceManager.getHeapMonitor().updateStateAndSendEvent(CRITICAL_HEAP_USED, \"test\");\n-      }\n+    vm.invoke(\"vm hits critical heap\", () -> {\n+      InternalResourceManager resourceManager =\n+          (InternalResourceManager) getCache().getResourceManager();\n+      resourceManager.getHeapMonitor().updateStateAndSendEvent(CRITICAL_HEAP_USED, \"test\");\n     });\n   }\n \n+\n   private void vmRecoversFromCriticalHeap(VM vm) {\n-    vm.invoke(new CacheSerializableRunnable(\"vm hits critical heap\") {\n-      @Override\n-      public void run2() {\n-        InternalResourceManager resourceManager =\n-            (InternalResourceManager) getCache().getResourceManager();\n-        resourceManager.getHeapMonitor().updateStateAndSendEvent(NORMAL_HEAP_USED, \"test\");\n-      }\n+    vm.invoke(\"vm recovers from critical heap\", () -> {\n+      InternalResourceManager resourceManager =\n+          (InternalResourceManager) getCache().getResourceManager();\n+      resourceManager.getHeapMonitor().updateStateAndSendEvent(NORMAL_HEAP_USED, \"test\");\n     });\n   }\n \n-  private void createLatchTestHook(VM vm) {\n-    vm.invoke(new CacheSerializableRunnable(\"create latch test Hook\") {\n-      @Override\n-      public void run2() {\n-        DefaultQuery.TestHook hook = getPauseHook();\n-        DefaultQuery.testHook = hook;\n-      }\n+  private MemoryThresholds.MemoryState vmCheckCritcalHeap(VM vm) {\n+    return vm.invoke(\"vm check critical heap\", () -> {\n+      InternalResourceManager resourceManager =\n+          (InternalResourceManager) getCache().getResourceManager();\n+      return resourceManager.getHeapMonitor().getState();\n     });\n   }\n \n-  private void createCancelDuringGatherTestHook(VM vm) {\n-    vm.invoke(new CacheSerializableRunnable(\"create cancel during gather test Hook\") {\n-      @Override\n-      public void run2() {\n-        DefaultQuery.TestHook hook = getCancelDuringGatherHook();\n-        DefaultQuery.testHook = hook;\n-      }\n+  private static MemoryThresholds.MemoryState vmCheckCritcalHeap() {\n+    InternalResourceManager resourceManager =\n+        (InternalResourceManager) basicGetCache().getResourceManager();\n+    return resourceManager.getHeapMonitor().getState();\n+  }\n+\n+  private void createLatchTestHook(VM vm, boolean hitCriticalThreshold,\n+      VM vmToCallBack) {\n+    vm.invoke(\"create latch test Hook\", () -> {\n+      DefaultQuery.testHook = getPauseHook(hitCriticalThreshold, vmToCallBack);\n+    });\n+  }\n+\n+  private void createCancelDuringGatherTestHook(VM vm,\n+      VM vmToCallback) {\n+    vm.invoke(\"create cancel during gather test Hook\", () -> {\n+      DefaultQuery.testHook = getCancelDuringGatherHook(vmToCallback);\n     });\n   }\n \n   private void createCancelDuringAddResultsTestHook(VM vm) {\n-    vm.invoke(new CacheSerializableRunnable(\"create cancel during gather test Hook\") {\n-      @Override\n-      public void run2() {\n-        DefaultQuery.TestHook hook = getCancelDuringAddResultsHook();\n-        DefaultQuery.testHook = hook;\n-      }\n+    vm.invoke(\"create cancel during gather test Hook\", () -> {\n+      DefaultQuery.testHook = getCancelDuringAddResultsHook();\n     });\n   }\n \n \n   private void releaseHook(VM vm) {\n-    vm.invoke(new CacheSerializableRunnable(\"release latch Hook\") {\n-      @Override\n-      public void run2() {\n-        PauseTestHook hook = (PauseTestHook) DefaultQuery.testHook;\n-        hook.countDown();\n-      }\n+    vm.invoke(\"release latch Hook\", () -> {\n+      PauseTestHook hook = (PauseTestHook) DefaultQuery.testHook;\n+      hook.countDown();\n     });\n   }\n \n   // Verify that PRQueryEvaluator dropped objects if low memory\n-  private void verifyRejectedObjects(VM vm, final boolean disabledQueryMonitorForLowMem,\n-      final int queryTimeout, final boolean hitCriticalThreshold) {\n-    vm.invoke(new CacheSerializableRunnable(\"verify dropped objects\") {\n-      @Override\n-      public void run2() {\n-        if ((disabledQueryMonitorForLowMem == false && hitCriticalThreshold)) {\n-          if (DefaultQuery.testHook instanceof PauseTestHook) {\n-            PauseTestHook hook = (PauseTestHook) DefaultQuery.testHook;\n-            assertTrue(hook.rejectedObjects);\n-          } else if (DefaultQuery.testHook instanceof CancelDuringGatherHook) {\n-            CancelDuringGatherHook hook = (CancelDuringGatherHook) DefaultQuery.testHook;\n-            assertTrue(hook.rejectedObjects);\n-          } else if (DefaultQuery.testHook instanceof CancelDuringAddResultsHook) {\n-            CancelDuringAddResultsHook hook = (CancelDuringAddResultsHook) DefaultQuery.testHook;\n-            assertTrue(hook.rejectedObjects);\n-          }\n-        }\n+  private void verifyRejectedObjects(VM vm) {\n+    vm.invoke(\"verify dropped objects\", () -> {\n+      if (DefaultQuery.testHook instanceof PauseTestHook) {\n+        PauseTestHook hook = (PauseTestHook) DefaultQuery.testHook;\n+        assertThat(hook.rejectedObjects).isTrue();\n+      } else if (DefaultQuery.testHook instanceof CancelDuringGatherHook) {\n+        CancelDuringGatherHook hook = (CancelDuringGatherHook) DefaultQuery.testHook;\n+        assertThat(hook.rejectedObjects).isTrue();\n+      } else if (DefaultQuery.testHook instanceof CancelDuringAddResultsHook) {\n+        CancelDuringAddResultsHook hook = (CancelDuringAddResultsHook) DefaultQuery.testHook;\n+        assertThat(hook.rejectedObjects).isTrue();\n       }\n-\n     });\n   }\n \n-  private void populateData(VM vm, final String regionName, final int numObjects) {\n-    vm.invoke(new CacheSerializableRunnable(\"populate data for \" + regionName) {\n-      @Override\n-      public void run2() {\n-        Region region = getCache().getRegion(regionName);\n-        for (int i = 0; i < numObjects; i++) {\n-          region.put(\"key_\" + i, new Portfolio(i));\n-        }\n+  private void populateData(VM vm) {\n+    vm.invoke(\"populate data for \" + \"portfolios\", () -> {\n+      Region<String, Portfolio> region = getCache().getRegion(\"portfolios\");\n+      for (int i = 0; i < 200; i++) {\n+        region.put(\"key_\" + i, new Portfolio(i));\n       }\n     });\n   }\n \n   private void stopServer(VM server) {\n-    server.invoke(new SerializableCallable() {\n-      @Override\n-      public Object call() throws Exception {\n-        GemFireCacheImpl cache = (GemFireCacheImpl) getCache();\n-        cache.MAX_QUERY_EXECUTION_TIME = -1;\n-        return null;\n-      }\n+    server.invoke(() -> {\n+      GemFireCacheImpl cache = (GemFireCacheImpl) getCache();\n+      cache.MAX_QUERY_EXECUTION_TIME = -1;\n+      return null;\n     });\n   }\n \n-  private void startCacheServer(VM server, final int port, final int criticalThreshold,\n+  private void startCacheServer(VM server, final int port,\n       final boolean disableQueryMonitorForLowMemory,\n       final int queryTimeout,\n-      final String regionName, final boolean createPR,\n-      final int prRedundancy) throws Exception {\n-\n-    server.invoke(new SerializableCallable() {\n-      @Override\n-      public Object call() throws Exception {\n-        getSystem(getServerProperties(disableQueryMonitorForLowMemory, queryTimeout));\n-        if (disableQueryMonitorForLowMemory == true) {\n-          System.setProperty(\n-              GeodeGlossary.GEMFIRE_PREFIX + \"Cache.DISABLE_QUERY_MONITOR_FOR_LOW_MEMORY\",\n-              \"true\");\n-        } else {\n-          System.clearProperty(\n-              GeodeGlossary.GEMFIRE_PREFIX + \"Cache.DISABLE_QUERY_MONITOR_FOR_LOW_MEMORY\");\n-        }\n+      final boolean createPR) {\n+\n+    server.invoke(() -> {\n+      getSystem(getServerProperties());\n+      if (disableQueryMonitorForLowMemory) {\n+        System.setProperty(\n+            GeodeGlossary.GEMFIRE_PREFIX + \"Cache.DISABLE_QUERY_MONITOR_FOR_LOW_MEMORY\",\n+            \"true\");\n+      } else {\n+        System.clearProperty(\n+            GeodeGlossary.GEMFIRE_PREFIX + \"Cache.DISABLE_QUERY_MONITOR_FOR_LOW_MEMORY\");\n+      }\n \n-        GemFireCacheImpl cache = (GemFireCacheImpl) getCache();\n+      GemFireCacheImpl cache = (GemFireCacheImpl) getCache();\n \n-        if (queryTimeout != -1) {\n-          cache.MAX_QUERY_EXECUTION_TIME = queryTimeout;\n-        } else {\n-          cache.MAX_QUERY_EXECUTION_TIME = -1;\n-        }\n+      cache.MAX_QUERY_EXECUTION_TIME = queryTimeout;\n \n-        if (criticalThreshold != 0) {\n-          InternalResourceManager resourceManager =\n-              (InternalResourceManager) cache.getResourceManager();\n-          HeapMemoryMonitor heapMonitor = resourceManager.getHeapMonitor();\n-          heapMonitor.setTestMaxMemoryBytes(1000);\n-          HeapMemoryMonitor.setTestBytesUsedForThresholdSet(NORMAL_HEAP_USED);\n-          resourceManager.setCriticalHeapPercentage(criticalThreshold);\n-        }\n+      InternalResourceManager resourceManager =\n+          (InternalResourceManager) cache.getResourceManager();\n+      HeapMemoryMonitor heapMonitor = resourceManager.getHeapMonitor();\n+      heapMonitor.setTestMaxMemoryBytes(1000);\n+      HeapMemoryMonitor.setTestBytesUsedForThresholdSet(NORMAL_HEAP_USED);\n+      resourceManager.setCriticalHeapPercentage(85);\n \n-        AttributesFactory factory = new AttributesFactory();\n-        if (createPR) {\n-          PartitionAttributesFactory paf = new PartitionAttributesFactory();\n-          paf.setRedundantCopies(prRedundancy);\n-          paf.setTotalNumBuckets(11);\n-          factory.setPartitionAttributes(paf.create());\n-        } else {\n-          factory.setScope(Scope.DISTRIBUTED_ACK);\n-          factory.setDataPolicy(DataPolicy.REPLICATE);\n-        }\n-        Region region = createRootRegion(regionName, factory.create());\n-        if (createPR) {\n-          assertTrue(region instanceof PartitionedRegion);\n-        } else {\n-          assertTrue(region instanceof DistributedRegion);\n-        }\n-        CacheServer cacheServer = getCache().addCacheServer();\n-        cacheServer.setPort(port);\n-        cacheServer.start();\n-\n-        return null;\n+      RegionFactory<String, Portfolio> factory = cache.createRegionFactory();\n+      if (createPR) {\n+        PartitionAttributesFactory paf = new PartitionAttributesFactory();\n+        paf.setRedundantCopies(0);\n+        paf.setTotalNumBuckets(11);\n+        factory.setPartitionAttributes(paf.create());\n+      } else {\n+        factory.setScope(Scope.DISTRIBUTED_ACK);\n+        factory.setDataPolicy(DataPolicy.REPLICATE);\n       }\n-    });\n-  }\n-\n-  private void startClient(VM client, final VM server, final int port, final String regionName) {\n-\n-    client.invoke(new CacheSerializableRunnable(\"Start client\") {\n-      @Override\n-      public void run2() throws CacheException {\n-        Properties props = getClientProps();\n-        getSystem(props);\n-\n-        final ClientCacheFactory ccf = new ClientCacheFactory(props);\n-        ccf.addPoolServer(NetworkUtils.getServerHostName(server.getHost()), port);\n-        ClientCache cache = (ClientCache) getClientCache(ccf);\n+      Region region = createRootRegion(\"portfolios\", factory);\n+      if (createPR) {\n+        assertThat(region instanceof PartitionedRegion).isTrue();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzNzkyNA=="}, "originalCommit": {"oid": "40db9bd39c00a0468aa08ddc4541cd0d26d2f2b9"}, "originalPosition": 1727}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MTk3MjU5OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjowMTo0NFrOFpAJeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxOToxNzoyM1rOFpgVNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzODM2Mg==", "bodyText": "I recommend changing the await to use the GeodeAwaitility.getTimeout().", "url": "https://github.com/apache/geode/pull/4691#discussion_r378538362", "createdAt": "2020-02-12T22:01:44Z", "author": {"login": "kirklund"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "diffHunk": "@@ -1273,73 +1037,123 @@ private boolean isExceptionDueToTimeout(QueryException e) {\n     String message = e.getMessage();\n     // -1 needs to be matched due to client/server set up, BaseCommand uses the\n     // MAX_QUERY_EXECUTION_TIME and not the testMaxQueryExecutionTime\n+\n     return (message.contains(\"The QueryMonitor thread may be sleeping longer than\")\n         || message.contains(\"Query execution canceled after exceeding max execution time\")\n         || message.contains(\n             String.format(\"Query execution canceled after exceeding max execution time %sms.\",\n                 -1)));\n   }\n \n-  private DefaultQuery.TestHook getPauseHook() {\n-    return new PauseTestHook();\n+  private DefaultQuery.TestHook getPauseHook(boolean hitCriticalThreshold,\n+      VM vmToCallback) {\n+    return new PauseTestHook(hitCriticalThreshold, vmToCallback);\n   }\n \n-  private DefaultQuery.TestHook getCancelDuringGatherHook() {\n-    return new CancelDuringGatherHook();\n+  private DefaultQuery.TestHook getCancelDuringGatherHook(VM vmToCallback) {\n+    return new CancelDuringGatherHook(true, vmToCallback);\n   }\n \n   private DefaultQuery.TestHook getCancelDuringAddResultsHook() {\n     return new CancelDuringAddResultsHook();\n   }\n \n-  private static class PauseTestHook implements DefaultQuery.TestHook {\n-    private CountDownLatch latch = new CountDownLatch(1);\n-    public boolean rejectedObjects = false;\n+  static class RejectedObjectsInterface {\n+    boolean rejectedObjects = false;\n+  }\n+\n+  private class PauseTestHook extends RejectedObjectsInterface implements DefaultQuery.TestHook {\n+    private final CountDownLatch latch = new CountDownLatch(1);\n+\n+    boolean hitCriticalThreshold;\n+    AtomicBoolean hitOnce = new AtomicBoolean(false);\n+    VM callbackVM;\n+\n+    PauseTestHook(boolean hitCriticalThreshold, VM vmToCallback) {\n+      super();\n+      this.hitCriticalThreshold = hitCriticalThreshold;\n+      callbackVM = vmToCallback;\n+    }\n \n     @Override\n     public void doTestHook(final SPOTS spot, final DefaultQuery _ignored,\n         final ExecutionContext executionContext) {\n       switch (spot) {\n         case BEFORE_QUERY_EXECUTION:\n           try {\n-            if (!latch.await(8, TimeUnit.SECONDS)) {\n-              fail(\"query was never unlatched\");\n+            if (!latch.await(8, SECONDS)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40db9bd39c00a0468aa08ddc4541cd0d26d2f2b9"}, "originalPosition": 1853}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA2NTY1NA==", "bodyText": "Done.", "url": "https://github.com/apache/geode/pull/4691#discussion_r379065654", "createdAt": "2020-02-13T19:17:23Z", "author": {"login": "mhansonp"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "diffHunk": "@@ -1273,73 +1037,123 @@ private boolean isExceptionDueToTimeout(QueryException e) {\n     String message = e.getMessage();\n     // -1 needs to be matched due to client/server set up, BaseCommand uses the\n     // MAX_QUERY_EXECUTION_TIME and not the testMaxQueryExecutionTime\n+\n     return (message.contains(\"The QueryMonitor thread may be sleeping longer than\")\n         || message.contains(\"Query execution canceled after exceeding max execution time\")\n         || message.contains(\n             String.format(\"Query execution canceled after exceeding max execution time %sms.\",\n                 -1)));\n   }\n \n-  private DefaultQuery.TestHook getPauseHook() {\n-    return new PauseTestHook();\n+  private DefaultQuery.TestHook getPauseHook(boolean hitCriticalThreshold,\n+      VM vmToCallback) {\n+    return new PauseTestHook(hitCriticalThreshold, vmToCallback);\n   }\n \n-  private DefaultQuery.TestHook getCancelDuringGatherHook() {\n-    return new CancelDuringGatherHook();\n+  private DefaultQuery.TestHook getCancelDuringGatherHook(VM vmToCallback) {\n+    return new CancelDuringGatherHook(true, vmToCallback);\n   }\n \n   private DefaultQuery.TestHook getCancelDuringAddResultsHook() {\n     return new CancelDuringAddResultsHook();\n   }\n \n-  private static class PauseTestHook implements DefaultQuery.TestHook {\n-    private CountDownLatch latch = new CountDownLatch(1);\n-    public boolean rejectedObjects = false;\n+  static class RejectedObjectsInterface {\n+    boolean rejectedObjects = false;\n+  }\n+\n+  private class PauseTestHook extends RejectedObjectsInterface implements DefaultQuery.TestHook {\n+    private final CountDownLatch latch = new CountDownLatch(1);\n+\n+    boolean hitCriticalThreshold;\n+    AtomicBoolean hitOnce = new AtomicBoolean(false);\n+    VM callbackVM;\n+\n+    PauseTestHook(boolean hitCriticalThreshold, VM vmToCallback) {\n+      super();\n+      this.hitCriticalThreshold = hitCriticalThreshold;\n+      callbackVM = vmToCallback;\n+    }\n \n     @Override\n     public void doTestHook(final SPOTS spot, final DefaultQuery _ignored,\n         final ExecutionContext executionContext) {\n       switch (spot) {\n         case BEFORE_QUERY_EXECUTION:\n           try {\n-            if (!latch.await(8, TimeUnit.SECONDS)) {\n-              fail(\"query was never unlatched\");\n+            if (!latch.await(8, SECONDS)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzODM2Mg=="}, "originalCommit": {"oid": "40db9bd39c00a0468aa08ddc4541cd0d26d2f2b9"}, "originalPosition": 1853}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MTk3NDMxOnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjowMjoyMVrOFpAKkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxOToxNzozMlrOFpgVfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzODY0Mw==", "bodyText": "Change all of the awaits to use GeodeAwaitility.getTimeout().", "url": "https://github.com/apache/geode/pull/4691#discussion_r378538643", "createdAt": "2020-02-12T22:02:21Z", "author": {"login": "kirklund"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "diffHunk": "@@ -1273,73 +1037,123 @@ private boolean isExceptionDueToTimeout(QueryException e) {\n     String message = e.getMessage();\n     // -1 needs to be matched due to client/server set up, BaseCommand uses the\n     // MAX_QUERY_EXECUTION_TIME and not the testMaxQueryExecutionTime\n+\n     return (message.contains(\"The QueryMonitor thread may be sleeping longer than\")\n         || message.contains(\"Query execution canceled after exceeding max execution time\")\n         || message.contains(\n             String.format(\"Query execution canceled after exceeding max execution time %sms.\",\n                 -1)));\n   }\n \n-  private DefaultQuery.TestHook getPauseHook() {\n-    return new PauseTestHook();\n+  private DefaultQuery.TestHook getPauseHook(boolean hitCriticalThreshold,\n+      VM vmToCallback) {\n+    return new PauseTestHook(hitCriticalThreshold, vmToCallback);\n   }\n \n-  private DefaultQuery.TestHook getCancelDuringGatherHook() {\n-    return new CancelDuringGatherHook();\n+  private DefaultQuery.TestHook getCancelDuringGatherHook(VM vmToCallback) {\n+    return new CancelDuringGatherHook(true, vmToCallback);\n   }\n \n   private DefaultQuery.TestHook getCancelDuringAddResultsHook() {\n     return new CancelDuringAddResultsHook();\n   }\n \n-  private static class PauseTestHook implements DefaultQuery.TestHook {\n-    private CountDownLatch latch = new CountDownLatch(1);\n-    public boolean rejectedObjects = false;\n+  static class RejectedObjectsInterface {\n+    boolean rejectedObjects = false;\n+  }\n+\n+  private class PauseTestHook extends RejectedObjectsInterface implements DefaultQuery.TestHook {\n+    private final CountDownLatch latch = new CountDownLatch(1);\n+\n+    boolean hitCriticalThreshold;\n+    AtomicBoolean hitOnce = new AtomicBoolean(false);\n+    VM callbackVM;\n+\n+    PauseTestHook(boolean hitCriticalThreshold, VM vmToCallback) {\n+      super();\n+      this.hitCriticalThreshold = hitCriticalThreshold;\n+      callbackVM = vmToCallback;\n+    }\n \n     @Override\n     public void doTestHook(final SPOTS spot, final DefaultQuery _ignored,\n         final ExecutionContext executionContext) {\n       switch (spot) {\n         case BEFORE_QUERY_EXECUTION:\n           try {\n-            if (!latch.await(8, TimeUnit.SECONDS)) {\n-              fail(\"query was never unlatched\");\n+            if (!latch.await(8, SECONDS)) {\n+              logger.warn(\"doTestHook latch took to long to release\");\n+              if (!latch.await(1, MINUTES)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40db9bd39c00a0468aa08ddc4541cd0d26d2f2b9"}, "originalPosition": 1855}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA2NTcyNw==", "bodyText": "Done.", "url": "https://github.com/apache/geode/pull/4691#discussion_r379065727", "createdAt": "2020-02-13T19:17:32Z", "author": {"login": "mhansonp"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/dunit/ResourceManagerWithQueryMonitorDUnitTest.java", "diffHunk": "@@ -1273,73 +1037,123 @@ private boolean isExceptionDueToTimeout(QueryException e) {\n     String message = e.getMessage();\n     // -1 needs to be matched due to client/server set up, BaseCommand uses the\n     // MAX_QUERY_EXECUTION_TIME and not the testMaxQueryExecutionTime\n+\n     return (message.contains(\"The QueryMonitor thread may be sleeping longer than\")\n         || message.contains(\"Query execution canceled after exceeding max execution time\")\n         || message.contains(\n             String.format(\"Query execution canceled after exceeding max execution time %sms.\",\n                 -1)));\n   }\n \n-  private DefaultQuery.TestHook getPauseHook() {\n-    return new PauseTestHook();\n+  private DefaultQuery.TestHook getPauseHook(boolean hitCriticalThreshold,\n+      VM vmToCallback) {\n+    return new PauseTestHook(hitCriticalThreshold, vmToCallback);\n   }\n \n-  private DefaultQuery.TestHook getCancelDuringGatherHook() {\n-    return new CancelDuringGatherHook();\n+  private DefaultQuery.TestHook getCancelDuringGatherHook(VM vmToCallback) {\n+    return new CancelDuringGatherHook(true, vmToCallback);\n   }\n \n   private DefaultQuery.TestHook getCancelDuringAddResultsHook() {\n     return new CancelDuringAddResultsHook();\n   }\n \n-  private static class PauseTestHook implements DefaultQuery.TestHook {\n-    private CountDownLatch latch = new CountDownLatch(1);\n-    public boolean rejectedObjects = false;\n+  static class RejectedObjectsInterface {\n+    boolean rejectedObjects = false;\n+  }\n+\n+  private class PauseTestHook extends RejectedObjectsInterface implements DefaultQuery.TestHook {\n+    private final CountDownLatch latch = new CountDownLatch(1);\n+\n+    boolean hitCriticalThreshold;\n+    AtomicBoolean hitOnce = new AtomicBoolean(false);\n+    VM callbackVM;\n+\n+    PauseTestHook(boolean hitCriticalThreshold, VM vmToCallback) {\n+      super();\n+      this.hitCriticalThreshold = hitCriticalThreshold;\n+      callbackVM = vmToCallback;\n+    }\n \n     @Override\n     public void doTestHook(final SPOTS spot, final DefaultQuery _ignored,\n         final ExecutionContext executionContext) {\n       switch (spot) {\n         case BEFORE_QUERY_EXECUTION:\n           try {\n-            if (!latch.await(8, TimeUnit.SECONDS)) {\n-              fail(\"query was never unlatched\");\n+            if (!latch.await(8, SECONDS)) {\n+              logger.warn(\"doTestHook latch took to long to release\");\n+              if (!latch.await(1, MINUTES)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzODY0Mw=="}, "originalCommit": {"oid": "40db9bd39c00a0468aa08ddc4541cd0d26d2f2b9"}, "originalPosition": 1855}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3769, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}