{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ1MDE0MjIx", "number": 5349, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNjowOTo1NlrOER4cpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxODo0Njo0NlrOER7fcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MTg2MDg3OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/netty/ExecutionHandlerContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNjowOTo1NlrOG21Usw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNjozNToxMlrOG22Iag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0OTkzOQ==", "bodyText": "Is there a test for this exception?", "url": "https://github.com/apache/geode/pull/5349#discussion_r460149939", "createdAt": "2020-07-24T16:09:56Z", "author": {"login": "ringles"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/netty/ExecutionHandlerContext.java", "diffHunk": "@@ -191,38 +199,121 @@ public void channelInactive(ChannelHandlerContext ctx) {\n     ctx.close();\n   }\n \n-  private void executeCommand(ChannelHandlerContext ctx, Command command) {\n-    RedisResponse response;\n-\n-    if (!isAuthenticated()) {\n-      response = handleUnAuthenticatedCommand(command);\n-      writeToChannel(response);\n-      return;\n+  private void startAsyncCommandExecution(Command command) {\n+    if (logger.isDebugEnabled()) {\n+      logger.debug(\"Starting execution of async Redis command: {}\", command);\n     }\n+    final long start = redisStats.startCommand(command.getCommandType());\n+    command.setAsyncStartTime(start);\n+    command.execute(this);\n+  }\n \n-    if (command.isUnsupported() && !allowUnsupportedCommands()) {\n-      writeToChannel(\n-          RedisResponse.error(command.getCommandType() + RedisConstants.ERROR_UNSUPPORTED_COMMAND));\n-      return;\n+  public void endAsyncCommandExecution(Command command, ByteBuf response) {\n+    synchronized (commandQueue) {\n+      Command head = takeFromCommandQueue();\n+      if (head != command) {\n+        throw new IllegalStateException(\n+            \"expected \" + command + \" but found \" + head + \" in the queue\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6b665614ac21b15a5f5dcbf48b85233bed9e976"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE2MzE3OA==", "bodyText": "No. This is basically a check to make sure the implementation is correct. It should never happen if it is.\nSo the only way I could think of getting it to happen under test would be to have a unit test that mocks takeFromCommandQueue to return a bogus command. But I don't see much value in adding that test.", "url": "https://github.com/apache/geode/pull/5349#discussion_r460163178", "createdAt": "2020-07-24T16:35:12Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/netty/ExecutionHandlerContext.java", "diffHunk": "@@ -191,38 +199,121 @@ public void channelInactive(ChannelHandlerContext ctx) {\n     ctx.close();\n   }\n \n-  private void executeCommand(ChannelHandlerContext ctx, Command command) {\n-    RedisResponse response;\n-\n-    if (!isAuthenticated()) {\n-      response = handleUnAuthenticatedCommand(command);\n-      writeToChannel(response);\n-      return;\n+  private void startAsyncCommandExecution(Command command) {\n+    if (logger.isDebugEnabled()) {\n+      logger.debug(\"Starting execution of async Redis command: {}\", command);\n     }\n+    final long start = redisStats.startCommand(command.getCommandType());\n+    command.setAsyncStartTime(start);\n+    command.execute(this);\n+  }\n \n-    if (command.isUnsupported() && !allowUnsupportedCommands()) {\n-      writeToChannel(\n-          RedisResponse.error(command.getCommandType() + RedisConstants.ERROR_UNSUPPORTED_COMMAND));\n-      return;\n+  public void endAsyncCommandExecution(Command command, ByteBuf response) {\n+    synchronized (commandQueue) {\n+      Command head = takeFromCommandQueue();\n+      if (head != command) {\n+        throw new IllegalStateException(\n+            \"expected \" + command + \" but found \" + head + \" in the queue\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0OTkzOQ=="}, "originalCommit": {"oid": "f6b665614ac21b15a5f5dcbf48b85233bed9e976"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MjM1MTIyOnYy", "diffSide": "RIGHT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/netty/ExecutionHandlerContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxODo0Mzo1NlrOG26B4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxOToyMDo1N1rOG27DLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIyNzA0MA==", "bodyText": "I think this might read a bit better like this:\n    synchronized (commandQueue) {\n      boolean isEmpty = commandQueue.isEmpty();\n      boolean isAsync = command.getCommandType().isAsync();\n      if (!isEmpty) {\n        commandQueue.offer(command);\n        return;\n      }\n      if (!isAsync) {\n        executeCommand(command);\n      } else {\n        commandQueue.offer(command);\n        startAsyncCommandExecution(command);\n      }\n    }", "url": "https://github.com/apache/geode/pull/5349#discussion_r460227040", "createdAt": "2020-07-24T18:43:56Z", "author": {"login": "jdeppe-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/netty/ExecutionHandlerContext.java", "diffHunk": "@@ -113,17 +114,19 @@ public ChannelFuture writeToChannel(RedisResponse response) {\n   @Override\n   public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n     Command command = (Command) msg;\n-    try {\n-      if (logger.isDebugEnabled()) {\n-        logger.debug(\"Executing Redis command: {}\", command);\n+    command.setChannelHandlerContext(ctx);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "728832147739278ec8b9847bdf113b4478e59203"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI0Mzc1Ng==", "bodyText": "Yes, and since isEmpty and isAsync are only used once I ended up changing it to this:\n    synchronized (commandQueue) {\n      if (!commandQueue.isEmpty()) {\n        commandQueue.offer(command);\n        return;\n      }\n      if (command.getCommandType().isAsync()) {\n        commandQueue.offer(command);\n        startAsyncCommandExecution(command);\n        return;\n      }\n      executeCommand(command);\n    }", "url": "https://github.com/apache/geode/pull/5349#discussion_r460243756", "createdAt": "2020-07-24T19:20:57Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/netty/ExecutionHandlerContext.java", "diffHunk": "@@ -113,17 +114,19 @@ public ChannelFuture writeToChannel(RedisResponse response) {\n   @Override\n   public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n     Command command = (Command) msg;\n-    try {\n-      if (logger.isDebugEnabled()) {\n-        logger.debug(\"Executing Redis command: {}\", command);\n+    command.setChannelHandlerContext(ctx);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIyNzA0MA=="}, "originalCommit": {"oid": "728832147739278ec8b9847bdf113b4478e59203"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MjM1OTU0OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/pubsub/PublishExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxODo0Njo0NlrOG26G0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxOTozNzozNVrOG27gww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIyODMwNg==", "bodyText": "I'd prefer to create a RedisResponse so that we keep netty specifics out of the executors.", "url": "https://github.com/apache/geode/pull/5349#discussion_r460228306", "createdAt": "2020-07-24T18:46:46Z", "author": {"login": "jdeppe-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/pubsub/PublishExecutor.java", "diffHunk": "@@ -27,12 +30,34 @@\n   @Override\n   public RedisResponse executeCommand(Command command,\n       ExecutionHandlerContext context) {\n-    List<byte[]> args = command.getProcessedCommand();\n-\n-    long publishCount =\n-        context.getPubSub().publish(getDataRegion(context), args.get(1), args.get(2));\n-\n-    return RedisResponse.integer(publishCount);\n+    context.getBackgroundExecutor().submit(new PublishingRunnable(context, command));\n+    return null;\n   }\n \n+  public static class PublishingRunnable implements Runnable {\n+\n+    private final ExecutionHandlerContext context;\n+    private final Command command;\n+\n+    public PublishingRunnable(ExecutionHandlerContext context, Command command) {\n+      this.context = context;\n+      this.command = command;\n+    }\n+\n+    @Override\n+    public void run() {\n+      List<byte[]> args = command.getProcessedCommand();\n+      byte[] channelName = args.get(1);\n+      byte[] message = args.get(2);\n+      try {\n+        long publishCount =\n+            context.getPubSub()\n+                .publish(context.getRegionProvider().getDataRegion(), channelName, message);\n+        ByteBuf response = Coder.getIntegerResponse(context.getByteBufAllocator(), publishCount);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "728832147739278ec8b9847bdf113b4478e59203"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI1MTMzMQ==", "bodyText": "Done. I also found one other place (in AbstractSubscription) that was not using RedisResponse. I change it also to do so and deleted the old writeToChannel(ByteBuf) which was no longer used after these changes.", "url": "https://github.com/apache/geode/pull/5349#discussion_r460251331", "createdAt": "2020-07-24T19:37:35Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/pubsub/PublishExecutor.java", "diffHunk": "@@ -27,12 +30,34 @@\n   @Override\n   public RedisResponse executeCommand(Command command,\n       ExecutionHandlerContext context) {\n-    List<byte[]> args = command.getProcessedCommand();\n-\n-    long publishCount =\n-        context.getPubSub().publish(getDataRegion(context), args.get(1), args.get(2));\n-\n-    return RedisResponse.integer(publishCount);\n+    context.getBackgroundExecutor().submit(new PublishingRunnable(context, command));\n+    return null;\n   }\n \n+  public static class PublishingRunnable implements Runnable {\n+\n+    private final ExecutionHandlerContext context;\n+    private final Command command;\n+\n+    public PublishingRunnable(ExecutionHandlerContext context, Command command) {\n+      this.context = context;\n+      this.command = command;\n+    }\n+\n+    @Override\n+    public void run() {\n+      List<byte[]> args = command.getProcessedCommand();\n+      byte[] channelName = args.get(1);\n+      byte[] message = args.get(2);\n+      try {\n+        long publishCount =\n+            context.getPubSub()\n+                .publish(context.getRegionProvider().getDataRegion(), channelName, message);\n+        ByteBuf response = Coder.getIntegerResponse(context.getByteBufAllocator(), publishCount);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIyODMwNg=="}, "originalCommit": {"oid": "728832147739278ec8b9847bdf113b4478e59203"}, "originalPosition": 45}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3908, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}