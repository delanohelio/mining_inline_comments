{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEyMDgxNTUx", "number": 5037, "title": "GEODE-8029: Delete orphaned drf files", "bodyText": "The OpLog initialization now delete unused drf files to prevent the\nproliferation of unused records and files within the system, which\ncan could cause members to fail during startup while recovering\ndisk-stores (especially when they are isolated for gateway-senders).\n\nAdded distributed tests.\nDelete orphaned drf files when deleting the corresponding\ncrf during recovery.\n\nThank you for submitting a contribution to Apache Geode.\nIn order to streamline the review of the contribution we ask you\nto ensure the following steps have been taken:\nFor all changes:\n\n\n Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?\n\n\n Has your PR been rebased against the latest commit within the target branch (typically develop)?\n\n\n Is your initial contribution a single, squashed commit?\n\n\n Does gradlew build run cleanly?\n\n\n Have you written or updated unit tests to verify your changes?\n\n\n If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under ASF 2.0?\n\n\nNote:\nPlease ensure that once the PR is submitted, check Concourse for build issues and\nsubmit an update to your PR as soon as possible. If you need help, please send an\nemail to dev@geode.apache.org.", "createdAt": "2020-05-01T10:40:30Z", "url": "https://github.com/apache/geode/pull/5037", "merged": true, "mergeCommit": {"oid": "be8ac497eb1ece588e9a6c299d6aab4feb192ed3"}, "closed": true, "closedAt": "2020-05-05T08:36:37Z", "author": {"login": "jujoramos"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcc_Rr_AH2gAyNDEyMDgxNTUxOjk1N2RkOTBjOGNkZGE0YTg1NzhkOTRmYmE2NThkODJkZjY0MDU3OGE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABceBZbCgFqTQwNTEwODgyNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "957dd90c8cdda4a8578d94fba658d82df640578a", "author": {"user": {"login": "jujoramos", "name": "Juan Jos\u00e9 Ramos"}}, "url": "https://github.com/apache/geode/commit/957dd90c8cdda4a8578d94fba658d82df640578a", "committedDate": "2020-05-01T10:39:18Z", "message": "GEODE-8029: Delete orphaned drf files\n\nThe OpLog initialization now delete unused drf files to prevent the\nproliferation of unused records and files within the system, which\ncan could cause members to fail during startup while recovering\ndisk-stores (especially when they are isolated for gateway-senders).\n\n- Added distributed tests.\n- Delete orphaned drf files when deleting the corresponding\n  crf during recovery."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0MjU3ODE3", "url": "https://github.com/apache/geode/pull/5037#pullrequestreview-404257817", "createdAt": "2020-05-01T16:30:33Z", "commit": {"oid": "957dd90c8cdda4a8578d94fba658d82df640578a"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxNjozMDozM1rOGPOjKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxNzoxMjo1NlrOGPPsrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYyMDIwMA==", "bodyText": "Instead of having two almost identical methods, might it be better to have one call the other to prevent code duplication? Or maybe mark this one as a test method for now?", "url": "https://github.com/apache/geode/pull/5037#discussion_r418620200", "createdAt": "2020-05-01T16:30:33Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/DiskStoreImpl.java", "diffHunk": "@@ -4279,6 +4279,28 @@ public static void validate(String name, File[] dirs) throws Exception {\n     }\n   }\n \n+  /**\n+   * Validates the disk-store in offline mode, and returns the validated DiskStore instance.\n+   * This method is an \"almost exact copy\" of {@link DiskStoreImpl#validate(String, File[])}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "957dd90c8cdda4a8578d94fba658d82df640578a"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYyMDc0Ng==", "bodyText": "This should be \"especially\".", "url": "https://github.com/apache/geode/pull/5037#discussion_r418620746", "createdAt": "2020-05-01T16:31:48Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/Oplog.java", "diffHunk": "@@ -937,14 +937,20 @@ void initAfterRecovery(boolean offline) {\n         // this.crf.raf.seek(this.crf.currSize);\n       } else if (!offline) {\n         // drf exists but crf has been deleted (because it was empty).\n-        // I don't think the drf needs to be opened. It is only used during\n-        // recovery.\n-        // At some point the compacter my identify that it can be deleted.\n         this.crf.RAFClosed = true;\n         deleteCRF();\n+\n+        // See GEODE-8029.\n+        // The drf file needs to be deleted, specially when the disk-store is *only* used by", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "957dd90c8cdda4a8578d94fba658d82df640578a"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYzMzEyNA==", "bodyText": "This test should be renamed.", "url": "https://github.com/apache/geode/pull/5037#discussion_r418633124", "createdAt": "2020-05-01T16:59:48Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/PersistentGatewaySenderWithIsolatedDiskStoreDistributedTest.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.DISTRIBUTED_SYSTEM_ID;\n+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;\n+import static org.apache.geode.distributed.ConfigurationProperties.REMOTE_LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.START_LOCATOR;\n+import static org.apache.geode.internal.AvailablePortHelper.getRandomAvailableTCPPortsForDUnitSite;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.File;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.cache.DiskStore;\n+import org.apache.geode.cache.DiskStoreFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.wan.GatewayReceiverFactory;\n+import org.apache.geode.cache.wan.GatewaySender;\n+import org.apache.geode.cache.wan.GatewaySenderFactory;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.DiskStoreImpl;\n+import org.apache.geode.internal.cache.RegionQueue;\n+import org.apache.geode.internal.cache.persistence.OplogType;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedDiskDirRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+import org.apache.geode.test.junit.rules.serializable.SerializableTestName;\n+\n+/**\n+ * Tests to verify WAN functionality when the gateway-sender(s) have isolated, non-shared with\n+ * other region(s), disk-store(s).\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PersistentGatewaySenderWithIsolatedDiskStoreDistributedTest implements Serializable {\n+  private static final String REGION_NAME = \"TestRegion\";\n+  private static final String DISK_STORE_ID = \"testDisk\";\n+  private static final String GATEWAY_SENDER_ID = \"testSender\";\n+  private static final String TEST_CASE_NAME = \"[{index}] {method}(RegionType:{0}, Parallel:{1})\";\n+  private int site1Port, site2Port;\n+  private VM serverCluster1, serverCluster2;\n+\n+  @Rule\n+  public CacheRule cacheRule = new CacheRule();\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule();\n+\n+  @Rule\n+  public SerializableTestName testName = new SerializableTestName();\n+\n+  @Rule\n+  public DistributedDiskDirRule distributedDiskDirRule = new DistributedDiskDirRule();\n+\n+  private Properties createLocatorConfiguration(int distributedSystemId, int localLocatorPort,\n+      int remoteLocatorPort) {\n+    Properties config = new Properties();\n+    config.setProperty(MCAST_PORT, \"0\");\n+    config.setProperty(DISTRIBUTED_SYSTEM_ID, String.valueOf(distributedSystemId));\n+    config.setProperty(LOCATORS, \"localhost[\" + localLocatorPort + ']');\n+    config.setProperty(REMOTE_LOCATORS, \"localhost[\" + remoteLocatorPort + ']');\n+    config.setProperty(START_LOCATOR,\n+        \"localhost[\" + localLocatorPort + \"],server=true,peer=true,hostname-for-clients=localhost\");\n+\n+    return config;\n+  }\n+\n+  private Properties createServerConfiguration(int localLocatorPort) {\n+    Properties config = new Properties();\n+    config.setProperty(MCAST_PORT, \"0\");\n+    config.setProperty(LOCATORS, \"localhost[\" + localLocatorPort + ']');\n+\n+    return config;\n+  }\n+\n+  private void createDiskStore() {\n+    String basePath = distributedDiskDirRule.getDiskDir().getAbsolutePath();\n+    File diskDirectory = new File(basePath + File.separator + DISK_STORE_ID);\n+    DiskStoreFactory diskStoreFactory = cacheRule.getCache().createDiskStoreFactory();\n+    diskStoreFactory.setAutoCompact(true);\n+    diskStoreFactory.setAllowForceCompaction(true);\n+    diskStoreFactory.setDiskDirs(new File[] {diskDirectory});\n+    diskStoreFactory.create(DISK_STORE_ID);\n+  }\n+\n+  private void createRegion(RegionShortcut regionShortcut) {\n+    cacheRule.getCache()\n+        .<String, String>createRegionFactory(regionShortcut)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void createGatewayReceiver() {\n+    GatewayReceiverFactory gatewayReceiverFactory =\n+        cacheRule.getCache().createGatewayReceiverFactory();\n+    gatewayReceiverFactory.setManualStart(false);\n+    gatewayReceiverFactory.create();\n+  }\n+\n+  private void createGatewaySender(boolean parallel, int remoteDistributedSystemId) {\n+    GatewaySenderFactory gatewaySenderFactory = cacheRule.getCache().createGatewaySenderFactory();\n+    gatewaySenderFactory.setParallel(parallel);\n+    gatewaySenderFactory.setDiskSynchronous(true);\n+    gatewaySenderFactory.setPersistenceEnabled(true);\n+    gatewaySenderFactory.setDiskStoreName(DISK_STORE_ID);\n+    gatewaySenderFactory.create(GATEWAY_SENDER_ID, remoteDistributedSystemId);\n+  }\n+\n+  private void createServerWithRegionAndGatewayReceiver(RegionShortcut regionShortcut) {\n+    createGatewayReceiver();\n+    createRegion(regionShortcut);\n+  }\n+\n+  private void createServerWithRegionAndPersistentGatewaySender(RegionShortcut regionShortcut,\n+      int remoteDistributedSystemId, boolean parallel) {\n+    createDiskStore();\n+    createRegion(regionShortcut);\n+    createGatewaySender(parallel, remoteDistributedSystemId);\n+    Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+    region.getAttributesMutator().addGatewaySenderId(GATEWAY_SENDER_ID);\n+  }\n+\n+  private void gracefullyDisconnect() {\n+    InternalDistributedSystem.getConnectedInstance().stopReconnectingNoDisconnect();\n+    InternalDistributedSystem.getConnectedInstance().disconnect();\n+    await()\n+        .untilAsserted(() -> assertThat(InternalDistributedSystem.getConnectedInstance()).isNull());\n+  }\n+\n+  private void awaitForQueueSize(int queueSize) {\n+    GatewaySender gatewaySender = cacheRule.getCache().getGatewaySender(GATEWAY_SENDER_ID);\n+    await().untilAsserted(() -> {\n+      Set<RegionQueue> queues = ((AbstractGatewaySender) gatewaySender).getQueues();\n+      int totalSize = queues.stream().mapToInt(RegionQueue::size).sum();\n+      assertThat(queueSize).isEqualTo(totalSize);\n+    });\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] regionAndGatewayTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    parameters.add(new Object[] {RegionShortcut.PARTITION, true});\n+    parameters.add(new Object[] {RegionShortcut.REPLICATE, false});\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() {\n+    VM locatorCluster1 = getVM(0);\n+    serverCluster1 = getVM(1);\n+    VM locatorCluster2 = getVM(2);\n+    serverCluster2 = getVM(3);\n+\n+    int[] ports = getRandomAvailableTCPPortsForDUnitSite(2);\n+    site1Port = ports[0];\n+    site2Port = ports[1];\n+\n+    // Start 2 sites, one locator and one server per site.\n+    locatorCluster1\n+        .invoke(() -> cacheRule.createCache(createLocatorConfiguration(1, site1Port, site2Port)));\n+    locatorCluster2\n+        .invoke(() -> cacheRule.createCache(createLocatorConfiguration(2, site2Port, site1Port)));\n+\n+    serverCluster1.invoke(() -> cacheRule.createCache(createServerConfiguration(site1Port)));\n+    serverCluster2.invoke(() -> cacheRule.createCache(createServerConfiguration(site2Port)));\n+  }\n+\n+  /**\n+   * The tests executes the following:\n+   * - Creates region and gateway-receiver on cluster2.\n+   * - Creates the region and gateway-sender on cluster1.\n+   * - Populates the region and waits until WAN replication has finished.\n+   * - Restarts server on cluster1, and stops it afterwards (the initial compaction occurs during\n+   * startup and the disk validation is done offline).\n+   * - Asserts that there are no orphaned drf files, neither compact-able records on the disks-tore.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"regionAndGatewayTypes\")\n+  public void diskStoreShouldBeCompactedOnMemberRestartWhenAllEventsHaveBeenDispatched(\n+      RegionShortcut regionShortcut, boolean parallel) throws Exception {\n+    final int entries = 100;\n+\n+    // Create Region and Receiver on Cluster2\n+    serverCluster2.invoke(() -> createServerWithRegionAndGatewayReceiver(regionShortcut));\n+\n+    // Create Region, DiskStore and Gateway on Cluster1\n+    String diskStorePath = serverCluster1.invoke(() -> {\n+      createServerWithRegionAndPersistentGatewaySender(regionShortcut, 2, parallel);\n+      DiskStore diskStore = cacheRule.getCache().findDiskStore(DISK_STORE_ID);\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      // Insert entries and wait for WAN replication to finish.\n+      IntStream.range(0, entries).forEach(value -> region.put(\"Key\" + value, \"Value\" + value));\n+      awaitForQueueSize(0);\n+\n+      return diskStore.getDiskDirs()[0].getAbsolutePath();\n+    });\n+\n+    // Wait for Cluster2 to receive all events.\n+    serverCluster2.invoke(() -> await().untilAsserted(\n+        () -> assertThat(cacheRule.getCache().getRegion(REGION_NAME).size()).isEqualTo(entries)));\n+\n+    // Restart and Stop Server on Cluster1\n+    serverCluster1.invoke(() -> {\n+      gracefullyDisconnect();\n+      cacheRule.createCache(createServerConfiguration(site1Port));\n+      createServerWithRegionAndPersistentGatewaySender(regionShortcut, 2, parallel);\n+      gracefullyDisconnect();\n+    });\n+\n+    // There should be no orphaned drf files, neither compact-able records on the disk-store.\n+    File gatewayDiskStore = new File(diskStorePath);\n+    assertThat(gatewayDiskStore.list())\n+        .hasSize(3)\n+        .contains(OplogType.BACKUP.getPrefix() + DISK_STORE_ID + \".if\")\n+        .contains(OplogType.BACKUP.getPrefix() + DISK_STORE_ID + \"_2.drf\")\n+        .contains(OplogType.BACKUP.getPrefix() + DISK_STORE_ID + \"_2.crf\");\n+\n+    DiskStore diskStore =\n+        DiskStoreImpl.offlineValidate(DISK_STORE_ID, new File[] {gatewayDiskStore});\n+    assertThat(((DiskStoreImpl) diskStore).getLiveEntryCount()).isEqualTo(0);\n+    assertThat(((DiskStoreImpl) diskStore).getDeadRecordCount()).isEqualTo(0);\n+  }\n+\n+  /**\n+   * The tests executes the following:\n+   * - Creates the region and a gateway-sender on cluster2.\n+   * - Populates the region and waits until all events have been enqueued.\n+   * - Restarts server on cluster2 and stops it afterwards (the initial compaction occurs during\n+   * startup and the validation is done offline).\n+   * - Verifies that there are no orphaned files neither compact-able records on the disk-store.\n+   * - Creates the region and a gateway-receiver on cluster1.\n+   * - Starts server on cluster2 again and waits for WAN replication to finish.\n+   * - Restart server on cluster2, and stop it afterwards (the initial compaction occurs during\n+   * startup and the validation is done offline).\n+   * - Asserts that there are no orphaned drf files, neither compact-able records on the disks-tore.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"regionAndGatewayTypes\")\n+  public void anotherTest(RegionShortcut regionShortcut, boolean parallel) throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "957dd90c8cdda4a8578d94fba658d82df640578a"}, "originalPosition": 271}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYzNDg0Ng==", "bodyText": "What about the cases where the region is PARTITION and parallel is false, or region is REPLICATE and parallel is true? Do those need to be covered?", "url": "https://github.com/apache/geode/pull/5037#discussion_r418634846", "createdAt": "2020-05-01T17:03:32Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/PersistentGatewaySenderWithIsolatedDiskStoreDistributedTest.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.DISTRIBUTED_SYSTEM_ID;\n+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;\n+import static org.apache.geode.distributed.ConfigurationProperties.REMOTE_LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.START_LOCATOR;\n+import static org.apache.geode.internal.AvailablePortHelper.getRandomAvailableTCPPortsForDUnitSite;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.File;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.cache.DiskStore;\n+import org.apache.geode.cache.DiskStoreFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.wan.GatewayReceiverFactory;\n+import org.apache.geode.cache.wan.GatewaySender;\n+import org.apache.geode.cache.wan.GatewaySenderFactory;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.DiskStoreImpl;\n+import org.apache.geode.internal.cache.RegionQueue;\n+import org.apache.geode.internal.cache.persistence.OplogType;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedDiskDirRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+import org.apache.geode.test.junit.rules.serializable.SerializableTestName;\n+\n+/**\n+ * Tests to verify WAN functionality when the gateway-sender(s) have isolated, non-shared with\n+ * other region(s), disk-store(s).\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PersistentGatewaySenderWithIsolatedDiskStoreDistributedTest implements Serializable {\n+  private static final String REGION_NAME = \"TestRegion\";\n+  private static final String DISK_STORE_ID = \"testDisk\";\n+  private static final String GATEWAY_SENDER_ID = \"testSender\";\n+  private static final String TEST_CASE_NAME = \"[{index}] {method}(RegionType:{0}, Parallel:{1})\";\n+  private int site1Port, site2Port;\n+  private VM serverCluster1, serverCluster2;\n+\n+  @Rule\n+  public CacheRule cacheRule = new CacheRule();\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule();\n+\n+  @Rule\n+  public SerializableTestName testName = new SerializableTestName();\n+\n+  @Rule\n+  public DistributedDiskDirRule distributedDiskDirRule = new DistributedDiskDirRule();\n+\n+  private Properties createLocatorConfiguration(int distributedSystemId, int localLocatorPort,\n+      int remoteLocatorPort) {\n+    Properties config = new Properties();\n+    config.setProperty(MCAST_PORT, \"0\");\n+    config.setProperty(DISTRIBUTED_SYSTEM_ID, String.valueOf(distributedSystemId));\n+    config.setProperty(LOCATORS, \"localhost[\" + localLocatorPort + ']');\n+    config.setProperty(REMOTE_LOCATORS, \"localhost[\" + remoteLocatorPort + ']');\n+    config.setProperty(START_LOCATOR,\n+        \"localhost[\" + localLocatorPort + \"],server=true,peer=true,hostname-for-clients=localhost\");\n+\n+    return config;\n+  }\n+\n+  private Properties createServerConfiguration(int localLocatorPort) {\n+    Properties config = new Properties();\n+    config.setProperty(MCAST_PORT, \"0\");\n+    config.setProperty(LOCATORS, \"localhost[\" + localLocatorPort + ']');\n+\n+    return config;\n+  }\n+\n+  private void createDiskStore() {\n+    String basePath = distributedDiskDirRule.getDiskDir().getAbsolutePath();\n+    File diskDirectory = new File(basePath + File.separator + DISK_STORE_ID);\n+    DiskStoreFactory diskStoreFactory = cacheRule.getCache().createDiskStoreFactory();\n+    diskStoreFactory.setAutoCompact(true);\n+    diskStoreFactory.setAllowForceCompaction(true);\n+    diskStoreFactory.setDiskDirs(new File[] {diskDirectory});\n+    diskStoreFactory.create(DISK_STORE_ID);\n+  }\n+\n+  private void createRegion(RegionShortcut regionShortcut) {\n+    cacheRule.getCache()\n+        .<String, String>createRegionFactory(regionShortcut)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void createGatewayReceiver() {\n+    GatewayReceiverFactory gatewayReceiverFactory =\n+        cacheRule.getCache().createGatewayReceiverFactory();\n+    gatewayReceiverFactory.setManualStart(false);\n+    gatewayReceiverFactory.create();\n+  }\n+\n+  private void createGatewaySender(boolean parallel, int remoteDistributedSystemId) {\n+    GatewaySenderFactory gatewaySenderFactory = cacheRule.getCache().createGatewaySenderFactory();\n+    gatewaySenderFactory.setParallel(parallel);\n+    gatewaySenderFactory.setDiskSynchronous(true);\n+    gatewaySenderFactory.setPersistenceEnabled(true);\n+    gatewaySenderFactory.setDiskStoreName(DISK_STORE_ID);\n+    gatewaySenderFactory.create(GATEWAY_SENDER_ID, remoteDistributedSystemId);\n+  }\n+\n+  private void createServerWithRegionAndGatewayReceiver(RegionShortcut regionShortcut) {\n+    createGatewayReceiver();\n+    createRegion(regionShortcut);\n+  }\n+\n+  private void createServerWithRegionAndPersistentGatewaySender(RegionShortcut regionShortcut,\n+      int remoteDistributedSystemId, boolean parallel) {\n+    createDiskStore();\n+    createRegion(regionShortcut);\n+    createGatewaySender(parallel, remoteDistributedSystemId);\n+    Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+    region.getAttributesMutator().addGatewaySenderId(GATEWAY_SENDER_ID);\n+  }\n+\n+  private void gracefullyDisconnect() {\n+    InternalDistributedSystem.getConnectedInstance().stopReconnectingNoDisconnect();\n+    InternalDistributedSystem.getConnectedInstance().disconnect();\n+    await()\n+        .untilAsserted(() -> assertThat(InternalDistributedSystem.getConnectedInstance()).isNull());\n+  }\n+\n+  private void awaitForQueueSize(int queueSize) {\n+    GatewaySender gatewaySender = cacheRule.getCache().getGatewaySender(GATEWAY_SENDER_ID);\n+    await().untilAsserted(() -> {\n+      Set<RegionQueue> queues = ((AbstractGatewaySender) gatewaySender).getQueues();\n+      int totalSize = queues.stream().mapToInt(RegionQueue::size).sum();\n+      assertThat(queueSize).isEqualTo(totalSize);\n+    });\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] regionAndGatewayTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    parameters.add(new Object[] {RegionShortcut.PARTITION, true});\n+    parameters.add(new Object[] {RegionShortcut.REPLICATE, false});", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "957dd90c8cdda4a8578d94fba658d82df640578a"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYzNTkwOQ==", "bodyText": "Is one server per cluster enough to test the behaviour with a parallel gateway sender here? Or is this a situation where that's not relevant?", "url": "https://github.com/apache/geode/pull/5037#discussion_r418635909", "createdAt": "2020-05-01T17:06:04Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/PersistentGatewaySenderWithIsolatedDiskStoreDistributedTest.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.DISTRIBUTED_SYSTEM_ID;\n+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;\n+import static org.apache.geode.distributed.ConfigurationProperties.REMOTE_LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.START_LOCATOR;\n+import static org.apache.geode.internal.AvailablePortHelper.getRandomAvailableTCPPortsForDUnitSite;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.File;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.cache.DiskStore;\n+import org.apache.geode.cache.DiskStoreFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.wan.GatewayReceiverFactory;\n+import org.apache.geode.cache.wan.GatewaySender;\n+import org.apache.geode.cache.wan.GatewaySenderFactory;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.DiskStoreImpl;\n+import org.apache.geode.internal.cache.RegionQueue;\n+import org.apache.geode.internal.cache.persistence.OplogType;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedDiskDirRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+import org.apache.geode.test.junit.rules.serializable.SerializableTestName;\n+\n+/**\n+ * Tests to verify WAN functionality when the gateway-sender(s) have isolated, non-shared with\n+ * other region(s), disk-store(s).\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PersistentGatewaySenderWithIsolatedDiskStoreDistributedTest implements Serializable {\n+  private static final String REGION_NAME = \"TestRegion\";\n+  private static final String DISK_STORE_ID = \"testDisk\";\n+  private static final String GATEWAY_SENDER_ID = \"testSender\";\n+  private static final String TEST_CASE_NAME = \"[{index}] {method}(RegionType:{0}, Parallel:{1})\";\n+  private int site1Port, site2Port;\n+  private VM serverCluster1, serverCluster2;\n+\n+  @Rule\n+  public CacheRule cacheRule = new CacheRule();\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule();\n+\n+  @Rule\n+  public SerializableTestName testName = new SerializableTestName();\n+\n+  @Rule\n+  public DistributedDiskDirRule distributedDiskDirRule = new DistributedDiskDirRule();\n+\n+  private Properties createLocatorConfiguration(int distributedSystemId, int localLocatorPort,\n+      int remoteLocatorPort) {\n+    Properties config = new Properties();\n+    config.setProperty(MCAST_PORT, \"0\");\n+    config.setProperty(DISTRIBUTED_SYSTEM_ID, String.valueOf(distributedSystemId));\n+    config.setProperty(LOCATORS, \"localhost[\" + localLocatorPort + ']');\n+    config.setProperty(REMOTE_LOCATORS, \"localhost[\" + remoteLocatorPort + ']');\n+    config.setProperty(START_LOCATOR,\n+        \"localhost[\" + localLocatorPort + \"],server=true,peer=true,hostname-for-clients=localhost\");\n+\n+    return config;\n+  }\n+\n+  private Properties createServerConfiguration(int localLocatorPort) {\n+    Properties config = new Properties();\n+    config.setProperty(MCAST_PORT, \"0\");\n+    config.setProperty(LOCATORS, \"localhost[\" + localLocatorPort + ']');\n+\n+    return config;\n+  }\n+\n+  private void createDiskStore() {\n+    String basePath = distributedDiskDirRule.getDiskDir().getAbsolutePath();\n+    File diskDirectory = new File(basePath + File.separator + DISK_STORE_ID);\n+    DiskStoreFactory diskStoreFactory = cacheRule.getCache().createDiskStoreFactory();\n+    diskStoreFactory.setAutoCompact(true);\n+    diskStoreFactory.setAllowForceCompaction(true);\n+    diskStoreFactory.setDiskDirs(new File[] {diskDirectory});\n+    diskStoreFactory.create(DISK_STORE_ID);\n+  }\n+\n+  private void createRegion(RegionShortcut regionShortcut) {\n+    cacheRule.getCache()\n+        .<String, String>createRegionFactory(regionShortcut)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void createGatewayReceiver() {\n+    GatewayReceiverFactory gatewayReceiverFactory =\n+        cacheRule.getCache().createGatewayReceiverFactory();\n+    gatewayReceiverFactory.setManualStart(false);\n+    gatewayReceiverFactory.create();\n+  }\n+\n+  private void createGatewaySender(boolean parallel, int remoteDistributedSystemId) {\n+    GatewaySenderFactory gatewaySenderFactory = cacheRule.getCache().createGatewaySenderFactory();\n+    gatewaySenderFactory.setParallel(parallel);\n+    gatewaySenderFactory.setDiskSynchronous(true);\n+    gatewaySenderFactory.setPersistenceEnabled(true);\n+    gatewaySenderFactory.setDiskStoreName(DISK_STORE_ID);\n+    gatewaySenderFactory.create(GATEWAY_SENDER_ID, remoteDistributedSystemId);\n+  }\n+\n+  private void createServerWithRegionAndGatewayReceiver(RegionShortcut regionShortcut) {\n+    createGatewayReceiver();\n+    createRegion(regionShortcut);\n+  }\n+\n+  private void createServerWithRegionAndPersistentGatewaySender(RegionShortcut regionShortcut,\n+      int remoteDistributedSystemId, boolean parallel) {\n+    createDiskStore();\n+    createRegion(regionShortcut);\n+    createGatewaySender(parallel, remoteDistributedSystemId);\n+    Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+    region.getAttributesMutator().addGatewaySenderId(GATEWAY_SENDER_ID);\n+  }\n+\n+  private void gracefullyDisconnect() {\n+    InternalDistributedSystem.getConnectedInstance().stopReconnectingNoDisconnect();\n+    InternalDistributedSystem.getConnectedInstance().disconnect();\n+    await()\n+        .untilAsserted(() -> assertThat(InternalDistributedSystem.getConnectedInstance()).isNull());\n+  }\n+\n+  private void awaitForQueueSize(int queueSize) {\n+    GatewaySender gatewaySender = cacheRule.getCache().getGatewaySender(GATEWAY_SENDER_ID);\n+    await().untilAsserted(() -> {\n+      Set<RegionQueue> queues = ((AbstractGatewaySender) gatewaySender).getQueues();\n+      int totalSize = queues.stream().mapToInt(RegionQueue::size).sum();\n+      assertThat(queueSize).isEqualTo(totalSize);\n+    });\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] regionAndGatewayTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    parameters.add(new Object[] {RegionShortcut.PARTITION, true});\n+    parameters.add(new Object[] {RegionShortcut.REPLICATE, false});\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() {\n+    VM locatorCluster1 = getVM(0);\n+    serverCluster1 = getVM(1);\n+    VM locatorCluster2 = getVM(2);\n+    serverCluster2 = getVM(3);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "957dd90c8cdda4a8578d94fba658d82df640578a"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYzOTAyMQ==", "bodyText": "Small nitpick. The number of entries in this test is 100, but in the other test in this class it's 1000. Could they be the same, for consistency?", "url": "https://github.com/apache/geode/pull/5037#discussion_r418639021", "createdAt": "2020-05-01T17:12:56Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/PersistentGatewaySenderWithIsolatedDiskStoreDistributedTest.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.DISTRIBUTED_SYSTEM_ID;\n+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;\n+import static org.apache.geode.distributed.ConfigurationProperties.REMOTE_LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.START_LOCATOR;\n+import static org.apache.geode.internal.AvailablePortHelper.getRandomAvailableTCPPortsForDUnitSite;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.File;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.cache.DiskStore;\n+import org.apache.geode.cache.DiskStoreFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.wan.GatewayReceiverFactory;\n+import org.apache.geode.cache.wan.GatewaySender;\n+import org.apache.geode.cache.wan.GatewaySenderFactory;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.DiskStoreImpl;\n+import org.apache.geode.internal.cache.RegionQueue;\n+import org.apache.geode.internal.cache.persistence.OplogType;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedDiskDirRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+import org.apache.geode.test.junit.rules.serializable.SerializableTestName;\n+\n+/**\n+ * Tests to verify WAN functionality when the gateway-sender(s) have isolated, non-shared with\n+ * other region(s), disk-store(s).\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PersistentGatewaySenderWithIsolatedDiskStoreDistributedTest implements Serializable {\n+  private static final String REGION_NAME = \"TestRegion\";\n+  private static final String DISK_STORE_ID = \"testDisk\";\n+  private static final String GATEWAY_SENDER_ID = \"testSender\";\n+  private static final String TEST_CASE_NAME = \"[{index}] {method}(RegionType:{0}, Parallel:{1})\";\n+  private int site1Port, site2Port;\n+  private VM serverCluster1, serverCluster2;\n+\n+  @Rule\n+  public CacheRule cacheRule = new CacheRule();\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule();\n+\n+  @Rule\n+  public SerializableTestName testName = new SerializableTestName();\n+\n+  @Rule\n+  public DistributedDiskDirRule distributedDiskDirRule = new DistributedDiskDirRule();\n+\n+  private Properties createLocatorConfiguration(int distributedSystemId, int localLocatorPort,\n+      int remoteLocatorPort) {\n+    Properties config = new Properties();\n+    config.setProperty(MCAST_PORT, \"0\");\n+    config.setProperty(DISTRIBUTED_SYSTEM_ID, String.valueOf(distributedSystemId));\n+    config.setProperty(LOCATORS, \"localhost[\" + localLocatorPort + ']');\n+    config.setProperty(REMOTE_LOCATORS, \"localhost[\" + remoteLocatorPort + ']');\n+    config.setProperty(START_LOCATOR,\n+        \"localhost[\" + localLocatorPort + \"],server=true,peer=true,hostname-for-clients=localhost\");\n+\n+    return config;\n+  }\n+\n+  private Properties createServerConfiguration(int localLocatorPort) {\n+    Properties config = new Properties();\n+    config.setProperty(MCAST_PORT, \"0\");\n+    config.setProperty(LOCATORS, \"localhost[\" + localLocatorPort + ']');\n+\n+    return config;\n+  }\n+\n+  private void createDiskStore() {\n+    String basePath = distributedDiskDirRule.getDiskDir().getAbsolutePath();\n+    File diskDirectory = new File(basePath + File.separator + DISK_STORE_ID);\n+    DiskStoreFactory diskStoreFactory = cacheRule.getCache().createDiskStoreFactory();\n+    diskStoreFactory.setAutoCompact(true);\n+    diskStoreFactory.setAllowForceCompaction(true);\n+    diskStoreFactory.setDiskDirs(new File[] {diskDirectory});\n+    diskStoreFactory.create(DISK_STORE_ID);\n+  }\n+\n+  private void createRegion(RegionShortcut regionShortcut) {\n+    cacheRule.getCache()\n+        .<String, String>createRegionFactory(regionShortcut)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void createGatewayReceiver() {\n+    GatewayReceiverFactory gatewayReceiverFactory =\n+        cacheRule.getCache().createGatewayReceiverFactory();\n+    gatewayReceiverFactory.setManualStart(false);\n+    gatewayReceiverFactory.create();\n+  }\n+\n+  private void createGatewaySender(boolean parallel, int remoteDistributedSystemId) {\n+    GatewaySenderFactory gatewaySenderFactory = cacheRule.getCache().createGatewaySenderFactory();\n+    gatewaySenderFactory.setParallel(parallel);\n+    gatewaySenderFactory.setDiskSynchronous(true);\n+    gatewaySenderFactory.setPersistenceEnabled(true);\n+    gatewaySenderFactory.setDiskStoreName(DISK_STORE_ID);\n+    gatewaySenderFactory.create(GATEWAY_SENDER_ID, remoteDistributedSystemId);\n+  }\n+\n+  private void createServerWithRegionAndGatewayReceiver(RegionShortcut regionShortcut) {\n+    createGatewayReceiver();\n+    createRegion(regionShortcut);\n+  }\n+\n+  private void createServerWithRegionAndPersistentGatewaySender(RegionShortcut regionShortcut,\n+      int remoteDistributedSystemId, boolean parallel) {\n+    createDiskStore();\n+    createRegion(regionShortcut);\n+    createGatewaySender(parallel, remoteDistributedSystemId);\n+    Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+    region.getAttributesMutator().addGatewaySenderId(GATEWAY_SENDER_ID);\n+  }\n+\n+  private void gracefullyDisconnect() {\n+    InternalDistributedSystem.getConnectedInstance().stopReconnectingNoDisconnect();\n+    InternalDistributedSystem.getConnectedInstance().disconnect();\n+    await()\n+        .untilAsserted(() -> assertThat(InternalDistributedSystem.getConnectedInstance()).isNull());\n+  }\n+\n+  private void awaitForQueueSize(int queueSize) {\n+    GatewaySender gatewaySender = cacheRule.getCache().getGatewaySender(GATEWAY_SENDER_ID);\n+    await().untilAsserted(() -> {\n+      Set<RegionQueue> queues = ((AbstractGatewaySender) gatewaySender).getQueues();\n+      int totalSize = queues.stream().mapToInt(RegionQueue::size).sum();\n+      assertThat(queueSize).isEqualTo(totalSize);\n+    });\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] regionAndGatewayTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    parameters.add(new Object[] {RegionShortcut.PARTITION, true});\n+    parameters.add(new Object[] {RegionShortcut.REPLICATE, false});\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() {\n+    VM locatorCluster1 = getVM(0);\n+    serverCluster1 = getVM(1);\n+    VM locatorCluster2 = getVM(2);\n+    serverCluster2 = getVM(3);\n+\n+    int[] ports = getRandomAvailableTCPPortsForDUnitSite(2);\n+    site1Port = ports[0];\n+    site2Port = ports[1];\n+\n+    // Start 2 sites, one locator and one server per site.\n+    locatorCluster1\n+        .invoke(() -> cacheRule.createCache(createLocatorConfiguration(1, site1Port, site2Port)));\n+    locatorCluster2\n+        .invoke(() -> cacheRule.createCache(createLocatorConfiguration(2, site2Port, site1Port)));\n+\n+    serverCluster1.invoke(() -> cacheRule.createCache(createServerConfiguration(site1Port)));\n+    serverCluster2.invoke(() -> cacheRule.createCache(createServerConfiguration(site2Port)));\n+  }\n+\n+  /**\n+   * The tests executes the following:\n+   * - Creates region and gateway-receiver on cluster2.\n+   * - Creates the region and gateway-sender on cluster1.\n+   * - Populates the region and waits until WAN replication has finished.\n+   * - Restarts server on cluster1, and stops it afterwards (the initial compaction occurs during\n+   * startup and the disk validation is done offline).\n+   * - Asserts that there are no orphaned drf files, neither compact-able records on the disks-tore.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"regionAndGatewayTypes\")\n+  public void diskStoreShouldBeCompactedOnMemberRestartWhenAllEventsHaveBeenDispatched(\n+      RegionShortcut regionShortcut, boolean parallel) throws Exception {\n+    final int entries = 100;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "957dd90c8cdda4a8578d94fba658d82df640578a"}, "originalPosition": 211}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d2571d16a499c606e3b6bc09fa0b140e641fd7c6", "author": {"user": {"login": "jujoramos", "name": "Juan Jos\u00e9 Ramos"}}, "url": "https://github.com/apache/geode/commit/d2571d16a499c606e3b6bc09fa0b140e641fd7c6", "committedDate": "2020-05-03T17:09:00Z", "message": "GEODE-8029: Changes requested by reviewers."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1MTA4ODI3", "url": "https://github.com/apache/geode/pull/5037#pullrequestreview-405108827", "createdAt": "2020-05-04T15:41:29Z", "commit": {"oid": "d2571d16a499c606e3b6bc09fa0b140e641fd7c6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4654, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}