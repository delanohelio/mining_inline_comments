{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDExOTY0OTQ0", "number": 5036, "title": "GEODE-8058: Create Dunit tests for EXPIRE, PEXPIRE, EXPIREAT, and PEXPIREAT", "bodyText": "Thank you for submitting a contribution to Apache Geode.\nIn order to streamline the review of the contribution we ask you\nto ensure the following steps have been taken:\nFor all changes:\n\n\n Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?\n\n\n Has your PR been rebased against the latest commit within the target branch (typically develop)?\n\n\n Is your initial contribution a single, squashed commit?\n\n\n Does gradlew build run cleanly?\n\n\n Have you written or updated unit tests to verify your changes?\n\n\n If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under ASF 2.0?\n\n\nNote:\nPlease ensure that once the PR is submitted, check Concourse for build issues and\nsubmit an update to your PR as soon as possible. If you need help, please send an\nemail to dev@geode.apache.org.", "createdAt": "2020-05-01T03:57:30Z", "url": "https://github.com/apache/geode/pull/5036", "merged": true, "mergeCommit": {"oid": "757b1ec94e43f1b3491b532ae93fc90005e442d2"}, "closed": true, "closedAt": "2020-05-08T18:32:13Z", "author": {"login": "jdeppe-pivotal"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcc5fhjgH2gAyNDExOTY0OTQ0OjgxYjkwNWE1ODVjYWM1MWVhZWQwNDJhMjJlYWUzY2NhM2EzYjg3ZWQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcfVeHTAFqTQwODQwMzgyNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "81b905a585cac51eaed042a22eae3cca3a3b87ed", "author": {"user": {"login": "ringles", "name": "Ray Ingles"}}, "url": "https://github.com/apache/geode/commit/81b905a585cac51eaed042a22eae3cca3a3b87ed", "committedDate": "2020-05-01T03:54:59Z", "message": "GEODE-8051: Create multi-node concurrency (distributed) tests for HSET and HMSET"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3a884591278bff2eea56cc2ca7299b03c7c2373", "author": {"user": {"login": "jdeppe-pivotal", "name": "Jens Deppe"}}, "url": "https://github.com/apache/geode/commit/c3a884591278bff2eea56cc2ca7299b03c7c2373", "committedDate": "2020-05-01T13:17:25Z", "message": "Fix issue introduced by prior merge\n\n- Apply IntelliJ cleanup suggestions\n\nAuthored-by: Jens Deppe <jdeppe@vmware.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e6f93fef48ae153d80f9d924cc3db7b0a229b11f", "author": {"user": {"login": "jhutchison", "name": "John Hutchison"}}, "url": "https://github.com/apache/geode/commit/e6f93fef48ae153d80f9d924cc3db7b0a229b11f", "committedDate": "2020-05-04T18:36:41Z", "message": "added todo comment for review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4a9c5f7494a74d63fda3e6ab877f257316b5cac", "author": {"user": {"login": "jdeppe-pivotal", "name": "Jens Deppe"}}, "url": "https://github.com/apache/geode/commit/a4a9c5f7494a74d63fda3e6ab877f257316b5cac", "committedDate": "2020-05-05T03:44:42Z", "message": "Revert \"added todo comment for review\"\n\nThis reverts commit e6f93fef48ae153d80f9d924cc3db7b0a229b11f."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7fd5ef50bdc3a15750c8e63ed5dac945d5e3ea66", "author": {"user": {"login": "sabbey37", "name": "Sarah"}}, "url": "https://github.com/apache/geode/commit/7fd5ef50bdc3a15750c8e63ed5dac945d5e3ea66", "committedDate": "2020-05-05T13:40:10Z", "message": "Adds back lost expire tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1ODQ0MzQx", "url": "https://github.com/apache/geode/pull/5036#pullrequestreview-405844341", "createdAt": "2020-05-05T14:28:26Z", "commit": {"oid": "7fd5ef50bdc3a15750c8e63ed5dac945d5e3ea66"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNDoyODoyNlrOGQsH0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNDozNDoxMlrOGQsYug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE1MzI5OQ==", "bodyText": "this is the same as the one above except for the extra.  Can we combine them, or have mutually exclusive asserts?", "url": "https://github.com/apache/geode/pull/5036#discussion_r420153299", "createdAt": "2020-05-05T14:28:26Z", "author": {"login": "prettyClouds"}, "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/executors/ExpireDUnitTest.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis.executors;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.MAX_WAIT_TIME_RECONNECT;\n+import static org.apache.geode.distributed.ConfigurationProperties.REDIS_BIND_ADDRESS;\n+import static org.apache.geode.distributed.ConfigurationProperties.REDIS_PORT;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.Properties;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import redis.clients.jedis.Jedis;\n+\n+import org.apache.geode.internal.AvailablePortHelper;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.redis.internal.ByteArrayWrapper;\n+import org.apache.geode.redis.internal.GeodeRedisService;\n+import org.apache.geode.redis.internal.executor.TTLExecutor;\n+import org.apache.geode.test.awaitility.GeodeAwaitility;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+\n+@Ignore(\"GEODE-8058: this test needs to pass to have feature parity with native redis\")\n+public class ExpireDUnitTest {\n+\n+  @ClassRule\n+  public static ClusterStartupRule clusterStartUp = new ClusterStartupRule(4);\n+\n+  static final String LOCAL_HOST = \"127.0.0.1\";\n+  static int[] availablePorts;\n+  private static final int JEDIS_TIMEOUT =\n+      Math.toIntExact(GeodeAwaitility.getTimeout().toMillis());\n+  static Jedis jedis1;\n+  static Jedis jedis2;\n+  static Jedis jedis3;\n+\n+  static Properties locatorProperties;\n+  static Properties serverProperties1;\n+  static Properties serverProperties2;\n+  static Properties serverProperties3;\n+\n+  static MemberVM locator;\n+  static MemberVM server1;\n+  static MemberVM server2;\n+  static MemberVM server3;\n+\n+  @BeforeClass\n+  public static void classSetup() {\n+\n+    availablePorts = AvailablePortHelper.getRandomAvailableTCPPorts(3);\n+\n+    locatorProperties = new Properties();\n+    serverProperties1 = new Properties();\n+    serverProperties2 = new Properties();\n+    serverProperties3 = new Properties();\n+\n+    locatorProperties.setProperty(MAX_WAIT_TIME_RECONNECT, \"15000\");\n+\n+    serverProperties1.setProperty(REDIS_PORT, Integer.toString(availablePorts[0]));\n+    serverProperties1.setProperty(REDIS_BIND_ADDRESS, LOCAL_HOST);\n+\n+    serverProperties2.setProperty(REDIS_PORT, Integer.toString(availablePorts[1]));\n+    serverProperties2.setProperty(REDIS_BIND_ADDRESS, LOCAL_HOST);\n+\n+    serverProperties3.setProperty(REDIS_PORT, Integer.toString(availablePorts[2]));\n+    serverProperties3.setProperty(REDIS_BIND_ADDRESS, LOCAL_HOST);\n+\n+    locator = clusterStartUp.startLocatorVM(0, locatorProperties);\n+    server1 = clusterStartUp.startServerVM(1, serverProperties1, locator.getPort());\n+    server2 = clusterStartUp.startServerVM(2, serverProperties2, locator.getPort());\n+    server3 = clusterStartUp.startServerVM(3, serverProperties3, locator.getPort());\n+\n+    jedis1 = new Jedis(LOCAL_HOST, availablePorts[0], JEDIS_TIMEOUT);\n+    jedis2 = new Jedis(LOCAL_HOST, availablePorts[1], JEDIS_TIMEOUT);\n+    jedis3 = new Jedis(LOCAL_HOST, availablePorts[2], JEDIS_TIMEOUT);\n+  }\n+\n+  @After\n+  public void testCleanUp() {\n+    jedis1.flushAll();\n+  }\n+\n+  @AfterClass\n+  public static void tearDown() {\n+    jedis1.disconnect();\n+    jedis2.disconnect();\n+    jedis3.disconnect();\n+\n+    server1.stop();\n+    server2.stop();\n+    server3.stop();\n+  }\n+\n+  @Test\n+  public void expireOnOneServer_shouldPropagateToAllServers() {\n+    String key = \"key\";\n+\n+    jedis1.set(key, \"value\");\n+    jedis1.expire(key, 20);\n+\n+    assertThat(jedis2.ttl(key)).isGreaterThan(0);\n+  }\n+\n+  @Test\n+  public void expireOnOneServer_shouldResultInKeyRemovalFromOtherServer() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fd5ef50bdc3a15750c8e63ed5dac945d5e3ea66"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE1NTEyNw==", "bodyText": "why do we need to check the internal state in the integration test?  everything else operates at the external, jedis level.", "url": "https://github.com/apache/geode/pull/5036#discussion_r420155127", "createdAt": "2020-05-05T14:30:46Z", "author": {"login": "prettyClouds"}, "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/executors/ExpireDUnitTest.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis.executors;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.MAX_WAIT_TIME_RECONNECT;\n+import static org.apache.geode.distributed.ConfigurationProperties.REDIS_BIND_ADDRESS;\n+import static org.apache.geode.distributed.ConfigurationProperties.REDIS_PORT;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.Properties;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import redis.clients.jedis.Jedis;\n+\n+import org.apache.geode.internal.AvailablePortHelper;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.redis.internal.ByteArrayWrapper;\n+import org.apache.geode.redis.internal.GeodeRedisService;\n+import org.apache.geode.redis.internal.executor.TTLExecutor;\n+import org.apache.geode.test.awaitility.GeodeAwaitility;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+\n+@Ignore(\"GEODE-8058: this test needs to pass to have feature parity with native redis\")\n+public class ExpireDUnitTest {\n+\n+  @ClassRule\n+  public static ClusterStartupRule clusterStartUp = new ClusterStartupRule(4);\n+\n+  static final String LOCAL_HOST = \"127.0.0.1\";\n+  static int[] availablePorts;\n+  private static final int JEDIS_TIMEOUT =\n+      Math.toIntExact(GeodeAwaitility.getTimeout().toMillis());\n+  static Jedis jedis1;\n+  static Jedis jedis2;\n+  static Jedis jedis3;\n+\n+  static Properties locatorProperties;\n+  static Properties serverProperties1;\n+  static Properties serverProperties2;\n+  static Properties serverProperties3;\n+\n+  static MemberVM locator;\n+  static MemberVM server1;\n+  static MemberVM server2;\n+  static MemberVM server3;\n+\n+  @BeforeClass\n+  public static void classSetup() {\n+\n+    availablePorts = AvailablePortHelper.getRandomAvailableTCPPorts(3);\n+\n+    locatorProperties = new Properties();\n+    serverProperties1 = new Properties();\n+    serverProperties2 = new Properties();\n+    serverProperties3 = new Properties();\n+\n+    locatorProperties.setProperty(MAX_WAIT_TIME_RECONNECT, \"15000\");\n+\n+    serverProperties1.setProperty(REDIS_PORT, Integer.toString(availablePorts[0]));\n+    serverProperties1.setProperty(REDIS_BIND_ADDRESS, LOCAL_HOST);\n+\n+    serverProperties2.setProperty(REDIS_PORT, Integer.toString(availablePorts[1]));\n+    serverProperties2.setProperty(REDIS_BIND_ADDRESS, LOCAL_HOST);\n+\n+    serverProperties3.setProperty(REDIS_PORT, Integer.toString(availablePorts[2]));\n+    serverProperties3.setProperty(REDIS_BIND_ADDRESS, LOCAL_HOST);\n+\n+    locator = clusterStartUp.startLocatorVM(0, locatorProperties);\n+    server1 = clusterStartUp.startServerVM(1, serverProperties1, locator.getPort());\n+    server2 = clusterStartUp.startServerVM(2, serverProperties2, locator.getPort());\n+    server3 = clusterStartUp.startServerVM(3, serverProperties3, locator.getPort());\n+\n+    jedis1 = new Jedis(LOCAL_HOST, availablePorts[0], JEDIS_TIMEOUT);\n+    jedis2 = new Jedis(LOCAL_HOST, availablePorts[1], JEDIS_TIMEOUT);\n+    jedis3 = new Jedis(LOCAL_HOST, availablePorts[2], JEDIS_TIMEOUT);\n+  }\n+\n+  @After\n+  public void testCleanUp() {\n+    jedis1.flushAll();\n+  }\n+\n+  @AfterClass\n+  public static void tearDown() {\n+    jedis1.disconnect();\n+    jedis2.disconnect();\n+    jedis3.disconnect();\n+\n+    server1.stop();\n+    server2.stop();\n+    server3.stop();\n+  }\n+\n+  @Test\n+  public void expireOnOneServer_shouldPropagateToAllServers() {\n+    String key = \"key\";\n+\n+    jedis1.set(key, \"value\");\n+    jedis1.expire(key, 20);\n+\n+    assertThat(jedis2.ttl(key)).isGreaterThan(0);\n+  }\n+\n+  @Test\n+  public void expireOnOneServer_shouldResultInKeyRemovalFromOtherServer() {\n+    String key = \"key\";\n+\n+    jedis1.set(key, \"value\");\n+    jedis1.expire(key, 2);\n+\n+    assertThat(jedis2.ttl(key)).isGreaterThan(0);\n+    GeodeAwaitility.await().until(() -> jedis2.ttl(key) == TTLExecutor.NOT_EXISTS);\n+  }\n+\n+  @Test\n+  public void whenExpirationIsSet_andIsUpdatedOnAnotherServer_itIsReflectedOnFirstServer() {\n+    String key = \"key\";\n+\n+    jedis1.set(key, \"value\");\n+    jedis1.expire(key, 20);\n+    jedis2.expire(key, 10000);\n+\n+    assertThat(jedis1.ttl(key)).isGreaterThan(20L);\n+  }\n+\n+  @Test\n+  public void whenExpirationIsSet_andKeyIsResetOnAnotherServer_ttlIsRemovedOnFirstServer() {\n+    String key = \"key\";\n+\n+    jedis1.set(key, \"value\");\n+    jedis1.expire(key, 20);\n+    jedis2.set(key, \"newValue\");\n+\n+    assertThat(jedis1.ttl(key)).isEqualTo(TTLExecutor.NO_TIMEOUT);\n+  }\n+\n+  @Test\n+  public void whenExpirationIsSet_andKeyIsPersistedOnAnotherServer_ttlIsRemovedOnFirstServer() {\n+    String key = \"key\";\n+\n+    jedis1.set(key, \"value\");\n+    jedis1.expire(key, 20);\n+    jedis2.persist(key);\n+\n+    assertThat(jedis1.ttl(key)).isEqualTo(TTLExecutor.NO_TIMEOUT);\n+  }\n+\n+  @Test\n+  public void whenExpirationIsSet_andKeyIsDeletedOnAnotherServer_ttlReflectsChanges() {\n+    String key = \"key\";\n+\n+    jedis1.set(key, \"value\");\n+    jedis1.expire(key, 20);\n+    jedis2.del(key);\n+\n+    server1.invoke(() -> {\n+      InternalCache cache = ClusterStartupRule.getCache();\n+      GeodeRedisService redisService = cache.getService(GeodeRedisService.class);\n+      boolean hasExpiration = redisService.getGeodeRedisServer().getRegionCache()\n+          .hasExpiration(new ByteArrayWrapper(key.getBytes()));\n+      assertThat(hasExpiration).as(\"expiration should not be set\").isFalse();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fd5ef50bdc3a15750c8e63ed5dac945d5e3ea66"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE1Njg2Nw==", "bodyText": "if we remove that internal check mentioned above, we don't need this getter.", "url": "https://github.com/apache/geode/pull/5036#discussion_r420156867", "createdAt": "2020-05-05T14:33:10Z", "author": {"login": "prettyClouds"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/GeodeRedisService.java", "diffHunk": "@@ -87,4 +88,9 @@ private void stopRedisServer() {\n   public CacheServiceMBeanBase getMBean() {\n     return null;\n   }\n+\n+  @VisibleForTesting\n+  public GeodeRedisServer getGeodeRedisServer() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fd5ef50bdc3a15750c8e63ed5dac945d5e3ea66"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE1NzYyNg==", "bodyText": "i thought this wasn't working...did we change expiration to make these distributed scenarios work?", "url": "https://github.com/apache/geode/pull/5036#discussion_r420157626", "createdAt": "2020-05-05T14:34:12Z", "author": {"login": "prettyClouds"}, "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/executors/ExpireDUnitTest.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis.executors;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.MAX_WAIT_TIME_RECONNECT;\n+import static org.apache.geode.distributed.ConfigurationProperties.REDIS_BIND_ADDRESS;\n+import static org.apache.geode.distributed.ConfigurationProperties.REDIS_PORT;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.Properties;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import redis.clients.jedis.Jedis;\n+\n+import org.apache.geode.internal.AvailablePortHelper;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.redis.internal.ByteArrayWrapper;\n+import org.apache.geode.redis.internal.GeodeRedisService;\n+import org.apache.geode.redis.internal.executor.TTLExecutor;\n+import org.apache.geode.test.awaitility.GeodeAwaitility;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+\n+@Ignore(\"GEODE-8058: this test needs to pass to have feature parity with native redis\")\n+public class ExpireDUnitTest {\n+\n+  @ClassRule\n+  public static ClusterStartupRule clusterStartUp = new ClusterStartupRule(4);\n+\n+  static final String LOCAL_HOST = \"127.0.0.1\";\n+  static int[] availablePorts;\n+  private static final int JEDIS_TIMEOUT =\n+      Math.toIntExact(GeodeAwaitility.getTimeout().toMillis());\n+  static Jedis jedis1;\n+  static Jedis jedis2;\n+  static Jedis jedis3;\n+\n+  static Properties locatorProperties;\n+  static Properties serverProperties1;\n+  static Properties serverProperties2;\n+  static Properties serverProperties3;\n+\n+  static MemberVM locator;\n+  static MemberVM server1;\n+  static MemberVM server2;\n+  static MemberVM server3;\n+\n+  @BeforeClass\n+  public static void classSetup() {\n+\n+    availablePorts = AvailablePortHelper.getRandomAvailableTCPPorts(3);\n+\n+    locatorProperties = new Properties();\n+    serverProperties1 = new Properties();\n+    serverProperties2 = new Properties();\n+    serverProperties3 = new Properties();\n+\n+    locatorProperties.setProperty(MAX_WAIT_TIME_RECONNECT, \"15000\");\n+\n+    serverProperties1.setProperty(REDIS_PORT, Integer.toString(availablePorts[0]));\n+    serverProperties1.setProperty(REDIS_BIND_ADDRESS, LOCAL_HOST);\n+\n+    serverProperties2.setProperty(REDIS_PORT, Integer.toString(availablePorts[1]));\n+    serverProperties2.setProperty(REDIS_BIND_ADDRESS, LOCAL_HOST);\n+\n+    serverProperties3.setProperty(REDIS_PORT, Integer.toString(availablePorts[2]));\n+    serverProperties3.setProperty(REDIS_BIND_ADDRESS, LOCAL_HOST);\n+\n+    locator = clusterStartUp.startLocatorVM(0, locatorProperties);\n+    server1 = clusterStartUp.startServerVM(1, serverProperties1, locator.getPort());\n+    server2 = clusterStartUp.startServerVM(2, serverProperties2, locator.getPort());\n+    server3 = clusterStartUp.startServerVM(3, serverProperties3, locator.getPort());\n+\n+    jedis1 = new Jedis(LOCAL_HOST, availablePorts[0], JEDIS_TIMEOUT);\n+    jedis2 = new Jedis(LOCAL_HOST, availablePorts[1], JEDIS_TIMEOUT);\n+    jedis3 = new Jedis(LOCAL_HOST, availablePorts[2], JEDIS_TIMEOUT);\n+  }\n+\n+  @After\n+  public void testCleanUp() {\n+    jedis1.flushAll();\n+  }\n+\n+  @AfterClass\n+  public static void tearDown() {\n+    jedis1.disconnect();\n+    jedis2.disconnect();\n+    jedis3.disconnect();\n+\n+    server1.stop();\n+    server2.stop();\n+    server3.stop();\n+  }\n+\n+  @Test\n+  public void expireOnOneServer_shouldPropagateToAllServers() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fd5ef50bdc3a15750c8e63ed5dac945d5e3ea66"}, "originalPosition": 114}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c443164f71bf085bee1cdef7592c93ebe5a84efb", "author": {"user": {"login": "sabbey37", "name": "Sarah"}}, "url": "https://github.com/apache/geode/commit/c443164f71bf085bee1cdef7592c93ebe5a84efb", "committedDate": "2020-05-05T15:16:44Z", "message": "PR changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4NDAzODI0", "url": "https://github.com/apache/geode/pull/5036#pullrequestreview-408403824", "createdAt": "2020-05-08T17:38:39Z", "commit": {"oid": "c443164f71bf085bee1cdef7592c93ebe5a84efb"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4651, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}