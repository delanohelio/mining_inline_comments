{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAzNTU2MDg3", "number": 5625, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQyMjowOToyNVrOEtrwcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNjoxMzo1NVrOEuEjtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MzM4Mjg5OnYy", "diffSide": "RIGHT", "path": "geode-dunit/src/main/java/org/apache/geode/test/dunit/internal/DUnitLauncher.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQyMjowOToyNVrOHhnT9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNzozMjozNVrOHiSnnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTAwOTE0MQ==", "bodyText": "This will fail on the first log file with suspect strings, and so will not report suspect strings from the remaining log files. If you move this check after the for loop in closeAndCheckForSuspects(), it will be able to report suspect strings from all log files.", "url": "https://github.com/apache/geode/pull/5625#discussion_r505009141", "createdAt": "2020-10-14T22:09:25Z", "author": {"login": "demery-pivotal"}, "path": "geode-dunit/src/main/java/org/apache/geode/test/dunit/internal/DUnitLauncher.java", "diffHunk": "@@ -343,59 +339,120 @@ public static void init(MasterRemote master) {\n     System.setProperty(LAUNCHED_PROPERTY, \"true\");\n   }\n \n+  private static List<File> getDunitSuspectFiles() {\n+    File[] suspectFiles = getDunitSuspectsDir()\n+        .listFiles((dir, name) -> name.startsWith(SUSPECT_FILENAME_PREFIX));\n+\n+    return Arrays.asList(suspectFiles);\n+  }\n+\n+  private static File getDunitSuspectsDir() {\n+    return Paths.get(getWorkspaceDir()).toFile();\n+  }\n+\n+  private static void deleteDunitSuspectFiles() {\n+    getDunitSuspectFiles().forEach(File::delete);\n+  }\n+\n+  private static File createDunitSuspectFile(int vmId, String workingDir) {\n+    String suffix;\n+\n+    switch (vmId) {\n+      case -2:\n+        suffix = \"locator\";\n+        break;\n+      case -1:\n+        suffix = \"local\";\n+        break;\n+      default:\n+        suffix = \"vm\" + vmId;\n+    }\n+\n+    File dunitSuspect = new File(getDunitSuspectsDir(),\n+        String.format(\"%s-%s.log\", SUSPECT_FILENAME_PREFIX, suffix));\n+    dunitSuspect.deleteOnExit();\n+\n+    return dunitSuspect;\n+  }\n+\n+  private static String getWorkspaceDir() {\n+    String workspaceDir = System.getProperty(DUnitLauncher.WORKSPACE_DIR_PARAM);\n+    workspaceDir = workspaceDir == null ? new File(\".\").getAbsolutePath() : workspaceDir;\n+\n+    return workspaceDir;\n+  }\n+\n   public static void closeAndCheckForSuspects() {\n-    if (isLaunched()) {\n-      final List<Pattern> expectedStrings = ExpectedStrings.create(\"dunit\");\n-      final LogConsumer logConsumer = new LogConsumer(true, expectedStrings, \"log4j\", 5);\n+    if (!isLaunched()) {\n+      return;\n+    }\n \n-      final StringBuilder suspectStringBuilder = new StringBuilder();\n+    List<File> suspectFiles = getDunitSuspectFiles();\n \n-      BufferedReader buffReader = null;\n-      FileChannel fileChannel = null;\n-      try {\n-        fileChannel = new FileOutputStream(DUNIT_SUSPECT_FILE, true).getChannel();\n-        buffReader = new BufferedReader(new FileReader(DUNIT_SUSPECT_FILE));\n-      } catch (FileNotFoundException e) {\n-        System.err.println(\"Could not find the suspect string output file: \" + e);\n-        return;\n-      }\n+    if (suspectFiles.isEmpty()) {\n+      throw new IllegalStateException(\"No dunit suspect log files found in '\"\n+          + getDunitSuspectsDir().getAbsolutePath()\n+          + \"' - perhaps a rule that is cleaning up before suspect processing has already run.\");\n+    }\n+\n+    for (File suspect : suspectFiles) {\n+      checkSuspectFile(suspect);\n+    }\n+  }\n+\n+  public static void checkSuspectFile(File suspectFile) {\n+    final List<Pattern> expectedStrings = ExpectedStrings.create(\"dunit\");\n+    final LogConsumer logConsumer = new LogConsumer(true, expectedStrings,\n+        suspectFile.getName(), 5);\n+\n+    final StringBuilder suspectStringBuilder = new StringBuilder();\n+\n+    BufferedReader buffReader;\n+    FileChannel fileChannel;\n+    try {\n+      fileChannel = new FileOutputStream(suspectFile, true).getChannel();\n+      buffReader = new BufferedReader(new FileReader(suspectFile));\n+    } catch (FileNotFoundException e) {\n+      System.err.println(\"Could not find the suspect string output file: \" + e);\n+      return;\n+    }\n+\n+    try {\n+      String line;\n       try {\n-        String line;\n-        try {\n-          while ((line = buffReader.readLine()) != null) {\n-            final StringBuilder builder = logConsumer.consume(line);\n-            if (builder != null) {\n-              suspectStringBuilder.append(builder);\n-            }\n+        while ((line = buffReader.readLine()) != null) {\n+          final StringBuilder builder = logConsumer.consume(line);\n+          if (builder != null) {\n+            suspectStringBuilder.append(builder);\n           }\n-        } catch (IOException e) {\n-          System.err.println(\"Could not read the suspect string output file: \" + e);\n         }\n+      } catch (IOException e) {\n+        System.err.println(\"Could not read the suspect string output file: \" + e);\n+      }\n \n-        try {\n-          fileChannel.truncate(0);\n-        } catch (IOException e) {\n-          System.err.println(\"Could not truncate the suspect string output file: \" + e);\n-        }\n+      try {\n+        fileChannel.truncate(0);\n+      } catch (IOException e) {\n+        System.err.println(\"Could not truncate the suspect string output file: \" + e);\n+      }\n \n-      } finally {\n-        try {\n-          buffReader.close();\n-          fileChannel.close();\n-        } catch (IOException e) {\n-          System.err.println(\"Could not close the suspect string output file: \" + e);\n-        }\n+    } finally {\n+      try {\n+        buffReader.close();\n+        fileChannel.close();\n+      } catch (IOException e) {\n+        System.err.println(\"Could not close the suspect string output file: \" + e);\n       }\n+    }\n \n-      if (suspectStringBuilder.length() != 0) {\n-        System.err.println(\"Suspicious strings were written to the log during this run.\\n\"\n-            + \"Fix the strings or use IgnoredException.addIgnoredException to ignore.\\n\"\n-            + suspectStringBuilder);\n+    if (suspectStringBuilder.length() != 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cd22023bf22f193cff2ff733610cba2cd40d7fe"}, "originalPosition": 207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcxODY4Nw==", "bodyText": "Good point! Functionally it's fixed but I will also apply your other suggestion.", "url": "https://github.com/apache/geode/pull/5625#discussion_r505718687", "createdAt": "2020-10-15T17:32:35Z", "author": {"login": "jdeppe-pivotal"}, "path": "geode-dunit/src/main/java/org/apache/geode/test/dunit/internal/DUnitLauncher.java", "diffHunk": "@@ -343,59 +339,120 @@ public static void init(MasterRemote master) {\n     System.setProperty(LAUNCHED_PROPERTY, \"true\");\n   }\n \n+  private static List<File> getDunitSuspectFiles() {\n+    File[] suspectFiles = getDunitSuspectsDir()\n+        .listFiles((dir, name) -> name.startsWith(SUSPECT_FILENAME_PREFIX));\n+\n+    return Arrays.asList(suspectFiles);\n+  }\n+\n+  private static File getDunitSuspectsDir() {\n+    return Paths.get(getWorkspaceDir()).toFile();\n+  }\n+\n+  private static void deleteDunitSuspectFiles() {\n+    getDunitSuspectFiles().forEach(File::delete);\n+  }\n+\n+  private static File createDunitSuspectFile(int vmId, String workingDir) {\n+    String suffix;\n+\n+    switch (vmId) {\n+      case -2:\n+        suffix = \"locator\";\n+        break;\n+      case -1:\n+        suffix = \"local\";\n+        break;\n+      default:\n+        suffix = \"vm\" + vmId;\n+    }\n+\n+    File dunitSuspect = new File(getDunitSuspectsDir(),\n+        String.format(\"%s-%s.log\", SUSPECT_FILENAME_PREFIX, suffix));\n+    dunitSuspect.deleteOnExit();\n+\n+    return dunitSuspect;\n+  }\n+\n+  private static String getWorkspaceDir() {\n+    String workspaceDir = System.getProperty(DUnitLauncher.WORKSPACE_DIR_PARAM);\n+    workspaceDir = workspaceDir == null ? new File(\".\").getAbsolutePath() : workspaceDir;\n+\n+    return workspaceDir;\n+  }\n+\n   public static void closeAndCheckForSuspects() {\n-    if (isLaunched()) {\n-      final List<Pattern> expectedStrings = ExpectedStrings.create(\"dunit\");\n-      final LogConsumer logConsumer = new LogConsumer(true, expectedStrings, \"log4j\", 5);\n+    if (!isLaunched()) {\n+      return;\n+    }\n \n-      final StringBuilder suspectStringBuilder = new StringBuilder();\n+    List<File> suspectFiles = getDunitSuspectFiles();\n \n-      BufferedReader buffReader = null;\n-      FileChannel fileChannel = null;\n-      try {\n-        fileChannel = new FileOutputStream(DUNIT_SUSPECT_FILE, true).getChannel();\n-        buffReader = new BufferedReader(new FileReader(DUNIT_SUSPECT_FILE));\n-      } catch (FileNotFoundException e) {\n-        System.err.println(\"Could not find the suspect string output file: \" + e);\n-        return;\n-      }\n+    if (suspectFiles.isEmpty()) {\n+      throw new IllegalStateException(\"No dunit suspect log files found in '\"\n+          + getDunitSuspectsDir().getAbsolutePath()\n+          + \"' - perhaps a rule that is cleaning up before suspect processing has already run.\");\n+    }\n+\n+    for (File suspect : suspectFiles) {\n+      checkSuspectFile(suspect);\n+    }\n+  }\n+\n+  public static void checkSuspectFile(File suspectFile) {\n+    final List<Pattern> expectedStrings = ExpectedStrings.create(\"dunit\");\n+    final LogConsumer logConsumer = new LogConsumer(true, expectedStrings,\n+        suspectFile.getName(), 5);\n+\n+    final StringBuilder suspectStringBuilder = new StringBuilder();\n+\n+    BufferedReader buffReader;\n+    FileChannel fileChannel;\n+    try {\n+      fileChannel = new FileOutputStream(suspectFile, true).getChannel();\n+      buffReader = new BufferedReader(new FileReader(suspectFile));\n+    } catch (FileNotFoundException e) {\n+      System.err.println(\"Could not find the suspect string output file: \" + e);\n+      return;\n+    }\n+\n+    try {\n+      String line;\n       try {\n-        String line;\n-        try {\n-          while ((line = buffReader.readLine()) != null) {\n-            final StringBuilder builder = logConsumer.consume(line);\n-            if (builder != null) {\n-              suspectStringBuilder.append(builder);\n-            }\n+        while ((line = buffReader.readLine()) != null) {\n+          final StringBuilder builder = logConsumer.consume(line);\n+          if (builder != null) {\n+            suspectStringBuilder.append(builder);\n           }\n-        } catch (IOException e) {\n-          System.err.println(\"Could not read the suspect string output file: \" + e);\n         }\n+      } catch (IOException e) {\n+        System.err.println(\"Could not read the suspect string output file: \" + e);\n+      }\n \n-        try {\n-          fileChannel.truncate(0);\n-        } catch (IOException e) {\n-          System.err.println(\"Could not truncate the suspect string output file: \" + e);\n-        }\n+      try {\n+        fileChannel.truncate(0);\n+      } catch (IOException e) {\n+        System.err.println(\"Could not truncate the suspect string output file: \" + e);\n+      }\n \n-      } finally {\n-        try {\n-          buffReader.close();\n-          fileChannel.close();\n-        } catch (IOException e) {\n-          System.err.println(\"Could not close the suspect string output file: \" + e);\n-        }\n+    } finally {\n+      try {\n+        buffReader.close();\n+        fileChannel.close();\n+      } catch (IOException e) {\n+        System.err.println(\"Could not close the suspect string output file: \" + e);\n       }\n+    }\n \n-      if (suspectStringBuilder.length() != 0) {\n-        System.err.println(\"Suspicious strings were written to the log during this run.\\n\"\n-            + \"Fix the strings or use IgnoredException.addIgnoredException to ignore.\\n\"\n-            + suspectStringBuilder);\n+    if (suspectStringBuilder.length() != 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTAwOTE0MQ=="}, "originalCommit": {"oid": "2cd22023bf22f193cff2ff733610cba2cd40d7fe"}, "originalPosition": 207}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NzQ0NjMxOnYy", "diffSide": "RIGHT", "path": "geode-dunit/src/main/java/org/apache/geode/test/dunit/internal/DUnitLauncher.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNjoxMzo1NVrOHiPmIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNzozMzowN1rOHiSpHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY2OTE1Mg==", "bodyText": "An alternative is to create a StringBuilder here and pass it into checkSuspectFile() to collect the suspects. That way the strings can be included in the assertion failure message.", "url": "https://github.com/apache/geode/pull/5625#discussion_r505669152", "createdAt": "2020-10-15T16:13:55Z", "author": {"login": "demery-pivotal"}, "path": "geode-dunit/src/main/java/org/apache/geode/test/dunit/internal/DUnitLauncher.java", "diffHunk": "@@ -395,12 +395,18 @@ public static void closeAndCheckForSuspects() {\n           + \"' - perhaps a rule that is cleaning up before suspect processing has already run.\");\n     }\n \n+    boolean ok = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "225cb0875b1504d9ffddcfa8990cac1ab397568d"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcxOTA2OQ==", "bodyText": "Good idea - I'll apply that shortly.", "url": "https://github.com/apache/geode/pull/5625#discussion_r505719069", "createdAt": "2020-10-15T17:33:07Z", "author": {"login": "jdeppe-pivotal"}, "path": "geode-dunit/src/main/java/org/apache/geode/test/dunit/internal/DUnitLauncher.java", "diffHunk": "@@ -395,12 +395,18 @@ public static void closeAndCheckForSuspects() {\n           + \"' - perhaps a rule that is cleaning up before suspect processing has already run.\");\n     }\n \n+    boolean ok = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY2OTE1Mg=="}, "originalCommit": {"oid": "225cb0875b1504d9ffddcfa8990cac1ab397568d"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4709, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}