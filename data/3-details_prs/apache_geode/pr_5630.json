{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA0MTc0ODg1", "number": 5630, "title": "GEODE-8605: Alter Gateway Sender command", "bodyText": "Thank you for submitting a contribution to Apache Geode.\nIn order to streamline the review of the contribution we ask you\nto ensure the following steps have been taken:\nFor all changes:\n\n\n[*] Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?\n\n\n[*] Has your PR been rebased against the latest commit within the target branch (typically develop)?\n\n\n[*] Is your initial contribution a single, squashed commit?\n\n\n[*] Does gradlew build run cleanly?\n\n\n[*] Have you written or updated unit tests to verify your changes?\n\n\n If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under ASF 2.0?\n\n\nNote:\nPlease ensure that once the PR is submitted, check Concourse for build issues and\nsubmit an update to your PR as soon as possible. If you need help, please send an\nemail to dev@geode.apache.org.", "createdAt": "2020-10-15T15:05:07Z", "url": "https://github.com/apache/geode/pull/5630", "merged": true, "mergeCommit": {"oid": "7aa03824cc552433f034c8b27f4241d96bdb6383"}, "closed": true, "closedAt": "2021-04-08T08:45:31Z", "author": {"login": "mivanac"}, "timelineItems": {"totalCount": 65, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdS1ALTABqjM4ODI3MDU1NTE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABeJOytdABqjQ1NDY1MTU1Nzc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c3c8ca395120d14abf5514e523426c635dd68893", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/c3c8ca395120d14abf5514e523426c635dd68893", "committedDate": "2020-10-15T15:56:28Z", "message": "GEODE-8605: fix for failing integration test"}, "afterCommit": {"oid": "ca561e06f680c245311b1468adc454e7e321836b", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/ca561e06f680c245311b1468adc454e7e321836b", "committedDate": "2020-10-15T17:11:55Z", "message": "GEODE-8605: fix for failing integration test"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f75037870965d0fa50d08c4168d206a3d66e670c", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/f75037870965d0fa50d08c4168d206a3d66e670c", "committedDate": "2020-10-22T06:23:50Z", "message": "GEODE-8605: added test for new function"}, "afterCommit": {"oid": "bc19554ad6cd2ccc5de411c7ed38056f296d4669", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/bc19554ad6cd2ccc5de411c7ed38056f296d4669", "committedDate": "2020-10-22T08:52:48Z", "message": "GEODE-8605: added test for new function"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bc19554ad6cd2ccc5de411c7ed38056f296d4669", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/bc19554ad6cd2ccc5de411c7ed38056f296d4669", "committedDate": "2020-10-22T08:52:48Z", "message": "GEODE-8605: added test for new function"}, "afterCommit": {"oid": "e1a53b1597a12afbebabfd921797e8ae30ca4074", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/e1a53b1597a12afbebabfd921797e8ae30ca4074", "committedDate": "2020-10-27T11:32:49Z", "message": "GEODE-8605: added filter test"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e1a53b1597a12afbebabfd921797e8ae30ca4074", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/e1a53b1597a12afbebabfd921797e8ae30ca4074", "committedDate": "2020-10-27T11:32:49Z", "message": "GEODE-8605: added filter test"}, "afterCommit": {"oid": "34314f6b7422ac15659496078fd6f859521a3750", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/34314f6b7422ac15659496078fd6f859521a3750", "committedDate": "2020-10-27T12:32:26Z", "message": "GEODE-8605: added filter test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3OTQxOTU2", "url": "https://github.com/apache/geode/pull/5630#pullrequestreview-517941956", "createdAt": "2020-10-27T17:06:55Z", "commit": {"oid": "34314f6b7422ac15659496078fd6f859521a3750"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fd142445a751f9d3079ba1299e19d0a13d0fa525", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/fd142445a751f9d3079ba1299e19d0a13d0fa525", "committedDate": "2020-10-27T18:03:31Z", "message": "GEODE-8605: update after comments"}, "afterCommit": {"oid": "8ecc33769979f8336c6e15f1dbbc97aa029b670b", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/8ecc33769979f8336c6e15f1dbbc97aa029b670b", "committedDate": "2020-10-27T18:57:27Z", "message": "GEODE-8605: update after comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4MTc0NjIx", "url": "https://github.com/apache/geode/pull/5630#pullrequestreview-518174621", "createdAt": "2020-10-27T21:44:16Z", "commit": {"oid": "8ecc33769979f8336c6e15f1dbbc97aa029b670b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyMTUwNzU5", "url": "https://github.com/apache/geode/pull/5630#pullrequestreview-522150759", "createdAt": "2020-11-03T02:03:54Z", "commit": {"oid": "8ecc33769979f8336c6e15f1dbbc97aa029b670b"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8ecc33769979f8336c6e15f1dbbc97aa029b670b", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/8ecc33769979f8336c6e15f1dbbc97aa029b670b", "committedDate": "2020-10-27T18:57:27Z", "message": "GEODE-8605: update after comments"}, "afterCommit": {"oid": "425da1885433f52bbd97d329107ab6873d7634d9", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/425da1885433f52bbd97d329107ab6873d7634d9", "committedDate": "2020-11-16T21:11:54Z", "message": "GEODE-8605: update solution"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "050c581c06414376f7e0369f52c4ac8e6f59b7a1", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/050c581c06414376f7e0369f52c4ac8e6f59b7a1", "committedDate": "2020-12-03T17:20:00Z", "message": "GEODE-8605: added setters instead of update"}, "afterCommit": {"oid": "2504a3a2baa22b8da86a88936f97b952ab78976d", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/2504a3a2baa22b8da86a88936f97b952ab78976d", "committedDate": "2020-12-03T21:15:17Z", "message": "GEODE-8605: added setters instead of update"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6266835dc8a0d7e7df811006b1876468094f2b37", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/6266835dc8a0d7e7df811006b1876468094f2b37", "committedDate": "2020-12-04T17:11:19Z", "message": "GEODE-8605: added ParallelGatewaySender tests"}, "afterCommit": {"oid": "013344379e43f4c15e729a731a6f4e39338f8502", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/013344379e43f4c15e729a731a6f4e39338f8502", "committedDate": "2020-12-04T22:39:45Z", "message": "GEODE-8605: added test for SerialGatewaySender"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bb6825a095dc17cc04a3ed4982ba0d496504e051", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/bb6825a095dc17cc04a3ed4982ba0d496504e051", "committedDate": "2020-12-05T13:51:11Z", "message": "GEODE-8605: update solution"}, "afterCommit": {"oid": "1909ea65f4ed353b768f131ac95a6e8ed442ae97", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/1909ea65f4ed353b768f131ac95a6e8ed442ae97", "committedDate": "2020-12-12T20:19:57Z", "message": "GEODE-8605: add option to remove gateway-event-filters"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1909ea65f4ed353b768f131ac95a6e8ed442ae97", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/1909ea65f4ed353b768f131ac95a6e8ed442ae97", "committedDate": "2020-12-12T20:19:57Z", "message": "GEODE-8605: add option to remove gateway-event-filters"}, "afterCommit": {"oid": "04fcb2cbee4f89ae3a105b87da1f9999eead701b", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/04fcb2cbee4f89ae3a105b87da1f9999eead701b", "committedDate": "2020-12-13T22:40:11Z", "message": "GEODE-8605: add option to remove gateway-event-filters"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "60a9a99d79b72d82b4c3a9b29090ff1f7ae64fbe", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/60a9a99d79b72d82b4c3a9b29090ff1f7ae64fbe", "committedDate": "2020-12-14T09:21:28Z", "message": "GEODE-8605: update of remove filters solution"}, "afterCommit": {"oid": "df4475334938bfcab00bd2663ecf323a26aaf675", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/df4475334938bfcab00bd2663ecf323a26aaf675", "committedDate": "2020-12-14T11:42:14Z", "message": "GEODE-8605: update of remove filters solution"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "df4475334938bfcab00bd2663ecf323a26aaf675", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/df4475334938bfcab00bd2663ecf323a26aaf675", "committedDate": "2020-12-14T11:42:14Z", "message": "GEODE-8605: update of remove filters solution"}, "afterCommit": {"oid": "9b553da6b58fdc30b5852666293a5f983e20c9b3", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/9b553da6b58fdc30b5852666293a5f983e20c9b3", "committedDate": "2020-12-19T08:50:35Z", "message": "GEODE-8605: update of remove filters solution"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9b553da6b58fdc30b5852666293a5f983e20c9b3", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/9b553da6b58fdc30b5852666293a5f983e20c9b3", "committedDate": "2020-12-19T08:50:35Z", "message": "GEODE-8605: update of remove filters solution"}, "afterCommit": {"oid": "1b111ff83634bda2b9a143cc855f50eff5588a38", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/1b111ff83634bda2b9a143cc855f50eff5588a38", "committedDate": "2021-01-25T17:11:51Z", "message": "GEODE-8605: rebase solution"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1b111ff83634bda2b9a143cc855f50eff5588a38", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/1b111ff83634bda2b9a143cc855f50eff5588a38", "committedDate": "2021-01-25T17:11:51Z", "message": "GEODE-8605: rebase solution"}, "afterCommit": {"oid": "0d2bddf62441ac7f32a7151bae1212027ff06953", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/0d2bddf62441ac7f32a7151bae1212027ff06953", "committedDate": "2021-01-25T17:56:13Z", "message": "GEODE-8605: rebase solution"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0d2bddf62441ac7f32a7151bae1212027ff06953", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/0d2bddf62441ac7f32a7151bae1212027ff06953", "committedDate": "2021-01-25T17:56:13Z", "message": "GEODE-8605: rebase solution"}, "afterCommit": {"oid": "1cf1a7f0625e38bc292713cb695806531a765f54", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/1cf1a7f0625e38bc292713cb695806531a765f54", "committedDate": "2021-01-25T17:57:23Z", "message": "GEODE-8605: rebase solution"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "752828816812457b05c6d700a2d5d7bd3f53c982", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/752828816812457b05c6d700a2d5d7bd3f53c982", "committedDate": "2021-01-28T18:35:07Z", "message": "GEODE-8605: added serialVersionUID to GatewaySender"}, "afterCommit": {"oid": "dcf2cf94f8d56c6b68e42772e13a10895dd368c7", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/dcf2cf94f8d56c6b68e42772e13a10895dd368c7", "committedDate": "2021-01-28T20:01:00Z", "message": "GEODE-8605: added serialVersionUID to GatewaySender"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dcf2cf94f8d56c6b68e42772e13a10895dd368c7", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/dcf2cf94f8d56c6b68e42772e13a10895dd368c7", "committedDate": "2021-01-28T20:01:00Z", "message": "GEODE-8605: added serialVersionUID to GatewaySender"}, "afterCommit": {"oid": "a418d4b575d5b529fcdc0215d7b4f8d5299023dd", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/a418d4b575d5b529fcdc0215d7b4f8d5299023dd", "committedDate": "2021-01-28T21:30:23Z", "message": "GEODE-8605: added serialVersionUID to GatewaySender"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ba2724ff2ddfe6b247fed4aebb269e7049048284", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/ba2724ff2ddfe6b247fed4aebb269e7049048284", "committedDate": "2021-02-04T10:55:09Z", "message": "GEODE-8605: added test case"}, "afterCommit": {"oid": "6c4ca3bebcb1eef1a2e3691b7c99a583c30d7f61", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/6c4ca3bebcb1eef1a2e3691b7c99a583c30d7f61", "committedDate": "2021-02-04T18:04:01Z", "message": "GEODE-8605: added test case"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg3MTE2NDM4", "url": "https://github.com/apache/geode/pull/5630#pullrequestreview-587116438", "createdAt": "2021-02-09T23:33:32Z", "commit": {"oid": "6c4ca3bebcb1eef1a2e3691b7c99a583c30d7f61"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wOVQyMzozMzozMlrOIixJMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wOVQyMzozNjoyMlrOIixQuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzMyNzY2NA==", "bodyText": "You should create a new unit test even for inner-classes. Any class that you make Serializable should also have to unit test coverage to ensure that both seriallization and deserialization succeeds and results in a faithful replica of the original object (shamelessly copied from Effective Java 3rd Ed. Item 86). I recommend using org.apache.commons.lang3.SerializationUtils to simplify the unit testing.", "url": "https://github.com/apache/geode/pull/5630#discussion_r573327664", "createdAt": "2021-02-09T23:33:32Z", "author": {"login": "kirklund"}, "path": "geode-core/src/main/java/org/apache/geode/cache/configuration/CacheConfig.java", "diffHunk": "@@ -2612,7 +2612,8 @@ public void setOverflowDirectory(String value) {\n   @XmlAccessorType(XmlAccessType.FIELD)\n   @XmlType(name = \"\", propOrder = {\"gatewayEventFilters\", \"gatewayEventSubstitutionFilter\",\n       \"gatewayTransportFilters\"})\n-  public static class GatewaySender {\n+  public static class GatewaySender extends CacheElement {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c4ca3bebcb1eef1a2e3691b7c99a583c30d7f61"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzMyOTU5NQ==", "bodyText": "public mutable fields are not good. I guess this class has other such fields so I'll just skip over this class. If it was me, I'd completely rewrite this class to get make all fields private.", "url": "https://github.com/apache/geode/pull/5630#discussion_r573329595", "createdAt": "2021-02-09T23:36:22Z", "author": {"login": "kirklund"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/GatewaySenderAttributes.java", "diffHunk": "@@ -88,6 +88,20 @@\n   public boolean enforceThreadsConnectSameReceiver =\n       GatewaySender.DEFAULT_ENFORCE_THREADS_CONNECT_SAME_RECEIVER;\n \n+  // Added due to \"alter gateway-sender\" command\n+\n+  public boolean modifyAlertThreshold = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c4ca3bebcb1eef1a2e3691b7c99a583c30d7f61"}, "originalPosition": 6}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "857010f12f5e9857e613e53aa4f5c59587ff3d24", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/857010f12f5e9857e613e53aa4f5c59587ff3d24", "committedDate": "2021-02-15T19:48:57Z", "message": "GEODE-8605: remove changes in CacheConfig.GatewaySender"}, "afterCommit": {"oid": "44c49b66708a378572b71452cfd33f7160a05cec", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/44c49b66708a378572b71452cfd33f7160a05cec", "committedDate": "2021-02-15T20:22:52Z", "message": "GEODE-8605: remove changes in CacheConfig.GatewaySender"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "44c49b66708a378572b71452cfd33f7160a05cec", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/44c49b66708a378572b71452cfd33f7160a05cec", "committedDate": "2021-02-15T20:22:52Z", "message": "GEODE-8605: remove changes in CacheConfig.GatewaySender"}, "afterCommit": {"oid": "fb0150476ce137eb9b0749de4b2e15a1f3f8df41", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/fb0150476ce137eb9b0749de4b2e15a1f3f8df41", "committedDate": "2021-02-15T20:54:29Z", "message": "GEODE-8605: remove changes in CacheConfig.GatewaySender"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fb0150476ce137eb9b0749de4b2e15a1f3f8df41", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/fb0150476ce137eb9b0749de4b2e15a1f3f8df41", "committedDate": "2021-02-15T20:54:29Z", "message": "GEODE-8605: remove changes in CacheConfig.GatewaySender"}, "afterCommit": {"oid": "10f9b95d5bc27642bf76bfb10332913e0ee9d5c4", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/10f9b95d5bc27642bf76bfb10332913e0ee9d5c4", "committedDate": "2021-02-16T09:33:21Z", "message": "GEODE-8605: remove changes in CacheConfig.GatewaySender"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "10f9b95d5bc27642bf76bfb10332913e0ee9d5c4", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/10f9b95d5bc27642bf76bfb10332913e0ee9d5c4", "committedDate": "2021-02-16T09:33:21Z", "message": "GEODE-8605: remove changes in CacheConfig.GatewaySender"}, "afterCommit": {"oid": "f6918015d1efe49f8c905012596d964a878aa776", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/f6918015d1efe49f8c905012596d964a878aa776", "committedDate": "2021-03-02T21:09:22Z", "message": "GEODE-8605: add setters to GatewaySenderAttributes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAyMzI2ODQ4", "url": "https://github.com/apache/geode/pull/5630#pullrequestreview-602326848", "createdAt": "2021-03-02T22:21:53Z", "commit": {"oid": "f6918015d1efe49f8c905012596d964a878aa776"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f6918015d1efe49f8c905012596d964a878aa776", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/f6918015d1efe49f8c905012596d964a878aa776", "committedDate": "2021-03-02T21:09:22Z", "message": "GEODE-8605: add setters to GatewaySenderAttributes"}, "afterCommit": {"oid": "30ac9967be6a5fdbe36c04d06a20f47f13ae100c", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/30ac9967be6a5fdbe36c04d06a20f47f13ae100c", "committedDate": "2021-03-03T09:02:48Z", "message": "GEODE-8605: add setters to GatewaySenderAttributes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAzMjgyMzcy", "url": "https://github.com/apache/geode/pull/5630#pullrequestreview-603282372", "createdAt": "2021-03-03T19:46:00Z", "commit": {"oid": "30ac9967be6a5fdbe36c04d06a20f47f13ae100c"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "30ac9967be6a5fdbe36c04d06a20f47f13ae100c", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/30ac9967be6a5fdbe36c04d06a20f47f13ae100c", "committedDate": "2021-03-03T09:02:48Z", "message": "GEODE-8605: add setters to GatewaySenderAttributes"}, "afterCommit": {"oid": "bf5f2b5da8e7601785d084636309a01c0583eb60", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/bf5f2b5da8e7601785d084636309a01c0583eb60", "committedDate": "2021-03-12T14:45:54Z", "message": "GEODE-8605: add setters to GatewaySenderAttributes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bf5f2b5da8e7601785d084636309a01c0583eb60", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/bf5f2b5da8e7601785d084636309a01c0583eb60", "committedDate": "2021-03-12T14:45:54Z", "message": "GEODE-8605: add setters to GatewaySenderAttributes"}, "afterCommit": {"oid": "e817a31292ad07435ba6f8f162f177d389c7cc15", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/e817a31292ad07435ba6f8f162f177d389c7cc15", "committedDate": "2021-03-12T16:28:29Z", "message": "GEODE-8605: add setters to GatewaySenderAttributes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e817a31292ad07435ba6f8f162f177d389c7cc15", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/e817a31292ad07435ba6f8f162f177d389c7cc15", "committedDate": "2021-03-12T16:28:29Z", "message": "GEODE-8605: add setters to GatewaySenderAttributes"}, "afterCommit": {"oid": "77fe9f06f6b4771d506ca47298127b3e693576b5", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/77fe9f06f6b4771d506ca47298127b3e693576b5", "committedDate": "2021-03-13T09:44:34Z", "message": "GEODE-8605: small update"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "77fe9f06f6b4771d506ca47298127b3e693576b5", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/77fe9f06f6b4771d506ca47298127b3e693576b5", "committedDate": "2021-03-13T09:44:34Z", "message": "GEODE-8605: small update"}, "afterCommit": {"oid": "9f80ce7134d96bb3a8c87c6b255e2a9c28f77d3d", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/9f80ce7134d96bb3a8c87c6b255e2a9c28f77d3d", "committedDate": "2021-03-17T20:42:27Z", "message": "GEODE-8605: small update"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9f80ce7134d96bb3a8c87c6b255e2a9c28f77d3d", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/9f80ce7134d96bb3a8c87c6b255e2a9c28f77d3d", "committedDate": "2021-03-17T20:42:27Z", "message": "GEODE-8605: small update"}, "afterCommit": {"oid": "df695e4b637a669815843e5b1a181ce9fbba95ea", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/df695e4b637a669815843e5b1a181ce9fbba95ea", "committedDate": "2021-03-18T10:22:59Z", "message": "GEODE-8605: small update"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "df695e4b637a669815843e5b1a181ce9fbba95ea", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/df695e4b637a669815843e5b1a181ce9fbba95ea", "committedDate": "2021-03-18T10:22:59Z", "message": "GEODE-8605: small update"}, "afterCommit": {"oid": "9430438d08a37857ec518fbb0682e99b94b72188", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/9430438d08a37857ec518fbb0682e99b94b72188", "committedDate": "2021-03-30T12:21:18Z", "message": "GEODE-8605: update after rebase"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI0MjkyMTU1", "url": "https://github.com/apache/geode/pull/5630#pullrequestreview-624292155", "createdAt": "2021-03-30T13:57:47Z", "commit": {"oid": "9430438d08a37857ec518fbb0682e99b94b72188"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0zMFQxNDoxMDozN1rOJAJWyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0zMFQxNDo1NzoyMlrOJAMCDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDEzMzA2NA==", "bodyText": "What is the purpose of these members and the functions to get/set them? I have not found the use in the rest of the code.", "url": "https://github.com/apache/geode/pull/5630#discussion_r604133064", "createdAt": "2021-03-30T14:10:37Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/GatewaySenderAttributes.java", "diffHunk": "@@ -31,63 +31,201 @@\n   public static final boolean DEFAULT_IS_META_QUEUE = false;\n \n \n-  public int socketBufferSize = GatewaySender.DEFAULT_SOCKET_BUFFER_SIZE;\n+  private int socketBufferSize = GatewaySender.DEFAULT_SOCKET_BUFFER_SIZE;\n \n-  public int socketReadTimeout = GatewaySender.DEFAULT_SOCKET_READ_TIMEOUT;\n+  private int socketReadTimeout = GatewaySender.DEFAULT_SOCKET_READ_TIMEOUT;\n \n-  public int maximumQueueMemory = GatewaySender.DEFAULT_MAXIMUM_QUEUE_MEMORY;\n+  private int maximumQueueMemory = GatewaySender.DEFAULT_MAXIMUM_QUEUE_MEMORY;\n \n-  public int batchSize = GatewaySender.DEFAULT_BATCH_SIZE;\n+  private int batchSize = GatewaySender.DEFAULT_BATCH_SIZE;\n \n-  public int batchTimeInterval = GatewaySender.DEFAULT_BATCH_TIME_INTERVAL;\n+  private int batchTimeInterval = GatewaySender.DEFAULT_BATCH_TIME_INTERVAL;\n \n-  public boolean isBatchConflationEnabled = GatewaySender.DEFAULT_BATCH_CONFLATION;\n+  private boolean isBatchConflationEnabled = GatewaySender.DEFAULT_BATCH_CONFLATION;\n \n-  public boolean isPersistenceEnabled = GatewaySender.DEFAULT_PERSISTENCE_ENABLED;\n+  private boolean isPersistenceEnabled = GatewaySender.DEFAULT_PERSISTENCE_ENABLED;\n \n-  public int alertThreshold = GatewaySender.DEFAULT_ALERT_THRESHOLD;\n+  private int alertThreshold = GatewaySender.DEFAULT_ALERT_THRESHOLD;\n \n-  public boolean manualStart = GatewaySender.DEFAULT_MANUAL_START;\n+  private boolean manualStart = GatewaySender.DEFAULT_MANUAL_START;\n \n-  public String diskStoreName;\n+  private String diskStoreName;\n \n-  public List<GatewayEventFilter> eventFilters = new ArrayList<GatewayEventFilter>();\n+  private List<GatewayEventFilter> eventFilters = new ArrayList<GatewayEventFilter>();\n \n-  public ArrayList<GatewayTransportFilter> transFilters = new ArrayList<GatewayTransportFilter>();\n+  private ArrayList<GatewayTransportFilter> transFilters = new ArrayList<GatewayTransportFilter>();\n \n-  public List<AsyncEventListener> listeners = new ArrayList<AsyncEventListener>();\n+  private List<AsyncEventListener> listeners = new ArrayList<AsyncEventListener>();\n \n-  public GatewayEventSubstitutionFilter eventSubstitutionFilter;\n+  private GatewayEventSubstitutionFilter eventSubstitutionFilter;\n \n-  public String id;\n+  private String id;\n \n-  public int remoteDs = GatewaySender.DEFAULT_DISTRIBUTED_SYSTEM_ID;\n+  private int remoteDs = GatewaySender.DEFAULT_DISTRIBUTED_SYSTEM_ID;\n \n-  public LocatorDiscoveryCallback locatorDiscoveryCallback;\n+  private LocatorDiscoveryCallback locatorDiscoveryCallback;\n \n-  public boolean isDiskSynchronous = GatewaySender.DEFAULT_DISK_SYNCHRONOUS;\n+  private boolean isDiskSynchronous = GatewaySender.DEFAULT_DISK_SYNCHRONOUS;\n \n-  public OrderPolicy policy;\n+  private OrderPolicy policy;\n \n-  public int dispatcherThreads = GatewaySender.DEFAULT_DISPATCHER_THREADS;\n+  private int dispatcherThreads = GatewaySender.DEFAULT_DISPATCHER_THREADS;\n \n-  public int parallelism = GatewaySender.DEFAULT_PARALLELISM_REPLICATED_REGION;\n+  private int parallelism = GatewaySender.DEFAULT_PARALLELISM_REPLICATED_REGION;\n \n-  public boolean isParallel = GatewaySender.DEFAULT_IS_PARALLEL;\n+  private boolean isParallel = GatewaySender.DEFAULT_IS_PARALLEL;\n \n-  public boolean groupTransactionEvents = GatewaySender.DEFAULT_MUST_GROUP_TRANSACTION_EVENTS;\n+  private boolean groupTransactionEvents = GatewaySender.DEFAULT_MUST_GROUP_TRANSACTION_EVENTS;\n \n-  public boolean isForInternalUse = GatewaySender.DEFAULT_IS_FOR_INTERNAL_USE;\n+  private boolean isForInternalUse = GatewaySender.DEFAULT_IS_FOR_INTERNAL_USE;\n \n-  public boolean isBucketSorted = GatewaySenderAttributes.DEFAULT_IS_BUCKETSORTED;\n+  private boolean isBucketSorted = GatewaySenderAttributes.DEFAULT_IS_BUCKETSORTED;\n \n-  public boolean isMetaQueue = GatewaySenderAttributes.DEFAULT_IS_META_QUEUE;\n+  private boolean isMetaQueue = GatewaySenderAttributes.DEFAULT_IS_META_QUEUE;\n \n-  public boolean forwardExpirationDestroy = GatewaySender.DEFAULT_FORWARD_EXPIRATION_DESTROY;\n+  private boolean forwardExpirationDestroy = GatewaySender.DEFAULT_FORWARD_EXPIRATION_DESTROY;\n \n-  public boolean enforceThreadsConnectSameReceiver =\n+  private boolean enforceThreadsConnectSameReceiver =\n       GatewaySender.DEFAULT_ENFORCE_THREADS_CONNECT_SAME_RECEIVER;\n \n+  // Added due to \"alter gateway-sender\" command\n+\n+  private boolean modifyAlertThreshold = false;\n+\n+  private boolean modifyBatchSize = false;\n+\n+  private boolean modifyBatchTimeInterval = false;\n+\n+  private boolean modifyGroupTransactionEvents = false;\n+\n+  private boolean modifyGatewayEventFilter = false;\n+\n+  private boolean modifyGatewayTransportFilter = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9430438d08a37857ec518fbb0682e99b94b72188"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDEzNjY0MQ==", "bodyText": "How about something more compact? return gatewayEventFilters != null;", "url": "https://github.com/apache/geode/pull/5630#discussion_r604136641", "createdAt": "2021-03-30T14:14:48Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/main/java/org/apache/geode/cache/configuration/CacheConfig.java", "diffHunk": "@@ -2689,6 +2689,12 @@ public void setOverflowDirectory(String value) {\n       return this.gatewayEventFilters;\n     }\n \n+    public boolean areGatewayEventFiltersUpdated() {\n+      if (gatewayEventFilters == null)\n+        return false;\n+      return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9430438d08a37857ec518fbb0682e99b94b72188"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDEzNzg0Mg==", "bodyText": "This line is redundant.", "url": "https://github.com/apache/geode/pull/5630#discussion_r604137842", "createdAt": "2021-03-30T14:16:06Z", "author": {"login": "albertogpz"}, "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/AlterGatewaySenderCommand.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.management.internal.cli.commands;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.shell.core.annotation.CliCommand;\n+import org.springframework.shell.core.annotation.CliOption;\n+\n+import org.apache.geode.cache.configuration.CacheConfig;\n+import org.apache.geode.cache.configuration.DeclarableType;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.InternalConfigurationPersistenceService;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+import org.apache.geode.management.cli.CliMetaData;\n+import org.apache.geode.management.cli.ConverterHint;\n+import org.apache.geode.management.cli.SingleGfshCommand;\n+import org.apache.geode.management.internal.cli.functions.AlterGatewaySenderFunction;\n+import org.apache.geode.management.internal.cli.functions.GatewaySenderFunctionArgs;\n+import org.apache.geode.management.internal.cli.result.model.ResultModel;\n+import org.apache.geode.management.internal.exceptions.EntityNotFoundException;\n+import org.apache.geode.management.internal.functions.CliFunctionResult;\n+import org.apache.geode.management.internal.i18n.CliStrings;\n+import org.apache.geode.management.internal.security.ResourceOperation;\n+import org.apache.geode.security.ResourcePermission;\n+\n+public class AlterGatewaySenderCommand extends SingleGfshCommand {\n+  private final AlterGatewaySenderFunction alterGatewaySenderFunction =\n+      new AlterGatewaySenderFunction();\n+  private static final Logger logger = LogService.getLogger();\n+\n+  @CliCommand(value = CliStrings.ALTER_GATEWAYSENDER,\n+      help = CliStrings.ALTER_GATEWAYSENDER__HELP)\n+  @CliMetaData(relatedTopic = CliStrings.TOPIC_GEODE_WAN)\n+  @ResourceOperation(resource = ResourcePermission.Resource.CLUSTER,\n+      operation = ResourcePermission.Operation.MANAGE, target = ResourcePermission.Target.GATEWAY)\n+\n+  public ResultModel alterGatewaySender(@CliOption(key = CliStrings.ALTER_GATEWAYSENDER__ID,\n+      mandatory = true, optionContext = ConverterHint.GATEWAY_SENDER_ID,\n+      help = CliStrings.ALTER_GATEWAYSENDER__ID__HELP) String senderId,\n+      @CliOption(key = {CliStrings.GROUP, CliStrings.GROUPS},\n+          optionContext = ConverterHint.MEMBERGROUP,\n+          help = CliStrings.ALTER_GATEWAYSENDER__GROUP__HELP) String[] onGroup,\n+      @CliOption(key = {CliStrings.MEMBER, CliStrings.MEMBERS},\n+          optionContext = ConverterHint.MEMBERIDNAME,\n+          help = CliStrings.ALTER_GATEWAYSENDER__MEMBER__HELP) String[] onMember,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__ALERTTHRESHOLD,\n+          help = CliStrings.ALTER_GATEWAYSENDER__ALERTTHRESHOLD__HELP) Integer alertThreshold,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__BATCHSIZE,\n+          help = CliStrings.ALTER_GATEWAYSENDER__BATCHSIZE__HELP) Integer batchSize,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__BATCHTIMEINTERVAL,\n+          help = CliStrings.ALTER_GATEWAYSENDER__BATCHTIMEINTERVAL__HELP) Integer batchTimeInterval,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__GATEWAYEVENTFILTER,\n+          specifiedDefaultValue = CliStrings.NULL,\n+          help = CliStrings.ALTER_GATEWAYSENDER__GATEWAYEVENTFILTER__HELP) String[] gatewayEventFilters,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__GROUPTRANSACTIONEVENTS,\n+          specifiedDefaultValue = \"true\",\n+          help = CliStrings.ALTER_GATEWAYSENDER__GROUPTRANSACTIONEVENTS__HELP) Boolean groupTransactionEvents)\n+      throws EntityNotFoundException {\n+\n+    // need not check if any running servers has this gateway-sender. A server with this\n+    // gateway-sender id\n+    // may be shutdown, but we still need to update Cluster Configuration.\n+    if (getConfigurationPersistenceService() == null) {\n+      return ResultModel.createError(\"Cluster Configuration Service is not available. \"\n+          + \"Please connect to a locator with running Cluster Configuration Service.\");\n+    }\n+\n+    final String id = senderId.trim();\n+\n+    CacheConfig.GatewaySender oldConfiguration = findGW(id);\n+\n+    if (oldConfiguration == null) {\n+      String message = String.format(\"Cannot find a gateway sender with id '%s'.\", id);\n+      throw new EntityNotFoundException(message);\n+    }\n+\n+    if (groupTransactionEvents != null && groupTransactionEvents\n+        && !oldConfiguration.mustGroupTransactionEvents()) {\n+      if (!oldConfiguration.isParallel() && (oldConfiguration.getDispatcherThreads() == null\n+          || Integer.parseInt(oldConfiguration.getDispatcherThreads()) > 1)) {\n+        return ResultModel.createError(\n+            \"alter-gateway-sender cannot be performed for --group-transaction-events attribute if serial sender and dispatcher-threads is greater than 1.\");\n+      }\n+\n+      if (oldConfiguration.isEnableBatchConflation()) {\n+        return ResultModel.createError(\n+            \"alter-gateway-sender cannot be performed for --group-transaction-events attribute if batch-conflation is enabled.\");\n+      }\n+    }\n+\n+    Set<DistributedMember> dsMembers = findMembers(onGroup, onMember);\n+\n+    if (dsMembers.isEmpty()) {\n+      return ResultModel.createError(CliStrings.NO_MEMBERS_FOUND_MESSAGE);\n+    }\n+\n+    CacheConfig.GatewaySender gwConfiguration = new CacheConfig.GatewaySender();\n+    gwConfiguration.setId(id);\n+\n+    boolean modify = false;\n+\n+    if (alertThreshold != null) {\n+      modify = true;\n+      gwConfiguration.setAlertThreshold(alertThreshold.toString());\n+    }\n+\n+    if (batchSize != null) {\n+      modify = true;\n+      gwConfiguration.setBatchSize(batchSize.toString());\n+    }\n+\n+    if (batchTimeInterval != null) {\n+      modify = true;\n+      gwConfiguration.setBatchTimeInterval(batchTimeInterval.toString());\n+    }\n+\n+    if (groupTransactionEvents != null) {\n+      modify = true;\n+      gwConfiguration.setGroupTransactionEvents(groupTransactionEvents);\n+    }\n+\n+    if (gatewayEventFilters != null) {\n+      modify = true;\n+      if (gatewayEventFilters.length == 1\n+          && gatewayEventFilters[0].equalsIgnoreCase(CliStrings.NULL)) {\n+        gwConfiguration.getGatewayEventFilters();\n+      } else {\n+        gwConfiguration.getGatewayEventFilters()\n+            .addAll((stringsToDeclarableTypes(gatewayEventFilters)));\n+      }\n+    }\n+\n+    if (!modify) {\n+      return ResultModel.createError(CliStrings.ALTER_GATEWAYSENDER__RELEVANT__OPTION__MESSAGE);\n+    }\n+\n+    GatewaySenderFunctionArgs gatewaySenderFunctionArgs =\n+        new GatewaySenderFunctionArgs(gwConfiguration);\n+\n+    List<CliFunctionResult> gatewaySenderAlterResults =\n+        executeAndGetFunctionResult(alterGatewaySenderFunction, gatewaySenderFunctionArgs,\n+            dsMembers);\n+\n+    ResultModel resultModel = ResultModel.createMemberStatusResult(gatewaySenderAlterResults);\n+\n+    resultModel.setConfigObject(gwConfiguration);\n+\n+    return resultModel;\n+  }\n+\n+  @Override\n+  public boolean updateConfigForGroup(String group, CacheConfig config, Object configObject) {\n+    List<CacheConfig.GatewaySender> gwSenders = config.getGatewaySenders();\n+    if (gwSenders.isEmpty()) {\n+      return false;\n+    }\n+\n+    boolean gwConfigsHaveBeenUpdated = false;\n+    CacheConfig.GatewaySender gwConfiguration =\n+        ((CacheConfig.GatewaySender) configObject);\n+\n+    String gwId = gwConfiguration.getId();\n+\n+    for (CacheConfig.GatewaySender sender : gwSenders) {\n+      if (gwId.equals(sender.getId())) {\n+        gwConfigsHaveBeenUpdated = true;\n+        if (StringUtils.isNotBlank(gwConfiguration.getBatchSize())) {\n+          sender.setBatchSize(gwConfiguration.getBatchSize());\n+        }\n+\n+        if (StringUtils.isNotBlank(gwConfiguration.getBatchTimeInterval())) {\n+          sender.setBatchTimeInterval(gwConfiguration.getBatchTimeInterval());\n+        }\n+\n+        if (StringUtils.isNotBlank(gwConfiguration.getAlertThreshold())) {\n+          sender.setAlertThreshold(gwConfiguration.getAlertThreshold());\n+        }\n+        if (gwConfiguration.mustGroupTransactionEvents() != null) {\n+          sender.setGroupTransactionEvents(gwConfiguration.mustGroupTransactionEvents());\n+        }\n+\n+        if (gwConfiguration.areGatewayEventFiltersUpdated()) {\n+          if (!sender.getGatewayEventFilters().isEmpty()) {\n+            sender.getGatewayEventFilters().clear();\n+          }\n+          if (!gwConfiguration.getGatewayEventFilters().isEmpty()) {\n+            sender.getGatewayEventFilters().addAll(gwConfiguration.getGatewayEventFilters());\n+          }\n+        }\n+\n+      }\n+    }\n+    return gwConfigsHaveBeenUpdated;\n+\n+  }\n+\n+  private CacheConfig.GatewaySender findGW(String gwId) {\n+    CacheConfig.GatewaySender gwsender = null;\n+    InternalConfigurationPersistenceService ccService =\n+        (InternalConfigurationPersistenceService) this.getConfigurationPersistenceService();\n+    if (ccService == null) {\n+      return null;\n+    }\n+\n+    Set<String> groups = ccService.getGroups();\n+    gwsender = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9430438d08a37857ec518fbb0682e99b94b72188"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDE3MjI4Ng==", "bodyText": "Is it necessary that the sender is paused while the parameters are changed? If it is so, it would have to be said in the documentation. Otherwise, I would remove the pause here and in the other calls where a gateway sender parameter is changed.", "url": "https://github.com/apache/geode/pull/5630#discussion_r604172286", "createdAt": "2021-03-30T14:52:25Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderOperationsDUnitTest.java", "diffHunk": "@@ -1023,6 +1238,268 @@ private void createPartitionedRegions(boolean createAccessors) {\n     vm3.invoke(() -> createPartitionedRegion(regionName, \"ln\", 1, 100, isOffHeap()));\n   }\n \n+  private void updateBatchSize(int batchsize) {\n+    vm4.invoke(() -> {\n+      AbstractGatewaySender sender = (AbstractGatewaySender) cache.getGatewaySender(\"ln\");\n+      boolean paused = false;\n+      if (sender.isRunning() && !sender.isPaused()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9430438d08a37857ec518fbb0682e99b94b72188"}, "originalPosition": 244}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDE3NjkxMA==", "bodyText": "Same comment as before on the ParallelGateway sender tests. If it is necessary that the gateway sender is paused while parameters are changed, that would have to be documented. Otherwise, I would remove the pause here and in the other parameter changes, below.", "url": "https://github.com/apache/geode/pull/5630#discussion_r604176910", "createdAt": "2021-03-30T14:57:22Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderAlterOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,885 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static java.lang.System.currentTimeMillis;\n+import static java.util.Arrays.asList;\n+import static org.apache.geode.cache.Region.SEPARATOR;\n+import static org.apache.geode.cache.RegionShortcut.REPLICATE;\n+import static org.apache.geode.cache.wan.GatewaySender.DEFAULT_ORDER_POLICY;\n+import static org.apache.geode.cache.wan.GatewaySender.DEFAULT_SOCKET_BUFFER_SIZE;\n+import static org.apache.geode.distributed.ConfigurationProperties.DISTRIBUTED_SYSTEM_ID;\n+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;\n+import static org.apache.geode.distributed.ConfigurationProperties.REMOTE_LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.START_LOCATOR;\n+import static org.apache.geode.internal.AvailablePortHelper.getRandomAvailableTCPPort;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.IgnoredException.addIgnoredException;\n+import static org.apache.geode.test.dunit.VM.getCurrentVMNum;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.apache.geode.test.dunit.VM.toArray;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.StringTokenizer;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+import org.junit.runners.Parameterized.UseParametersRunnerFactory;\n+\n+import org.apache.geode.cache.CacheClosedException;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.DiskStore;\n+import org.apache.geode.cache.DiskStoreFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionDestroyedException;\n+import org.apache.geode.cache.RegionFactory;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.cache.wan.GatewayEventFilter;\n+import org.apache.geode.cache.wan.GatewayQueueEvent;\n+import org.apache.geode.cache.wan.GatewayReceiver;\n+import org.apache.geode.cache.wan.GatewayReceiverFactory;\n+import org.apache.geode.cache.wan.GatewaySender;\n+import org.apache.geode.cache.wan.GatewaySender.OrderPolicy;\n+import org.apache.geode.distributed.Locator;\n+import org.apache.geode.distributed.internal.InternalLocator;\n+import org.apache.geode.internal.cache.ForceReattemptException;\n+import org.apache.geode.internal.cache.RegionQueue;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySenderEventProcessor;\n+import org.apache.geode.internal.cache.wan.GatewaySenderException;\n+import org.apache.geode.internal.cache.wan.InternalGatewaySender;\n+import org.apache.geode.internal.cache.wan.InternalGatewaySenderFactory;\n+import org.apache.geode.internal.cache.wan.WANTestBase;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.IgnoredException;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.cache.CacheTestCase;\n+import org.apache.geode.test.junit.categories.WanTest;\n+import org.apache.geode.test.junit.rules.serializable.SerializableTemporaryFolder;\n+import org.apache.geode.test.junit.runners.CategoryWithParameterizedRunnerFactory;\n+\n+@Category(WanTest.class)\n+@RunWith(Parameterized.class)\n+@UseParametersRunnerFactory(CategoryWithParameterizedRunnerFactory.class)\n+@SuppressWarnings(\"serial\")\n+public class SerialGatewaySenderAlterOperationsDUnitTest extends CacheTestCase {\n+  private static final Logger logger = LogService.getLogger();\n+\n+  @Parameters(name = \"{index}: numDispatchers={0}\")\n+  public static Collection<Integer> data() {\n+    return asList(1, 3, 5);\n+  }\n+\n+  @Parameter\n+  public int numDispatchers;\n+\n+  private VM vm0;\n+  private VM vm1;\n+  private VM vm2;\n+  private VM vm3;\n+  private VM vm4;\n+  private VM vm5;\n+  private VM vm6;\n+  private VM vm7;\n+\n+  private String className;\n+\n+  @Rule\n+  public SerializableTemporaryFolder temporaryFolder = new SerializableTemporaryFolder();\n+\n+  @Before\n+  public void setUp() {\n+    addIgnoredException(\"Broken pipe\");\n+    addIgnoredException(\"Connection refused\");\n+    addIgnoredException(\"Connection reset\");\n+    addIgnoredException(\"could not get remote locator information\");\n+    addIgnoredException(\"Software caused connection abort\");\n+    addIgnoredException(\"Unexpected IOException\");\n+\n+    className = getClass().getSimpleName();\n+\n+    vm0 = getVM(0);\n+    vm1 = getVM(1);\n+    vm2 = getVM(2);\n+    vm3 = getVM(3);\n+    vm4 = getVM(4);\n+    vm5 = getVM(5);\n+    vm6 = getVM(6);\n+    vm7 = getVM(7);\n+\n+    // Stopping the gateway closed the region, which causes this exception to get logged\n+    addIgnoredException(RegionDestroyedException.class);\n+  }\n+\n+  @Test\n+  public void testStartPauseResumeSerialGatewaySenderUpdateAttributes() throws Exception {\n+    int lnPort = vm0.invoke(() -> createFirstLocatorWithDSId(1));\n+    int nyPort = vm1.invoke(() -> createFirstRemoteLocator(2, lnPort));\n+\n+    for (VM vm : toArray(vm2, vm3)) {\n+      vm.invoke(() -> {\n+        createCache(nyPort);\n+        createReceiver();\n+      });\n+    }\n+\n+    vm4.invoke(() -> createCache(lnPort));\n+    vm5.invoke(() -> createCache(lnPort));\n+    vm6.invoke(() -> createCache(lnPort));\n+    vm7.invoke(() -> createCache(lnPort));\n+\n+    vm4.invoke(() -> createSenderInVm4());\n+    vm5.invoke(() -> createSenderInVm5());\n+\n+    vm2.invoke(() -> createReplicatedRegion(className + \"_RR\", null));\n+    vm3.invoke(() -> createReplicatedRegion(className + \"_RR\", null));\n+\n+    vm4.invoke(() -> createReplicatedRegion(className + \"_RR\", \"ln\"));\n+    vm5.invoke(() -> createReplicatedRegion(className + \"_RR\", \"ln\"));\n+    vm6.invoke(() -> createReplicatedRegion(className + \"_RR\", \"ln\"));\n+    vm7.invoke(() -> createReplicatedRegion(className + \"_RR\", \"ln\"));\n+\n+    for (VM vm : toArray(vm4, vm5)) {\n+      vm.invoke(() -> startSender(\"ln\"));\n+    }\n+\n+    vm4.invoke(() -> pauseSender(\"ln\"));\n+    vm5.invoke(() -> pauseSender(\"ln\"));\n+\n+    vm4.invoke(() -> validateSenderPausedState(\"ln\"));\n+    vm5.invoke(() -> validateSenderPausedState(\"ln\"));\n+\n+    vm4.invoke(() -> doPuts(className + \"_RR\", 1000));\n+\n+    updateBatchSize(50);\n+    updateBatchTimeInterval(200);\n+\n+    vm4.invoke(() -> resumeSender(\"ln\"));\n+    vm5.invoke(() -> resumeSender(\"ln\"));\n+\n+    vm4.invoke(() -> validateSenderResumedState(\"ln\"));\n+    vm5.invoke(() -> validateSenderResumedState(\"ln\"));\n+\n+    checkBatchSize(50);\n+    checkBatchTimeInterval(200);\n+\n+    vm4.invoke(() -> validateQueueContents(\"ln\", 0));\n+    vm5.invoke(() -> validateQueueContents(\"ln\", 0));\n+\n+    vm2.invoke(() -> validateRegionSize(className + \"_RR\", 1000));\n+    vm3.invoke(() -> validateRegionSize(className + \"_RR\", 1000));\n+  }\n+\n+  @Test\n+  public void testSerialGatewaySenderUpdateAttributesWhilePutting() throws Exception {\n+    int lnPort = vm0.invoke(() -> createFirstLocatorWithDSId(1));\n+    int nyPort = vm1.invoke(() -> createFirstRemoteLocator(2, lnPort));\n+\n+    for (VM vm : toArray(vm2, vm3)) {\n+      vm.invoke(() -> {\n+        createCache(nyPort);\n+        createReceiver();\n+      });\n+    }\n+\n+    vm4.invoke(() -> createCache(lnPort));\n+    vm5.invoke(() -> createCache(lnPort));\n+    vm6.invoke(() -> createCache(lnPort));\n+    vm7.invoke(() -> createCache(lnPort));\n+\n+    vm4.invoke(() -> createSenderInVm4());\n+    vm5.invoke(() -> createSenderInVm5());\n+\n+    vm2.invoke(() -> createReplicatedRegion(className + \"_RR\", null));\n+    vm3.invoke(() -> createReplicatedRegion(className + \"_RR\", null));\n+\n+    vm4.invoke(() -> createReplicatedRegion(className + \"_RR\", \"ln\"));\n+    vm5.invoke(() -> createReplicatedRegion(className + \"_RR\", \"ln\"));\n+    vm6.invoke(() -> createReplicatedRegion(className + \"_RR\", \"ln\"));\n+    vm7.invoke(() -> createReplicatedRegion(className + \"_RR\", \"ln\"));\n+\n+    for (VM vm : toArray(vm4, vm5)) {\n+      vm.invoke(() -> startSender(\"ln\"));\n+    }\n+\n+    // Do some puts from both vm4 and vm5 while restarting a sender\n+    AsyncInvocation doPutsInVm4 =\n+        vm4.invokeAsync(() -> doPuts(className + \"_RR\", 1000));\n+\n+    updateBatchSize(50);\n+    updateBatchTimeInterval(200);\n+\n+    doPutsInVm4.await();\n+\n+    checkBatchSize(50);\n+    checkBatchTimeInterval(200);\n+\n+    vm4.invoke(() -> validateQueueContents(\"ln\", 0));\n+    vm5.invoke(() -> validateQueueContents(\"ln\", 0));\n+\n+    vm2.invoke(() -> validateRegionSize(className + \"_RR\", 1000));\n+    vm3.invoke(() -> validateRegionSize(className + \"_RR\", 1000));\n+  }\n+\n+  @Test\n+  public void testSerialGatewaySenderUpdateGatewayEventFiltersWhilePutting() throws Exception {\n+    int lnPort = vm0.invoke(() -> createFirstLocatorWithDSId(1));\n+    int nyPort = vm1.invoke(() -> createFirstRemoteLocator(2, lnPort));\n+\n+    List<GatewayEventFilter> filters = new ArrayList<>();\n+    filters.add(new MyGatewayEventFilter_AfterAck());\n+    filters.add(new PDXGatewayEventFilter());\n+\n+    for (VM vm : toArray(vm2, vm3)) {\n+      vm.invoke(() -> {\n+        createCache(nyPort);\n+        createReceiver();\n+      });\n+    }\n+\n+    vm4.invoke(() -> createCache(lnPort));\n+    vm5.invoke(() -> createCache(lnPort));\n+    vm6.invoke(() -> createCache(lnPort));\n+    vm7.invoke(() -> createCache(lnPort));\n+\n+    vm4.invoke(() -> createSenderInVm4());\n+    vm5.invoke(() -> createSenderInVm5());\n+\n+    vm2.invoke(() -> createReplicatedRegion(className + \"_RR\", null));\n+    vm3.invoke(() -> createReplicatedRegion(className + \"_RR\", null));\n+\n+    vm4.invoke(() -> createReplicatedRegion(className + \"_RR\", \"ln\"));\n+    vm5.invoke(() -> createReplicatedRegion(className + \"_RR\", \"ln\"));\n+    vm6.invoke(() -> createReplicatedRegion(className + \"_RR\", \"ln\"));\n+    vm7.invoke(() -> createReplicatedRegion(className + \"_RR\", \"ln\"));\n+\n+    for (VM vm : toArray(vm4, vm5)) {\n+      vm.invoke(() -> startSender(\"ln\"));\n+    }\n+\n+    // Do some puts from both vm4 and vm5 while restarting a sender\n+    AsyncInvocation doPutsInVm4 =\n+        vm4.invokeAsync(() -> doPuts(className + \"_RR\", 5000));\n+\n+    updateBatchSize(40);\n+    updateGatewayEventFilters(filters);\n+\n+    doPutsInVm4.await();\n+\n+    checkBatchSize(40);\n+\n+    vm4.invoke(() -> validateQueueContents(\"ln\", 0));\n+    vm5.invoke(() -> validateQueueContents(\"ln\", 0));\n+\n+    vm2.invoke(() -> validateRegionSize(className + \"_RR\", 5000));\n+    vm3.invoke(() -> validateRegionSize(className + \"_RR\", 5000));\n+  }\n+\n+  protected boolean isOffHeap() {\n+    return false;\n+  }\n+\n+  protected void createSenderInVm4() throws IOException {\n+    createSender(\"ln\", 2, true, true, numDispatchers, DEFAULT_ORDER_POLICY);\n+  }\n+\n+  protected void createSenderInVm5() throws IOException {\n+    createSender(\"ln\", 2, true, true, numDispatchers, DEFAULT_ORDER_POLICY);\n+  }\n+\n+  protected final void createSender(String id,\n+      int remoteDsId,\n+      boolean isPersistent,\n+      boolean isManualStart,\n+      int numDispatchers,\n+      OrderPolicy policy) throws IOException {\n+    try (IgnoredException ie = addIgnoredException(\"Could not connect\")) {\n+      File persistentDirectory =\n+          temporaryFolder.newFolder(id + \"_disk_\" + currentTimeMillis() + \"_\" + getCurrentVMNum());\n+      DiskStoreFactory diskStoreFactory = getCache().createDiskStoreFactory();\n+      File[] dirs = new File[] {persistentDirectory};\n+\n+      InternalGatewaySenderFactory gatewaySenderFactory =\n+          (InternalGatewaySenderFactory) getCache().createGatewaySenderFactory();\n+\n+      gatewaySenderFactory.setParallel(false);\n+      gatewaySenderFactory.setMaximumQueueMemory(100);\n+      gatewaySenderFactory.setBatchSize(10);\n+      gatewaySenderFactory.setBatchConflationEnabled(false);\n+      gatewaySenderFactory.setManualStart(isManualStart);\n+      gatewaySenderFactory.setDispatcherThreads(numDispatchers);\n+      gatewaySenderFactory.setOrderPolicy(policy);\n+      gatewaySenderFactory.setSocketBufferSize(DEFAULT_SOCKET_BUFFER_SIZE);\n+\n+      if (isPersistent) {\n+        gatewaySenderFactory.setPersistenceEnabled(true);\n+        gatewaySenderFactory.setDiskStoreName(\n+            diskStoreFactory.setDiskDirs(dirs).create(id).getName());\n+      } else {\n+        DiskStore store = diskStoreFactory.setDiskDirs(dirs).create(id);\n+        gatewaySenderFactory.setDiskStoreName(store.getName());\n+      }\n+\n+      gatewaySenderFactory.create(id, remoteDsId);\n+    }\n+  }\n+\n+  private Properties getDistributedSystemProperties(int locatorPort) {\n+    Properties props = getDistributedSystemProperties();\n+    props.setProperty(MCAST_PORT, \"0\");\n+    props.setProperty(LOCATORS, \"localhost[\" + locatorPort + \"]\");\n+    return props;\n+  }\n+\n+  private void createCache(int locatorPort) {\n+    getCache(getDistributedSystemProperties(locatorPort));\n+  }\n+\n+  private void createReplicatedRegion(String regionName, String senderIds) {\n+    try (IgnoredException ie1 = addIgnoredException(ForceReattemptException.class);\n+        IgnoredException ie2 = addIgnoredException(GatewaySenderException.class);\n+        IgnoredException ie3 = addIgnoredException(InterruptedException.class)) {\n+      RegionFactory regionFactory = getCache().createRegionFactory(REPLICATE);\n+\n+      if (senderIds != null) {\n+        StringTokenizer tokenizer = new StringTokenizer(senderIds, \",\");\n+        while (tokenizer.hasMoreTokens()) {\n+          String senderId = tokenizer.nextToken();\n+          regionFactory.addGatewaySenderId(senderId);\n+        }\n+      }\n+\n+      regionFactory.setDataPolicy(DataPolicy.REPLICATE);\n+      regionFactory.setScope(Scope.DISTRIBUTED_ACK);\n+      regionFactory.setOffHeap(isOffHeap());\n+\n+      regionFactory.create(regionName);\n+    }\n+  }\n+\n+  private void doPuts(String regionName, int count) {\n+    try (IgnoredException ie1 = addIgnoredException(GatewaySenderException.class);\n+        IgnoredException ie2 = addIgnoredException(InterruptedException.class)) {\n+      Region<Number, String> region = getCache().getRegion(SEPARATOR + regionName);\n+      for (int i = 0; i < count; i++) {\n+        region.put(i, \"Value_\" + i);\n+      }\n+    }\n+  }\n+\n+  private void doPuts(String regionName, int from, int count) {\n+    Region<Number, String> region = getCache().getRegion(SEPARATOR + regionName);\n+    for (int i = from; i < count; i++) {\n+      region.put(i, \"Value_\" + i);\n+    }\n+  }\n+\n+  private int createFirstLocatorWithDSId(int systemId) {\n+    stopOldLocator();\n+    int locatorPort = getRandomAvailableTCPPort();\n+    startLocator(systemId, locatorPort, locatorPort, -1, true);\n+    return locatorPort;\n+  }\n+\n+  private int createFirstRemoteLocator(int systemId, int remoteLocatorPort) {\n+    stopOldLocator();\n+    int locatorPort = getRandomAvailableTCPPort();\n+    startLocator(systemId, locatorPort, locatorPort, remoteLocatorPort, true);\n+    return locatorPort;\n+  }\n+\n+  private void startLocator(int systemId, int locatorPort, int startLocatorPort,\n+      int remoteLocatorPort, boolean startServerLocator) {\n+    Properties props = getDistributedSystemProperties();\n+\n+    props.setProperty(DISTRIBUTED_SYSTEM_ID, String.valueOf(systemId));\n+    props.setProperty(MCAST_PORT, \"0\");\n+    props.setProperty(LOCATORS, \"localhost[\" + locatorPort + \"]\");\n+    props.setProperty(START_LOCATOR, \"localhost[\" + startLocatorPort + \"],server=\"\n+        + startServerLocator + \",peer=true,hostname-for-clients=localhost\");\n+\n+    if (remoteLocatorPort != -1) {\n+      props.setProperty(REMOTE_LOCATORS, \"localhost[\" + remoteLocatorPort + \"]\");\n+    }\n+\n+    // Start start the locator with a LOCATOR_DM_TYPE and not a NORMAL_DM_TYPE\n+    System.setProperty(InternalLocator.FORCE_LOCATOR_DM_TYPE, \"true\");\n+    try {\n+      getSystem(props);\n+    } finally {\n+      System.clearProperty(InternalLocator.FORCE_LOCATOR_DM_TYPE);\n+    }\n+  }\n+\n+  private void stopOldLocator() {\n+    if (Locator.hasLocator()) {\n+      Locator.getLocator().stop();\n+    }\n+  }\n+\n+  private InternalGatewaySender findInternalGatewaySender(String senderId) {\n+    return (InternalGatewaySender) findGatewaySender(senderId, true);\n+  }\n+\n+  private GatewaySender findGatewaySender(String senderId) {\n+    return findGatewaySender(senderId, true);\n+  }\n+\n+  private GatewaySender findGatewaySender(String senderId, boolean assertNotNull) {\n+    Set<GatewaySender> senders = getCache().getGatewaySenders();\n+    GatewaySender sender = null;\n+    for (GatewaySender s : senders) {\n+      if (s.getId().equals(senderId)) {\n+        sender = s;\n+        break;\n+      }\n+    }\n+\n+    if (assertNotNull) {\n+      assertThat(sender).isNotNull();\n+    }\n+\n+    return sender;\n+  }\n+\n+  private void startSender(String senderId) {\n+    try (IgnoredException ie1 = addIgnoredException(\"Could not connect\");\n+        IgnoredException ie2 = addIgnoredException(ForceReattemptException.class);\n+        IgnoredException ie3 = addIgnoredException(InterruptedException.class)) {\n+      findGatewaySender(senderId).start();\n+    }\n+  }\n+\n+  private void pauseSender(String senderId) {\n+    try (IgnoredException ie1 = addIgnoredException(\"Could not connect\");\n+        IgnoredException ie2 = addIgnoredException(ForceReattemptException.class)) {\n+      InternalGatewaySender sender = findInternalGatewaySender(senderId);\n+      sender.pause();\n+      sender.getEventProcessor().waitForDispatcherToPause();\n+    }\n+  }\n+\n+  private void resumeSender(String senderId) {\n+    try (IgnoredException ie1 = addIgnoredException(\"Could not connect\");\n+        IgnoredException ie2 = addIgnoredException(ForceReattemptException.class)) {\n+      findGatewaySender(senderId).resume();\n+    }\n+  }\n+\n+  private void stopSender(String senderId) {\n+    try (IgnoredException ie1 = addIgnoredException(\"Could not connect\");\n+        IgnoredException ie2 = addIgnoredException(ForceReattemptException.class)) {\n+      InternalGatewaySender sender = findInternalGatewaySender(senderId);\n+\n+      AbstractGatewaySenderEventProcessor eventProcessor = sender.getEventProcessor();\n+\n+      sender.stop();\n+\n+      if (eventProcessor instanceof ConcurrentSerialGatewaySenderEventProcessor) {\n+        ConcurrentSerialGatewaySenderEventProcessor concurrentEventProcessor =\n+            (ConcurrentSerialGatewaySenderEventProcessor) eventProcessor;\n+        Set<RegionQueue> queues = concurrentEventProcessor.getQueues();\n+        for (RegionQueue queue : queues) {\n+          if (queue instanceof SerialGatewaySenderQueue) {\n+            assertThat(((SerialGatewaySenderQueue) queue).isRemovalThreadAlive())\n+                .isFalse();\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  private int createReceiver() throws IOException {\n+    int receiverPort = getRandomAvailableTCPPort();\n+\n+    GatewayReceiverFactory gatewayReceiverFactory = getCache().createGatewayReceiverFactory();\n+    gatewayReceiverFactory.setStartPort(receiverPort);\n+    gatewayReceiverFactory.setEndPort(receiverPort);\n+    gatewayReceiverFactory.setManualStart(true);\n+\n+    GatewayReceiver receiver = gatewayReceiverFactory.create();\n+    receiver.start();\n+\n+    return receiverPort;\n+  }\n+\n+  private void validateRegionSize(String regionName, int regionSize) {\n+    try (IgnoredException ie1 = addIgnoredException(CacheClosedException.class);\n+        IgnoredException ie2 = addIgnoredException(ForceReattemptException.class)) {\n+      Region region = getCache().getRegion(SEPARATOR + regionName);\n+\n+      await()\n+          .untilAsserted(() -> {\n+            assertThat(region.keySet()).hasSize(regionSize);\n+          });\n+    }\n+  }\n+\n+  private void validateQueueContents(String senderId, int regionSize) {\n+    try (IgnoredException ie1 = addIgnoredException(GatewaySenderException.class);\n+        IgnoredException ie2 = addIgnoredException(InterruptedException.class)) {\n+      InternalGatewaySender sender = findInternalGatewaySender(senderId);\n+\n+      if (sender.isParallel()) {\n+        RegionQueue regionQueue = sender.getQueues().toArray(new RegionQueue[1])[0];\n+        await()\n+            .untilAsserted(() -> {\n+              assertThat(regionQueue.size())\n+                  .isEqualTo(regionSize);\n+            });\n+\n+      } else {\n+        Set<RegionQueue> queues = sender.getQueues();\n+        await()\n+            .untilAsserted(() -> {\n+              int size = 0;\n+              for (RegionQueue queue : queues) {\n+                size += queue.size();\n+              }\n+              assertThat(size)\n+                  .isEqualTo(regionSize);\n+            });\n+      }\n+    }\n+  }\n+\n+  private void validateSenderPausedState(String senderId) {\n+    GatewaySender sender = findGatewaySender(senderId);\n+\n+    assertThat(sender.isPaused())\n+        .isTrue();\n+  }\n+\n+  private void validateSenderResumedState(String senderId) {\n+    GatewaySender sender = findGatewaySender(senderId);\n+\n+    assertThat(sender.isPaused())\n+        .isFalse();\n+    assertThat(sender.isRunning())\n+        .isTrue();\n+  }\n+\n+  private void updateBatchSize(int batchsize) {\n+    vm4.invoke(() -> {\n+      AbstractGatewaySender sender = (AbstractGatewaySender) cache.getGatewaySender(\"ln\");\n+      boolean paused = false;\n+      if (sender.isRunning() && !sender.isPaused()) {\n+        sender.pause();\n+        paused = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9430438d08a37857ec518fbb0682e99b94b72188"}, "originalPosition": 598}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI1NTUwOTIy", "url": "https://github.com/apache/geode/pull/5630#pullrequestreview-625550922", "createdAt": "2021-03-31T17:34:04Z", "commit": {"oid": "174e17590ffb320f23d9a5fba706e739f409fc40"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0zMVQxNzozNDowNFrOJBD3Qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0zMVQxNzozNDoxN1rOJBD30A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNTA5MTY1MQ==", "bodyText": "Can this be renamed to findGatewaySenderConfiguration or something more explicit?", "url": "https://github.com/apache/geode/pull/5630#discussion_r605091651", "createdAt": "2021-03-31T17:34:04Z", "author": {"login": "boglesby"}, "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/AlterGatewaySenderCommand.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.management.internal.cli.commands;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.shell.core.annotation.CliCommand;\n+import org.springframework.shell.core.annotation.CliOption;\n+\n+import org.apache.geode.cache.configuration.CacheConfig;\n+import org.apache.geode.cache.configuration.DeclarableType;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.InternalConfigurationPersistenceService;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+import org.apache.geode.management.cli.CliMetaData;\n+import org.apache.geode.management.cli.ConverterHint;\n+import org.apache.geode.management.cli.SingleGfshCommand;\n+import org.apache.geode.management.internal.cli.functions.AlterGatewaySenderFunction;\n+import org.apache.geode.management.internal.cli.functions.GatewaySenderFunctionArgs;\n+import org.apache.geode.management.internal.cli.result.model.ResultModel;\n+import org.apache.geode.management.internal.exceptions.EntityNotFoundException;\n+import org.apache.geode.management.internal.functions.CliFunctionResult;\n+import org.apache.geode.management.internal.i18n.CliStrings;\n+import org.apache.geode.management.internal.security.ResourceOperation;\n+import org.apache.geode.security.ResourcePermission;\n+\n+public class AlterGatewaySenderCommand extends SingleGfshCommand {\n+  private final AlterGatewaySenderFunction alterGatewaySenderFunction =\n+      new AlterGatewaySenderFunction();\n+  private static final Logger logger = LogService.getLogger();\n+\n+  @CliCommand(value = CliStrings.ALTER_GATEWAYSENDER,\n+      help = CliStrings.ALTER_GATEWAYSENDER__HELP)\n+  @CliMetaData(relatedTopic = CliStrings.TOPIC_GEODE_WAN)\n+  @ResourceOperation(resource = ResourcePermission.Resource.CLUSTER,\n+      operation = ResourcePermission.Operation.MANAGE, target = ResourcePermission.Target.GATEWAY)\n+\n+  public ResultModel alterGatewaySender(@CliOption(key = CliStrings.ALTER_GATEWAYSENDER__ID,\n+      mandatory = true, optionContext = ConverterHint.GATEWAY_SENDER_ID,\n+      help = CliStrings.ALTER_GATEWAYSENDER__ID__HELP) String senderId,\n+      @CliOption(key = {CliStrings.GROUP, CliStrings.GROUPS},\n+          optionContext = ConverterHint.MEMBERGROUP,\n+          help = CliStrings.ALTER_GATEWAYSENDER__GROUP__HELP) String[] onGroup,\n+      @CliOption(key = {CliStrings.MEMBER, CliStrings.MEMBERS},\n+          optionContext = ConverterHint.MEMBERIDNAME,\n+          help = CliStrings.ALTER_GATEWAYSENDER__MEMBER__HELP) String[] onMember,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__ALERTTHRESHOLD,\n+          help = CliStrings.ALTER_GATEWAYSENDER__ALERTTHRESHOLD__HELP) Integer alertThreshold,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__BATCHSIZE,\n+          help = CliStrings.ALTER_GATEWAYSENDER__BATCHSIZE__HELP) Integer batchSize,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__BATCHTIMEINTERVAL,\n+          help = CliStrings.ALTER_GATEWAYSENDER__BATCHTIMEINTERVAL__HELP) Integer batchTimeInterval,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__GATEWAYEVENTFILTER,\n+          specifiedDefaultValue = CliStrings.NULL,\n+          help = CliStrings.ALTER_GATEWAYSENDER__GATEWAYEVENTFILTER__HELP) String[] gatewayEventFilters,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__GROUPTRANSACTIONEVENTS,\n+          specifiedDefaultValue = \"true\",\n+          help = CliStrings.ALTER_GATEWAYSENDER__GROUPTRANSACTIONEVENTS__HELP) Boolean groupTransactionEvents)\n+      throws EntityNotFoundException {\n+\n+    // need not check if any running servers has this gateway-sender. A server with this\n+    // gateway-sender id\n+    // may be shutdown, but we still need to update Cluster Configuration.\n+    if (getConfigurationPersistenceService() == null) {\n+      return ResultModel.createError(\"Cluster Configuration Service is not available. \"\n+          + \"Please connect to a locator with running Cluster Configuration Service.\");\n+    }\n+\n+    final String id = senderId.trim();\n+\n+    CacheConfig.GatewaySender oldConfiguration = findGW(id);\n+\n+    if (oldConfiguration == null) {\n+      String message = String.format(\"Cannot find a gateway sender with id '%s'.\", id);\n+      throw new EntityNotFoundException(message);\n+    }\n+\n+    if (groupTransactionEvents != null && groupTransactionEvents\n+        && !oldConfiguration.mustGroupTransactionEvents()) {\n+      if (!oldConfiguration.isParallel() && (oldConfiguration.getDispatcherThreads() == null\n+          || Integer.parseInt(oldConfiguration.getDispatcherThreads()) > 1)) {\n+        return ResultModel.createError(\n+            \"alter-gateway-sender cannot be performed for --group-transaction-events attribute if serial sender and dispatcher-threads is greater than 1.\");\n+      }\n+\n+      if (oldConfiguration.isEnableBatchConflation()) {\n+        return ResultModel.createError(\n+            \"alter-gateway-sender cannot be performed for --group-transaction-events attribute if batch-conflation is enabled.\");\n+      }\n+    }\n+\n+    Set<DistributedMember> dsMembers = findMembers(onGroup, onMember);\n+\n+    if (dsMembers.isEmpty()) {\n+      return ResultModel.createError(CliStrings.NO_MEMBERS_FOUND_MESSAGE);\n+    }\n+\n+    CacheConfig.GatewaySender gwConfiguration = new CacheConfig.GatewaySender();\n+    gwConfiguration.setId(id);\n+\n+    boolean modify = false;\n+\n+    if (alertThreshold != null) {\n+      modify = true;\n+      gwConfiguration.setAlertThreshold(alertThreshold.toString());\n+    }\n+\n+    if (batchSize != null) {\n+      modify = true;\n+      gwConfiguration.setBatchSize(batchSize.toString());\n+    }\n+\n+    if (batchTimeInterval != null) {\n+      modify = true;\n+      gwConfiguration.setBatchTimeInterval(batchTimeInterval.toString());\n+    }\n+\n+    if (groupTransactionEvents != null) {\n+      modify = true;\n+      gwConfiguration.setGroupTransactionEvents(groupTransactionEvents);\n+    }\n+\n+    if (gatewayEventFilters != null) {\n+      modify = true;\n+      if (gatewayEventFilters.length == 1\n+          && gatewayEventFilters[0].equalsIgnoreCase(CliStrings.NULL)) {\n+        gwConfiguration.getGatewayEventFilters();\n+      } else {\n+        gwConfiguration.getGatewayEventFilters()\n+            .addAll((stringsToDeclarableTypes(gatewayEventFilters)));\n+      }\n+    }\n+\n+    if (!modify) {\n+      return ResultModel.createError(CliStrings.ALTER_GATEWAYSENDER__RELEVANT__OPTION__MESSAGE);\n+    }\n+\n+    GatewaySenderFunctionArgs gatewaySenderFunctionArgs =\n+        new GatewaySenderFunctionArgs(gwConfiguration);\n+\n+    List<CliFunctionResult> gatewaySenderAlterResults =\n+        executeAndGetFunctionResult(alterGatewaySenderFunction, gatewaySenderFunctionArgs,\n+            dsMembers);\n+\n+    ResultModel resultModel = ResultModel.createMemberStatusResult(gatewaySenderAlterResults);\n+\n+    resultModel.setConfigObject(gwConfiguration);\n+\n+    return resultModel;\n+  }\n+\n+  @Override\n+  public boolean updateConfigForGroup(String group, CacheConfig config, Object configObject) {\n+    List<CacheConfig.GatewaySender> gwSenders = config.getGatewaySenders();\n+    if (gwSenders.isEmpty()) {\n+      return false;\n+    }\n+\n+    boolean gwConfigsHaveBeenUpdated = false;\n+    CacheConfig.GatewaySender gwConfiguration =\n+        ((CacheConfig.GatewaySender) configObject);\n+\n+    String gwId = gwConfiguration.getId();\n+\n+    for (CacheConfig.GatewaySender sender : gwSenders) {\n+      if (gwId.equals(sender.getId())) {\n+        gwConfigsHaveBeenUpdated = true;\n+        if (StringUtils.isNotBlank(gwConfiguration.getBatchSize())) {\n+          sender.setBatchSize(gwConfiguration.getBatchSize());\n+        }\n+\n+        if (StringUtils.isNotBlank(gwConfiguration.getBatchTimeInterval())) {\n+          sender.setBatchTimeInterval(gwConfiguration.getBatchTimeInterval());\n+        }\n+\n+        if (StringUtils.isNotBlank(gwConfiguration.getAlertThreshold())) {\n+          sender.setAlertThreshold(gwConfiguration.getAlertThreshold());\n+        }\n+        if (gwConfiguration.mustGroupTransactionEvents() != null) {\n+          sender.setGroupTransactionEvents(gwConfiguration.mustGroupTransactionEvents());\n+        }\n+\n+        if (gwConfiguration.areGatewayEventFiltersUpdated()) {\n+          if (!sender.getGatewayEventFilters().isEmpty()) {\n+            sender.getGatewayEventFilters().clear();\n+          }\n+          if (!gwConfiguration.getGatewayEventFilters().isEmpty()) {\n+            sender.getGatewayEventFilters().addAll(gwConfiguration.getGatewayEventFilters());\n+          }\n+        }\n+\n+      }\n+    }\n+    return gwConfigsHaveBeenUpdated;\n+\n+  }\n+\n+  private CacheConfig.GatewaySender findGW(String gwId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "174e17590ffb320f23d9a5fba706e739f409fc40"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNTA5MTc5Mg==", "bodyText": "This cast is not necessary.", "url": "https://github.com/apache/geode/pull/5630#discussion_r605091792", "createdAt": "2021-03-31T17:34:17Z", "author": {"login": "boglesby"}, "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/AlterGatewaySenderCommand.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.management.internal.cli.commands;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.shell.core.annotation.CliCommand;\n+import org.springframework.shell.core.annotation.CliOption;\n+\n+import org.apache.geode.cache.configuration.CacheConfig;\n+import org.apache.geode.cache.configuration.DeclarableType;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.InternalConfigurationPersistenceService;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+import org.apache.geode.management.cli.CliMetaData;\n+import org.apache.geode.management.cli.ConverterHint;\n+import org.apache.geode.management.cli.SingleGfshCommand;\n+import org.apache.geode.management.internal.cli.functions.AlterGatewaySenderFunction;\n+import org.apache.geode.management.internal.cli.functions.GatewaySenderFunctionArgs;\n+import org.apache.geode.management.internal.cli.result.model.ResultModel;\n+import org.apache.geode.management.internal.exceptions.EntityNotFoundException;\n+import org.apache.geode.management.internal.functions.CliFunctionResult;\n+import org.apache.geode.management.internal.i18n.CliStrings;\n+import org.apache.geode.management.internal.security.ResourceOperation;\n+import org.apache.geode.security.ResourcePermission;\n+\n+public class AlterGatewaySenderCommand extends SingleGfshCommand {\n+  private final AlterGatewaySenderFunction alterGatewaySenderFunction =\n+      new AlterGatewaySenderFunction();\n+  private static final Logger logger = LogService.getLogger();\n+\n+  @CliCommand(value = CliStrings.ALTER_GATEWAYSENDER,\n+      help = CliStrings.ALTER_GATEWAYSENDER__HELP)\n+  @CliMetaData(relatedTopic = CliStrings.TOPIC_GEODE_WAN)\n+  @ResourceOperation(resource = ResourcePermission.Resource.CLUSTER,\n+      operation = ResourcePermission.Operation.MANAGE, target = ResourcePermission.Target.GATEWAY)\n+\n+  public ResultModel alterGatewaySender(@CliOption(key = CliStrings.ALTER_GATEWAYSENDER__ID,\n+      mandatory = true, optionContext = ConverterHint.GATEWAY_SENDER_ID,\n+      help = CliStrings.ALTER_GATEWAYSENDER__ID__HELP) String senderId,\n+      @CliOption(key = {CliStrings.GROUP, CliStrings.GROUPS},\n+          optionContext = ConverterHint.MEMBERGROUP,\n+          help = CliStrings.ALTER_GATEWAYSENDER__GROUP__HELP) String[] onGroup,\n+      @CliOption(key = {CliStrings.MEMBER, CliStrings.MEMBERS},\n+          optionContext = ConverterHint.MEMBERIDNAME,\n+          help = CliStrings.ALTER_GATEWAYSENDER__MEMBER__HELP) String[] onMember,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__ALERTTHRESHOLD,\n+          help = CliStrings.ALTER_GATEWAYSENDER__ALERTTHRESHOLD__HELP) Integer alertThreshold,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__BATCHSIZE,\n+          help = CliStrings.ALTER_GATEWAYSENDER__BATCHSIZE__HELP) Integer batchSize,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__BATCHTIMEINTERVAL,\n+          help = CliStrings.ALTER_GATEWAYSENDER__BATCHTIMEINTERVAL__HELP) Integer batchTimeInterval,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__GATEWAYEVENTFILTER,\n+          specifiedDefaultValue = CliStrings.NULL,\n+          help = CliStrings.ALTER_GATEWAYSENDER__GATEWAYEVENTFILTER__HELP) String[] gatewayEventFilters,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__GROUPTRANSACTIONEVENTS,\n+          specifiedDefaultValue = \"true\",\n+          help = CliStrings.ALTER_GATEWAYSENDER__GROUPTRANSACTIONEVENTS__HELP) Boolean groupTransactionEvents)\n+      throws EntityNotFoundException {\n+\n+    // need not check if any running servers has this gateway-sender. A server with this\n+    // gateway-sender id\n+    // may be shutdown, but we still need to update Cluster Configuration.\n+    if (getConfigurationPersistenceService() == null) {\n+      return ResultModel.createError(\"Cluster Configuration Service is not available. \"\n+          + \"Please connect to a locator with running Cluster Configuration Service.\");\n+    }\n+\n+    final String id = senderId.trim();\n+\n+    CacheConfig.GatewaySender oldConfiguration = findGW(id);\n+\n+    if (oldConfiguration == null) {\n+      String message = String.format(\"Cannot find a gateway sender with id '%s'.\", id);\n+      throw new EntityNotFoundException(message);\n+    }\n+\n+    if (groupTransactionEvents != null && groupTransactionEvents\n+        && !oldConfiguration.mustGroupTransactionEvents()) {\n+      if (!oldConfiguration.isParallel() && (oldConfiguration.getDispatcherThreads() == null\n+          || Integer.parseInt(oldConfiguration.getDispatcherThreads()) > 1)) {\n+        return ResultModel.createError(\n+            \"alter-gateway-sender cannot be performed for --group-transaction-events attribute if serial sender and dispatcher-threads is greater than 1.\");\n+      }\n+\n+      if (oldConfiguration.isEnableBatchConflation()) {\n+        return ResultModel.createError(\n+            \"alter-gateway-sender cannot be performed for --group-transaction-events attribute if batch-conflation is enabled.\");\n+      }\n+    }\n+\n+    Set<DistributedMember> dsMembers = findMembers(onGroup, onMember);\n+\n+    if (dsMembers.isEmpty()) {\n+      return ResultModel.createError(CliStrings.NO_MEMBERS_FOUND_MESSAGE);\n+    }\n+\n+    CacheConfig.GatewaySender gwConfiguration = new CacheConfig.GatewaySender();\n+    gwConfiguration.setId(id);\n+\n+    boolean modify = false;\n+\n+    if (alertThreshold != null) {\n+      modify = true;\n+      gwConfiguration.setAlertThreshold(alertThreshold.toString());\n+    }\n+\n+    if (batchSize != null) {\n+      modify = true;\n+      gwConfiguration.setBatchSize(batchSize.toString());\n+    }\n+\n+    if (batchTimeInterval != null) {\n+      modify = true;\n+      gwConfiguration.setBatchTimeInterval(batchTimeInterval.toString());\n+    }\n+\n+    if (groupTransactionEvents != null) {\n+      modify = true;\n+      gwConfiguration.setGroupTransactionEvents(groupTransactionEvents);\n+    }\n+\n+    if (gatewayEventFilters != null) {\n+      modify = true;\n+      if (gatewayEventFilters.length == 1\n+          && gatewayEventFilters[0].equalsIgnoreCase(CliStrings.NULL)) {\n+        gwConfiguration.getGatewayEventFilters();\n+      } else {\n+        gwConfiguration.getGatewayEventFilters()\n+            .addAll((stringsToDeclarableTypes(gatewayEventFilters)));\n+      }\n+    }\n+\n+    if (!modify) {\n+      return ResultModel.createError(CliStrings.ALTER_GATEWAYSENDER__RELEVANT__OPTION__MESSAGE);\n+    }\n+\n+    GatewaySenderFunctionArgs gatewaySenderFunctionArgs =\n+        new GatewaySenderFunctionArgs(gwConfiguration);\n+\n+    List<CliFunctionResult> gatewaySenderAlterResults =\n+        executeAndGetFunctionResult(alterGatewaySenderFunction, gatewaySenderFunctionArgs,\n+            dsMembers);\n+\n+    ResultModel resultModel = ResultModel.createMemberStatusResult(gatewaySenderAlterResults);\n+\n+    resultModel.setConfigObject(gwConfiguration);\n+\n+    return resultModel;\n+  }\n+\n+  @Override\n+  public boolean updateConfigForGroup(String group, CacheConfig config, Object configObject) {\n+    List<CacheConfig.GatewaySender> gwSenders = config.getGatewaySenders();\n+    if (gwSenders.isEmpty()) {\n+      return false;\n+    }\n+\n+    boolean gwConfigsHaveBeenUpdated = false;\n+    CacheConfig.GatewaySender gwConfiguration =\n+        ((CacheConfig.GatewaySender) configObject);\n+\n+    String gwId = gwConfiguration.getId();\n+\n+    for (CacheConfig.GatewaySender sender : gwSenders) {\n+      if (gwId.equals(sender.getId())) {\n+        gwConfigsHaveBeenUpdated = true;\n+        if (StringUtils.isNotBlank(gwConfiguration.getBatchSize())) {\n+          sender.setBatchSize(gwConfiguration.getBatchSize());\n+        }\n+\n+        if (StringUtils.isNotBlank(gwConfiguration.getBatchTimeInterval())) {\n+          sender.setBatchTimeInterval(gwConfiguration.getBatchTimeInterval());\n+        }\n+\n+        if (StringUtils.isNotBlank(gwConfiguration.getAlertThreshold())) {\n+          sender.setAlertThreshold(gwConfiguration.getAlertThreshold());\n+        }\n+        if (gwConfiguration.mustGroupTransactionEvents() != null) {\n+          sender.setGroupTransactionEvents(gwConfiguration.mustGroupTransactionEvents());\n+        }\n+\n+        if (gwConfiguration.areGatewayEventFiltersUpdated()) {\n+          if (!sender.getGatewayEventFilters().isEmpty()) {\n+            sender.getGatewayEventFilters().clear();\n+          }\n+          if (!gwConfiguration.getGatewayEventFilters().isEmpty()) {\n+            sender.getGatewayEventFilters().addAll(gwConfiguration.getGatewayEventFilters());\n+          }\n+        }\n+\n+      }\n+    }\n+    return gwConfigsHaveBeenUpdated;\n+\n+  }\n+\n+  private CacheConfig.GatewaySender findGW(String gwId) {\n+    CacheConfig.GatewaySender gwsender = null;\n+    InternalConfigurationPersistenceService ccService =\n+        (InternalConfigurationPersistenceService) this.getConfigurationPersistenceService();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "174e17590ffb320f23d9a5fba706e739f409fc40"}, "originalPosition": 219}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI2NTYxMTkz", "url": "https://github.com/apache/geode/pull/5630#pullrequestreview-626561193", "createdAt": "2021-04-01T18:56:26Z", "commit": {"oid": "174e17590ffb320f23d9a5fba706e739f409fc40"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wMVQxODo1NjoyNlrOJBz46w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wMVQxODo1NjoyNlrOJBz46w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNTg3ODUwNw==", "bodyText": "A new way to do this is to use ClassName[]. The gfsh parser will parse the comma separated list and any initialization json and put them into this ClassName array for you. See AlterRegionCommand for examples.", "url": "https://github.com/apache/geode/pull/5630#discussion_r605878507", "createdAt": "2021-04-01T18:56:26Z", "author": {"login": "jinmeiliao"}, "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/AlterGatewaySenderCommand.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.management.internal.cli.commands;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.shell.core.annotation.CliCommand;\n+import org.springframework.shell.core.annotation.CliOption;\n+\n+import org.apache.geode.cache.configuration.CacheConfig;\n+import org.apache.geode.cache.configuration.DeclarableType;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.InternalConfigurationPersistenceService;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+import org.apache.geode.management.cli.CliMetaData;\n+import org.apache.geode.management.cli.ConverterHint;\n+import org.apache.geode.management.cli.SingleGfshCommand;\n+import org.apache.geode.management.internal.cli.functions.AlterGatewaySenderFunction;\n+import org.apache.geode.management.internal.cli.functions.GatewaySenderFunctionArgs;\n+import org.apache.geode.management.internal.cli.result.model.ResultModel;\n+import org.apache.geode.management.internal.exceptions.EntityNotFoundException;\n+import org.apache.geode.management.internal.functions.CliFunctionResult;\n+import org.apache.geode.management.internal.i18n.CliStrings;\n+import org.apache.geode.management.internal.security.ResourceOperation;\n+import org.apache.geode.security.ResourcePermission;\n+\n+public class AlterGatewaySenderCommand extends SingleGfshCommand {\n+  private final AlterGatewaySenderFunction alterGatewaySenderFunction =\n+      new AlterGatewaySenderFunction();\n+  private static final Logger logger = LogService.getLogger();\n+\n+  @CliCommand(value = CliStrings.ALTER_GATEWAYSENDER,\n+      help = CliStrings.ALTER_GATEWAYSENDER__HELP)\n+  @CliMetaData(relatedTopic = CliStrings.TOPIC_GEODE_WAN)\n+  @ResourceOperation(resource = ResourcePermission.Resource.CLUSTER,\n+      operation = ResourcePermission.Operation.MANAGE, target = ResourcePermission.Target.GATEWAY)\n+\n+  public ResultModel alterGatewaySender(@CliOption(key = CliStrings.ALTER_GATEWAYSENDER__ID,\n+      mandatory = true, optionContext = ConverterHint.GATEWAY_SENDER_ID,\n+      help = CliStrings.ALTER_GATEWAYSENDER__ID__HELP) String senderId,\n+      @CliOption(key = {CliStrings.GROUP, CliStrings.GROUPS},\n+          optionContext = ConverterHint.MEMBERGROUP,\n+          help = CliStrings.ALTER_GATEWAYSENDER__GROUP__HELP) String[] onGroup,\n+      @CliOption(key = {CliStrings.MEMBER, CliStrings.MEMBERS},\n+          optionContext = ConverterHint.MEMBERIDNAME,\n+          help = CliStrings.ALTER_GATEWAYSENDER__MEMBER__HELP) String[] onMember,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__ALERTTHRESHOLD,\n+          help = CliStrings.ALTER_GATEWAYSENDER__ALERTTHRESHOLD__HELP) Integer alertThreshold,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__BATCHSIZE,\n+          help = CliStrings.ALTER_GATEWAYSENDER__BATCHSIZE__HELP) Integer batchSize,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__BATCHTIMEINTERVAL,\n+          help = CliStrings.ALTER_GATEWAYSENDER__BATCHTIMEINTERVAL__HELP) Integer batchTimeInterval,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__GATEWAYEVENTFILTER,\n+          specifiedDefaultValue = CliStrings.NULL,\n+          help = CliStrings.ALTER_GATEWAYSENDER__GATEWAYEVENTFILTER__HELP) String[] gatewayEventFilters,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "174e17590ffb320f23d9a5fba706e739f409fc40"}, "originalPosition": 73}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI2NzA4OTI4", "url": "https://github.com/apache/geode/pull/5630#pullrequestreview-626708928", "createdAt": "2021-04-01T23:24:49Z", "commit": {"oid": "174e17590ffb320f23d9a5fba706e739f409fc40"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad87607ef90248b63d999749b2df0da8a9d129ab", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/ad87607ef90248b63d999749b2df0da8a9d129ab", "committedDate": "2021-04-02T07:42:08Z", "message": "GEODE-8605: Alter Gateway Sender command"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8015da3bf0c5e925ddea533bb9c526a881265424", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/8015da3bf0c5e925ddea533bb9c526a881265424", "committedDate": "2021-04-02T07:42:08Z", "message": "GEODE-8605: fix for failing integration test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd1886c9430c19c5b3577c1008123bcdd8b5e1b4", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/dd1886c9430c19c5b3577c1008123bcdd8b5e1b4", "committedDate": "2021-04-02T07:42:08Z", "message": "GEODE-8605: added distributed test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b2ca734617883dd0391a6976e69fb17de8b4f23", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/9b2ca734617883dd0391a6976e69fb17de8b4f23", "committedDate": "2021-04-02T07:42:08Z", "message": "GEODE-8605: update stability of distributed tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "538737cd5305271e2d5045da4ff8392072144eeb", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/538737cd5305271e2d5045da4ff8392072144eeb", "committedDate": "2021-04-02T07:42:08Z", "message": "GEODE-8605: added documentation impacts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "745efbf72edad6275e1afb65fb495ee343cb0781", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/745efbf72edad6275e1afb65fb495ee343cb0781", "committedDate": "2021-04-02T07:42:08Z", "message": "GEODE-8605: added test for new function"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d2c58e5758ed715ddbb34587638cab79deb9d95a", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/d2c58e5758ed715ddbb34587638cab79deb9d95a", "committedDate": "2021-04-02T07:42:08Z", "message": "GEODE-8605: added filter test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "80409500ab7ba5c08a2c8203bff60cdfa8e7c1b5", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/80409500ab7ba5c08a2c8203bff60cdfa8e7c1b5", "committedDate": "2021-04-02T07:42:08Z", "message": "GEODE-8605: update after comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09f491d08d94ec91ba3a9b802fb75806c60abab9", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/09f491d08d94ec91ba3a9b802fb75806c60abab9", "committedDate": "2021-04-02T07:42:08Z", "message": "GEODE-8605: update solution"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9d2bf4a7f71317528a71c019158e0d871eb69e2", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/c9d2bf4a7f71317528a71c019158e0d871eb69e2", "committedDate": "2021-04-02T07:42:08Z", "message": "GEODE-8605: add test for parallel gw sender"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05fb8c0bf2c9b80a41ef9178abb5f76ab7176f5c", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/05fb8c0bf2c9b80a41ef9178abb5f76ab7176f5c", "committedDate": "2021-04-02T07:42:08Z", "message": "GEODE-8605: added setters instead of update"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9caceb72e00fa77d4226e449c6f9d28abd908d4", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/c9caceb72e00fa77d4226e449c6f9d28abd908d4", "committedDate": "2021-04-02T07:42:08Z", "message": "GEODE-8605: added ParallelGatewaySender tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d9af7eee77c6c99cb982977028071a2bac49d71", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/2d9af7eee77c6c99cb982977028071a2bac49d71", "committedDate": "2021-04-02T07:42:08Z", "message": "GEODE-8605: added test for SerialGatewaySender"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e0c356cdf5f5631e08e2f10ac0c9e045401702cb", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/e0c356cdf5f5631e08e2f10ac0c9e045401702cb", "committedDate": "2021-04-02T07:42:08Z", "message": "GEODE-8605: update solution"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d240f9f961c2a5aaf5cf49933ec036ebbcbe1658", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/d240f9f961c2a5aaf5cf49933ec036ebbcbe1658", "committedDate": "2021-04-02T07:42:08Z", "message": "GEODE-8605: add option to remove gateway-event-filters"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b1d8158bf5d6088a47842081bc4e57c7c368697c", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/b1d8158bf5d6088a47842081bc4e57c7c368697c", "committedDate": "2021-04-02T07:42:08Z", "message": "GEODE-8605: update of remove filters solution"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b2dcfbfacb550905a76be70c5859a472c8b3266", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/2b2dcfbfacb550905a76be70c5859a472c8b3266", "committedDate": "2021-04-02T07:42:09Z", "message": "GEODE-8605: rebase solution"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4901476d7fa830dbe7d555d5fbb40d3b23eb884", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/f4901476d7fa830dbe7d555d5fbb40d3b23eb884", "committedDate": "2021-04-02T07:42:09Z", "message": "GEODE-8605: added serialVersionUID to GatewaySender"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0abfae9d3630139ea775d75f97ab39b3b7a286ca", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/0abfae9d3630139ea775d75f97ab39b3b7a286ca", "committedDate": "2021-04-02T07:42:09Z", "message": "GEODE-8605: added test case"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7dae1cff7debe0c80e915dbdc2bdade33a0499ea", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/7dae1cff7debe0c80e915dbdc2bdade33a0499ea", "committedDate": "2021-04-02T07:42:09Z", "message": "GEODE-8605: remove changes in CacheConfig.GatewaySender"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e1e38dbcce30c12bfc923713f27d5f1294034f3", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/7e1e38dbcce30c12bfc923713f27d5f1294034f3", "committedDate": "2021-04-02T07:42:09Z", "message": "GEODE-8605: add setters to GatewaySenderAttributes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d5ebbec6bfdca4fb24f4c9a1a69de74b3a91ac4", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/8d5ebbec6bfdca4fb24f4c9a1a69de74b3a91ac4", "committedDate": "2021-04-02T07:42:09Z", "message": "GEODE-8605: small update"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "31b00db23e56b19d0d8d639901d232903229e703", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/31b00db23e56b19d0d8d639901d232903229e703", "committedDate": "2021-04-02T07:42:10Z", "message": "GEODE-8605: update after rebase"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e60ac37d8736337af5964628fab3057f6e68eb3f", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/e60ac37d8736337af5964628fab3057f6e68eb3f", "committedDate": "2021-04-02T07:42:10Z", "message": "GEODE-8605: update after comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b7ad4ccfc5eca1b1b7c90679146c3eb5b40b343", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/0b7ad4ccfc5eca1b1b7c90679146c3eb5b40b343", "committedDate": "2021-04-02T17:46:16Z", "message": "GEODE-8605: update after comments without atomic change"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "174e17590ffb320f23d9a5fba706e739f409fc40", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/174e17590ffb320f23d9a5fba706e739f409fc40", "committedDate": "2021-03-30T15:55:07Z", "message": "GEODE-8605: update after comments"}, "afterCommit": {"oid": "0b7ad4ccfc5eca1b1b7c90679146c3eb5b40b343", "author": {"user": {"login": "mivanac", "name": "Mario Ivanac"}}, "url": "https://github.com/apache/geode/commit/0b7ad4ccfc5eca1b1b7c90679146c3eb5b40b343", "committedDate": "2021-04-02T17:46:16Z", "message": "GEODE-8605: update after comments without atomic change"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4113, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}