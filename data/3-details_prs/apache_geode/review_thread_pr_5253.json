{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM0OTcxOTE4", "number": 5253, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjozNDowOFrOEGbVLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNTo1Mzo1MlrOEKKe7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTc0NzAyOnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/cache/client/internal/OpExecutorImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjozNDowOFrOGlN0og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNjoyODozM1rOGrEo7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY3Njk2Mg==", "bodyText": "you should remove this commented-out code", "url": "https://github.com/apache/geode/pull/5253#discussion_r441676962", "createdAt": "2020-06-17T16:34:08Z", "author": {"login": "bschuchardt"}, "path": "geode-core/src/main/java/org/apache/geode/cache/client/internal/OpExecutorImpl.java", "diffHunk": "@@ -556,8 +556,8 @@ protected void handleException(Throwable e, Connection conn, int retryCount, boo\n       title = null;\n       exToThrow = new ServerOperationException(e);\n     } else if (e instanceof SerializationException) {\n-      title = null; // no message\n-      exToThrow = new ServerOperationException(e);\n+      title = \"Unexpected SerializationException\";\n+      // exToThrow = new ServerOperationException(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2779bdd875b000f3683751c32ea279e76b866ceb"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgxNzk2NQ==", "bodyText": "We have a new fix.", "url": "https://github.com/apache/geode/pull/5253#discussion_r447817965", "createdAt": "2020-06-30T16:28:33Z", "author": {"login": "gesterzhou"}, "path": "geode-core/src/main/java/org/apache/geode/cache/client/internal/OpExecutorImpl.java", "diffHunk": "@@ -556,8 +556,8 @@ protected void handleException(Throwable e, Connection conn, int retryCount, boo\n       title = null;\n       exToThrow = new ServerOperationException(e);\n     } else if (e instanceof SerializationException) {\n-      title = null; // no message\n-      exToThrow = new ServerOperationException(e);\n+      title = \"Unexpected SerializationException\";\n+      // exToThrow = new ServerOperationException(e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY3Njk2Mg=="}, "originalCommit": {"oid": "2779bdd875b000f3683751c32ea279e76b866ceb"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTc1NDUxOnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/internal/InternalDataSerializer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjozNjowNlrOGlN5Yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMTo1MjoxNlrOGn780g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY3ODE3OQ==", "bodyText": "I still think you should catch CancelException and propagate that instead of a SerializationException", "url": "https://github.com/apache/geode/pull/5253#discussion_r441678179", "createdAt": "2020-06-17T16:36:06Z", "author": {"login": "bschuchardt"}, "path": "geode-core/src/main/java/org/apache/geode/internal/InternalDataSerializer.java", "diffHunk": "@@ -2506,153 +2506,156 @@ public static Object basicReadObject(final DataInput in)\n       throw new IOException(\"Unknown header byte: \" + header);\n     }\n \n-    switch (headerDSCode) {\n-      case DS_FIXED_ID_BYTE:\n-        return dsfidFactory.create(in.readByte(), in);\n-      case DS_FIXED_ID_SHORT:\n-        return dsfidFactory.create(in.readShort(), in);\n-      case DS_FIXED_ID_INT:\n-        return dsfidFactory.create(in.readInt(), in);\n-      case DS_NO_FIXED_ID:\n-      case DATA_SERIALIZABLE:\n-        return readDataSerializable(in);\n-      case NULL:\n-      case NULL_STRING:\n-        return null;\n-      case STRING:\n-        return readStringUTFFromDataInput(in);\n-      case HUGE_STRING:\n-        return readHugeStringFromDataInput(in);\n-      case STRING_BYTES:\n-        return readStringBytesFromDataInput(in, in.readUnsignedShort());\n-      case HUGE_STRING_BYTES:\n-        return readStringBytesFromDataInput(in, in.readInt());\n-      case CLASS:\n-        return readClass(in);\n-      case DATE:\n-        return readDate(in);\n-      case FILE:\n-        return readFile(in);\n-      case INET_ADDRESS:\n-        return readInetAddress(in);\n-      case BOOLEAN:\n-        return readBoolean(in);\n-      case CHARACTER:\n-        return readCharacter(in);\n-      case BYTE:\n-        return readByte(in);\n-      case SHORT:\n-        return readShort(in);\n-      case INTEGER:\n-        return readInteger(in);\n-      case LONG:\n-        return readLong(in);\n-      case FLOAT:\n-        return readFloat(in);\n-      case DOUBLE:\n-        return readDouble(in);\n-      case BYTE_ARRAY:\n-        return readByteArray(in);\n-      case ARRAY_OF_BYTE_ARRAYS:\n-        return readArrayOfByteArrays(in);\n-      case SHORT_ARRAY:\n-        return readShortArray(in);\n-      case STRING_ARRAY:\n-        return readStringArray(in);\n-      case INT_ARRAY:\n-        return readIntArray(in);\n-      case LONG_ARRAY:\n-        return readLongArray(in);\n-      case FLOAT_ARRAY:\n-        return readFloatArray(in);\n-      case DOUBLE_ARRAY:\n-        return readDoubleArray(in);\n-      case BOOLEAN_ARRAY:\n-        return readBooleanArray(in);\n-      case CHAR_ARRAY:\n-        return readCharArray(in);\n-      case OBJECT_ARRAY:\n-        return readObjectArray(in);\n-      case ARRAY_LIST:\n-        return readArrayList(in);\n-      case LINKED_LIST:\n-        return readLinkedList(in);\n-      case HASH_SET:\n-        return readHashSet(in);\n-      case LINKED_HASH_SET:\n-        return readLinkedHashSet(in);\n-      case HASH_MAP:\n-        return readHashMap(in);\n-      case IDENTITY_HASH_MAP:\n-        return readIdentityHashMap(in);\n-      case HASH_TABLE:\n-        return readHashtable(in);\n-      case CONCURRENT_HASH_MAP:\n-        return readConcurrentHashMap(in);\n-      case PROPERTIES:\n-        return readProperties(in);\n-      case TIME_UNIT:\n-        return readTimeUnit(in);\n-      case USER_CLASS:\n-        return readUserObject(in, in.readByte());\n-      case USER_CLASS_2:\n-        return readUserObject(in, in.readShort());\n-      case USER_CLASS_4:\n-        return readUserObject(in, in.readInt());\n-      case VECTOR:\n-        return readVector(in);\n-      case STACK:\n-        return readStack(in);\n-      case TREE_MAP:\n-        return readTreeMap(in);\n-      case TREE_SET:\n-        return readTreeSet(in);\n-      case BOOLEAN_TYPE:\n-        return Boolean.TYPE;\n-      case CHARACTER_TYPE:\n-        return Character.TYPE;\n-      case BYTE_TYPE:\n-        return Byte.TYPE;\n-      case SHORT_TYPE:\n-        return Short.TYPE;\n-      case INTEGER_TYPE:\n-        return Integer.TYPE;\n-      case LONG_TYPE:\n-        return Long.TYPE;\n-      case FLOAT_TYPE:\n-        return Float.TYPE;\n-      case DOUBLE_TYPE:\n-        return Double.TYPE;\n-      case VOID_TYPE:\n-        return Void.TYPE;\n-      case USER_DATA_SERIALIZABLE:\n-        return readUserDataSerializable(in, in.readByte());\n-      case USER_DATA_SERIALIZABLE_2:\n-        return readUserDataSerializable(in, in.readShort());\n-      case USER_DATA_SERIALIZABLE_4:\n-        return readUserDataSerializable(in, in.readInt());\n-      case SERIALIZABLE:\n-        return readSerializable(in);\n-      case PDX:\n-        return readPdxSerializable(in);\n-      case PDX_ENUM:\n-        return readPdxEnum(in);\n-      case GEMFIRE_ENUM:\n-        return readGemFireEnum(in);\n-      case PDX_INLINE_ENUM:\n-        return readPdxInlineEnum(in);\n-      case BIG_INTEGER:\n-        return readBigInteger(in);\n-      case BIG_DECIMAL:\n-        return readBigDecimal(in);\n-      case UUID:\n-        return readUUID(in);\n-      case TIMESTAMP:\n-        return readTimestamp(in);\n-      default:\n-        throw new IOException(\"Unknown header byte: \" + header);\n+    try {\n+      switch (headerDSCode) {\n+        case DS_FIXED_ID_BYTE:\n+          return dsfidFactory.create(in.readByte(), in);\n+        case DS_FIXED_ID_SHORT:\n+          return dsfidFactory.create(in.readShort(), in);\n+        case DS_FIXED_ID_INT:\n+          return dsfidFactory.create(in.readInt(), in);\n+        case DS_NO_FIXED_ID:\n+        case DATA_SERIALIZABLE:\n+          return readDataSerializable(in);\n+        case NULL:\n+        case NULL_STRING:\n+          return null;\n+        case STRING:\n+          return readStringUTFFromDataInput(in);\n+        case HUGE_STRING:\n+          return readHugeStringFromDataInput(in);\n+        case STRING_BYTES:\n+          return readStringBytesFromDataInput(in, in.readUnsignedShort());\n+        case HUGE_STRING_BYTES:\n+          return readStringBytesFromDataInput(in, in.readInt());\n+        case CLASS:\n+          return readClass(in);\n+        case DATE:\n+          return readDate(in);\n+        case FILE:\n+          return readFile(in);\n+        case INET_ADDRESS:\n+          return readInetAddress(in);\n+        case BOOLEAN:\n+          return readBoolean(in);\n+        case CHARACTER:\n+          return readCharacter(in);\n+        case BYTE:\n+          return readByte(in);\n+        case SHORT:\n+          return readShort(in);\n+        case INTEGER:\n+          return readInteger(in);\n+        case LONG:\n+          return readLong(in);\n+        case FLOAT:\n+          return readFloat(in);\n+        case DOUBLE:\n+          return readDouble(in);\n+        case BYTE_ARRAY:\n+          return readByteArray(in);\n+        case ARRAY_OF_BYTE_ARRAYS:\n+          return readArrayOfByteArrays(in);\n+        case SHORT_ARRAY:\n+          return readShortArray(in);\n+        case STRING_ARRAY:\n+          return readStringArray(in);\n+        case INT_ARRAY:\n+          return readIntArray(in);\n+        case LONG_ARRAY:\n+          return readLongArray(in);\n+        case FLOAT_ARRAY:\n+          return readFloatArray(in);\n+        case DOUBLE_ARRAY:\n+          return readDoubleArray(in);\n+        case BOOLEAN_ARRAY:\n+          return readBooleanArray(in);\n+        case CHAR_ARRAY:\n+          return readCharArray(in);\n+        case OBJECT_ARRAY:\n+          return readObjectArray(in);\n+        case ARRAY_LIST:\n+          return readArrayList(in);\n+        case LINKED_LIST:\n+          return readLinkedList(in);\n+        case HASH_SET:\n+          return readHashSet(in);\n+        case LINKED_HASH_SET:\n+          return readLinkedHashSet(in);\n+        case HASH_MAP:\n+          return readHashMap(in);\n+        case IDENTITY_HASH_MAP:\n+          return readIdentityHashMap(in);\n+        case HASH_TABLE:\n+          return readHashtable(in);\n+        case CONCURRENT_HASH_MAP:\n+          return readConcurrentHashMap(in);\n+        case PROPERTIES:\n+          return readProperties(in);\n+        case TIME_UNIT:\n+          return readTimeUnit(in);\n+        case USER_CLASS:\n+          return readUserObject(in, in.readByte());\n+        case USER_CLASS_2:\n+          return readUserObject(in, in.readShort());\n+        case USER_CLASS_4:\n+          return readUserObject(in, in.readInt());\n+        case VECTOR:\n+          return readVector(in);\n+        case STACK:\n+          return readStack(in);\n+        case TREE_MAP:\n+          return readTreeMap(in);\n+        case TREE_SET:\n+          return readTreeSet(in);\n+        case BOOLEAN_TYPE:\n+          return Boolean.TYPE;\n+        case CHARACTER_TYPE:\n+          return Character.TYPE;\n+        case BYTE_TYPE:\n+          return Byte.TYPE;\n+        case SHORT_TYPE:\n+          return Short.TYPE;\n+        case INTEGER_TYPE:\n+          return Integer.TYPE;\n+        case LONG_TYPE:\n+          return Long.TYPE;\n+        case FLOAT_TYPE:\n+          return Float.TYPE;\n+        case DOUBLE_TYPE:\n+          return Double.TYPE;\n+        case VOID_TYPE:\n+          return Void.TYPE;\n+        case USER_DATA_SERIALIZABLE:\n+          return readUserDataSerializable(in, in.readByte());\n+        case USER_DATA_SERIALIZABLE_2:\n+          return readUserDataSerializable(in, in.readShort());\n+        case USER_DATA_SERIALIZABLE_4:\n+          return readUserDataSerializable(in, in.readInt());\n+        case SERIALIZABLE:\n+          return readSerializable(in);\n+        case PDX:\n+          return readPdxSerializable(in);\n+        case PDX_ENUM:\n+          return readPdxEnum(in);\n+        case GEMFIRE_ENUM:\n+          return readGemFireEnum(in);\n+        case PDX_INLINE_ENUM:\n+          return readPdxInlineEnum(in);\n+        case BIG_INTEGER:\n+          return readBigInteger(in);\n+        case BIG_DECIMAL:\n+          return readBigDecimal(in);\n+        case UUID:\n+          return readUUID(in);\n+        case TIMESTAMP:\n+          return readTimestamp(in);\n+        default:\n+          throw new IOException(\"Unknown header byte: \" + header);\n+      }\n+    } catch (RuntimeException rte) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2779bdd875b000f3683751c32ea279e76b866ceb"}, "originalPosition": 296}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUyOTg3NA==", "bodyText": "fixed.", "url": "https://github.com/apache/geode/pull/5253#discussion_r444529874", "createdAt": "2020-06-23T21:52:16Z", "author": {"login": "gesterzhou"}, "path": "geode-core/src/main/java/org/apache/geode/internal/InternalDataSerializer.java", "diffHunk": "@@ -2506,153 +2506,156 @@ public static Object basicReadObject(final DataInput in)\n       throw new IOException(\"Unknown header byte: \" + header);\n     }\n \n-    switch (headerDSCode) {\n-      case DS_FIXED_ID_BYTE:\n-        return dsfidFactory.create(in.readByte(), in);\n-      case DS_FIXED_ID_SHORT:\n-        return dsfidFactory.create(in.readShort(), in);\n-      case DS_FIXED_ID_INT:\n-        return dsfidFactory.create(in.readInt(), in);\n-      case DS_NO_FIXED_ID:\n-      case DATA_SERIALIZABLE:\n-        return readDataSerializable(in);\n-      case NULL:\n-      case NULL_STRING:\n-        return null;\n-      case STRING:\n-        return readStringUTFFromDataInput(in);\n-      case HUGE_STRING:\n-        return readHugeStringFromDataInput(in);\n-      case STRING_BYTES:\n-        return readStringBytesFromDataInput(in, in.readUnsignedShort());\n-      case HUGE_STRING_BYTES:\n-        return readStringBytesFromDataInput(in, in.readInt());\n-      case CLASS:\n-        return readClass(in);\n-      case DATE:\n-        return readDate(in);\n-      case FILE:\n-        return readFile(in);\n-      case INET_ADDRESS:\n-        return readInetAddress(in);\n-      case BOOLEAN:\n-        return readBoolean(in);\n-      case CHARACTER:\n-        return readCharacter(in);\n-      case BYTE:\n-        return readByte(in);\n-      case SHORT:\n-        return readShort(in);\n-      case INTEGER:\n-        return readInteger(in);\n-      case LONG:\n-        return readLong(in);\n-      case FLOAT:\n-        return readFloat(in);\n-      case DOUBLE:\n-        return readDouble(in);\n-      case BYTE_ARRAY:\n-        return readByteArray(in);\n-      case ARRAY_OF_BYTE_ARRAYS:\n-        return readArrayOfByteArrays(in);\n-      case SHORT_ARRAY:\n-        return readShortArray(in);\n-      case STRING_ARRAY:\n-        return readStringArray(in);\n-      case INT_ARRAY:\n-        return readIntArray(in);\n-      case LONG_ARRAY:\n-        return readLongArray(in);\n-      case FLOAT_ARRAY:\n-        return readFloatArray(in);\n-      case DOUBLE_ARRAY:\n-        return readDoubleArray(in);\n-      case BOOLEAN_ARRAY:\n-        return readBooleanArray(in);\n-      case CHAR_ARRAY:\n-        return readCharArray(in);\n-      case OBJECT_ARRAY:\n-        return readObjectArray(in);\n-      case ARRAY_LIST:\n-        return readArrayList(in);\n-      case LINKED_LIST:\n-        return readLinkedList(in);\n-      case HASH_SET:\n-        return readHashSet(in);\n-      case LINKED_HASH_SET:\n-        return readLinkedHashSet(in);\n-      case HASH_MAP:\n-        return readHashMap(in);\n-      case IDENTITY_HASH_MAP:\n-        return readIdentityHashMap(in);\n-      case HASH_TABLE:\n-        return readHashtable(in);\n-      case CONCURRENT_HASH_MAP:\n-        return readConcurrentHashMap(in);\n-      case PROPERTIES:\n-        return readProperties(in);\n-      case TIME_UNIT:\n-        return readTimeUnit(in);\n-      case USER_CLASS:\n-        return readUserObject(in, in.readByte());\n-      case USER_CLASS_2:\n-        return readUserObject(in, in.readShort());\n-      case USER_CLASS_4:\n-        return readUserObject(in, in.readInt());\n-      case VECTOR:\n-        return readVector(in);\n-      case STACK:\n-        return readStack(in);\n-      case TREE_MAP:\n-        return readTreeMap(in);\n-      case TREE_SET:\n-        return readTreeSet(in);\n-      case BOOLEAN_TYPE:\n-        return Boolean.TYPE;\n-      case CHARACTER_TYPE:\n-        return Character.TYPE;\n-      case BYTE_TYPE:\n-        return Byte.TYPE;\n-      case SHORT_TYPE:\n-        return Short.TYPE;\n-      case INTEGER_TYPE:\n-        return Integer.TYPE;\n-      case LONG_TYPE:\n-        return Long.TYPE;\n-      case FLOAT_TYPE:\n-        return Float.TYPE;\n-      case DOUBLE_TYPE:\n-        return Double.TYPE;\n-      case VOID_TYPE:\n-        return Void.TYPE;\n-      case USER_DATA_SERIALIZABLE:\n-        return readUserDataSerializable(in, in.readByte());\n-      case USER_DATA_SERIALIZABLE_2:\n-        return readUserDataSerializable(in, in.readShort());\n-      case USER_DATA_SERIALIZABLE_4:\n-        return readUserDataSerializable(in, in.readInt());\n-      case SERIALIZABLE:\n-        return readSerializable(in);\n-      case PDX:\n-        return readPdxSerializable(in);\n-      case PDX_ENUM:\n-        return readPdxEnum(in);\n-      case GEMFIRE_ENUM:\n-        return readGemFireEnum(in);\n-      case PDX_INLINE_ENUM:\n-        return readPdxInlineEnum(in);\n-      case BIG_INTEGER:\n-        return readBigInteger(in);\n-      case BIG_DECIMAL:\n-        return readBigDecimal(in);\n-      case UUID:\n-        return readUUID(in);\n-      case TIMESTAMP:\n-        return readTimestamp(in);\n-      default:\n-        throw new IOException(\"Unknown header byte: \" + header);\n+    try {\n+      switch (headerDSCode) {\n+        case DS_FIXED_ID_BYTE:\n+          return dsfidFactory.create(in.readByte(), in);\n+        case DS_FIXED_ID_SHORT:\n+          return dsfidFactory.create(in.readShort(), in);\n+        case DS_FIXED_ID_INT:\n+          return dsfidFactory.create(in.readInt(), in);\n+        case DS_NO_FIXED_ID:\n+        case DATA_SERIALIZABLE:\n+          return readDataSerializable(in);\n+        case NULL:\n+        case NULL_STRING:\n+          return null;\n+        case STRING:\n+          return readStringUTFFromDataInput(in);\n+        case HUGE_STRING:\n+          return readHugeStringFromDataInput(in);\n+        case STRING_BYTES:\n+          return readStringBytesFromDataInput(in, in.readUnsignedShort());\n+        case HUGE_STRING_BYTES:\n+          return readStringBytesFromDataInput(in, in.readInt());\n+        case CLASS:\n+          return readClass(in);\n+        case DATE:\n+          return readDate(in);\n+        case FILE:\n+          return readFile(in);\n+        case INET_ADDRESS:\n+          return readInetAddress(in);\n+        case BOOLEAN:\n+          return readBoolean(in);\n+        case CHARACTER:\n+          return readCharacter(in);\n+        case BYTE:\n+          return readByte(in);\n+        case SHORT:\n+          return readShort(in);\n+        case INTEGER:\n+          return readInteger(in);\n+        case LONG:\n+          return readLong(in);\n+        case FLOAT:\n+          return readFloat(in);\n+        case DOUBLE:\n+          return readDouble(in);\n+        case BYTE_ARRAY:\n+          return readByteArray(in);\n+        case ARRAY_OF_BYTE_ARRAYS:\n+          return readArrayOfByteArrays(in);\n+        case SHORT_ARRAY:\n+          return readShortArray(in);\n+        case STRING_ARRAY:\n+          return readStringArray(in);\n+        case INT_ARRAY:\n+          return readIntArray(in);\n+        case LONG_ARRAY:\n+          return readLongArray(in);\n+        case FLOAT_ARRAY:\n+          return readFloatArray(in);\n+        case DOUBLE_ARRAY:\n+          return readDoubleArray(in);\n+        case BOOLEAN_ARRAY:\n+          return readBooleanArray(in);\n+        case CHAR_ARRAY:\n+          return readCharArray(in);\n+        case OBJECT_ARRAY:\n+          return readObjectArray(in);\n+        case ARRAY_LIST:\n+          return readArrayList(in);\n+        case LINKED_LIST:\n+          return readLinkedList(in);\n+        case HASH_SET:\n+          return readHashSet(in);\n+        case LINKED_HASH_SET:\n+          return readLinkedHashSet(in);\n+        case HASH_MAP:\n+          return readHashMap(in);\n+        case IDENTITY_HASH_MAP:\n+          return readIdentityHashMap(in);\n+        case HASH_TABLE:\n+          return readHashtable(in);\n+        case CONCURRENT_HASH_MAP:\n+          return readConcurrentHashMap(in);\n+        case PROPERTIES:\n+          return readProperties(in);\n+        case TIME_UNIT:\n+          return readTimeUnit(in);\n+        case USER_CLASS:\n+          return readUserObject(in, in.readByte());\n+        case USER_CLASS_2:\n+          return readUserObject(in, in.readShort());\n+        case USER_CLASS_4:\n+          return readUserObject(in, in.readInt());\n+        case VECTOR:\n+          return readVector(in);\n+        case STACK:\n+          return readStack(in);\n+        case TREE_MAP:\n+          return readTreeMap(in);\n+        case TREE_SET:\n+          return readTreeSet(in);\n+        case BOOLEAN_TYPE:\n+          return Boolean.TYPE;\n+        case CHARACTER_TYPE:\n+          return Character.TYPE;\n+        case BYTE_TYPE:\n+          return Byte.TYPE;\n+        case SHORT_TYPE:\n+          return Short.TYPE;\n+        case INTEGER_TYPE:\n+          return Integer.TYPE;\n+        case LONG_TYPE:\n+          return Long.TYPE;\n+        case FLOAT_TYPE:\n+          return Float.TYPE;\n+        case DOUBLE_TYPE:\n+          return Double.TYPE;\n+        case VOID_TYPE:\n+          return Void.TYPE;\n+        case USER_DATA_SERIALIZABLE:\n+          return readUserDataSerializable(in, in.readByte());\n+        case USER_DATA_SERIALIZABLE_2:\n+          return readUserDataSerializable(in, in.readShort());\n+        case USER_DATA_SERIALIZABLE_4:\n+          return readUserDataSerializable(in, in.readInt());\n+        case SERIALIZABLE:\n+          return readSerializable(in);\n+        case PDX:\n+          return readPdxSerializable(in);\n+        case PDX_ENUM:\n+          return readPdxEnum(in);\n+        case GEMFIRE_ENUM:\n+          return readGemFireEnum(in);\n+        case PDX_INLINE_ENUM:\n+          return readPdxInlineEnum(in);\n+        case BIG_INTEGER:\n+          return readBigInteger(in);\n+        case BIG_DECIMAL:\n+          return readBigDecimal(in);\n+        case UUID:\n+          return readUUID(in);\n+        case TIMESTAMP:\n+          return readTimestamp(in);\n+        default:\n+          throw new IOException(\"Unknown header byte: \" + header);\n+      }\n+    } catch (RuntimeException rte) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY3ODE3OQ=="}, "originalCommit": {"oid": "2779bdd875b000f3683751c32ea279e76b866ceb"}, "originalPosition": 296}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MDkyOTc1OnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/cache/client/internal/GetAllOpJUnitTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNTo1Mzo1MlrOGrDH4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNzoxMjoyNVrOGrGdjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5MzEyMw==", "bodyText": "this needs an assertion that the operation was retried", "url": "https://github.com/apache/geode/pull/5253#discussion_r447793123", "createdAt": "2020-06-30T15:53:52Z", "author": {"login": "bschuchardt"}, "path": "geode-core/src/test/java/org/apache/geode/cache/client/internal/GetAllOpJUnitTest.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.cache.client.internal;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.SerializationException;\n+import org.apache.geode.cache.client.ServerOperationException;\n+import org.apache.geode.distributed.internal.ServerLocation;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.execute.BucketMovedException;\n+import org.apache.geode.internal.cache.tier.sockets.VersionedObjectList;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+import org.apache.geode.test.fake.Fakes;\n+\n+public class GetAllOpJUnitTest {\n+  private ExecutablePool pool = mock(PoolImpl.class);\n+  private GemFireCacheImpl cache = Fakes.cache();\n+  private LocalRegion region = mock(LocalRegion.class);\n+  ArrayList<Integer> keys;\n+\n+  protected static final Logger logger = LogService.getLogger();\n+\n+  @Before\n+  public void setup() {\n+    when(region.getCache()).thenReturn(cache);\n+    ClientMetadataService cms = mock(ClientMetadataService.class);\n+    when(cache.getClientMetadataService()).thenReturn(cms);\n+\n+    keys = new ArrayList<>();\n+    for (int i = 1; i <= 10; i++) {\n+      keys.add(i);\n+    }\n+    Map<ServerLocation, Set> serverToFilterMap = new HashMap<>();\n+    when(cms.getServerToFilterMap(keys, region, true)).thenReturn(serverToFilterMap);\n+    ServerLocation serverLocation = new ServerLocation(\"localhost\", 12345);\n+    serverToFilterMap.put(serverLocation, new HashSet(keys));\n+  }\n+\n+  @Test\n+  public void singleHopGetAllShouldRetrySOECausedBySerialzationExp() {\n+    when(region.getFullPath()).thenReturn(\"/testRegion\")\n+        .thenThrow(new ServerOperationException(new SerializationException(\"testRetry\")))\n+        .thenReturn(\"/testRegion\");\n+    VersionedObjectList vol = new VersionedObjectList();\n+    when(pool.execute(any())).thenReturn(vol);\n+    GetAllOp.execute(pool, region, keys, -1, null);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b25d75943ce1d499b284d3db92b48621cd431426"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgxNjE3Ng==", "bodyText": "If not retried, the operation will fail with exception. See my next test case.", "url": "https://github.com/apache/geode/pull/5253#discussion_r447816176", "createdAt": "2020-06-30T16:26:04Z", "author": {"login": "gesterzhou"}, "path": "geode-core/src/test/java/org/apache/geode/cache/client/internal/GetAllOpJUnitTest.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.cache.client.internal;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.SerializationException;\n+import org.apache.geode.cache.client.ServerOperationException;\n+import org.apache.geode.distributed.internal.ServerLocation;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.execute.BucketMovedException;\n+import org.apache.geode.internal.cache.tier.sockets.VersionedObjectList;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+import org.apache.geode.test.fake.Fakes;\n+\n+public class GetAllOpJUnitTest {\n+  private ExecutablePool pool = mock(PoolImpl.class);\n+  private GemFireCacheImpl cache = Fakes.cache();\n+  private LocalRegion region = mock(LocalRegion.class);\n+  ArrayList<Integer> keys;\n+\n+  protected static final Logger logger = LogService.getLogger();\n+\n+  @Before\n+  public void setup() {\n+    when(region.getCache()).thenReturn(cache);\n+    ClientMetadataService cms = mock(ClientMetadataService.class);\n+    when(cache.getClientMetadataService()).thenReturn(cms);\n+\n+    keys = new ArrayList<>();\n+    for (int i = 1; i <= 10; i++) {\n+      keys.add(i);\n+    }\n+    Map<ServerLocation, Set> serverToFilterMap = new HashMap<>();\n+    when(cms.getServerToFilterMap(keys, region, true)).thenReturn(serverToFilterMap);\n+    ServerLocation serverLocation = new ServerLocation(\"localhost\", 12345);\n+    serverToFilterMap.put(serverLocation, new HashSet(keys));\n+  }\n+\n+  @Test\n+  public void singleHopGetAllShouldRetrySOECausedBySerialzationExp() {\n+    when(region.getFullPath()).thenReturn(\"/testRegion\")\n+        .thenThrow(new ServerOperationException(new SerializationException(\"testRetry\")))\n+        .thenReturn(\"/testRegion\");\n+    VersionedObjectList vol = new VersionedObjectList();\n+    when(pool.execute(any())).thenReturn(vol);\n+    GetAllOp.execute(pool, region, keys, -1, null);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5MzEyMw=="}, "originalCommit": {"oid": "b25d75943ce1d499b284d3db92b48621cd431426"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg0NzgyMQ==", "bodyText": "fixed.", "url": "https://github.com/apache/geode/pull/5253#discussion_r447847821", "createdAt": "2020-06-30T17:12:25Z", "author": {"login": "gesterzhou"}, "path": "geode-core/src/test/java/org/apache/geode/cache/client/internal/GetAllOpJUnitTest.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.cache.client.internal;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.SerializationException;\n+import org.apache.geode.cache.client.ServerOperationException;\n+import org.apache.geode.distributed.internal.ServerLocation;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.execute.BucketMovedException;\n+import org.apache.geode.internal.cache.tier.sockets.VersionedObjectList;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+import org.apache.geode.test.fake.Fakes;\n+\n+public class GetAllOpJUnitTest {\n+  private ExecutablePool pool = mock(PoolImpl.class);\n+  private GemFireCacheImpl cache = Fakes.cache();\n+  private LocalRegion region = mock(LocalRegion.class);\n+  ArrayList<Integer> keys;\n+\n+  protected static final Logger logger = LogService.getLogger();\n+\n+  @Before\n+  public void setup() {\n+    when(region.getCache()).thenReturn(cache);\n+    ClientMetadataService cms = mock(ClientMetadataService.class);\n+    when(cache.getClientMetadataService()).thenReturn(cms);\n+\n+    keys = new ArrayList<>();\n+    for (int i = 1; i <= 10; i++) {\n+      keys.add(i);\n+    }\n+    Map<ServerLocation, Set> serverToFilterMap = new HashMap<>();\n+    when(cms.getServerToFilterMap(keys, region, true)).thenReturn(serverToFilterMap);\n+    ServerLocation serverLocation = new ServerLocation(\"localhost\", 12345);\n+    serverToFilterMap.put(serverLocation, new HashSet(keys));\n+  }\n+\n+  @Test\n+  public void singleHopGetAllShouldRetrySOECausedBySerialzationExp() {\n+    when(region.getFullPath()).thenReturn(\"/testRegion\")\n+        .thenThrow(new ServerOperationException(new SerializationException(\"testRetry\")))\n+        .thenReturn(\"/testRegion\");\n+    VersionedObjectList vol = new VersionedObjectList();\n+    when(pool.execute(any())).thenReturn(vol);\n+    GetAllOp.execute(pool, region, keys, -1, null);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5MzEyMw=="}, "originalCommit": {"oid": "b25d75943ce1d499b284d3db92b48621cd431426"}, "originalPosition": 74}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4004, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}