{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE4ODc0MTA5", "number": 5124, "title": "GEODE-7678 (2nd PR) - Support for cache-listener and client-notification for Partitioned Region Clear operation ", "bodyText": "The changes are made to PR clear messaging and locking mechanism to preserve\ncache-listener and client-events ordering during concurrent cache operation\nwhile clear in progress.\nThis also handles any partial clear due to member departure, by throwing PartitionedRegionPartialClearException.\nThank you for submitting a contribution to Apache Geode.\nIn order to streamline the review of the contribution we ask you\nto ensure the following steps have been taken:\nFor all changes:\n\n\n[Y] Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?\n\n\n[Y] Has your PR been rebased against the latest commit within the target branch (typically develop)?\n\n\n[N] Is your initial contribution a single, squashed commit?\n\n\n[Y] Does gradlew build run cleanly?\n\n\n[Y] Have you written or updated unit tests to verify your changes?\n\n\n[NA] If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under ASF 2.0?\n\n\nNote:\nPlease ensure that once the PR is submitted, check Concourse for build issues and\nsubmit an update to your PR as soon as possible. If you need help, please send an\nemail to dev@geode.apache.org.", "createdAt": "2020-05-15T23:19:05Z", "url": "https://github.com/apache/geode/pull/5124", "merged": true, "mergeCommit": {"oid": "e9600213fef5d6adb4fcef4e3ed655553fd0cc21"}, "closed": true, "closedAt": "2020-05-20T23:08:08Z", "author": {"login": "agingade"}, "timelineItems": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABchplrrgH2gAyNDE4ODc0MTA5OmVmZTRjZjhmYTJiMDU4MjYzZDZiNWViMDEwZDg4YjJhZmZhMWFlYzg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcjQPoPgFqTQxNTczOTExNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "efe4cf8fa2b058263d6b5eb010d88b2affa1aec8", "author": {"user": null}, "url": "https://github.com/apache/geode/commit/efe4cf8fa2b058263d6b5eb010d88b2affa1aec8", "committedDate": "2020-05-15T22:12:51Z", "message": "GEODE-7678: Add support for cache listener and client notification for PR clear\n\nThe changes are made to PR clear messaging and locking mechanism to preserve\ncache-listener and client-events ordering during concurrent cache operation\nwhile clear in progress."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b733af0783157203469a61964121c0e6f6c83fb", "author": {"user": null}, "url": "https://github.com/apache/geode/commit/2b733af0783157203469a61964121c0e6f6c83fb", "committedDate": "2020-05-15T22:14:55Z", "message": "run spotlessApply"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3161e2174d097e1703fcf04230f3f8d8261d449", "author": {"user": null}, "url": "https://github.com/apache/geode/commit/f3161e2174d097e1703fcf04230f3f8d8261d449", "committedDate": "2020-05-15T22:15:33Z", "message": "Add new message class into serializer text.\nAdd check for client interests with local filter."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d83b4b68fc85907e8772b287c223fad24d228732", "author": {"user": null}, "url": "https://github.com/apache/geode/commit/d83b4b68fc85907e8772b287c223fad24d228732", "committedDate": "2020-05-15T22:16:07Z", "message": "Handle member departure during clear.\nAdded wait for secondary buckets to become primary."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd2a582acf74c1488a6bacddd43e0207ed1f6194", "author": {"user": null}, "url": "https://github.com/apache/geode/commit/bd2a582acf74c1488a6bacddd43e0207ed1f6194", "committedDate": "2020-05-15T22:29:19Z", "message": "Incorporate review comments.\nAdd PartitionedRegionPartialClearException.java\nAdd check to verify primary buckets are available for all the local secondary buckets before clear."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35f377954254acc4ee97a13c982b1df733f41663", "author": {"user": null}, "url": "https://github.com/apache/geode/commit/35f377954254acc4ee97a13c982b1df733f41663", "committedDate": "2020-05-15T22:30:23Z", "message": "run spA"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b861b9cf498fe92f770358744b935cd7be1e97b5", "author": {"user": null}, "url": "https://github.com/apache/geode/commit/b861b9cf498fe92f770358744b935cd7be1e97b5", "committedDate": "2020-05-15T22:32:58Z", "message": "Add review comments\nAdd validation to check the buckets cleared after clear completed on all nodes.\nThrow CacheWriterException during netSearch timeout failure with cache write."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77b8493cea70d4e076cdd10212acc17b0debd777", "author": {"user": null}, "url": "https://github.com/apache/geode/commit/77b8493cea70d4e076cdd10212acc17b0debd777", "committedDate": "2020-05-15T22:33:28Z", "message": "Remove unused fields"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b40cf029c3c1afbab3a161283a4c09e04ec7225", "author": {"user": null}, "url": "https://github.com/apache/geode/commit/8b40cf029c3c1afbab3a161283a4c09e04ec7225", "committedDate": "2020-05-15T22:33:45Z", "message": "Remove processException() which was just invoking method from super class."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e68cc4f3293dfc37712b8795e1052ae8effa8646", "author": {"user": null}, "url": "https://github.com/apache/geode/commit/e68cc4f3293dfc37712b8795e1052ae8effa8646", "committedDate": "2020-05-15T22:34:13Z", "message": "Changes based on review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8922c0180ca5fd37873bff3e8acc5d8ba38a871a", "author": {"user": null}, "url": "https://github.com/apache/geode/commit/8922c0180ca5fd37873bff3e8acc5d8ba38a871a", "committedDate": "2020-05-15T22:52:31Z", "message": "Resolve merge issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a69c94d76878033cb798a83720ef70326a3523c1", "author": {"user": null}, "url": "https://github.com/apache/geode/commit/a69c94d76878033cb798a83720ef70326a3523c1", "committedDate": "2020-05-15T23:13:57Z", "message": "Add review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79be7df81e200c9eadef151b361d0d1468a16bb4", "author": {"user": null}, "url": "https://github.com/apache/geode/commit/79be7df81e200c9eadef151b361d0d1468a16bb4", "committedDate": "2020-05-16T04:14:36Z", "message": "Split test to persistent and non-persistent"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee106f8d2e3c7badd8d1d6e3b58784f4435a4db6", "author": {"user": null}, "url": "https://github.com/apache/geode/commit/ee106f8d2e3c7badd8d1d6e3b58784f4435a4db6", "committedDate": "2020-05-16T04:18:55Z", "message": "run spA"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "988f1f61a70bfda29f565e1421df705473554e78", "author": {"user": null}, "url": "https://github.com/apache/geode/commit/988f1f61a70bfda29f565e1421df705473554e78", "committedDate": "2020-05-18T19:13:01Z", "message": "Changes to restart the PR pipeline"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzOTI1OTUw", "url": "https://github.com/apache/geode/pull/5124#pullrequestreview-413925950", "createdAt": "2020-05-18T20:44:13Z", "commit": {"oid": "ee106f8d2e3c7badd8d1d6e3b58784f4435a4db6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6", "author": {"user": null}, "url": "https://github.com/apache/geode/commit/845719cc30d3d6ebabbe8145ffd97860b4a1dbb6", "committedDate": "2020-05-19T01:08:29Z", "message": "Change the expected destroy events."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0NjYxNjM3", "url": "https://github.com/apache/geode/pull/5124#pullrequestreview-414661637", "createdAt": "2020-05-19T17:19:13Z", "commit": {"oid": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNzoxOToxM1rOGXqoMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxODo0NTo0NVrOGXt7CA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ2ODg0OA==", "bodyText": "Should this line be uncommented or removed?", "url": "https://github.com/apache/geode/pull/5124#discussion_r427468848", "createdAt": "2020-05-19T17:19:13Z", "author": {"login": "jchen21"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/PRCacheListenerDistributedTest.java", "diffHunk": "@@ -38,28 +45,60 @@\n @SuppressWarnings(\"serial\")\n public class PRCacheListenerDistributedTest extends ReplicateCacheListenerDistributedTest {\n \n-  @Parameters(name = \"{index}: redundancy={0}\")\n-  public static Iterable<Integer> data() {\n-    return Arrays.asList(0, 3);\n+  @Parameters\n+  public static Collection<Object[]> data() {\n+    return Arrays.asList(new Object[][] {\n+        {1, Boolean.FALSE},\n+        // {3, Boolean.TRUE},", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3NjE1NQ==", "bodyText": "I am not sure why we need a new reference here.", "url": "https://github.com/apache/geode/pull/5124#discussion_r427476155", "createdAt": "2020-05-19T17:30:17Z", "author": {"login": "jchen21"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithExpirationDUnitTest.java", "diffHunk": "@@ -408,22 +394,21 @@ public void clearShouldFailWhenCoordinatorMemberIsBouncedAndExpirationTasksShoul\n   @TestCaseName(\"[{index}] {method}(Coordinator:{0}, RegionType:{1})\")\n   public void clearShouldSucceedAndRemoveRegisteredExpirationTasksWhenNonCoordinatorMemberIsBounced(\n       TestVM coordinatorVM, RegionShortcut regionShortcut) {\n-    final int entries = 1500;\n+    final int entries = 500;\n+\n+    RegionShortcut rs = regionShortcut;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3Nzk4MA==", "bodyText": "I think you mean It's instead of Its.", "url": "https://github.com/apache/geode/pull/5124#discussion_r427477980", "createdAt": "2020-05-19T17:33:03Z", "author": {"login": "jchen21"}, "path": "geode-core/src/main/java/org/apache/geode/cache/Region.java", "diffHunk": "@@ -1302,7 +1302,10 @@ Object selectValue(String queryPredicate) throws FunctionDomainException, TypeMi\n    * @see java.util.Map#clear()\n    * @see CacheListener#afterRegionClear\n    * @see CacheWriter#beforeRegionClear\n-   * @throws UnsupportedOperationException If the region is a partitioned region\n+   * @throws PartitionedRegionPartialClearException when data is partially cleared on partitioned\n+   *         region. Its caller responsibility to handle the partial data clear either by retrying", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ4MDQ5MQ==", "bodyText": "My understanding is if it is locked already, release the write locks for clear. I think the ! should be removed.", "url": "https://github.com/apache/geode/pull/5124#discussion_r427480491", "createdAt": "2020-05-19T17:36:54Z", "author": {"login": "jchen21"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/BucketRegion.java", "diffHunk": "@@ -575,16 +575,23 @@ public void cmnClearRegion(RegionEventImpl regionEvent, boolean cacheWrite, bool\n     // get rvvLock\n     Set<InternalDistributedMember> participants =\n         getCacheDistributionAdvisor().adviseInvalidateRegion();\n+    boolean isLockedAlready = this.partitionedRegion.getPartitionedRegionClear()\n+        .isLockedForListenerAndClientNotification();\n+\n     try {\n-      obtainWriteLocksForClear(regionEvent, participants);\n+      if (!isLockedAlready) {\n+        obtainWriteLocksForClear(regionEvent, participants);\n+      }\n       // no need to dominate my own rvv.\n       // Clear is on going here, there won't be GII for this member\n       clearRegionLocally(regionEvent, cacheWrite, null);\n       distributeClearOperation(regionEvent, rvv, participants);\n \n       // TODO: call reindexUserDataRegion if there're lucene indexes\n     } finally {\n-      releaseWriteLocksForClear(regionEvent, participants);\n+      if (!isLockedAlready) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ4NjU4OQ==", "bodyText": "LocalRegionDataView. checkSupportsRegionClear() does nothing. The other data views, including transactions related data views throw exception. Is it expected?", "url": "https://github.com/apache/geode/pull/5124#discussion_r427486589", "createdAt": "2020-05-19T17:46:31Z", "author": {"login": "jchen21"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/BucketRegion.java", "diffHunk": "@@ -2493,4 +2500,11 @@ void updateSenderIdMonitor() {\n   void checkSameSenderIdsAvailableOnAllNodes() {\n     // nothing needed on a bucket region\n   }\n+\n+  @Override\n+  protected void basicClear(RegionEventImpl regionEvent) {\n+    getDataView().checkSupportsRegionClear();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ5NDY1Mg==", "bodyText": "If this section of code is not used, it's better to remove it.", "url": "https://github.com/apache/geode/pull/5124#discussion_r427494652", "createdAt": "2020-05-19T17:58:54Z", "author": {"login": "jchen21"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegion.java", "diffHunk": "@@ -2148,69 +2150,71 @@ public void writeToDisk() {\n     throw new UnsupportedOperationException();\n   }\n \n-  @Override\n-  void basicClear(RegionEventImpl regionEvent, boolean cacheWrite) {\n-    final boolean isDebugEnabled = logger.isDebugEnabled();\n-    synchronized (clearLock) {\n-      final DistributedLockService lockService = getPartitionedRegionLockService();\n-      try {\n-        lockService.lock(\"_clearOperation\" + this.getFullPath().replace('/', '_'), -1, -1);\n-      } catch (IllegalStateException e) {\n-        lockCheckReadiness();\n-        throw e;\n-      }\n-      try {\n-        if (cache.isCacheAtShutdownAll()) {\n-          throw cache.getCacheClosedException(\"Cache is shutting down\");\n-        }\n-\n-        // do cacheWrite\n-        cacheWriteBeforeRegionClear(regionEvent);\n-\n-        // create ClearPRMessage per bucket\n-        List<ClearPRMessage> clearMsgList = createClearPRMessages(regionEvent.getEventId());\n-        for (ClearPRMessage clearPRMessage : clearMsgList) {\n-          int bucketId = clearPRMessage.getBucketId();\n-          checkReadiness();\n-          long sendMessagesStartTime = 0;\n-          if (isDebugEnabled) {\n-            sendMessagesStartTime = System.currentTimeMillis();\n-          }\n-          try {\n-            sendClearMsgByBucket(bucketId, clearPRMessage);\n-          } catch (PartitionOfflineException poe) {\n-            // TODO add a PartialResultException\n-            logger.info(\"PR.sendClearMsgByBucket encountered PartitionOfflineException at bucket \"\n-                + bucketId, poe);\n-          } catch (Exception e) {\n-            logger.info(\"PR.sendClearMsgByBucket encountered exception at bucket \" + bucketId, e);\n-          }\n-\n-          if (isDebugEnabled) {\n-            long now = System.currentTimeMillis();\n-            logger.debug(\"PR.sendClearMsgByBucket for bucket {} took {} ms\", bucketId,\n-                (now - sendMessagesStartTime));\n-          }\n-          // TODO add psStats\n-        }\n-      } finally {\n-        try {\n-          lockService.unlock(\"_clearOperation\" + this.getFullPath().replace('/', '_'));\n-        } catch (IllegalStateException e) {\n-          lockCheckReadiness();\n-        }\n-      }\n-\n-      // notify bridge clients at PR level\n-      regionEvent.setEventType(EnumListenerEvent.AFTER_REGION_CLEAR);\n-      boolean hasListener = hasListener();\n-      if (hasListener) {\n-        dispatchListenerEvent(EnumListenerEvent.AFTER_REGION_CLEAR, regionEvent);\n-      }\n-      notifyBridgeClients(regionEvent);\n-      logger.info(\"Partitioned region {} finsihed clear operation.\", this.getFullPath());\n-    }\n-  }\n+  /* @Override */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ5NzY5MA==", "bodyText": "This seems to be duplicate. The super class already has an ArrayList of recipients.", "url": "https://github.com/apache/geode/pull/5124#discussion_r427497690", "createdAt": "2020-05-19T18:03:42Z", "author": {"login": "jchen21"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegionClearMessage.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.cache;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.cache.CacheException;\n+import org.apache.geode.cache.Operation;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.DistributionMessage;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplyMessage;\n+import org.apache.geode.distributed.internal.ReplyProcessor21;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.Assert;\n+import org.apache.geode.internal.NanoTimer;\n+import org.apache.geode.internal.cache.partitioned.PartitionMessage;\n+import org.apache.geode.internal.logging.log4j.LogMarker;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class PartitionedRegionClearMessage extends PartitionMessage {\n+\n+  public enum OperationType {\n+    OP_LOCK_FOR_PR_CLEAR, OP_UNLOCK_FOR_PR_CLEAR, OP_PR_CLEAR,\n+  }\n+\n+  private Object cbArg;\n+\n+  private OperationType op;\n+\n+  private EventID eventID;\n+\n+  private PartitionedRegion partitionedRegion;\n+\n+  private Set<InternalDistributedMember> recipients;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUwNDY2OA==", "bodyText": "The implementation can use super.toString() and append fields specific to this class.", "url": "https://github.com/apache/geode/pull/5124#discussion_r427504668", "createdAt": "2020-05-19T18:15:09Z", "author": {"login": "jchen21"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegionClearMessage.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.cache;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.cache.CacheException;\n+import org.apache.geode.cache.Operation;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.DistributionMessage;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplyMessage;\n+import org.apache.geode.distributed.internal.ReplyProcessor21;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.Assert;\n+import org.apache.geode.internal.NanoTimer;\n+import org.apache.geode.internal.cache.partitioned.PartitionMessage;\n+import org.apache.geode.internal.logging.log4j.LogMarker;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class PartitionedRegionClearMessage extends PartitionMessage {\n+\n+  public enum OperationType {\n+    OP_LOCK_FOR_PR_CLEAR, OP_UNLOCK_FOR_PR_CLEAR, OP_PR_CLEAR,\n+  }\n+\n+  private Object cbArg;\n+\n+  private OperationType op;\n+\n+  private EventID eventID;\n+\n+  private PartitionedRegion partitionedRegion;\n+\n+  private Set<InternalDistributedMember> recipients;\n+\n+  private ArrayList bucketsCleared;\n+\n+  @Override\n+  public EventID getEventID() {\n+    return eventID;\n+  }\n+\n+  public PartitionedRegionClearMessage() {}\n+\n+  PartitionedRegionClearMessage(Set recipients, PartitionedRegion region,\n+      ReplyProcessor21 processor, PartitionedRegionClearMessage.OperationType operationType,\n+      final RegionEventImpl event) {\n+    super(recipients, region.getPRId(), processor);\n+    this.recipients = recipients;\n+    partitionedRegion = region;\n+    op = operationType;\n+    cbArg = event.getRawCallbackArgument();\n+    eventID = event.getEventId();\n+  }\n+\n+  public OperationType getOp() {\n+    return op;\n+  }\n+\n+  public void send() {\n+    Assert.assertTrue(recipients != null, \"ClearMessage NULL recipients set\");\n+    setTransactionDistributed(partitionedRegion.getCache().getTxManager().isDistributed());\n+    partitionedRegion.getDistributionManager().putOutgoing(this);\n+  }\n+\n+  @Override\n+  protected Throwable processCheckForPR(PartitionedRegion pr,\n+      DistributionManager distributionManager) {\n+    if (pr != null && !pr.getDistributionAdvisor().isInitialized()) {\n+      Throwable thr = new ForceReattemptException(\n+          String.format(\"%s : could not find partitioned region with Id %s\",\n+              distributionManager.getDistributionManagerId(),\n+              pr.getRegionIdentifier()));\n+      return thr;\n+    }\n+    return null;\n+  }\n+\n+  @Override\n+  protected boolean operateOnPartitionedRegion(ClusterDistributionManager dm,\n+      PartitionedRegion partitionedRegion,\n+      long startTime) throws CacheException {\n+\n+    if (partitionedRegion == null) {\n+      return true;\n+    }\n+\n+    if (partitionedRegion.isDestroyed()) {\n+      return true;\n+    }\n+\n+    if (op == OperationType.OP_LOCK_FOR_PR_CLEAR) {\n+      partitionedRegion.getPartitionedRegionClear().obtainClearLockLocal(getSender());\n+    } else if (op == OperationType.OP_UNLOCK_FOR_PR_CLEAR) {\n+      partitionedRegion.getPartitionedRegionClear().releaseClearLockLocal();\n+    } else {\n+      RegionEventImpl event =\n+          new RegionEventImpl(partitionedRegion, Operation.REGION_CLEAR, this.cbArg, true,\n+              partitionedRegion.getMyId(),\n+              getEventID());\n+      bucketsCleared = partitionedRegion.getPartitionedRegionClear().clearRegionLocal(event);\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  protected void appendFields(StringBuilder buff) {\n+    super.appendFields(buff);\n+    buff.append(\" cbArg=\").append(this.cbArg).append(\" op=\").append(this.op);\n+  }\n+\n+  @Override\n+  public int getDSFID() {\n+    return CLEAR_PARTITIONED_REGION_MESSAGE;\n+  }\n+\n+  @Override\n+  public void fromData(DataInput in,\n+      DeserializationContext context) throws IOException, ClassNotFoundException {\n+    super.fromData(in, context);\n+    this.cbArg = DataSerializer.readObject(in);\n+    op = PartitionedRegionClearMessage.OperationType.values()[in.readByte()];\n+    eventID = DataSerializer.readObject(in);\n+  }\n+\n+  @Override\n+  public void toData(DataOutput out,\n+      SerializationContext context) throws IOException {\n+    super.toData(out, context);\n+    DataSerializer.writeObject(this.cbArg, out);\n+    out.writeByte(op.ordinal());\n+    DataSerializer.writeObject(eventID, out);\n+  }\n+\n+  /**\n+   * The response on which to wait for all the replies. This response ignores any exceptions\n+   * received from the \"far side\"\n+   */\n+  public static class PartitionedRegionClearResponse extends ReplyProcessor21 {\n+    CopyOnWriteArrayList bucketsCleared = new CopyOnWriteArrayList();\n+\n+    public PartitionedRegionClearResponse(InternalDistributedSystem system, Set initMembers) {\n+      super(system, initMembers);\n+    }\n+\n+    @Override\n+    public void process(DistributionMessage msg) {\n+      if (msg instanceof PartitionedRegionClearReplyMessage) {\n+        List buckets = ((PartitionedRegionClearReplyMessage) msg).bucketsCleared;\n+        if (buckets != null) {\n+          bucketsCleared.addAll(buckets);\n+        }\n+      }\n+      super.process(msg, true);\n+    }\n+  }\n+\n+  @Override\n+  protected void sendReply(InternalDistributedMember member, int processorId,\n+      DistributionManager distributionManager, ReplyException ex,\n+      PartitionedRegion partitionedRegion, long startTime) {\n+    if (partitionedRegion != null) {\n+      if (startTime > 0) {\n+        partitionedRegion.getPrStats().endPartitionMessagesProcessing(startTime);\n+      }\n+    }\n+    PartitionedRegionClearMessage.PartitionedRegionClearReplyMessage\n+        .send(member, processorId, getReplySender(distributionManager), op, bucketsCleared,\n+            ex);\n+  }\n+\n+  public static class PartitionedRegionClearReplyMessage extends ReplyMessage {\n+\n+    private ArrayList bucketsCleared;\n+\n+    private OperationType op;\n+\n+    @Override\n+    public boolean getInlineProcess() {\n+      return true;\n+    }\n+\n+    /**\n+     * Empty constructor to conform to DataSerializable interface\n+     */\n+    public PartitionedRegionClearReplyMessage() {}\n+\n+    private PartitionedRegionClearReplyMessage(int processorId, OperationType op,\n+        ArrayList bucketsCleared, ReplyException ex) {\n+      super();\n+      this.bucketsCleared = bucketsCleared;\n+      this.op = op;\n+      setProcessorId(processorId);\n+      setException(ex);\n+    }\n+\n+    /** Send an ack */\n+    public static void send(InternalDistributedMember recipient, int processorId, ReplySender dm,\n+        OperationType op, ArrayList bucketsCleared, ReplyException ex) {\n+\n+      Assert.assertTrue(recipient != null, \"partitionedRegionClearReplyMessage NULL reply message\");\n+\n+      PartitionedRegionClearMessage.PartitionedRegionClearReplyMessage m =\n+          new PartitionedRegionClearMessage.PartitionedRegionClearReplyMessage(processorId, op,\n+              bucketsCleared, ex);\n+\n+      m.setRecipient(recipient);\n+      dm.putOutgoing(m);\n+    }\n+\n+    /**\n+     * Processes this message. This method is invoked by the receiver of the message.\n+     *\n+     * @param dm the distribution manager that is processing the message.\n+     */\n+    @Override\n+    public void process(final DistributionManager dm, final ReplyProcessor21 rp) {\n+      final long startTime = getTimestamp();\n+\n+      if (rp == null) {\n+        if (LogService.getLogger().isTraceEnabled(LogMarker.DM_VERBOSE)) {\n+          LogService.getLogger().trace(LogMarker.DM_VERBOSE, \"{}: processor not found\", this);\n+        }\n+        return;\n+      }\n+\n+      rp.process(this);\n+\n+      dm.getStats().incReplyMessageTime(NanoTimer.getTime() - startTime);\n+    }\n+\n+    @Override\n+    public int getDSFID() {\n+      return CLEAR_PARTITIONED_REGION_REPLY_MESSAGE;\n+    }\n+\n+    @Override\n+    public void fromData(DataInput in,\n+        DeserializationContext context) throws IOException, ClassNotFoundException {\n+      super.fromData(in, context);\n+      op = PartitionedRegionClearMessage.OperationType.values()[in.readByte()];\n+      bucketsCleared = DataSerializer.readArrayList(in);\n+    }\n+\n+    @Override\n+    public void toData(DataOutput out,\n+        SerializationContext context) throws IOException {\n+      super.toData(out, context);\n+      out.writeByte(op.ordinal());\n+      DataSerializer.writeArrayList(bucketsCleared, out);\n+    }\n+\n+    @Override\n+    public String toString() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6"}, "originalPosition": 280}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUwODc1Ng==", "bodyText": "Is the deleted test case covered else where? Or it no longer valid?", "url": "https://github.com/apache/geode/pull/5124#discussion_r427508756", "createdAt": "2020-05-19T18:21:48Z", "author": {"login": "jchen21"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/PartitionedRegionTest.java", "diffHunk": "@@ -221,22 +220,6 @@ public void clearShouldNotThrowUnsupportedOperationException() {\n     spyPartitionedRegion.clear();\n   }\n \n-  @Test(expected = CacheClosedException.class)\n-  public void clearShouldThrowCacheClosedExceptionIfShutdownAll() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUwODg1MA==", "bodyText": "Is the deleted test case covered else where? Or it no longer valid?", "url": "https://github.com/apache/geode/pull/5124#discussion_r427508850", "createdAt": "2020-05-19T18:21:57Z", "author": {"login": "jchen21"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/PartitionedRegionTest.java", "diffHunk": "@@ -249,28 +232,6 @@ public void createClearPRMessagesShouldCreateMessagePerBucket() {\n     assertThat(msgs.size()).isEqualTo(3);\n   }\n \n-  @Test\n-  public void sendEachMessagePerBucket() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUyMjczOA==", "bodyText": "This method never returns false. It always returns true. So there is no need to do the if check.", "url": "https://github.com/apache/geode/pull/5124#discussion_r427522738", "createdAt": "2020-05-19T18:45:38Z", "author": {"login": "jchen21"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegionClearMessage.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.cache;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.cache.CacheException;\n+import org.apache.geode.cache.Operation;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.DistributionMessage;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplyMessage;\n+import org.apache.geode.distributed.internal.ReplyProcessor21;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.Assert;\n+import org.apache.geode.internal.NanoTimer;\n+import org.apache.geode.internal.cache.partitioned.PartitionMessage;\n+import org.apache.geode.internal.logging.log4j.LogMarker;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class PartitionedRegionClearMessage extends PartitionMessage {\n+\n+  public enum OperationType {\n+    OP_LOCK_FOR_PR_CLEAR, OP_UNLOCK_FOR_PR_CLEAR, OP_PR_CLEAR,\n+  }\n+\n+  private Object cbArg;\n+\n+  private OperationType op;\n+\n+  private EventID eventID;\n+\n+  private PartitionedRegion partitionedRegion;\n+\n+  private Set<InternalDistributedMember> recipients;\n+\n+  private ArrayList bucketsCleared;\n+\n+  @Override\n+  public EventID getEventID() {\n+    return eventID;\n+  }\n+\n+  public PartitionedRegionClearMessage() {}\n+\n+  PartitionedRegionClearMessage(Set recipients, PartitionedRegion region,\n+      ReplyProcessor21 processor, PartitionedRegionClearMessage.OperationType operationType,\n+      final RegionEventImpl event) {\n+    super(recipients, region.getPRId(), processor);\n+    this.recipients = recipients;\n+    partitionedRegion = region;\n+    op = operationType;\n+    cbArg = event.getRawCallbackArgument();\n+    eventID = event.getEventId();\n+  }\n+\n+  public OperationType getOp() {\n+    return op;\n+  }\n+\n+  public void send() {\n+    Assert.assertTrue(recipients != null, \"ClearMessage NULL recipients set\");\n+    setTransactionDistributed(partitionedRegion.getCache().getTxManager().isDistributed());\n+    partitionedRegion.getDistributionManager().putOutgoing(this);\n+  }\n+\n+  @Override\n+  protected Throwable processCheckForPR(PartitionedRegion pr,\n+      DistributionManager distributionManager) {\n+    if (pr != null && !pr.getDistributionAdvisor().isInitialized()) {\n+      Throwable thr = new ForceReattemptException(\n+          String.format(\"%s : could not find partitioned region with Id %s\",\n+              distributionManager.getDistributionManagerId(),\n+              pr.getRegionIdentifier()));\n+      return thr;\n+    }\n+    return null;\n+  }\n+\n+  @Override\n+  protected boolean operateOnPartitionedRegion(ClusterDistributionManager dm,\n+      PartitionedRegion partitionedRegion,\n+      long startTime) throws CacheException {\n+\n+    if (partitionedRegion == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUyMjgyNA==", "bodyText": "This method never returns false. It always returns true. So there is no need to do the if check.", "url": "https://github.com/apache/geode/pull/5124#discussion_r427522824", "createdAt": "2020-05-19T18:45:45Z", "author": {"login": "jchen21"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegionClearMessage.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.cache;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.cache.CacheException;\n+import org.apache.geode.cache.Operation;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.DistributionMessage;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplyMessage;\n+import org.apache.geode.distributed.internal.ReplyProcessor21;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.Assert;\n+import org.apache.geode.internal.NanoTimer;\n+import org.apache.geode.internal.cache.partitioned.PartitionMessage;\n+import org.apache.geode.internal.logging.log4j.LogMarker;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class PartitionedRegionClearMessage extends PartitionMessage {\n+\n+  public enum OperationType {\n+    OP_LOCK_FOR_PR_CLEAR, OP_UNLOCK_FOR_PR_CLEAR, OP_PR_CLEAR,\n+  }\n+\n+  private Object cbArg;\n+\n+  private OperationType op;\n+\n+  private EventID eventID;\n+\n+  private PartitionedRegion partitionedRegion;\n+\n+  private Set<InternalDistributedMember> recipients;\n+\n+  private ArrayList bucketsCleared;\n+\n+  @Override\n+  public EventID getEventID() {\n+    return eventID;\n+  }\n+\n+  public PartitionedRegionClearMessage() {}\n+\n+  PartitionedRegionClearMessage(Set recipients, PartitionedRegion region,\n+      ReplyProcessor21 processor, PartitionedRegionClearMessage.OperationType operationType,\n+      final RegionEventImpl event) {\n+    super(recipients, region.getPRId(), processor);\n+    this.recipients = recipients;\n+    partitionedRegion = region;\n+    op = operationType;\n+    cbArg = event.getRawCallbackArgument();\n+    eventID = event.getEventId();\n+  }\n+\n+  public OperationType getOp() {\n+    return op;\n+  }\n+\n+  public void send() {\n+    Assert.assertTrue(recipients != null, \"ClearMessage NULL recipients set\");\n+    setTransactionDistributed(partitionedRegion.getCache().getTxManager().isDistributed());\n+    partitionedRegion.getDistributionManager().putOutgoing(this);\n+  }\n+\n+  @Override\n+  protected Throwable processCheckForPR(PartitionedRegion pr,\n+      DistributionManager distributionManager) {\n+    if (pr != null && !pr.getDistributionAdvisor().isInitialized()) {\n+      Throwable thr = new ForceReattemptException(\n+          String.format(\"%s : could not find partitioned region with Id %s\",\n+              distributionManager.getDistributionManagerId(),\n+              pr.getRegionIdentifier()));\n+      return thr;\n+    }\n+    return null;\n+  }\n+\n+  @Override\n+  protected boolean operateOnPartitionedRegion(ClusterDistributionManager dm,\n+      PartitionedRegion partitionedRegion,\n+      long startTime) throws CacheException {\n+\n+    if (partitionedRegion == null) {\n+      return true;\n+    }\n+\n+    if (partitionedRegion.isDestroyed()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "845719cc30d3d6ebabbe8145ffd97860b4a1dbb6"}, "originalPosition": 114}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2cd7c2ee1ef32759cf9d9f29905ba6fd74fbdd5f", "author": {"user": null}, "url": "https://github.com/apache/geode/commit/2cd7c2ee1ef32759cf9d9f29905ba6fd74fbdd5f", "committedDate": "2020-05-19T21:22:05Z", "message": "Uncomment the test parameter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6316dbb74978e078b062da25c82ab5345ee4178a", "author": {"user": null}, "url": "https://github.com/apache/geode/commit/6316dbb74978e078b062da25c82ab5345ee4178a", "committedDate": "2020-05-19T21:56:07Z", "message": "Addressing review comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0OTIxNDAz", "url": "https://github.com/apache/geode/pull/5124#pullrequestreview-414921403", "createdAt": "2020-05-20T00:53:46Z", "commit": {"oid": "6316dbb74978e078b062da25c82ab5345ee4178a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMDo1Mzo0NlrOGX3oNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMDo1Mzo0NlrOGX3oNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY4MTg0Nw==", "bodyText": "The sender field is missing.", "url": "https://github.com/apache/geode/pull/5124#discussion_r427681847", "createdAt": "2020-05-20T00:53:46Z", "author": {"login": "jchen21"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegionClearMessage.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.cache;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.cache.CacheException;\n+import org.apache.geode.cache.Operation;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.DistributionMessage;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplyMessage;\n+import org.apache.geode.distributed.internal.ReplyProcessor21;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.Assert;\n+import org.apache.geode.internal.NanoTimer;\n+import org.apache.geode.internal.cache.partitioned.PartitionMessage;\n+import org.apache.geode.internal.logging.log4j.LogMarker;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class PartitionedRegionClearMessage extends PartitionMessage {\n+\n+  public enum OperationType {\n+    OP_LOCK_FOR_PR_CLEAR, OP_UNLOCK_FOR_PR_CLEAR, OP_PR_CLEAR,\n+  }\n+\n+  private Object cbArg;\n+\n+  private OperationType op;\n+\n+  private EventID eventID;\n+\n+  private PartitionedRegion partitionedRegion;\n+\n+  private ArrayList bucketsCleared;\n+\n+  @Override\n+  public EventID getEventID() {\n+    return eventID;\n+  }\n+\n+  public PartitionedRegionClearMessage() {}\n+\n+  PartitionedRegionClearMessage(Set recipients, PartitionedRegion region,\n+      ReplyProcessor21 processor, PartitionedRegionClearMessage.OperationType operationType,\n+      final RegionEventImpl event) {\n+    super(recipients, region.getPRId(), processor);\n+    partitionedRegion = region;\n+    op = operationType;\n+    cbArg = event.getRawCallbackArgument();\n+    eventID = event.getEventId();\n+  }\n+\n+  public OperationType getOp() {\n+    return op;\n+  }\n+\n+  public void send() {\n+    Assert.assertTrue(getRecipients() != null, \"ClearMessage NULL recipients set\");\n+    setTransactionDistributed(partitionedRegion.getCache().getTxManager().isDistributed());\n+    partitionedRegion.getDistributionManager().putOutgoing(this);\n+  }\n+\n+  @Override\n+  protected Throwable processCheckForPR(PartitionedRegion pr,\n+      DistributionManager distributionManager) {\n+    if (pr != null && !pr.getDistributionAdvisor().isInitialized()) {\n+      Throwable thr = new ForceReattemptException(\n+          String.format(\"%s : could not find partitioned region with Id %s\",\n+              distributionManager.getDistributionManagerId(),\n+              pr.getRegionIdentifier()));\n+      return thr;\n+    }\n+    return null;\n+  }\n+\n+  @Override\n+  protected boolean operateOnPartitionedRegion(ClusterDistributionManager dm,\n+      PartitionedRegion partitionedRegion,\n+      long startTime) throws CacheException {\n+\n+    if (partitionedRegion == null) {\n+      return true;\n+    }\n+\n+    if (partitionedRegion.isDestroyed()) {\n+      return true;\n+    }\n+\n+    if (op == OperationType.OP_LOCK_FOR_PR_CLEAR) {\n+      partitionedRegion.getPartitionedRegionClear().obtainClearLockLocal(getSender());\n+    } else if (op == OperationType.OP_UNLOCK_FOR_PR_CLEAR) {\n+      partitionedRegion.getPartitionedRegionClear().releaseClearLockLocal();\n+    } else {\n+      RegionEventImpl event =\n+          new RegionEventImpl(partitionedRegion, Operation.REGION_CLEAR, this.cbArg, true,\n+              partitionedRegion.getMyId(),\n+              getEventID());\n+      bucketsCleared = partitionedRegion.getPartitionedRegionClear().clearRegionLocal(event);\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  protected void appendFields(StringBuilder buff) {\n+    super.appendFields(buff);\n+    buff.append(\" cbArg=\").append(this.cbArg).append(\" op=\").append(this.op);\n+  }\n+\n+  @Override\n+  public int getDSFID() {\n+    return CLEAR_PARTITIONED_REGION_MESSAGE;\n+  }\n+\n+  @Override\n+  public void fromData(DataInput in,\n+      DeserializationContext context) throws IOException, ClassNotFoundException {\n+    super.fromData(in, context);\n+    this.cbArg = DataSerializer.readObject(in);\n+    op = PartitionedRegionClearMessage.OperationType.values()[in.readByte()];\n+    eventID = DataSerializer.readObject(in);\n+  }\n+\n+  @Override\n+  public void toData(DataOutput out,\n+      SerializationContext context) throws IOException {\n+    super.toData(out, context);\n+    DataSerializer.writeObject(this.cbArg, out);\n+    out.writeByte(op.ordinal());\n+    DataSerializer.writeObject(eventID, out);\n+  }\n+\n+  /**\n+   * The response on which to wait for all the replies. This response ignores any exceptions\n+   * received from the \"far side\"\n+   */\n+  public static class PartitionedRegionClearResponse extends ReplyProcessor21 {\n+    CopyOnWriteArrayList bucketsCleared = new CopyOnWriteArrayList();\n+\n+    public PartitionedRegionClearResponse(InternalDistributedSystem system, Set initMembers) {\n+      super(system, initMembers);\n+    }\n+\n+    @Override\n+    public void process(DistributionMessage msg) {\n+      if (msg instanceof PartitionedRegionClearReplyMessage) {\n+        List buckets = ((PartitionedRegionClearReplyMessage) msg).bucketsCleared;\n+        if (buckets != null) {\n+          bucketsCleared.addAll(buckets);\n+        }\n+      }\n+      super.process(msg, true);\n+    }\n+  }\n+\n+  @Override\n+  protected void sendReply(InternalDistributedMember member, int processorId,\n+      DistributionManager distributionManager, ReplyException ex,\n+      PartitionedRegion partitionedRegion, long startTime) {\n+    if (partitionedRegion != null) {\n+      if (startTime > 0) {\n+        partitionedRegion.getPrStats().endPartitionMessagesProcessing(startTime);\n+      }\n+    }\n+    PartitionedRegionClearMessage.PartitionedRegionClearReplyMessage\n+        .send(member, processorId, getReplySender(distributionManager), op, bucketsCleared,\n+            ex);\n+  }\n+\n+  public static class PartitionedRegionClearReplyMessage extends ReplyMessage {\n+\n+    private ArrayList bucketsCleared;\n+\n+    private OperationType op;\n+\n+    @Override\n+    public boolean getInlineProcess() {\n+      return true;\n+    }\n+\n+    /**\n+     * Empty constructor to conform to DataSerializable interface\n+     */\n+    public PartitionedRegionClearReplyMessage() {}\n+\n+    private PartitionedRegionClearReplyMessage(int processorId, OperationType op,\n+        ArrayList bucketsCleared, ReplyException ex) {\n+      super();\n+      this.bucketsCleared = bucketsCleared;\n+      this.op = op;\n+      setProcessorId(processorId);\n+      setException(ex);\n+    }\n+\n+    /** Send an ack */\n+    public static void send(InternalDistributedMember recipient, int processorId, ReplySender dm,\n+        OperationType op, ArrayList bucketsCleared, ReplyException ex) {\n+\n+      Assert.assertTrue(recipient != null, \"partitionedRegionClearReplyMessage NULL reply message\");\n+\n+      PartitionedRegionClearMessage.PartitionedRegionClearReplyMessage m =\n+          new PartitionedRegionClearMessage.PartitionedRegionClearReplyMessage(processorId, op,\n+              bucketsCleared, ex);\n+\n+      m.setRecipient(recipient);\n+      dm.putOutgoing(m);\n+    }\n+\n+    /**\n+     * Processes this message. This method is invoked by the receiver of the message.\n+     *\n+     * @param dm the distribution manager that is processing the message.\n+     */\n+    @Override\n+    public void process(final DistributionManager dm, final ReplyProcessor21 rp) {\n+      final long startTime = getTimestamp();\n+\n+      if (rp == null) {\n+        if (LogService.getLogger().isTraceEnabled(LogMarker.DM_VERBOSE)) {\n+          LogService.getLogger().trace(LogMarker.DM_VERBOSE, \"{}: processor not found\", this);\n+        }\n+        return;\n+      }\n+\n+      rp.process(this);\n+\n+      dm.getStats().incReplyMessageTime(NanoTimer.getTime() - startTime);\n+    }\n+\n+    @Override\n+    public int getDSFID() {\n+      return CLEAR_PARTITIONED_REGION_REPLY_MESSAGE;\n+    }\n+\n+    @Override\n+    public void fromData(DataInput in,\n+        DeserializationContext context) throws IOException, ClassNotFoundException {\n+      super.fromData(in, context);\n+      op = PartitionedRegionClearMessage.OperationType.values()[in.readByte()];\n+      bucketsCleared = DataSerializer.readArrayList(in);\n+    }\n+\n+    @Override\n+    public void toData(DataOutput out,\n+        SerializationContext context) throws IOException {\n+      super.toData(out, context);\n+      out.writeByte(op.ordinal());\n+      DataSerializer.writeArrayList(bucketsCleared, out);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      StringBuffer sb = new StringBuffer();\n+      sb.append(\"PartitionedRegionClearReplyMessage \").append(\"processorid=\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6316dbb74978e078b062da25c82ab5345ee4178a"}, "originalPosition": 279}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1NTgxMTA3", "url": "https://github.com/apache/geode/pull/5124#pullrequestreview-415581107", "createdAt": "2020-05-20T17:56:25Z", "commit": {"oid": "6316dbb74978e078b062da25c82ab5345ee4178a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cda2de8ba2f9ee74acfe13ffbf1029561c0ca0ce", "author": {"user": null}, "url": "https://github.com/apache/geode/commit/cda2de8ba2f9ee74acfe13ffbf1029561c0ca0ce", "committedDate": "2020-05-20T19:47:58Z", "message": "Add review comment with toString()"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1NzM5MTE1", "url": "https://github.com/apache/geode/pull/5124#pullrequestreview-415739115", "createdAt": "2020-05-20T21:48:59Z", "commit": {"oid": "cda2de8ba2f9ee74acfe13ffbf1029561c0ca0ce"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4541, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}