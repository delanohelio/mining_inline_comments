{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyNzc1MTgx", "number": 5236, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNDozNDozNlrOEEtiXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNzo0NzoyN1rOEForpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMzc1ODM3OnYy", "diffSide": "RIGHT", "path": "geode-membership/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/MembershipIntegrationTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNDozNDozNlrOGigOOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNzowNTo0OVrOGimqUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgzMjY5Ng==", "bodyText": "There are a couple of these auto-generated try/catch statements in the test.  If they're failure conditions shouldn't the test fail?  If they're not, what good are these stack traces?", "url": "https://github.com/apache/geode/pull/5236#discussion_r438832696", "createdAt": "2020-06-11T14:34:36Z", "author": {"login": "bschuchardt"}, "path": "geode-membership/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/MembershipIntegrationTest.java", "diffHunk": "@@ -172,6 +179,91 @@ public void secondMembershipCanJoinUsingTheSecondLocatorToStart()\n     stop(locator2, locator1);\n   }\n \n+  @Test\n+  public void secondMembershipPausesForLocatorWaitTime()\n+      throws IOException, MemberStartupException {\n+\n+    /*\n+     * Start a locator for the coordinator (membership) so we have a port for it.\n+     *\n+     * Its locator-wait-time is set to 0 so it eventually (soon after membership is started) forms a\n+     * distributed system and becomes a coordinator.\n+     */\n+\n+    final MembershipLocator<MemberIdentifier> coordinatorLocator = createLocator(0);\n+    coordinatorLocator.start();\n+    final int coordinatorLocatorPort = coordinatorLocator.getPort();\n+\n+    final Membership<MemberIdentifier> coordinatorMembership =\n+        createMembership(coordinatorLocator, coordinatorLocatorPort);\n+\n+    /*\n+     * We have not even started the membership yet \u2014 connection attempts will certainly fail until\n+     * we do. This is a bit like the locator (host) not being present in DNS (yet).\n+     */\n+\n+    /*\n+     * Start a second locator and membership trying to join via the coordinator (membership) that\n+     * hasn't yet started behind the port.\n+     *\n+     * Set its locator-wait-time so it'll not become a coordinator right away, allowing time for the\n+     * other member to start and become a coordinator.\n+     *\n+     * Calculate the locator-wait-time to be greater than the minimum wait time for connecting to a\n+     * locator.\n+     */\n+\n+    final MembershipLocator<MemberIdentifier> lateJoiningLocator = createLocator(0);\n+    lateJoiningLocator.start();\n+    final int lateJoiningLocatorPort = lateJoiningLocator.getPort();\n+\n+    final int[] lateJoiningMembershipLocatorPorts =\n+        new int[] {coordinatorLocatorPort, lateJoiningLocatorPort};\n+\n+    final Duration minimumJoinWaitTime = Duration\n+        .ofMillis(2_000) // expected amount of sleep time per loop in GMSJoinLeave.join()\n+        .multipliedBy(lateJoiningMembershipLocatorPorts.length * 2); // expected number of loops\n+    final int locatorWaitTime = (int) (3 * minimumJoinWaitTime.getSeconds());\n+\n+    final MembershipConfig lateJoiningMembershipConfig =\n+        createMembershipConfig(true, locatorWaitTime, lateJoiningMembershipLocatorPorts);\n+    final Membership<MemberIdentifier> lateJoiningMembership =\n+        createMembership(lateJoiningMembershipConfig, lateJoiningLocator);\n+\n+    CompletableFuture<Void> lateJoiningMembershipStartup = executorServiceRule.runAsync(() -> {\n+      try {\n+        start(lateJoiningMembership);\n+      } catch (MemberStartupException e) {\n+        e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c49c8bcc4d58ff36e16f98cc1177feb1cd0a8a12"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzODE5NA==", "bodyText": "Updated in latest commits", "url": "https://github.com/apache/geode/pull/5236#discussion_r438938194", "createdAt": "2020-06-11T17:05:49Z", "author": {"login": "aaronlindsey"}, "path": "geode-membership/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/MembershipIntegrationTest.java", "diffHunk": "@@ -172,6 +179,91 @@ public void secondMembershipCanJoinUsingTheSecondLocatorToStart()\n     stop(locator2, locator1);\n   }\n \n+  @Test\n+  public void secondMembershipPausesForLocatorWaitTime()\n+      throws IOException, MemberStartupException {\n+\n+    /*\n+     * Start a locator for the coordinator (membership) so we have a port for it.\n+     *\n+     * Its locator-wait-time is set to 0 so it eventually (soon after membership is started) forms a\n+     * distributed system and becomes a coordinator.\n+     */\n+\n+    final MembershipLocator<MemberIdentifier> coordinatorLocator = createLocator(0);\n+    coordinatorLocator.start();\n+    final int coordinatorLocatorPort = coordinatorLocator.getPort();\n+\n+    final Membership<MemberIdentifier> coordinatorMembership =\n+        createMembership(coordinatorLocator, coordinatorLocatorPort);\n+\n+    /*\n+     * We have not even started the membership yet \u2014 connection attempts will certainly fail until\n+     * we do. This is a bit like the locator (host) not being present in DNS (yet).\n+     */\n+\n+    /*\n+     * Start a second locator and membership trying to join via the coordinator (membership) that\n+     * hasn't yet started behind the port.\n+     *\n+     * Set its locator-wait-time so it'll not become a coordinator right away, allowing time for the\n+     * other member to start and become a coordinator.\n+     *\n+     * Calculate the locator-wait-time to be greater than the minimum wait time for connecting to a\n+     * locator.\n+     */\n+\n+    final MembershipLocator<MemberIdentifier> lateJoiningLocator = createLocator(0);\n+    lateJoiningLocator.start();\n+    final int lateJoiningLocatorPort = lateJoiningLocator.getPort();\n+\n+    final int[] lateJoiningMembershipLocatorPorts =\n+        new int[] {coordinatorLocatorPort, lateJoiningLocatorPort};\n+\n+    final Duration minimumJoinWaitTime = Duration\n+        .ofMillis(2_000) // expected amount of sleep time per loop in GMSJoinLeave.join()\n+        .multipliedBy(lateJoiningMembershipLocatorPorts.length * 2); // expected number of loops\n+    final int locatorWaitTime = (int) (3 * minimumJoinWaitTime.getSeconds());\n+\n+    final MembershipConfig lateJoiningMembershipConfig =\n+        createMembershipConfig(true, locatorWaitTime, lateJoiningMembershipLocatorPorts);\n+    final Membership<MemberIdentifier> lateJoiningMembership =\n+        createMembership(lateJoiningMembershipConfig, lateJoiningLocator);\n+\n+    CompletableFuture<Void> lateJoiningMembershipStartup = executorServiceRule.runAsync(() -> {\n+      try {\n+        start(lateJoiningMembership);\n+      } catch (MemberStartupException e) {\n+        e.printStackTrace();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgzMjY5Ng=="}, "originalCommit": {"oid": "c49c8bcc4d58ff36e16f98cc1177feb1cd0a8a12"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNDM5MjMwOnYy", "diffSide": "RIGHT", "path": "geode-membership/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/MembershipIntegrationTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNzowNDoxM1rOGimnDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNzowNjowMVrOGimq3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzNzM1OQ==", "bodyText": "It seems like it would be better to reference the same constants that are used in GMSJoinLeave instead of hard-coding this value.", "url": "https://github.com/apache/geode/pull/5236#discussion_r438937359", "createdAt": "2020-06-11T17:04:13Z", "author": {"login": "aaronlindsey"}, "path": "geode-membership/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/MembershipIntegrationTest.java", "diffHunk": "@@ -172,6 +179,91 @@ public void secondMembershipCanJoinUsingTheSecondLocatorToStart()\n     stop(locator2, locator1);\n   }\n \n+  @Test\n+  public void secondMembershipPausesForLocatorWaitTime()\n+      throws IOException, MemberStartupException {\n+\n+    /*\n+     * Start a locator for the coordinator (membership) so we have a port for it.\n+     *\n+     * Its locator-wait-time is set to 0 so it eventually (soon after membership is started) forms a\n+     * distributed system and becomes a coordinator.\n+     */\n+\n+    final MembershipLocator<MemberIdentifier> coordinatorLocator = createLocator(0);\n+    coordinatorLocator.start();\n+    final int coordinatorLocatorPort = coordinatorLocator.getPort();\n+\n+    final Membership<MemberIdentifier> coordinatorMembership =\n+        createMembership(coordinatorLocator, coordinatorLocatorPort);\n+\n+    /*\n+     * We have not even started the membership yet \u2014 connection attempts will certainly fail until\n+     * we do. This is a bit like the locator (host) not being present in DNS (yet).\n+     */\n+\n+    /*\n+     * Start a second locator and membership trying to join via the coordinator (membership) that\n+     * hasn't yet started behind the port.\n+     *\n+     * Set its locator-wait-time so it'll not become a coordinator right away, allowing time for the\n+     * other member to start and become a coordinator.\n+     *\n+     * Calculate the locator-wait-time to be greater than the minimum wait time for connecting to a\n+     * locator.\n+     */\n+\n+    final MembershipLocator<MemberIdentifier> lateJoiningLocator = createLocator(0);\n+    lateJoiningLocator.start();\n+    final int lateJoiningLocatorPort = lateJoiningLocator.getPort();\n+\n+    final int[] lateJoiningMembershipLocatorPorts =\n+        new int[] {coordinatorLocatorPort, lateJoiningLocatorPort};\n+\n+    final Duration minimumJoinWaitTime = Duration\n+        .ofMillis(2_000) // expected amount of sleep time per loop in GMSJoinLeave.join()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c49c8bcc4d58ff36e16f98cc1177feb1cd0a8a12"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzODMzNA==", "bodyText": "Updated in latest commits", "url": "https://github.com/apache/geode/pull/5236#discussion_r438938334", "createdAt": "2020-06-11T17:06:01Z", "author": {"login": "aaronlindsey"}, "path": "geode-membership/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/MembershipIntegrationTest.java", "diffHunk": "@@ -172,6 +179,91 @@ public void secondMembershipCanJoinUsingTheSecondLocatorToStart()\n     stop(locator2, locator1);\n   }\n \n+  @Test\n+  public void secondMembershipPausesForLocatorWaitTime()\n+      throws IOException, MemberStartupException {\n+\n+    /*\n+     * Start a locator for the coordinator (membership) so we have a port for it.\n+     *\n+     * Its locator-wait-time is set to 0 so it eventually (soon after membership is started) forms a\n+     * distributed system and becomes a coordinator.\n+     */\n+\n+    final MembershipLocator<MemberIdentifier> coordinatorLocator = createLocator(0);\n+    coordinatorLocator.start();\n+    final int coordinatorLocatorPort = coordinatorLocator.getPort();\n+\n+    final Membership<MemberIdentifier> coordinatorMembership =\n+        createMembership(coordinatorLocator, coordinatorLocatorPort);\n+\n+    /*\n+     * We have not even started the membership yet \u2014 connection attempts will certainly fail until\n+     * we do. This is a bit like the locator (host) not being present in DNS (yet).\n+     */\n+\n+    /*\n+     * Start a second locator and membership trying to join via the coordinator (membership) that\n+     * hasn't yet started behind the port.\n+     *\n+     * Set its locator-wait-time so it'll not become a coordinator right away, allowing time for the\n+     * other member to start and become a coordinator.\n+     *\n+     * Calculate the locator-wait-time to be greater than the minimum wait time for connecting to a\n+     * locator.\n+     */\n+\n+    final MembershipLocator<MemberIdentifier> lateJoiningLocator = createLocator(0);\n+    lateJoiningLocator.start();\n+    final int lateJoiningLocatorPort = lateJoiningLocator.getPort();\n+\n+    final int[] lateJoiningMembershipLocatorPorts =\n+        new int[] {coordinatorLocatorPort, lateJoiningLocatorPort};\n+\n+    final Duration minimumJoinWaitTime = Duration\n+        .ofMillis(2_000) // expected amount of sleep time per loop in GMSJoinLeave.join()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzNzM1OQ=="}, "originalCommit": {"oid": "c49c8bcc4d58ff36e16f98cc1177feb1cd0a8a12"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MzQzNDIzOnYy", "diffSide": "RIGHT", "path": "geode-membership/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/MembershipIntegrationTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNzo0MzowOVrOGj8TuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMDo0NDo1NlrOGlWw7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0MTQzMg==", "bodyText": "where does 3 come from?", "url": "https://github.com/apache/geode/pull/5236#discussion_r440341432", "createdAt": "2020-06-15T17:43:09Z", "author": {"login": "Bill"}, "path": "geode-membership/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/MembershipIntegrationTest.java", "diffHunk": "@@ -172,6 +181,92 @@ public void secondMembershipCanJoinUsingTheSecondLocatorToStart()\n     stop(locator2, locator1);\n   }\n \n+  @Test\n+  public void secondMembershipPausesForLocatorWaitTime()\n+      throws IOException, MemberStartupException {\n+\n+    /*\n+     * Start a locator for the coordinator (membership) so we have a port for it.\n+     *\n+     * Its locator-wait-time is set to 0 so it eventually (soon after membership is started) forms a\n+     * distributed system and becomes a coordinator.\n+     */\n+\n+    final MembershipLocator<MemberIdentifier> coordinatorLocator = createLocator(0);\n+    coordinatorLocator.start();\n+    final int coordinatorLocatorPort = coordinatorLocator.getPort();\n+\n+    final Membership<MemberIdentifier> coordinatorMembership =\n+        createMembership(coordinatorLocator, coordinatorLocatorPort);\n+\n+    /*\n+     * We have not even started the membership yet \u2014 connection attempts will certainly fail until\n+     * we do. This is a bit like the locator (host) not being present in DNS (yet).\n+     */\n+\n+    /*\n+     * Start a second locator and membership trying to join via the coordinator (membership) that\n+     * hasn't yet started behind the port.\n+     *\n+     * Set its locator-wait-time so it'll not become a coordinator right away, allowing time for the\n+     * other member to start and become a coordinator.\n+     *\n+     * Calculate the locator-wait-time to be greater than the minimum wait time for connecting to a\n+     * locator.\n+     */\n+\n+    final MembershipLocator<MemberIdentifier> lateJoiningLocator = createLocator(0);\n+    lateJoiningLocator.start();\n+    final int lateJoiningLocatorPort = lateJoiningLocator.getPort();\n+\n+    final int[] lateJoiningMembershipLocatorPorts =\n+        new int[] {coordinatorLocatorPort, lateJoiningLocatorPort};\n+\n+    final Duration minimumJoinWaitTime = Duration\n+        .ofMillis(JOIN_RETRY_SLEEP + FIND_LOCATOR_RETRY_SLEEP) // amount of sleep time per retry\n+        .multipliedBy(lateJoiningMembershipLocatorPorts.length * 2); // expected number of retries\n+    final int locatorWaitTime = (int) (3 * minimumJoinWaitTime.getSeconds());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90479c43a5f74c0b90cf29bb2042777545ba7bec"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ0NzM4NQ==", "bodyText": "There is a minimum amount of time a locator will wait to become the coordinator, regardless of the value for locator-wait-time. The variable, minimumJoinWaitTime, is meant to capture that value. By setting locator-wait-time to 3x the minimumJoinWaitTime, we are just trying to make sure the locator-wait-time is sufficiently larger than the minimum so we can reliably detect whether the lateJoiningMembership is waiting for the full locator-wait-time and not just the minimum wait time.", "url": "https://github.com/apache/geode/pull/5236#discussion_r440447385", "createdAt": "2020-06-15T21:07:00Z", "author": {"login": "aaronlindsey"}, "path": "geode-membership/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/MembershipIntegrationTest.java", "diffHunk": "@@ -172,6 +181,92 @@ public void secondMembershipCanJoinUsingTheSecondLocatorToStart()\n     stop(locator2, locator1);\n   }\n \n+  @Test\n+  public void secondMembershipPausesForLocatorWaitTime()\n+      throws IOException, MemberStartupException {\n+\n+    /*\n+     * Start a locator for the coordinator (membership) so we have a port for it.\n+     *\n+     * Its locator-wait-time is set to 0 so it eventually (soon after membership is started) forms a\n+     * distributed system and becomes a coordinator.\n+     */\n+\n+    final MembershipLocator<MemberIdentifier> coordinatorLocator = createLocator(0);\n+    coordinatorLocator.start();\n+    final int coordinatorLocatorPort = coordinatorLocator.getPort();\n+\n+    final Membership<MemberIdentifier> coordinatorMembership =\n+        createMembership(coordinatorLocator, coordinatorLocatorPort);\n+\n+    /*\n+     * We have not even started the membership yet \u2014 connection attempts will certainly fail until\n+     * we do. This is a bit like the locator (host) not being present in DNS (yet).\n+     */\n+\n+    /*\n+     * Start a second locator and membership trying to join via the coordinator (membership) that\n+     * hasn't yet started behind the port.\n+     *\n+     * Set its locator-wait-time so it'll not become a coordinator right away, allowing time for the\n+     * other member to start and become a coordinator.\n+     *\n+     * Calculate the locator-wait-time to be greater than the minimum wait time for connecting to a\n+     * locator.\n+     */\n+\n+    final MembershipLocator<MemberIdentifier> lateJoiningLocator = createLocator(0);\n+    lateJoiningLocator.start();\n+    final int lateJoiningLocatorPort = lateJoiningLocator.getPort();\n+\n+    final int[] lateJoiningMembershipLocatorPorts =\n+        new int[] {coordinatorLocatorPort, lateJoiningLocatorPort};\n+\n+    final Duration minimumJoinWaitTime = Duration\n+        .ofMillis(JOIN_RETRY_SLEEP + FIND_LOCATOR_RETRY_SLEEP) // amount of sleep time per retry\n+        .multipliedBy(lateJoiningMembershipLocatorPorts.length * 2); // expected number of retries\n+    final int locatorWaitTime = (int) (3 * minimumJoinWaitTime.getSeconds());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0MTQzMg=="}, "originalCommit": {"oid": "90479c43a5f74c0b90cf29bb2042777545ba7bec"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgyMzQ2OA==", "bodyText": "I added a comment to the code in the latest commit.", "url": "https://github.com/apache/geode/pull/5236#discussion_r441823468", "createdAt": "2020-06-17T20:44:56Z", "author": {"login": "aaronlindsey"}, "path": "geode-membership/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/MembershipIntegrationTest.java", "diffHunk": "@@ -172,6 +181,92 @@ public void secondMembershipCanJoinUsingTheSecondLocatorToStart()\n     stop(locator2, locator1);\n   }\n \n+  @Test\n+  public void secondMembershipPausesForLocatorWaitTime()\n+      throws IOException, MemberStartupException {\n+\n+    /*\n+     * Start a locator for the coordinator (membership) so we have a port for it.\n+     *\n+     * Its locator-wait-time is set to 0 so it eventually (soon after membership is started) forms a\n+     * distributed system and becomes a coordinator.\n+     */\n+\n+    final MembershipLocator<MemberIdentifier> coordinatorLocator = createLocator(0);\n+    coordinatorLocator.start();\n+    final int coordinatorLocatorPort = coordinatorLocator.getPort();\n+\n+    final Membership<MemberIdentifier> coordinatorMembership =\n+        createMembership(coordinatorLocator, coordinatorLocatorPort);\n+\n+    /*\n+     * We have not even started the membership yet \u2014 connection attempts will certainly fail until\n+     * we do. This is a bit like the locator (host) not being present in DNS (yet).\n+     */\n+\n+    /*\n+     * Start a second locator and membership trying to join via the coordinator (membership) that\n+     * hasn't yet started behind the port.\n+     *\n+     * Set its locator-wait-time so it'll not become a coordinator right away, allowing time for the\n+     * other member to start and become a coordinator.\n+     *\n+     * Calculate the locator-wait-time to be greater than the minimum wait time for connecting to a\n+     * locator.\n+     */\n+\n+    final MembershipLocator<MemberIdentifier> lateJoiningLocator = createLocator(0);\n+    lateJoiningLocator.start();\n+    final int lateJoiningLocatorPort = lateJoiningLocator.getPort();\n+\n+    final int[] lateJoiningMembershipLocatorPorts =\n+        new int[] {coordinatorLocatorPort, lateJoiningLocatorPort};\n+\n+    final Duration minimumJoinWaitTime = Duration\n+        .ofMillis(JOIN_RETRY_SLEEP + FIND_LOCATOR_RETRY_SLEEP) // amount of sleep time per retry\n+        .multipliedBy(lateJoiningMembershipLocatorPorts.length * 2); // expected number of retries\n+    final int locatorWaitTime = (int) (3 * minimumJoinWaitTime.getSeconds());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0MTQzMg=="}, "originalCommit": {"oid": "90479c43a5f74c0b90cf29bb2042777545ba7bec"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MzQzNjU2OnYy", "diffSide": "RIGHT", "path": "geode-membership/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/MembershipIntegrationTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNzo0Mzo1N1rOGj8VOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMDo0NToyN1rOGlWyCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0MTgxNw==", "bodyText": "where does 2 come from? even if you don't want to explicitly reference an internal constant, it'd be nice to document where that constant lives", "url": "https://github.com/apache/geode/pull/5236#discussion_r440341817", "createdAt": "2020-06-15T17:43:57Z", "author": {"login": "Bill"}, "path": "geode-membership/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/MembershipIntegrationTest.java", "diffHunk": "@@ -172,6 +181,92 @@ public void secondMembershipCanJoinUsingTheSecondLocatorToStart()\n     stop(locator2, locator1);\n   }\n \n+  @Test\n+  public void secondMembershipPausesForLocatorWaitTime()\n+      throws IOException, MemberStartupException {\n+\n+    /*\n+     * Start a locator for the coordinator (membership) so we have a port for it.\n+     *\n+     * Its locator-wait-time is set to 0 so it eventually (soon after membership is started) forms a\n+     * distributed system and becomes a coordinator.\n+     */\n+\n+    final MembershipLocator<MemberIdentifier> coordinatorLocator = createLocator(0);\n+    coordinatorLocator.start();\n+    final int coordinatorLocatorPort = coordinatorLocator.getPort();\n+\n+    final Membership<MemberIdentifier> coordinatorMembership =\n+        createMembership(coordinatorLocator, coordinatorLocatorPort);\n+\n+    /*\n+     * We have not even started the membership yet \u2014 connection attempts will certainly fail until\n+     * we do. This is a bit like the locator (host) not being present in DNS (yet).\n+     */\n+\n+    /*\n+     * Start a second locator and membership trying to join via the coordinator (membership) that\n+     * hasn't yet started behind the port.\n+     *\n+     * Set its locator-wait-time so it'll not become a coordinator right away, allowing time for the\n+     * other member to start and become a coordinator.\n+     *\n+     * Calculate the locator-wait-time to be greater than the minimum wait time for connecting to a\n+     * locator.\n+     */\n+\n+    final MembershipLocator<MemberIdentifier> lateJoiningLocator = createLocator(0);\n+    lateJoiningLocator.start();\n+    final int lateJoiningLocatorPort = lateJoiningLocator.getPort();\n+\n+    final int[] lateJoiningMembershipLocatorPorts =\n+        new int[] {coordinatorLocatorPort, lateJoiningLocatorPort};\n+\n+    final Duration minimumJoinWaitTime = Duration\n+        .ofMillis(JOIN_RETRY_SLEEP + FIND_LOCATOR_RETRY_SLEEP) // amount of sleep time per retry\n+        .multipliedBy(lateJoiningMembershipLocatorPorts.length * 2); // expected number of retries", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90479c43a5f74c0b90cf29bb2042777545ba7bec"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ0ODU2OQ==", "bodyText": "It comes from this line. I could assign the 2 to a constant and reference that if it would be clearer.", "url": "https://github.com/apache/geode/pull/5236#discussion_r440448569", "createdAt": "2020-06-15T21:09:18Z", "author": {"login": "aaronlindsey"}, "path": "geode-membership/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/MembershipIntegrationTest.java", "diffHunk": "@@ -172,6 +181,92 @@ public void secondMembershipCanJoinUsingTheSecondLocatorToStart()\n     stop(locator2, locator1);\n   }\n \n+  @Test\n+  public void secondMembershipPausesForLocatorWaitTime()\n+      throws IOException, MemberStartupException {\n+\n+    /*\n+     * Start a locator for the coordinator (membership) so we have a port for it.\n+     *\n+     * Its locator-wait-time is set to 0 so it eventually (soon after membership is started) forms a\n+     * distributed system and becomes a coordinator.\n+     */\n+\n+    final MembershipLocator<MemberIdentifier> coordinatorLocator = createLocator(0);\n+    coordinatorLocator.start();\n+    final int coordinatorLocatorPort = coordinatorLocator.getPort();\n+\n+    final Membership<MemberIdentifier> coordinatorMembership =\n+        createMembership(coordinatorLocator, coordinatorLocatorPort);\n+\n+    /*\n+     * We have not even started the membership yet \u2014 connection attempts will certainly fail until\n+     * we do. This is a bit like the locator (host) not being present in DNS (yet).\n+     */\n+\n+    /*\n+     * Start a second locator and membership trying to join via the coordinator (membership) that\n+     * hasn't yet started behind the port.\n+     *\n+     * Set its locator-wait-time so it'll not become a coordinator right away, allowing time for the\n+     * other member to start and become a coordinator.\n+     *\n+     * Calculate the locator-wait-time to be greater than the minimum wait time for connecting to a\n+     * locator.\n+     */\n+\n+    final MembershipLocator<MemberIdentifier> lateJoiningLocator = createLocator(0);\n+    lateJoiningLocator.start();\n+    final int lateJoiningLocatorPort = lateJoiningLocator.getPort();\n+\n+    final int[] lateJoiningMembershipLocatorPorts =\n+        new int[] {coordinatorLocatorPort, lateJoiningLocatorPort};\n+\n+    final Duration minimumJoinWaitTime = Duration\n+        .ofMillis(JOIN_RETRY_SLEEP + FIND_LOCATOR_RETRY_SLEEP) // amount of sleep time per retry\n+        .multipliedBy(lateJoiningMembershipLocatorPorts.length * 2); // expected number of retries", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0MTgxNw=="}, "originalCommit": {"oid": "90479c43a5f74c0b90cf29bb2042777545ba7bec"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgyMzc1NQ==", "bodyText": "I extracted a method for calculating the minimum number of retries before becoming coordinator in the latest commit.", "url": "https://github.com/apache/geode/pull/5236#discussion_r441823755", "createdAt": "2020-06-17T20:45:27Z", "author": {"login": "aaronlindsey"}, "path": "geode-membership/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/MembershipIntegrationTest.java", "diffHunk": "@@ -172,6 +181,92 @@ public void secondMembershipCanJoinUsingTheSecondLocatorToStart()\n     stop(locator2, locator1);\n   }\n \n+  @Test\n+  public void secondMembershipPausesForLocatorWaitTime()\n+      throws IOException, MemberStartupException {\n+\n+    /*\n+     * Start a locator for the coordinator (membership) so we have a port for it.\n+     *\n+     * Its locator-wait-time is set to 0 so it eventually (soon after membership is started) forms a\n+     * distributed system and becomes a coordinator.\n+     */\n+\n+    final MembershipLocator<MemberIdentifier> coordinatorLocator = createLocator(0);\n+    coordinatorLocator.start();\n+    final int coordinatorLocatorPort = coordinatorLocator.getPort();\n+\n+    final Membership<MemberIdentifier> coordinatorMembership =\n+        createMembership(coordinatorLocator, coordinatorLocatorPort);\n+\n+    /*\n+     * We have not even started the membership yet \u2014 connection attempts will certainly fail until\n+     * we do. This is a bit like the locator (host) not being present in DNS (yet).\n+     */\n+\n+    /*\n+     * Start a second locator and membership trying to join via the coordinator (membership) that\n+     * hasn't yet started behind the port.\n+     *\n+     * Set its locator-wait-time so it'll not become a coordinator right away, allowing time for the\n+     * other member to start and become a coordinator.\n+     *\n+     * Calculate the locator-wait-time to be greater than the minimum wait time for connecting to a\n+     * locator.\n+     */\n+\n+    final MembershipLocator<MemberIdentifier> lateJoiningLocator = createLocator(0);\n+    lateJoiningLocator.start();\n+    final int lateJoiningLocatorPort = lateJoiningLocator.getPort();\n+\n+    final int[] lateJoiningMembershipLocatorPorts =\n+        new int[] {coordinatorLocatorPort, lateJoiningLocatorPort};\n+\n+    final Duration minimumJoinWaitTime = Duration\n+        .ofMillis(JOIN_RETRY_SLEEP + FIND_LOCATOR_RETRY_SLEEP) // amount of sleep time per retry\n+        .multipliedBy(lateJoiningMembershipLocatorPorts.length * 2); // expected number of retries", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0MTgxNw=="}, "originalCommit": {"oid": "90479c43a5f74c0b90cf29bb2042777545ba7bec"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MzQ0ODY5OnYy", "diffSide": "RIGHT", "path": "geode-membership/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/MembershipIntegrationTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNzo0NzoyN1rOGj8c1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMDo0NDo1MlrOGlWwzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0Mzc2NQ==", "bodyText": "where does this 2 come from?", "url": "https://github.com/apache/geode/pull/5236#discussion_r440343765", "createdAt": "2020-06-15T17:47:27Z", "author": {"login": "Bill"}, "path": "geode-membership/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/MembershipIntegrationTest.java", "diffHunk": "@@ -172,6 +181,92 @@ public void secondMembershipCanJoinUsingTheSecondLocatorToStart()\n     stop(locator2, locator1);\n   }\n \n+  @Test\n+  public void secondMembershipPausesForLocatorWaitTime()\n+      throws IOException, MemberStartupException {\n+\n+    /*\n+     * Start a locator for the coordinator (membership) so we have a port for it.\n+     *\n+     * Its locator-wait-time is set to 0 so it eventually (soon after membership is started) forms a\n+     * distributed system and becomes a coordinator.\n+     */\n+\n+    final MembershipLocator<MemberIdentifier> coordinatorLocator = createLocator(0);\n+    coordinatorLocator.start();\n+    final int coordinatorLocatorPort = coordinatorLocator.getPort();\n+\n+    final Membership<MemberIdentifier> coordinatorMembership =\n+        createMembership(coordinatorLocator, coordinatorLocatorPort);\n+\n+    /*\n+     * We have not even started the membership yet \u2014 connection attempts will certainly fail until\n+     * we do. This is a bit like the locator (host) not being present in DNS (yet).\n+     */\n+\n+    /*\n+     * Start a second locator and membership trying to join via the coordinator (membership) that\n+     * hasn't yet started behind the port.\n+     *\n+     * Set its locator-wait-time so it'll not become a coordinator right away, allowing time for the\n+     * other member to start and become a coordinator.\n+     *\n+     * Calculate the locator-wait-time to be greater than the minimum wait time for connecting to a\n+     * locator.\n+     */\n+\n+    final MembershipLocator<MemberIdentifier> lateJoiningLocator = createLocator(0);\n+    lateJoiningLocator.start();\n+    final int lateJoiningLocatorPort = lateJoiningLocator.getPort();\n+\n+    final int[] lateJoiningMembershipLocatorPorts =\n+        new int[] {coordinatorLocatorPort, lateJoiningLocatorPort};\n+\n+    final Duration minimumJoinWaitTime = Duration\n+        .ofMillis(JOIN_RETRY_SLEEP + FIND_LOCATOR_RETRY_SLEEP) // amount of sleep time per retry\n+        .multipliedBy(lateJoiningMembershipLocatorPorts.length * 2); // expected number of retries\n+    final int locatorWaitTime = (int) (3 * minimumJoinWaitTime.getSeconds());\n+\n+    final MembershipConfig lateJoiningMembershipConfig =\n+        createMembershipConfig(true, locatorWaitTime, lateJoiningMembershipLocatorPorts);\n+    final Membership<MemberIdentifier> lateJoiningMembership =\n+        createMembership(lateJoiningMembershipConfig, lateJoiningLocator);\n+\n+    CompletableFuture<Void> lateJoiningMembershipStartup = executorServiceRule.runAsync(() -> {\n+      try {\n+        start(lateJoiningMembership);\n+      } catch (MemberStartupException e) {\n+        throw new RuntimeException(e);\n+      }\n+    });\n+\n+    /*\n+     * Now start the coordinator (membership), after waiting longer than the minimum wait time for\n+     * connecting to a locator but shorter than the locator-wait-time.\n+     */\n+\n+    CompletableFuture<Void> coordinatorMembershipStartup = executorServiceRule.runAsync(() -> {\n+      try {\n+        Thread.sleep(2 * minimumJoinWaitTime.toMillis());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90479c43a5f74c0b90cf29bb2042777545ba7bec"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ1MTMwNA==", "bodyText": "Again, minimumJoinWaitTime is the minimum amount of time a locator will wait to become a coordinator. We are just trying to make sure we sleep for longer than the minimum but shorter than the locator-wait-time so we can detect whether the lateJoiningMembership is waiting for the full locator-wait-time and not just the minimum wait time.", "url": "https://github.com/apache/geode/pull/5236#discussion_r440451304", "createdAt": "2020-06-15T21:15:07Z", "author": {"login": "aaronlindsey"}, "path": "geode-membership/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/MembershipIntegrationTest.java", "diffHunk": "@@ -172,6 +181,92 @@ public void secondMembershipCanJoinUsingTheSecondLocatorToStart()\n     stop(locator2, locator1);\n   }\n \n+  @Test\n+  public void secondMembershipPausesForLocatorWaitTime()\n+      throws IOException, MemberStartupException {\n+\n+    /*\n+     * Start a locator for the coordinator (membership) so we have a port for it.\n+     *\n+     * Its locator-wait-time is set to 0 so it eventually (soon after membership is started) forms a\n+     * distributed system and becomes a coordinator.\n+     */\n+\n+    final MembershipLocator<MemberIdentifier> coordinatorLocator = createLocator(0);\n+    coordinatorLocator.start();\n+    final int coordinatorLocatorPort = coordinatorLocator.getPort();\n+\n+    final Membership<MemberIdentifier> coordinatorMembership =\n+        createMembership(coordinatorLocator, coordinatorLocatorPort);\n+\n+    /*\n+     * We have not even started the membership yet \u2014 connection attempts will certainly fail until\n+     * we do. This is a bit like the locator (host) not being present in DNS (yet).\n+     */\n+\n+    /*\n+     * Start a second locator and membership trying to join via the coordinator (membership) that\n+     * hasn't yet started behind the port.\n+     *\n+     * Set its locator-wait-time so it'll not become a coordinator right away, allowing time for the\n+     * other member to start and become a coordinator.\n+     *\n+     * Calculate the locator-wait-time to be greater than the minimum wait time for connecting to a\n+     * locator.\n+     */\n+\n+    final MembershipLocator<MemberIdentifier> lateJoiningLocator = createLocator(0);\n+    lateJoiningLocator.start();\n+    final int lateJoiningLocatorPort = lateJoiningLocator.getPort();\n+\n+    final int[] lateJoiningMembershipLocatorPorts =\n+        new int[] {coordinatorLocatorPort, lateJoiningLocatorPort};\n+\n+    final Duration minimumJoinWaitTime = Duration\n+        .ofMillis(JOIN_RETRY_SLEEP + FIND_LOCATOR_RETRY_SLEEP) // amount of sleep time per retry\n+        .multipliedBy(lateJoiningMembershipLocatorPorts.length * 2); // expected number of retries\n+    final int locatorWaitTime = (int) (3 * minimumJoinWaitTime.getSeconds());\n+\n+    final MembershipConfig lateJoiningMembershipConfig =\n+        createMembershipConfig(true, locatorWaitTime, lateJoiningMembershipLocatorPorts);\n+    final Membership<MemberIdentifier> lateJoiningMembership =\n+        createMembership(lateJoiningMembershipConfig, lateJoiningLocator);\n+\n+    CompletableFuture<Void> lateJoiningMembershipStartup = executorServiceRule.runAsync(() -> {\n+      try {\n+        start(lateJoiningMembership);\n+      } catch (MemberStartupException e) {\n+        throw new RuntimeException(e);\n+      }\n+    });\n+\n+    /*\n+     * Now start the coordinator (membership), after waiting longer than the minimum wait time for\n+     * connecting to a locator but shorter than the locator-wait-time.\n+     */\n+\n+    CompletableFuture<Void> coordinatorMembershipStartup = executorServiceRule.runAsync(() -> {\n+      try {\n+        Thread.sleep(2 * minimumJoinWaitTime.toMillis());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0Mzc2NQ=="}, "originalCommit": {"oid": "90479c43a5f74c0b90cf29bb2042777545ba7bec"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgyMzQzNw==", "bodyText": "I added a comment to the code in the latest commit.", "url": "https://github.com/apache/geode/pull/5236#discussion_r441823437", "createdAt": "2020-06-17T20:44:52Z", "author": {"login": "aaronlindsey"}, "path": "geode-membership/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/MembershipIntegrationTest.java", "diffHunk": "@@ -172,6 +181,92 @@ public void secondMembershipCanJoinUsingTheSecondLocatorToStart()\n     stop(locator2, locator1);\n   }\n \n+  @Test\n+  public void secondMembershipPausesForLocatorWaitTime()\n+      throws IOException, MemberStartupException {\n+\n+    /*\n+     * Start a locator for the coordinator (membership) so we have a port for it.\n+     *\n+     * Its locator-wait-time is set to 0 so it eventually (soon after membership is started) forms a\n+     * distributed system and becomes a coordinator.\n+     */\n+\n+    final MembershipLocator<MemberIdentifier> coordinatorLocator = createLocator(0);\n+    coordinatorLocator.start();\n+    final int coordinatorLocatorPort = coordinatorLocator.getPort();\n+\n+    final Membership<MemberIdentifier> coordinatorMembership =\n+        createMembership(coordinatorLocator, coordinatorLocatorPort);\n+\n+    /*\n+     * We have not even started the membership yet \u2014 connection attempts will certainly fail until\n+     * we do. This is a bit like the locator (host) not being present in DNS (yet).\n+     */\n+\n+    /*\n+     * Start a second locator and membership trying to join via the coordinator (membership) that\n+     * hasn't yet started behind the port.\n+     *\n+     * Set its locator-wait-time so it'll not become a coordinator right away, allowing time for the\n+     * other member to start and become a coordinator.\n+     *\n+     * Calculate the locator-wait-time to be greater than the minimum wait time for connecting to a\n+     * locator.\n+     */\n+\n+    final MembershipLocator<MemberIdentifier> lateJoiningLocator = createLocator(0);\n+    lateJoiningLocator.start();\n+    final int lateJoiningLocatorPort = lateJoiningLocator.getPort();\n+\n+    final int[] lateJoiningMembershipLocatorPorts =\n+        new int[] {coordinatorLocatorPort, lateJoiningLocatorPort};\n+\n+    final Duration minimumJoinWaitTime = Duration\n+        .ofMillis(JOIN_RETRY_SLEEP + FIND_LOCATOR_RETRY_SLEEP) // amount of sleep time per retry\n+        .multipliedBy(lateJoiningMembershipLocatorPorts.length * 2); // expected number of retries\n+    final int locatorWaitTime = (int) (3 * minimumJoinWaitTime.getSeconds());\n+\n+    final MembershipConfig lateJoiningMembershipConfig =\n+        createMembershipConfig(true, locatorWaitTime, lateJoiningMembershipLocatorPorts);\n+    final Membership<MemberIdentifier> lateJoiningMembership =\n+        createMembership(lateJoiningMembershipConfig, lateJoiningLocator);\n+\n+    CompletableFuture<Void> lateJoiningMembershipStartup = executorServiceRule.runAsync(() -> {\n+      try {\n+        start(lateJoiningMembership);\n+      } catch (MemberStartupException e) {\n+        throw new RuntimeException(e);\n+      }\n+    });\n+\n+    /*\n+     * Now start the coordinator (membership), after waiting longer than the minimum wait time for\n+     * connecting to a locator but shorter than the locator-wait-time.\n+     */\n+\n+    CompletableFuture<Void> coordinatorMembershipStartup = executorServiceRule.runAsync(() -> {\n+      try {\n+        Thread.sleep(2 * minimumJoinWaitTime.toMillis());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0Mzc2NQ=="}, "originalCommit": {"oid": "90479c43a5f74c0b90cf29bb2042777545ba7bec"}, "originalPosition": 107}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3985, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}