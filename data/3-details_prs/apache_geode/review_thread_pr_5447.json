{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY2MjU3NzE5", "number": 5447, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxODo1MzoyNlrOEXwS9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMjozNToyN1rOEX0qbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMzQzOTg4OnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TombstoneServiceTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxODo1MzoyNlrOG_uSJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMDo1MDo1NVrOG_yYjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ3MTc4MQ==", "bodyText": "This method is empty and can be removed.", "url": "https://github.com/apache/geode/pull/5447#discussion_r469471781", "createdAt": "2020-08-12T18:53:26Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TombstoneServiceTest.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package org.apache.geode.internal.cache;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.concurrent.ExecutorService;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.distributed.internal.CacheTime;\n+import org.apache.geode.internal.cache.versions.RegionVersionVector;\n+import org.apache.geode.internal.cache.versions.VersionTag;\n+\n+public class TombstoneServiceTest {\n+  CacheTime cacheTime = mock(CacheTime.class);\n+  CachePerfStats stats = mock(CachePerfStats.class);\n+  CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+  ExecutorService executor = mock(ExecutorService.class);\n+  RegionMap regionMap = mock(RegionMap.class);\n+  RegionEntry entry = mock(RegionEntry.class);\n+  DistributedRegion region = mock(DistributedRegion.class);\n+  VersionTag destroyedVersion = mock(VersionTag.class);\n+\n+  @Before\n+  public void setUp() throws Exception {}\n+\n+  @After\n+  public void tearDown() throws Exception {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73cd21ca3fadfd16e8154210464ebdce45229f74"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUzODk1Ng==", "bodyText": "Done", "url": "https://github.com/apache/geode/pull/5447#discussion_r469538956", "createdAt": "2020-08-12T20:50:55Z", "author": {"login": "mhansonp"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TombstoneServiceTest.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package org.apache.geode.internal.cache;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.concurrent.ExecutorService;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.distributed.internal.CacheTime;\n+import org.apache.geode.internal.cache.versions.RegionVersionVector;\n+import org.apache.geode.internal.cache.versions.VersionTag;\n+\n+public class TombstoneServiceTest {\n+  CacheTime cacheTime = mock(CacheTime.class);\n+  CachePerfStats stats = mock(CachePerfStats.class);\n+  CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+  ExecutorService executor = mock(ExecutorService.class);\n+  RegionMap regionMap = mock(RegionMap.class);\n+  RegionEntry entry = mock(RegionEntry.class);\n+  DistributedRegion region = mock(DistributedRegion.class);\n+  VersionTag destroyedVersion = mock(VersionTag.class);\n+\n+  @Before\n+  public void setUp() throws Exception {}\n+\n+  @After\n+  public void tearDown() throws Exception {}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ3MTc4MQ=="}, "originalCommit": {"oid": "73cd21ca3fadfd16e8154210464ebdce45229f74"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMzQ0NjM0OnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TombstoneServiceTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxODo1NToxNFrOG_uWOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMDo1MTowM1rOG_yYww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ3MjgyNg==", "bodyText": "The creation and assignment of the mocks should be moved to the setUp() method to ensure that fresh mocks are created for each test method and hence prevent multiple tests acting on the same instance of a mock and producing unexpected results.", "url": "https://github.com/apache/geode/pull/5447#discussion_r469472826", "createdAt": "2020-08-12T18:55:14Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TombstoneServiceTest.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package org.apache.geode.internal.cache;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.concurrent.ExecutorService;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.distributed.internal.CacheTime;\n+import org.apache.geode.internal.cache.versions.RegionVersionVector;\n+import org.apache.geode.internal.cache.versions.VersionTag;\n+\n+public class TombstoneServiceTest {\n+  CacheTime cacheTime = mock(CacheTime.class);\n+  CachePerfStats stats = mock(CachePerfStats.class);\n+  CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+  ExecutorService executor = mock(ExecutorService.class);\n+  RegionMap regionMap = mock(RegionMap.class);\n+  RegionEntry entry = mock(RegionEntry.class);\n+  DistributedRegion region = mock(DistributedRegion.class);\n+  VersionTag destroyedVersion = mock(VersionTag.class);\n+\n+  @Before\n+  public void setUp() throws Exception {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73cd21ca3fadfd16e8154210464ebdce45229f74"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUzOTAxMQ==", "bodyText": "Done", "url": "https://github.com/apache/geode/pull/5447#discussion_r469539011", "createdAt": "2020-08-12T20:51:03Z", "author": {"login": "mhansonp"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TombstoneServiceTest.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package org.apache.geode.internal.cache;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.concurrent.ExecutorService;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.distributed.internal.CacheTime;\n+import org.apache.geode.internal.cache.versions.RegionVersionVector;\n+import org.apache.geode.internal.cache.versions.VersionTag;\n+\n+public class TombstoneServiceTest {\n+  CacheTime cacheTime = mock(CacheTime.class);\n+  CachePerfStats stats = mock(CachePerfStats.class);\n+  CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+  ExecutorService executor = mock(ExecutorService.class);\n+  RegionMap regionMap = mock(RegionMap.class);\n+  RegionEntry entry = mock(RegionEntry.class);\n+  DistributedRegion region = mock(DistributedRegion.class);\n+  VersionTag destroyedVersion = mock(VersionTag.class);\n+\n+  @Before\n+  public void setUp() throws Exception {}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ3MjgyNg=="}, "originalCommit": {"oid": "73cd21ca3fadfd16e8154210464ebdce45229f74"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMzQ1ODEwOnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TombstoneServiceTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxODo1ODo1OFrOG_ueEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMToyMTo1M1rOG_zUiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ3NDgzMg==", "bodyText": "For these verifications, would it be reasonable to assert the specific number of invocations of getVersionVector() and recordGCVersion() we expect to see using Mockito.times(1) rather than just that it's at least one?", "url": "https://github.com/apache/geode/pull/5447#discussion_r469474832", "createdAt": "2020-08-12T18:58:58Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TombstoneServiceTest.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package org.apache.geode.internal.cache;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.concurrent.ExecutorService;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.distributed.internal.CacheTime;\n+import org.apache.geode.internal.cache.versions.RegionVersionVector;\n+import org.apache.geode.internal.cache.versions.VersionTag;\n+\n+public class TombstoneServiceTest {\n+  CacheTime cacheTime = mock(CacheTime.class);\n+  CachePerfStats stats = mock(CachePerfStats.class);\n+  CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+  ExecutorService executor = mock(ExecutorService.class);\n+  RegionMap regionMap = mock(RegionMap.class);\n+  RegionEntry entry = mock(RegionEntry.class);\n+  DistributedRegion region = mock(DistributedRegion.class);\n+  VersionTag destroyedVersion = mock(VersionTag.class);\n+\n+  @Before\n+  public void setUp() throws Exception {}\n+\n+  @After\n+  public void tearDown() throws Exception {}\n+\n+  @Test\n+  public void validateThatRemoveIsNotCalledOnTombstoneInRegionThatIsNotInitialized() {\n+\n+    when(region.isInitialized()).thenReturn(false);\n+    when(region.getRegionMap()).thenReturn(regionMap);\n+    TombstoneService.ReplicateTombstoneSweeper replicateTombstoneSweeper =\n+        new TombstoneService.ReplicateTombstoneSweeper(cacheTime, stats,\n+            cancelCriterion, executor);\n+    TombstoneService.Tombstone tombstone =\n+        new TombstoneService.Tombstone(entry, region, destroyedVersion);\n+    tombstone.entry = entry;\n+\n+    replicateTombstoneSweeper.expireTombstone(tombstone);\n+    replicateTombstoneSweeper.expireBatch();\n+    verify(regionMap, Mockito.never()).removeTombstone(tombstone.entry, destroyedVersion, false,\n+        true);\n+  }\n+\n+  @Test\n+  public void validateThatRemoveIsCalledOnTombstoneInRegionThatIsInitialized() {\n+    RegionVersionVector regionVersionVector = mock(RegionVersionVector.class);\n+\n+    when(region.isInitialized()).thenReturn(true);\n+    when(region.getRegionMap()).thenReturn(regionMap);\n+    when(region.getVersionVector()).thenReturn(regionVersionVector);\n+    when(region.getDataPolicy()).thenReturn(DataPolicy.PERSISTENT_REPLICATE);\n+    when(region.getDiskRegion()).thenReturn(mock(DiskRegion.class));\n+\n+    TombstoneService.ReplicateTombstoneSweeper replicateTombstoneSweeper =\n+        new TombstoneService.ReplicateTombstoneSweeper(cacheTime, stats,\n+            cancelCriterion, executor);\n+    TombstoneService.Tombstone tombstone =\n+        new TombstoneService.Tombstone(entry, region, destroyedVersion);\n+    tombstone.entry = entry;\n+\n+    replicateTombstoneSweeper.expireTombstone(tombstone);\n+    replicateTombstoneSweeper.expireBatch();\n+    verify(region, Mockito.atLeastOnce()).getVersionVector();\n+    verify(regionVersionVector, Mockito.atLeastOnce()).recordGCVersion(tombstone.getMemberID(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73cd21ca3fadfd16e8154210464ebdce45229f74"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU1NDMxMw==", "bodyText": "changed the code to actually check a call to removeTombstone which is what we really care about. Using times 1 now.", "url": "https://github.com/apache/geode/pull/5447#discussion_r469554313", "createdAt": "2020-08-12T21:21:53Z", "author": {"login": "mhansonp"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TombstoneServiceTest.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package org.apache.geode.internal.cache;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.concurrent.ExecutorService;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.distributed.internal.CacheTime;\n+import org.apache.geode.internal.cache.versions.RegionVersionVector;\n+import org.apache.geode.internal.cache.versions.VersionTag;\n+\n+public class TombstoneServiceTest {\n+  CacheTime cacheTime = mock(CacheTime.class);\n+  CachePerfStats stats = mock(CachePerfStats.class);\n+  CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+  ExecutorService executor = mock(ExecutorService.class);\n+  RegionMap regionMap = mock(RegionMap.class);\n+  RegionEntry entry = mock(RegionEntry.class);\n+  DistributedRegion region = mock(DistributedRegion.class);\n+  VersionTag destroyedVersion = mock(VersionTag.class);\n+\n+  @Before\n+  public void setUp() throws Exception {}\n+\n+  @After\n+  public void tearDown() throws Exception {}\n+\n+  @Test\n+  public void validateThatRemoveIsNotCalledOnTombstoneInRegionThatIsNotInitialized() {\n+\n+    when(region.isInitialized()).thenReturn(false);\n+    when(region.getRegionMap()).thenReturn(regionMap);\n+    TombstoneService.ReplicateTombstoneSweeper replicateTombstoneSweeper =\n+        new TombstoneService.ReplicateTombstoneSweeper(cacheTime, stats,\n+            cancelCriterion, executor);\n+    TombstoneService.Tombstone tombstone =\n+        new TombstoneService.Tombstone(entry, region, destroyedVersion);\n+    tombstone.entry = entry;\n+\n+    replicateTombstoneSweeper.expireTombstone(tombstone);\n+    replicateTombstoneSweeper.expireBatch();\n+    verify(regionMap, Mockito.never()).removeTombstone(tombstone.entry, destroyedVersion, false,\n+        true);\n+  }\n+\n+  @Test\n+  public void validateThatRemoveIsCalledOnTombstoneInRegionThatIsInitialized() {\n+    RegionVersionVector regionVersionVector = mock(RegionVersionVector.class);\n+\n+    when(region.isInitialized()).thenReturn(true);\n+    when(region.getRegionMap()).thenReturn(regionMap);\n+    when(region.getVersionVector()).thenReturn(regionVersionVector);\n+    when(region.getDataPolicy()).thenReturn(DataPolicy.PERSISTENT_REPLICATE);\n+    when(region.getDiskRegion()).thenReturn(mock(DiskRegion.class));\n+\n+    TombstoneService.ReplicateTombstoneSweeper replicateTombstoneSweeper =\n+        new TombstoneService.ReplicateTombstoneSweeper(cacheTime, stats,\n+            cancelCriterion, executor);\n+    TombstoneService.Tombstone tombstone =\n+        new TombstoneService.Tombstone(entry, region, destroyedVersion);\n+    tombstone.entry = entry;\n+\n+    replicateTombstoneSweeper.expireTombstone(tombstone);\n+    replicateTombstoneSweeper.expireBatch();\n+    verify(region, Mockito.atLeastOnce()).getVersionVector();\n+    verify(regionVersionVector, Mockito.atLeastOnce()).recordGCVersion(tombstone.getMemberID(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ3NDgzMg=="}, "originalCommit": {"oid": "73cd21ca3fadfd16e8154210464ebdce45229f74"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMzgyOTkzOnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TombstoneServiceTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMDo0MjoxNFrOG_yHcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMToyMzoxM1rOG_zWyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUzNDU3OA==", "bodyText": "please include the standard apache copyright header", "url": "https://github.com/apache/geode/pull/5447#discussion_r469534578", "createdAt": "2020-08-12T20:42:14Z", "author": {"login": "onichols-pivotal"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TombstoneServiceTest.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package org.apache.geode.internal.cache;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73cd21ca3fadfd16e8154210464ebdce45229f74"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU1NDg4OA==", "bodyText": "done.", "url": "https://github.com/apache/geode/pull/5447#discussion_r469554888", "createdAt": "2020-08-12T21:23:13Z", "author": {"login": "mhansonp"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TombstoneServiceTest.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package org.apache.geode.internal.cache;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUzNDU3OA=="}, "originalCommit": {"oid": "73cd21ca3fadfd16e8154210464ebdce45229f74"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNDE1NTM0OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/GIIDeltaDUnitTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMjozNToyN1rOG_1LTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMjozNToyN1rOG_1LTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU4NDcxNg==", "bodyText": "Does the comment above have to be updated?", "url": "https://github.com/apache/geode/pull/5447#discussion_r469584716", "createdAt": "2020-08-12T22:35:27Z", "author": {"login": "jchen21"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/GIIDeltaDUnitTest.java", "diffHunk": "@@ -497,7 +497,7 @@ public void run() {\n \n     // If fullGII, the key size in gii chunk is 3, i.e. key1,key3,key5. key2 is GCed.\n     // If delta GII, the key size should be 1 (key5(T) which is unfinished operation)\n-    verifyDeltaSizeFromStats(R, 3, 0);\n+    verifyDeltaSizeFromStats(R, 1, 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db8b7064d7fc1452b17ed986657cebc82cb5ea9d"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4727, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}