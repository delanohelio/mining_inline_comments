{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE2ODI5NTY1", "number": 5099, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QyMDowMTo1M1rOECTT1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QyMDowMTo1M1rOECTT1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwODQ4OTgyOnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/Oplog.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QyMDowMTo1M1rOGerXxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMTo1Nzo1OFrOGfrkYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgyMTA2Mw==", "bodyText": "This change comes into picture after the recovery is completed - \"initAfterRecovery\".\nThe real problem seems to be during recovery. If there is a periodic recovery this could be fine, but if there are large number of deleted records during the first recovery, the issue may still arise...We may need to have some checks during recovery (before reading the drfs) to avoid reading large deleted records. Please correct me if my understanding is wrong.\nAlso, looking at the other part of the code where \"setHasDeletes\" is called, it looks like it is called before the deleteDRF() - there could be a reason for doing this.\nAnd there is also call to \"getOplogSet().removeDrf(this);\" This may be needed here...", "url": "https://github.com/apache/geode/pull/5099#discussion_r434821063", "createdAt": "2020-06-03T20:01:53Z", "author": {"login": "agingade"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/Oplog.java", "diffHunk": "@@ -937,14 +937,21 @@ void initAfterRecovery(boolean offline) {\n         // this.crf.raf.seek(this.crf.currSize);\n       } else if (!offline) {\n         // drf exists but crf has been deleted (because it was empty).\n-        // I don't think the drf needs to be opened. It is only used during\n-        // recovery.\n-        // At some point the compacter my identify that it can be deleted.\n         this.crf.RAFClosed = true;\n         deleteCRF();\n+\n+        // See GEODE-8029.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96fb570ebf00181e8a2dc287c0497f7fadde1192"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIzNzk4Mg==", "bodyText": "This change comes into picture after the recovery is completed - \"initAfterRecovery\".\nThe real problem seems to be during recovery. If there is a periodic recovery this could be fine, but if there are large number of deleted records during the first recovery, the issue may still arise...We may need to have some checks during recovery (before reading the drfs) to avoid reading large deleted records. Please correct me if my understanding is wrong.\n\nYour understanding is correct, however, the change are to prevent the issue from happening in the first place. By deleting the unused drf files here and avoid storing them on disk when not needed, users won't hit the IllegalStateException at all.\nAs a side note, in order to hit the problem in the first place, the user would need to have more than 805306401 delete operations within the opLog files in one single run, and compaction should have not run at all, which is highly unlikely. Adding to that, when we record a delete operation within the drf file, we check whether the new drf size would be higher than the max configured size for the drf file, and roll to a new one afterwards. Considering that the drf file is 10% of the max-oplog-size, and that we use 10 bytes per DEL_ENTRY, to be able to hit the problem the max drf file should be higher than 8.5GB, meaning that the max-oplog-size should be configured, at least, to be 85GB (with no automatic compaction at all, which is something we don't recommend).\nIf you think we should add the count while reading the files instead and, somehow, expand the load factor when needed or something similar, let me know and I'll give it a try. I'm worried, though, about the performance impact this might have while recovering files from disk... the recovery time will suffer during every single startup and, considering that there's only a handful of scenarios on which the actual issue can happen, I believe making sure we delete unused files is a better approach.\n\nAlso, looking at the other part of the code where \"setHasDeletes\" is called, it looks like it is called before the deleteDRF() - there could be a reason for doing this.\n\nWill change this, thanks for catching it.\n\nAnd there is also call to \"getOplogSet().removeDrf(this);\" This may be needed here...\n\nThis is already done within the deleteDRF() method.\n\nPlease let me know what you think about point 1 (add an extra check while recovering to make sure we are below the load-factor threshold), so I can go ahead and make all the changes at once.", "url": "https://github.com/apache/geode/pull/5099#discussion_r435237982", "createdAt": "2020-06-04T13:07:01Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/Oplog.java", "diffHunk": "@@ -937,14 +937,21 @@ void initAfterRecovery(boolean offline) {\n         // this.crf.raf.seek(this.crf.currSize);\n       } else if (!offline) {\n         // drf exists but crf has been deleted (because it was empty).\n-        // I don't think the drf needs to be opened. It is only used during\n-        // recovery.\n-        // At some point the compacter my identify that it can be deleted.\n         this.crf.RAFClosed = true;\n         deleteCRF();\n+\n+        // See GEODE-8029.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgyMTA2Mw=="}, "originalCommit": {"oid": "96fb570ebf00181e8a2dc287c0497f7fadde1192"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU4MTAwOA==", "bodyText": "I am fine with the approach you have taken. Wanted to bring it up that there could be distinct possibility.\nLooks good to me.", "url": "https://github.com/apache/geode/pull/5099#discussion_r435581008", "createdAt": "2020-06-04T22:11:33Z", "author": {"login": "agingade"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/Oplog.java", "diffHunk": "@@ -937,14 +937,21 @@ void initAfterRecovery(boolean offline) {\n         // this.crf.raf.seek(this.crf.currSize);\n       } else if (!offline) {\n         // drf exists but crf has been deleted (because it was empty).\n-        // I don't think the drf needs to be opened. It is only used during\n-        // recovery.\n-        // At some point the compacter my identify that it can be deleted.\n         this.crf.RAFClosed = true;\n         deleteCRF();\n+\n+        // See GEODE-8029.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgyMTA2Mw=="}, "originalCommit": {"oid": "96fb570ebf00181e8a2dc287c0497f7fadde1192"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3Mjg2Ng==", "bodyText": "@agingade\nThanks, I've made the requested changes already and verified that no new regressions have been introduced due to the modifications, please go ahead and approve the PR (if there's nothing else you want me to change) so I can merge it \ud83d\udc4d.", "url": "https://github.com/apache/geode/pull/5099#discussion_r435872866", "createdAt": "2020-06-05T11:57:58Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/Oplog.java", "diffHunk": "@@ -937,14 +937,21 @@ void initAfterRecovery(boolean offline) {\n         // this.crf.raf.seek(this.crf.currSize);\n       } else if (!offline) {\n         // drf exists but crf has been deleted (because it was empty).\n-        // I don't think the drf needs to be opened. It is only used during\n-        // recovery.\n-        // At some point the compacter my identify that it can be deleted.\n         this.crf.RAFClosed = true;\n         deleteCRF();\n+\n+        // See GEODE-8029.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgyMTA2Mw=="}, "originalCommit": {"oid": "96fb570ebf00181e8a2dc287c0497f7fadde1192"}, "originalPosition": 10}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4036, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}