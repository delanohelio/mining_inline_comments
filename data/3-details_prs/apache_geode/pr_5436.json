{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY0Nzk1NDE4", "number": 5436, "title": "GEODE-7672: add dunit test to verify OQL index after PR clear.", "bodyText": "allow ClusterStartupRule to launch dunit default locator", "createdAt": "2020-08-07T20:07:50Z", "url": "https://github.com/apache/geode/pull/5436", "merged": true, "mergeCommit": {"oid": "e0e00bd6798d4aff8c34d4b64655f7c1c12e4db5"}, "closed": true, "closedAt": "2020-09-08T19:19:53Z", "author": {"login": "jinmeiliao"}, "timelineItems": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc9lFCRgBqjM2Mzk2MjM0MDg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdG6KrIAH2gAyNDY0Nzk1NDE4OjdiNmMxMzg2MDA5YWU4MWU0ZTFlY2ZlYmEzYmM2NTY1NmJjZWExMGY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5896a6b98344711bed9ac44db30c873fa4a4d013", "author": {"user": {"login": "jinmeiliao", "name": "Jinmei Liao"}}, "url": "https://github.com/apache/geode/commit/5896a6b98344711bed9ac44db30c873fa4a4d013", "committedDate": "2020-08-07T20:06:05Z", "message": "GEODE-7672: add dunit test to verify OQL index after PR clear."}, "afterCommit": {"oid": "93f9c52031f040de3ee0f5211dd64404e0157f29", "author": {"user": {"login": "jinmeiliao", "name": "Jinmei Liao"}}, "url": "https://github.com/apache/geode/commit/93f9c52031f040de3ee0f5211dd64404e0157f29", "committedDate": "2020-08-10T16:46:27Z", "message": "GEODE-7672: add dunit test to verify OQL index after PR clear."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1MzE5NjE1", "url": "https://github.com/apache/geode/pull/5436#pullrequestreview-465319615", "createdAt": "2020-08-11T18:24:24Z", "commit": {"oid": "93f9c52031f040de3ee0f5211dd64404e0157f29"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxODoyNDoyNFrOG_D8Tw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxODoyNzo1MFrOG_EDew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc3ODA2Mw==", "bodyText": "The assertions here could be executed before region.clear() in line 148, or even before the region is populated. There is no guarantee when the code block in invokeAsync is executed.", "url": "https://github.com/apache/geode/pull/5436#discussion_r468778063", "createdAt": "2020-08-11T18:24:24Z", "author": {"login": "jchen21"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/partitioned/PRClearQueryIndexDUnitTest.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.cache.query.partitioned;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.SERIALIZABLE_OBJECT_FILTER;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.client.ClientCache;\n+import org.apache.geode.cache.query.Index;\n+import org.apache.geode.cache.query.IndexStatistics;\n+import org.apache.geode.cache.query.Query;\n+import org.apache.geode.cache.query.QueryService;\n+import org.apache.geode.cache.query.SelectResults;\n+import org.apache.geode.cache.query.data.City;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.rules.ClientCacheRule;\n+\n+public class PRClearQueryIndexDUnitTest {\n+  public static final String MUMBAI_QUERY = \"select * from /cities c where c.name = 'MUMBAI'\";\n+  public static final String ID_10_QUERY = \"select * from /cities c where c.id = 10\";\n+  @ClassRule\n+  public static ClusterStartupRule cluster = new ClusterStartupRule(2, true);\n+\n+  private static MemberVM server1;\n+  private static MemberVM server2;\n+\n+  @Rule\n+  public ClientCacheRule clientCacheRule = new ClientCacheRule();\n+\n+  private ClientCache clientCache;\n+\n+  // class test setup. set up the servers, regions and indexes on the servers\n+  @BeforeClass\n+  public static void beforeClass() {\n+    int locatorPort = ClusterStartupRule.getDUnitLocatorPort();\n+    server1 = cluster.startServerVM(0, s -> s.withConnectionToLocator(locatorPort)\n+        .withProperty(SERIALIZABLE_OBJECT_FILTER, \"org.apache.geode.cache.query.data.*\")\n+        .withRegion(RegionShortcut.PARTITION, \"cities\"));\n+    server2 = cluster.startServerVM(1, s -> s.withConnectionToLocator(locatorPort)\n+        .withProperty(SERIALIZABLE_OBJECT_FILTER, \"org.apache.geode.cache.query.data.*\")\n+        .withRegion(RegionShortcut.PARTITION, \"cities\"));\n+\n+    server1.invoke(() -> {\n+      Cache cache = ClusterStartupRule.getCache();\n+      Region region = cache.getRegion(\"cities\");\n+      // create indexes\n+      QueryService queryService = cache.getQueryService();\n+      queryService.createKeyIndex(\"cityId\", \"c.id\", \"/cities c\");\n+      queryService.createIndex(\"cityName\", \"c.name\", \"/cities c\");\n+      assertThat(cache.getQueryService().getIndexes(region)).hasSize(2);\n+    });\n+\n+    server2.invoke(() -> {\n+      Cache cache = ClusterStartupRule.getCache();\n+      Region region = cache.getRegion(\"cities\");\n+      assertThat(cache.getQueryService().getIndexes(region)).hasSize(2);\n+    });\n+  }\n+\n+  // before every test method, create the client cache and region\n+  @Before\n+  public void before() throws Exception {\n+    int locatorPort = ClusterStartupRule.getDUnitLocatorPort();\n+    clientCache = clientCacheRule.withLocatorConnection(locatorPort).createCache();\n+  }\n+\n+  @Test\n+  public void verifyQuerySucceedsAfterClear() throws Exception {\n+    Region cities = clientCacheRule.createProxyRegion(\"cities\");\n+    // put in some data\n+    IntStream.range(0, 100).forEach(i -> cities.put(i, new City(i)));\n+\n+    MemberVM.invokeInEveryMember(() -> {\n+      InternalCache internalCache = ClusterStartupRule.getCache();\n+      Region region = internalCache.getRegion(\"cities\");\n+      assertThat(region.size()).isEqualTo(100);\n+    }, server1, server2);\n+\n+    QueryService queryService = clientCache.getQueryService();\n+    Query query = queryService.newQuery(MUMBAI_QUERY);\n+    Query query2 = queryService.newQuery(ID_10_QUERY);\n+    assertThat(((SelectResults) query.execute()).size()).isEqualTo(50);\n+    assertThat(((SelectResults) query2.execute()).size()).isEqualTo(1);\n+\n+    cities.clear();\n+    MemberVM.invokeInEveryMember(() -> {\n+      InternalCache internalCache = ClusterStartupRule.getCache();\n+      Region region = internalCache.getRegion(\"cities\");\n+      assertThat(region.size()).isEqualTo(0);\n+    }, server1, server2);\n+\n+    assertThat(((SelectResults) query.execute()).size()).isEqualTo(0);\n+    assertThat(((SelectResults) query2.execute()).size()).isEqualTo(0);\n+\n+    MemberVM.invokeInEveryMember(() -> {\n+      InternalCache internalCache = ClusterStartupRule.getCache();\n+      QueryService qs = internalCache.getQueryService();\n+      Region region = internalCache.getRegion(\"cities\");\n+      Index cityId = qs.getIndex(region, \"cityId\");\n+      IndexStatistics statistics = cityId.getStatistics();\n+      assertThat(statistics.getNumberOfKeys()).isEqualTo(0);\n+      assertThat(statistics.getNumberOfValues()).isEqualTo(0);\n+      Index cityName = qs.getIndex(region, \"cityName\");\n+      IndexStatistics statistics1 = cityName.getStatistics();\n+      assertThat(statistics1.getNumberOfKeys()).isEqualTo(0);\n+      assertThat(statistics1.getNumberOfValues()).isEqualTo(0);\n+    }, server1, server2);\n+  }\n+\n+  @Test\n+  public void concurrentClearAndQuery() {\n+    QueryService queryService = clientCache.getQueryService();\n+    Query query = queryService.newQuery(MUMBAI_QUERY);\n+    Query query2 = queryService.newQuery(ID_10_QUERY);\n+\n+    server1.invokeAsync(() -> {\n+      Cache cache = ClusterStartupRule.getCache();\n+      Region region = cache.getRegion(\"cities\");\n+      IntStream.range(0, 100).forEach(i -> region.put(i, new City(i)));\n+      region.clear();\n+    });\n+\n+    await().pollDelay(5, TimeUnit.MILLISECONDS).untilAsserted(() -> {\n+      assertThat(((SelectResults) query.execute()).size()).isEqualTo(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93f9c52031f040de3ee0f5211dd64404e0157f29"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc3OTg5OQ==", "bodyText": "The City class is defined in another package used by other tests. Any changes in City could potentially break the test. I would recommend using a class defined within the test itself. It is easier to maintain the code.", "url": "https://github.com/apache/geode/pull/5436#discussion_r468779899", "createdAt": "2020-08-11T18:27:50Z", "author": {"login": "jchen21"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/partitioned/PRClearQueryIndexDUnitTest.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.cache.query.partitioned;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.SERIALIZABLE_OBJECT_FILTER;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.client.ClientCache;\n+import org.apache.geode.cache.query.Index;\n+import org.apache.geode.cache.query.IndexStatistics;\n+import org.apache.geode.cache.query.Query;\n+import org.apache.geode.cache.query.QueryService;\n+import org.apache.geode.cache.query.SelectResults;\n+import org.apache.geode.cache.query.data.City;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.rules.ClientCacheRule;\n+\n+public class PRClearQueryIndexDUnitTest {\n+  public static final String MUMBAI_QUERY = \"select * from /cities c where c.name = 'MUMBAI'\";\n+  public static final String ID_10_QUERY = \"select * from /cities c where c.id = 10\";\n+  @ClassRule\n+  public static ClusterStartupRule cluster = new ClusterStartupRule(2, true);\n+\n+  private static MemberVM server1;\n+  private static MemberVM server2;\n+\n+  @Rule\n+  public ClientCacheRule clientCacheRule = new ClientCacheRule();\n+\n+  private ClientCache clientCache;\n+\n+  // class test setup. set up the servers, regions and indexes on the servers\n+  @BeforeClass\n+  public static void beforeClass() {\n+    int locatorPort = ClusterStartupRule.getDUnitLocatorPort();\n+    server1 = cluster.startServerVM(0, s -> s.withConnectionToLocator(locatorPort)\n+        .withProperty(SERIALIZABLE_OBJECT_FILTER, \"org.apache.geode.cache.query.data.*\")\n+        .withRegion(RegionShortcut.PARTITION, \"cities\"));\n+    server2 = cluster.startServerVM(1, s -> s.withConnectionToLocator(locatorPort)\n+        .withProperty(SERIALIZABLE_OBJECT_FILTER, \"org.apache.geode.cache.query.data.*\")\n+        .withRegion(RegionShortcut.PARTITION, \"cities\"));\n+\n+    server1.invoke(() -> {\n+      Cache cache = ClusterStartupRule.getCache();\n+      Region region = cache.getRegion(\"cities\");\n+      // create indexes\n+      QueryService queryService = cache.getQueryService();\n+      queryService.createKeyIndex(\"cityId\", \"c.id\", \"/cities c\");\n+      queryService.createIndex(\"cityName\", \"c.name\", \"/cities c\");\n+      assertThat(cache.getQueryService().getIndexes(region)).hasSize(2);\n+    });\n+\n+    server2.invoke(() -> {\n+      Cache cache = ClusterStartupRule.getCache();\n+      Region region = cache.getRegion(\"cities\");\n+      assertThat(cache.getQueryService().getIndexes(region)).hasSize(2);\n+    });\n+  }\n+\n+  // before every test method, create the client cache and region\n+  @Before\n+  public void before() throws Exception {\n+    int locatorPort = ClusterStartupRule.getDUnitLocatorPort();\n+    clientCache = clientCacheRule.withLocatorConnection(locatorPort).createCache();\n+  }\n+\n+  @Test\n+  public void verifyQuerySucceedsAfterClear() throws Exception {\n+    Region cities = clientCacheRule.createProxyRegion(\"cities\");\n+    // put in some data\n+    IntStream.range(0, 100).forEach(i -> cities.put(i, new City(i)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93f9c52031f040de3ee0f5211dd64404e0157f29"}, "originalPosition": 99}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c54c8588262ac1529e70e2048a757c3e1158b84a", "author": {"user": {"login": "jinmeiliao", "name": "Jinmei Liao"}}, "url": "https://github.com/apache/geode/commit/c54c8588262ac1529e70e2048a757c3e1158b84a", "committedDate": "2020-08-13T19:42:47Z", "message": "add more tests"}, "afterCommit": {"oid": "fbe8a5a7129831117054ed71e3d78772bcc0e51f", "author": {"user": {"login": "jinmeiliao", "name": "Jinmei Liao"}}, "url": "https://github.com/apache/geode/commit/fbe8a5a7129831117054ed71e3d78772bcc0e51f", "committedDate": "2020-08-14T17:02:30Z", "message": "add more tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "92e865d66f4f0814455b4549afa792326e55d0ac", "author": {"user": {"login": "jinmeiliao", "name": "Jinmei Liao"}}, "url": "https://github.com/apache/geode/commit/92e865d66f4f0814455b4549afa792326e55d0ac", "committedDate": "2020-08-19T16:10:34Z", "message": "fix test"}, "afterCommit": {"oid": "9a93507ef6c793b4d17a832baedf43f259f505d8", "author": {"user": {"login": "jinmeiliao", "name": "Jinmei Liao"}}, "url": "https://github.com/apache/geode/commit/9a93507ef6c793b4d17a832baedf43f259f505d8", "committedDate": "2020-08-19T20:02:29Z", "message": "fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ddd0524390ec774065bbda52274155bd06d2a45", "author": {"user": {"login": "jinmeiliao", "name": "Jinmei Liao"}}, "url": "https://github.com/apache/geode/commit/0ddd0524390ec774065bbda52274155bd06d2a45", "committedDate": "2020-08-24T17:57:22Z", "message": "GEODE-7672: add dunit test to verify OQL index after PR clear."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "425f11a5292417688e7a7ce74bfad01ff4aadcac", "author": {"user": {"login": "jinmeiliao", "name": "Jinmei Liao"}}, "url": "https://github.com/apache/geode/commit/425f11a5292417688e7a7ce74bfad01ff4aadcac", "committedDate": "2020-08-24T17:57:22Z", "message": "add more tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17c124402a8c283813eb09fd97683ad5160fcfd8", "author": {"user": {"login": "jinmeiliao", "name": "Jinmei Liao"}}, "url": "https://github.com/apache/geode/commit/17c124402a8c283813eb09fd97683ad5160fcfd8", "committedDate": "2020-08-24T17:57:22Z", "message": "add more tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1030a19b8d64150bee192e111152bdad238b48a9", "author": {"user": {"login": "jinmeiliao", "name": "Jinmei Liao"}}, "url": "https://github.com/apache/geode/commit/1030a19b8d64150bee192e111152bdad238b48a9", "committedDate": "2020-08-24T17:57:22Z", "message": "fix test"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "69944353718a3b3e3f21779f46e52aed313d6746", "author": {"user": {"login": "jinmeiliao", "name": "Jinmei Liao"}}, "url": "https://github.com/apache/geode/commit/69944353718a3b3e3f21779f46e52aed313d6746", "committedDate": "2020-08-19T20:32:43Z", "message": "logging"}, "afterCommit": {"oid": "61ba94aac374984c813f102c304f825f907fcc31", "author": {"user": {"login": "jinmeiliao", "name": "Jinmei Liao"}}, "url": "https://github.com/apache/geode/commit/61ba94aac374984c813f102c304f825f907fcc31", "committedDate": "2020-08-25T23:08:38Z", "message": "require rvv lock when create index"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1MDY0MDcy", "url": "https://github.com/apache/geode/pull/5436#pullrequestreview-475064072", "createdAt": "2020-08-26T00:03:10Z", "commit": {"oid": "61ba94aac374984c813f102c304f825f907fcc31"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwMDowMzoxMFrOHGzPUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwMDowMzoxMFrOHGzPUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njg5MzAxMA==", "bodyText": "I am not sure I understand the purpose of this test. Depends on the thread scheduling, the query result size could be non-zero. e.g. if the query is executed after populating the region, but before clearing the region.\nThe test result is non-deterministic. This test is flaky.", "url": "https://github.com/apache/geode/pull/5436#discussion_r476893010", "createdAt": "2020-08-26T00:03:10Z", "author": {"login": "jchen21"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/partitioned/PRClearQueryIndexDUnitTest.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.cache.query.partitioned;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.SERIALIZABLE_OBJECT_FILTER;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.client.ClientCache;\n+import org.apache.geode.cache.query.Index;\n+import org.apache.geode.cache.query.IndexStatistics;\n+import org.apache.geode.cache.query.Query;\n+import org.apache.geode.cache.query.QueryService;\n+import org.apache.geode.cache.query.SelectResults;\n+import org.apache.geode.cache.query.data.City;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.rules.ClientCacheRule;\n+\n+public class PRClearQueryIndexDUnitTest {\n+  public static final String MUMBAI_QUERY = \"select * from /cities c where c.name = 'MUMBAI'\";\n+  public static final String ID_10_QUERY = \"select * from /cities c where c.id = 10\";\n+  @ClassRule\n+  public static ClusterStartupRule cluster = new ClusterStartupRule(2, true);\n+\n+  private static MemberVM server1;\n+  private static MemberVM server2;\n+\n+  @Rule\n+  public ClientCacheRule clientCacheRule = new ClientCacheRule();\n+\n+  private ClientCache clientCache;\n+\n+  // class test setup. set up the servers, regions and indexes on the servers\n+  @BeforeClass\n+  public static void beforeClass() {\n+    int locatorPort = ClusterStartupRule.getDUnitLocatorPort();\n+    server1 = cluster.startServerVM(0, s -> s.withConnectionToLocator(locatorPort)\n+        .withProperty(SERIALIZABLE_OBJECT_FILTER, \"org.apache.geode.cache.query.data.*\")\n+        .withRegion(RegionShortcut.PARTITION, \"cities\"));\n+    server2 = cluster.startServerVM(1, s -> s.withConnectionToLocator(locatorPort)\n+        .withProperty(SERIALIZABLE_OBJECT_FILTER, \"org.apache.geode.cache.query.data.*\")\n+        .withRegion(RegionShortcut.PARTITION, \"cities\"));\n+\n+    server1.invoke(() -> {\n+      Cache cache = ClusterStartupRule.getCache();\n+      Region region = cache.getRegion(\"cities\");\n+      // create indexes\n+      QueryService queryService = cache.getQueryService();\n+      queryService.createKeyIndex(\"cityId\", \"c.id\", \"/cities c\");\n+      queryService.createIndex(\"cityName\", \"c.name\", \"/cities c\");\n+      assertThat(cache.getQueryService().getIndexes(region)).hasSize(2);\n+    });\n+\n+    server2.invoke(() -> {\n+      Cache cache = ClusterStartupRule.getCache();\n+      Region region = cache.getRegion(\"cities\");\n+      assertThat(cache.getQueryService().getIndexes(region)).hasSize(2);\n+    });\n+  }\n+\n+  // before every test method, create the client cache and region\n+  @Before\n+  public void before() throws Exception {\n+    int locatorPort = ClusterStartupRule.getDUnitLocatorPort();\n+    clientCache = clientCacheRule.withLocatorConnection(locatorPort).createCache();\n+  }\n+\n+  @Test\n+  public void verifyQuerySucceedsAfterClear() throws Exception {\n+    Region cities = clientCacheRule.createProxyRegion(\"cities\");\n+    // put in some data\n+    IntStream.range(0, 100).forEach(i -> cities.put(i, new City(i)));\n+\n+    MemberVM.invokeInEveryMember(() -> {\n+      InternalCache internalCache = ClusterStartupRule.getCache();\n+      Region region = internalCache.getRegion(\"cities\");\n+      assertThat(region.size()).isEqualTo(100);\n+    }, server1, server2);\n+\n+    QueryService queryService = clientCache.getQueryService();\n+    Query query = queryService.newQuery(MUMBAI_QUERY);\n+    Query query2 = queryService.newQuery(ID_10_QUERY);\n+    assertThat(((SelectResults) query.execute()).size()).isEqualTo(50);\n+    assertThat(((SelectResults) query2.execute()).size()).isEqualTo(1);\n+\n+    cities.clear();\n+    MemberVM.invokeInEveryMember(() -> {\n+      InternalCache internalCache = ClusterStartupRule.getCache();\n+      Region region = internalCache.getRegion(\"cities\");\n+      assertThat(region.size()).isEqualTo(0);\n+    }, server1, server2);\n+\n+    assertThat(((SelectResults) query.execute()).size()).isEqualTo(0);\n+    assertThat(((SelectResults) query2.execute()).size()).isEqualTo(0);\n+\n+    MemberVM.invokeInEveryMember(() -> {\n+      InternalCache internalCache = ClusterStartupRule.getCache();\n+      QueryService qs = internalCache.getQueryService();\n+      Region region = internalCache.getRegion(\"cities\");\n+      Index cityId = qs.getIndex(region, \"cityId\");\n+      IndexStatistics statistics = cityId.getStatistics();\n+      assertThat(statistics.getNumberOfKeys()).isEqualTo(0);\n+      assertThat(statistics.getNumberOfValues()).isEqualTo(0);\n+      Index cityName = qs.getIndex(region, \"cityName\");\n+      IndexStatistics statistics1 = cityName.getStatistics();\n+      assertThat(statistics1.getNumberOfKeys()).isEqualTo(0);\n+      assertThat(statistics1.getNumberOfValues()).isEqualTo(0);\n+    }, server1, server2);\n+  }\n+\n+  @Test\n+  public void concurrentClearAndQuery() {\n+    QueryService queryService = clientCache.getQueryService();\n+    Query query = queryService.newQuery(MUMBAI_QUERY);\n+    Query query2 = queryService.newQuery(ID_10_QUERY);\n+\n+    server1.invokeAsync(() -> {\n+      Cache cache = ClusterStartupRule.getCache();\n+      Region region = cache.getRegion(\"cities\");\n+      IntStream.range(0, 100).forEach(i -> region.put(i, new City(i)));\n+      region.clear();\n+    });\n+\n+    await().pollDelay(5, TimeUnit.MILLISECONDS).untilAsserted(() -> {\n+      assertThat(((SelectResults) query.execute()).size()).isEqualTo(0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc3ODA2Mw=="}, "originalCommit": {"oid": "93f9c52031f040de3ee0f5211dd64404e0157f29"}, "originalPosition": 152}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "937f2a0896e156e3576f938a5f4725183456404b", "author": {"user": {"login": "jinmeiliao", "name": "Jinmei Liao"}}, "url": "https://github.com/apache/geode/commit/937f2a0896e156e3576f938a5f4725183456404b", "committedDate": "2020-08-26T17:35:38Z", "message": "require rvv lock when create index"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "61ba94aac374984c813f102c304f825f907fcc31", "author": {"user": {"login": "jinmeiliao", "name": "Jinmei Liao"}}, "url": "https://github.com/apache/geode/commit/61ba94aac374984c813f102c304f825f907fcc31", "committedDate": "2020-08-25T23:08:38Z", "message": "require rvv lock when create index"}, "afterCommit": {"oid": "937f2a0896e156e3576f938a5f4725183456404b", "author": {"user": {"login": "jinmeiliao", "name": "Jinmei Liao"}}, "url": "https://github.com/apache/geode/commit/937f2a0896e156e3576f938a5f4725183456404b", "committedDate": "2020-08-26T17:35:38Z", "message": "require rvv lock when create index"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0704603954db5c26f3522d9c79b4083208c7e801", "author": {"user": {"login": "jinmeiliao", "name": "Jinmei Liao"}}, "url": "https://github.com/apache/geode/commit/0704603954db5c26f3522d9c79b4083208c7e801", "committedDate": "2020-08-26T18:04:48Z", "message": "review change"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2MDk3ODEx", "url": "https://github.com/apache/geode/pull/5436#pullrequestreview-476097811", "createdAt": "2020-08-26T23:27:07Z", "commit": {"oid": "0704603954db5c26f3522d9c79b4083208c7e801"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2MTA5OTg0", "url": "https://github.com/apache/geode/pull/5436#pullrequestreview-476109984", "createdAt": "2020-08-26T23:31:53Z", "commit": {"oid": "0704603954db5c26f3522d9c79b4083208c7e801"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3MDA3Mzcw", "url": "https://github.com/apache/geode/pull/5436#pullrequestreview-477007370", "createdAt": "2020-08-27T19:12:29Z", "commit": {"oid": "0704603954db5c26f3522d9c79b4083208c7e801"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxOToxMjoyOVrOHIdvDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxOTozMzo0OFrOHIeajA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYzNzgzNg==", "bodyText": "Another most commonly used index is range index; which gets created when multiple iterators are used in index expression, can you please add that one into the test.\nqs.createIndex(\"sIndex\", \"pos.secId\",\n\"portfolio.values val, val.positions.values pos\");", "url": "https://github.com/apache/geode/pull/5436#discussion_r478637836", "createdAt": "2020-08-27T19:12:29Z", "author": {"login": "agingade"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/partitioned/PRClearQueryIndexDUnitTest.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.cache.query.partitioned;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.SERIALIZABLE_OBJECT_FILTER;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.junit.rules.VMProvider.invokeInEveryMember;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.client.ClientCache;\n+import org.apache.geode.cache.client.ServerOperationException;\n+import org.apache.geode.cache.query.Index;\n+import org.apache.geode.cache.query.IndexStatistics;\n+import org.apache.geode.cache.query.Query;\n+import org.apache.geode.cache.query.QueryService;\n+import org.apache.geode.cache.query.SelectResults;\n+import org.apache.geode.cache.query.data.City;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.DUnitBlackboard;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.rules.ClientCacheRule;\n+import org.apache.geode.test.junit.rules.ExecutorServiceRule;\n+\n+public class PRClearQueryIndexDUnitTest {\n+  public static final String MUMBAI_QUERY = \"select * from /cities c where c.name = 'MUMBAI'\";\n+  public static final String ID_10_QUERY = \"select * from /cities c where c.id = 10\";\n+  @ClassRule\n+  public static ClusterStartupRule cluster = new ClusterStartupRule(4, true);\n+\n+  private static MemberVM server1;\n+  private static MemberVM server2;\n+\n+  private static DUnitBlackboard blackboard;\n+\n+  @Rule\n+  public ClientCacheRule clientCacheRule = new ClientCacheRule();\n+\n+  @Rule\n+  public ExecutorServiceRule executor = ExecutorServiceRule.builder().build();\n+\n+  private ClientCache clientCache;\n+  private Region cities;\n+\n+  // class test setup. set up the servers, regions and indexes on the servers\n+  @BeforeClass\n+  public static void beforeClass() {\n+    int locatorPort = ClusterStartupRule.getDUnitLocatorPort();\n+    server1 = cluster.startServerVM(1, s -> s.withConnectionToLocator(locatorPort)\n+        .withProperty(SERIALIZABLE_OBJECT_FILTER, \"org.apache.geode.cache.query.data.*\")\n+        .withRegion(RegionShortcut.PARTITION, \"cities\"));\n+    server2 = cluster.startServerVM(2, s -> s.withConnectionToLocator(locatorPort)\n+        .withProperty(SERIALIZABLE_OBJECT_FILTER, \"org.apache.geode.cache.query.data.*\")\n+        .withRegion(RegionShortcut.PARTITION, \"cities\"));\n+\n+    server1.invoke(() -> {\n+      Cache cache = ClusterStartupRule.getCache();\n+      Region region = cache.getRegion(\"cities\");\n+      // create indexes\n+      QueryService queryService = cache.getQueryService();\n+      queryService.createKeyIndex(\"cityId\", \"c.id\", \"/cities c\");\n+      queryService.createIndex(\"cityName\", \"c.name\", \"/cities c\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0704603954db5c26f3522d9c79b4083208c7e801"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY0MjExNw==", "bodyText": "If the idea is to get clear and index to be happening parallel, this may not guarantee that. There is a IndexManager.testHook that can be used to control index creation. And having more entries will help chances of occurring clear and create-index in parallel.", "url": "https://github.com/apache/geode/pull/5436#discussion_r478642117", "createdAt": "2020-08-27T19:20:28Z", "author": {"login": "agingade"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/partitioned/PRClearQueryIndexDUnitTest.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.cache.query.partitioned;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.SERIALIZABLE_OBJECT_FILTER;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.junit.rules.VMProvider.invokeInEveryMember;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.client.ClientCache;\n+import org.apache.geode.cache.client.ServerOperationException;\n+import org.apache.geode.cache.query.Index;\n+import org.apache.geode.cache.query.IndexStatistics;\n+import org.apache.geode.cache.query.Query;\n+import org.apache.geode.cache.query.QueryService;\n+import org.apache.geode.cache.query.SelectResults;\n+import org.apache.geode.cache.query.data.City;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.DUnitBlackboard;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.rules.ClientCacheRule;\n+import org.apache.geode.test.junit.rules.ExecutorServiceRule;\n+\n+public class PRClearQueryIndexDUnitTest {\n+  public static final String MUMBAI_QUERY = \"select * from /cities c where c.name = 'MUMBAI'\";\n+  public static final String ID_10_QUERY = \"select * from /cities c where c.id = 10\";\n+  @ClassRule\n+  public static ClusterStartupRule cluster = new ClusterStartupRule(4, true);\n+\n+  private static MemberVM server1;\n+  private static MemberVM server2;\n+\n+  private static DUnitBlackboard blackboard;\n+\n+  @Rule\n+  public ClientCacheRule clientCacheRule = new ClientCacheRule();\n+\n+  @Rule\n+  public ExecutorServiceRule executor = ExecutorServiceRule.builder().build();\n+\n+  private ClientCache clientCache;\n+  private Region cities;\n+\n+  // class test setup. set up the servers, regions and indexes on the servers\n+  @BeforeClass\n+  public static void beforeClass() {\n+    int locatorPort = ClusterStartupRule.getDUnitLocatorPort();\n+    server1 = cluster.startServerVM(1, s -> s.withConnectionToLocator(locatorPort)\n+        .withProperty(SERIALIZABLE_OBJECT_FILTER, \"org.apache.geode.cache.query.data.*\")\n+        .withRegion(RegionShortcut.PARTITION, \"cities\"));\n+    server2 = cluster.startServerVM(2, s -> s.withConnectionToLocator(locatorPort)\n+        .withProperty(SERIALIZABLE_OBJECT_FILTER, \"org.apache.geode.cache.query.data.*\")\n+        .withRegion(RegionShortcut.PARTITION, \"cities\"));\n+\n+    server1.invoke(() -> {\n+      Cache cache = ClusterStartupRule.getCache();\n+      Region region = cache.getRegion(\"cities\");\n+      // create indexes\n+      QueryService queryService = cache.getQueryService();\n+      queryService.createKeyIndex(\"cityId\", \"c.id\", \"/cities c\");\n+      queryService.createIndex(\"cityName\", \"c.name\", \"/cities c\");\n+      assertThat(cache.getQueryService().getIndexes(region))\n+          .extracting(Index::getName).containsExactlyInAnyOrder(\"cityId\", \"cityName\");\n+    });\n+\n+    server2.invoke(() -> {\n+      Cache cache = ClusterStartupRule.getCache();\n+      Region region = cache.getRegion(\"cities\");\n+      assertThat(cache.getQueryService().getIndexes(region))\n+          .extracting(Index::getName).containsExactlyInAnyOrder(\"cityId\", \"cityName\");\n+    });\n+  }\n+\n+  // before every test method, create the client cache and region\n+  @Before\n+  public void before() throws Exception {\n+    int locatorPort = ClusterStartupRule.getDUnitLocatorPort();\n+    clientCache = clientCacheRule.withLocatorConnection(locatorPort).createCache();\n+    cities = clientCacheRule.createProxyRegion(\"cities\");\n+  }\n+\n+  @Test\n+  public void clearOnEmptyRegion() throws Exception {\n+    cities.clear();\n+    invokeInEveryMember(() -> {\n+      verifyIndexesAfterClear();\n+    }, server1, server2);\n+\n+    IntStream.range(0, 10).forEach(i -> cities.put(i, new City(i)));\n+    cities.clear();\n+    invokeInEveryMember(() -> {\n+      verifyIndexesAfterClear();\n+    }, server1, server2);\n+  }\n+\n+  @Test\n+  public void createIndexWhileClear() throws Exception {\n+    IntStream.range(0, 100).forEach(i -> cities.put(i, new City(i)));\n+\n+    // create index while clear\n+    AsyncInvocation createIndex = server1.invokeAsync(\"create index\", () -> {\n+      Cache cache = ClusterStartupRule.getCache();\n+      QueryService queryService = cache.getQueryService();\n+      Index cityZip = queryService.createIndex(\"cityZip\", \"c.zip\", \"/cities c\");\n+      assertThat(cityZip).isNotNull();\n+    });\n+\n+    // do clear at the same time\n+    cities.clear();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0704603954db5c26f3522d9c79b4083208c7e801"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY0ODk3Mg==", "bodyText": "This is a way to see how many entries are there in index. With this we need to make sure the query has used index.\nAlong with that it will be nice to validate the index storage size: it could be done by calling  isEmpty() on Index class or using the index stats (as done in other places in this test)", "url": "https://github.com/apache/geode/pull/5436#discussion_r478648972", "createdAt": "2020-08-27T19:33:48Z", "author": {"login": "agingade"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/partitioned/PRClearQueryIndexDUnitTest.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.cache.query.partitioned;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.SERIALIZABLE_OBJECT_FILTER;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.junit.rules.VMProvider.invokeInEveryMember;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.client.ClientCache;\n+import org.apache.geode.cache.client.ServerOperationException;\n+import org.apache.geode.cache.query.Index;\n+import org.apache.geode.cache.query.IndexStatistics;\n+import org.apache.geode.cache.query.Query;\n+import org.apache.geode.cache.query.QueryService;\n+import org.apache.geode.cache.query.SelectResults;\n+import org.apache.geode.cache.query.data.City;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.DUnitBlackboard;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.rules.ClientCacheRule;\n+import org.apache.geode.test.junit.rules.ExecutorServiceRule;\n+\n+public class PRClearQueryIndexDUnitTest {\n+  public static final String MUMBAI_QUERY = \"select * from /cities c where c.name = 'MUMBAI'\";\n+  public static final String ID_10_QUERY = \"select * from /cities c where c.id = 10\";\n+  @ClassRule\n+  public static ClusterStartupRule cluster = new ClusterStartupRule(4, true);\n+\n+  private static MemberVM server1;\n+  private static MemberVM server2;\n+\n+  private static DUnitBlackboard blackboard;\n+\n+  @Rule\n+  public ClientCacheRule clientCacheRule = new ClientCacheRule();\n+\n+  @Rule\n+  public ExecutorServiceRule executor = ExecutorServiceRule.builder().build();\n+\n+  private ClientCache clientCache;\n+  private Region cities;\n+\n+  // class test setup. set up the servers, regions and indexes on the servers\n+  @BeforeClass\n+  public static void beforeClass() {\n+    int locatorPort = ClusterStartupRule.getDUnitLocatorPort();\n+    server1 = cluster.startServerVM(1, s -> s.withConnectionToLocator(locatorPort)\n+        .withProperty(SERIALIZABLE_OBJECT_FILTER, \"org.apache.geode.cache.query.data.*\")\n+        .withRegion(RegionShortcut.PARTITION, \"cities\"));\n+    server2 = cluster.startServerVM(2, s -> s.withConnectionToLocator(locatorPort)\n+        .withProperty(SERIALIZABLE_OBJECT_FILTER, \"org.apache.geode.cache.query.data.*\")\n+        .withRegion(RegionShortcut.PARTITION, \"cities\"));\n+\n+    server1.invoke(() -> {\n+      Cache cache = ClusterStartupRule.getCache();\n+      Region region = cache.getRegion(\"cities\");\n+      // create indexes\n+      QueryService queryService = cache.getQueryService();\n+      queryService.createKeyIndex(\"cityId\", \"c.id\", \"/cities c\");\n+      queryService.createIndex(\"cityName\", \"c.name\", \"/cities c\");\n+      assertThat(cache.getQueryService().getIndexes(region))\n+          .extracting(Index::getName).containsExactlyInAnyOrder(\"cityId\", \"cityName\");\n+    });\n+\n+    server2.invoke(() -> {\n+      Cache cache = ClusterStartupRule.getCache();\n+      Region region = cache.getRegion(\"cities\");\n+      assertThat(cache.getQueryService().getIndexes(region))\n+          .extracting(Index::getName).containsExactlyInAnyOrder(\"cityId\", \"cityName\");\n+    });\n+  }\n+\n+  // before every test method, create the client cache and region\n+  @Before\n+  public void before() throws Exception {\n+    int locatorPort = ClusterStartupRule.getDUnitLocatorPort();\n+    clientCache = clientCacheRule.withLocatorConnection(locatorPort).createCache();\n+    cities = clientCacheRule.createProxyRegion(\"cities\");\n+  }\n+\n+  @Test\n+  public void clearOnEmptyRegion() throws Exception {\n+    cities.clear();\n+    invokeInEveryMember(() -> {\n+      verifyIndexesAfterClear();\n+    }, server1, server2);\n+\n+    IntStream.range(0, 10).forEach(i -> cities.put(i, new City(i)));\n+    cities.clear();\n+    invokeInEveryMember(() -> {\n+      verifyIndexesAfterClear();\n+    }, server1, server2);\n+  }\n+\n+  @Test\n+  public void createIndexWhileClear() throws Exception {\n+    IntStream.range(0, 100).forEach(i -> cities.put(i, new City(i)));\n+\n+    // create index while clear\n+    AsyncInvocation createIndex = server1.invokeAsync(\"create index\", () -> {\n+      Cache cache = ClusterStartupRule.getCache();\n+      QueryService queryService = cache.getQueryService();\n+      Index cityZip = queryService.createIndex(\"cityZip\", \"c.zip\", \"/cities c\");\n+      assertThat(cityZip).isNotNull();\n+    });\n+\n+    // do clear at the same time\n+    cities.clear();\n+    createIndex.await();\n+\n+    invokeInEveryMember(() -> {\n+      verifyIndexesAfterClear();\n+    }, server1, server2);\n+\n+    QueryService queryService = clientCache.getQueryService();\n+    Query query =\n+        queryService.newQuery(\"select * from /cities c where c.zip < \" + (City.ZIP_START + 10));\n+    assertThat(((SelectResults) query.execute()).size()).isEqualTo(0);\n+\n+    IntStream.range(0, 10).forEach(i -> cities.put(i, new City(i)));\n+    assertThat(((SelectResults) query.execute()).size()).isEqualTo(10);\n+  }\n+\n+  @Test\n+  public void createIndexWhileClearOnReplicateRegion() throws Exception {\n+    invokeInEveryMember(() -> {\n+      Cache cache = ClusterStartupRule.getCache();\n+      cache.createRegionFactory(RegionShortcut.PARTITION)\n+          .create(\"replicateCities\");\n+    }, server1, server2);\n+\n+    Region replicateCities = clientCacheRule.createProxyRegion(\"replicateCities\");\n+    IntStream.range(0, 100).forEach(i -> replicateCities.put(i, new City(i)));\n+\n+    // create index while clear\n+    AsyncInvocation createIndex = server1.invokeAsync(\"create index on replicate regions\", () -> {\n+      Cache cache = ClusterStartupRule.getCache();\n+      QueryService queryService = cache.getQueryService();\n+      Index cityZip = queryService.createIndex(\"cityZip_replicate\", \"c.zip\", \"/replicateCities c\");\n+      assertThat(cityZip).isNotNull();\n+    });\n+\n+    // do clear at the same time\n+    replicateCities.clear();\n+    createIndex.await();\n+\n+    QueryService queryService = clientCache.getQueryService();\n+    Query query =\n+        queryService\n+            .newQuery(\"select * from /replicateCities c where c.zip < \" + (City.ZIP_START + 10));\n+    assertThat(((SelectResults) query.execute()).size()).isEqualTo(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0704603954db5c26f3522d9c79b4083208c7e801"}, "originalPosition": 181}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "129bcaace870e95741357ea58541a589f5684f2d", "author": {"user": {"login": "jinmeiliao", "name": "Jinmei Liao"}}, "url": "https://github.com/apache/geode/commit/129bcaace870e95741357ea58541a589f5684f2d", "committedDate": "2020-08-28T15:39:20Z", "message": "review updates"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwMTkyMzU5", "url": "https://github.com/apache/geode/pull/5436#pullrequestreview-480192359", "createdAt": "2020-09-01T23:55:02Z", "commit": {"oid": "129bcaace870e95741357ea58541a589f5684f2d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwMTk1Njg1", "url": "https://github.com/apache/geode/pull/5436#pullrequestreview-480195685", "createdAt": "2020-09-02T00:05:12Z", "commit": {"oid": "129bcaace870e95741357ea58541a589f5684f2d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwMDowNToxMlrOHLMURw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwMDowNToxMlrOHLMURw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ5ODE4Mw==", "bodyText": "The asserts here should probably be await.untilAsserted's. Judging from the DUnit failure.", "url": "https://github.com/apache/geode/pull/5436#discussion_r481498183", "createdAt": "2020-09-02T00:05:12Z", "author": {"login": "mhansonp"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/partitioned/PRClearQueryIndexDUnitTest.java", "diffHunk": "@@ -0,0 +1,374 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.cache.query.partitioned;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.SERIALIZABLE_OBJECT_FILTER;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.junit.rules.VMProvider.invokeInEveryMember;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.client.ClientCache;\n+import org.apache.geode.cache.client.ServerOperationException;\n+import org.apache.geode.cache.query.Index;\n+import org.apache.geode.cache.query.IndexStatistics;\n+import org.apache.geode.cache.query.Query;\n+import org.apache.geode.cache.query.QueryService;\n+import org.apache.geode.cache.query.SelectResults;\n+import org.apache.geode.cache.query.data.City;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.DUnitBlackboard;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.rules.ClientCacheRule;\n+import org.apache.geode.test.junit.rules.ExecutorServiceRule;\n+\n+public class PRClearQueryIndexDUnitTest {\n+  public static final String MUMBAI_QUERY = \"select * from /cities c where c.name = 'MUMBAI'\";\n+  public static final String ID_10_QUERY = \"select * from /cities c where c.id = 10\";\n+  @ClassRule\n+  public static ClusterStartupRule cluster = new ClusterStartupRule(4, true);\n+\n+  private static MemberVM server1;\n+  private static MemberVM server2;\n+\n+  private static DUnitBlackboard blackboard;\n+\n+  @Rule\n+  public ClientCacheRule clientCacheRule = new ClientCacheRule();\n+\n+  @Rule\n+  public ExecutorServiceRule executor = ExecutorServiceRule.builder().build();\n+\n+  private ClientCache clientCache;\n+  private Region cities;\n+\n+  // class test setup. set up the servers, regions and indexes on the servers\n+  @BeforeClass\n+  public static void beforeClass() {\n+    int locatorPort = ClusterStartupRule.getDUnitLocatorPort();\n+    server1 = cluster.startServerVM(1, s -> s.withConnectionToLocator(locatorPort)\n+        .withProperty(SERIALIZABLE_OBJECT_FILTER, \"org.apache.geode.cache.query.data.*\")\n+        .withRegion(RegionShortcut.PARTITION, \"cities\"));\n+    server2 = cluster.startServerVM(2, s -> s.withConnectionToLocator(locatorPort)\n+        .withProperty(SERIALIZABLE_OBJECT_FILTER, \"org.apache.geode.cache.query.data.*\")\n+        .withRegion(RegionShortcut.PARTITION, \"cities\"));\n+\n+    server1.invoke(() -> {\n+      Cache cache = ClusterStartupRule.getCache();\n+      Region region = cache.getRegion(\"cities\");\n+      // create indexes\n+      QueryService queryService = cache.getQueryService();\n+      queryService.createKeyIndex(\"cityId\", \"c.id\", \"/cities c\");\n+      queryService.createIndex(\"cityName\", \"c.name\", \"/cities c\");\n+      assertThat(cache.getQueryService().getIndexes(region))\n+          .extracting(Index::getName).containsExactlyInAnyOrder(\"cityId\", \"cityName\");\n+    });\n+\n+    server2.invoke(() -> {\n+      Cache cache = ClusterStartupRule.getCache();\n+      Region region = cache.getRegion(\"cities\");\n+      assertThat(cache.getQueryService().getIndexes(region))\n+          .extracting(Index::getName).containsExactlyInAnyOrder(\"cityId\", \"cityName\");\n+    });\n+  }\n+\n+  // before every test method, create the client cache and region\n+  @Before\n+  public void before() throws Exception {\n+    int locatorPort = ClusterStartupRule.getDUnitLocatorPort();\n+    clientCache = clientCacheRule.withLocatorConnection(locatorPort).createCache();\n+    cities = clientCacheRule.createProxyRegion(\"cities\");\n+  }\n+\n+  @Test\n+  public void clearOnEmptyRegion() throws Exception {\n+    cities.clear();\n+    invokeInEveryMember(() -> {\n+      verifyIndexesAfterClear(\"cities\", \"cityId\", \"cityName\");\n+    }, server1, server2);\n+\n+    IntStream.range(0, 10).forEach(i -> cities.put(i, new City(i)));\n+    cities.clear();\n+    invokeInEveryMember(() -> {\n+      verifyIndexesAfterClear(\"cities\", \"cityId\", \"cityName\");\n+    }, server1, server2);\n+  }\n+\n+  @Test\n+  public void createIndexWhileClear() throws Exception {\n+    IntStream.range(0, 1000).forEach(i -> cities.put(i, new City(i)));\n+\n+    // create index while clear\n+    AsyncInvocation createIndex = server1.invokeAsync(\"create index\", () -> {\n+      Cache cache = ClusterStartupRule.getCache();\n+      QueryService queryService = cache.getQueryService();\n+      Index cityZip = queryService.createIndex(\"cityZip\", \"c.zip\", \"/cities c\");\n+      assertThat(cityZip).isNotNull();\n+    });\n+\n+    // do clear for 3 times at the same time to increease the concurrency of clear and createIndex\n+    for (int i = 0; i < 3; i++) {\n+      cities.clear();\n+    }\n+    createIndex.await();\n+\n+    invokeInEveryMember(() -> {\n+      verifyIndexesAfterClear(\"cities\", \"cityId\", \"cityName\");\n+    }, server1, server2);\n+\n+    QueryService queryService = clientCache.getQueryService();\n+    Query query =\n+        queryService.newQuery(\"select * from /cities c where c.zip < \" + (City.ZIP_START + 10));\n+    assertThat(((SelectResults) query.execute()).size()).isEqualTo(0);\n+\n+    IntStream.range(0, 10).forEach(i -> cities.put(i, new City(i)));\n+    assertThat(((SelectResults) query.execute()).size()).isEqualTo(10);\n+  }\n+\n+  @Test\n+  public void createIndexWhileClearOnReplicateRegion() throws Exception {\n+    invokeInEveryMember(() -> {\n+      Cache cache = ClusterStartupRule.getCache();\n+      cache.createRegionFactory(RegionShortcut.PARTITION)\n+          .create(\"replicateCities\");\n+    }, server1, server2);\n+\n+    Region replicateCities = clientCacheRule.createProxyRegion(\"replicateCities\");\n+    IntStream.range(0, 1000).forEach(i -> replicateCities.put(i, new City(i)));\n+\n+    // create index while clear\n+    AsyncInvocation createIndex = server1.invokeAsync(\"create index on replicate regions\", () -> {\n+      Cache cache = ClusterStartupRule.getCache();\n+      QueryService queryService = cache.getQueryService();\n+      Index cityZip = queryService.createIndex(\"cityZip_replicate\", \"c.zip\", \"/replicateCities c\");\n+      assertThat(cityZip).isNotNull();\n+    });\n+\n+    // do clear at the same time for 3 timese\n+    for (int i = 0; i < 3; i++) {\n+      replicateCities.clear();\n+    }\n+    createIndex.await();\n+\n+    invokeInEveryMember(() -> {\n+      verifyIndexesAfterClear(\"replicateCities\", \"cityZip_replicate\");\n+    }, server1, server2);\n+\n+    QueryService queryService = clientCache.getQueryService();\n+    Query query =\n+        queryService\n+            .newQuery(\"select * from /replicateCities c where c.zip < \" + (City.ZIP_START + 10));\n+    assertThat(((SelectResults) query.execute()).size()).isEqualTo(0);\n+\n+    IntStream.range(0, 10).forEach(i -> replicateCities.put(i, new City(i)));\n+    assertThat(((SelectResults) query.execute()).size()).isEqualTo(10);\n+  }\n+\n+  @Test\n+  public void removeIndexWhileClear() throws Exception {\n+    // create cityZip index\n+    server1.invoke(\"create index\", () -> {\n+      Cache cache = ClusterStartupRule.getCache();\n+      QueryService queryService = cache.getQueryService();\n+      Index cityZip = queryService.createIndex(\"cityZip\", \"c.zip\", \"/cities c\");\n+      assertThat(cityZip).isNotNull();\n+    });\n+\n+    // remove index while clear\n+    // removeIndex has to be invoked on each server. It's not distributed\n+    AsyncInvocation removeIndex1 = server1.invokeAsync(\"remove index\",\n+        PRClearQueryIndexDUnitTest::removeCityZipIndex);\n+    AsyncInvocation removeIndex2 = server2.invokeAsync(\"remove index\",\n+        PRClearQueryIndexDUnitTest::removeCityZipIndex);\n+\n+    cities.clear();\n+    removeIndex1.await();\n+    removeIndex2.await();\n+\n+    // make sure removeIndex and clear operations are successful\n+    invokeInEveryMember(() -> {\n+      InternalCache internalCache = ClusterStartupRule.getCache();\n+      QueryService qs = internalCache.getQueryService();\n+      Region region = internalCache.getRegion(\"cities\");\n+      assertThat(region.size()).isEqualTo(0);\n+      // verify only 2 indexes created in the beginning of the tests exist\n+      assertThat(qs.getIndexes(region)).extracting(Index::getName)\n+          .containsExactlyInAnyOrder(\"cityId\", \"cityName\");\n+    }, server1, server2);\n+  }\n+\n+  private static void removeCityZipIndex() {\n+    Cache cache = ClusterStartupRule.getCache();\n+    QueryService qs = cache.getQueryService();\n+    Region<Object, Object> region = cache.getRegion(\"cities\");\n+    Index cityZip = qs.getIndex(region, \"cityZip\");\n+    if (cityZip != null) {\n+      qs.removeIndex(cityZip);\n+    }\n+  }\n+\n+  @Test\n+  public void verifyQuerySucceedsAfterClear() throws Exception {\n+    // put in some data\n+    IntStream.range(0, 100).forEach(i -> cities.put(i, new City(i)));\n+\n+    QueryService queryService = clientCache.getQueryService();\n+    Query query = queryService.newQuery(MUMBAI_QUERY);\n+    Query query2 = queryService.newQuery(ID_10_QUERY);\n+    assertThat(((SelectResults) query.execute()).size()).isEqualTo(50);\n+    assertThat(((SelectResults) query2.execute()).size()).isEqualTo(1);\n+\n+    cities.clear();\n+    invokeInEveryMember(() -> {\n+      verifyIndexesAfterClear(\"cities\", \"cityId\", \"cityName\");\n+    }, server1, server2);\n+\n+    assertThat(((SelectResults) query.execute()).size()).isEqualTo(0);\n+    assertThat(((SelectResults) query2.execute()).size()).isEqualTo(0);\n+  }\n+\n+  private static void verifyIndexesAfterClear(String regionName, String... indexes) {\n+    InternalCache internalCache = ClusterStartupRule.getCache();\n+    QueryService qs = internalCache.getQueryService();\n+    Region region = internalCache.getRegion(regionName);\n+    assertThat(region.size()).isEqualTo(0);\n+    for (String indexName : indexes) {\n+      Index index = qs.getIndex(region, indexName);\n+      IndexStatistics statistics = index.getStatistics();\n+      assertThat(statistics.getNumberOfKeys()).isEqualTo(0);\n+      assertThat(statistics.getNumberOfValues()).isEqualTo(0);\n+    }\n+  }\n+\n+  @Test\n+  public void concurrentClearAndQuery() {\n+    QueryService queryService = clientCache.getQueryService();\n+    Query query = queryService.newQuery(MUMBAI_QUERY);\n+    Query query2 = queryService.newQuery(ID_10_QUERY);\n+\n+    IntStream.range(0, 100).forEach(i -> cities.put(i, new City(i)));\n+\n+    server1.invokeAsync(() -> {\n+      Cache cache = ClusterStartupRule.getCache();\n+      Region region = cache.getRegion(\"cities\");\n+      region.clear();\n+    });\n+\n+    await().untilAsserted(() -> {\n+      assertThat(((SelectResults) query.execute()).size()).isEqualTo(0);\n+      assertThat(((SelectResults) query2.execute()).size()).isEqualTo(0);\n+    });\n+  }\n+\n+  @Test\n+  public void concurrentClearAndPut() throws Exception {\n+    AsyncInvocation puts = server1.invokeAsync(() -> {\n+      Cache cache = ClusterStartupRule.getCache();\n+      Region region = cache.getRegion(\"cities\");\n+      for (int i = 0; i < 1000; i++) {\n+        // wait for gate to open\n+        getBlackboard().waitForGate(\"proceedToPut\", 60, TimeUnit.SECONDS);\n+        region.put(i, new City(i));\n+      }\n+    });\n+\n+    AsyncInvocation clears = server2.invokeAsync(() -> {\n+      Cache cache = ClusterStartupRule.getCache();\n+      Region region = cache.getRegion(\"cities\");\n+      // do clear 10 times\n+      for (int i = 0; i < 10; i++) {\n+        try {\n+          // don't allow put to proceed. It's like \"close the gate\"\n+          getBlackboard().clearGate(\"proceedToPut\");\n+          region.clear();\n+          verifyIndexesAfterClear(\"cities\", \"cityId\", \"cityName\");\n+        } finally {\n+          // allow put to proceed. It's like \"open the gate\"\n+          getBlackboard().signalGate(\"proceedToPut\");\n+        }\n+      }\n+    });\n+\n+    puts.await();\n+    clears.await();\n+  }\n+\n+  @Test\n+  public void serverLeavingAndJoiningWhilePutAndClear() throws Exception {\n+    int locatorPort = ClusterStartupRule.getDUnitLocatorPort();\n+    Future<Void> startStopServer = executor.submit(() -> {\n+      for (int i = 0; i < 3; i++) {\n+        MemberVM server3 = cluster.startServerVM(3, s -> s.withConnectionToLocator(locatorPort)\n+            .withProperty(SERIALIZABLE_OBJECT_FILTER, \"org.apache.geode.cache.query.data.*\")\n+            .withRegion(RegionShortcut.PARTITION, \"cities\"));\n+        server3.stop(false);\n+      }\n+    });\n+\n+    Future<Void> putAndClear = executor.submit(() -> {\n+      for (int i = 0; i < 30; i++) {\n+        IntStream.range(0, 100).forEach(j -> cities.put(j, new City(j)));\n+        try {\n+          cities.clear();\n+        } catch (ServerOperationException e) {\n+          assertThat(e.getCause().getMessage())\n+              .contains(\"Unable to clear all the buckets from the partitioned region cities\")\n+              .contains(\"either data (buckets) moved or member departed\");\n+        }\n+        QueryService queryService = clientCache.getQueryService();\n+        Query query = queryService.newQuery(MUMBAI_QUERY);\n+        Query query2 = queryService.newQuery(ID_10_QUERY);\n+        assertThat(((SelectResults) query.execute()).size()).isEqualTo(0);\n+        assertThat(((SelectResults) query2.execute()).size()).isEqualTo(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "129bcaace870e95741357ea58541a589f5684f2d"}, "originalPosition": 350}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwMTk2NTA5", "url": "https://github.com/apache/geode/pull/5436#pullrequestreview-480196509", "createdAt": "2020-09-02T00:07:40Z", "commit": {"oid": "129bcaace870e95741357ea58541a589f5684f2d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwMDowNzo0MVrOHLMXEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwMDowNzo0MVrOHLMXEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ5ODg5OQ==", "bodyText": "Would this be better as an await.untilAsserted?", "url": "https://github.com/apache/geode/pull/5436#discussion_r481498899", "createdAt": "2020-09-02T00:07:41Z", "author": {"login": "mhansonp"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/query/partitioned/PRClearQueryIndexDUnitTest.java", "diffHunk": "@@ -0,0 +1,374 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.cache.query.partitioned;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.SERIALIZABLE_OBJECT_FILTER;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.junit.rules.VMProvider.invokeInEveryMember;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.client.ClientCache;\n+import org.apache.geode.cache.client.ServerOperationException;\n+import org.apache.geode.cache.query.Index;\n+import org.apache.geode.cache.query.IndexStatistics;\n+import org.apache.geode.cache.query.Query;\n+import org.apache.geode.cache.query.QueryService;\n+import org.apache.geode.cache.query.SelectResults;\n+import org.apache.geode.cache.query.data.City;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.DUnitBlackboard;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.rules.ClientCacheRule;\n+import org.apache.geode.test.junit.rules.ExecutorServiceRule;\n+\n+public class PRClearQueryIndexDUnitTest {\n+  public static final String MUMBAI_QUERY = \"select * from /cities c where c.name = 'MUMBAI'\";\n+  public static final String ID_10_QUERY = \"select * from /cities c where c.id = 10\";\n+  @ClassRule\n+  public static ClusterStartupRule cluster = new ClusterStartupRule(4, true);\n+\n+  private static MemberVM server1;\n+  private static MemberVM server2;\n+\n+  private static DUnitBlackboard blackboard;\n+\n+  @Rule\n+  public ClientCacheRule clientCacheRule = new ClientCacheRule();\n+\n+  @Rule\n+  public ExecutorServiceRule executor = ExecutorServiceRule.builder().build();\n+\n+  private ClientCache clientCache;\n+  private Region cities;\n+\n+  // class test setup. set up the servers, regions and indexes on the servers\n+  @BeforeClass\n+  public static void beforeClass() {\n+    int locatorPort = ClusterStartupRule.getDUnitLocatorPort();\n+    server1 = cluster.startServerVM(1, s -> s.withConnectionToLocator(locatorPort)\n+        .withProperty(SERIALIZABLE_OBJECT_FILTER, \"org.apache.geode.cache.query.data.*\")\n+        .withRegion(RegionShortcut.PARTITION, \"cities\"));\n+    server2 = cluster.startServerVM(2, s -> s.withConnectionToLocator(locatorPort)\n+        .withProperty(SERIALIZABLE_OBJECT_FILTER, \"org.apache.geode.cache.query.data.*\")\n+        .withRegion(RegionShortcut.PARTITION, \"cities\"));\n+\n+    server1.invoke(() -> {\n+      Cache cache = ClusterStartupRule.getCache();\n+      Region region = cache.getRegion(\"cities\");\n+      // create indexes\n+      QueryService queryService = cache.getQueryService();\n+      queryService.createKeyIndex(\"cityId\", \"c.id\", \"/cities c\");\n+      queryService.createIndex(\"cityName\", \"c.name\", \"/cities c\");\n+      assertThat(cache.getQueryService().getIndexes(region))\n+          .extracting(Index::getName).containsExactlyInAnyOrder(\"cityId\", \"cityName\");\n+    });\n+\n+    server2.invoke(() -> {\n+      Cache cache = ClusterStartupRule.getCache();\n+      Region region = cache.getRegion(\"cities\");\n+      assertThat(cache.getQueryService().getIndexes(region))\n+          .extracting(Index::getName).containsExactlyInAnyOrder(\"cityId\", \"cityName\");\n+    });\n+  }\n+\n+  // before every test method, create the client cache and region\n+  @Before\n+  public void before() throws Exception {\n+    int locatorPort = ClusterStartupRule.getDUnitLocatorPort();\n+    clientCache = clientCacheRule.withLocatorConnection(locatorPort).createCache();\n+    cities = clientCacheRule.createProxyRegion(\"cities\");\n+  }\n+\n+  @Test\n+  public void clearOnEmptyRegion() throws Exception {\n+    cities.clear();\n+    invokeInEveryMember(() -> {\n+      verifyIndexesAfterClear(\"cities\", \"cityId\", \"cityName\");\n+    }, server1, server2);\n+\n+    IntStream.range(0, 10).forEach(i -> cities.put(i, new City(i)));\n+    cities.clear();\n+    invokeInEveryMember(() -> {\n+      verifyIndexesAfterClear(\"cities\", \"cityId\", \"cityName\");\n+    }, server1, server2);\n+  }\n+\n+  @Test\n+  public void createIndexWhileClear() throws Exception {\n+    IntStream.range(0, 1000).forEach(i -> cities.put(i, new City(i)));\n+\n+    // create index while clear\n+    AsyncInvocation createIndex = server1.invokeAsync(\"create index\", () -> {\n+      Cache cache = ClusterStartupRule.getCache();\n+      QueryService queryService = cache.getQueryService();\n+      Index cityZip = queryService.createIndex(\"cityZip\", \"c.zip\", \"/cities c\");\n+      assertThat(cityZip).isNotNull();\n+    });\n+\n+    // do clear for 3 times at the same time to increease the concurrency of clear and createIndex\n+    for (int i = 0; i < 3; i++) {\n+      cities.clear();\n+    }\n+    createIndex.await();\n+\n+    invokeInEveryMember(() -> {\n+      verifyIndexesAfterClear(\"cities\", \"cityId\", \"cityName\");\n+    }, server1, server2);\n+\n+    QueryService queryService = clientCache.getQueryService();\n+    Query query =\n+        queryService.newQuery(\"select * from /cities c where c.zip < \" + (City.ZIP_START + 10));\n+    assertThat(((SelectResults) query.execute()).size()).isEqualTo(0);\n+\n+    IntStream.range(0, 10).forEach(i -> cities.put(i, new City(i)));\n+    assertThat(((SelectResults) query.execute()).size()).isEqualTo(10);\n+  }\n+\n+  @Test\n+  public void createIndexWhileClearOnReplicateRegion() throws Exception {\n+    invokeInEveryMember(() -> {\n+      Cache cache = ClusterStartupRule.getCache();\n+      cache.createRegionFactory(RegionShortcut.PARTITION)\n+          .create(\"replicateCities\");\n+    }, server1, server2);\n+\n+    Region replicateCities = clientCacheRule.createProxyRegion(\"replicateCities\");\n+    IntStream.range(0, 1000).forEach(i -> replicateCities.put(i, new City(i)));\n+\n+    // create index while clear\n+    AsyncInvocation createIndex = server1.invokeAsync(\"create index on replicate regions\", () -> {\n+      Cache cache = ClusterStartupRule.getCache();\n+      QueryService queryService = cache.getQueryService();\n+      Index cityZip = queryService.createIndex(\"cityZip_replicate\", \"c.zip\", \"/replicateCities c\");\n+      assertThat(cityZip).isNotNull();\n+    });\n+\n+    // do clear at the same time for 3 timese\n+    for (int i = 0; i < 3; i++) {\n+      replicateCities.clear();\n+    }\n+    createIndex.await();\n+\n+    invokeInEveryMember(() -> {\n+      verifyIndexesAfterClear(\"replicateCities\", \"cityZip_replicate\");\n+    }, server1, server2);\n+\n+    QueryService queryService = clientCache.getQueryService();\n+    Query query =\n+        queryService\n+            .newQuery(\"select * from /replicateCities c where c.zip < \" + (City.ZIP_START + 10));\n+    assertThat(((SelectResults) query.execute()).size()).isEqualTo(0);\n+\n+    IntStream.range(0, 10).forEach(i -> replicateCities.put(i, new City(i)));\n+    assertThat(((SelectResults) query.execute()).size()).isEqualTo(10);\n+  }\n+\n+  @Test\n+  public void removeIndexWhileClear() throws Exception {\n+    // create cityZip index\n+    server1.invoke(\"create index\", () -> {\n+      Cache cache = ClusterStartupRule.getCache();\n+      QueryService queryService = cache.getQueryService();\n+      Index cityZip = queryService.createIndex(\"cityZip\", \"c.zip\", \"/cities c\");\n+      assertThat(cityZip).isNotNull();\n+    });\n+\n+    // remove index while clear\n+    // removeIndex has to be invoked on each server. It's not distributed\n+    AsyncInvocation removeIndex1 = server1.invokeAsync(\"remove index\",\n+        PRClearQueryIndexDUnitTest::removeCityZipIndex);\n+    AsyncInvocation removeIndex2 = server2.invokeAsync(\"remove index\",\n+        PRClearQueryIndexDUnitTest::removeCityZipIndex);\n+\n+    cities.clear();\n+    removeIndex1.await();\n+    removeIndex2.await();\n+\n+    // make sure removeIndex and clear operations are successful\n+    invokeInEveryMember(() -> {\n+      InternalCache internalCache = ClusterStartupRule.getCache();\n+      QueryService qs = internalCache.getQueryService();\n+      Region region = internalCache.getRegion(\"cities\");\n+      assertThat(region.size()).isEqualTo(0);\n+      // verify only 2 indexes created in the beginning of the tests exist\n+      assertThat(qs.getIndexes(region)).extracting(Index::getName)\n+          .containsExactlyInAnyOrder(\"cityId\", \"cityName\");\n+    }, server1, server2);\n+  }\n+\n+  private static void removeCityZipIndex() {\n+    Cache cache = ClusterStartupRule.getCache();\n+    QueryService qs = cache.getQueryService();\n+    Region<Object, Object> region = cache.getRegion(\"cities\");\n+    Index cityZip = qs.getIndex(region, \"cityZip\");\n+    if (cityZip != null) {\n+      qs.removeIndex(cityZip);\n+    }\n+  }\n+\n+  @Test\n+  public void verifyQuerySucceedsAfterClear() throws Exception {\n+    // put in some data\n+    IntStream.range(0, 100).forEach(i -> cities.put(i, new City(i)));\n+\n+    QueryService queryService = clientCache.getQueryService();\n+    Query query = queryService.newQuery(MUMBAI_QUERY);\n+    Query query2 = queryService.newQuery(ID_10_QUERY);\n+    assertThat(((SelectResults) query.execute()).size()).isEqualTo(50);\n+    assertThat(((SelectResults) query2.execute()).size()).isEqualTo(1);\n+\n+    cities.clear();\n+    invokeInEveryMember(() -> {\n+      verifyIndexesAfterClear(\"cities\", \"cityId\", \"cityName\");\n+    }, server1, server2);\n+\n+    assertThat(((SelectResults) query.execute()).size()).isEqualTo(0);\n+    assertThat(((SelectResults) query2.execute()).size()).isEqualTo(0);\n+  }\n+\n+  private static void verifyIndexesAfterClear(String regionName, String... indexes) {\n+    InternalCache internalCache = ClusterStartupRule.getCache();\n+    QueryService qs = internalCache.getQueryService();\n+    Region region = internalCache.getRegion(regionName);\n+    assertThat(region.size()).isEqualTo(0);\n+    for (String indexName : indexes) {\n+      Index index = qs.getIndex(region, indexName);\n+      IndexStatistics statistics = index.getStatistics();\n+      assertThat(statistics.getNumberOfKeys()).isEqualTo(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "129bcaace870e95741357ea58541a589f5684f2d"}, "originalPosition": 266}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b6c1386009ae81e4e1ecfeba3bc65656bcea10f", "author": {"user": {"login": "jinmeiliao", "name": "Jinmei Liao"}}, "url": "https://github.com/apache/geode/commit/7b6c1386009ae81e4e1ecfeba3bc65656bcea10f", "committedDate": "2020-09-08T16:26:56Z", "message": "fix test"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4271, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}