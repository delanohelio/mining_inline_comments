{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA5MzAwOTg0", "number": 5667, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMjoyODozNFrOEylCfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMjoyODozNFrOEylCfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDcxMTAyOnYy", "diffSide": "RIGHT", "path": "geode-dunit/src/distributedTest/java/org/apache/geode/test/dunit/rules/tests/DistributedMapTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMjoyODozNFrOHpTWfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMjoyODozNFrOHpTWfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA3MDcxNw==", "bodyText": "Might it be worth extracting the hardcoded string keys/values in this test class to constants?", "url": "https://github.com/apache/geode/pull/5667#discussion_r513070717", "createdAt": "2020-10-27T22:28:34Z", "author": {"login": "DonalEvans"}, "path": "geode-dunit/src/distributedTest/java/org/apache/geode/test/dunit/rules/tests/DistributedMapTest.java", "diffHunk": "@@ -491,4 +495,162 @@ public void getReturnsSameValueInEveryVmAsPutInOtherVm() {\n       });\n     }\n   }\n+\n+  @Test\n+  public void accessesDistributedMapInEachVm() {\n+    runTestWithValidation(HasDistributedMap.class);\n+  }\n+\n+  @Test\n+  public void tearsDownDistributedMapInEachVm() {\n+    runTestWithValidation(HasDistributedMap.class);\n+\n+    getController().invoke(() -> {\n+      assertThat(HasDistributedMap.map.get()).isEmpty();\n+    });\n+  }\n+\n+  @Test\n+  public void accessesTwoDistributedMapsInEachVm() {\n+    runTestWithValidation(HasTwoDistributedMaps.class);\n+  }\n+\n+  @Test\n+  public void tearsDownTwoDistributedMapsInEachVm() {\n+    runTestWithValidation(HasTwoDistributedMaps.class);\n+\n+    getController().invoke(() -> {\n+      assertThat(HasTwoDistributedMaps.map1.get()).isEmpty();\n+      assertThat(HasTwoDistributedMaps.map2.get()).isEmpty();\n+    });\n+  }\n+\n+  @Test\n+  public void accessesManyDistributedMapsInEachVm() {\n+    runTestWithValidation(HasManyDistributedMaps.class);\n+  }\n+\n+  @Test\n+  public void tearsDownManyDistributedMapsInEachVm() {\n+    runTestWithValidation(HasManyDistributedMaps.class);\n+\n+    getController().invoke(() -> {\n+      assertThat(HasManyDistributedMaps.map1.get()).isEmpty();\n+      assertThat(HasManyDistributedMaps.map2.get()).isEmpty();\n+      assertThat(HasManyDistributedMaps.map3.get()).isEmpty();\n+    });\n+  }\n+\n+  public static class HasDistributedMap implements Serializable {\n+\n+    private static final AtomicReference<Map<Object, Object>> map = new AtomicReference<>();\n+\n+    @Rule\n+    public DistributedMap<Object, Object> distributedMap = new DistributedMap<>();\n+\n+    @Before\n+    public void setUp() {\n+      getController().invoke(() -> {\n+        map.set(distributedMap.map());\n+        distributedMap.put(\"key1\", \"value1\");\n+      });\n+    }\n+\n+    @Test\n+    public void distributedMapIsAccessibleInEveryVm() {\n+      for (VM vm : asList(getVM(0), getVM(1), getVM(2), getVM(3), getController())) {\n+        vm.invoke(() -> {\n+          assertThat(distributedMap.map()).isSameAs(map.get());\n+          assertThat(distributedMap.get(\"key1\")).isEqualTo(\"value1\");\n+        });\n+      }\n+    }\n+  }\n+\n+  public static class HasTwoDistributedMaps implements Serializable {\n+\n+    private static final AtomicReference<Map<Object, Object>> map1 = new AtomicReference<>();\n+    private static final AtomicReference<Map<Object, Object>> map2 = new AtomicReference<>();\n+\n+    @Rule\n+    public DistributedMap<Object, Object> distributedMap1 = new DistributedMap<>();\n+    @Rule\n+    public DistributedMap<Object, Object> distributedMap2 = new DistributedMap<>();\n+\n+    @Before\n+    public void setUp() {\n+      getController().invoke(() -> {\n+        map1.set(distributedMap1.map());\n+        distributedMap1.put(\"key1\", \"value1\");\n+\n+        map2.set(distributedMap2.map());\n+        distributedMap2.put(\"key2\", \"value2\");\n+      });\n+    }\n+\n+    @Test\n+    public void twoDistributedMapsAreAccessibleInEveryVm() {\n+      for (VM vm : asList(getVM(0), getVM(1), getVM(2), getVM(3), getController())) {\n+        vm.invoke(() -> {\n+          assertThat(distributedMap1.map()).isSameAs(map1.get());\n+          assertThat(distributedMap1.get(\"key1\")).isEqualTo(\"value1\");\n+          assertThat(distributedMap1.get(\"key2\")).isNull();\n+\n+          assertThat(distributedMap2.map()).isSameAs(map2.get());\n+          assertThat(distributedMap2.get(\"key1\")).isNull();\n+          assertThat(distributedMap2.get(\"key2\")).isEqualTo(\"value2\");\n+        });\n+      }\n+    }\n+  }\n+\n+  public static class HasManyDistributedMaps implements Serializable {\n+\n+    private static final AtomicReference<Map<Object, Object>> map1 = new AtomicReference<>();\n+    private static final AtomicReference<Map<Object, Object>> map2 = new AtomicReference<>();\n+    private static final AtomicReference<Map<Object, Object>> map3 = new AtomicReference<>();\n+\n+    @Rule\n+    public DistributedMap<Object, Object> distributedMap1 = new DistributedMap<>();\n+    @Rule\n+    public DistributedMap<Object, Object> distributedMap2 = new DistributedMap<>();\n+    @Rule\n+    public DistributedMap<Object, Object> distributedMap3 = new DistributedMap<>();\n+\n+    @Before\n+    public void setUp() {\n+      getController().invoke(() -> {\n+        map1.set(distributedMap1.map());\n+        distributedMap1.put(\"key1\", \"value1\");\n+\n+        map2.set(distributedMap2.map());\n+        distributedMap2.put(\"key2\", \"value2\");\n+\n+        map3.set(distributedMap3.map());\n+        distributedMap3.put(\"key3\", \"value3\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8591490eed0ca4fee90f05a1815aee785753616"}, "originalPosition": 169}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4585, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}