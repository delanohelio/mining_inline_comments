{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc2NTE4NDE5", "number": 5490, "title": "GEODE-8467: server fails to notify of a ForcedDisconnect and fails to tear down the cache", "bodyText": "Catch exceptions that occur during XML generation and disable auto\nreconnect.\nEnsure that the DisconnectThread is launched by placing it in a\n\"finally\" block.\n@kamilla1201 @Bill\nThank you for submitting a contribution to Apache Geode.\nIn order to streamline the review of the contribution we ask you\nto ensure the following steps have been taken:\nFor all changes:\n\n\n Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?\n\n\n Has your PR been rebased against the latest commit within the target branch (typically develop)?\n\n\n Is your initial contribution a single, squashed commit?\n\n\n Does gradlew build run cleanly?\n\n\n Have you written or updated unit tests to verify your changes?\n\n\n If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under ASF 2.0?\n\n\nNote:\nPlease ensure that once the PR is submitted, check Concourse for build issues and\nsubmit an update to your PR as soon as possible. If you need help, please send an\nemail to dev@geode.apache.org.", "createdAt": "2020-08-31T20:18:37Z", "url": "https://github.com/apache/geode/pull/5490", "merged": true, "mergeCommit": {"oid": "e402ed35102a4a885ad24a1052216b0542672bc7"}, "closed": true, "closedAt": "2020-09-01T14:32:48Z", "author": {"login": "bschuchardt"}, "timelineItems": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdEYn5fAH2gAyNDc2NTE4NDE5OjZmYTdlM2YzOTY1ZTZjNDQ5Y2JiMTk4MmUwOTJlYmEwZjU5NGVlYzI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdEbYbVgFqTQ3OTAzMTc2Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "6fa7e3f3965e6c449cbb1982e092eba0f594eec2", "author": {"user": {"login": "bschuchardt", "name": "Bruce Schuchardt"}}, "url": "https://github.com/apache/geode/commit/6fa7e3f3965e6c449cbb1982e092eba0f594eec2", "committedDate": "2020-08-31T20:14:14Z", "message": "GEODE-8467: server fails to notify of a ForcedDisconnect and fails to tear down the cache\n\nCatch exceptions that occur during XML generation and disable auto\nreconnect.\n\nEnsure that the DisconnectThread is launched by placing it in a\n\"finally\" block."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc5MDMxNzY3", "url": "https://github.com/apache/geode/pull/5490#pullrequestreview-479031767", "createdAt": "2020-08-31T23:17:40Z", "commit": {"oid": "6fa7e3f3965e6c449cbb1982e092eba0f594eec2"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMzoxNzo0MVrOHKNZDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMzoxNzo0MVrOHKNZDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ2NzIxMw==", "bodyText": "I guess it's ok to not rethrow the Throwable here. saveConfg() is called from two places in GMSMembership:\n\nManagerImpl.forceDisconnect()\nrequestMemberRemoval()\n\nIn both those cases it looks like setDisableAutoReconnect(true) will set us on a permanent shutdown path. Since we've logged the Throwable here we've fulfilled our obligation to inform the operator.", "url": "https://github.com/apache/geode/pull/5490#discussion_r480467213", "createdAt": "2020-08-31T23:17:41Z", "author": {"login": "Bill"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/GemFireCacheImpl.java", "diffHunk": "@@ -1177,34 +1178,53 @@ public MeterRegistry getMeterRegistry() {\n \n   @Override\n   public void saveCacheXmlForReconnect() {\n-    // there are two versions of this method so it can be unit-tested\n-    boolean sharedConfigEnabled = getDistributionManager().getConfig().getUseSharedConfiguration();\n+    prepareForReconnect((pw) -> CacheXmlGenerator.generate((Cache) this, pw, false));\n+  }\n \n-    if (!Boolean.getBoolean(GEMFIRE_PREFIX + \"autoReconnect-useCacheXMLFile\")\n-        && !sharedConfigEnabled) {\n-      try {\n-        logger.info(\"generating XML to rebuild the cache after reconnect completes\");\n-        StringPrintWriter pw = new StringPrintWriter();\n-        CacheXmlGenerator.generate((Cache) this, pw, false);\n-        String cacheXML = pw.toString();\n-        getCacheConfig().setCacheXMLDescription(cacheXML);\n-        logger.info(\"XML generation completed: {}\", cacheXML);\n-      } catch (CancelException e) {\n-        logger.info(\"Unable to generate XML description for reconnect of cache due to exception\",\n-            e);\n-      }\n-    } else if (sharedConfigEnabled && !getCacheServers().isEmpty()) {\n-      // we need to retain a cache-server description if this JVM was started by gfsh\n-      List<CacheServerCreation> list = new ArrayList<>(getCacheServers().size());\n-      for (Object o : getCacheServers()) {\n-        CacheServerImpl cs = (CacheServerImpl) o;\n-        if (cs.isDefaultServer()) {\n-          CacheServerCreation bsc = new CacheServerCreation(this, cs);\n-          list.add(bsc);\n+\n+  /**\n+   * Testable version of saveCacheXmlForReconnect() that allows us to inject an XML generator\n+   *\n+   * @param xmlGenerator a consumer of a PrintWriter that generates a description of the Cache\n+   */\n+  protected void prepareForReconnect(Consumer<PrintWriter> xmlGenerator) {\n+    boolean sharedConfigEnabled =\n+        getInternalDistributedSystem().getConfig().getUseSharedConfiguration();\n+\n+    try {\n+      if (!Boolean.getBoolean(GEMFIRE_PREFIX + \"autoReconnect-useCacheXMLFile\")\n+          && !sharedConfigEnabled) {\n+        try {\n+          logger.info(\"generating XML to rebuild the cache after reconnect completes\");\n+          StringPrintWriter pw = new StringPrintWriter();\n+          xmlGenerator.accept(pw);\n+          String cacheXML = pw.toString();\n+          getCacheConfig().setCacheXMLDescription(cacheXML);\n+          logger.info(\"XML generation completed: {}\", cacheXML);\n+        } catch (CancelException e) {\n+          logger.info(\"Unable to generate XML description for reconnect of cache due to exception\",\n+              e);\n         }\n+      } else if (sharedConfigEnabled && !getCacheServers().isEmpty()) {\n+        // we need to retain a cache-server description if this JVM was started by gfsh\n+        logger.info(\"saving cache server configuration for use with the cluster-configuration \"\n+            + \"service on reconnect\");\n+        List<CacheServerCreation> list = new ArrayList<>(getCacheServers().size());\n+        for (Object o : getCacheServers()) {\n+          CacheServerImpl cs = (CacheServerImpl) o;\n+          if (cs.isDefaultServer()) {\n+            CacheServerCreation bsc = new CacheServerCreation(this, cs);\n+            list.add(bsc);\n+          }\n+        }\n+        getCacheConfig().setCacheServerCreation(list);\n+        logger.info(\"cache server configuration saved\");\n       }\n-      getCacheConfig().setCacheServerCreation(list);\n-      logger.info(\"CacheServer configuration saved\");\n+    } catch (Throwable throwable) {\n+      logger.info(\"Saving of cache configuration for auto-reconnect has failed.  \"\n+          + \"Auto-reconnect will be disabled since the cache cannot be rebuilt.\", throwable);\n+      getInternalDistributedSystem().getConfig().setDisableAutoReconnect(true);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fa7e3f3965e6c449cbb1982e092eba0f594eec2"}, "originalPosition": 83}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4179, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}