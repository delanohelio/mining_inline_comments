{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyNzc1MTgx", "number": 5236, "title": "GEODE-8241: Locator observes locator-wait-time", "bodyText": "In the case where a locator starts up and is unable to connect to any\nother locators, it may decide to become the membership coordinator even\nif locator-wait-time has not elapsed.\nThis change addresses this issue by requiring a locator to wait for\nlocator-wait-time before deciding to become the coordinator.\nCo-authored-by: Aaron Lindsey alindsey@vmware.com\nCo-Authored-By: Vincent Ford vford@pivotal.io\nCo-authored-by: Bill Burcham bburcham@pivotal.io", "createdAt": "2020-06-11T00:41:11Z", "url": "https://github.com/apache/geode/pull/5236", "merged": true, "mergeCommit": {"oid": "720a4caea2ddb22296aa3225fc5264d2096cdf20"}, "closed": true, "closedAt": "2020-06-18T22:33:53Z", "author": {"login": "aaronlindsey"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcqPR9xAFqTQyODk3NDQ3OA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcsl7iUAFqTQzMzY4MTMzNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4OTc0NDc4", "url": "https://github.com/apache/geode/pull/5236#pullrequestreview-428974478", "createdAt": "2020-06-11T14:34:35Z", "commit": {"oid": "c49c8bcc4d58ff36e16f98cc1177feb1cd0a8a12"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNDozNDozNlrOGigOOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNDozNDozNlrOGigOOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgzMjY5Ng==", "bodyText": "There are a couple of these auto-generated try/catch statements in the test.  If they're failure conditions shouldn't the test fail?  If they're not, what good are these stack traces?", "url": "https://github.com/apache/geode/pull/5236#discussion_r438832696", "createdAt": "2020-06-11T14:34:36Z", "author": {"login": "bschuchardt"}, "path": "geode-membership/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/MembershipIntegrationTest.java", "diffHunk": "@@ -172,6 +179,91 @@ public void secondMembershipCanJoinUsingTheSecondLocatorToStart()\n     stop(locator2, locator1);\n   }\n \n+  @Test\n+  public void secondMembershipPausesForLocatorWaitTime()\n+      throws IOException, MemberStartupException {\n+\n+    /*\n+     * Start a locator for the coordinator (membership) so we have a port for it.\n+     *\n+     * Its locator-wait-time is set to 0 so it eventually (soon after membership is started) forms a\n+     * distributed system and becomes a coordinator.\n+     */\n+\n+    final MembershipLocator<MemberIdentifier> coordinatorLocator = createLocator(0);\n+    coordinatorLocator.start();\n+    final int coordinatorLocatorPort = coordinatorLocator.getPort();\n+\n+    final Membership<MemberIdentifier> coordinatorMembership =\n+        createMembership(coordinatorLocator, coordinatorLocatorPort);\n+\n+    /*\n+     * We have not even started the membership yet \u2014 connection attempts will certainly fail until\n+     * we do. This is a bit like the locator (host) not being present in DNS (yet).\n+     */\n+\n+    /*\n+     * Start a second locator and membership trying to join via the coordinator (membership) that\n+     * hasn't yet started behind the port.\n+     *\n+     * Set its locator-wait-time so it'll not become a coordinator right away, allowing time for the\n+     * other member to start and become a coordinator.\n+     *\n+     * Calculate the locator-wait-time to be greater than the minimum wait time for connecting to a\n+     * locator.\n+     */\n+\n+    final MembershipLocator<MemberIdentifier> lateJoiningLocator = createLocator(0);\n+    lateJoiningLocator.start();\n+    final int lateJoiningLocatorPort = lateJoiningLocator.getPort();\n+\n+    final int[] lateJoiningMembershipLocatorPorts =\n+        new int[] {coordinatorLocatorPort, lateJoiningLocatorPort};\n+\n+    final Duration minimumJoinWaitTime = Duration\n+        .ofMillis(2_000) // expected amount of sleep time per loop in GMSJoinLeave.join()\n+        .multipliedBy(lateJoiningMembershipLocatorPorts.length * 2); // expected number of loops\n+    final int locatorWaitTime = (int) (3 * minimumJoinWaitTime.getSeconds());\n+\n+    final MembershipConfig lateJoiningMembershipConfig =\n+        createMembershipConfig(true, locatorWaitTime, lateJoiningMembershipLocatorPorts);\n+    final Membership<MemberIdentifier> lateJoiningMembership =\n+        createMembership(lateJoiningMembershipConfig, lateJoiningLocator);\n+\n+    CompletableFuture<Void> lateJoiningMembershipStartup = executorServiceRule.runAsync(() -> {\n+      try {\n+        start(lateJoiningMembership);\n+      } catch (MemberStartupException e) {\n+        e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c49c8bcc4d58ff36e16f98cc1177feb1cd0a8a12"}, "originalPosition": 94}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5MTEyMTYz", "url": "https://github.com/apache/geode/pull/5236#pullrequestreview-429112163", "createdAt": "2020-06-11T17:04:13Z", "commit": {"oid": "c49c8bcc4d58ff36e16f98cc1177feb1cd0a8a12"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNzowNDoxM1rOGimnDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNzowNDoxM1rOGimnDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzNzM1OQ==", "bodyText": "It seems like it would be better to reference the same constants that are used in GMSJoinLeave instead of hard-coding this value.", "url": "https://github.com/apache/geode/pull/5236#discussion_r438937359", "createdAt": "2020-06-11T17:04:13Z", "author": {"login": "aaronlindsey"}, "path": "geode-membership/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/MembershipIntegrationTest.java", "diffHunk": "@@ -172,6 +179,91 @@ public void secondMembershipCanJoinUsingTheSecondLocatorToStart()\n     stop(locator2, locator1);\n   }\n \n+  @Test\n+  public void secondMembershipPausesForLocatorWaitTime()\n+      throws IOException, MemberStartupException {\n+\n+    /*\n+     * Start a locator for the coordinator (membership) so we have a port for it.\n+     *\n+     * Its locator-wait-time is set to 0 so it eventually (soon after membership is started) forms a\n+     * distributed system and becomes a coordinator.\n+     */\n+\n+    final MembershipLocator<MemberIdentifier> coordinatorLocator = createLocator(0);\n+    coordinatorLocator.start();\n+    final int coordinatorLocatorPort = coordinatorLocator.getPort();\n+\n+    final Membership<MemberIdentifier> coordinatorMembership =\n+        createMembership(coordinatorLocator, coordinatorLocatorPort);\n+\n+    /*\n+     * We have not even started the membership yet \u2014 connection attempts will certainly fail until\n+     * we do. This is a bit like the locator (host) not being present in DNS (yet).\n+     */\n+\n+    /*\n+     * Start a second locator and membership trying to join via the coordinator (membership) that\n+     * hasn't yet started behind the port.\n+     *\n+     * Set its locator-wait-time so it'll not become a coordinator right away, allowing time for the\n+     * other member to start and become a coordinator.\n+     *\n+     * Calculate the locator-wait-time to be greater than the minimum wait time for connecting to a\n+     * locator.\n+     */\n+\n+    final MembershipLocator<MemberIdentifier> lateJoiningLocator = createLocator(0);\n+    lateJoiningLocator.start();\n+    final int lateJoiningLocatorPort = lateJoiningLocator.getPort();\n+\n+    final int[] lateJoiningMembershipLocatorPorts =\n+        new int[] {coordinatorLocatorPort, lateJoiningLocatorPort};\n+\n+    final Duration minimumJoinWaitTime = Duration\n+        .ofMillis(2_000) // expected amount of sleep time per loop in GMSJoinLeave.join()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c49c8bcc4d58ff36e16f98cc1177feb1cd0a8a12"}, "originalPosition": 81}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwODYwMDc2", "url": "https://github.com/apache/geode/pull/5236#pullrequestreview-430860076", "createdAt": "2020-06-15T17:43:09Z", "commit": {"oid": "90479c43a5f74c0b90cf29bb2042777545ba7bec"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNzo0MzowOVrOGj8TuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNzo0NzoyN1rOGj8c1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0MTQzMg==", "bodyText": "where does 3 come from?", "url": "https://github.com/apache/geode/pull/5236#discussion_r440341432", "createdAt": "2020-06-15T17:43:09Z", "author": {"login": "Bill"}, "path": "geode-membership/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/MembershipIntegrationTest.java", "diffHunk": "@@ -172,6 +181,92 @@ public void secondMembershipCanJoinUsingTheSecondLocatorToStart()\n     stop(locator2, locator1);\n   }\n \n+  @Test\n+  public void secondMembershipPausesForLocatorWaitTime()\n+      throws IOException, MemberStartupException {\n+\n+    /*\n+     * Start a locator for the coordinator (membership) so we have a port for it.\n+     *\n+     * Its locator-wait-time is set to 0 so it eventually (soon after membership is started) forms a\n+     * distributed system and becomes a coordinator.\n+     */\n+\n+    final MembershipLocator<MemberIdentifier> coordinatorLocator = createLocator(0);\n+    coordinatorLocator.start();\n+    final int coordinatorLocatorPort = coordinatorLocator.getPort();\n+\n+    final Membership<MemberIdentifier> coordinatorMembership =\n+        createMembership(coordinatorLocator, coordinatorLocatorPort);\n+\n+    /*\n+     * We have not even started the membership yet \u2014 connection attempts will certainly fail until\n+     * we do. This is a bit like the locator (host) not being present in DNS (yet).\n+     */\n+\n+    /*\n+     * Start a second locator and membership trying to join via the coordinator (membership) that\n+     * hasn't yet started behind the port.\n+     *\n+     * Set its locator-wait-time so it'll not become a coordinator right away, allowing time for the\n+     * other member to start and become a coordinator.\n+     *\n+     * Calculate the locator-wait-time to be greater than the minimum wait time for connecting to a\n+     * locator.\n+     */\n+\n+    final MembershipLocator<MemberIdentifier> lateJoiningLocator = createLocator(0);\n+    lateJoiningLocator.start();\n+    final int lateJoiningLocatorPort = lateJoiningLocator.getPort();\n+\n+    final int[] lateJoiningMembershipLocatorPorts =\n+        new int[] {coordinatorLocatorPort, lateJoiningLocatorPort};\n+\n+    final Duration minimumJoinWaitTime = Duration\n+        .ofMillis(JOIN_RETRY_SLEEP + FIND_LOCATOR_RETRY_SLEEP) // amount of sleep time per retry\n+        .multipliedBy(lateJoiningMembershipLocatorPorts.length * 2); // expected number of retries\n+    final int locatorWaitTime = (int) (3 * minimumJoinWaitTime.getSeconds());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90479c43a5f74c0b90cf29bb2042777545ba7bec"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0MTgxNw==", "bodyText": "where does 2 come from? even if you don't want to explicitly reference an internal constant, it'd be nice to document where that constant lives", "url": "https://github.com/apache/geode/pull/5236#discussion_r440341817", "createdAt": "2020-06-15T17:43:57Z", "author": {"login": "Bill"}, "path": "geode-membership/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/MembershipIntegrationTest.java", "diffHunk": "@@ -172,6 +181,92 @@ public void secondMembershipCanJoinUsingTheSecondLocatorToStart()\n     stop(locator2, locator1);\n   }\n \n+  @Test\n+  public void secondMembershipPausesForLocatorWaitTime()\n+      throws IOException, MemberStartupException {\n+\n+    /*\n+     * Start a locator for the coordinator (membership) so we have a port for it.\n+     *\n+     * Its locator-wait-time is set to 0 so it eventually (soon after membership is started) forms a\n+     * distributed system and becomes a coordinator.\n+     */\n+\n+    final MembershipLocator<MemberIdentifier> coordinatorLocator = createLocator(0);\n+    coordinatorLocator.start();\n+    final int coordinatorLocatorPort = coordinatorLocator.getPort();\n+\n+    final Membership<MemberIdentifier> coordinatorMembership =\n+        createMembership(coordinatorLocator, coordinatorLocatorPort);\n+\n+    /*\n+     * We have not even started the membership yet \u2014 connection attempts will certainly fail until\n+     * we do. This is a bit like the locator (host) not being present in DNS (yet).\n+     */\n+\n+    /*\n+     * Start a second locator and membership trying to join via the coordinator (membership) that\n+     * hasn't yet started behind the port.\n+     *\n+     * Set its locator-wait-time so it'll not become a coordinator right away, allowing time for the\n+     * other member to start and become a coordinator.\n+     *\n+     * Calculate the locator-wait-time to be greater than the minimum wait time for connecting to a\n+     * locator.\n+     */\n+\n+    final MembershipLocator<MemberIdentifier> lateJoiningLocator = createLocator(0);\n+    lateJoiningLocator.start();\n+    final int lateJoiningLocatorPort = lateJoiningLocator.getPort();\n+\n+    final int[] lateJoiningMembershipLocatorPorts =\n+        new int[] {coordinatorLocatorPort, lateJoiningLocatorPort};\n+\n+    final Duration minimumJoinWaitTime = Duration\n+        .ofMillis(JOIN_RETRY_SLEEP + FIND_LOCATOR_RETRY_SLEEP) // amount of sleep time per retry\n+        .multipliedBy(lateJoiningMembershipLocatorPorts.length * 2); // expected number of retries", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90479c43a5f74c0b90cf29bb2042777545ba7bec"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0Mzc2NQ==", "bodyText": "where does this 2 come from?", "url": "https://github.com/apache/geode/pull/5236#discussion_r440343765", "createdAt": "2020-06-15T17:47:27Z", "author": {"login": "Bill"}, "path": "geode-membership/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/MembershipIntegrationTest.java", "diffHunk": "@@ -172,6 +181,92 @@ public void secondMembershipCanJoinUsingTheSecondLocatorToStart()\n     stop(locator2, locator1);\n   }\n \n+  @Test\n+  public void secondMembershipPausesForLocatorWaitTime()\n+      throws IOException, MemberStartupException {\n+\n+    /*\n+     * Start a locator for the coordinator (membership) so we have a port for it.\n+     *\n+     * Its locator-wait-time is set to 0 so it eventually (soon after membership is started) forms a\n+     * distributed system and becomes a coordinator.\n+     */\n+\n+    final MembershipLocator<MemberIdentifier> coordinatorLocator = createLocator(0);\n+    coordinatorLocator.start();\n+    final int coordinatorLocatorPort = coordinatorLocator.getPort();\n+\n+    final Membership<MemberIdentifier> coordinatorMembership =\n+        createMembership(coordinatorLocator, coordinatorLocatorPort);\n+\n+    /*\n+     * We have not even started the membership yet \u2014 connection attempts will certainly fail until\n+     * we do. This is a bit like the locator (host) not being present in DNS (yet).\n+     */\n+\n+    /*\n+     * Start a second locator and membership trying to join via the coordinator (membership) that\n+     * hasn't yet started behind the port.\n+     *\n+     * Set its locator-wait-time so it'll not become a coordinator right away, allowing time for the\n+     * other member to start and become a coordinator.\n+     *\n+     * Calculate the locator-wait-time to be greater than the minimum wait time for connecting to a\n+     * locator.\n+     */\n+\n+    final MembershipLocator<MemberIdentifier> lateJoiningLocator = createLocator(0);\n+    lateJoiningLocator.start();\n+    final int lateJoiningLocatorPort = lateJoiningLocator.getPort();\n+\n+    final int[] lateJoiningMembershipLocatorPorts =\n+        new int[] {coordinatorLocatorPort, lateJoiningLocatorPort};\n+\n+    final Duration minimumJoinWaitTime = Duration\n+        .ofMillis(JOIN_RETRY_SLEEP + FIND_LOCATOR_RETRY_SLEEP) // amount of sleep time per retry\n+        .multipliedBy(lateJoiningMembershipLocatorPorts.length * 2); // expected number of retries\n+    final int locatorWaitTime = (int) (3 * minimumJoinWaitTime.getSeconds());\n+\n+    final MembershipConfig lateJoiningMembershipConfig =\n+        createMembershipConfig(true, locatorWaitTime, lateJoiningMembershipLocatorPorts);\n+    final Membership<MemberIdentifier> lateJoiningMembership =\n+        createMembership(lateJoiningMembershipConfig, lateJoiningLocator);\n+\n+    CompletableFuture<Void> lateJoiningMembershipStartup = executorServiceRule.runAsync(() -> {\n+      try {\n+        start(lateJoiningMembership);\n+      } catch (MemberStartupException e) {\n+        throw new RuntimeException(e);\n+      }\n+    });\n+\n+    /*\n+     * Now start the coordinator (membership), after waiting longer than the minimum wait time for\n+     * connecting to a locator but shorter than the locator-wait-time.\n+     */\n+\n+    CompletableFuture<Void> coordinatorMembershipStartup = executorServiceRule.runAsync(() -> {\n+      try {\n+        Thread.sleep(2 * minimumJoinWaitTime.toMillis());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90479c43a5f74c0b90cf29bb2042777545ba7bec"}, "originalPosition": 107}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNDgxODEx", "url": "https://github.com/apache/geode/pull/5236#pullrequestreview-433481811", "createdAt": "2020-06-18T17:05:39Z", "commit": {"oid": "505bc841b20c1bd55b99dfe1aa8b95e1e536ae3e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "19c4e2d692634ab986162aeb19251d042daae073", "author": {"user": {"login": "aaronlindsey", "name": "Aaron Lindsey"}}, "url": "https://github.com/apache/geode/commit/19c4e2d692634ab986162aeb19251d042daae073", "committedDate": "2020-06-18T18:01:11Z", "message": "GEODE-8241: Locator observes locator-wait-time\n\nIn the case where a locator starts up and is unable to connect to any\nother locators, it may decide to become the membership coordinator even\nif locator-wait-time has not elapsed.\n\nThis change addresses this issue by requiring a locator to wait for\nlocator-wait-time before deciding to become the coordinator.\n\nCo-authored-by: Aaron Lindsey <alindsey@vmware.com>\nCo-Authored-By: Vincent Ford <vford@pivotal.io>\nCo-authored-by: Bill Burcham <bburcham@pivotal.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d4dc92a09b4ff4d400ee64275c9a9aa3eb64901", "author": {"user": {"login": "aaronlindsey", "name": "Aaron Lindsey"}}, "url": "https://github.com/apache/geode/commit/9d4dc92a09b4ff4d400ee64275c9a9aa3eb64901", "committedDate": "2020-06-18T18:01:11Z", "message": "Make the test fail when an exception other than InterruptedException is\nthrown within a CompleteableFuture\n\nAuthored-by: Aaron Lindsey <alindsey@vmware.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8024749a29ebbb7c91f719405a640312c848e78c", "author": {"user": {"login": "aaronlindsey", "name": "Aaron Lindsey"}}, "url": "https://github.com/apache/geode/commit/8024749a29ebbb7c91f719405a640312c848e78c", "committedDate": "2020-06-18T18:01:11Z", "message": "Extract find coordinator sleep time to constant and reference sleep time\nconstants from test\n\nAuthored-by: Aaron Lindsey <alindsey@vmware.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c57e83a02bfc7af9aec63090085846fe0261281", "author": {"user": {"login": "aaronlindsey", "name": "Aaron Lindsey"}}, "url": "https://github.com/apache/geode/commit/6c57e83a02bfc7af9aec63090085846fe0261281", "committedDate": "2020-06-18T18:01:11Z", "message": "Document constants in test and extract method for calculating the\nminimum number of retries before becoming coordinator\n\nAuthored-by: Aaron Lindsey <alindsey@vmware.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f483897818923b79515fbfe9c33277ea9ed98e6", "author": {"user": {"login": "aaronlindsey", "name": "Aaron Lindsey"}}, "url": "https://github.com/apache/geode/commit/1f483897818923b79515fbfe9c33277ea9ed98e6", "committedDate": "2020-06-18T18:01:11Z", "message": "Increase locator-wait-time to make chance of flakiness negligible\n\n- Remove second CompletableFuture because it wasn't necessary\n\nAuthored-by: Aaron Lindsey <alindsey@vmware.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "505bc841b20c1bd55b99dfe1aa8b95e1e536ae3e", "author": {"user": {"login": "aaronlindsey", "name": "Aaron Lindsey"}}, "url": "https://github.com/apache/geode/commit/505bc841b20c1bd55b99dfe1aa8b95e1e536ae3e", "committedDate": "2020-06-18T00:52:30Z", "message": "Increase locator-wait-time to make chance of flakiness negligible\n\n- Remove second CompletableFuture because it wasn't necessary\n\nAuthored-by: Aaron Lindsey <alindsey@vmware.com>"}, "afterCommit": {"oid": "1f483897818923b79515fbfe9c33277ea9ed98e6", "author": {"user": {"login": "aaronlindsey", "name": "Aaron Lindsey"}}, "url": "https://github.com/apache/geode/commit/1f483897818923b79515fbfe9c33277ea9ed98e6", "committedDate": "2020-06-18T18:01:11Z", "message": "Increase locator-wait-time to make chance of flakiness negligible\n\n- Remove second CompletableFuture because it wasn't necessary\n\nAuthored-by: Aaron Lindsey <alindsey@vmware.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjgxMzM3", "url": "https://github.com/apache/geode/pull/5236#pullrequestreview-433681337", "createdAt": "2020-06-18T22:10:16Z", "commit": {"oid": "1f483897818923b79515fbfe9c33277ea9ed98e6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4452, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}