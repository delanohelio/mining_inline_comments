{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI0MjM1MTE4", "number": 5763, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNjoxODoyM1rOE7m8Fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNzoyMjowOFrOE-wgpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwOTM5NDE0OnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/internal/monitoring/ThreadsMonitoringImpl.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNjoxODoyM1rOH3WbJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMjo0OTo1OVrOH3jRYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzgwMTEyNw==", "bodyText": "I'm a little concerned about the impact of taking yet another millisecond clock reading on every message that we dispatch.  This should be run through extensive performance testing before merging it to develop.", "url": "https://github.com/apache/geode/pull/5763#discussion_r527801127", "createdAt": "2020-11-20T16:18:23Z", "author": {"login": "bschuchardt"}, "path": "geode-core/src/main/java/org/apache/geode/internal/monitoring/ThreadsMonitoringImpl.java", "diffHunk": "@@ -96,39 +98,60 @@ public void updateThreadStatus() {\n \n   @Override\n   public boolean startMonitor(Mode mode) {\n-    AbstractExecutor absExtgroup;\n+    return startMonitoring(createAbstractExecutor(mode));\n+  }\n+\n+  @Override\n+  public void endMonitor() {\n+    this.monitorMap.remove(Thread.currentThread().getId());\n+  }\n+\n+  @VisibleForTesting\n+  boolean isMonitoring() {\n+    return monitorMap.containsKey(Thread.currentThread().getId());\n+  }\n+\n+  @Override\n+  public AbstractExecutor createAbstractExecutor(Mode mode) {\n     switch (mode) {\n       case FunctionExecutor:\n-        absExtgroup = new FunctionExecutionPooledExecutorGroup(this);\n-        break;\n+        return new FunctionExecutionPooledExecutorGroup();\n       case PooledExecutor:\n-        absExtgroup = new PooledExecutorGroup(this);\n-        break;\n+        return new PooledExecutorGroup();\n       case SerialQueuedExecutor:\n-        absExtgroup = new SerialQueuedExecutorGroup(this);\n-        break;\n+        return new SerialQueuedExecutorGroup();\n       case OneTaskOnlyExecutor:\n-        absExtgroup = new OneTaskOnlyExecutorGroup(this);\n-        break;\n+        return new OneTaskOnlyExecutorGroup();\n       case ScheduledThreadExecutor:\n-        absExtgroup = new ScheduledThreadPoolExecutorWKAGroup(this);\n-        break;\n+        return new ScheduledThreadPoolExecutorWKAGroup();\n       case AGSExecutor:\n-        absExtgroup = new GatewaySenderEventProcessorGroup(this);\n-        break;\n+        return new GatewaySenderEventProcessorGroup();\n+      case P2PReaderExecutor:\n+        return new P2PReaderExecutorGroup();\n       default:\n-        return false;\n+        throw new IllegalStateException(\"Unhandled mode=\" + mode);\n     }\n-    this.monitorMap.put(Thread.currentThread().getId(), absExtgroup);\n+  }\n+\n+  @Override\n+  public boolean startMonitoring(AbstractExecutor executor) {\n+    executor.setStartTime(System.currentTimeMillis());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36c7ac0761806f6e2542c538f3f886820a50a30b"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzgzODI1NQ==", "bodyText": "I had the same thought. I was even concerned about constantly adding and removing from the concurrent map. We could just use the frequency of the monitor thread to do the time work. For example if it finds an AbstractExecutor in the map that it has not seen before then the monitor thread could set the time it first saw it. If later monitor samples see it again it could use this time (i.e. the one the monitor set) to determine if it is stuck. This could even be done without timestamps. Just a simple counter the monitor incs and the p2p reader thread clears. If the monitor thread is waking up at a fixed interval then you know the thread has been stuck for at least that much time. I like your idea of having custom code in P2PReaderExecutorGroup for this. When I was thinking about it I thought I would need to change the behavior of all the existing threads being monitored. Thanks for the feedback!", "url": "https://github.com/apache/geode/pull/5763#discussion_r527838255", "createdAt": "2020-11-20T17:13:50Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-core/src/main/java/org/apache/geode/internal/monitoring/ThreadsMonitoringImpl.java", "diffHunk": "@@ -96,39 +98,60 @@ public void updateThreadStatus() {\n \n   @Override\n   public boolean startMonitor(Mode mode) {\n-    AbstractExecutor absExtgroup;\n+    return startMonitoring(createAbstractExecutor(mode));\n+  }\n+\n+  @Override\n+  public void endMonitor() {\n+    this.monitorMap.remove(Thread.currentThread().getId());\n+  }\n+\n+  @VisibleForTesting\n+  boolean isMonitoring() {\n+    return monitorMap.containsKey(Thread.currentThread().getId());\n+  }\n+\n+  @Override\n+  public AbstractExecutor createAbstractExecutor(Mode mode) {\n     switch (mode) {\n       case FunctionExecutor:\n-        absExtgroup = new FunctionExecutionPooledExecutorGroup(this);\n-        break;\n+        return new FunctionExecutionPooledExecutorGroup();\n       case PooledExecutor:\n-        absExtgroup = new PooledExecutorGroup(this);\n-        break;\n+        return new PooledExecutorGroup();\n       case SerialQueuedExecutor:\n-        absExtgroup = new SerialQueuedExecutorGroup(this);\n-        break;\n+        return new SerialQueuedExecutorGroup();\n       case OneTaskOnlyExecutor:\n-        absExtgroup = new OneTaskOnlyExecutorGroup(this);\n-        break;\n+        return new OneTaskOnlyExecutorGroup();\n       case ScheduledThreadExecutor:\n-        absExtgroup = new ScheduledThreadPoolExecutorWKAGroup(this);\n-        break;\n+        return new ScheduledThreadPoolExecutorWKAGroup();\n       case AGSExecutor:\n-        absExtgroup = new GatewaySenderEventProcessorGroup(this);\n-        break;\n+        return new GatewaySenderEventProcessorGroup();\n+      case P2PReaderExecutor:\n+        return new P2PReaderExecutorGroup();\n       default:\n-        return false;\n+        throw new IllegalStateException(\"Unhandled mode=\" + mode);\n     }\n-    this.monitorMap.put(Thread.currentThread().getId(), absExtgroup);\n+  }\n+\n+  @Override\n+  public boolean startMonitoring(AbstractExecutor executor) {\n+    executor.setStartTime(System.currentTimeMillis());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzgwMTEyNw=="}, "originalCommit": {"oid": "36c7ac0761806f6e2542c538f3f886820a50a30b"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzg1OTQxMQ==", "bodyText": "I converted back to draft mode. Will rework this and submit it again.", "url": "https://github.com/apache/geode/pull/5763#discussion_r527859411", "createdAt": "2020-11-20T17:40:18Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-core/src/main/java/org/apache/geode/internal/monitoring/ThreadsMonitoringImpl.java", "diffHunk": "@@ -96,39 +98,60 @@ public void updateThreadStatus() {\n \n   @Override\n   public boolean startMonitor(Mode mode) {\n-    AbstractExecutor absExtgroup;\n+    return startMonitoring(createAbstractExecutor(mode));\n+  }\n+\n+  @Override\n+  public void endMonitor() {\n+    this.monitorMap.remove(Thread.currentThread().getId());\n+  }\n+\n+  @VisibleForTesting\n+  boolean isMonitoring() {\n+    return monitorMap.containsKey(Thread.currentThread().getId());\n+  }\n+\n+  @Override\n+  public AbstractExecutor createAbstractExecutor(Mode mode) {\n     switch (mode) {\n       case FunctionExecutor:\n-        absExtgroup = new FunctionExecutionPooledExecutorGroup(this);\n-        break;\n+        return new FunctionExecutionPooledExecutorGroup();\n       case PooledExecutor:\n-        absExtgroup = new PooledExecutorGroup(this);\n-        break;\n+        return new PooledExecutorGroup();\n       case SerialQueuedExecutor:\n-        absExtgroup = new SerialQueuedExecutorGroup(this);\n-        break;\n+        return new SerialQueuedExecutorGroup();\n       case OneTaskOnlyExecutor:\n-        absExtgroup = new OneTaskOnlyExecutorGroup(this);\n-        break;\n+        return new OneTaskOnlyExecutorGroup();\n       case ScheduledThreadExecutor:\n-        absExtgroup = new ScheduledThreadPoolExecutorWKAGroup(this);\n-        break;\n+        return new ScheduledThreadPoolExecutorWKAGroup();\n       case AGSExecutor:\n-        absExtgroup = new GatewaySenderEventProcessorGroup(this);\n-        break;\n+        return new GatewaySenderEventProcessorGroup();\n+      case P2PReaderExecutor:\n+        return new P2PReaderExecutorGroup();\n       default:\n-        return false;\n+        throw new IllegalStateException(\"Unhandled mode=\" + mode);\n     }\n-    this.monitorMap.put(Thread.currentThread().getId(), absExtgroup);\n+  }\n+\n+  @Override\n+  public boolean startMonitoring(AbstractExecutor executor) {\n+    executor.setStartTime(System.currentTimeMillis());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzgwMTEyNw=="}, "originalCommit": {"oid": "36c7ac0761806f6e2542c538f3f886820a50a30b"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkxMzE4NQ==", "bodyText": "having the monitor thread set the time is a good idea.  Another thing you could do is have the Monitor thread record the current time when it wakes up and use that for new entries in the map.  GMSHealthMonitor's monitor thread does something like that.", "url": "https://github.com/apache/geode/pull/5763#discussion_r527913185", "createdAt": "2020-11-20T19:04:17Z", "author": {"login": "bschuchardt"}, "path": "geode-core/src/main/java/org/apache/geode/internal/monitoring/ThreadsMonitoringImpl.java", "diffHunk": "@@ -96,39 +98,60 @@ public void updateThreadStatus() {\n \n   @Override\n   public boolean startMonitor(Mode mode) {\n-    AbstractExecutor absExtgroup;\n+    return startMonitoring(createAbstractExecutor(mode));\n+  }\n+\n+  @Override\n+  public void endMonitor() {\n+    this.monitorMap.remove(Thread.currentThread().getId());\n+  }\n+\n+  @VisibleForTesting\n+  boolean isMonitoring() {\n+    return monitorMap.containsKey(Thread.currentThread().getId());\n+  }\n+\n+  @Override\n+  public AbstractExecutor createAbstractExecutor(Mode mode) {\n     switch (mode) {\n       case FunctionExecutor:\n-        absExtgroup = new FunctionExecutionPooledExecutorGroup(this);\n-        break;\n+        return new FunctionExecutionPooledExecutorGroup();\n       case PooledExecutor:\n-        absExtgroup = new PooledExecutorGroup(this);\n-        break;\n+        return new PooledExecutorGroup();\n       case SerialQueuedExecutor:\n-        absExtgroup = new SerialQueuedExecutorGroup(this);\n-        break;\n+        return new SerialQueuedExecutorGroup();\n       case OneTaskOnlyExecutor:\n-        absExtgroup = new OneTaskOnlyExecutorGroup(this);\n-        break;\n+        return new OneTaskOnlyExecutorGroup();\n       case ScheduledThreadExecutor:\n-        absExtgroup = new ScheduledThreadPoolExecutorWKAGroup(this);\n-        break;\n+        return new ScheduledThreadPoolExecutorWKAGroup();\n       case AGSExecutor:\n-        absExtgroup = new GatewaySenderEventProcessorGroup(this);\n-        break;\n+        return new GatewaySenderEventProcessorGroup();\n+      case P2PReaderExecutor:\n+        return new P2PReaderExecutorGroup();\n       default:\n-        return false;\n+        throw new IllegalStateException(\"Unhandled mode=\" + mode);\n     }\n-    this.monitorMap.put(Thread.currentThread().getId(), absExtgroup);\n+  }\n+\n+  @Override\n+  public boolean startMonitoring(AbstractExecutor executor) {\n+    executor.setStartTime(System.currentTimeMillis());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzgwMTEyNw=="}, "originalCommit": {"oid": "36c7ac0761806f6e2542c538f3f886820a50a30b"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAxMTYxOA==", "bodyText": "the p2p reader now simply sets a volatile boolean before and after messageDispatch.\nthe startTime for a p2p reader will now be set by the monitor thread.\nLet me know what you think", "url": "https://github.com/apache/geode/pull/5763#discussion_r528011618", "createdAt": "2020-11-20T22:49:59Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-core/src/main/java/org/apache/geode/internal/monitoring/ThreadsMonitoringImpl.java", "diffHunk": "@@ -96,39 +98,60 @@ public void updateThreadStatus() {\n \n   @Override\n   public boolean startMonitor(Mode mode) {\n-    AbstractExecutor absExtgroup;\n+    return startMonitoring(createAbstractExecutor(mode));\n+  }\n+\n+  @Override\n+  public void endMonitor() {\n+    this.monitorMap.remove(Thread.currentThread().getId());\n+  }\n+\n+  @VisibleForTesting\n+  boolean isMonitoring() {\n+    return monitorMap.containsKey(Thread.currentThread().getId());\n+  }\n+\n+  @Override\n+  public AbstractExecutor createAbstractExecutor(Mode mode) {\n     switch (mode) {\n       case FunctionExecutor:\n-        absExtgroup = new FunctionExecutionPooledExecutorGroup(this);\n-        break;\n+        return new FunctionExecutionPooledExecutorGroup();\n       case PooledExecutor:\n-        absExtgroup = new PooledExecutorGroup(this);\n-        break;\n+        return new PooledExecutorGroup();\n       case SerialQueuedExecutor:\n-        absExtgroup = new SerialQueuedExecutorGroup(this);\n-        break;\n+        return new SerialQueuedExecutorGroup();\n       case OneTaskOnlyExecutor:\n-        absExtgroup = new OneTaskOnlyExecutorGroup(this);\n-        break;\n+        return new OneTaskOnlyExecutorGroup();\n       case ScheduledThreadExecutor:\n-        absExtgroup = new ScheduledThreadPoolExecutorWKAGroup(this);\n-        break;\n+        return new ScheduledThreadPoolExecutorWKAGroup();\n       case AGSExecutor:\n-        absExtgroup = new GatewaySenderEventProcessorGroup(this);\n-        break;\n+        return new GatewaySenderEventProcessorGroup();\n+      case P2PReaderExecutor:\n+        return new P2PReaderExecutorGroup();\n       default:\n-        return false;\n+        throw new IllegalStateException(\"Unhandled mode=\" + mode);\n     }\n-    this.monitorMap.put(Thread.currentThread().getId(), absExtgroup);\n+  }\n+\n+  @Override\n+  public boolean startMonitoring(AbstractExecutor executor) {\n+    executor.setStartTime(System.currentTimeMillis());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzgwMTEyNw=="}, "originalCommit": {"oid": "36c7ac0761806f6e2542c538f3f886820a50a30b"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MjQwMDE4OnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/internal/monitoring/ThreadsMonitoringProcess.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNzoxNzozNlrOH8FUxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQyMTo1OTowNVrOH8PgwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc2Mzg0Nw==", "bodyText": "What unit is timeLimit? I recommend either adding a TimeUnit parameter or renaming timeLimit to include Millis or something as a prefix.", "url": "https://github.com/apache/geode/pull/5763#discussion_r532763847", "createdAt": "2020-11-30T17:17:36Z", "author": {"login": "kirklund"}, "path": "geode-core/src/main/java/org/apache/geode/internal/monitoring/ThreadsMonitoringProcess.java", "diffHunk": "@@ -33,73 +31,86 @@\n \n public class ThreadsMonitoringProcess extends TimerTask {\n \n-  private final ThreadsMonitoring threadsMonitoring;\n-  private ResourceManagerStats resourceManagerStats = null;\n   private static final Logger logger = LogService.getLogger();\n+\n+  private final ThreadsMonitoring threadsMonitoring;\n   private final int timeLimit;\n   private final InternalDistributedSystem internalDistributedSystem;\n \n-  private final Properties nonDefault = new Properties();\n-  private final DistributionConfigImpl distributionConfigImpl =\n-      new DistributionConfigImpl(nonDefault);\n+  private ResourceManagerStats resourceManagerStats = null;\n \n   protected ThreadsMonitoringProcess(ThreadsMonitoring tMonitoring,\n-      InternalDistributedSystem iDistributedSystem) {\n-    this.timeLimit = this.distributionConfigImpl.getThreadMonitorTimeLimit();\n+      InternalDistributedSystem iDistributedSystem, int timeLimit) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23d4ee647cfd70db6de82317e0471775373889a1"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkzMDc1Mg==", "bodyText": "I changed the name to timeLimitMillis. This unit is determined by an external geode property so it will always be milliseconds", "url": "https://github.com/apache/geode/pull/5763#discussion_r532930752", "createdAt": "2020-11-30T21:59:05Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-core/src/main/java/org/apache/geode/internal/monitoring/ThreadsMonitoringProcess.java", "diffHunk": "@@ -33,73 +31,86 @@\n \n public class ThreadsMonitoringProcess extends TimerTask {\n \n-  private final ThreadsMonitoring threadsMonitoring;\n-  private ResourceManagerStats resourceManagerStats = null;\n   private static final Logger logger = LogService.getLogger();\n+\n+  private final ThreadsMonitoring threadsMonitoring;\n   private final int timeLimit;\n   private final InternalDistributedSystem internalDistributedSystem;\n \n-  private final Properties nonDefault = new Properties();\n-  private final DistributionConfigImpl distributionConfigImpl =\n-      new DistributionConfigImpl(nonDefault);\n+  private ResourceManagerStats resourceManagerStats = null;\n \n   protected ThreadsMonitoringProcess(ThreadsMonitoring tMonitoring,\n-      InternalDistributedSystem iDistributedSystem) {\n-    this.timeLimit = this.distributionConfigImpl.getThreadMonitorTimeLimit();\n+      InternalDistributedSystem iDistributedSystem, int timeLimit) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc2Mzg0Nw=="}, "originalCommit": {"oid": "23d4ee647cfd70db6de82317e0471775373889a1"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MjQxMTcyOnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/monitoring/ThreadsMonitoringProcessJUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNzoyMDoyMlrOH8FcIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQyMTo1OToxMlrOH8Pg_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc2NTcyOA==", "bodyText": "Please indicate the units of measure in the name or an additional parameter.", "url": "https://github.com/apache/geode/pull/5763#discussion_r532765728", "createdAt": "2020-11-30T17:20:22Z", "author": {"login": "kirklund"}, "path": "geode-core/src/test/java/org/apache/geode/internal/monitoring/ThreadsMonitoringProcessJUnitTest.java", "diffHunk": "@@ -34,11 +31,13 @@\n  */\n public class ThreadsMonitoringProcessJUnitTest {\n \n+  private static final int TIME_LIMIT = 1000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23d4ee647cfd70db6de82317e0471775373889a1"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkzMDgxMg==", "bodyText": "done", "url": "https://github.com/apache/geode/pull/5763#discussion_r532930812", "createdAt": "2020-11-30T21:59:12Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-core/src/test/java/org/apache/geode/internal/monitoring/ThreadsMonitoringProcessJUnitTest.java", "diffHunk": "@@ -34,11 +31,13 @@\n  */\n public class ThreadsMonitoringProcessJUnitTest {\n \n+  private static final int TIME_LIMIT = 1000;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc2NTcyOA=="}, "originalCommit": {"oid": "23d4ee647cfd70db6de82317e0471775373889a1"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MjQxOTU5OnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/monitoring/executor/P2PReaderExecutorGroupJUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNzoyMjowOFrOH8Fg2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQyMTo1NzoyOFrOH8Pdlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc2NjkzNg==", "bodyText": "I recommend just naming unit tests as P2PReaderExecutorGroupTest (no need to include JUnit)", "url": "https://github.com/apache/geode/pull/5763#discussion_r532766936", "createdAt": "2020-11-30T17:22:08Z", "author": {"login": "kirklund"}, "path": "geode-core/src/test/java/org/apache/geode/internal/monitoring/executor/P2PReaderExecutorGroupJUnitTest.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.monitoring.executor;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import org.junit.Test;\n+\n+public class P2PReaderExecutorGroupJUnitTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23d4ee647cfd70db6de82317e0471775373889a1"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkyOTk0Mg==", "bodyText": "done", "url": "https://github.com/apache/geode/pull/5763#discussion_r532929942", "createdAt": "2020-11-30T21:57:28Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-core/src/test/java/org/apache/geode/internal/monitoring/executor/P2PReaderExecutorGroupJUnitTest.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.monitoring.executor;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import org.junit.Test;\n+\n+public class P2PReaderExecutorGroupJUnitTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc2NjkzNg=="}, "originalCommit": {"oid": "23d4ee647cfd70db6de82317e0471775373889a1"}, "originalPosition": 21}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4515, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}