{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIxNjQ1OTg1", "number": 5146, "title": "GEODE-8175: removed list, sorted set, hyperLog and transaction redis commands and code", "bodyText": "Thank you for submitting a contribution to Apache Geode.\nIn order to streamline the review of the contribution we ask you\nto ensure the following steps have been taken:\nFor all changes:\n\n\n Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?\n\n\n Has your PR been rebased against the latest commit within the target branch (typically develop)?\n\n\n Is your initial contribution a single, squashed commit?\n\n\n Does gradlew build run cleanly?\n\n\n Have you written or updated unit tests to verify your changes?\n\n\n If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under ASF 2.0?\n\n\nNote:\nPlease ensure that once the PR is submitted, check Concourse for build issues and\nsubmit an update to your PR as soon as possible. If you need help, please send an\nemail to dev@geode.apache.org.", "createdAt": "2020-05-22T00:02:23Z", "url": "https://github.com/apache/geode/pull/5146", "merged": true, "mergeCommit": {"oid": "a05b86dc7b847844a99f300bd04132137dfc9597"}, "closed": true, "closedAt": "2020-05-23T00:42:54Z", "author": {"login": "dschneider-pivotal"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcjzIuNgFqTQxNjkzODgxMQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcj6sWXABqjMzNjY0MDA5NDM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2OTM4ODEx", "url": "https://github.com/apache/geode/pull/5146#pullrequestreview-416938811", "createdAt": "2020-05-22T14:06:30Z", "commit": {"oid": "507b9db04a041a943fc28c1c6d0a1ee1e99f97fd"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDowNjozMVrOGZYZ1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDoyNTowNlrOGZZEPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI2NzQxNA==", "bodyText": "Can we get rid of the @ignore on this test now that we're only testing hashes and sets?", "url": "https://github.com/apache/geode/pull/5146#discussion_r429267414", "createdAt": "2020-05-22T14:06:31Z", "author": {"login": "ringles"}, "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/RedisDistDUnitTest.java", "diffHunk": "@@ -209,18 +209,6 @@ public void run() throws InterruptedException {\n             } else {\n               jedis.del(hKey);\n             }\n-          } else if (n == 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "507b9db04a041a943fc28c1c6d0a1ee1e99f97fd"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI3MTYxNA==", "bodyText": "Doesn't look like the arguments are needed anymore. In fact, the whole function may be eliminated...", "url": "https://github.com/apache/geode/pull/5146#discussion_r429271614", "createdAt": "2020-05-22T14:13:58Z", "author": {"login": "ringles"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/KeyRegistrar.java", "diffHunk": "@@ -201,11 +172,7 @@ private void throwDataTypeException(ByteArrayWrapper key, RedisData data) {\n   }\n \n   private void throwDataTypeException(ByteArrayWrapper key, RedisDataType dataType) {\n-    if (RedisDataType.REDIS_PROTECTED.equals(dataType)) {\n-      throw new RedisDataTypeMismatchException(\"The key name \\\"\" + key + \"\\\" is protected\");\n-    } else {\n-      throw new RedisDataTypeMismatchException(\n-          RedisConstants.ERROR_WRONG_TYPE);\n-    }\n+    throw new RedisDataTypeMismatchException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "507b9db04a041a943fc28c1c6d0a1ee1e99f97fd"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI3ODI2OQ==", "bodyText": "So, because we don't care whether or not these calls return true or false, we don't really need the lock anymore? If two threads try to remove the same key, at least one will succeed so no harm, no foul?", "url": "https://github.com/apache/geode/pull/5146#discussion_r429278269", "createdAt": "2020-05-22T14:25:06Z", "author": {"login": "ringles"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/RegionProvider.java", "diffHunk": "@@ -205,281 +98,27 @@ private boolean typeStoresDataInKeyRegistrar(RedisDataType type) {\n   }\n \n   public boolean removeKey(ByteArrayWrapper key, RedisDataType type, boolean cancelExpiration) {\n-    if (type == RedisDataType.REDIS_PROTECTED) {\n-      return false;\n+    if (!typeStoresDataInKeyRegistrar(type)) {\n+      keyRegistrar.unregister(key);\n     }\n-    Lock lock = dynamicRegionLocks.get(key);\n+    RedisKeyCommands redisKeyCommands = new RedisKeyCommandsFunctionExecutor(dataRegion);\n     try {\n-      if (lock != null) { // only typeUsesDynamicRegions will have a lock\n-        lock.lock();\n-      }\n-      if (!typeStoresDataInKeyRegistrar(type)) {\n-        keyRegistrar.unregister(key);\n-      }\n-      RedisKeyCommands redisKeyCommands = new RedisKeyCommandsFunctionExecutor(dataRegion);\n-      try {\n-        if (type == RedisDataType.REDIS_STRING) {\n-          return stringsRegion.remove(key) != null;\n-        } else if (type == RedisDataType.REDIS_HLL) {\n-          return hLLRegion.remove(key) != null;\n-        } else if (type == RedisDataType.REDIS_LIST || type == RedisDataType.REDIS_SORTEDSET) {\n-          return destroyRegion(key, type);\n-        } else if (type == RedisDataType.REDIS_SET || type == RedisDataType.REDIS_HASH) {\n-          return redisKeyCommands.del(key);\n-        } else {\n-          return false;\n-        }\n-      } catch (Exception exc) {\n+      if (type == RedisDataType.REDIS_STRING) {\n+        return stringsRegion.remove(key) != null;\n+      } else if (type == RedisDataType.REDIS_SET || type == RedisDataType.REDIS_HASH) {\n+        return redisKeyCommands.del(key);\n+      } else {\n         return false;\n-      } finally {\n-        if (cancelExpiration) {\n-          cancelKeyExpiration(key);\n-        } else {\n-          removeKeyExpiration(key);\n-        }\n-        if (lock != null) {\n-          dynamicRegionLocks.remove(key);\n-        }\n       }\n+    } catch (Exception exc) {\n+      return false;\n     } finally {\n-      if (lock != null) {\n-        lock.unlock();\n-      }\n-    }\n-  }\n-\n-  public Region<?, ?> getOrCreateRegion(ByteArrayWrapper key, RedisDataType type,\n-      ExecutionHandlerContext context) {\n-    return getOrCreateRegion0(key, type, context, true);\n-  }\n-\n-  public boolean typeUsesDynamicRegions(RedisDataType type) {\n-    return type == RedisDataType.REDIS_LIST || type == RedisDataType.REDIS_SORTEDSET;\n-  }\n-\n-  public void createRemoteRegionReferenceLocally(ByteArrayWrapper key, RedisDataType type) {\n-    if (!typeUsesDynamicRegions(type)) {\n-      return;\n-    }\n-    Region<Object, Object> r = dynamicRegions.get(key);\n-    if (r != null) {\n-      return;\n-    }\n-    Lock lock = dynamicRegionLocks.get(key);\n-    if (lock == null) {\n-      Lock newLock = new ReentrantLock();\n-      lock = dynamicRegionLocks.putIfAbsent(key, newLock);\n-      if (lock == null) {\n-        lock = newLock;\n-      }\n-    }\n-    boolean locked = lock.tryLock();\n-    // If we cannot get the lock then this remote event may have been initialized\n-    // independently on this machine, so if we wait on the lock it is more than\n-    // likely we will deadlock just to do the same task. This event can be ignored\n-    if (locked) {\n-      try {\n-        r = cache.getRegion(key.toString());\n-        // If r is null, this implies that we are after a create/destroy\n-        // simply ignore. Calls to getRegion or getOrCreate will work correctly\n-        if (r == null) {\n-          // TODO: one caller of this method only calls it if getRegion returned null. It was\n-          // expecting us to create it locally. If someone else will create it locally then this\n-          // method does not need to be called.\n-          return;\n-        }\n-\n-        if (type == RedisDataType.REDIS_LIST) {\n-          doInitializeList(key, r);\n-        } else if (type == RedisDataType.REDIS_SORTEDSET) {\n-          try {\n-            doInitializeSortedSet(key, r);\n-          } catch (RegionNotFoundException | IndexInvalidException e) {\n-            // ignore\n-          }\n-        }\n-        dynamicRegions.put(key, r);\n-      } finally {\n-        lock.unlock();\n-      }\n-    }\n-  }\n-\n-  private Region<?, ?> getOrCreateRegion0(ByteArrayWrapper key, RedisDataType type,\n-      ExecutionHandlerContext context, boolean addToMeta) {\n-\n-    keyRegistrar.validate(key, type);\n-    Region<Object, Object> r = dynamicRegions.get(key);\n-    if (r != null && r.isDestroyed()) {\n-      removeKey(key, type);\n-      r = null;\n-    }\n-    if (r == null) {\n-      Lock lock = dynamicRegionLocks.get(key);\n-      if (lock == null) {\n-        Lock newLock = new ReentrantLock();\n-        lock = dynamicRegionLocks.putIfAbsent(key, newLock);\n-        if (lock == null) {\n-          lock = newLock;\n-        }\n-      }\n-\n-      lock.lock();\n-      try {\n-        r = dynamicRegions.get(key);\n-        if (r == null) {\n-          boolean hasTransaction = context != null && context.hasTransaction(); // Can create\n-          // without context\n-          CacheTransactionManager txm = null;\n-          TransactionId transactionId = null;\n-          try {\n-            if (hasTransaction) {\n-              txm = cache.getCacheTransactionManager();\n-              transactionId = txm.suspend();\n-            }\n-            Exception concurrentCreateDestroyException;\n-            do {\n-              concurrentCreateDestroyException = null;\n-\n-              r = createRegionGlobally(key.toString());\n-\n-              try {\n-                if (type == RedisDataType.REDIS_LIST) {\n-                  doInitializeList(key, r);\n-                } else if (type == RedisDataType.REDIS_SORTEDSET) {\n-                  try {\n-                    doInitializeSortedSet(key, r);\n-                  } catch (RegionNotFoundException | IndexInvalidException e) {\n-                    concurrentCreateDestroyException = e;\n-                  }\n-                }\n-              } catch (QueryInvalidException e) {\n-                if (e.getCause() instanceof RegionNotFoundException) {\n-                  concurrentCreateDestroyException = e;\n-                }\n-              }\n-            } while (concurrentCreateDestroyException != null);\n-            dynamicRegions.put(key, r);\n-            if (addToMeta) {\n-              keyRegistrar.register(key, type);\n-            }\n-          } finally {\n-            if (hasTransaction) {\n-              txm.resume(transactionId);\n-            }\n-          }\n-        }\n-      } finally {\n-        lock.unlock();\n-      }\n-    }\n-    return r;\n-  }\n-\n-  /**\n-   * SYNCHRONIZE EXTERNALLY OF this.locks.get(key)!!!!!\n-   *\n-   * @param key Key of region to destroy\n-   * @param type Type of region to destroyu\n-   * @return Flag if destroyed\n-   */\n-  private boolean destroyRegion(ByteArrayWrapper key, RedisDataType type) {\n-    Region<?, ?> r = dynamicRegions.get(key);\n-    if (r != null) {\n-      try {\n-        r.destroyRegion();\n-      } catch (Exception e) {\n-        return false;\n-      } finally {\n-        removeRegionState(key, type);\n+      if (cancelExpiration) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "507b9db04a041a943fc28c1c6d0a1ee1e99f97fd"}, "originalPosition": 366}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MjE1MDk4", "url": "https://github.com/apache/geode/pull/5146#pullrequestreview-417215098", "createdAt": "2020-05-22T22:41:01Z", "commit": {"oid": "cda3b559858d7d35bbd24ddcb28c4208d915d2da"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "96719b5042336a0cb46e878aa4fe63f1b629ad6b", "author": {"user": {"login": "dschneider-pivotal", "name": "Darrel Schneider"}}, "url": "https://github.com/apache/geode/commit/96719b5042336a0cb46e878aa4fe63f1b629ad6b", "committedDate": "2020-05-22T23:16:08Z", "message": "removed list and sorted set commands and code\n\nremoved redis HyperLog commands\n\nremoved PROTECTED as a type\n\nremoved redis transaction commands"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cda3b559858d7d35bbd24ddcb28c4208d915d2da", "author": {"user": {"login": "dschneider-pivotal", "name": "Darrel Schneider"}}, "url": "https://github.com/apache/geode/commit/cda3b559858d7d35bbd24ddcb28c4208d915d2da", "committedDate": "2020-05-22T16:46:47Z", "message": "more cleanup of RedisDistDUnitTest and no longer ignore its test methods"}, "afterCommit": {"oid": "96719b5042336a0cb46e878aa4fe63f1b629ad6b", "author": {"user": {"login": "dschneider-pivotal", "name": "Darrel Schneider"}}, "url": "https://github.com/apache/geode/commit/96719b5042336a0cb46e878aa4fe63f1b629ad6b", "committedDate": "2020-05-22T23:16:08Z", "message": "removed list and sorted set commands and code\n\nremoved redis HyperLog commands\n\nremoved PROTECTED as a type\n\nremoved redis transaction commands"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4570, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}