{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA4NTE0ODU0", "number": 5654, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNDoyMjowMFrOEx7G3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNjoxMzoyNlrOEx-hag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNzg0MDkzOnYy", "diffSide": "RIGHT", "path": "geode-redis/src/integrationTest/java/org/apache/geode/redis/internal/executor/string/AbstractIncrIntegrationTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNDoyMjowMFrOHoR1Sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxODowNToyMVrOHocHCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk5NzI1OA==", "bodyText": "Could we change this back to the ERROR_NOT_INTEGER constant? Geode Redis should return the same errors as Redis.", "url": "https://github.com/apache/geode/pull/5654#discussion_r511997258", "createdAt": "2020-10-26T14:22:00Z", "author": {"login": "sabbey37"}, "path": "geode-redis/src/integrationTest/java/org/apache/geode/redis/internal/executor/string/AbstractIncrIntegrationTest.java", "diffHunk": "@@ -104,7 +104,7 @@ public void testIncr_whenWrongType_shouldReturnError() {\n     try {\n       jedis.incr(key);\n     } catch (JedisDataException e) {\n-      assertThat(e.getMessage()).contains(RedisConstants.ERROR_NOT_INTEGER);\n+      assertThat(e.getMessage()).contains(\"out of range\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66bfdbc60e661c6b72f453f4711f00c6729cf842"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE0NTIwMA==", "bodyText": "If our messages are out of sync with native redis shouldn't we be seeing our native acceptance tests failing on this branch? It looks like they all passed. Does this indicate something is wrong with our native redis testing?", "url": "https://github.com/apache/geode/pull/5654#discussion_r512145200", "createdAt": "2020-10-26T17:33:47Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/integrationTest/java/org/apache/geode/redis/internal/executor/string/AbstractIncrIntegrationTest.java", "diffHunk": "@@ -104,7 +104,7 @@ public void testIncr_whenWrongType_shouldReturnError() {\n     try {\n       jedis.incr(key);\n     } catch (JedisDataException e) {\n-      assertThat(e.getMessage()).contains(RedisConstants.ERROR_NOT_INTEGER);\n+      assertThat(e.getMessage()).contains(\"out of range\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk5NzI1OA=="}, "originalCommit": {"oid": "66bfdbc60e661c6b72f453f4711f00c6729cf842"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE2NTY0Mg==", "bodyText": "This one was not out of sync until this PR.  The reason it still passes is because it was changed to only check that the error message contains \"out of range\" rather than the full message \"value is not an integer or out of range\".  I'm sure there are some messages throughout our code that are not the same as Redis, but we haven't found them yet because the commands are not fully tested.", "url": "https://github.com/apache/geode/pull/5654#discussion_r512165642", "createdAt": "2020-10-26T18:05:21Z", "author": {"login": "sabbey37"}, "path": "geode-redis/src/integrationTest/java/org/apache/geode/redis/internal/executor/string/AbstractIncrIntegrationTest.java", "diffHunk": "@@ -104,7 +104,7 @@ public void testIncr_whenWrongType_shouldReturnError() {\n     try {\n       jedis.incr(key);\n     } catch (JedisDataException e) {\n-      assertThat(e.getMessage()).contains(RedisConstants.ERROR_NOT_INTEGER);\n+      assertThat(e.getMessage()).contains(\"out of range\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk5NzI1OA=="}, "originalCommit": {"oid": "66bfdbc60e661c6b72f453f4711f00c6729cf842"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNzkwMTQ1OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/data/RedisString.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNDozMzozOVrOHoSZow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNDozMzozOVrOHoSZow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAwNjU2Mw==", "bodyText": "I definitely understand your thinking here.  However, we want to match the errors returned by Redis, which is why we are returning the not integer error.  We had to use a Java long here instead of an integer because the integer's storage capacity was not large enough, according to the Redis INCR docs the string stored at the key is interpreted as a base-10 64 bit signed integer.", "url": "https://github.com/apache/geode/pull/5654#discussion_r512006563", "createdAt": "2020-10-26T14:33:39Z", "author": {"login": "sabbey37"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/data/RedisString.java", "diffHunk": "@@ -134,7 +132,7 @@ private long parseValueAsLong() {\n     try {\n       return Long.parseLong(value.toString());\n     } catch (NumberFormatException ex) {\n-      throw new NumberFormatException(RedisConstants.ERROR_NOT_INTEGER);\n+      throw new NumberFormatException(RedisConstants.ERROR_NOT_LONG);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66bfdbc60e661c6b72f453f4711f00c6729cf842"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwODEzMDUyOnYy", "diffSide": "RIGHT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/RedisConstants.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNToxODoxNFrOHoUlNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNToxODoxNFrOHoUlNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA0MjI5Mw==", "bodyText": "I don't think Redis ever returns this error.", "url": "https://github.com/apache/geode/pull/5654#discussion_r512042293", "createdAt": "2020-10-26T15:18:14Z", "author": {"login": "sabbey37"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/RedisConstants.java", "diffHunk": "@@ -42,6 +42,7 @@\n   public static final String ERROR_WRONG_TYPE =\n       \"Operation against a key holding the wrong kind of value\";\n   public static final String ERROR_NOT_INTEGER = \"value is not an integer or out of range\";\n+  public static final String ERROR_NOT_LONG = \"value is not a long or out of range\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66bfdbc60e661c6b72f453f4711f00c6729cf842"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwODM5NDM2OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/test/java/org/apache/geode/redis/internal/data/RedisStringTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNjoxMjowMVrOHoXJMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNjoxMjowMVrOHoXJMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA4NDI3Mw==", "bodyText": "This seems to be an error due to the inability to parse the value as a long rather than due to overflow.  We could change the test name or make it error due to overflow instead.", "url": "https://github.com/apache/geode/pull/5654#discussion_r512084273", "createdAt": "2020-10-26T16:12:01Z", "author": {"login": "sabbey37"}, "path": "geode-redis/src/test/java/org/apache/geode/redis/internal/data/RedisStringTest.java", "diffHunk": "@@ -41,16 +42,228 @@ public static void beforeClass() {\n   }\n \n   @Test\n-  public void confirmSerializationIsStable() throws IOException, ClassNotFoundException {\n-    RedisString o1 = new RedisString(new ByteArrayWrapper(new byte[] {0, 1, 2, 3}));\n-    o1.setExpirationTimestampNoDelta(1000);\n+  public void constructorSetsValue() {\n+    ByteArrayWrapper byteArrayWrapper = new ByteArrayWrapper(new byte[] {0, 1, 2});\n+    RedisString string = new RedisString(byteArrayWrapper);\n+    ByteArrayWrapper returnedByteArrayWrapper = string.get();\n+    assertThat(returnedByteArrayWrapper).isNotNull();\n+    assertThat(returnedByteArrayWrapper.value).isEqualTo(byteArrayWrapper.value);\n+  }\n+\n+  @Test\n+  public void setSetsValue() {\n+    RedisString string = new RedisString();\n+    string.set(new ByteArrayWrapper(new byte[] {0, 1, 2}));\n+    ByteArrayWrapper returnedByteArrayWrapper = string.get();\n+    assertThat(returnedByteArrayWrapper).isNotNull();\n+    assertThat(returnedByteArrayWrapper.value)\n+        .isEqualTo(new ByteArrayWrapper(new byte[] {0, 1, 2}).value);\n+  }\n+\n+  @Test\n+  public void getReturnsSetValue() {\n+    RedisString string = new RedisString(new ByteArrayWrapper(new byte[] {0, 1}));\n+    ByteArrayWrapper returnedByteArrayWrapper = string.get();\n+    assertThat(returnedByteArrayWrapper).isNotNull();\n+    assertThat(returnedByteArrayWrapper.value)\n+        .isEqualTo(new ByteArrayWrapper(new byte[] {0, 1}).value);\n+  }\n+\n+  @Test\n+  public void appendResizesByteArray() {\n+    // allows unchecked cast of mock to Region<ByteArrayWrapper, RedisData>\n+    @SuppressWarnings(\"unchecked\")\n+    Region<ByteArrayWrapper, RedisData> region = mock(Region.class);\n+    RedisString redisString = new RedisString(new ByteArrayWrapper(new byte[] {0, 1}));\n+    ByteArrayWrapper part2 = new ByteArrayWrapper(new byte[] {2, 3, 4, 5});\n+    int redisStringSize = redisString.strlen();\n+    int part2Size = part2.length();\n+    int appendedStringSize = redisString.append(part2, region, null);\n+    assertThat(appendedStringSize).isEqualTo(redisStringSize + part2Size);\n+  }\n+\n+  @Test\n+  public void appendStoresStableDelta() throws IOException {\n+    // allows unchecked cast of mock to Region<ByteArrayWrapper, RedisData>\n+    @SuppressWarnings(\"unchecked\")\n+    Region<ByteArrayWrapper, RedisData> region = mock(Region.class);\n+    RedisString o1 = new RedisString(new ByteArrayWrapper(new byte[] {0, 1}));\n+    ByteArrayWrapper part2 = new ByteArrayWrapper(new byte[] {2, 3});\n+    o1.append(part2, region, null);\n+    assertThat(o1.hasDelta()).isTrue();\n+    assertThat(o1.get()).isEqualTo(new ByteArrayWrapper(new byte[] {0, 1, 2, 3}));\n     HeapDataOutputStream out = new HeapDataOutputStream(100);\n-    DataSerializer.writeObject(o1, out);\n+    o1.toDelta(out);\n+    assertThat(o1.hasDelta()).isFalse();\n     ByteArrayDataInput in = new ByteArrayDataInput(out.toByteArray());\n-    RedisString o2 = DataSerializer.readObject(in);\n+    RedisString o2 = new RedisString(new ByteArrayWrapper(new byte[] {0, 1}));\n+    assertThat(o2).isNotEqualTo(o1);\n+    o2.fromDelta(in);\n+    assertThat(o2.get()).isEqualTo(new ByteArrayWrapper(new byte[] {0, 1, 2, 3}));\n     assertThat(o2).isEqualTo(o1);\n   }\n \n+  @Test\n+  public void serializationIsStable() throws IOException, ClassNotFoundException {\n+    RedisString o1 = new RedisString(new ByteArrayWrapper(new byte[] {0, 1, 2, 3}));\n+    o1.setExpirationTimestampNoDelta(1000);\n+    HeapDataOutputStream outputStream = new HeapDataOutputStream(100);\n+    DataSerializer.writeObject(o1, outputStream);\n+    ByteArrayDataInput dataInput = new ByteArrayDataInput(outputStream.toByteArray());\n+    RedisString o2 = DataSerializer.readObject(dataInput);\n+    assertThat(o2).isEqualTo(o1);\n+  }\n+\n+  @Test\n+  public void incrThrowsArithmeticErrorWhenNotALong() {\n+    // allows unchecked cast of mock to Region<ByteArrayWrapper, RedisData>\n+    @SuppressWarnings(\"unchecked\")\n+    Region<ByteArrayWrapper, RedisData> region = mock(Region.class);\n+    ByteArrayWrapper byteArrayWrapper = new ByteArrayWrapper(new byte[] {'1', '0', ' ', '1'});\n+    RedisString string = new RedisString(byteArrayWrapper);\n+    assertThatThrownBy(() -> string.incr(region, byteArrayWrapper))\n+        .isInstanceOf(NumberFormatException.class);\n+  }\n+\n+  @Test\n+  public void incrErrorsWhenValueOverflows() {\n+    // allows unchecked cast of mock to Region<ByteArrayWrapper, RedisData>\n+    @SuppressWarnings(\"unchecked\")\n+    Region<ByteArrayWrapper, RedisData> region = mock(Region.class);\n+    ByteArrayWrapper byteArrayWrapper = new ByteArrayWrapper(\n+        // max value for signed long\n+        new byte[] {'9', '2', '2', '3', '3', '7', '2', '0', '3', '6', '8', '5', '4', '7', '7', '5',\n+            '8', '0', '7'});\n+    RedisString string = new RedisString(byteArrayWrapper);\n+    assertThatThrownBy(() -> string.incr(region, byteArrayWrapper))\n+        .isInstanceOf(ArithmeticException.class);\n+  }\n+\n+  @Test\n+  public void incrIncrementsValueAtGivenKey() {\n+    // allows unchecked cast of mock to Region<ByteArrayWrapper, RedisData>\n+    @SuppressWarnings(\"unchecked\")\n+    Region<ByteArrayWrapper, RedisData> region = mock(Region.class);\n+    ByteArrayWrapper byteArrayWrapper = new ByteArrayWrapper(new byte[] {'1', '0'});\n+    RedisString string = new RedisString(byteArrayWrapper);\n+    string.incr(region, byteArrayWrapper);\n+    assertThat(string.get().toString()).isEqualTo(\"11\");\n+  }\n+\n+  @Test\n+  public void incrbyThrowsNumberFormatExceptionWhenNotALong() {\n+    // allows unchecked cast of mock to Region<ByteArrayWrapper, RedisData>\n+    @SuppressWarnings(\"unchecked\")\n+    Region<ByteArrayWrapper, RedisData> region = mock(Region.class);\n+    ByteArrayWrapper byteArrayWrapper = new ByteArrayWrapper(new byte[] {'1', '0', ' ', '1'});\n+    RedisString string = new RedisString(byteArrayWrapper);\n+    assertThatThrownBy(() -> string.incrby(region, byteArrayWrapper, 2L))\n+        .isInstanceOf(NumberFormatException.class);\n+  }\n+\n+  @Test\n+  public void incrbyErrorsWhenValueOverflows() {\n+    // allows unchecked cast of mock to Region<ByteArrayWrapper, RedisData>\n+    @SuppressWarnings(\"unchecked\")\n+    Region<ByteArrayWrapper, RedisData> region = mock(Region.class);\n+    ByteArrayWrapper byteArrayWrapper = new ByteArrayWrapper(\n+        // max value for signed long\n+        new byte[] {'9', '2', '2', '3', '3', '7', '2', '0', '3', '6', '8', '5', '4', '7', '7', '5',\n+            '8', '0', '7'});\n+    RedisString string = new RedisString(byteArrayWrapper);\n+    assertThatThrownBy(() -> string.incrby(region, byteArrayWrapper, 2L))\n+        .isInstanceOf(ArithmeticException.class);\n+  }\n+\n+  @Test\n+  public void incrbyIncrementsValueByGivenLong() {\n+    // allows unchecked cast of mock to Region<ByteArrayWrapper, RedisData>\n+    @SuppressWarnings(\"unchecked\")\n+    Region<ByteArrayWrapper, RedisData> region = mock(Region.class);\n+    ByteArrayWrapper byteArrayWrapper = new ByteArrayWrapper(new byte[] {'1', '0'});\n+    RedisString string = new RedisString(byteArrayWrapper);\n+    string.incrby(region, byteArrayWrapper, 2L);\n+    assertThat(string.get().toString()).isEqualTo(\"12\");\n+  }\n+\n+  @Test\n+  public void incrbyfloatThrowsArithmeticErrorWhenNotADouble() {\n+    // allows unchecked cast of mock to Region<ByteArrayWrapper, RedisData>\n+    @SuppressWarnings(\"unchecked\")\n+    Region<ByteArrayWrapper, RedisData> region = mock(Region.class);\n+    ByteArrayWrapper byteArrayWrapper = new ByteArrayWrapper(new byte[] {'1', '0', ' ', '1'});\n+    RedisString string = new RedisString(byteArrayWrapper);\n+    assertThatThrownBy(() -> string.incrbyfloat(region, byteArrayWrapper, 1.1))\n+        .isInstanceOf(NumberFormatException.class);\n+  }\n+\n+  @Test\n+  public void incrbyfloatIncrementsValueByGivenFloat() {\n+    // allows unchecked cast of mock to Region<ByteArrayWrapper, RedisData>\n+    @SuppressWarnings(\"unchecked\")\n+    Region<ByteArrayWrapper, RedisData> region = mock(Region.class);\n+    ByteArrayWrapper byteArrayWrapper = new ByteArrayWrapper(new byte[] {'1', '0'});\n+    RedisString string = new RedisString(byteArrayWrapper);\n+    string.incrbyfloat(region, byteArrayWrapper, 2.20);\n+    assertThat(string.get().toString()).isEqualTo(\"12.2\");\n+  }\n+\n+  @Test\n+  public void decrErrorsWhenOverflows() {\n+    // allows unchecked cast of mock to Region<ByteArrayWrapper, RedisData>\n+    @SuppressWarnings(\"unchecked\")\n+    Region<ByteArrayWrapper, RedisData> region = mock(Region.class);\n+    ByteArrayWrapper byteArrayWrapper = new ByteArrayWrapper(new byte[] {0});\n+    RedisString string = new RedisString(byteArrayWrapper);\n+    assertThatThrownBy(() -> string.decr(region, byteArrayWrapper))\n+        .isInstanceOf(NumberFormatException.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66bfdbc60e661c6b72f453f4711f00c6729cf842"}, "originalPosition": 191}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwODQwMDQyOnYy", "diffSide": "RIGHT", "path": "geode-redis/src/test/java/org/apache/geode/redis/internal/data/RedisStringTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNjoxMzoyNlrOHoXM0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNjoxMzoyNlrOHoXM0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA4NTIwMw==", "bodyText": "This also seems to be an error due to the inability to parse the value as a long rather than due to overflow. We could change the test name or make it error due to overflow instead.", "url": "https://github.com/apache/geode/pull/5654#discussion_r512085203", "createdAt": "2020-10-26T16:13:26Z", "author": {"login": "sabbey37"}, "path": "geode-redis/src/test/java/org/apache/geode/redis/internal/data/RedisStringTest.java", "diffHunk": "@@ -41,16 +42,228 @@ public static void beforeClass() {\n   }\n \n   @Test\n-  public void confirmSerializationIsStable() throws IOException, ClassNotFoundException {\n-    RedisString o1 = new RedisString(new ByteArrayWrapper(new byte[] {0, 1, 2, 3}));\n-    o1.setExpirationTimestampNoDelta(1000);\n+  public void constructorSetsValue() {\n+    ByteArrayWrapper byteArrayWrapper = new ByteArrayWrapper(new byte[] {0, 1, 2});\n+    RedisString string = new RedisString(byteArrayWrapper);\n+    ByteArrayWrapper returnedByteArrayWrapper = string.get();\n+    assertThat(returnedByteArrayWrapper).isNotNull();\n+    assertThat(returnedByteArrayWrapper.value).isEqualTo(byteArrayWrapper.value);\n+  }\n+\n+  @Test\n+  public void setSetsValue() {\n+    RedisString string = new RedisString();\n+    string.set(new ByteArrayWrapper(new byte[] {0, 1, 2}));\n+    ByteArrayWrapper returnedByteArrayWrapper = string.get();\n+    assertThat(returnedByteArrayWrapper).isNotNull();\n+    assertThat(returnedByteArrayWrapper.value)\n+        .isEqualTo(new ByteArrayWrapper(new byte[] {0, 1, 2}).value);\n+  }\n+\n+  @Test\n+  public void getReturnsSetValue() {\n+    RedisString string = new RedisString(new ByteArrayWrapper(new byte[] {0, 1}));\n+    ByteArrayWrapper returnedByteArrayWrapper = string.get();\n+    assertThat(returnedByteArrayWrapper).isNotNull();\n+    assertThat(returnedByteArrayWrapper.value)\n+        .isEqualTo(new ByteArrayWrapper(new byte[] {0, 1}).value);\n+  }\n+\n+  @Test\n+  public void appendResizesByteArray() {\n+    // allows unchecked cast of mock to Region<ByteArrayWrapper, RedisData>\n+    @SuppressWarnings(\"unchecked\")\n+    Region<ByteArrayWrapper, RedisData> region = mock(Region.class);\n+    RedisString redisString = new RedisString(new ByteArrayWrapper(new byte[] {0, 1}));\n+    ByteArrayWrapper part2 = new ByteArrayWrapper(new byte[] {2, 3, 4, 5});\n+    int redisStringSize = redisString.strlen();\n+    int part2Size = part2.length();\n+    int appendedStringSize = redisString.append(part2, region, null);\n+    assertThat(appendedStringSize).isEqualTo(redisStringSize + part2Size);\n+  }\n+\n+  @Test\n+  public void appendStoresStableDelta() throws IOException {\n+    // allows unchecked cast of mock to Region<ByteArrayWrapper, RedisData>\n+    @SuppressWarnings(\"unchecked\")\n+    Region<ByteArrayWrapper, RedisData> region = mock(Region.class);\n+    RedisString o1 = new RedisString(new ByteArrayWrapper(new byte[] {0, 1}));\n+    ByteArrayWrapper part2 = new ByteArrayWrapper(new byte[] {2, 3});\n+    o1.append(part2, region, null);\n+    assertThat(o1.hasDelta()).isTrue();\n+    assertThat(o1.get()).isEqualTo(new ByteArrayWrapper(new byte[] {0, 1, 2, 3}));\n     HeapDataOutputStream out = new HeapDataOutputStream(100);\n-    DataSerializer.writeObject(o1, out);\n+    o1.toDelta(out);\n+    assertThat(o1.hasDelta()).isFalse();\n     ByteArrayDataInput in = new ByteArrayDataInput(out.toByteArray());\n-    RedisString o2 = DataSerializer.readObject(in);\n+    RedisString o2 = new RedisString(new ByteArrayWrapper(new byte[] {0, 1}));\n+    assertThat(o2).isNotEqualTo(o1);\n+    o2.fromDelta(in);\n+    assertThat(o2.get()).isEqualTo(new ByteArrayWrapper(new byte[] {0, 1, 2, 3}));\n     assertThat(o2).isEqualTo(o1);\n   }\n \n+  @Test\n+  public void serializationIsStable() throws IOException, ClassNotFoundException {\n+    RedisString o1 = new RedisString(new ByteArrayWrapper(new byte[] {0, 1, 2, 3}));\n+    o1.setExpirationTimestampNoDelta(1000);\n+    HeapDataOutputStream outputStream = new HeapDataOutputStream(100);\n+    DataSerializer.writeObject(o1, outputStream);\n+    ByteArrayDataInput dataInput = new ByteArrayDataInput(outputStream.toByteArray());\n+    RedisString o2 = DataSerializer.readObject(dataInput);\n+    assertThat(o2).isEqualTo(o1);\n+  }\n+\n+  @Test\n+  public void incrThrowsArithmeticErrorWhenNotALong() {\n+    // allows unchecked cast of mock to Region<ByteArrayWrapper, RedisData>\n+    @SuppressWarnings(\"unchecked\")\n+    Region<ByteArrayWrapper, RedisData> region = mock(Region.class);\n+    ByteArrayWrapper byteArrayWrapper = new ByteArrayWrapper(new byte[] {'1', '0', ' ', '1'});\n+    RedisString string = new RedisString(byteArrayWrapper);\n+    assertThatThrownBy(() -> string.incr(region, byteArrayWrapper))\n+        .isInstanceOf(NumberFormatException.class);\n+  }\n+\n+  @Test\n+  public void incrErrorsWhenValueOverflows() {\n+    // allows unchecked cast of mock to Region<ByteArrayWrapper, RedisData>\n+    @SuppressWarnings(\"unchecked\")\n+    Region<ByteArrayWrapper, RedisData> region = mock(Region.class);\n+    ByteArrayWrapper byteArrayWrapper = new ByteArrayWrapper(\n+        // max value for signed long\n+        new byte[] {'9', '2', '2', '3', '3', '7', '2', '0', '3', '6', '8', '5', '4', '7', '7', '5',\n+            '8', '0', '7'});\n+    RedisString string = new RedisString(byteArrayWrapper);\n+    assertThatThrownBy(() -> string.incr(region, byteArrayWrapper))\n+        .isInstanceOf(ArithmeticException.class);\n+  }\n+\n+  @Test\n+  public void incrIncrementsValueAtGivenKey() {\n+    // allows unchecked cast of mock to Region<ByteArrayWrapper, RedisData>\n+    @SuppressWarnings(\"unchecked\")\n+    Region<ByteArrayWrapper, RedisData> region = mock(Region.class);\n+    ByteArrayWrapper byteArrayWrapper = new ByteArrayWrapper(new byte[] {'1', '0'});\n+    RedisString string = new RedisString(byteArrayWrapper);\n+    string.incr(region, byteArrayWrapper);\n+    assertThat(string.get().toString()).isEqualTo(\"11\");\n+  }\n+\n+  @Test\n+  public void incrbyThrowsNumberFormatExceptionWhenNotALong() {\n+    // allows unchecked cast of mock to Region<ByteArrayWrapper, RedisData>\n+    @SuppressWarnings(\"unchecked\")\n+    Region<ByteArrayWrapper, RedisData> region = mock(Region.class);\n+    ByteArrayWrapper byteArrayWrapper = new ByteArrayWrapper(new byte[] {'1', '0', ' ', '1'});\n+    RedisString string = new RedisString(byteArrayWrapper);\n+    assertThatThrownBy(() -> string.incrby(region, byteArrayWrapper, 2L))\n+        .isInstanceOf(NumberFormatException.class);\n+  }\n+\n+  @Test\n+  public void incrbyErrorsWhenValueOverflows() {\n+    // allows unchecked cast of mock to Region<ByteArrayWrapper, RedisData>\n+    @SuppressWarnings(\"unchecked\")\n+    Region<ByteArrayWrapper, RedisData> region = mock(Region.class);\n+    ByteArrayWrapper byteArrayWrapper = new ByteArrayWrapper(\n+        // max value for signed long\n+        new byte[] {'9', '2', '2', '3', '3', '7', '2', '0', '3', '6', '8', '5', '4', '7', '7', '5',\n+            '8', '0', '7'});\n+    RedisString string = new RedisString(byteArrayWrapper);\n+    assertThatThrownBy(() -> string.incrby(region, byteArrayWrapper, 2L))\n+        .isInstanceOf(ArithmeticException.class);\n+  }\n+\n+  @Test\n+  public void incrbyIncrementsValueByGivenLong() {\n+    // allows unchecked cast of mock to Region<ByteArrayWrapper, RedisData>\n+    @SuppressWarnings(\"unchecked\")\n+    Region<ByteArrayWrapper, RedisData> region = mock(Region.class);\n+    ByteArrayWrapper byteArrayWrapper = new ByteArrayWrapper(new byte[] {'1', '0'});\n+    RedisString string = new RedisString(byteArrayWrapper);\n+    string.incrby(region, byteArrayWrapper, 2L);\n+    assertThat(string.get().toString()).isEqualTo(\"12\");\n+  }\n+\n+  @Test\n+  public void incrbyfloatThrowsArithmeticErrorWhenNotADouble() {\n+    // allows unchecked cast of mock to Region<ByteArrayWrapper, RedisData>\n+    @SuppressWarnings(\"unchecked\")\n+    Region<ByteArrayWrapper, RedisData> region = mock(Region.class);\n+    ByteArrayWrapper byteArrayWrapper = new ByteArrayWrapper(new byte[] {'1', '0', ' ', '1'});\n+    RedisString string = new RedisString(byteArrayWrapper);\n+    assertThatThrownBy(() -> string.incrbyfloat(region, byteArrayWrapper, 1.1))\n+        .isInstanceOf(NumberFormatException.class);\n+  }\n+\n+  @Test\n+  public void incrbyfloatIncrementsValueByGivenFloat() {\n+    // allows unchecked cast of mock to Region<ByteArrayWrapper, RedisData>\n+    @SuppressWarnings(\"unchecked\")\n+    Region<ByteArrayWrapper, RedisData> region = mock(Region.class);\n+    ByteArrayWrapper byteArrayWrapper = new ByteArrayWrapper(new byte[] {'1', '0'});\n+    RedisString string = new RedisString(byteArrayWrapper);\n+    string.incrbyfloat(region, byteArrayWrapper, 2.20);\n+    assertThat(string.get().toString()).isEqualTo(\"12.2\");\n+  }\n+\n+  @Test\n+  public void decrErrorsWhenOverflows() {\n+    // allows unchecked cast of mock to Region<ByteArrayWrapper, RedisData>\n+    @SuppressWarnings(\"unchecked\")\n+    Region<ByteArrayWrapper, RedisData> region = mock(Region.class);\n+    ByteArrayWrapper byteArrayWrapper = new ByteArrayWrapper(new byte[] {0});\n+    RedisString string = new RedisString(byteArrayWrapper);\n+    assertThatThrownBy(() -> string.decr(region, byteArrayWrapper))\n+        .isInstanceOf(NumberFormatException.class);\n+  }\n+\n+  @Test\n+  public void decrDecrementsValue() {\n+    // allows unchecked cast of mock to Region<ByteArrayWrapper, RedisData>\n+    @SuppressWarnings(\"unchecked\")\n+    Region<ByteArrayWrapper, RedisData> region = mock(Region.class);\n+    ByteArrayWrapper byteArrayWrapper = new ByteArrayWrapper(new byte[] {'1', '0'});\n+    RedisString string = new RedisString(byteArrayWrapper);\n+    string.decr(region, byteArrayWrapper);\n+    assertThat(string.get().toString()).isEqualTo(\"9\");\n+  }\n+\n+  @Test\n+  public void decrbyErrorsWhenOverflows() {\n+    // allows unchecked cast of mock to Region<ByteArrayWrapper, RedisData>\n+    @SuppressWarnings(\"unchecked\")\n+    Region<ByteArrayWrapper, RedisData> region = mock(Region.class);\n+    ByteArrayWrapper byteArrayWrapper = new ByteArrayWrapper(new byte[] {1});\n+    RedisString string = new RedisString(byteArrayWrapper);\n+    assertThatThrownBy(() -> string.decrby(region, byteArrayWrapper, 2))\n+        .isInstanceOf(NumberFormatException.class);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66bfdbc60e661c6b72f453f4711f00c6729cf842"}, "originalPosition": 214}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4573, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}