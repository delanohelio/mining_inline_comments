{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxNjgzNTU1", "number": 4938, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQyMTo1MDo0MVrODw3sJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQyMjowMDoxMVrODw3zxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNTcwNjYzOnYy", "diffSide": "RIGHT", "path": "geode-assembly/src/acceptanceTest/java/org/apache/geode/client/sni/ClientSNIAcceptanceTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQyMTo1MDo0MVrOGEGyDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNjoxMDoyMFrOGErjrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk1ODYwNQ==", "bodyText": "Should this code just be enabled by default so we have the logs in CI?", "url": "https://github.com/apache/geode/pull/4938#discussion_r406958605", "createdAt": "2020-04-10T21:50:41Z", "author": {"login": "upthewaterspout"}, "path": "geode-assembly/src/acceptanceTest/java/org/apache/geode/client/sni/ClientSNIAcceptanceTest.java", "diffHunk": "@@ -58,50 +64,143 @@\n       .file(DOCKER_COMPOSE_PATH.getPath())\n       .build();\n \n-\n-  private String trustStorePath;\n+  private ClientCache cache;\n+  private Region<String, String> region;\n+  private Map<String, String> bulkData;\n \n   @Before\n   public void before() throws IOException, InterruptedException {\n-    trustStorePath =\n+    // start up server/locator processes and initialize the server cache\n+    docker.exec(options(\"-T\"), \"geode\",\n+        arguments(\"gfsh\", \"run\", \"--file=/geode/scripts/geode-starter.gfsh\"));\n+\n+    final String trustStorePath =\n         createTempFileFromResource(ClientSNIAcceptanceTest.class,\n             \"geode-config/truststore.jks\")\n                 .getAbsolutePath();\n-    docker.exec(options(\"-T\"), \"geode\",\n-        arguments(\"gfsh\", \"run\", \"--file=/geode/scripts/geode-starter.gfsh\"));\n+\n+    // set up client cache properties so it can connect to the server\n+    Properties clientCacheProperties = new Properties();\n+    clientCacheProperties.setProperty(SSL_ENABLED_COMPONENTS, \"all\");\n+    clientCacheProperties.setProperty(SSL_KEYSTORE_TYPE, \"jks\");\n+    clientCacheProperties.setProperty(SSL_REQUIRE_AUTHENTICATION, \"false\");\n+\n+    clientCacheProperties.setProperty(SSL_TRUSTSTORE, trustStorePath);\n+    clientCacheProperties.setProperty(SSL_TRUSTSTORE_PASSWORD, \"geode\");\n+    clientCacheProperties.setProperty(SSL_ENDPOINT_IDENTIFICATION_ENABLED, \"true\");\n+    cache = getClientCache(clientCacheProperties);\n+\n+    // the gfsh startup script created a server-side region named \"jellyfish\"\n+    region = cache.<String, String>createClientRegionFactory(ClientRegionShortcut.PROXY)\n+        .create(\"jellyfish\");\n+    bulkData = getBulkDataMap();\n+    region.putAll(bulkData);\n+  }\n+\n+  @After\n+  public void after() {\n+    // preserve this commented code for debugging\n+    // String logs = docker.exec(options(\"-T\"), \"geode\",\n+    // arguments(\"cat\", \"server-dolores/server-dolores.log\"));\n+    // System.out.println(\"server logs------------------------------------------\");\n+    // System.out.println(logs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "649f0a72fa8aaaed75100818edb3825b4fc2d729"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU2MTEzMw==", "bodyText": "done", "url": "https://github.com/apache/geode/pull/4938#discussion_r407561133", "createdAt": "2020-04-13T16:10:20Z", "author": {"login": "bschuchardt"}, "path": "geode-assembly/src/acceptanceTest/java/org/apache/geode/client/sni/ClientSNIAcceptanceTest.java", "diffHunk": "@@ -58,50 +64,143 @@\n       .file(DOCKER_COMPOSE_PATH.getPath())\n       .build();\n \n-\n-  private String trustStorePath;\n+  private ClientCache cache;\n+  private Region<String, String> region;\n+  private Map<String, String> bulkData;\n \n   @Before\n   public void before() throws IOException, InterruptedException {\n-    trustStorePath =\n+    // start up server/locator processes and initialize the server cache\n+    docker.exec(options(\"-T\"), \"geode\",\n+        arguments(\"gfsh\", \"run\", \"--file=/geode/scripts/geode-starter.gfsh\"));\n+\n+    final String trustStorePath =\n         createTempFileFromResource(ClientSNIAcceptanceTest.class,\n             \"geode-config/truststore.jks\")\n                 .getAbsolutePath();\n-    docker.exec(options(\"-T\"), \"geode\",\n-        arguments(\"gfsh\", \"run\", \"--file=/geode/scripts/geode-starter.gfsh\"));\n+\n+    // set up client cache properties so it can connect to the server\n+    Properties clientCacheProperties = new Properties();\n+    clientCacheProperties.setProperty(SSL_ENABLED_COMPONENTS, \"all\");\n+    clientCacheProperties.setProperty(SSL_KEYSTORE_TYPE, \"jks\");\n+    clientCacheProperties.setProperty(SSL_REQUIRE_AUTHENTICATION, \"false\");\n+\n+    clientCacheProperties.setProperty(SSL_TRUSTSTORE, trustStorePath);\n+    clientCacheProperties.setProperty(SSL_TRUSTSTORE_PASSWORD, \"geode\");\n+    clientCacheProperties.setProperty(SSL_ENDPOINT_IDENTIFICATION_ENABLED, \"true\");\n+    cache = getClientCache(clientCacheProperties);\n+\n+    // the gfsh startup script created a server-side region named \"jellyfish\"\n+    region = cache.<String, String>createClientRegionFactory(ClientRegionShortcut.PROXY)\n+        .create(\"jellyfish\");\n+    bulkData = getBulkDataMap();\n+    region.putAll(bulkData);\n+  }\n+\n+  @After\n+  public void after() {\n+    // preserve this commented code for debugging\n+    // String logs = docker.exec(options(\"-T\"), \"geode\",\n+    // arguments(\"cat\", \"server-dolores/server-dolores.log\"));\n+    // System.out.println(\"server logs------------------------------------------\");\n+    // System.out.println(logs);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk1ODYwNQ=="}, "originalCommit": {"oid": "649f0a72fa8aaaed75100818edb3825b4fc2d729"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNTcwODA3OnYy", "diffSide": "RIGHT", "path": "geode-assembly/src/acceptanceTest/java/org/apache/geode/client/sni/ClientSNIAcceptanceTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQyMTo1MToyNlrOGEGy3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQyMjoyMDowMVrOGEHRLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk1ODgxMw==", "bodyText": "Is this comment correct? When I look at MAXIMUM_CHUNK_SIZE I see it defaults to 100. If that's the value it has then numberOfKeys would be 1000", "url": "https://github.com/apache/geode/pull/4938#discussion_r406958813", "createdAt": "2020-04-10T21:51:26Z", "author": {"login": "Bill"}, "path": "geode-assembly/src/acceptanceTest/java/org/apache/geode/client/sni/ClientSNIAcceptanceTest.java", "diffHunk": "@@ -58,50 +64,143 @@\n       .file(DOCKER_COMPOSE_PATH.getPath())\n       .build();\n \n-\n-  private String trustStorePath;\n+  private ClientCache cache;\n+  private Region<String, String> region;\n+  private Map<String, String> bulkData;\n \n   @Before\n   public void before() throws IOException, InterruptedException {\n-    trustStorePath =\n+    // start up server/locator processes and initialize the server cache\n+    docker.exec(options(\"-T\"), \"geode\",\n+        arguments(\"gfsh\", \"run\", \"--file=/geode/scripts/geode-starter.gfsh\"));\n+\n+    final String trustStorePath =\n         createTempFileFromResource(ClientSNIAcceptanceTest.class,\n             \"geode-config/truststore.jks\")\n                 .getAbsolutePath();\n-    docker.exec(options(\"-T\"), \"geode\",\n-        arguments(\"gfsh\", \"run\", \"--file=/geode/scripts/geode-starter.gfsh\"));\n+\n+    // set up client cache properties so it can connect to the server\n+    Properties clientCacheProperties = new Properties();\n+    clientCacheProperties.setProperty(SSL_ENABLED_COMPONENTS, \"all\");\n+    clientCacheProperties.setProperty(SSL_KEYSTORE_TYPE, \"jks\");\n+    clientCacheProperties.setProperty(SSL_REQUIRE_AUTHENTICATION, \"false\");\n+\n+    clientCacheProperties.setProperty(SSL_TRUSTSTORE, trustStorePath);\n+    clientCacheProperties.setProperty(SSL_TRUSTSTORE_PASSWORD, \"geode\");\n+    clientCacheProperties.setProperty(SSL_ENDPOINT_IDENTIFICATION_ENABLED, \"true\");\n+    cache = getClientCache(clientCacheProperties);\n+\n+    // the gfsh startup script created a server-side region named \"jellyfish\"\n+    region = cache.<String, String>createClientRegionFactory(ClientRegionShortcut.PROXY)\n+        .create(\"jellyfish\");\n+    bulkData = getBulkDataMap();\n+    region.putAll(bulkData);\n+  }\n+\n+  @After\n+  public void after() {\n+    // preserve this commented code for debugging\n+    // String logs = docker.exec(options(\"-T\"), \"geode\",\n+    // arguments(\"cat\", \"server-dolores/server-dolores.log\"));\n+    // System.out.println(\"server logs------------------------------------------\");\n+    // System.out.println(logs);\n+\n+    if (cache != null) {\n+      cache.close();\n+      cache = null;\n+    }\n+    bulkData = null;\n+    region = null;\n   }\n \n+  // run all tests in one @Test to avoid having to stage a new Docker cluster for each\n   @Test\n+  public void runAllTests() throws Exception {\n+    connectToSNIProxyDocker();\n+    verifyServerAPIs();\n+    query();\n+    getAll();\n+    removeAll();\n+  }\n+\n+  /**\n+   * A basic connectivity test that performs a few simple operations\n+   */\n   public void connectToSNIProxyDocker() {\n-    Properties gemFireProps = new Properties();\n-    gemFireProps.setProperty(SSL_ENABLED_COMPONENTS, \"all\");\n-    gemFireProps.setProperty(SSL_KEYSTORE_TYPE, \"jks\");\n-    gemFireProps.setProperty(SSL_REQUIRE_AUTHENTICATION, \"false\");\n+    region.put(\"hello\", \"world\");\n+    assertThat(region.containsKey(\"hello\")).isFalse(); // proxy regions don't store locally\n+    assertThat(region.get(\"hello\")).isEqualTo(\"world\");\n+    region.destroy(\"hello\");\n+    assertThat(region.get(\"hello\")).isNull();\n+  }\n+\n+  /**\n+   * A test of Region query that returns a \"big\" result\n+   */\n+  public void query() throws Exception {\n+    final SelectResults<String> results = region.query(\"SELECT * from /jellyfish\");\n+    assertThat(results).hasSize(bulkData.size());\n+    for (String result : results) {\n+      assertThat(bulkData.containsValue(result)).isTrue();\n+    }\n+  }\n+\n+  /**\n+   * A test of Region bulk getAll\n+   */\n+  public void getAll() {\n+    final Map<String, String> results = region.getAll(bulkData.keySet());\n+    assertThat(results).hasSize(bulkData.size());\n+    for (Map.Entry<String, String> entry : results.entrySet()) {\n+      assertThat(region.containsKey(entry.getKey())).isFalse();\n+      assertThat(bulkData.containsKey(entry.getKey())).isTrue();\n+      assertThat(entry.getValue()).isEqualTo(bulkData.get(entry.getKey()));\n+    }\n+  }\n+\n+  /**\n+   * A test of Region bulk removeAll\n+   */\n+  public void removeAll() {\n+    assertThat(region.sizeOnServer()).isEqualTo(bulkData.size());\n+    region.removeAll(bulkData.keySet());\n+    assertThat(region.sizeOnServer()).isZero();\n+    region.putAll(bulkData);\n+  }\n \n-    gemFireProps.setProperty(SSL_TRUSTSTORE, trustStorePath);\n-    gemFireProps.setProperty(SSL_TRUSTSTORE_PASSWORD, \"geode\");\n-    gemFireProps.setProperty(SSL_ENDPOINT_IDENTIFICATION_ENABLED, \"true\");\n+  /**\n+   * A test of the Region API's methods that directly access the server cache\n+   */\n+  public void verifyServerAPIs() {\n+    assertThat(region.sizeOnServer()).isEqualTo(bulkData.size());\n+    Set<String> keysOnServer = region.keySetOnServer();\n+    for (String entry : bulkData.keySet()) {\n+      assertThat(region.containsKeyOnServer(entry)).isTrue();\n+      assertThat(keysOnServer).contains(entry);\n+    }\n+  }\n+\n+\n+  protected Map<String, String> getBulkDataMap() {\n+    // create a putAll map with enough keys to force a lot of \"chunking\" of the results\n+    int numberOfKeys = BaseCommand.MAXIMUM_CHUNK_SIZE * 10; // 10,000 keys", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "649f0a72fa8aaaed75100818edb3825b4fc2d729"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk2MjI5Ng==", "bodyText": "oh, yeah.  I had that set to * 100 but lowered it.  I'll fix the comment.  It only needs to be > MAXIMUM_CHUNK_SIZE", "url": "https://github.com/apache/geode/pull/4938#discussion_r406962296", "createdAt": "2020-04-10T22:03:17Z", "author": {"login": "bschuchardt"}, "path": "geode-assembly/src/acceptanceTest/java/org/apache/geode/client/sni/ClientSNIAcceptanceTest.java", "diffHunk": "@@ -58,50 +64,143 @@\n       .file(DOCKER_COMPOSE_PATH.getPath())\n       .build();\n \n-\n-  private String trustStorePath;\n+  private ClientCache cache;\n+  private Region<String, String> region;\n+  private Map<String, String> bulkData;\n \n   @Before\n   public void before() throws IOException, InterruptedException {\n-    trustStorePath =\n+    // start up server/locator processes and initialize the server cache\n+    docker.exec(options(\"-T\"), \"geode\",\n+        arguments(\"gfsh\", \"run\", \"--file=/geode/scripts/geode-starter.gfsh\"));\n+\n+    final String trustStorePath =\n         createTempFileFromResource(ClientSNIAcceptanceTest.class,\n             \"geode-config/truststore.jks\")\n                 .getAbsolutePath();\n-    docker.exec(options(\"-T\"), \"geode\",\n-        arguments(\"gfsh\", \"run\", \"--file=/geode/scripts/geode-starter.gfsh\"));\n+\n+    // set up client cache properties so it can connect to the server\n+    Properties clientCacheProperties = new Properties();\n+    clientCacheProperties.setProperty(SSL_ENABLED_COMPONENTS, \"all\");\n+    clientCacheProperties.setProperty(SSL_KEYSTORE_TYPE, \"jks\");\n+    clientCacheProperties.setProperty(SSL_REQUIRE_AUTHENTICATION, \"false\");\n+\n+    clientCacheProperties.setProperty(SSL_TRUSTSTORE, trustStorePath);\n+    clientCacheProperties.setProperty(SSL_TRUSTSTORE_PASSWORD, \"geode\");\n+    clientCacheProperties.setProperty(SSL_ENDPOINT_IDENTIFICATION_ENABLED, \"true\");\n+    cache = getClientCache(clientCacheProperties);\n+\n+    // the gfsh startup script created a server-side region named \"jellyfish\"\n+    region = cache.<String, String>createClientRegionFactory(ClientRegionShortcut.PROXY)\n+        .create(\"jellyfish\");\n+    bulkData = getBulkDataMap();\n+    region.putAll(bulkData);\n+  }\n+\n+  @After\n+  public void after() {\n+    // preserve this commented code for debugging\n+    // String logs = docker.exec(options(\"-T\"), \"geode\",\n+    // arguments(\"cat\", \"server-dolores/server-dolores.log\"));\n+    // System.out.println(\"server logs------------------------------------------\");\n+    // System.out.println(logs);\n+\n+    if (cache != null) {\n+      cache.close();\n+      cache = null;\n+    }\n+    bulkData = null;\n+    region = null;\n   }\n \n+  // run all tests in one @Test to avoid having to stage a new Docker cluster for each\n   @Test\n+  public void runAllTests() throws Exception {\n+    connectToSNIProxyDocker();\n+    verifyServerAPIs();\n+    query();\n+    getAll();\n+    removeAll();\n+  }\n+\n+  /**\n+   * A basic connectivity test that performs a few simple operations\n+   */\n   public void connectToSNIProxyDocker() {\n-    Properties gemFireProps = new Properties();\n-    gemFireProps.setProperty(SSL_ENABLED_COMPONENTS, \"all\");\n-    gemFireProps.setProperty(SSL_KEYSTORE_TYPE, \"jks\");\n-    gemFireProps.setProperty(SSL_REQUIRE_AUTHENTICATION, \"false\");\n+    region.put(\"hello\", \"world\");\n+    assertThat(region.containsKey(\"hello\")).isFalse(); // proxy regions don't store locally\n+    assertThat(region.get(\"hello\")).isEqualTo(\"world\");\n+    region.destroy(\"hello\");\n+    assertThat(region.get(\"hello\")).isNull();\n+  }\n+\n+  /**\n+   * A test of Region query that returns a \"big\" result\n+   */\n+  public void query() throws Exception {\n+    final SelectResults<String> results = region.query(\"SELECT * from /jellyfish\");\n+    assertThat(results).hasSize(bulkData.size());\n+    for (String result : results) {\n+      assertThat(bulkData.containsValue(result)).isTrue();\n+    }\n+  }\n+\n+  /**\n+   * A test of Region bulk getAll\n+   */\n+  public void getAll() {\n+    final Map<String, String> results = region.getAll(bulkData.keySet());\n+    assertThat(results).hasSize(bulkData.size());\n+    for (Map.Entry<String, String> entry : results.entrySet()) {\n+      assertThat(region.containsKey(entry.getKey())).isFalse();\n+      assertThat(bulkData.containsKey(entry.getKey())).isTrue();\n+      assertThat(entry.getValue()).isEqualTo(bulkData.get(entry.getKey()));\n+    }\n+  }\n+\n+  /**\n+   * A test of Region bulk removeAll\n+   */\n+  public void removeAll() {\n+    assertThat(region.sizeOnServer()).isEqualTo(bulkData.size());\n+    region.removeAll(bulkData.keySet());\n+    assertThat(region.sizeOnServer()).isZero();\n+    region.putAll(bulkData);\n+  }\n \n-    gemFireProps.setProperty(SSL_TRUSTSTORE, trustStorePath);\n-    gemFireProps.setProperty(SSL_TRUSTSTORE_PASSWORD, \"geode\");\n-    gemFireProps.setProperty(SSL_ENDPOINT_IDENTIFICATION_ENABLED, \"true\");\n+  /**\n+   * A test of the Region API's methods that directly access the server cache\n+   */\n+  public void verifyServerAPIs() {\n+    assertThat(region.sizeOnServer()).isEqualTo(bulkData.size());\n+    Set<String> keysOnServer = region.keySetOnServer();\n+    for (String entry : bulkData.keySet()) {\n+      assertThat(region.containsKeyOnServer(entry)).isTrue();\n+      assertThat(keysOnServer).contains(entry);\n+    }\n+  }\n+\n+\n+  protected Map<String, String> getBulkDataMap() {\n+    // create a putAll map with enough keys to force a lot of \"chunking\" of the results\n+    int numberOfKeys = BaseCommand.MAXIMUM_CHUNK_SIZE * 10; // 10,000 keys", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk1ODgxMw=="}, "originalCommit": {"oid": "649f0a72fa8aaaed75100818edb3825b4fc2d729"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk2MjU3Nw==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4938#discussion_r406962577", "createdAt": "2020-04-10T22:04:07Z", "author": {"login": "Bill"}, "path": "geode-assembly/src/acceptanceTest/java/org/apache/geode/client/sni/ClientSNIAcceptanceTest.java", "diffHunk": "@@ -58,50 +64,143 @@\n       .file(DOCKER_COMPOSE_PATH.getPath())\n       .build();\n \n-\n-  private String trustStorePath;\n+  private ClientCache cache;\n+  private Region<String, String> region;\n+  private Map<String, String> bulkData;\n \n   @Before\n   public void before() throws IOException, InterruptedException {\n-    trustStorePath =\n+    // start up server/locator processes and initialize the server cache\n+    docker.exec(options(\"-T\"), \"geode\",\n+        arguments(\"gfsh\", \"run\", \"--file=/geode/scripts/geode-starter.gfsh\"));\n+\n+    final String trustStorePath =\n         createTempFileFromResource(ClientSNIAcceptanceTest.class,\n             \"geode-config/truststore.jks\")\n                 .getAbsolutePath();\n-    docker.exec(options(\"-T\"), \"geode\",\n-        arguments(\"gfsh\", \"run\", \"--file=/geode/scripts/geode-starter.gfsh\"));\n+\n+    // set up client cache properties so it can connect to the server\n+    Properties clientCacheProperties = new Properties();\n+    clientCacheProperties.setProperty(SSL_ENABLED_COMPONENTS, \"all\");\n+    clientCacheProperties.setProperty(SSL_KEYSTORE_TYPE, \"jks\");\n+    clientCacheProperties.setProperty(SSL_REQUIRE_AUTHENTICATION, \"false\");\n+\n+    clientCacheProperties.setProperty(SSL_TRUSTSTORE, trustStorePath);\n+    clientCacheProperties.setProperty(SSL_TRUSTSTORE_PASSWORD, \"geode\");\n+    clientCacheProperties.setProperty(SSL_ENDPOINT_IDENTIFICATION_ENABLED, \"true\");\n+    cache = getClientCache(clientCacheProperties);\n+\n+    // the gfsh startup script created a server-side region named \"jellyfish\"\n+    region = cache.<String, String>createClientRegionFactory(ClientRegionShortcut.PROXY)\n+        .create(\"jellyfish\");\n+    bulkData = getBulkDataMap();\n+    region.putAll(bulkData);\n+  }\n+\n+  @After\n+  public void after() {\n+    // preserve this commented code for debugging\n+    // String logs = docker.exec(options(\"-T\"), \"geode\",\n+    // arguments(\"cat\", \"server-dolores/server-dolores.log\"));\n+    // System.out.println(\"server logs------------------------------------------\");\n+    // System.out.println(logs);\n+\n+    if (cache != null) {\n+      cache.close();\n+      cache = null;\n+    }\n+    bulkData = null;\n+    region = null;\n   }\n \n+  // run all tests in one @Test to avoid having to stage a new Docker cluster for each\n   @Test\n+  public void runAllTests() throws Exception {\n+    connectToSNIProxyDocker();\n+    verifyServerAPIs();\n+    query();\n+    getAll();\n+    removeAll();\n+  }\n+\n+  /**\n+   * A basic connectivity test that performs a few simple operations\n+   */\n   public void connectToSNIProxyDocker() {\n-    Properties gemFireProps = new Properties();\n-    gemFireProps.setProperty(SSL_ENABLED_COMPONENTS, \"all\");\n-    gemFireProps.setProperty(SSL_KEYSTORE_TYPE, \"jks\");\n-    gemFireProps.setProperty(SSL_REQUIRE_AUTHENTICATION, \"false\");\n+    region.put(\"hello\", \"world\");\n+    assertThat(region.containsKey(\"hello\")).isFalse(); // proxy regions don't store locally\n+    assertThat(region.get(\"hello\")).isEqualTo(\"world\");\n+    region.destroy(\"hello\");\n+    assertThat(region.get(\"hello\")).isNull();\n+  }\n+\n+  /**\n+   * A test of Region query that returns a \"big\" result\n+   */\n+  public void query() throws Exception {\n+    final SelectResults<String> results = region.query(\"SELECT * from /jellyfish\");\n+    assertThat(results).hasSize(bulkData.size());\n+    for (String result : results) {\n+      assertThat(bulkData.containsValue(result)).isTrue();\n+    }\n+  }\n+\n+  /**\n+   * A test of Region bulk getAll\n+   */\n+  public void getAll() {\n+    final Map<String, String> results = region.getAll(bulkData.keySet());\n+    assertThat(results).hasSize(bulkData.size());\n+    for (Map.Entry<String, String> entry : results.entrySet()) {\n+      assertThat(region.containsKey(entry.getKey())).isFalse();\n+      assertThat(bulkData.containsKey(entry.getKey())).isTrue();\n+      assertThat(entry.getValue()).isEqualTo(bulkData.get(entry.getKey()));\n+    }\n+  }\n+\n+  /**\n+   * A test of Region bulk removeAll\n+   */\n+  public void removeAll() {\n+    assertThat(region.sizeOnServer()).isEqualTo(bulkData.size());\n+    region.removeAll(bulkData.keySet());\n+    assertThat(region.sizeOnServer()).isZero();\n+    region.putAll(bulkData);\n+  }\n \n-    gemFireProps.setProperty(SSL_TRUSTSTORE, trustStorePath);\n-    gemFireProps.setProperty(SSL_TRUSTSTORE_PASSWORD, \"geode\");\n-    gemFireProps.setProperty(SSL_ENDPOINT_IDENTIFICATION_ENABLED, \"true\");\n+  /**\n+   * A test of the Region API's methods that directly access the server cache\n+   */\n+  public void verifyServerAPIs() {\n+    assertThat(region.sizeOnServer()).isEqualTo(bulkData.size());\n+    Set<String> keysOnServer = region.keySetOnServer();\n+    for (String entry : bulkData.keySet()) {\n+      assertThat(region.containsKeyOnServer(entry)).isTrue();\n+      assertThat(keysOnServer).contains(entry);\n+    }\n+  }\n+\n+\n+  protected Map<String, String> getBulkDataMap() {\n+    // create a putAll map with enough keys to force a lot of \"chunking\" of the results\n+    int numberOfKeys = BaseCommand.MAXIMUM_CHUNK_SIZE * 10; // 10,000 keys", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk1ODgxMw=="}, "originalCommit": {"oid": "649f0a72fa8aaaed75100818edb3825b4fc2d729"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk2NjU3Mg==", "bodyText": "fixed", "url": "https://github.com/apache/geode/pull/4938#discussion_r406966572", "createdAt": "2020-04-10T22:20:01Z", "author": {"login": "bschuchardt"}, "path": "geode-assembly/src/acceptanceTest/java/org/apache/geode/client/sni/ClientSNIAcceptanceTest.java", "diffHunk": "@@ -58,50 +64,143 @@\n       .file(DOCKER_COMPOSE_PATH.getPath())\n       .build();\n \n-\n-  private String trustStorePath;\n+  private ClientCache cache;\n+  private Region<String, String> region;\n+  private Map<String, String> bulkData;\n \n   @Before\n   public void before() throws IOException, InterruptedException {\n-    trustStorePath =\n+    // start up server/locator processes and initialize the server cache\n+    docker.exec(options(\"-T\"), \"geode\",\n+        arguments(\"gfsh\", \"run\", \"--file=/geode/scripts/geode-starter.gfsh\"));\n+\n+    final String trustStorePath =\n         createTempFileFromResource(ClientSNIAcceptanceTest.class,\n             \"geode-config/truststore.jks\")\n                 .getAbsolutePath();\n-    docker.exec(options(\"-T\"), \"geode\",\n-        arguments(\"gfsh\", \"run\", \"--file=/geode/scripts/geode-starter.gfsh\"));\n+\n+    // set up client cache properties so it can connect to the server\n+    Properties clientCacheProperties = new Properties();\n+    clientCacheProperties.setProperty(SSL_ENABLED_COMPONENTS, \"all\");\n+    clientCacheProperties.setProperty(SSL_KEYSTORE_TYPE, \"jks\");\n+    clientCacheProperties.setProperty(SSL_REQUIRE_AUTHENTICATION, \"false\");\n+\n+    clientCacheProperties.setProperty(SSL_TRUSTSTORE, trustStorePath);\n+    clientCacheProperties.setProperty(SSL_TRUSTSTORE_PASSWORD, \"geode\");\n+    clientCacheProperties.setProperty(SSL_ENDPOINT_IDENTIFICATION_ENABLED, \"true\");\n+    cache = getClientCache(clientCacheProperties);\n+\n+    // the gfsh startup script created a server-side region named \"jellyfish\"\n+    region = cache.<String, String>createClientRegionFactory(ClientRegionShortcut.PROXY)\n+        .create(\"jellyfish\");\n+    bulkData = getBulkDataMap();\n+    region.putAll(bulkData);\n+  }\n+\n+  @After\n+  public void after() {\n+    // preserve this commented code for debugging\n+    // String logs = docker.exec(options(\"-T\"), \"geode\",\n+    // arguments(\"cat\", \"server-dolores/server-dolores.log\"));\n+    // System.out.println(\"server logs------------------------------------------\");\n+    // System.out.println(logs);\n+\n+    if (cache != null) {\n+      cache.close();\n+      cache = null;\n+    }\n+    bulkData = null;\n+    region = null;\n   }\n \n+  // run all tests in one @Test to avoid having to stage a new Docker cluster for each\n   @Test\n+  public void runAllTests() throws Exception {\n+    connectToSNIProxyDocker();\n+    verifyServerAPIs();\n+    query();\n+    getAll();\n+    removeAll();\n+  }\n+\n+  /**\n+   * A basic connectivity test that performs a few simple operations\n+   */\n   public void connectToSNIProxyDocker() {\n-    Properties gemFireProps = new Properties();\n-    gemFireProps.setProperty(SSL_ENABLED_COMPONENTS, \"all\");\n-    gemFireProps.setProperty(SSL_KEYSTORE_TYPE, \"jks\");\n-    gemFireProps.setProperty(SSL_REQUIRE_AUTHENTICATION, \"false\");\n+    region.put(\"hello\", \"world\");\n+    assertThat(region.containsKey(\"hello\")).isFalse(); // proxy regions don't store locally\n+    assertThat(region.get(\"hello\")).isEqualTo(\"world\");\n+    region.destroy(\"hello\");\n+    assertThat(region.get(\"hello\")).isNull();\n+  }\n+\n+  /**\n+   * A test of Region query that returns a \"big\" result\n+   */\n+  public void query() throws Exception {\n+    final SelectResults<String> results = region.query(\"SELECT * from /jellyfish\");\n+    assertThat(results).hasSize(bulkData.size());\n+    for (String result : results) {\n+      assertThat(bulkData.containsValue(result)).isTrue();\n+    }\n+  }\n+\n+  /**\n+   * A test of Region bulk getAll\n+   */\n+  public void getAll() {\n+    final Map<String, String> results = region.getAll(bulkData.keySet());\n+    assertThat(results).hasSize(bulkData.size());\n+    for (Map.Entry<String, String> entry : results.entrySet()) {\n+      assertThat(region.containsKey(entry.getKey())).isFalse();\n+      assertThat(bulkData.containsKey(entry.getKey())).isTrue();\n+      assertThat(entry.getValue()).isEqualTo(bulkData.get(entry.getKey()));\n+    }\n+  }\n+\n+  /**\n+   * A test of Region bulk removeAll\n+   */\n+  public void removeAll() {\n+    assertThat(region.sizeOnServer()).isEqualTo(bulkData.size());\n+    region.removeAll(bulkData.keySet());\n+    assertThat(region.sizeOnServer()).isZero();\n+    region.putAll(bulkData);\n+  }\n \n-    gemFireProps.setProperty(SSL_TRUSTSTORE, trustStorePath);\n-    gemFireProps.setProperty(SSL_TRUSTSTORE_PASSWORD, \"geode\");\n-    gemFireProps.setProperty(SSL_ENDPOINT_IDENTIFICATION_ENABLED, \"true\");\n+  /**\n+   * A test of the Region API's methods that directly access the server cache\n+   */\n+  public void verifyServerAPIs() {\n+    assertThat(region.sizeOnServer()).isEqualTo(bulkData.size());\n+    Set<String> keysOnServer = region.keySetOnServer();\n+    for (String entry : bulkData.keySet()) {\n+      assertThat(region.containsKeyOnServer(entry)).isTrue();\n+      assertThat(keysOnServer).contains(entry);\n+    }\n+  }\n+\n+\n+  protected Map<String, String> getBulkDataMap() {\n+    // create a putAll map with enough keys to force a lot of \"chunking\" of the results\n+    int numberOfKeys = BaseCommand.MAXIMUM_CHUNK_SIZE * 10; // 10,000 keys", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk1ODgxMw=="}, "originalCommit": {"oid": "649f0a72fa8aaaed75100818edb3825b4fc2d729"}, "originalPosition": 164}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNTcxOTMwOnYy", "diffSide": "RIGHT", "path": "geode-assembly/src/acceptanceTest/java/org/apache/geode/client/sni/ClientSNIAcceptanceTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQyMTo1Njo0OFrOGEG5ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQyMjowNjo0OVrOGEHEKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk2MDUyMg==", "bodyText": "I don't understand why the region should not contain this key?", "url": "https://github.com/apache/geode/pull/4938#discussion_r406960522", "createdAt": "2020-04-10T21:56:48Z", "author": {"login": "Bill"}, "path": "geode-assembly/src/acceptanceTest/java/org/apache/geode/client/sni/ClientSNIAcceptanceTest.java", "diffHunk": "@@ -58,50 +64,143 @@\n       .file(DOCKER_COMPOSE_PATH.getPath())\n       .build();\n \n-\n-  private String trustStorePath;\n+  private ClientCache cache;\n+  private Region<String, String> region;\n+  private Map<String, String> bulkData;\n \n   @Before\n   public void before() throws IOException, InterruptedException {\n-    trustStorePath =\n+    // start up server/locator processes and initialize the server cache\n+    docker.exec(options(\"-T\"), \"geode\",\n+        arguments(\"gfsh\", \"run\", \"--file=/geode/scripts/geode-starter.gfsh\"));\n+\n+    final String trustStorePath =\n         createTempFileFromResource(ClientSNIAcceptanceTest.class,\n             \"geode-config/truststore.jks\")\n                 .getAbsolutePath();\n-    docker.exec(options(\"-T\"), \"geode\",\n-        arguments(\"gfsh\", \"run\", \"--file=/geode/scripts/geode-starter.gfsh\"));\n+\n+    // set up client cache properties so it can connect to the server\n+    Properties clientCacheProperties = new Properties();\n+    clientCacheProperties.setProperty(SSL_ENABLED_COMPONENTS, \"all\");\n+    clientCacheProperties.setProperty(SSL_KEYSTORE_TYPE, \"jks\");\n+    clientCacheProperties.setProperty(SSL_REQUIRE_AUTHENTICATION, \"false\");\n+\n+    clientCacheProperties.setProperty(SSL_TRUSTSTORE, trustStorePath);\n+    clientCacheProperties.setProperty(SSL_TRUSTSTORE_PASSWORD, \"geode\");\n+    clientCacheProperties.setProperty(SSL_ENDPOINT_IDENTIFICATION_ENABLED, \"true\");\n+    cache = getClientCache(clientCacheProperties);\n+\n+    // the gfsh startup script created a server-side region named \"jellyfish\"\n+    region = cache.<String, String>createClientRegionFactory(ClientRegionShortcut.PROXY)\n+        .create(\"jellyfish\");\n+    bulkData = getBulkDataMap();\n+    region.putAll(bulkData);\n+  }\n+\n+  @After\n+  public void after() {\n+    // preserve this commented code for debugging\n+    // String logs = docker.exec(options(\"-T\"), \"geode\",\n+    // arguments(\"cat\", \"server-dolores/server-dolores.log\"));\n+    // System.out.println(\"server logs------------------------------------------\");\n+    // System.out.println(logs);\n+\n+    if (cache != null) {\n+      cache.close();\n+      cache = null;\n+    }\n+    bulkData = null;\n+    region = null;\n   }\n \n+  // run all tests in one @Test to avoid having to stage a new Docker cluster for each\n   @Test\n+  public void runAllTests() throws Exception {\n+    connectToSNIProxyDocker();\n+    verifyServerAPIs();\n+    query();\n+    getAll();\n+    removeAll();\n+  }\n+\n+  /**\n+   * A basic connectivity test that performs a few simple operations\n+   */\n   public void connectToSNIProxyDocker() {\n-    Properties gemFireProps = new Properties();\n-    gemFireProps.setProperty(SSL_ENABLED_COMPONENTS, \"all\");\n-    gemFireProps.setProperty(SSL_KEYSTORE_TYPE, \"jks\");\n-    gemFireProps.setProperty(SSL_REQUIRE_AUTHENTICATION, \"false\");\n+    region.put(\"hello\", \"world\");\n+    assertThat(region.containsKey(\"hello\")).isFalse(); // proxy regions don't store locally\n+    assertThat(region.get(\"hello\")).isEqualTo(\"world\");\n+    region.destroy(\"hello\");\n+    assertThat(region.get(\"hello\")).isNull();\n+  }\n+\n+  /**\n+   * A test of Region query that returns a \"big\" result\n+   */\n+  public void query() throws Exception {\n+    final SelectResults<String> results = region.query(\"SELECT * from /jellyfish\");\n+    assertThat(results).hasSize(bulkData.size());\n+    for (String result : results) {\n+      assertThat(bulkData.containsValue(result)).isTrue();\n+    }\n+  }\n+\n+  /**\n+   * A test of Region bulk getAll\n+   */\n+  public void getAll() {\n+    final Map<String, String> results = region.getAll(bulkData.keySet());\n+    assertThat(results).hasSize(bulkData.size());\n+    for (Map.Entry<String, String> entry : results.entrySet()) {\n+      assertThat(region.containsKey(entry.getKey())).isFalse();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "649f0a72fa8aaaed75100818edb3825b4fc2d729"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk2MjcwMQ==", "bodyText": "The local region is a PROXY.  It's empty, so it won't have the key.   I put in that check in case someone accidentally changes the type of region in the client.  It would invalidate a lot of the tests if the client cache was stateful.", "url": "https://github.com/apache/geode/pull/4938#discussion_r406962701", "createdAt": "2020-04-10T22:04:37Z", "author": {"login": "bschuchardt"}, "path": "geode-assembly/src/acceptanceTest/java/org/apache/geode/client/sni/ClientSNIAcceptanceTest.java", "diffHunk": "@@ -58,50 +64,143 @@\n       .file(DOCKER_COMPOSE_PATH.getPath())\n       .build();\n \n-\n-  private String trustStorePath;\n+  private ClientCache cache;\n+  private Region<String, String> region;\n+  private Map<String, String> bulkData;\n \n   @Before\n   public void before() throws IOException, InterruptedException {\n-    trustStorePath =\n+    // start up server/locator processes and initialize the server cache\n+    docker.exec(options(\"-T\"), \"geode\",\n+        arguments(\"gfsh\", \"run\", \"--file=/geode/scripts/geode-starter.gfsh\"));\n+\n+    final String trustStorePath =\n         createTempFileFromResource(ClientSNIAcceptanceTest.class,\n             \"geode-config/truststore.jks\")\n                 .getAbsolutePath();\n-    docker.exec(options(\"-T\"), \"geode\",\n-        arguments(\"gfsh\", \"run\", \"--file=/geode/scripts/geode-starter.gfsh\"));\n+\n+    // set up client cache properties so it can connect to the server\n+    Properties clientCacheProperties = new Properties();\n+    clientCacheProperties.setProperty(SSL_ENABLED_COMPONENTS, \"all\");\n+    clientCacheProperties.setProperty(SSL_KEYSTORE_TYPE, \"jks\");\n+    clientCacheProperties.setProperty(SSL_REQUIRE_AUTHENTICATION, \"false\");\n+\n+    clientCacheProperties.setProperty(SSL_TRUSTSTORE, trustStorePath);\n+    clientCacheProperties.setProperty(SSL_TRUSTSTORE_PASSWORD, \"geode\");\n+    clientCacheProperties.setProperty(SSL_ENDPOINT_IDENTIFICATION_ENABLED, \"true\");\n+    cache = getClientCache(clientCacheProperties);\n+\n+    // the gfsh startup script created a server-side region named \"jellyfish\"\n+    region = cache.<String, String>createClientRegionFactory(ClientRegionShortcut.PROXY)\n+        .create(\"jellyfish\");\n+    bulkData = getBulkDataMap();\n+    region.putAll(bulkData);\n+  }\n+\n+  @After\n+  public void after() {\n+    // preserve this commented code for debugging\n+    // String logs = docker.exec(options(\"-T\"), \"geode\",\n+    // arguments(\"cat\", \"server-dolores/server-dolores.log\"));\n+    // System.out.println(\"server logs------------------------------------------\");\n+    // System.out.println(logs);\n+\n+    if (cache != null) {\n+      cache.close();\n+      cache = null;\n+    }\n+    bulkData = null;\n+    region = null;\n   }\n \n+  // run all tests in one @Test to avoid having to stage a new Docker cluster for each\n   @Test\n+  public void runAllTests() throws Exception {\n+    connectToSNIProxyDocker();\n+    verifyServerAPIs();\n+    query();\n+    getAll();\n+    removeAll();\n+  }\n+\n+  /**\n+   * A basic connectivity test that performs a few simple operations\n+   */\n   public void connectToSNIProxyDocker() {\n-    Properties gemFireProps = new Properties();\n-    gemFireProps.setProperty(SSL_ENABLED_COMPONENTS, \"all\");\n-    gemFireProps.setProperty(SSL_KEYSTORE_TYPE, \"jks\");\n-    gemFireProps.setProperty(SSL_REQUIRE_AUTHENTICATION, \"false\");\n+    region.put(\"hello\", \"world\");\n+    assertThat(region.containsKey(\"hello\")).isFalse(); // proxy regions don't store locally\n+    assertThat(region.get(\"hello\")).isEqualTo(\"world\");\n+    region.destroy(\"hello\");\n+    assertThat(region.get(\"hello\")).isNull();\n+  }\n+\n+  /**\n+   * A test of Region query that returns a \"big\" result\n+   */\n+  public void query() throws Exception {\n+    final SelectResults<String> results = region.query(\"SELECT * from /jellyfish\");\n+    assertThat(results).hasSize(bulkData.size());\n+    for (String result : results) {\n+      assertThat(bulkData.containsValue(result)).isTrue();\n+    }\n+  }\n+\n+  /**\n+   * A test of Region bulk getAll\n+   */\n+  public void getAll() {\n+    final Map<String, String> results = region.getAll(bulkData.keySet());\n+    assertThat(results).hasSize(bulkData.size());\n+    for (Map.Entry<String, String> entry : results.entrySet()) {\n+      assertThat(region.containsKey(entry.getKey())).isFalse();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk2MDUyMg=="}, "originalCommit": {"oid": "649f0a72fa8aaaed75100818edb3825b4fc2d729"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk2MzI0Mg==", "bodyText": "nice", "url": "https://github.com/apache/geode/pull/4938#discussion_r406963242", "createdAt": "2020-04-10T22:06:49Z", "author": {"login": "Bill"}, "path": "geode-assembly/src/acceptanceTest/java/org/apache/geode/client/sni/ClientSNIAcceptanceTest.java", "diffHunk": "@@ -58,50 +64,143 @@\n       .file(DOCKER_COMPOSE_PATH.getPath())\n       .build();\n \n-\n-  private String trustStorePath;\n+  private ClientCache cache;\n+  private Region<String, String> region;\n+  private Map<String, String> bulkData;\n \n   @Before\n   public void before() throws IOException, InterruptedException {\n-    trustStorePath =\n+    // start up server/locator processes and initialize the server cache\n+    docker.exec(options(\"-T\"), \"geode\",\n+        arguments(\"gfsh\", \"run\", \"--file=/geode/scripts/geode-starter.gfsh\"));\n+\n+    final String trustStorePath =\n         createTempFileFromResource(ClientSNIAcceptanceTest.class,\n             \"geode-config/truststore.jks\")\n                 .getAbsolutePath();\n-    docker.exec(options(\"-T\"), \"geode\",\n-        arguments(\"gfsh\", \"run\", \"--file=/geode/scripts/geode-starter.gfsh\"));\n+\n+    // set up client cache properties so it can connect to the server\n+    Properties clientCacheProperties = new Properties();\n+    clientCacheProperties.setProperty(SSL_ENABLED_COMPONENTS, \"all\");\n+    clientCacheProperties.setProperty(SSL_KEYSTORE_TYPE, \"jks\");\n+    clientCacheProperties.setProperty(SSL_REQUIRE_AUTHENTICATION, \"false\");\n+\n+    clientCacheProperties.setProperty(SSL_TRUSTSTORE, trustStorePath);\n+    clientCacheProperties.setProperty(SSL_TRUSTSTORE_PASSWORD, \"geode\");\n+    clientCacheProperties.setProperty(SSL_ENDPOINT_IDENTIFICATION_ENABLED, \"true\");\n+    cache = getClientCache(clientCacheProperties);\n+\n+    // the gfsh startup script created a server-side region named \"jellyfish\"\n+    region = cache.<String, String>createClientRegionFactory(ClientRegionShortcut.PROXY)\n+        .create(\"jellyfish\");\n+    bulkData = getBulkDataMap();\n+    region.putAll(bulkData);\n+  }\n+\n+  @After\n+  public void after() {\n+    // preserve this commented code for debugging\n+    // String logs = docker.exec(options(\"-T\"), \"geode\",\n+    // arguments(\"cat\", \"server-dolores/server-dolores.log\"));\n+    // System.out.println(\"server logs------------------------------------------\");\n+    // System.out.println(logs);\n+\n+    if (cache != null) {\n+      cache.close();\n+      cache = null;\n+    }\n+    bulkData = null;\n+    region = null;\n   }\n \n+  // run all tests in one @Test to avoid having to stage a new Docker cluster for each\n   @Test\n+  public void runAllTests() throws Exception {\n+    connectToSNIProxyDocker();\n+    verifyServerAPIs();\n+    query();\n+    getAll();\n+    removeAll();\n+  }\n+\n+  /**\n+   * A basic connectivity test that performs a few simple operations\n+   */\n   public void connectToSNIProxyDocker() {\n-    Properties gemFireProps = new Properties();\n-    gemFireProps.setProperty(SSL_ENABLED_COMPONENTS, \"all\");\n-    gemFireProps.setProperty(SSL_KEYSTORE_TYPE, \"jks\");\n-    gemFireProps.setProperty(SSL_REQUIRE_AUTHENTICATION, \"false\");\n+    region.put(\"hello\", \"world\");\n+    assertThat(region.containsKey(\"hello\")).isFalse(); // proxy regions don't store locally\n+    assertThat(region.get(\"hello\")).isEqualTo(\"world\");\n+    region.destroy(\"hello\");\n+    assertThat(region.get(\"hello\")).isNull();\n+  }\n+\n+  /**\n+   * A test of Region query that returns a \"big\" result\n+   */\n+  public void query() throws Exception {\n+    final SelectResults<String> results = region.query(\"SELECT * from /jellyfish\");\n+    assertThat(results).hasSize(bulkData.size());\n+    for (String result : results) {\n+      assertThat(bulkData.containsValue(result)).isTrue();\n+    }\n+  }\n+\n+  /**\n+   * A test of Region bulk getAll\n+   */\n+  public void getAll() {\n+    final Map<String, String> results = region.getAll(bulkData.keySet());\n+    assertThat(results).hasSize(bulkData.size());\n+    for (Map.Entry<String, String> entry : results.entrySet()) {\n+      assertThat(region.containsKey(entry.getKey())).isFalse();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk2MDUyMg=="}, "originalCommit": {"oid": "649f0a72fa8aaaed75100818edb3825b4fc2d729"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNTcyMjkzOnYy", "diffSide": "RIGHT", "path": "geode-assembly/src/acceptanceTest/java/org/apache/geode/client/sni/ClientSNIAcceptanceTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQyMTo1ODo0MlrOGEG7oQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQyMjoxNDozNFrOGEHMDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk2MTA1Nw==", "bodyText": "should we be testing clear() also?", "url": "https://github.com/apache/geode/pull/4938#discussion_r406961057", "createdAt": "2020-04-10T21:58:42Z", "author": {"login": "Bill"}, "path": "geode-assembly/src/acceptanceTest/java/org/apache/geode/client/sni/ClientSNIAcceptanceTest.java", "diffHunk": "@@ -58,50 +64,143 @@\n       .file(DOCKER_COMPOSE_PATH.getPath())\n       .build();\n \n-\n-  private String trustStorePath;\n+  private ClientCache cache;\n+  private Region<String, String> region;\n+  private Map<String, String> bulkData;\n \n   @Before\n   public void before() throws IOException, InterruptedException {\n-    trustStorePath =\n+    // start up server/locator processes and initialize the server cache\n+    docker.exec(options(\"-T\"), \"geode\",\n+        arguments(\"gfsh\", \"run\", \"--file=/geode/scripts/geode-starter.gfsh\"));\n+\n+    final String trustStorePath =\n         createTempFileFromResource(ClientSNIAcceptanceTest.class,\n             \"geode-config/truststore.jks\")\n                 .getAbsolutePath();\n-    docker.exec(options(\"-T\"), \"geode\",\n-        arguments(\"gfsh\", \"run\", \"--file=/geode/scripts/geode-starter.gfsh\"));\n+\n+    // set up client cache properties so it can connect to the server\n+    Properties clientCacheProperties = new Properties();\n+    clientCacheProperties.setProperty(SSL_ENABLED_COMPONENTS, \"all\");\n+    clientCacheProperties.setProperty(SSL_KEYSTORE_TYPE, \"jks\");\n+    clientCacheProperties.setProperty(SSL_REQUIRE_AUTHENTICATION, \"false\");\n+\n+    clientCacheProperties.setProperty(SSL_TRUSTSTORE, trustStorePath);\n+    clientCacheProperties.setProperty(SSL_TRUSTSTORE_PASSWORD, \"geode\");\n+    clientCacheProperties.setProperty(SSL_ENDPOINT_IDENTIFICATION_ENABLED, \"true\");\n+    cache = getClientCache(clientCacheProperties);\n+\n+    // the gfsh startup script created a server-side region named \"jellyfish\"\n+    region = cache.<String, String>createClientRegionFactory(ClientRegionShortcut.PROXY)\n+        .create(\"jellyfish\");\n+    bulkData = getBulkDataMap();\n+    region.putAll(bulkData);\n+  }\n+\n+  @After\n+  public void after() {\n+    // preserve this commented code for debugging\n+    // String logs = docker.exec(options(\"-T\"), \"geode\",\n+    // arguments(\"cat\", \"server-dolores/server-dolores.log\"));\n+    // System.out.println(\"server logs------------------------------------------\");\n+    // System.out.println(logs);\n+\n+    if (cache != null) {\n+      cache.close();\n+      cache = null;\n+    }\n+    bulkData = null;\n+    region = null;\n   }\n \n+  // run all tests in one @Test to avoid having to stage a new Docker cluster for each\n   @Test\n+  public void runAllTests() throws Exception {\n+    connectToSNIProxyDocker();\n+    verifyServerAPIs();\n+    query();\n+    getAll();\n+    removeAll();\n+  }\n+\n+  /**\n+   * A basic connectivity test that performs a few simple operations\n+   */\n   public void connectToSNIProxyDocker() {\n-    Properties gemFireProps = new Properties();\n-    gemFireProps.setProperty(SSL_ENABLED_COMPONENTS, \"all\");\n-    gemFireProps.setProperty(SSL_KEYSTORE_TYPE, \"jks\");\n-    gemFireProps.setProperty(SSL_REQUIRE_AUTHENTICATION, \"false\");\n+    region.put(\"hello\", \"world\");\n+    assertThat(region.containsKey(\"hello\")).isFalse(); // proxy regions don't store locally\n+    assertThat(region.get(\"hello\")).isEqualTo(\"world\");\n+    region.destroy(\"hello\");\n+    assertThat(region.get(\"hello\")).isNull();\n+  }\n+\n+  /**\n+   * A test of Region query that returns a \"big\" result\n+   */\n+  public void query() throws Exception {\n+    final SelectResults<String> results = region.query(\"SELECT * from /jellyfish\");\n+    assertThat(results).hasSize(bulkData.size());\n+    for (String result : results) {\n+      assertThat(bulkData.containsValue(result)).isTrue();\n+    }\n+  }\n+\n+  /**\n+   * A test of Region bulk getAll\n+   */\n+  public void getAll() {\n+    final Map<String, String> results = region.getAll(bulkData.keySet());\n+    assertThat(results).hasSize(bulkData.size());\n+    for (Map.Entry<String, String> entry : results.entrySet()) {\n+      assertThat(region.containsKey(entry.getKey())).isFalse();\n+      assertThat(bulkData.containsKey(entry.getKey())).isTrue();\n+      assertThat(entry.getValue()).isEqualTo(bulkData.get(entry.getKey()));\n+    }\n+  }\n+\n+  /**\n+   * A test of Region bulk removeAll\n+   */\n+  public void removeAll() {\n+    assertThat(region.sizeOnServer()).isEqualTo(bulkData.size());\n+    region.removeAll(bulkData.keySet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "649f0a72fa8aaaed75100818edb3825b4fc2d729"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk2Mzk5Ng==", "bodyText": "clear() doesn't transfer much of any information.  I don't think it belongs in this PR.", "url": "https://github.com/apache/geode/pull/4938#discussion_r406963996", "createdAt": "2020-04-10T22:09:30Z", "author": {"login": "bschuchardt"}, "path": "geode-assembly/src/acceptanceTest/java/org/apache/geode/client/sni/ClientSNIAcceptanceTest.java", "diffHunk": "@@ -58,50 +64,143 @@\n       .file(DOCKER_COMPOSE_PATH.getPath())\n       .build();\n \n-\n-  private String trustStorePath;\n+  private ClientCache cache;\n+  private Region<String, String> region;\n+  private Map<String, String> bulkData;\n \n   @Before\n   public void before() throws IOException, InterruptedException {\n-    trustStorePath =\n+    // start up server/locator processes and initialize the server cache\n+    docker.exec(options(\"-T\"), \"geode\",\n+        arguments(\"gfsh\", \"run\", \"--file=/geode/scripts/geode-starter.gfsh\"));\n+\n+    final String trustStorePath =\n         createTempFileFromResource(ClientSNIAcceptanceTest.class,\n             \"geode-config/truststore.jks\")\n                 .getAbsolutePath();\n-    docker.exec(options(\"-T\"), \"geode\",\n-        arguments(\"gfsh\", \"run\", \"--file=/geode/scripts/geode-starter.gfsh\"));\n+\n+    // set up client cache properties so it can connect to the server\n+    Properties clientCacheProperties = new Properties();\n+    clientCacheProperties.setProperty(SSL_ENABLED_COMPONENTS, \"all\");\n+    clientCacheProperties.setProperty(SSL_KEYSTORE_TYPE, \"jks\");\n+    clientCacheProperties.setProperty(SSL_REQUIRE_AUTHENTICATION, \"false\");\n+\n+    clientCacheProperties.setProperty(SSL_TRUSTSTORE, trustStorePath);\n+    clientCacheProperties.setProperty(SSL_TRUSTSTORE_PASSWORD, \"geode\");\n+    clientCacheProperties.setProperty(SSL_ENDPOINT_IDENTIFICATION_ENABLED, \"true\");\n+    cache = getClientCache(clientCacheProperties);\n+\n+    // the gfsh startup script created a server-side region named \"jellyfish\"\n+    region = cache.<String, String>createClientRegionFactory(ClientRegionShortcut.PROXY)\n+        .create(\"jellyfish\");\n+    bulkData = getBulkDataMap();\n+    region.putAll(bulkData);\n+  }\n+\n+  @After\n+  public void after() {\n+    // preserve this commented code for debugging\n+    // String logs = docker.exec(options(\"-T\"), \"geode\",\n+    // arguments(\"cat\", \"server-dolores/server-dolores.log\"));\n+    // System.out.println(\"server logs------------------------------------------\");\n+    // System.out.println(logs);\n+\n+    if (cache != null) {\n+      cache.close();\n+      cache = null;\n+    }\n+    bulkData = null;\n+    region = null;\n   }\n \n+  // run all tests in one @Test to avoid having to stage a new Docker cluster for each\n   @Test\n+  public void runAllTests() throws Exception {\n+    connectToSNIProxyDocker();\n+    verifyServerAPIs();\n+    query();\n+    getAll();\n+    removeAll();\n+  }\n+\n+  /**\n+   * A basic connectivity test that performs a few simple operations\n+   */\n   public void connectToSNIProxyDocker() {\n-    Properties gemFireProps = new Properties();\n-    gemFireProps.setProperty(SSL_ENABLED_COMPONENTS, \"all\");\n-    gemFireProps.setProperty(SSL_KEYSTORE_TYPE, \"jks\");\n-    gemFireProps.setProperty(SSL_REQUIRE_AUTHENTICATION, \"false\");\n+    region.put(\"hello\", \"world\");\n+    assertThat(region.containsKey(\"hello\")).isFalse(); // proxy regions don't store locally\n+    assertThat(region.get(\"hello\")).isEqualTo(\"world\");\n+    region.destroy(\"hello\");\n+    assertThat(region.get(\"hello\")).isNull();\n+  }\n+\n+  /**\n+   * A test of Region query that returns a \"big\" result\n+   */\n+  public void query() throws Exception {\n+    final SelectResults<String> results = region.query(\"SELECT * from /jellyfish\");\n+    assertThat(results).hasSize(bulkData.size());\n+    for (String result : results) {\n+      assertThat(bulkData.containsValue(result)).isTrue();\n+    }\n+  }\n+\n+  /**\n+   * A test of Region bulk getAll\n+   */\n+  public void getAll() {\n+    final Map<String, String> results = region.getAll(bulkData.keySet());\n+    assertThat(results).hasSize(bulkData.size());\n+    for (Map.Entry<String, String> entry : results.entrySet()) {\n+      assertThat(region.containsKey(entry.getKey())).isFalse();\n+      assertThat(bulkData.containsKey(entry.getKey())).isTrue();\n+      assertThat(entry.getValue()).isEqualTo(bulkData.get(entry.getKey()));\n+    }\n+  }\n+\n+  /**\n+   * A test of Region bulk removeAll\n+   */\n+  public void removeAll() {\n+    assertThat(region.sizeOnServer()).isEqualTo(bulkData.size());\n+    region.removeAll(bulkData.keySet());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk2MTA1Nw=="}, "originalCommit": {"oid": "649f0a72fa8aaaed75100818edb3825b4fc2d729"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk2NTI2MQ==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4938#discussion_r406965261", "createdAt": "2020-04-10T22:14:34Z", "author": {"login": "Bill"}, "path": "geode-assembly/src/acceptanceTest/java/org/apache/geode/client/sni/ClientSNIAcceptanceTest.java", "diffHunk": "@@ -58,50 +64,143 @@\n       .file(DOCKER_COMPOSE_PATH.getPath())\n       .build();\n \n-\n-  private String trustStorePath;\n+  private ClientCache cache;\n+  private Region<String, String> region;\n+  private Map<String, String> bulkData;\n \n   @Before\n   public void before() throws IOException, InterruptedException {\n-    trustStorePath =\n+    // start up server/locator processes and initialize the server cache\n+    docker.exec(options(\"-T\"), \"geode\",\n+        arguments(\"gfsh\", \"run\", \"--file=/geode/scripts/geode-starter.gfsh\"));\n+\n+    final String trustStorePath =\n         createTempFileFromResource(ClientSNIAcceptanceTest.class,\n             \"geode-config/truststore.jks\")\n                 .getAbsolutePath();\n-    docker.exec(options(\"-T\"), \"geode\",\n-        arguments(\"gfsh\", \"run\", \"--file=/geode/scripts/geode-starter.gfsh\"));\n+\n+    // set up client cache properties so it can connect to the server\n+    Properties clientCacheProperties = new Properties();\n+    clientCacheProperties.setProperty(SSL_ENABLED_COMPONENTS, \"all\");\n+    clientCacheProperties.setProperty(SSL_KEYSTORE_TYPE, \"jks\");\n+    clientCacheProperties.setProperty(SSL_REQUIRE_AUTHENTICATION, \"false\");\n+\n+    clientCacheProperties.setProperty(SSL_TRUSTSTORE, trustStorePath);\n+    clientCacheProperties.setProperty(SSL_TRUSTSTORE_PASSWORD, \"geode\");\n+    clientCacheProperties.setProperty(SSL_ENDPOINT_IDENTIFICATION_ENABLED, \"true\");\n+    cache = getClientCache(clientCacheProperties);\n+\n+    // the gfsh startup script created a server-side region named \"jellyfish\"\n+    region = cache.<String, String>createClientRegionFactory(ClientRegionShortcut.PROXY)\n+        .create(\"jellyfish\");\n+    bulkData = getBulkDataMap();\n+    region.putAll(bulkData);\n+  }\n+\n+  @After\n+  public void after() {\n+    // preserve this commented code for debugging\n+    // String logs = docker.exec(options(\"-T\"), \"geode\",\n+    // arguments(\"cat\", \"server-dolores/server-dolores.log\"));\n+    // System.out.println(\"server logs------------------------------------------\");\n+    // System.out.println(logs);\n+\n+    if (cache != null) {\n+      cache.close();\n+      cache = null;\n+    }\n+    bulkData = null;\n+    region = null;\n   }\n \n+  // run all tests in one @Test to avoid having to stage a new Docker cluster for each\n   @Test\n+  public void runAllTests() throws Exception {\n+    connectToSNIProxyDocker();\n+    verifyServerAPIs();\n+    query();\n+    getAll();\n+    removeAll();\n+  }\n+\n+  /**\n+   * A basic connectivity test that performs a few simple operations\n+   */\n   public void connectToSNIProxyDocker() {\n-    Properties gemFireProps = new Properties();\n-    gemFireProps.setProperty(SSL_ENABLED_COMPONENTS, \"all\");\n-    gemFireProps.setProperty(SSL_KEYSTORE_TYPE, \"jks\");\n-    gemFireProps.setProperty(SSL_REQUIRE_AUTHENTICATION, \"false\");\n+    region.put(\"hello\", \"world\");\n+    assertThat(region.containsKey(\"hello\")).isFalse(); // proxy regions don't store locally\n+    assertThat(region.get(\"hello\")).isEqualTo(\"world\");\n+    region.destroy(\"hello\");\n+    assertThat(region.get(\"hello\")).isNull();\n+  }\n+\n+  /**\n+   * A test of Region query that returns a \"big\" result\n+   */\n+  public void query() throws Exception {\n+    final SelectResults<String> results = region.query(\"SELECT * from /jellyfish\");\n+    assertThat(results).hasSize(bulkData.size());\n+    for (String result : results) {\n+      assertThat(bulkData.containsValue(result)).isTrue();\n+    }\n+  }\n+\n+  /**\n+   * A test of Region bulk getAll\n+   */\n+  public void getAll() {\n+    final Map<String, String> results = region.getAll(bulkData.keySet());\n+    assertThat(results).hasSize(bulkData.size());\n+    for (Map.Entry<String, String> entry : results.entrySet()) {\n+      assertThat(region.containsKey(entry.getKey())).isFalse();\n+      assertThat(bulkData.containsKey(entry.getKey())).isTrue();\n+      assertThat(entry.getValue()).isEqualTo(bulkData.get(entry.getKey()));\n+    }\n+  }\n+\n+  /**\n+   * A test of Region bulk removeAll\n+   */\n+  public void removeAll() {\n+    assertThat(region.sizeOnServer()).isEqualTo(bulkData.size());\n+    region.removeAll(bulkData.keySet());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk2MTA1Nw=="}, "originalCommit": {"oid": "649f0a72fa8aaaed75100818edb3825b4fc2d729"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNTcyNjE1OnYy", "diffSide": "LEFT", "path": "geode-tcp-server/src/test/java/org/apache/geode/distributed/internal/tcpserver/HostAndPortTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQyMjowMDoxMVrOGEG9cA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQyMjoxNDo0N1rOGEHMPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk2MTUyMA==", "bodyText": "I see you modified toString(). is there a reason why this test is no longer valuable?", "url": "https://github.com/apache/geode/pull/4938#discussion_r406961520", "createdAt": "2020-04-10T22:00:11Z", "author": {"login": "Bill"}, "path": "geode-tcp-server/src/test/java/org/apache/geode/distributed/internal/tcpserver/HostAndPortTest.java", "diffHunk": "@@ -93,12 +93,6 @@ public void hashCode_of_SocketAddress() {\n     assertThat(locator1.hashCode()).isEqualTo(host1address.hashCode());\n   }\n \n-  @Test\n-  public void toString_LocatorAddress() {\n-    HostAndPort locator1 = new HostAndPort(\"fakelocalhost\", 8091);\n-    assertThat(locator1.toString()).contains(\"socketInetAddress\");\n-  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "649f0a72fa8aaaed75100818edb3825b4fc2d729"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk2NDQ5MA==", "bodyText": "There's no contract on HostAndPort.toString() to have this string in its result.  I saw the string rep in test output and didn't like how wordy it was.  It's now HostAndPort[hostname:port].", "url": "https://github.com/apache/geode/pull/4938#discussion_r406964490", "createdAt": "2020-04-10T22:11:40Z", "author": {"login": "bschuchardt"}, "path": "geode-tcp-server/src/test/java/org/apache/geode/distributed/internal/tcpserver/HostAndPortTest.java", "diffHunk": "@@ -93,12 +93,6 @@ public void hashCode_of_SocketAddress() {\n     assertThat(locator1.hashCode()).isEqualTo(host1address.hashCode());\n   }\n \n-  @Test\n-  public void toString_LocatorAddress() {\n-    HostAndPort locator1 = new HostAndPort(\"fakelocalhost\", 8091);\n-    assertThat(locator1.toString()).contains(\"socketInetAddress\");\n-  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk2MTUyMA=="}, "originalCommit": {"oid": "649f0a72fa8aaaed75100818edb3825b4fc2d729"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk2NTMxMQ==", "bodyText": "good show", "url": "https://github.com/apache/geode/pull/4938#discussion_r406965311", "createdAt": "2020-04-10T22:14:47Z", "author": {"login": "Bill"}, "path": "geode-tcp-server/src/test/java/org/apache/geode/distributed/internal/tcpserver/HostAndPortTest.java", "diffHunk": "@@ -93,12 +93,6 @@ public void hashCode_of_SocketAddress() {\n     assertThat(locator1.hashCode()).isEqualTo(host1address.hashCode());\n   }\n \n-  @Test\n-  public void toString_LocatorAddress() {\n-    HostAndPort locator1 = new HostAndPort(\"fakelocalhost\", 8091);\n-    assertThat(locator1.toString()).contains(\"socketInetAddress\");\n-  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk2MTUyMA=="}, "originalCommit": {"oid": "649f0a72fa8aaaed75100818edb3825b4fc2d729"}, "originalPosition": 8}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4306, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}