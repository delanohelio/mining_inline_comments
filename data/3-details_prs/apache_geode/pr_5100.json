{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE2ODU5ODE2", "number": 5100, "title": "GEODE-8114: Refactor set", "bodyText": "I broke up the RedisSet and RedisHash classes by moving the static methods into separate non-static classes.  I also made canonical empty classes, so we don't have to do as much null-checking.\nThank you for submitting a contribution to Apache Geode.\nIn order to streamline the review of the contribution we ask you\nto ensure the following steps have been taken:\nFor all changes:\n\n\n Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?\n\n\n Has your PR been rebased against the latest commit within the target branch (typically develop)?\n\n\n Is your initial contribution a single, squashed commit?\n\n\n Does gradlew build run cleanly?\n\n\n Have you written or updated unit tests to verify your changes?\n\n\n If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under ASF 2.0?\n\n\nNote:\nPlease ensure that once the PR is submitted, check Concourse for build issues and\nsubmit an update to your PR as soon as possible. If you need help, please send an\nemail to dev@geode.apache.org.", "createdAt": "2020-05-12T17:14:55Z", "url": "https://github.com/apache/geode/pull/5100", "merged": true, "mergeCommit": {"oid": "d402351279cf4e81184a0ae8411778048858eee8"}, "closed": true, "closedAt": "2020-05-13T22:53:18Z", "author": {"login": "prettyClouds"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcgqsgWgBqjMzMjkyOTQyODg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABchAH29AFqTQxMTMyNjgxNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d1859b57ef10ca6221fbc5b9f74a35668fda44cd", "author": {"user": {"login": "prettyClouds", "name": "Murtuza Boxwala"}}, "url": "https://github.com/apache/geode/commit/d1859b57ef10ca6221fbc5b9f74a35668fda44cd", "committedDate": "2020-05-12T17:13:02Z", "message": "make all the layers implement RedisSetCommands"}, "afterCommit": {"oid": "2ab865e88e69c86fcfde48f05f02b31612f5ba4b", "author": {"user": {"login": "prettyClouds", "name": "Murtuza Boxwala"}}, "url": "https://github.com/apache/geode/commit/2ab865e88e69c86fcfde48f05f02b31612f5ba4b", "committedDate": "2020-05-12T20:50:22Z", "message": "make all the layers implement RedisSetCommands"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNjQxNTAy", "url": "https://github.com/apache/geode/pull/5100#pullrequestreview-410641502", "createdAt": "2020-05-13T07:05:53Z", "commit": {"oid": "7326f62a4d7d42a3daa36f83ac372ed935567c7e"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzowNTo1M1rOGUkFzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzoyODowM1rOGUkxjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIxNjAxMg==", "bodyText": "change \"get(key)\" to \"redisSet\"", "url": "https://github.com/apache/geode/pull/5100#discussion_r424216012", "createdAt": "2020-05-13T07:05:53Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/set/RedisSetInRegion.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis.internal.executor.set;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.regex.Pattern;\n+\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.redis.internal.ByteArrayWrapper;\n+\n+/**\n+ * This class checks whether a RedisSet exists before forwarding the message.\n+ */\n+public class RedisSetInRegion implements RedisSetCommands {\n+  private Region<ByteArrayWrapper, RedisSet> region;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public RedisSetInRegion(Region<ByteArrayWrapper, RedisSet> region) {\n+    this.region = region;\n+  }\n+\n+  @Override\n+  public long sadd(\n+      ByteArrayWrapper key,\n+      ArrayList<ByteArrayWrapper> membersToAdd) {\n+    RedisSet redisSet = get(key);\n+    long l = redisSet.sadd(key, membersToAdd);\n+    if (l > 0) {\n+      region.put(key, redisSet);\n+    }\n+    return l;\n+  }\n+\n+  @Override\n+  public long srem(\n+      ByteArrayWrapper key,\n+      ArrayList<ByteArrayWrapper> membersToRemove, AtomicBoolean setWasDeleted) {\n+    RedisSet redisSet = get(key);\n+    long l = redisSet.srem(key, membersToRemove, setWasDeleted);\n+    if (get(key).scard(key) == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7326f62a4d7d42a3daa36f83ac372ed935567c7e"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIxNjIzNw==", "bodyText": "change \"get(key)\" to \"redisSet\"", "url": "https://github.com/apache/geode/pull/5100#discussion_r424216237", "createdAt": "2020-05-13T07:06:22Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/set/RedisSetInRegion.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis.internal.executor.set;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.regex.Pattern;\n+\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.redis.internal.ByteArrayWrapper;\n+\n+/**\n+ * This class checks whether a RedisSet exists before forwarding the message.\n+ */\n+public class RedisSetInRegion implements RedisSetCommands {\n+  private Region<ByteArrayWrapper, RedisSet> region;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public RedisSetInRegion(Region<ByteArrayWrapper, RedisSet> region) {\n+    this.region = region;\n+  }\n+\n+  @Override\n+  public long sadd(\n+      ByteArrayWrapper key,\n+      ArrayList<ByteArrayWrapper> membersToAdd) {\n+    RedisSet redisSet = get(key);\n+    long l = redisSet.sadd(key, membersToAdd);\n+    if (l > 0) {\n+      region.put(key, redisSet);\n+    }\n+    return l;\n+  }\n+\n+  @Override\n+  public long srem(\n+      ByteArrayWrapper key,\n+      ArrayList<ByteArrayWrapper> membersToRemove, AtomicBoolean setWasDeleted) {\n+    RedisSet redisSet = get(key);\n+    long l = redisSet.srem(key, membersToRemove, setWasDeleted);\n+    if (get(key).scard(key) == 0) {\n+      region.remove(key);\n+    } else {\n+      region.put(key, get(key));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7326f62a4d7d42a3daa36f83ac372ed935567c7e"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIxNjQ5Nw==", "bodyText": "change \"get(key)\" to \"redisSet\"", "url": "https://github.com/apache/geode/pull/5100#discussion_r424216497", "createdAt": "2020-05-13T07:06:56Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/set/RedisSetInRegion.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis.internal.executor.set;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.regex.Pattern;\n+\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.redis.internal.ByteArrayWrapper;\n+\n+/**\n+ * This class checks whether a RedisSet exists before forwarding the message.\n+ */\n+public class RedisSetInRegion implements RedisSetCommands {\n+  private Region<ByteArrayWrapper, RedisSet> region;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public RedisSetInRegion(Region<ByteArrayWrapper, RedisSet> region) {\n+    this.region = region;\n+  }\n+\n+  @Override\n+  public long sadd(\n+      ByteArrayWrapper key,\n+      ArrayList<ByteArrayWrapper> membersToAdd) {\n+    RedisSet redisSet = get(key);\n+    long l = redisSet.sadd(key, membersToAdd);\n+    if (l > 0) {\n+      region.put(key, redisSet);\n+    }\n+    return l;\n+  }\n+\n+  @Override\n+  public long srem(\n+      ByteArrayWrapper key,\n+      ArrayList<ByteArrayWrapper> membersToRemove, AtomicBoolean setWasDeleted) {\n+    RedisSet redisSet = get(key);\n+    long l = redisSet.srem(key, membersToRemove, setWasDeleted);\n+    if (get(key).scard(key) == 0) {\n+      region.remove(key);\n+    } else {\n+      region.put(key, get(key));\n+    }\n+    return l;\n+  }\n+\n+  public boolean del(ByteArrayWrapper key) {\n+    return region.remove(key) != null;\n+  }\n+\n+  @Override\n+  public Set<ByteArrayWrapper> smembers(\n+      ByteArrayWrapper key) {\n+    return get(key).smembers(key);\n+  }\n+\n+  @Override\n+  public int scard(ByteArrayWrapper key) {\n+    return get(key).scard(key);\n+  }\n+\n+  @Override\n+  public boolean sismember(\n+      ByteArrayWrapper key, ByteArrayWrapper member) {\n+    return get(key).sismember(key, member);\n+  }\n+\n+  @Override\n+  public Collection<ByteArrayWrapper> srandmember(\n+      ByteArrayWrapper key, int count) {\n+    return get(key).srandmember(key, count);\n+  }\n+\n+  @Override\n+  public Collection<ByteArrayWrapper> spop(\n+      ByteArrayWrapper key, int popCount) {\n+    RedisSet redisSet = get(key);\n+    Collection<ByteArrayWrapper> byteArrayWrappers = redisSet.spop(key, popCount);\n+    if (get(key).scard(key) == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7326f62a4d7d42a3daa36f83ac372ed935567c7e"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIxNjYzOQ==", "bodyText": "change \"get(key)\" to \"redisSet\"", "url": "https://github.com/apache/geode/pull/5100#discussion_r424216639", "createdAt": "2020-05-13T07:07:11Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/set/RedisSetInRegion.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis.internal.executor.set;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.regex.Pattern;\n+\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.redis.internal.ByteArrayWrapper;\n+\n+/**\n+ * This class checks whether a RedisSet exists before forwarding the message.\n+ */\n+public class RedisSetInRegion implements RedisSetCommands {\n+  private Region<ByteArrayWrapper, RedisSet> region;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public RedisSetInRegion(Region<ByteArrayWrapper, RedisSet> region) {\n+    this.region = region;\n+  }\n+\n+  @Override\n+  public long sadd(\n+      ByteArrayWrapper key,\n+      ArrayList<ByteArrayWrapper> membersToAdd) {\n+    RedisSet redisSet = get(key);\n+    long l = redisSet.sadd(key, membersToAdd);\n+    if (l > 0) {\n+      region.put(key, redisSet);\n+    }\n+    return l;\n+  }\n+\n+  @Override\n+  public long srem(\n+      ByteArrayWrapper key,\n+      ArrayList<ByteArrayWrapper> membersToRemove, AtomicBoolean setWasDeleted) {\n+    RedisSet redisSet = get(key);\n+    long l = redisSet.srem(key, membersToRemove, setWasDeleted);\n+    if (get(key).scard(key) == 0) {\n+      region.remove(key);\n+    } else {\n+      region.put(key, get(key));\n+    }\n+    return l;\n+  }\n+\n+  public boolean del(ByteArrayWrapper key) {\n+    return region.remove(key) != null;\n+  }\n+\n+  @Override\n+  public Set<ByteArrayWrapper> smembers(\n+      ByteArrayWrapper key) {\n+    return get(key).smembers(key);\n+  }\n+\n+  @Override\n+  public int scard(ByteArrayWrapper key) {\n+    return get(key).scard(key);\n+  }\n+\n+  @Override\n+  public boolean sismember(\n+      ByteArrayWrapper key, ByteArrayWrapper member) {\n+    return get(key).sismember(key, member);\n+  }\n+\n+  @Override\n+  public Collection<ByteArrayWrapper> srandmember(\n+      ByteArrayWrapper key, int count) {\n+    return get(key).srandmember(key, count);\n+  }\n+\n+  @Override\n+  public Collection<ByteArrayWrapper> spop(\n+      ByteArrayWrapper key, int popCount) {\n+    RedisSet redisSet = get(key);\n+    Collection<ByteArrayWrapper> byteArrayWrappers = redisSet.spop(key, popCount);\n+    if (get(key).scard(key) == 0) {\n+      region.remove(key);\n+    } else {\n+      region.put(key, get(key));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7326f62a4d7d42a3daa36f83ac372ed935567c7e"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIxNzgzOA==", "bodyText": "I prefer getting null back from this method to prevent garbage creation. I know you prefer keeping the callers simpler by always returning a non-null. Can you return a canonical empty instance instead of always creating a new  RedisSet  and a new ArrayList?", "url": "https://github.com/apache/geode/pull/5100#discussion_r424217838", "createdAt": "2020-05-13T07:09:40Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/set/RedisSetInRegion.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis.internal.executor.set;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.regex.Pattern;\n+\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.redis.internal.ByteArrayWrapper;\n+\n+/**\n+ * This class checks whether a RedisSet exists before forwarding the message.\n+ */\n+public class RedisSetInRegion implements RedisSetCommands {\n+  private Region<ByteArrayWrapper, RedisSet> region;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public RedisSetInRegion(Region<ByteArrayWrapper, RedisSet> region) {\n+    this.region = region;\n+  }\n+\n+  @Override\n+  public long sadd(\n+      ByteArrayWrapper key,\n+      ArrayList<ByteArrayWrapper> membersToAdd) {\n+    RedisSet redisSet = get(key);\n+    long l = redisSet.sadd(key, membersToAdd);\n+    if (l > 0) {\n+      region.put(key, redisSet);\n+    }\n+    return l;\n+  }\n+\n+  @Override\n+  public long srem(\n+      ByteArrayWrapper key,\n+      ArrayList<ByteArrayWrapper> membersToRemove, AtomicBoolean setWasDeleted) {\n+    RedisSet redisSet = get(key);\n+    long l = redisSet.srem(key, membersToRemove, setWasDeleted);\n+    if (get(key).scard(key) == 0) {\n+      region.remove(key);\n+    } else {\n+      region.put(key, get(key));\n+    }\n+    return l;\n+  }\n+\n+  public boolean del(ByteArrayWrapper key) {\n+    return region.remove(key) != null;\n+  }\n+\n+  @Override\n+  public Set<ByteArrayWrapper> smembers(\n+      ByteArrayWrapper key) {\n+    return get(key).smembers(key);\n+  }\n+\n+  @Override\n+  public int scard(ByteArrayWrapper key) {\n+    return get(key).scard(key);\n+  }\n+\n+  @Override\n+  public boolean sismember(\n+      ByteArrayWrapper key, ByteArrayWrapper member) {\n+    return get(key).sismember(key, member);\n+  }\n+\n+  @Override\n+  public Collection<ByteArrayWrapper> srandmember(\n+      ByteArrayWrapper key, int count) {\n+    return get(key).srandmember(key, count);\n+  }\n+\n+  @Override\n+  public Collection<ByteArrayWrapper> spop(\n+      ByteArrayWrapper key, int popCount) {\n+    RedisSet redisSet = get(key);\n+    Collection<ByteArrayWrapper> byteArrayWrappers = redisSet.spop(key, popCount);\n+    if (get(key).scard(key) == 0) {\n+      region.remove(key);\n+    } else {\n+      region.put(key, get(key));\n+    }\n+    return byteArrayWrappers;\n+  }\n+\n+  @Override\n+  public List<Object> sscan(\n+      ByteArrayWrapper key, Pattern matchPattern, int count, int cursor) {\n+    return get(key).sscan(key, matchPattern, count, cursor);\n+  }\n+\n+  private RedisSet get(ByteArrayWrapper key) {\n+    RedisSet redisSet = region.get(key);\n+    return redisSet == null ? new RedisSet(new ArrayList<>()) : redisSet;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7326f62a4d7d42a3daa36f83ac372ed935567c7e"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIyMTM3MA==", "bodyText": "I don't think they way you have refactored the delta code is thread safe. As long as we have set ops that do not use the function+delta (that is why this method is synchronized still) then we need to send the delta before this synchronization is released.\nI also don't like that we leave deltas set until the next operation is done. This will just extend its life when it should have been garbage before this method released in sync. I think this issue with the delta management is throughout this class.", "url": "https://github.com/apache/geode/pull/5100#discussion_r424221370", "createdAt": "2020-05-13T07:16:52Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/set/RedisSet.java", "diffHunk": "@@ -304,70 +211,60 @@ public void fromData(DataInput in) throws IOException, ClassNotFoundException {\n   }\n \n   /**\n-   * @param membersToAdd members to add to this set; NOTE this list may by\n-   *        modified by this call\n-   * @param region the region this instance is stored in\n    * @param key the name of the set to add to\n+   * @param membersToAdd members to add to this set; NOTE this list may by modified by this call\n    * @return the number of members actually added; -1 if concurrent modification\n    */\n-  private synchronized long doSadd(ArrayList<ByteArrayWrapper> membersToAdd,\n-      Region<ByteArrayWrapper, RedisSet> region,\n-      ByteArrayWrapper key) {\n-\n+  @Override\n+  public synchronized long sadd(ByteArrayWrapper key, ArrayList<ByteArrayWrapper> membersToAdd) {\n+    this.deltas = null;\n     membersToAdd.removeIf(memberToAdd -> !members.add(memberToAdd));\n     int membersAdded = membersToAdd.size();\n     if (membersAdded != 0) {\n       deltasAreAdds = true;\n       deltas = membersToAdd;\n-      try {\n-        region.put(key, this);\n-      } finally {\n-        deltas = null;\n-      }\n     }\n     return membersAdded;\n   }\n \n   /**\n-   * @param membersToRemove members to remove from this set; NOTE this list may by\n-   *        modified by this call\n-   * @param region the region this instance is stored in\n    * @param key the name of the set to remove from\n+   * @param membersToRemove members to remove from this set; NOTE this list may by modified by this\n+   *        call\n    * @param setWasDeleted set to true if this method deletes the set\n    * @return the number of members actually removed; -1 if concurrent modification\n    */\n-  private synchronized long doSrem(ArrayList<ByteArrayWrapper> membersToRemove,\n-      Region<ByteArrayWrapper, RedisSet> region,\n-      ByteArrayWrapper key, AtomicBoolean setWasDeleted) {\n-\n+  @Override\n+  public synchronized long srem(ByteArrayWrapper key, ArrayList<ByteArrayWrapper> membersToRemove,\n+      AtomicBoolean setWasDeleted) {\n+    deltas = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7326f62a4d7d42a3daa36f83ac372ed935567c7e"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIyMzE3Mg==", "bodyText": "I don't think you should force RedisSetCommands on this class. None of the methods on this class currently need the \"key\" parameter because they do not need to find themselves in the region. But RedisSetCommands methods do  need a \"key\". I think that abstraction really does not fit this class.", "url": "https://github.com/apache/geode/pull/5100#discussion_r424223172", "createdAt": "2020-05-13T07:20:29Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/set/RedisSet.java", "diffHunk": "@@ -34,18 +33,15 @@\n import org.apache.geode.DataSerializer;\n import org.apache.geode.Delta;\n import org.apache.geode.InvalidDeltaException;\n-import org.apache.geode.cache.Region;\n import org.apache.geode.redis.internal.ByteArrayWrapper;\n import org.apache.geode.redis.internal.Coder;\n \n /**\n- * This class still uses \"synchronized\" to protect the\n- * underlying HashSet even though all writers do so under\n- * the {@link SynchronizedStripedExecutor}. The synchronization on this\n- * class can be removed once readers are changed to\n- * also use the {@link SynchronizedStripedExecutor}.\n+ * This class still uses \"synchronized\" to protect the underlying HashSet even though all writers do\n+ * so under the {@link SynchronizedStripedExecutor}. The synchronization on this class can be\n+ * removed once readers are changed to also use the {@link SynchronizedStripedExecutor}.\n  */\n-public class RedisSet implements Delta, DataSerializable {\n+public class RedisSet implements Delta, DataSerializable, RedisSetCommands {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7326f62a4d7d42a3daa36f83ac372ed935567c7e"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIyNjUzOQ==", "bodyText": "Maybe we could pass the RedisSetInRegion into the methods that need to update the region. If we added the \"key\" to RedisSetInRegion then it would know what key it is supposed to remove or put when we callback to it.\nThis would also allow the RedisSetInRegion and RedisSet to both implement a common interface (neither of their methods would have \"key\" parameters).", "url": "https://github.com/apache/geode/pull/5100#discussion_r424226539", "createdAt": "2020-05-13T07:26:51Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/set/RedisSet.java", "diffHunk": "@@ -304,70 +211,60 @@ public void fromData(DataInput in) throws IOException, ClassNotFoundException {\n   }\n \n   /**\n-   * @param membersToAdd members to add to this set; NOTE this list may by\n-   *        modified by this call\n-   * @param region the region this instance is stored in\n    * @param key the name of the set to add to\n+   * @param membersToAdd members to add to this set; NOTE this list may by modified by this call\n    * @return the number of members actually added; -1 if concurrent modification\n    */\n-  private synchronized long doSadd(ArrayList<ByteArrayWrapper> membersToAdd,\n-      Region<ByteArrayWrapper, RedisSet> region,\n-      ByteArrayWrapper key) {\n-\n+  @Override\n+  public synchronized long sadd(ByteArrayWrapper key, ArrayList<ByteArrayWrapper> membersToAdd) {\n+    this.deltas = null;\n     membersToAdd.removeIf(memberToAdd -> !members.add(memberToAdd));\n     int membersAdded = membersToAdd.size();\n     if (membersAdded != 0) {\n       deltasAreAdds = true;\n       deltas = membersToAdd;\n-      try {\n-        region.put(key, this);\n-      } finally {\n-        deltas = null;\n-      }\n     }\n     return membersAdded;\n   }\n \n   /**\n-   * @param membersToRemove members to remove from this set; NOTE this list may by\n-   *        modified by this call\n-   * @param region the region this instance is stored in\n    * @param key the name of the set to remove from\n+   * @param membersToRemove members to remove from this set; NOTE this list may by modified by this\n+   *        call\n    * @param setWasDeleted set to true if this method deletes the set\n    * @return the number of members actually removed; -1 if concurrent modification\n    */\n-  private synchronized long doSrem(ArrayList<ByteArrayWrapper> membersToRemove,\n-      Region<ByteArrayWrapper, RedisSet> region,\n-      ByteArrayWrapper key, AtomicBoolean setWasDeleted) {\n-\n+  @Override\n+  public synchronized long srem(ByteArrayWrapper key, ArrayList<ByteArrayWrapper> membersToRemove,\n+      AtomicBoolean setWasDeleted) {\n+    deltas = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIyMTM3MA=="}, "originalCommit": {"oid": "7326f62a4d7d42a3daa36f83ac372ed935567c7e"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIyNzIxMw==", "bodyText": "make this field final", "url": "https://github.com/apache/geode/pull/5100#discussion_r424227213", "createdAt": "2020-05-13T07:28:03Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/set/RedisSetInRegion.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis.internal.executor.set;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.regex.Pattern;\n+\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.redis.internal.ByteArrayWrapper;\n+\n+/**\n+ * This class checks whether a RedisSet exists before forwarding the message.\n+ */\n+public class RedisSetInRegion implements RedisSetCommands {\n+  private Region<ByteArrayWrapper, RedisSet> region;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7326f62a4d7d42a3daa36f83ac372ed935567c7e"}, "originalPosition": 32}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64a2d7eee002756828f20d0d0eb596639960b7de", "author": {"user": {"login": "prettyClouds", "name": "Murtuza Boxwala"}}, "url": "https://github.com/apache/geode/commit/64a2d7eee002756828f20d0d0eb596639960b7de", "committedDate": "2020-05-13T17:09:42Z", "message": "get rid of static methods"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7326f62a4d7d42a3daa36f83ac372ed935567c7e", "author": {"user": {"login": "prettyClouds", "name": "Murtuza Boxwala"}}, "url": "https://github.com/apache/geode/commit/7326f62a4d7d42a3daa36f83ac372ed935567c7e", "committedDate": "2020-05-12T21:13:09Z", "message": "spA"}, "afterCommit": {"oid": "64a2d7eee002756828f20d0d0eb596639960b7de", "author": {"user": {"login": "prettyClouds", "name": "Murtuza Boxwala"}}, "url": "https://github.com/apache/geode/commit/64a2d7eee002756828f20d0d0eb596639960b7de", "committedDate": "2020-05-13T17:09:42Z", "message": "get rid of static methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "659442bb2d81796f5bca2dea8c22457b00d82a2c", "author": {"user": {"login": "prettyClouds", "name": "Murtuza Boxwala"}}, "url": "https://github.com/apache/geode/commit/659442bb2d81796f5bca2dea8c22457b00d82a2c", "committedDate": "2020-05-13T18:01:29Z", "message": "Empty objects instead of nulls"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61a5780a60aad61bd4d1f8ec2d47b162fc74d6b3", "author": {"user": {"login": "prettyClouds", "name": "Murtuza Boxwala"}}, "url": "https://github.com/apache/geode/commit/61a5780a60aad61bd4d1f8ec2d47b162fc74d6b3", "committedDate": "2020-05-13T18:05:40Z", "message": "rename methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2879ad5a2879d0a7314ef1bd59115b5cacafcc08", "author": {"user": {"login": "prettyClouds", "name": "Murtuza Boxwala"}}, "url": "https://github.com/apache/geode/commit/2879ad5a2879d0a7314ef1bd59115b5cacafcc08", "committedDate": "2020-05-13T20:05:49Z", "message": "fix unchecked warning"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExMjY2NzY5", "url": "https://github.com/apache/geode/pull/5100#pullrequestreview-411266769", "createdAt": "2020-05-13T20:16:21Z", "commit": {"oid": "2879ad5a2879d0a7314ef1bd59115b5cacafcc08"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMDoxNjoyMVrOGVB9rA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMDoxNjoyMVrOGVB9rA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcwNTQ1Mg==", "bodyText": "Would it be worth refactoring this \"region.getOrDefault(key, RedisSet.EMPTY)\" into a local private method named \"getRedisSet(key)\" and then these methods can just be a one liner: \"return getRedisSet(key).smembers()\"", "url": "https://github.com/apache/geode/pull/5100#discussion_r424705452", "createdAt": "2020-05-13T20:16:21Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/set/RedisSetInRegion.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis.internal.executor.set;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.regex.Pattern;\n+\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.redis.internal.ByteArrayWrapper;\n+\n+/**\n+ * This class still uses \"synchronized\" to protect the underlying HashSet even though all writers do\n+ * so under the {@link SynchronizedStripedExecutor}. The synchronization on this class can be\n+ * removed once readers are changed to also use the {@link SynchronizedStripedExecutor}.\n+ */\n+public class RedisSetInRegion implements RedisSetCommands {\n+  private final Region<ByteArrayWrapper, RedisSet> region;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public RedisSetInRegion(Region<ByteArrayWrapper, RedisSet> region) {\n+    this.region = region;\n+  }\n+\n+  @Override\n+  public long sadd(\n+      ByteArrayWrapper key,\n+      ArrayList<ByteArrayWrapper> membersToAdd) {\n+\n+    RedisSet redisSet = region.get(key);\n+\n+    if (redisSet != null) {\n+      return redisSet.sadd(membersToAdd, region, key);\n+    } else {\n+      region.create(key, new RedisSet(membersToAdd));\n+      return membersToAdd.size();\n+    }\n+  }\n+\n+  @Override\n+  public long srem(\n+      ByteArrayWrapper key,\n+      ArrayList<ByteArrayWrapper> membersToRemove, AtomicBoolean setWasDeleted) {\n+    RedisSet redisSet = region.getOrDefault(key, RedisSet.EMPTY);\n+    return redisSet.srem(membersToRemove, region, key, setWasDeleted);\n+  }\n+\n+  public boolean del(ByteArrayWrapper key) {\n+    return region.remove(key) != null;\n+  }\n+\n+  @Override\n+  public Set<ByteArrayWrapper> smembers(\n+      ByteArrayWrapper key) {\n+    RedisSet redisSet = region.getOrDefault(key, RedisSet.EMPTY);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2879ad5a2879d0a7314ef1bd59115b5cacafcc08"}, "originalPosition": 71}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7da24d9f1010c7afd50a2622809524e02c298cb0", "author": {"user": {"login": "prettyClouds", "name": "Murtuza Boxwala"}}, "url": "https://github.com/apache/geode/commit/7da24d9f1010c7afd50a2622809524e02c298cb0", "committedDate": "2020-05-13T20:29:21Z", "message": "Refactor: extract method"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExMzI2ODE0", "url": "https://github.com/apache/geode/pull/5100#pullrequestreview-411326814", "createdAt": "2020-05-13T21:54:10Z", "commit": {"oid": "7da24d9f1010c7afd50a2622809524e02c298cb0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4515, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}