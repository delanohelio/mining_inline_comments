{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk0OTkyMzQ1", "number": 4862, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QyMjoyNjowNlrODsPpug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNTozNzoyNVrODsu2VA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3NzIwMzc4OnYy", "diffSide": "RIGHT", "path": "geode-membership/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/MembershipIntegrationTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QyMjoyNjowNlrOF9Djaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QyMjoyNjowNlrOF9Djaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU2NTY3NQ==", "bodyText": "do we want to say twoMembershhipsCanStart\u2026 to be consistent w/ other test names?", "url": "https://github.com/apache/geode/pull/4862#discussion_r399565675", "createdAt": "2020-03-27T22:26:06Z", "author": {"login": "Bill"}, "path": "geode-membership/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/MembershipIntegrationTest.java", "diffHunk": "@@ -0,0 +1,206 @@\n+package org.apache.geode.distributed.internal.membership.gms;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import org.apache.geode.distributed.internal.membership.api.MemberIdentifier;\n+import org.apache.geode.distributed.internal.membership.api.MemberIdentifierFactoryImpl;\n+import org.apache.geode.distributed.internal.membership.api.MemberStartupException;\n+import org.apache.geode.distributed.internal.membership.api.Membership;\n+import org.apache.geode.distributed.internal.membership.api.MembershipBuilder;\n+import org.apache.geode.distributed.internal.membership.api.MembershipConfig;\n+import org.apache.geode.distributed.internal.membership.api.MembershipConfigurationException;\n+import org.apache.geode.distributed.internal.membership.api.MembershipLocator;\n+import org.apache.geode.distributed.internal.membership.api.MembershipLocatorBuilder;\n+import org.apache.geode.distributed.internal.tcpserver.TcpClient;\n+import org.apache.geode.distributed.internal.tcpserver.TcpSocketCreator;\n+import org.apache.geode.distributed.internal.tcpserver.TcpSocketCreatorImpl;\n+import org.apache.geode.distributed.internal.tcpserver.TcpSocketFactory;\n+import org.apache.geode.internal.serialization.DSFIDSerializer;\n+import org.apache.geode.internal.serialization.internal.DSFIDSerializerImpl;\n+import org.apache.geode.logging.internal.executors.LoggingExecutors;\n+\n+/**\n+ * Tests of using the membership APIs to make multiple Membership systems that communicate\n+ * with each other and form a group\n+ */\n+public class MembershipIntegrationTest {\n+  private InetAddress localHost;\n+  private DSFIDSerializer dsfidSerializer;\n+  private TcpSocketCreator socketCreator;\n+\n+  @Rule\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  @Before\n+  public void before() throws IOException, MembershipConfigurationException {\n+    localHost = InetAddress.getLocalHost();\n+    dsfidSerializer = new DSFIDSerializerImpl();\n+    socketCreator = new TcpSocketCreatorImpl();\n+  }\n+\n+  @Test\n+  public void oneMembershipCanStartWithALocator()\n+      throws IOException, MemberStartupException {\n+    final MembershipLocator<MemberIdentifier> locator = createLocator(0);\n+    locator.start();\n+\n+    final Membership<MemberIdentifier> membership = createMembership(locator,\n+        locator.getPort());\n+    start(membership);\n+\n+    assertThat(membership.getView().getMembers()).hasSize(1);\n+  }\n+\n+  @Test\n+  public void twoMembersCanStartWithOneLocator()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3feec6680bc6e6a85cd42c0671504455d567a809"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3NzIxNTM3OnYy", "diffSide": "RIGHT", "path": "geode-membership/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/MembershipIntegrationTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QyMjozMTo1MlrOF9DqOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNTo1NDozNVrOF9wmKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU2NzQxNw==", "bodyText": "would it be better to send in the VM kind instead of the boolean isALocator? doing that would eliminate the conditional here.", "url": "https://github.com/apache/geode/pull/4862#discussion_r399567417", "createdAt": "2020-03-27T22:31:52Z", "author": {"login": "Bill"}, "path": "geode-membership/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/MembershipIntegrationTest.java", "diffHunk": "@@ -0,0 +1,206 @@\n+package org.apache.geode.distributed.internal.membership.gms;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import org.apache.geode.distributed.internal.membership.api.MemberIdentifier;\n+import org.apache.geode.distributed.internal.membership.api.MemberIdentifierFactoryImpl;\n+import org.apache.geode.distributed.internal.membership.api.MemberStartupException;\n+import org.apache.geode.distributed.internal.membership.api.Membership;\n+import org.apache.geode.distributed.internal.membership.api.MembershipBuilder;\n+import org.apache.geode.distributed.internal.membership.api.MembershipConfig;\n+import org.apache.geode.distributed.internal.membership.api.MembershipConfigurationException;\n+import org.apache.geode.distributed.internal.membership.api.MembershipLocator;\n+import org.apache.geode.distributed.internal.membership.api.MembershipLocatorBuilder;\n+import org.apache.geode.distributed.internal.tcpserver.TcpClient;\n+import org.apache.geode.distributed.internal.tcpserver.TcpSocketCreator;\n+import org.apache.geode.distributed.internal.tcpserver.TcpSocketCreatorImpl;\n+import org.apache.geode.distributed.internal.tcpserver.TcpSocketFactory;\n+import org.apache.geode.internal.serialization.DSFIDSerializer;\n+import org.apache.geode.internal.serialization.internal.DSFIDSerializerImpl;\n+import org.apache.geode.logging.internal.executors.LoggingExecutors;\n+\n+/**\n+ * Tests of using the membership APIs to make multiple Membership systems that communicate\n+ * with each other and form a group\n+ */\n+public class MembershipIntegrationTest {\n+  private InetAddress localHost;\n+  private DSFIDSerializer dsfidSerializer;\n+  private TcpSocketCreator socketCreator;\n+\n+  @Rule\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  @Before\n+  public void before() throws IOException, MembershipConfigurationException {\n+    localHost = InetAddress.getLocalHost();\n+    dsfidSerializer = new DSFIDSerializerImpl();\n+    socketCreator = new TcpSocketCreatorImpl();\n+  }\n+\n+  @Test\n+  public void oneMembershipCanStartWithALocator()\n+      throws IOException, MemberStartupException {\n+    final MembershipLocator<MemberIdentifier> locator = createLocator(0);\n+    locator.start();\n+\n+    final Membership<MemberIdentifier> membership = createMembership(locator,\n+        locator.getPort());\n+    start(membership);\n+\n+    assertThat(membership.getView().getMembers()).hasSize(1);\n+  }\n+\n+  @Test\n+  public void twoMembersCanStartWithOneLocator()\n+      throws IOException, MemberStartupException {\n+    final MembershipLocator<MemberIdentifier> locator = createLocator(0);\n+    locator.start();\n+    final int locatorPort = locator.getPort();\n+\n+    final Membership<MemberIdentifier> membership1 = createMembership(locator, locatorPort);\n+    start(membership1);\n+\n+    final Membership<MemberIdentifier> membership2 = createMembership(null, locatorPort);\n+    start(membership2);\n+\n+    assertThat(membership1.getView().getMembers()).hasSize(2);\n+    assertThat(membership2.getView().getMembers()).hasSize(2);\n+  }\n+\n+  @Test\n+  public void twoLocatorsCanStartSequentially()\n+      throws IOException, MemberStartupException {\n+\n+    final MembershipLocator<MemberIdentifier> locator1 = createLocator(0);\n+    locator1.start();\n+    final int locatorPort1 = locator1.getPort();\n+\n+    Membership<MemberIdentifier> membership1 = createMembership(locator1, locatorPort1);\n+    start(membership1);\n+\n+    final MembershipLocator<MemberIdentifier> locator2 = createLocator(0, locatorPort1);\n+    locator2.start();\n+    final int locatorPort2 = locator2.getPort();\n+\n+    Membership<MemberIdentifier> membership2 =\n+        createMembership(locator2, locatorPort1, locatorPort2);\n+    start(membership2);\n+\n+    assertThat(membership1.getView().getMembers()).hasSize(2);\n+    assertThat(membership2.getView().getMembers()).hasSize(2);\n+  }\n+\n+  @Test\n+  public void secondMembershipCanJoinUsingTheSecondLocatorToStart()\n+      throws IOException, MemberStartupException {\n+\n+    final MembershipLocator<MemberIdentifier> locator1 = createLocator(0);\n+    locator1.start();\n+    final int locatorPort1 = locator1.getPort();\n+\n+    final Membership<MemberIdentifier> membership1 = createMembership(locator1, locatorPort1);\n+    start(membership1);\n+\n+    final MembershipLocator<MemberIdentifier> locator2 = createLocator(0, locatorPort1);\n+    locator2.start();\n+    int locatorPort2 = locator2.getPort();\n+\n+    // Force the next membership to use locator2 by stopping locator1\n+    locator1.stop();\n+\n+    Membership<MemberIdentifier> membership2 =\n+        createMembership(locator2, locatorPort1, locatorPort2);\n+    start(membership2);\n+\n+    assertThat(membership1.getView().getMembers()).hasSize(2);\n+    assertThat(membership2.getView().getMembers()).hasSize(2);\n+  }\n+\n+  private void start(final Membership<MemberIdentifier> membership)\n+      throws MemberStartupException {\n+    membership.start();\n+    membership.startEventProcessing();\n+  }\n+\n+  private Membership<MemberIdentifier> createMembership(\n+      final MembershipLocator<MemberIdentifier> embeddedLocator,\n+      final int... locatorPorts)\n+      throws MembershipConfigurationException {\n+    final boolean isALocator = embeddedLocator != null;\n+    final MembershipConfig config = createMembershipConfig(isALocator, locatorPorts);\n+\n+    final MemberIdentifierFactoryImpl memberIdFactory = new MemberIdentifierFactoryImpl();\n+\n+    final TcpClient locatorClient =\n+        new TcpClient(socketCreator, dsfidSerializer.getObjectSerializer(),\n+            dsfidSerializer.getObjectDeserializer(), TcpSocketFactory.DEFAULT);\n+\n+    return MembershipBuilder.<MemberIdentifier>newMembershipBuilder(\n+        socketCreator, locatorClient, dsfidSerializer, memberIdFactory)\n+        .setMembershipLocator(embeddedLocator)\n+        .setConfig(config)\n+        .create();\n+  }\n+\n+  private MembershipConfig createMembershipConfig(\n+      final boolean isALocator,\n+      final int[] locatorPorts) {\n+    return new MembershipConfig() {\n+      public String getLocators() {\n+        return getLocatorString(locatorPorts);\n+      }\n+\n+      // TODO - the Membership system starting in the locator *MUST* be told that is\n+      // is a locator through this flag. Ideally it should be able to infer this from\n+      // being associated with a locator\n+      @Override\n+      public int getVmKind() {\n+        return isALocator ? MemberIdentifier.LOCATOR_DM_TYPE : MemberIdentifier.NORMAL_DM_TYPE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3feec6680bc6e6a85cd42c0671504455d567a809"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDMwMzY1Nw==", "bodyText": "Seems like that would just shift the conditional? I think I'll leave it the way it is for now since we want to get rid of this flag entirely when we fix the membership code.", "url": "https://github.com/apache/geode/pull/4862#discussion_r400303657", "createdAt": "2020-03-30T15:54:35Z", "author": {"login": "upthewaterspout"}, "path": "geode-membership/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/MembershipIntegrationTest.java", "diffHunk": "@@ -0,0 +1,206 @@\n+package org.apache.geode.distributed.internal.membership.gms;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import org.apache.geode.distributed.internal.membership.api.MemberIdentifier;\n+import org.apache.geode.distributed.internal.membership.api.MemberIdentifierFactoryImpl;\n+import org.apache.geode.distributed.internal.membership.api.MemberStartupException;\n+import org.apache.geode.distributed.internal.membership.api.Membership;\n+import org.apache.geode.distributed.internal.membership.api.MembershipBuilder;\n+import org.apache.geode.distributed.internal.membership.api.MembershipConfig;\n+import org.apache.geode.distributed.internal.membership.api.MembershipConfigurationException;\n+import org.apache.geode.distributed.internal.membership.api.MembershipLocator;\n+import org.apache.geode.distributed.internal.membership.api.MembershipLocatorBuilder;\n+import org.apache.geode.distributed.internal.tcpserver.TcpClient;\n+import org.apache.geode.distributed.internal.tcpserver.TcpSocketCreator;\n+import org.apache.geode.distributed.internal.tcpserver.TcpSocketCreatorImpl;\n+import org.apache.geode.distributed.internal.tcpserver.TcpSocketFactory;\n+import org.apache.geode.internal.serialization.DSFIDSerializer;\n+import org.apache.geode.internal.serialization.internal.DSFIDSerializerImpl;\n+import org.apache.geode.logging.internal.executors.LoggingExecutors;\n+\n+/**\n+ * Tests of using the membership APIs to make multiple Membership systems that communicate\n+ * with each other and form a group\n+ */\n+public class MembershipIntegrationTest {\n+  private InetAddress localHost;\n+  private DSFIDSerializer dsfidSerializer;\n+  private TcpSocketCreator socketCreator;\n+\n+  @Rule\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  @Before\n+  public void before() throws IOException, MembershipConfigurationException {\n+    localHost = InetAddress.getLocalHost();\n+    dsfidSerializer = new DSFIDSerializerImpl();\n+    socketCreator = new TcpSocketCreatorImpl();\n+  }\n+\n+  @Test\n+  public void oneMembershipCanStartWithALocator()\n+      throws IOException, MemberStartupException {\n+    final MembershipLocator<MemberIdentifier> locator = createLocator(0);\n+    locator.start();\n+\n+    final Membership<MemberIdentifier> membership = createMembership(locator,\n+        locator.getPort());\n+    start(membership);\n+\n+    assertThat(membership.getView().getMembers()).hasSize(1);\n+  }\n+\n+  @Test\n+  public void twoMembersCanStartWithOneLocator()\n+      throws IOException, MemberStartupException {\n+    final MembershipLocator<MemberIdentifier> locator = createLocator(0);\n+    locator.start();\n+    final int locatorPort = locator.getPort();\n+\n+    final Membership<MemberIdentifier> membership1 = createMembership(locator, locatorPort);\n+    start(membership1);\n+\n+    final Membership<MemberIdentifier> membership2 = createMembership(null, locatorPort);\n+    start(membership2);\n+\n+    assertThat(membership1.getView().getMembers()).hasSize(2);\n+    assertThat(membership2.getView().getMembers()).hasSize(2);\n+  }\n+\n+  @Test\n+  public void twoLocatorsCanStartSequentially()\n+      throws IOException, MemberStartupException {\n+\n+    final MembershipLocator<MemberIdentifier> locator1 = createLocator(0);\n+    locator1.start();\n+    final int locatorPort1 = locator1.getPort();\n+\n+    Membership<MemberIdentifier> membership1 = createMembership(locator1, locatorPort1);\n+    start(membership1);\n+\n+    final MembershipLocator<MemberIdentifier> locator2 = createLocator(0, locatorPort1);\n+    locator2.start();\n+    final int locatorPort2 = locator2.getPort();\n+\n+    Membership<MemberIdentifier> membership2 =\n+        createMembership(locator2, locatorPort1, locatorPort2);\n+    start(membership2);\n+\n+    assertThat(membership1.getView().getMembers()).hasSize(2);\n+    assertThat(membership2.getView().getMembers()).hasSize(2);\n+  }\n+\n+  @Test\n+  public void secondMembershipCanJoinUsingTheSecondLocatorToStart()\n+      throws IOException, MemberStartupException {\n+\n+    final MembershipLocator<MemberIdentifier> locator1 = createLocator(0);\n+    locator1.start();\n+    final int locatorPort1 = locator1.getPort();\n+\n+    final Membership<MemberIdentifier> membership1 = createMembership(locator1, locatorPort1);\n+    start(membership1);\n+\n+    final MembershipLocator<MemberIdentifier> locator2 = createLocator(0, locatorPort1);\n+    locator2.start();\n+    int locatorPort2 = locator2.getPort();\n+\n+    // Force the next membership to use locator2 by stopping locator1\n+    locator1.stop();\n+\n+    Membership<MemberIdentifier> membership2 =\n+        createMembership(locator2, locatorPort1, locatorPort2);\n+    start(membership2);\n+\n+    assertThat(membership1.getView().getMembers()).hasSize(2);\n+    assertThat(membership2.getView().getMembers()).hasSize(2);\n+  }\n+\n+  private void start(final Membership<MemberIdentifier> membership)\n+      throws MemberStartupException {\n+    membership.start();\n+    membership.startEventProcessing();\n+  }\n+\n+  private Membership<MemberIdentifier> createMembership(\n+      final MembershipLocator<MemberIdentifier> embeddedLocator,\n+      final int... locatorPorts)\n+      throws MembershipConfigurationException {\n+    final boolean isALocator = embeddedLocator != null;\n+    final MembershipConfig config = createMembershipConfig(isALocator, locatorPorts);\n+\n+    final MemberIdentifierFactoryImpl memberIdFactory = new MemberIdentifierFactoryImpl();\n+\n+    final TcpClient locatorClient =\n+        new TcpClient(socketCreator, dsfidSerializer.getObjectSerializer(),\n+            dsfidSerializer.getObjectDeserializer(), TcpSocketFactory.DEFAULT);\n+\n+    return MembershipBuilder.<MemberIdentifier>newMembershipBuilder(\n+        socketCreator, locatorClient, dsfidSerializer, memberIdFactory)\n+        .setMembershipLocator(embeddedLocator)\n+        .setConfig(config)\n+        .create();\n+  }\n+\n+  private MembershipConfig createMembershipConfig(\n+      final boolean isALocator,\n+      final int[] locatorPorts) {\n+    return new MembershipConfig() {\n+      public String getLocators() {\n+        return getLocatorString(locatorPorts);\n+      }\n+\n+      // TODO - the Membership system starting in the locator *MUST* be told that is\n+      // is a locator through this flag. Ideally it should be able to infer this from\n+      // being associated with a locator\n+      @Override\n+      public int getVmKind() {\n+        return isALocator ? MemberIdentifier.LOCATOR_DM_TYPE : MemberIdentifier.NORMAL_DM_TYPE;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU2NzQxNw=="}, "originalCommit": {"oid": "3feec6680bc6e6a85cd42c0671504455d567a809"}, "originalPosition": 172}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MjMxNTA4OnYy", "diffSide": "RIGHT", "path": "geode-membership/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/MembershipIntegrationTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNTozNzoyNVrOF9vzug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNjowMjoxNVrOF9w8sQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDI5MDc0Ng==", "bodyText": "This should use LocalHostUtil.getLocalHost()", "url": "https://github.com/apache/geode/pull/4862#discussion_r400290746", "createdAt": "2020-03-30T15:37:25Z", "author": {"login": "bschuchardt"}, "path": "geode-membership/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/MembershipIntegrationTest.java", "diffHunk": "@@ -0,0 +1,206 @@\n+package org.apache.geode.distributed.internal.membership.gms;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import org.apache.geode.distributed.internal.membership.api.MemberIdentifier;\n+import org.apache.geode.distributed.internal.membership.api.MemberIdentifierFactoryImpl;\n+import org.apache.geode.distributed.internal.membership.api.MemberStartupException;\n+import org.apache.geode.distributed.internal.membership.api.Membership;\n+import org.apache.geode.distributed.internal.membership.api.MembershipBuilder;\n+import org.apache.geode.distributed.internal.membership.api.MembershipConfig;\n+import org.apache.geode.distributed.internal.membership.api.MembershipConfigurationException;\n+import org.apache.geode.distributed.internal.membership.api.MembershipLocator;\n+import org.apache.geode.distributed.internal.membership.api.MembershipLocatorBuilder;\n+import org.apache.geode.distributed.internal.tcpserver.TcpClient;\n+import org.apache.geode.distributed.internal.tcpserver.TcpSocketCreator;\n+import org.apache.geode.distributed.internal.tcpserver.TcpSocketCreatorImpl;\n+import org.apache.geode.distributed.internal.tcpserver.TcpSocketFactory;\n+import org.apache.geode.internal.serialization.DSFIDSerializer;\n+import org.apache.geode.internal.serialization.internal.DSFIDSerializerImpl;\n+import org.apache.geode.logging.internal.executors.LoggingExecutors;\n+\n+/**\n+ * Tests of using the membership APIs to make multiple Membership systems that communicate\n+ * with each other and form a group\n+ */\n+public class MembershipIntegrationTest {\n+  private InetAddress localHost;\n+  private DSFIDSerializer dsfidSerializer;\n+  private TcpSocketCreator socketCreator;\n+\n+  @Rule\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  @Before\n+  public void before() throws IOException, MembershipConfigurationException {\n+    localHost = InetAddress.getLocalHost();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3feec6680bc6e6a85cd42c0671504455d567a809"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDMwOTQyNQ==", "bodyText": "Done", "url": "https://github.com/apache/geode/pull/4862#discussion_r400309425", "createdAt": "2020-03-30T16:02:15Z", "author": {"login": "upthewaterspout"}, "path": "geode-membership/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/MembershipIntegrationTest.java", "diffHunk": "@@ -0,0 +1,206 @@\n+package org.apache.geode.distributed.internal.membership.gms;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import org.apache.geode.distributed.internal.membership.api.MemberIdentifier;\n+import org.apache.geode.distributed.internal.membership.api.MemberIdentifierFactoryImpl;\n+import org.apache.geode.distributed.internal.membership.api.MemberStartupException;\n+import org.apache.geode.distributed.internal.membership.api.Membership;\n+import org.apache.geode.distributed.internal.membership.api.MembershipBuilder;\n+import org.apache.geode.distributed.internal.membership.api.MembershipConfig;\n+import org.apache.geode.distributed.internal.membership.api.MembershipConfigurationException;\n+import org.apache.geode.distributed.internal.membership.api.MembershipLocator;\n+import org.apache.geode.distributed.internal.membership.api.MembershipLocatorBuilder;\n+import org.apache.geode.distributed.internal.tcpserver.TcpClient;\n+import org.apache.geode.distributed.internal.tcpserver.TcpSocketCreator;\n+import org.apache.geode.distributed.internal.tcpserver.TcpSocketCreatorImpl;\n+import org.apache.geode.distributed.internal.tcpserver.TcpSocketFactory;\n+import org.apache.geode.internal.serialization.DSFIDSerializer;\n+import org.apache.geode.internal.serialization.internal.DSFIDSerializerImpl;\n+import org.apache.geode.logging.internal.executors.LoggingExecutors;\n+\n+/**\n+ * Tests of using the membership APIs to make multiple Membership systems that communicate\n+ * with each other and form a group\n+ */\n+public class MembershipIntegrationTest {\n+  private InetAddress localHost;\n+  private DSFIDSerializer dsfidSerializer;\n+  private TcpSocketCreator socketCreator;\n+\n+  @Rule\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  @Before\n+  public void before() throws IOException, MembershipConfigurationException {\n+    localHost = InetAddress.getLocalHost();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDI5MDc0Ng=="}, "originalCommit": {"oid": "3feec6680bc6e6a85cd42c0671504455d567a809"}, "originalPosition": 49}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4435, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}