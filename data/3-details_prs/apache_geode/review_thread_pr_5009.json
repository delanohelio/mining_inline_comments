{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA5Nzg3OTQ3", "number": 5009, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxMjoxODoyMlrOD3KoTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxMjozNjowNFrOD3LD3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MTcyNDMxOnYy", "diffSide": "RIGHT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/set/DeltaSet.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxMjoxODoyMlrOGNRIUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNTo0MjoyNFrOGNaj7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2NTMyOQ==", "bodyText": "This exception name tells the User what to do, i.e. \"retry\", instead of just stating what happened and letting the user decide how to handle it.\nMaybe just throwing a ConcurrentModificationException, or something like RegionUnexpectedModificationException", "url": "https://github.com/apache/geode/pull/5009#discussion_r416565329", "createdAt": "2020-04-28T12:18:22Z", "author": {"login": "prettyClouds"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/set/DeltaSet.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis.internal.executor.set;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.apache.geode.DataSerializable;\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.Delta;\n+import org.apache.geode.InvalidDeltaException;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.redis.internal.ByteArrayWrapper;\n+\n+/**\n+ * TODO: it is probably a bad idea for this class to implement Set.\n+ * We want to be careful how other code interacts with these instances\n+ * to make sure that no modifications are made that are not thread safe\n+ * and that will always be stored in the region.\n+ * Currently the only \"correct\" methods on this class are:\n+ * members, delete, customAddAll, customRemoveAll, and the\n+ * serialization methods.\n+ */\n+public class DeltaSet implements Delta, DataSerializable {\n+\n+  public static long sadd(Region<ByteArrayWrapper, DeltaSet> region,\n+      ByteArrayWrapper key,\n+      ArrayList<ByteArrayWrapper> membersToAdd) {\n+    while (true) {\n+      DeltaSet deltaSet = region.get(key);\n+      if (deltaSet == null) {\n+        // create new set\n+        if (region.putIfAbsent(key, new DeltaSet(membersToAdd)) == null) {\n+          return membersToAdd.size();\n+        } else {\n+          // retry since another thread concurrently changed the region\n+        }\n+      } else {\n+        // update existing value\n+        try {\n+          return deltaSet.saddInstance(membersToAdd, region, key);\n+        } catch (DeltaSet.RetryDueToConcurrentModification ex) {\n+          // retry since another thread concurrently changed the region\n+        }\n+      }\n+    }\n+  }\n+\n+  public static long srem(Region<ByteArrayWrapper, DeltaSet> region,\n+      ByteArrayWrapper key,\n+      ArrayList<ByteArrayWrapper> membersToRemove) {\n+    while (true) {\n+      DeltaSet deltaSet = region.get(key);\n+      if (deltaSet == null) {\n+        return 0L;\n+      }\n+      try {\n+        return deltaSet.sremInstance(membersToRemove, region, key);\n+      } catch (DeltaSet.RetryDueToConcurrentModification ex) {\n+        // retry since another thread concurrently changed the region\n+      }\n+    }\n+  }\n+\n+  public static boolean del(Region<ByteArrayWrapper, DeltaSet> region,\n+      ByteArrayWrapper key) {\n+    while (true) {\n+      DeltaSet deltaSet = region.get(key);\n+      if (deltaSet == null) {\n+        return false;\n+      }\n+      if (deltaSet.delInstance(region, key)) {\n+        return true;\n+      } else {\n+        // retry since another thread concurrently changed the region\n+      }\n+    }\n+  }\n+\n+  public static Set<ByteArrayWrapper> members(Region<ByteArrayWrapper, DeltaSet> region,\n+      ByteArrayWrapper key) {\n+    DeltaSet deltaSet = region.get(key);\n+    if (deltaSet != null) {\n+      return deltaSet.members();\n+    } else {\n+      return Collections.emptySet();\n+    }\n+  }\n+\n+  public synchronized boolean contains(ByteArrayWrapper member) {\n+    return members.contains(member);\n+  }\n+\n+  public synchronized int size() {\n+    return members.size();\n+  }\n+\n+  private HashSet<ByteArrayWrapper> members;\n+  private transient ArrayList<ByteArrayWrapper> deltas;\n+  // true if deltas contains adds; false if removes\n+  private transient boolean deltasAreAdds;\n+\n+  DeltaSet(Collection<ByteArrayWrapper> members) {\n+    if (members instanceof HashSet) {\n+      this.members = (HashSet<ByteArrayWrapper>) members;\n+    } else {\n+      this.members = new HashSet<>(members);\n+    }\n+  }\n+\n+  // for serialization\n+  public DeltaSet() {}\n+\n+\n+  // DELTA\n+  @Override\n+  public boolean hasDelta() {\n+    return deltas != null;\n+  }\n+\n+  @Override\n+  public void toDelta(DataOutput out) throws IOException {\n+    DataSerializer.writeBoolean(deltasAreAdds, out);\n+    DataSerializer.writeArrayList(deltas, out);\n+  }\n+\n+  @Override\n+  public synchronized void fromDelta(DataInput in)\n+      throws IOException, InvalidDeltaException {\n+    boolean deltaAdds = DataSerializer.readBoolean(in);\n+    try {\n+      ArrayList<ByteArrayWrapper> deltas = DataSerializer.readArrayList(in);\n+      if (deltas != null) {\n+        if (deltaAdds) {\n+          members.addAll(deltas);\n+        } else {\n+          members.removeAll(deltas);\n+        }\n+      }\n+    } catch (ClassNotFoundException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  // DATA SERIALIZABLE\n+\n+  @Override\n+  public void toData(DataOutput out) throws IOException {\n+    DataSerializer.writeHashSet(members, out);\n+  }\n+\n+  @Override\n+  public void fromData(DataInput in) throws IOException, ClassNotFoundException {\n+    members = DataSerializer.readHashSet(in);\n+  }\n+\n+\n+  /**\n+   * @param membersToAdd members to add to this set; NOTE this list may by\n+   *        modified by this call\n+   * @param region the region this instance is stored in\n+   * @param key the name of the set to add to\n+   * @return the number of members actually added\n+   * @throws RetryDueToConcurrentModification if a concurrent modification is detected\n+   */\n+  private synchronized long saddInstance(ArrayList<ByteArrayWrapper> membersToAdd,\n+      Region<ByteArrayWrapper, DeltaSet> region,\n+      ByteArrayWrapper key) {\n+    if (region.get(key) != this) {\n+      throw new RetryDueToConcurrentModification();\n+    }\n+    membersToAdd.removeIf(memberToAdd -> !members.add(memberToAdd));\n+    int membersAdded = membersToAdd.size();\n+    if (membersAdded != 0) {\n+      deltasAreAdds = true;\n+      deltas = membersToAdd;\n+      try {\n+        region.put(key, this);\n+      } finally {\n+        deltas = null;\n+      }\n+    }\n+    return membersAdded;\n+  }\n+\n+  /**\n+   * @param membersToRemove members to remove from this set; NOTE this list may by\n+   *        modified by this call\n+   * @param region the region this instance is stored in\n+   * @param key the name of the set to remove from\n+   * @return the number of members actually removed\n+   * @throws RetryDueToConcurrentModification if a concurrent modification is detected\n+   */\n+  private synchronized long sremInstance(ArrayList<ByteArrayWrapper> membersToRemove,\n+      Region<ByteArrayWrapper, DeltaSet> region,\n+      ByteArrayWrapper key) {\n+    if (region.get(key) != this) {\n+      throw new RetryDueToConcurrentModification();\n+    }\n+    membersToRemove.removeIf(memberToRemove -> !members.remove(memberToRemove));\n+    int membersRemoved = membersToRemove.size();\n+    if (membersRemoved != 0) {\n+      deltasAreAdds = false;\n+      deltas = membersToRemove;\n+      try {\n+        region.put(key, this);\n+      } finally {\n+        deltas = null;\n+      }\n+    }\n+    return membersRemoved;\n+  }\n+\n+  /**\n+   * This exception is thrown if a modification fails because some other\n+   * thread changed what is stored in the region.\n+   */\n+  static class RetryDueToConcurrentModification extends RuntimeException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "395bb3a7965a63d0f1941d76d40c85e2e81d7184"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjcxOTg1NQ==", "bodyText": "Keep in mind this exception is for our internal implementation; not the user. It is possible we could refactor this code so that we don't need to throw on exception to force a retry.", "url": "https://github.com/apache/geode/pull/5009#discussion_r416719855", "createdAt": "2020-04-28T15:42:24Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/set/DeltaSet.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis.internal.executor.set;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.apache.geode.DataSerializable;\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.Delta;\n+import org.apache.geode.InvalidDeltaException;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.redis.internal.ByteArrayWrapper;\n+\n+/**\n+ * TODO: it is probably a bad idea for this class to implement Set.\n+ * We want to be careful how other code interacts with these instances\n+ * to make sure that no modifications are made that are not thread safe\n+ * and that will always be stored in the region.\n+ * Currently the only \"correct\" methods on this class are:\n+ * members, delete, customAddAll, customRemoveAll, and the\n+ * serialization methods.\n+ */\n+public class DeltaSet implements Delta, DataSerializable {\n+\n+  public static long sadd(Region<ByteArrayWrapper, DeltaSet> region,\n+      ByteArrayWrapper key,\n+      ArrayList<ByteArrayWrapper> membersToAdd) {\n+    while (true) {\n+      DeltaSet deltaSet = region.get(key);\n+      if (deltaSet == null) {\n+        // create new set\n+        if (region.putIfAbsent(key, new DeltaSet(membersToAdd)) == null) {\n+          return membersToAdd.size();\n+        } else {\n+          // retry since another thread concurrently changed the region\n+        }\n+      } else {\n+        // update existing value\n+        try {\n+          return deltaSet.saddInstance(membersToAdd, region, key);\n+        } catch (DeltaSet.RetryDueToConcurrentModification ex) {\n+          // retry since another thread concurrently changed the region\n+        }\n+      }\n+    }\n+  }\n+\n+  public static long srem(Region<ByteArrayWrapper, DeltaSet> region,\n+      ByteArrayWrapper key,\n+      ArrayList<ByteArrayWrapper> membersToRemove) {\n+    while (true) {\n+      DeltaSet deltaSet = region.get(key);\n+      if (deltaSet == null) {\n+        return 0L;\n+      }\n+      try {\n+        return deltaSet.sremInstance(membersToRemove, region, key);\n+      } catch (DeltaSet.RetryDueToConcurrentModification ex) {\n+        // retry since another thread concurrently changed the region\n+      }\n+    }\n+  }\n+\n+  public static boolean del(Region<ByteArrayWrapper, DeltaSet> region,\n+      ByteArrayWrapper key) {\n+    while (true) {\n+      DeltaSet deltaSet = region.get(key);\n+      if (deltaSet == null) {\n+        return false;\n+      }\n+      if (deltaSet.delInstance(region, key)) {\n+        return true;\n+      } else {\n+        // retry since another thread concurrently changed the region\n+      }\n+    }\n+  }\n+\n+  public static Set<ByteArrayWrapper> members(Region<ByteArrayWrapper, DeltaSet> region,\n+      ByteArrayWrapper key) {\n+    DeltaSet deltaSet = region.get(key);\n+    if (deltaSet != null) {\n+      return deltaSet.members();\n+    } else {\n+      return Collections.emptySet();\n+    }\n+  }\n+\n+  public synchronized boolean contains(ByteArrayWrapper member) {\n+    return members.contains(member);\n+  }\n+\n+  public synchronized int size() {\n+    return members.size();\n+  }\n+\n+  private HashSet<ByteArrayWrapper> members;\n+  private transient ArrayList<ByteArrayWrapper> deltas;\n+  // true if deltas contains adds; false if removes\n+  private transient boolean deltasAreAdds;\n+\n+  DeltaSet(Collection<ByteArrayWrapper> members) {\n+    if (members instanceof HashSet) {\n+      this.members = (HashSet<ByteArrayWrapper>) members;\n+    } else {\n+      this.members = new HashSet<>(members);\n+    }\n+  }\n+\n+  // for serialization\n+  public DeltaSet() {}\n+\n+\n+  // DELTA\n+  @Override\n+  public boolean hasDelta() {\n+    return deltas != null;\n+  }\n+\n+  @Override\n+  public void toDelta(DataOutput out) throws IOException {\n+    DataSerializer.writeBoolean(deltasAreAdds, out);\n+    DataSerializer.writeArrayList(deltas, out);\n+  }\n+\n+  @Override\n+  public synchronized void fromDelta(DataInput in)\n+      throws IOException, InvalidDeltaException {\n+    boolean deltaAdds = DataSerializer.readBoolean(in);\n+    try {\n+      ArrayList<ByteArrayWrapper> deltas = DataSerializer.readArrayList(in);\n+      if (deltas != null) {\n+        if (deltaAdds) {\n+          members.addAll(deltas);\n+        } else {\n+          members.removeAll(deltas);\n+        }\n+      }\n+    } catch (ClassNotFoundException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  // DATA SERIALIZABLE\n+\n+  @Override\n+  public void toData(DataOutput out) throws IOException {\n+    DataSerializer.writeHashSet(members, out);\n+  }\n+\n+  @Override\n+  public void fromData(DataInput in) throws IOException, ClassNotFoundException {\n+    members = DataSerializer.readHashSet(in);\n+  }\n+\n+\n+  /**\n+   * @param membersToAdd members to add to this set; NOTE this list may by\n+   *        modified by this call\n+   * @param region the region this instance is stored in\n+   * @param key the name of the set to add to\n+   * @return the number of members actually added\n+   * @throws RetryDueToConcurrentModification if a concurrent modification is detected\n+   */\n+  private synchronized long saddInstance(ArrayList<ByteArrayWrapper> membersToAdd,\n+      Region<ByteArrayWrapper, DeltaSet> region,\n+      ByteArrayWrapper key) {\n+    if (region.get(key) != this) {\n+      throw new RetryDueToConcurrentModification();\n+    }\n+    membersToAdd.removeIf(memberToAdd -> !members.add(memberToAdd));\n+    int membersAdded = membersToAdd.size();\n+    if (membersAdded != 0) {\n+      deltasAreAdds = true;\n+      deltas = membersToAdd;\n+      try {\n+        region.put(key, this);\n+      } finally {\n+        deltas = null;\n+      }\n+    }\n+    return membersAdded;\n+  }\n+\n+  /**\n+   * @param membersToRemove members to remove from this set; NOTE this list may by\n+   *        modified by this call\n+   * @param region the region this instance is stored in\n+   * @param key the name of the set to remove from\n+   * @return the number of members actually removed\n+   * @throws RetryDueToConcurrentModification if a concurrent modification is detected\n+   */\n+  private synchronized long sremInstance(ArrayList<ByteArrayWrapper> membersToRemove,\n+      Region<ByteArrayWrapper, DeltaSet> region,\n+      ByteArrayWrapper key) {\n+    if (region.get(key) != this) {\n+      throw new RetryDueToConcurrentModification();\n+    }\n+    membersToRemove.removeIf(memberToRemove -> !members.remove(memberToRemove));\n+    int membersRemoved = membersToRemove.size();\n+    if (membersRemoved != 0) {\n+      deltasAreAdds = false;\n+      deltas = membersToRemove;\n+      try {\n+        region.put(key, this);\n+      } finally {\n+        deltas = null;\n+      }\n+    }\n+    return membersRemoved;\n+  }\n+\n+  /**\n+   * This exception is thrown if a modification fails because some other\n+   * thread changed what is stored in the region.\n+   */\n+  static class RetryDueToConcurrentModification extends RuntimeException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2NTMyOQ=="}, "originalCommit": {"oid": "395bb3a7965a63d0f1941d76d40c85e2e81d7184"}, "originalPosition": 237}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MTc3MzI1OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/set/DeltaSet.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxMjozMDo0NlrOGNRmYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxMjozODo0MlrOGNR6YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU3MzAyNw==", "bodyText": "If we synchronize \"lower\" in the stack, can we avoid the complexity of looping and throwing exceptions. Can we somehow guarantee that on a given key, only one of these operations is happening simultaneously? Maybe an exclusive lock on the key?", "url": "https://github.com/apache/geode/pull/5009#discussion_r416573027", "createdAt": "2020-04-28T12:30:46Z", "author": {"login": "prettyClouds"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/set/DeltaSet.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis.internal.executor.set;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.apache.geode.DataSerializable;\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.Delta;\n+import org.apache.geode.InvalidDeltaException;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.redis.internal.ByteArrayWrapper;\n+\n+/**\n+ * TODO: it is probably a bad idea for this class to implement Set.\n+ * We want to be careful how other code interacts with these instances\n+ * to make sure that no modifications are made that are not thread safe\n+ * and that will always be stored in the region.\n+ * Currently the only \"correct\" methods on this class are:\n+ * members, delete, customAddAll, customRemoveAll, and the\n+ * serialization methods.\n+ */\n+public class DeltaSet implements Delta, DataSerializable {\n+\n+  public static long sadd(Region<ByteArrayWrapper, DeltaSet> region,\n+      ByteArrayWrapper key,\n+      ArrayList<ByteArrayWrapper> membersToAdd) {\n+    while (true) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "395bb3a7965a63d0f1941d76d40c85e2e81d7184"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU3ODE0NQ==", "bodyText": "We could even use some kind of custom read-write lock...sadds should be able to happen in parallel, and srems should be able to happen in parallel exclusive of sadds, and dels just have to be exclusive of everything.", "url": "https://github.com/apache/geode/pull/5009#discussion_r416578145", "createdAt": "2020-04-28T12:38:42Z", "author": {"login": "prettyClouds"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/set/DeltaSet.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis.internal.executor.set;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.apache.geode.DataSerializable;\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.Delta;\n+import org.apache.geode.InvalidDeltaException;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.redis.internal.ByteArrayWrapper;\n+\n+/**\n+ * TODO: it is probably a bad idea for this class to implement Set.\n+ * We want to be careful how other code interacts with these instances\n+ * to make sure that no modifications are made that are not thread safe\n+ * and that will always be stored in the region.\n+ * Currently the only \"correct\" methods on this class are:\n+ * members, delete, customAddAll, customRemoveAll, and the\n+ * serialization methods.\n+ */\n+public class DeltaSet implements Delta, DataSerializable {\n+\n+  public static long sadd(Region<ByteArrayWrapper, DeltaSet> region,\n+      ByteArrayWrapper key,\n+      ArrayList<ByteArrayWrapper> membersToAdd) {\n+    while (true) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU3MzAyNw=="}, "originalCommit": {"oid": "395bb3a7965a63d0f1941d76d40c85e2e81d7184"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MTc4OTMzOnYy", "diffSide": "RIGHT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/set/SaddFunction.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxMjozNDo0MlrOGNRwGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNTozNToxNFrOGNaKVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU3NTUxMg==", "bodyText": "When we first implemented this a few weeks back, Jens suggested having just one remote function that encapsulated all the Set commands, and the execute could just switch on some parameter.  I don't have a strong feeling either way, but I can't remember Jens' rationale...just wanted to capture the thought here, before it gets lost.", "url": "https://github.com/apache/geode/pull/5009#discussion_r416575512", "createdAt": "2020-04-28T12:34:42Z", "author": {"login": "prettyClouds"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/set/SaddFunction.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis.internal.executor.set;\n+\n+import java.util.ArrayList;\n+\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.FunctionContext;\n+import org.apache.geode.internal.cache.execute.RegionFunctionContextImpl;\n+import org.apache.geode.redis.internal.ByteArrayWrapper;\n+\n+class SaddFunction implements Function {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "395bb3a7965a63d0f1941d76d40c85e2e81d7184"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjcxMzMwMg==", "bodyText": "I like that idea, just to reduce the number of functions", "url": "https://github.com/apache/geode/pull/5009#discussion_r416713302", "createdAt": "2020-04-28T15:35:14Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/set/SaddFunction.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis.internal.executor.set;\n+\n+import java.util.ArrayList;\n+\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.FunctionContext;\n+import org.apache.geode.internal.cache.execute.RegionFunctionContextImpl;\n+import org.apache.geode.redis.internal.ByteArrayWrapper;\n+\n+class SaddFunction implements Function {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU3NTUxMg=="}, "originalCommit": {"oid": "395bb3a7965a63d0f1941d76d40c85e2e81d7184"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MTc5NDg0OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/set/SaddFunction.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxMjozNjowNFrOGNRzgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxMjozNjowNFrOGNRzgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU3NjM4NQ==", "bodyText": "How do we get rid of these? Adding a type to the class declaration, like ... implements Function<Object>?", "url": "https://github.com/apache/geode/pull/5009#discussion_r416576385", "createdAt": "2020-04-28T12:36:04Z", "author": {"login": "prettyClouds"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/set/SaddFunction.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis.internal.executor.set;\n+\n+import java.util.ArrayList;\n+\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.FunctionContext;\n+import org.apache.geode.internal.cache.execute.RegionFunctionContextImpl;\n+import org.apache.geode.redis.internal.ByteArrayWrapper;\n+\n+class SaddFunction implements Function {\n+\n+  public static final String ID = \"SADD_FUNCTION\";\n+\n+  @SuppressWarnings(\"unchecked\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "395bb3a7965a63d0f1941d76d40c85e2e81d7184"}, "originalPosition": 30}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4134, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}