{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE4ODM1MDMz", "number": 5728, "title": "GEODE-8696: Fix synchronization in FederatingManager", "bodyText": "Prevent hang in GEODE-8696 while protecting against removal of member artifacts during startup of manager.\nI could not change the ReentrantLock to StoppableReentrantLock. Allowing that thread to abort due to the Cache closing (CancelCriterion from the Cache) breaks reconnect and pollutes the JVM such that later uses of GemFire Cache fail to create the Distributed*MXBeans.", "createdAt": "2020-11-10T23:58:23Z", "url": "https://github.com/apache/geode/pull/5728", "merged": true, "mergeCommit": {"oid": "42726bd99c9ebb57ec5d3e987d47ecae9f4ea3a7"}, "closed": true, "closedAt": "2021-01-08T21:25:29Z", "author": {"login": "kirklund"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdefjeTABqjQwMjMwNzg1MDg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABduNrysgFqTU2NDUxNTU3MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dbbea938bc5429fe0f806dfd6ef72eb29b8a31e1", "author": {"user": {"login": "kirklund", "name": "Kirk Lund"}}, "url": "https://github.com/apache/geode/commit/dbbea938bc5429fe0f806dfd6ef72eb29b8a31e1", "committedDate": "2020-11-14T00:56:06Z", "message": "Fix removeMember ordering"}, "afterCommit": {"oid": "38d5fd0d070373b7343cf3df9909374a0dadc89a", "author": {"user": {"login": "kirklund", "name": "Kirk Lund"}}, "url": "https://github.com/apache/geode/commit/38d5fd0d070373b7343cf3df9909374a0dadc89a", "committedDate": "2020-11-20T23:00:21Z", "message": "Rename log4j2.xml"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "38d5fd0d070373b7343cf3df9909374a0dadc89a", "author": {"user": {"login": "kirklund", "name": "Kirk Lund"}}, "url": "https://github.com/apache/geode/commit/38d5fd0d070373b7343cf3df9909374a0dadc89a", "committedDate": "2020-11-20T23:00:21Z", "message": "Rename log4j2.xml"}, "afterCommit": {"oid": "84ee7bc9ab5a2fda8f83a4d19c5dc153809d94d4", "author": {"user": {"login": "kirklund", "name": "Kirk Lund"}}, "url": "https://github.com/apache/geode/commit/84ee7bc9ab5a2fda8f83a4d19c5dc153809d94d4", "committedDate": "2020-11-30T20:12:10Z", "message": "GEODE-8696: Fix synchronization in FederatingManager\n\nPrevent hang while protecting against removal of member artifacts\nduring startup of manager."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0MzEwMTk2", "url": "https://github.com/apache/geode/pull/5728#pullrequestreview-544310196", "createdAt": "2020-12-03T19:30:08Z", "commit": {"oid": "84ee7bc9ab5a2fda8f83a4d19c5dc153809d94d4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxOTozMDowOVrOH-ttjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxOTozMDowOVrOH-ttjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUyMjcwMQ==", "bodyText": "Can the result of expectedServerMXBeans(\u2026) change each time through the loop? If not, is it worth it to call it before the loop, rather than inside?\nSimilar for other inside-the-loop calls to get lists of expected beans.", "url": "https://github.com/apache/geode/pull/5728#discussion_r535522701", "createdAt": "2020-12-03T19:30:09Z", "author": {"login": "demery-pivotal"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/management/JMXMBeanLocatorRestartTest.java", "diffHunk": "@@ -0,0 +1,317 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.management;\n+\n+import static java.lang.management.ManagementFactory.getPlatformMBeanServer;\n+import static java.util.Arrays.asList;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static javax.management.ObjectName.getInstance;\n+import static org.apache.geode.cache.Region.SEPARATOR;\n+import static org.apache.geode.distributed.ConfigurationProperties.HTTP_SERVICE_PORT;\n+import static org.apache.geode.distributed.ConfigurationProperties.JMX_MANAGER;\n+import static org.apache.geode.distributed.ConfigurationProperties.JMX_MANAGER_PORT;\n+import static org.apache.geode.distributed.ConfigurationProperties.JMX_MANAGER_START;\n+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.LOG_FILE;\n+import static org.apache.geode.distributed.ConfigurationProperties.MAX_WAIT_TIME_RECONNECT;\n+import static org.apache.geode.distributed.ConfigurationProperties.MEMBER_TIMEOUT;\n+import static org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper.crashDistributedSystem;\n+import static org.apache.geode.internal.AvailablePortHelper.getRandomAvailableTCPPorts;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.getTimeout;\n+import static org.apache.geode.test.dunit.Disconnect.disconnectAllFromDS;\n+import static org.apache.geode.test.dunit.IgnoredException.addIgnoredException;\n+import static org.apache.geode.test.dunit.Invoke.invokeInEveryVM;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.apache.geode.test.dunit.VM.getVMId;\n+import static org.apache.geode.util.internal.GeodeGlossary.GEMFIRE_PREFIX;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+\n+import java.io.File;\n+import java.io.Serializable;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelException;\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.alerting.internal.spi.AlertingIOException;\n+import org.apache.geode.cache.CacheClosedException;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.LocatorLauncher;\n+import org.apache.geode.distributed.ServerLauncher;\n+import org.apache.geode.distributed.internal.InternalLocator;\n+import org.apache.geode.distributed.internal.membership.api.MemberDisconnectedException;\n+import org.apache.geode.test.awaitility.GeodeAwaitility;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.DistributedErrorCollector;\n+import org.apache.geode.test.dunit.rules.DistributedRestoreSystemProperties;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+import org.apache.geode.test.junit.rules.GfshCommandRule;\n+import org.apache.geode.test.junit.rules.serializable.SerializableTemporaryFolder;\n+\n+public class JMXMBeanLocatorRestartTest implements Serializable {\n+\n+  private static final long TIMEOUT_MILLIS = getTimeout().toMillis();\n+  private static final LocatorLauncher DUMMY_LOCATOR = mock(LocatorLauncher.class);\n+  private static final ServerLauncher DUMMY_SERVER = mock(ServerLauncher.class);\n+\n+  private static final AtomicReference<CountDownLatch> BEFORE =\n+      new AtomicReference<>(new CountDownLatch(0));\n+  private static final AtomicReference<CountDownLatch> AFTER =\n+      new AtomicReference<>(new CountDownLatch(0));\n+\n+  private static final AtomicReference<LocatorLauncher> LOCATOR =\n+      new AtomicReference<>(DUMMY_LOCATOR);\n+  private static final AtomicReference<ServerLauncher> SERVER =\n+      new AtomicReference<>(DUMMY_SERVER);\n+\n+  private VM locatorVM;\n+  private VM serverVM;\n+\n+  private String locatorName;\n+  private String serverName;\n+  private String locators;\n+  private int locatorPort;\n+  private int locatorJmxPort;\n+  private String regionName;\n+  private Set<ObjectName> mxbeansOnServer;\n+  private Set<ObjectName> mxbeansOnLocator;\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule();\n+  @Rule\n+  public SerializableTemporaryFolder temporaryFolder = new SerializableTemporaryFolder();\n+  @Rule\n+  public DistributedErrorCollector errorCollector = new DistributedErrorCollector();\n+  @Rule\n+  public transient GfshCommandRule gfsh = new GfshCommandRule();\n+  @Rule\n+  public DistributedRestoreSystemProperties restoreProps = new DistributedRestoreSystemProperties();\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    locatorVM = getVM(1);\n+    serverVM = getVM(0);\n+\n+    for (VM vm : asList(locatorVM, serverVM)) {\n+      vm.invoke(() -> System.setProperty(GEMFIRE_PREFIX + \"standard-output-always-on\", \"true\"));\n+    }\n+\n+    locatorName = \"locator1\";\n+    serverName = \"server1\";\n+    File locator1Dir = temporaryFolder.newFolder(locatorName);\n+    File serverDir = temporaryFolder.newFolder(serverName);\n+\n+    int[] port = getRandomAvailableTCPPorts(4);\n+    locatorPort = port[0];\n+    locatorJmxPort = port[2];\n+    locators = \"localhost[\" + locatorPort + \"]\";\n+\n+    locatorVM.invoke(() -> {\n+      startLocator(locatorName, locator1Dir, locatorPort, locatorJmxPort, locators);\n+    });\n+\n+    serverVM.invoke(() -> startServer(serverName, serverDir, locators));\n+\n+    gfsh.connectAndVerify(locatorJmxPort, GfshCommandRule.PortType.jmxManager);\n+\n+    regionName = \"region1\";\n+    String createRegionCommand = \"create region --type=REPLICATE --name=\" + SEPARATOR + regionName;\n+    gfsh.executeAndAssertThat(createRegionCommand).statusIsSuccess();\n+\n+    addIgnoredException(AlertingIOException.class);\n+    addIgnoredException(CacheClosedException.class);\n+    addIgnoredException(CancelException.class);\n+    addIgnoredException(DistributedSystemDisconnectedException.class);\n+    addIgnoredException(ForcedDisconnectException.class);\n+    addIgnoredException(MemberDisconnectedException.class);\n+    addIgnoredException(\"Possible loss of quorum\");\n+\n+    mxbeansOnServer = serverVM.invoke(() -> {\n+      await().untilAsserted(() -> {\n+        assertThat(getPlatformMBeanServer().queryNames(getInstance(\"GemFire:*\"), null))\n+            .as(\"GemFire mbeans on server1\")\n+            .containsAll(expectedServerMXBeans(serverName, regionName));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84ee7bc9ab5a2fda8f83a4d19c5dc153809d94d4"}, "originalPosition": 157}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0MzMyNjQy", "url": "https://github.com/apache/geode/pull/5728#pullrequestreview-544332642", "createdAt": "2020-12-03T19:44:06Z", "commit": {"oid": "84ee7bc9ab5a2fda8f83a4d19c5dc153809d94d4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxOTo0NDowNlrOH-udEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxOTo0NDowNlrOH-udEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUzNDg2NA==", "bodyText": "Does this need to be a spy? I don't see any uses of the spyness (spyity?) in this test.", "url": "https://github.com/apache/geode/pull/5728#discussion_r535534864", "createdAt": "2020-12-03T19:44:06Z", "author": {"login": "demery-pivotal"}, "path": "geode-core/src/test/java/org/apache/geode/management/internal/FederatingManagerTest.java", "diffHunk": "@@ -437,14 +474,79 @@ public void removeMemberArtifactsDoesNotRemoveAllProxiesIfMonitoringRegionIsNull\n         .thenReturn(mock(Region.class));\n     when(system.getDistributedMember())\n         .thenReturn(member);\n-    FederatingManager federatingManager = new FederatingManager(repo, system, service, cache,\n-        statisticsFactory, statisticsClock, proxyFactory, messenger, executorService);\n+    FederatingManager federatingManager =\n+        new FederatingManager(repo, system, service, cache, statisticsFactory,\n+            statisticsClock, proxyFactory, messenger, cancelCriterion, executorService);\n \n     federatingManager.removeMemberArtifacts(member, false);\n \n     verifyNoMoreInteractions(proxyFactory);\n   }\n \n+  @Test\n+  public void removeMemberWaitsForStartManager() throws Exception {\n+    CountDownLatch latch = new CountDownLatch(1);\n+    CyclicBarrier barrier = new CyclicBarrier(2);\n+    ExecutorService executorService = mock(ExecutorService.class);\n+    List<Future<InternalDistributedMember>> futureTaskList = Collections.emptyList();\n+\n+    when(executorService.invokeAll(any())).thenAnswer(invocation -> {\n+      awaitCyclicBarrier(barrier);\n+      awaitCountDownLatch(latch);\n+      return futureTaskList;\n+    });\n+\n+    FederatingManager federatingManager =\n+        spy(new FederatingManager(repo, system, service, cache, statisticsFactory, statisticsClock,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84ee7bc9ab5a2fda8f83a4d19c5dc153809d94d4"}, "originalPosition": 329}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0MzQwNDA2", "url": "https://github.com/apache/geode/pull/5728#pullrequestreview-544340406", "createdAt": "2020-12-03T19:48:34Z", "commit": {"oid": "84ee7bc9ab5a2fda8f83a4d19c5dc153809d94d4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxOTo0ODozNFrOH-unrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxOTo0ODozNFrOH-unrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUzNzU4MQ==", "bodyText": "The concern I have with pendingStartup being set to true when FederatingManager is created is that removeMember could build up a big list of pending tasks if the call of startManager is delayed.\nIn some cases we are careful to call start right after create. But in others, based on how the gemfire properties configure jmx, it can be delayed. If you look in ManagementAdapter this code:     if (cache.getInternalDistributedSystem().getConfig().getJmxManager()) { service.createManager(); if (cache.getInternalDistributedSystem().getConfig().getJmxManagerStart()) { service.startManager(); } }\nwill not always call startManager.", "url": "https://github.com/apache/geode/pull/5728#discussion_r535537581", "createdAt": "2020-12-03T19:48:34Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-core/src/main/java/org/apache/geode/management/internal/FederatingManager.java", "diffHunk": "@@ -79,26 +82,39 @@\n    * unbounded in practical situation as number of members will be a finite set at any given point\n    * of time\n    */\n-  private ExecutorService executorService;\n+  private final AtomicReference<ExecutorService> executorService = new AtomicReference<>();\n+  private boolean pendingStartup = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84ee7bc9ab5a2fda8f83a4d19c5dc153809d94d4"}, "originalPosition": 30}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0MzQ1ODQ4", "url": "https://github.com/apache/geode/pull/5728#pullrequestreview-544345848", "createdAt": "2020-12-03T19:51:36Z", "commit": {"oid": "84ee7bc9ab5a2fda8f83a4d19c5dc153809d94d4"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxOTo1MTozN1rOH-uvVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxOTo1OTozOFrOH-vEow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUzOTU0Mg==", "bodyText": "I don't see port[1] and port[3] being used. Is it on purpose?", "url": "https://github.com/apache/geode/pull/5728#discussion_r535539542", "createdAt": "2020-12-03T19:51:37Z", "author": {"login": "jchen21"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/management/JMXMBeanLocatorRestartTest.java", "diffHunk": "@@ -0,0 +1,317 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.management;\n+\n+import static java.lang.management.ManagementFactory.getPlatformMBeanServer;\n+import static java.util.Arrays.asList;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static javax.management.ObjectName.getInstance;\n+import static org.apache.geode.cache.Region.SEPARATOR;\n+import static org.apache.geode.distributed.ConfigurationProperties.HTTP_SERVICE_PORT;\n+import static org.apache.geode.distributed.ConfigurationProperties.JMX_MANAGER;\n+import static org.apache.geode.distributed.ConfigurationProperties.JMX_MANAGER_PORT;\n+import static org.apache.geode.distributed.ConfigurationProperties.JMX_MANAGER_START;\n+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.LOG_FILE;\n+import static org.apache.geode.distributed.ConfigurationProperties.MAX_WAIT_TIME_RECONNECT;\n+import static org.apache.geode.distributed.ConfigurationProperties.MEMBER_TIMEOUT;\n+import static org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper.crashDistributedSystem;\n+import static org.apache.geode.internal.AvailablePortHelper.getRandomAvailableTCPPorts;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.getTimeout;\n+import static org.apache.geode.test.dunit.Disconnect.disconnectAllFromDS;\n+import static org.apache.geode.test.dunit.IgnoredException.addIgnoredException;\n+import static org.apache.geode.test.dunit.Invoke.invokeInEveryVM;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.apache.geode.test.dunit.VM.getVMId;\n+import static org.apache.geode.util.internal.GeodeGlossary.GEMFIRE_PREFIX;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+\n+import java.io.File;\n+import java.io.Serializable;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelException;\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.alerting.internal.spi.AlertingIOException;\n+import org.apache.geode.cache.CacheClosedException;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.LocatorLauncher;\n+import org.apache.geode.distributed.ServerLauncher;\n+import org.apache.geode.distributed.internal.InternalLocator;\n+import org.apache.geode.distributed.internal.membership.api.MemberDisconnectedException;\n+import org.apache.geode.test.awaitility.GeodeAwaitility;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.DistributedErrorCollector;\n+import org.apache.geode.test.dunit.rules.DistributedRestoreSystemProperties;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+import org.apache.geode.test.junit.rules.GfshCommandRule;\n+import org.apache.geode.test.junit.rules.serializable.SerializableTemporaryFolder;\n+\n+public class JMXMBeanLocatorRestartTest implements Serializable {\n+\n+  private static final long TIMEOUT_MILLIS = getTimeout().toMillis();\n+  private static final LocatorLauncher DUMMY_LOCATOR = mock(LocatorLauncher.class);\n+  private static final ServerLauncher DUMMY_SERVER = mock(ServerLauncher.class);\n+\n+  private static final AtomicReference<CountDownLatch> BEFORE =\n+      new AtomicReference<>(new CountDownLatch(0));\n+  private static final AtomicReference<CountDownLatch> AFTER =\n+      new AtomicReference<>(new CountDownLatch(0));\n+\n+  private static final AtomicReference<LocatorLauncher> LOCATOR =\n+      new AtomicReference<>(DUMMY_LOCATOR);\n+  private static final AtomicReference<ServerLauncher> SERVER =\n+      new AtomicReference<>(DUMMY_SERVER);\n+\n+  private VM locatorVM;\n+  private VM serverVM;\n+\n+  private String locatorName;\n+  private String serverName;\n+  private String locators;\n+  private int locatorPort;\n+  private int locatorJmxPort;\n+  private String regionName;\n+  private Set<ObjectName> mxbeansOnServer;\n+  private Set<ObjectName> mxbeansOnLocator;\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule();\n+  @Rule\n+  public SerializableTemporaryFolder temporaryFolder = new SerializableTemporaryFolder();\n+  @Rule\n+  public DistributedErrorCollector errorCollector = new DistributedErrorCollector();\n+  @Rule\n+  public transient GfshCommandRule gfsh = new GfshCommandRule();\n+  @Rule\n+  public DistributedRestoreSystemProperties restoreProps = new DistributedRestoreSystemProperties();\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    locatorVM = getVM(1);\n+    serverVM = getVM(0);\n+\n+    for (VM vm : asList(locatorVM, serverVM)) {\n+      vm.invoke(() -> System.setProperty(GEMFIRE_PREFIX + \"standard-output-always-on\", \"true\"));\n+    }\n+\n+    locatorName = \"locator1\";\n+    serverName = \"server1\";\n+    File locator1Dir = temporaryFolder.newFolder(locatorName);\n+    File serverDir = temporaryFolder.newFolder(serverName);\n+\n+    int[] port = getRandomAvailableTCPPorts(4);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84ee7bc9ab5a2fda8f83a4d19c5dc153809d94d4"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTU0NDk5NQ==", "bodyText": "The latches BEFORE and AFTER are initialized as 0. But I don't see them being used anywhere else.", "url": "https://github.com/apache/geode/pull/5728#discussion_r535544995", "createdAt": "2020-12-03T19:59:38Z", "author": {"login": "jchen21"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/management/JMXMBeanLocatorRestartTest.java", "diffHunk": "@@ -0,0 +1,317 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.management;\n+\n+import static java.lang.management.ManagementFactory.getPlatformMBeanServer;\n+import static java.util.Arrays.asList;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static javax.management.ObjectName.getInstance;\n+import static org.apache.geode.cache.Region.SEPARATOR;\n+import static org.apache.geode.distributed.ConfigurationProperties.HTTP_SERVICE_PORT;\n+import static org.apache.geode.distributed.ConfigurationProperties.JMX_MANAGER;\n+import static org.apache.geode.distributed.ConfigurationProperties.JMX_MANAGER_PORT;\n+import static org.apache.geode.distributed.ConfigurationProperties.JMX_MANAGER_START;\n+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.LOG_FILE;\n+import static org.apache.geode.distributed.ConfigurationProperties.MAX_WAIT_TIME_RECONNECT;\n+import static org.apache.geode.distributed.ConfigurationProperties.MEMBER_TIMEOUT;\n+import static org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper.crashDistributedSystem;\n+import static org.apache.geode.internal.AvailablePortHelper.getRandomAvailableTCPPorts;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.getTimeout;\n+import static org.apache.geode.test.dunit.Disconnect.disconnectAllFromDS;\n+import static org.apache.geode.test.dunit.IgnoredException.addIgnoredException;\n+import static org.apache.geode.test.dunit.Invoke.invokeInEveryVM;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.apache.geode.test.dunit.VM.getVMId;\n+import static org.apache.geode.util.internal.GeodeGlossary.GEMFIRE_PREFIX;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+\n+import java.io.File;\n+import java.io.Serializable;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelException;\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.alerting.internal.spi.AlertingIOException;\n+import org.apache.geode.cache.CacheClosedException;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.LocatorLauncher;\n+import org.apache.geode.distributed.ServerLauncher;\n+import org.apache.geode.distributed.internal.InternalLocator;\n+import org.apache.geode.distributed.internal.membership.api.MemberDisconnectedException;\n+import org.apache.geode.test.awaitility.GeodeAwaitility;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.DistributedErrorCollector;\n+import org.apache.geode.test.dunit.rules.DistributedRestoreSystemProperties;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+import org.apache.geode.test.junit.rules.GfshCommandRule;\n+import org.apache.geode.test.junit.rules.serializable.SerializableTemporaryFolder;\n+\n+public class JMXMBeanLocatorRestartTest implements Serializable {\n+\n+  private static final long TIMEOUT_MILLIS = getTimeout().toMillis();\n+  private static final LocatorLauncher DUMMY_LOCATOR = mock(LocatorLauncher.class);\n+  private static final ServerLauncher DUMMY_SERVER = mock(ServerLauncher.class);\n+\n+  private static final AtomicReference<CountDownLatch> BEFORE =\n+      new AtomicReference<>(new CountDownLatch(0));\n+  private static final AtomicReference<CountDownLatch> AFTER =\n+      new AtomicReference<>(new CountDownLatch(0));\n+\n+  private static final AtomicReference<LocatorLauncher> LOCATOR =\n+      new AtomicReference<>(DUMMY_LOCATOR);\n+  private static final AtomicReference<ServerLauncher> SERVER =\n+      new AtomicReference<>(DUMMY_SERVER);\n+\n+  private VM locatorVM;\n+  private VM serverVM;\n+\n+  private String locatorName;\n+  private String serverName;\n+  private String locators;\n+  private int locatorPort;\n+  private int locatorJmxPort;\n+  private String regionName;\n+  private Set<ObjectName> mxbeansOnServer;\n+  private Set<ObjectName> mxbeansOnLocator;\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule();\n+  @Rule\n+  public SerializableTemporaryFolder temporaryFolder = new SerializableTemporaryFolder();\n+  @Rule\n+  public DistributedErrorCollector errorCollector = new DistributedErrorCollector();\n+  @Rule\n+  public transient GfshCommandRule gfsh = new GfshCommandRule();\n+  @Rule\n+  public DistributedRestoreSystemProperties restoreProps = new DistributedRestoreSystemProperties();\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    locatorVM = getVM(1);\n+    serverVM = getVM(0);\n+\n+    for (VM vm : asList(locatorVM, serverVM)) {\n+      vm.invoke(() -> System.setProperty(GEMFIRE_PREFIX + \"standard-output-always-on\", \"true\"));\n+    }\n+\n+    locatorName = \"locator1\";\n+    serverName = \"server1\";\n+    File locator1Dir = temporaryFolder.newFolder(locatorName);\n+    File serverDir = temporaryFolder.newFolder(serverName);\n+\n+    int[] port = getRandomAvailableTCPPorts(4);\n+    locatorPort = port[0];\n+    locatorJmxPort = port[2];\n+    locators = \"localhost[\" + locatorPort + \"]\";\n+\n+    locatorVM.invoke(() -> {\n+      startLocator(locatorName, locator1Dir, locatorPort, locatorJmxPort, locators);\n+    });\n+\n+    serverVM.invoke(() -> startServer(serverName, serverDir, locators));\n+\n+    gfsh.connectAndVerify(locatorJmxPort, GfshCommandRule.PortType.jmxManager);\n+\n+    regionName = \"region1\";\n+    String createRegionCommand = \"create region --type=REPLICATE --name=\" + SEPARATOR + regionName;\n+    gfsh.executeAndAssertThat(createRegionCommand).statusIsSuccess();\n+\n+    addIgnoredException(AlertingIOException.class);\n+    addIgnoredException(CacheClosedException.class);\n+    addIgnoredException(CancelException.class);\n+    addIgnoredException(DistributedSystemDisconnectedException.class);\n+    addIgnoredException(ForcedDisconnectException.class);\n+    addIgnoredException(MemberDisconnectedException.class);\n+    addIgnoredException(\"Possible loss of quorum\");\n+\n+    mxbeansOnServer = serverVM.invoke(() -> {\n+      await().untilAsserted(() -> {\n+        assertThat(getPlatformMBeanServer().queryNames(getInstance(\"GemFire:*\"), null))\n+            .as(\"GemFire mbeans on server1\")\n+            .containsAll(expectedServerMXBeans(serverName, regionName));\n+      });\n+      return getPlatformMBeanServer().queryNames(getInstance(\"GemFire:*\"), null);\n+    });\n+\n+    mxbeansOnLocator = locatorVM.invoke(() -> {\n+      await().untilAsserted(() -> {\n+        assertThat(getPlatformMBeanServer().queryNames(getInstance(\"GemFire:*\"), null))\n+            .as(\"GemFire mbeans on locator1\")\n+            .containsAll(expectedServerMXBeans(serverName, regionName))\n+            .containsAll(expectedLocatorMXBeans(locatorName))\n+            .containsAll(expectedDistributedMXBeans(regionName));\n+      });\n+\n+      return getPlatformMBeanServer().queryNames(getInstance(\"GemFire:*\"), null);\n+    });\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    invokeInEveryVM(() -> {\n+      BEFORE.get().countDown();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84ee7bc9ab5a2fda8f83a4d19c5dc153809d94d4"}, "originalPosition": 178}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fd96ad39e6319fab7e0f4099406f01f2068529c8", "author": {"user": {"login": "kirklund", "name": "Kirk Lund"}}, "url": "https://github.com/apache/geode/commit/fd96ad39e6319fab7e0f4099406f01f2068529c8", "committedDate": "2020-12-08T18:04:16Z", "message": "Extract cleanUpFailedStart method"}, "afterCommit": {"oid": "f76ed9fdb8145b3e95ace1844bfe4f50c41a8833", "author": {"user": {"login": "kirklund", "name": "Kirk Lund"}}, "url": "https://github.com/apache/geode/commit/f76ed9fdb8145b3e95ace1844bfe4f50c41a8833", "committedDate": "2020-12-08T18:57:28Z", "message": "Extract cleanUpFailedStart method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7354ee34e5b33ea9610abd9ea6737b9c1a061f78", "author": {"user": {"login": "kirklund", "name": "Kirk Lund"}}, "url": "https://github.com/apache/geode/commit/7354ee34e5b33ea9610abd9ea6737b9c1a061f78", "committedDate": "2021-01-04T22:50:55Z", "message": "GEODE-8696: Fix synchronization in FederatingManager\n\nPrevent hang while protecting against removal of member artifacts\nduring startup of manager."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3ced92ec0291d9dc72f939b59107203a5205f138", "author": {"user": {"login": "kirklund", "name": "Kirk Lund"}}, "url": "https://github.com/apache/geode/commit/3ced92ec0291d9dc72f939b59107203a5205f138", "committedDate": "2020-12-09T21:42:14Z", "message": "Fixup"}, "afterCommit": {"oid": "6b09a511a5ab6545b48c252dcc7295088db7d3ea", "author": {"user": {"login": "kirklund", "name": "Kirk Lund"}}, "url": "https://github.com/apache/geode/commit/6b09a511a5ab6545b48c252dcc7295088db7d3ea", "committedDate": "2021-01-04T22:48:43Z", "message": "Fixup"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6b09a511a5ab6545b48c252dcc7295088db7d3ea", "author": {"user": {"login": "kirklund", "name": "Kirk Lund"}}, "url": "https://github.com/apache/geode/commit/6b09a511a5ab6545b48c252dcc7295088db7d3ea", "committedDate": "2021-01-04T22:48:43Z", "message": "Fixup"}, "afterCommit": {"oid": "70e207b8ab460625e2a3df44f00f5320da8d8bef", "author": {"user": {"login": "kirklund", "name": "Kirk Lund"}}, "url": "https://github.com/apache/geode/commit/70e207b8ab460625e2a3df44f00f5320da8d8bef", "committedDate": "2021-01-04T22:56:40Z", "message": "Rename and fixup both JMX reconnect distributed tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "93524b77568052c49e215bb6b2322626f279b7d6", "author": {"user": {"login": "kirklund", "name": "Kirk Lund"}}, "url": "https://github.com/apache/geode/commit/93524b77568052c49e215bb6b2322626f279b7d6", "committedDate": "2021-01-04T22:57:19Z", "message": "Partial wip with green precheckin"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "70e207b8ab460625e2a3df44f00f5320da8d8bef", "author": {"user": {"login": "kirklund", "name": "Kirk Lund"}}, "url": "https://github.com/apache/geode/commit/70e207b8ab460625e2a3df44f00f5320da8d8bef", "committedDate": "2021-01-04T22:56:40Z", "message": "Rename and fixup both JMX reconnect distributed tests"}, "afterCommit": {"oid": "86cbf6d5c08d9225564e5a8946c9b5cc2c9fb6b0", "author": {"user": {"login": "kirklund", "name": "Kirk Lund"}}, "url": "https://github.com/apache/geode/commit/86cbf6d5c08d9225564e5a8946c9b5cc2c9fb6b0", "committedDate": "2021-01-04T23:16:32Z", "message": "Fixup"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2435bd1f2e944750bcfb31944334cb76b157d104", "author": {"user": {"login": "kirklund", "name": "Kirk Lund"}}, "url": "https://github.com/apache/geode/commit/2435bd1f2e944750bcfb31944334cb76b157d104", "committedDate": "2021-01-05T17:15:38Z", "message": "Remove redundant synchronization blocks."}, "afterCommit": {"oid": "93524b77568052c49e215bb6b2322626f279b7d6", "author": {"user": {"login": "kirklund", "name": "Kirk Lund"}}, "url": "https://github.com/apache/geode/commit/93524b77568052c49e215bb6b2322626f279b7d6", "committedDate": "2021-01-04T22:57:19Z", "message": "Partial wip with green precheckin"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "821fe758653898c02204e4807d825721328e0f46", "author": {"user": {"login": "kirklund", "name": "Kirk Lund"}}, "url": "https://github.com/apache/geode/commit/821fe758653898c02204e4807d825721328e0f46", "committedDate": "2021-01-06T00:17:37Z", "message": "Remove unused parameters."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY0NDg2NTIw", "url": "https://github.com/apache/geode/pull/5728#pullrequestreview-564486520", "createdAt": "2021-01-08T18:28:00Z", "commit": {"oid": "821fe758653898c02204e4807d825721328e0f46"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxODoyODowMFrOIQcqbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxODoyODowMFrOIQcqbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDExNzc0Mw==", "bodyText": "Should this clear and setting running and starting also be protected by a lifecycleLock.lock/unlock?", "url": "https://github.com/apache/geode/pull/5728#discussion_r554117743", "createdAt": "2021-01-08T18:28:00Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-core/src/main/java/org/apache/geode/management/internal/FederatingManager.java", "diffHunk": "@@ -108,31 +114,60 @@\n   @Override\n   public synchronized void startManager() {\n     try {\n-      if (logger.isDebugEnabled()) {\n-        logger.debug(\"Starting the Federating Manager.... \");\n+      lifecycleLock.lock();\n+      try {\n+        if (starting || running) {\n+          return;\n+        }\n+        if (logger.isDebugEnabled()) {\n+          logger.debug(\"Starting the Federating Manager.... \");\n+        }\n+        starting = true;\n+        executorService.set(executorServiceSupplier.get());\n+        running = true;\n+      } finally {\n+        lifecycleLock.unlock();\n       }\n \n-      executorService = executorServiceSupplier.get();\n-\n-      running = true;\n       startManagingActivity();\n+\n+      lifecycleLock.lock();\n+      try {\n+        for (Runnable task : pendingTasks) {\n+          executeTask(task);\n+        }\n+      } finally {\n+        pendingTasks.clear();\n+        starting = false;\n+        lifecycleLock.unlock();\n+      }\n+\n       messenger.broadcastManagerInfo();\n+\n     } catch (Exception e) {\n+      pendingTasks.clear();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "821fe758653898c02204e4807d825721328e0f46"}, "originalPosition": 98}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "72c802dd54b4bd40a5ea4134ee8f739bba20d2e3", "author": {"user": {"login": "kirklund", "name": "Kirk Lund"}}, "url": "https://github.com/apache/geode/commit/72c802dd54b4bd40a5ea4134ee8f739bba20d2e3", "committedDate": "2021-01-08T19:11:13Z", "message": "Improve cleanup for failed start."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY0NTE1NTcw", "url": "https://github.com/apache/geode/pull/5728#pullrequestreview-564515570", "createdAt": "2021-01-08T19:14:21Z", "commit": {"oid": "72c802dd54b4bd40a5ea4134ee8f739bba20d2e3"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4018, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}