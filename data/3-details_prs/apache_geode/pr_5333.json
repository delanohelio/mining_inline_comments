{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQyNDE5MjQ2", "number": 5333, "title": "GEODE-8323: Process QueueRemovalMessage after queue initialized.", "bodyText": "Thank you for submitting a contribution to Apache Geode.\nIn order to streamline the review of the contribution we ask you\nto ensure the following steps have been taken:\nFor all changes:\n\n\n Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?\n\n\n Has your PR been rebased against the latest commit within the target branch (typically develop)?\n\n\n Is your initial contribution a single, squashed commit?\n\n\n Does gradlew build run cleanly?\n\n\n Have you written or updated unit tests to verify your changes?\n\n\n If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under ASF 2.0?\n\n\nNote:\nPlease ensure that once the PR is submitted, check Concourse for build issues and\nsubmit an update to your PR as soon as possible. If you need help, please send an\nemail to dev@geode.apache.org.", "createdAt": "2020-07-01T03:35:05Z", "url": "https://github.com/apache/geode/pull/5333", "merged": true, "mergeCommit": {"oid": "625a204f1a7173323648c05bb0002aded06e2a69"}, "closed": true, "closedAt": "2020-07-07T15:50:58Z", "author": {"login": "pivotal-eshu"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcwhsWCgH2gAyNDQyNDE5MjQ2OmJlMWFhNDg1N2UzZGQ4MTZiZTI0YmE0YzA2MDM0OWYyNWNiNmNmMjU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcyXEgXAFqTQ0MzM3Nzc5MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "be1aa4857e3dd816be24ba4c060349f25cb6cf25", "author": {"user": {"login": "pivotal-eshu", "name": "Eric Shu"}}, "url": "https://github.com/apache/geode/commit/be1aa4857e3dd816be24ba4c060349f25cb6cf25", "committedDate": "2020-07-01T03:29:45Z", "message": "GEODE-8323: Process QueueRemovalMessage after queue initialized."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4ee69ee0d03e6a86f59ff6d1866c002f15a1856", "author": {"user": {"login": "pivotal-eshu", "name": "Eric Shu"}}, "url": "https://github.com/apache/geode/commit/f4ee69ee0d03e6a86f59ff6d1866c002f15a1856", "committedDate": "2020-07-01T17:14:46Z", "message": "Do not change the toData method to avoid serialization change."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxODYzODM4", "url": "https://github.com/apache/geode/pull/5333#pullrequestreview-441863838", "createdAt": "2020-07-02T16:46:14Z", "commit": {"oid": "f4ee69ee0d03e6a86f59ff6d1866c002f15a1856"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjo0NjoxNFrOGsVqCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzowMjozMVrOGsWLvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE0NTM1NA==", "bodyText": "This test name is a little misleading. It might be better as \"getOwnerWithWaitReturnsNullIfNotInitializedWithWait\"", "url": "https://github.com/apache/geode/pull/5333#discussion_r449145354", "createdAt": "2020-07-02T16:46:14Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/HARegionTest.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.internal.statistics.StatisticsClockFactory.disabledClock;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.EvictionAction;\n+import org.apache.geode.cache.EvictionAlgorithm;\n+import org.apache.geode.cache.EvictionAttributes;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.internal.cache.ha.HARegionQueue;\n+\n+public class HARegionTest {\n+  private HARegion region;\n+\n+  private final InternalCache cache = mock(InternalCache.class, RETURNS_DEEP_STUBS);\n+  private final RegionAttributes attributes = mock(RegionAttributes.class, RETURNS_DEEP_STUBS);\n+  private final EvictionAttributes evictionAttributes =\n+      mock(EvictionAttributes.class, RETURNS_DEEP_STUBS);\n+\n+  @Before\n+  public void setup() {\n+    when(attributes.getEvictionAttributes()).thenReturn(evictionAttributes);\n+    when(attributes.getLoadFactor()).thenReturn(0.75f);\n+    when(attributes.getConcurrencyLevel()).thenReturn(16);\n+    when(evictionAttributes.getAlgorithm()).thenReturn(EvictionAlgorithm.NONE);\n+    when(evictionAttributes.getAction()).thenReturn(EvictionAction.NONE);\n+    Set<String> asyncEventQueueIds = Collections.singleton(\"id\");\n+    when(attributes.getAsyncEventQueueIds()).thenReturn(asyncEventQueueIds);\n+    region = new HARegion(\"HARegionTest_region\", attributes, null, cache, disabledClock());\n+  }\n+\n+  @Test\n+  public void getOwnerWithWaitReturnsHARegionQueueIfInitializedWithWait() throws Exception {\n+    long timeout = 1;\n+    HARegionQueue queue = mock(HARegionQueue.class);\n+    when(queue.isQueueInitializedWithWait(timeout)).thenReturn(true);\n+\n+    region.setOwner(queue);\n+\n+    assertThat(region.getOwnerWithWait(timeout)).isEqualTo(queue);\n+  }\n+\n+  @Test\n+  public void getOwnerWithWaitReturnsHARegionQueueIfNotInitializedWithWait() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4ee69ee0d03e6a86f59ff6d1866c002f15a1856"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE1MzUyNA==", "bodyText": "Can the two sizes here be extracted to constants, since they're referenced in multiple tests?", "url": "https://github.com/apache/geode/pull/5333#discussion_r449153524", "createdAt": "2020-07-02T17:01:32Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/ha/QueueRemovalMessageTest.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.ha;\n+\n+import static org.apache.geode.util.internal.UncheckedUtils.uncheckedCast;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.CacheClosedException;\n+import org.apache.geode.cache.EntryNotFoundException;\n+import org.apache.geode.cache.RegionDestroyedException;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.internal.cache.EventID;\n+import org.apache.geode.internal.cache.HARegion;\n+import org.apache.geode.internal.cache.InternalCache;\n+\n+public class QueueRemovalMessageTest {\n+  private QueueRemovalMessage queueRemovalMessage;\n+  private List<Object> messagesList;\n+\n+  private final ClusterDistributionManager dm = mock(ClusterDistributionManager.class);\n+  private final InternalCache cache = mock(InternalCache.class);\n+  private final String regionName1 = \"region1\";\n+  private final String regionName2 = \"region2\";\n+  private final HARegion region1 = mock(HARegion.class);\n+  private final HARegion region2 = mock(HARegion.class);\n+  private final HARegionQueue regionQueue1 = mock(HARegionQueue.class);\n+  private final HARegionQueue regionQueue2 = mock(HARegionQueue.class);\n+  private final EventID eventID1 = mock(EventID.class);\n+  private final EventID eventID2 = mock(EventID.class);\n+  private final EventID eventID3 = mock(EventID.class);\n+\n+\n+  @Before\n+  public void setup() {\n+    queueRemovalMessage = spy(new QueueRemovalMessage());\n+    messagesList = new LinkedList<>();\n+    queueRemovalMessage.setMessagesList(messagesList);\n+\n+    long maxWaitTimeForInitialization = 30000;\n+    when(cache.getRegion(regionName1)).thenReturn(uncheckedCast(region1));\n+    when(cache.getRegion(regionName2)).thenReturn(uncheckedCast(region2));\n+    when(region1.getOwnerWithWait(maxWaitTimeForInitialization)).thenReturn(regionQueue1);\n+    when(region2.getOwnerWithWait(maxWaitTimeForInitialization)).thenReturn(regionQueue2);\n+    when(regionQueue1.isQueueInitialized()).thenReturn(true);\n+    when(regionQueue2.isQueueInitialized()).thenReturn(true);\n+  }\n+\n+  @Test\n+  public void messageProcessInvokesProcessRegionQueues() {\n+    when(dm.getCache()).thenReturn(cache);\n+\n+    queueRemovalMessage.process(dm);\n+\n+    verify(queueRemovalMessage).processRegionQueues(eq(cache), any(Iterator.class));\n+  }\n+\n+  @Test\n+  public void processRegionQueuesCanProcessEachRegionQueue() {\n+    addToMessagesList();\n+    Iterator iterator = messagesList.iterator();\n+\n+    queueRemovalMessage.processRegionQueues(cache, iterator);\n+\n+    verify(queueRemovalMessage).processRegionQueue(iterator, regionName1, 1, regionQueue1);\n+    verify(queueRemovalMessage).processRegionQueue(iterator, regionName2, 2, regionQueue2);\n+    verify(queueRemovalMessage).removeQueueEvent(regionName1, regionQueue1, eventID1);\n+    verify(queueRemovalMessage).removeQueueEvent(regionName2, regionQueue2, eventID2);\n+    verify(queueRemovalMessage).removeQueueEvent(regionName2, regionQueue2, eventID3);\n+  }\n+\n+  private void addToMessagesList() {\n+    messagesList.add(regionName1);\n+    messagesList.add(1);\n+    messagesList.add(eventID1);\n+    messagesList.add(regionName2);\n+    messagesList.add(2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4ee69ee0d03e6a86f59ff6d1866c002f15a1856"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE1Mzk4MQ==", "bodyText": "Small typo here, I think this should be \"canProcessRegionQueuesWhenHARegionQueueIsNotInitialized'", "url": "https://github.com/apache/geode/pull/5333#discussion_r449153981", "createdAt": "2020-07-02T17:02:31Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/ha/QueueRemovalMessageTest.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.ha;\n+\n+import static org.apache.geode.util.internal.UncheckedUtils.uncheckedCast;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.CacheClosedException;\n+import org.apache.geode.cache.EntryNotFoundException;\n+import org.apache.geode.cache.RegionDestroyedException;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.internal.cache.EventID;\n+import org.apache.geode.internal.cache.HARegion;\n+import org.apache.geode.internal.cache.InternalCache;\n+\n+public class QueueRemovalMessageTest {\n+  private QueueRemovalMessage queueRemovalMessage;\n+  private List<Object> messagesList;\n+\n+  private final ClusterDistributionManager dm = mock(ClusterDistributionManager.class);\n+  private final InternalCache cache = mock(InternalCache.class);\n+  private final String regionName1 = \"region1\";\n+  private final String regionName2 = \"region2\";\n+  private final HARegion region1 = mock(HARegion.class);\n+  private final HARegion region2 = mock(HARegion.class);\n+  private final HARegionQueue regionQueue1 = mock(HARegionQueue.class);\n+  private final HARegionQueue regionQueue2 = mock(HARegionQueue.class);\n+  private final EventID eventID1 = mock(EventID.class);\n+  private final EventID eventID2 = mock(EventID.class);\n+  private final EventID eventID3 = mock(EventID.class);\n+\n+\n+  @Before\n+  public void setup() {\n+    queueRemovalMessage = spy(new QueueRemovalMessage());\n+    messagesList = new LinkedList<>();\n+    queueRemovalMessage.setMessagesList(messagesList);\n+\n+    long maxWaitTimeForInitialization = 30000;\n+    when(cache.getRegion(regionName1)).thenReturn(uncheckedCast(region1));\n+    when(cache.getRegion(regionName2)).thenReturn(uncheckedCast(region2));\n+    when(region1.getOwnerWithWait(maxWaitTimeForInitialization)).thenReturn(regionQueue1);\n+    when(region2.getOwnerWithWait(maxWaitTimeForInitialization)).thenReturn(regionQueue2);\n+    when(regionQueue1.isQueueInitialized()).thenReturn(true);\n+    when(regionQueue2.isQueueInitialized()).thenReturn(true);\n+  }\n+\n+  @Test\n+  public void messageProcessInvokesProcessRegionQueues() {\n+    when(dm.getCache()).thenReturn(cache);\n+\n+    queueRemovalMessage.process(dm);\n+\n+    verify(queueRemovalMessage).processRegionQueues(eq(cache), any(Iterator.class));\n+  }\n+\n+  @Test\n+  public void processRegionQueuesCanProcessEachRegionQueue() {\n+    addToMessagesList();\n+    Iterator iterator = messagesList.iterator();\n+\n+    queueRemovalMessage.processRegionQueues(cache, iterator);\n+\n+    verify(queueRemovalMessage).processRegionQueue(iterator, regionName1, 1, regionQueue1);\n+    verify(queueRemovalMessage).processRegionQueue(iterator, regionName2, 2, regionQueue2);\n+    verify(queueRemovalMessage).removeQueueEvent(regionName1, regionQueue1, eventID1);\n+    verify(queueRemovalMessage).removeQueueEvent(regionName2, regionQueue2, eventID2);\n+    verify(queueRemovalMessage).removeQueueEvent(regionName2, regionQueue2, eventID3);\n+  }\n+\n+  private void addToMessagesList() {\n+    messagesList.add(regionName1);\n+    messagesList.add(1);\n+    messagesList.add(eventID1);\n+    messagesList.add(regionName2);\n+    messagesList.add(2);\n+    messagesList.add(eventID2);\n+    messagesList.add(eventID3);\n+  }\n+\n+  @Test\n+  public void canProcessRegionQueuesWithoutHARegionInCache() {\n+    addToMessagesList();\n+    Iterator iterator = messagesList.iterator();\n+    when(cache.getRegion(regionName1)).thenReturn(null);\n+\n+    queueRemovalMessage.processRegionQueues(cache, iterator);\n+\n+    verify(queueRemovalMessage).processRegionQueue(iterator, regionName1, 1, null);\n+    verify(queueRemovalMessage).processRegionQueue(iterator, regionName2, 2, regionQueue2);\n+    verify(queueRemovalMessage, never()).removeQueueEvent(regionName1, regionQueue1, eventID1);\n+    verify(queueRemovalMessage).removeQueueEvent(regionName2, regionQueue2, eventID2);\n+    verify(queueRemovalMessage).removeQueueEvent(regionName2, regionQueue2, eventID3);\n+  }\n+\n+  @Test\n+  public void canProcessRegionQueuesWithoutHARegionQueueIsNotInitialized() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4ee69ee0d03e6a86f59ff6d1866c002f15a1856"}, "originalPosition": 126}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2c9f2ddea387d6018ac1722cdb90a433b6b0b43", "author": {"user": {"login": "pivotal-eshu", "name": "Eric Shu"}}, "url": "https://github.com/apache/geode/commit/e2c9f2ddea387d6018ac1722cdb90a433b6b0b43", "committedDate": "2020-07-06T20:09:00Z", "message": "fix review comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzMzc3Nzkw", "url": "https://github.com/apache/geode/pull/5333#pullrequestreview-443377790", "createdAt": "2020-07-06T20:15:02Z", "commit": {"oid": "e2c9f2ddea387d6018ac1722cdb90a433b6b0b43"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4345, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}