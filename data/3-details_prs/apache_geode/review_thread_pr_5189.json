{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI1Mzg0MTU4", "number": 5189, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxODoyMzo0OFrOECRUrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxODoyMzo0OFrOECRUrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwODE2NDI5OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionOverflowClearDUnitTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxODoyMzo0OFrOGeoHLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QyMzoxMDoxMFrOGewkEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc2NzY2MQ==", "bodyText": "I think you need a tearDown method to ensure that Locator and Servers are all stopped in every VM even if any tests failed. You could probably move destroyRegion and destroyDiskStore to tearDown as well (or remove them?).\nClose clients 1st, then servers, then locator (see the order of VMs in Arrays.asList):\n@After\npublic void tearDown() throws Exception {\n  for (VM vm : Arrays.asList(getVM(4), getVM(3), getVM(2), getVM(1), getVM(0)) {\n    vm.invoke(() -> {\n      if (clientCache != null) {\n        clientCache.close();\n      }\n      if (LOCATOR_LAUNCHER.get() != null) {\n        LOCATOR_LAUNCHER.get().stop();\n      }\n      if (SERVER_LAUNCHER.get() != null) {\n        SERVER_LAUNCHER.get().stop();\n      }\n\n      clientCache = null;\n      LOCATOR_LAUNCHER.set(null);\n      SERVER_LAUNCHER.set(null);\n    }\n  }\n}\n\nYou'll need to hoist anything (such as clientCache) to be a private static field/var in the test class so that you can reference it from tearDown() to close it.", "url": "https://github.com/apache/geode/pull/5189#discussion_r434767661", "createdAt": "2020-06-03T18:23:48Z", "author": {"login": "kirklund"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionOverflowClearDUnitTest.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.ENABLE_CLUSTER_CONFIGURATION;\n+import static org.apache.geode.distributed.ConfigurationProperties.HTTP_SERVICE_PORT;\n+import static org.apache.geode.distributed.ConfigurationProperties.JMX_MANAGER;\n+import static org.apache.geode.distributed.ConfigurationProperties.JMX_MANAGER_PORT;\n+import static org.apache.geode.distributed.ConfigurationProperties.JMX_MANAGER_START;\n+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.LOG_FILE;\n+import static org.apache.geode.distributed.ConfigurationProperties.MAX_WAIT_TIME_RECONNECT;\n+import static org.apache.geode.distributed.ConfigurationProperties.MEMBER_TIMEOUT;\n+import static org.apache.geode.distributed.ConfigurationProperties.USE_CLUSTER_CONFIGURATION;\n+import static org.apache.geode.internal.AvailablePortHelper.getRandomAvailableTCPPorts;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.apache.geode.test.dunit.VM.getVMId;\n+import static org.apache.geode.test.dunit.VM.toArray;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.File;\n+import java.io.Serializable;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.IntStream;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.DiskStoreFactory;\n+import org.apache.geode.cache.EvictionAction;\n+import org.apache.geode.cache.EvictionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.client.ClientCache;\n+import org.apache.geode.cache.client.ClientCacheFactory;\n+import org.apache.geode.cache.client.ClientRegionShortcut;\n+import org.apache.geode.distributed.LocatorLauncher;\n+import org.apache.geode.distributed.ServerLauncher;\n+import org.apache.geode.distributed.internal.InternalLocator;\n+import org.apache.geode.management.internal.cli.util.CommandStringBuilder;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+import org.apache.geode.test.junit.rules.GfshCommandRule;\n+import org.apache.geode.test.junit.rules.serializable.SerializableTemporaryFolder;\n+\n+public class PartitionedRegionOverflowClearDUnitTest implements Serializable {\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule();\n+\n+  @Rule\n+  public SerializableTemporaryFolder temporaryFolder = new SerializableTemporaryFolder();\n+\n+  @Rule\n+  public transient GfshCommandRule gfsh = new GfshCommandRule();\n+\n+  private VM server1;\n+  private VM server2;\n+  private VM accessor;\n+  private VM client;\n+\n+  private static final String LOCATOR_NAME = \"locator\";\n+  private static final String SERVER1_NAME = \"server1\";\n+  private static final String SERVER2_NAME = \"server2\";\n+  private static final String SERVER3_NAME = \"server3\";\n+\n+  private File locatorDir;\n+  private File server1Dir;\n+  private File server2Dir;\n+  private File server3Dir;\n+\n+  private String locatorString;\n+\n+  private int locatorPort;\n+  private int locatorJmxPort;\n+  private int locatorHttpPort;\n+  private int serverPort1;\n+  private int serverPort2;\n+  private int serverPort3;\n+\n+  private static final AtomicReference<LocatorLauncher> LOCATOR_LAUNCHER = new AtomicReference<>();\n+\n+  private static final AtomicReference<ServerLauncher> SERVER_LAUNCHER = new AtomicReference<>();\n+\n+  private static final String OVERFLOW_REGION_NAME = \"testOverflowRegion\";\n+\n+  public static final int NUM_ENTRIES = 1000;\n+\n+  @Before\n+  public void setup() throws Exception {\n+    VM locator = getVM(0);\n+    server1 = getVM(1);\n+    server2 = getVM(2);\n+    accessor = getVM(3);\n+    client = getVM(4);\n+\n+    locatorDir = temporaryFolder.newFolder(LOCATOR_NAME);\n+    server1Dir = temporaryFolder.newFolder(SERVER1_NAME);\n+    server2Dir = temporaryFolder.newFolder(SERVER2_NAME);\n+    server3Dir = temporaryFolder.newFolder(SERVER3_NAME);\n+\n+    int[] ports = getRandomAvailableTCPPorts(6);\n+    locatorPort = ports[0];\n+    locatorJmxPort = ports[1];\n+    locatorHttpPort = ports[2];\n+    serverPort1 = ports[3];\n+    serverPort2 = ports[4];\n+    serverPort3 = ports[5];\n+\n+    locator.invoke(\n+        () -> startLocator(locatorDir, locatorPort, locatorJmxPort, locatorHttpPort));\n+    gfsh.connectAndVerify(locatorJmxPort, GfshCommandRule.PortType.jmxManager);\n+\n+    locatorString = \"localhost[\" + locatorPort + \"]\";\n+    server1.invoke(() -> startServer(SERVER1_NAME, server1Dir, locatorString, serverPort1));\n+    server2.invoke(() -> startServer(SERVER2_NAME, server2Dir, locatorString, serverPort2));\n+  }\n+\n+  @Test\n+  public void testGfshClearRegionWithOverflow() throws InterruptedException {\n+    createPartitionRedundantPersistentOverflowRegion();\n+\n+    populateRegion();\n+    assertRegionSize(NUM_ENTRIES);\n+\n+    gfsh.executeAndAssertThat(\"clear region --name=\" + OVERFLOW_REGION_NAME).statusIsSuccess();\n+    assertRegionSize(0);\n+\n+    restartServers();\n+\n+    assertRegionSize(0);\n+\n+    destroyRegion();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4183ca970028e380b0ab59542880c592c99e082"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkwNjEyOA==", "bodyText": "Changes have been made per your suggestion.", "url": "https://github.com/apache/geode/pull/5189#discussion_r434906128", "createdAt": "2020-06-03T23:10:10Z", "author": {"login": "jchen21"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionOverflowClearDUnitTest.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.ENABLE_CLUSTER_CONFIGURATION;\n+import static org.apache.geode.distributed.ConfigurationProperties.HTTP_SERVICE_PORT;\n+import static org.apache.geode.distributed.ConfigurationProperties.JMX_MANAGER;\n+import static org.apache.geode.distributed.ConfigurationProperties.JMX_MANAGER_PORT;\n+import static org.apache.geode.distributed.ConfigurationProperties.JMX_MANAGER_START;\n+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.LOG_FILE;\n+import static org.apache.geode.distributed.ConfigurationProperties.MAX_WAIT_TIME_RECONNECT;\n+import static org.apache.geode.distributed.ConfigurationProperties.MEMBER_TIMEOUT;\n+import static org.apache.geode.distributed.ConfigurationProperties.USE_CLUSTER_CONFIGURATION;\n+import static org.apache.geode.internal.AvailablePortHelper.getRandomAvailableTCPPorts;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.apache.geode.test.dunit.VM.getVMId;\n+import static org.apache.geode.test.dunit.VM.toArray;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.File;\n+import java.io.Serializable;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.IntStream;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.DiskStoreFactory;\n+import org.apache.geode.cache.EvictionAction;\n+import org.apache.geode.cache.EvictionAttributes;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.client.ClientCache;\n+import org.apache.geode.cache.client.ClientCacheFactory;\n+import org.apache.geode.cache.client.ClientRegionShortcut;\n+import org.apache.geode.distributed.LocatorLauncher;\n+import org.apache.geode.distributed.ServerLauncher;\n+import org.apache.geode.distributed.internal.InternalLocator;\n+import org.apache.geode.management.internal.cli.util.CommandStringBuilder;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+import org.apache.geode.test.junit.rules.GfshCommandRule;\n+import org.apache.geode.test.junit.rules.serializable.SerializableTemporaryFolder;\n+\n+public class PartitionedRegionOverflowClearDUnitTest implements Serializable {\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule();\n+\n+  @Rule\n+  public SerializableTemporaryFolder temporaryFolder = new SerializableTemporaryFolder();\n+\n+  @Rule\n+  public transient GfshCommandRule gfsh = new GfshCommandRule();\n+\n+  private VM server1;\n+  private VM server2;\n+  private VM accessor;\n+  private VM client;\n+\n+  private static final String LOCATOR_NAME = \"locator\";\n+  private static final String SERVER1_NAME = \"server1\";\n+  private static final String SERVER2_NAME = \"server2\";\n+  private static final String SERVER3_NAME = \"server3\";\n+\n+  private File locatorDir;\n+  private File server1Dir;\n+  private File server2Dir;\n+  private File server3Dir;\n+\n+  private String locatorString;\n+\n+  private int locatorPort;\n+  private int locatorJmxPort;\n+  private int locatorHttpPort;\n+  private int serverPort1;\n+  private int serverPort2;\n+  private int serverPort3;\n+\n+  private static final AtomicReference<LocatorLauncher> LOCATOR_LAUNCHER = new AtomicReference<>();\n+\n+  private static final AtomicReference<ServerLauncher> SERVER_LAUNCHER = new AtomicReference<>();\n+\n+  private static final String OVERFLOW_REGION_NAME = \"testOverflowRegion\";\n+\n+  public static final int NUM_ENTRIES = 1000;\n+\n+  @Before\n+  public void setup() throws Exception {\n+    VM locator = getVM(0);\n+    server1 = getVM(1);\n+    server2 = getVM(2);\n+    accessor = getVM(3);\n+    client = getVM(4);\n+\n+    locatorDir = temporaryFolder.newFolder(LOCATOR_NAME);\n+    server1Dir = temporaryFolder.newFolder(SERVER1_NAME);\n+    server2Dir = temporaryFolder.newFolder(SERVER2_NAME);\n+    server3Dir = temporaryFolder.newFolder(SERVER3_NAME);\n+\n+    int[] ports = getRandomAvailableTCPPorts(6);\n+    locatorPort = ports[0];\n+    locatorJmxPort = ports[1];\n+    locatorHttpPort = ports[2];\n+    serverPort1 = ports[3];\n+    serverPort2 = ports[4];\n+    serverPort3 = ports[5];\n+\n+    locator.invoke(\n+        () -> startLocator(locatorDir, locatorPort, locatorJmxPort, locatorHttpPort));\n+    gfsh.connectAndVerify(locatorJmxPort, GfshCommandRule.PortType.jmxManager);\n+\n+    locatorString = \"localhost[\" + locatorPort + \"]\";\n+    server1.invoke(() -> startServer(SERVER1_NAME, server1Dir, locatorString, serverPort1));\n+    server2.invoke(() -> startServer(SERVER2_NAME, server2Dir, locatorString, serverPort2));\n+  }\n+\n+  @Test\n+  public void testGfshClearRegionWithOverflow() throws InterruptedException {\n+    createPartitionRedundantPersistentOverflowRegion();\n+\n+    populateRegion();\n+    assertRegionSize(NUM_ENTRIES);\n+\n+    gfsh.executeAndAssertThat(\"clear region --name=\" + OVERFLOW_REGION_NAME).statusIsSuccess();\n+    assertRegionSize(0);\n+\n+    restartServers();\n+\n+    assertRegionSize(0);\n+\n+    destroyRegion();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc2NzY2MQ=="}, "originalCommit": {"oid": "b4183ca970028e380b0ab59542880c592c99e082"}, "originalPosition": 149}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3943, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}