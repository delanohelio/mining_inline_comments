{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg5ODk0MTA1", "number": 4821, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDo1ODowOFrODprNtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMTowMzoyN1rODprT2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDI2MjMwOnYy", "diffSide": "RIGHT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/RedisLockKey.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDo1ODowOFrOF5AJyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMzo1ODoxN1rOF5Uy_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMxNTY1Ng==", "bodyText": "This class was renamed to KeyHashIdentifier on develop - I think you may have inadvertently picked this up during a merge. It can be deleted.", "url": "https://github.com/apache/geode/pull/4821#discussion_r395315656", "createdAt": "2020-03-19T20:58:08Z", "author": {"login": "jdeppe-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/RedisLockKey.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.apache.geode.redis.internal;\n+\n+import org.apache.commons.codec.digest.MurmurHash3;\n+\n+public class RedisLockKey {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8000650443523a0ba2d6f2f0607b8bf9bcd01797"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0MDUwNA==", "bodyText": "Deleted! Thank you.", "url": "https://github.com/apache/geode/pull/4821#discussion_r395640504", "createdAt": "2020-03-20T13:37:31Z", "author": {"login": "sabbey37"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/RedisLockKey.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.apache.geode.redis.internal;\n+\n+import org.apache.commons.codec.digest.MurmurHash3;\n+\n+public class RedisLockKey {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMxNTY1Ng=="}, "originalCommit": {"oid": "8000650443523a0ba2d6f2f0607b8bf9bcd01797"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY1Mzg4Ng==", "bodyText": "On it!", "url": "https://github.com/apache/geode/pull/4821#discussion_r395653886", "createdAt": "2020-03-20T13:58:17Z", "author": {"login": "ringles"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/RedisLockKey.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.apache.geode.redis.internal;\n+\n+import org.apache.commons.codec.digest.MurmurHash3;\n+\n+public class RedisLockKey {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMxNTY1Ng=="}, "originalCommit": {"oid": "8000650443523a0ba2d6f2f0607b8bf9bcd01797"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDI3ODAyOnYy", "diffSide": "RIGHT", "path": "geode-redis/src/integrationTest/java/org/apache/geode/redis/StringsIntegrationTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMTowMzoyOFrOF5AT7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMzo1Nzo1OFrOF5UyOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMxODI1Mw==", "bodyText": "There are a couple of these comments. Since all of these good changes are already being applied to this class, is there any reason not to validate these remaining few tests? Or is this more work than what it appears on the surface?", "url": "https://github.com/apache/geode/pull/4821#discussion_r395318253", "createdAt": "2020-03-19T21:03:28Z", "author": {"login": "jdeppe-pivotal"}, "path": "geode-redis/src/integrationTest/java/org/apache/geode/redis/StringsIntegrationTest.java", "diffHunk": "@@ -219,30 +351,313 @@ public void testMSetAndGet() {\n       vals[i] = val;\n     }\n \n-    jedis.mset(keyvals);\n+    String resultString = jedis.mset(keyvals);\n+    assertThat(resultString).isEqualTo(\"OK\");\n \n     List<String> ret = jedis.mget(keys);\n     Object[] retArray = ret.toArray();\n \n-    assertTrue(Arrays.equals(vals, retArray));\n+    assertThat(Arrays.equals(vals, retArray)).isTrue();\n+  }\n+\n+  @Test\n+  public void testMGet_requestNonexistentKey_respondsWithNil() {\n+    String key1 = \"existingKey\";\n+    String key2 = \"notReallyAKey\";\n+    String value1 = \"theRealValue\";\n+    String[] keys = new String[2];\n+    String[] expectedVals = new String[2];\n+    keys[0] = key1;\n+    keys[1] = key2;\n+    expectedVals[0] = value1;\n+    expectedVals[1] = null;\n+\n+    jedis.set(key1, value1);\n+\n+    List<String> ret = jedis.mget(keys);\n+    Object[] retArray = ret.toArray();\n+\n+    assertThat(Arrays.equals(expectedVals, retArray)).isTrue();\n+  }\n+\n+  @Test\n+  public void testMGet_concurrentInstances_mustBeAtomic()\n+      throws InterruptedException, ExecutionException {\n+    String keyBaseName = \"MSETBASE\";\n+    String val1BaseName = \"FIRSTVALBASE\";\n+    String val2BaseName = \"SECONDVALBASE\";\n+    String[] keysAndVals1 = new String[(ITERATION_COUNT * 2)];\n+    String[] keysAndVals2 = new String[(ITERATION_COUNT * 2)];\n+    String[] keys = new String[ITERATION_COUNT];\n+    String[] vals1 = new String[ITERATION_COUNT];\n+    String[] vals2 = new String[ITERATION_COUNT];\n+    String[] expectedVals;\n+\n+    SetUpArraysForConcurrentMSet(keyBaseName,\n+        val1BaseName, val2BaseName,\n+        keysAndVals1, keysAndVals2,\n+        keys,\n+        vals1, vals2);\n+\n+    RunTwoMSetsInParallelThreadsAndVerifyReturnValue(keysAndVals1, keysAndVals2);\n+\n+    List<String> actualVals = jedis.mget(keys);\n+    expectedVals = DetermineWhichMSetWonTheRace(vals1, vals2, actualVals);\n+\n+    assertThat(actualVals.toArray(new String[] {})).contains(expectedVals);\n+  }\n+\n+  private void SetUpArraysForConcurrentMSet(String keyBaseName, String val1BaseName,\n+      String val2BaseName, String[] keysAndVals1,\n+      String[] keysAndVals2, String[] keys, String[] vals1,\n+      String[] vals2) {\n+    for (int i = 0; i < ITERATION_COUNT; i++) {\n+      String key = keyBaseName + i;\n+      String value1 = val1BaseName + i;\n+      String value2 = val2BaseName + i;\n+      keysAndVals1[2 * i] = key;\n+      keysAndVals1[2 * i + 1] = value1;\n+      keysAndVals2[2 * i] = key;\n+      keysAndVals2[2 * i + 1] = value2;\n+      keys[i] = key;\n+      vals1[i] = value1;\n+      vals2[i] = value2;\n+    }\n+  }\n+\n+  private void RunTwoMSetsInParallelThreadsAndVerifyReturnValue(String[] keysAndVals1,\n+      String[] keysAndVals2)\n+      throws InterruptedException, ExecutionException {\n+    CountDownLatch latch = new CountDownLatch(1);\n+    ExecutorService pool = Executors.newFixedThreadPool(2);\n+    Callable<String> callable1 = () -> jedis.mset(keysAndVals1);\n+    Callable<String> callable2 = () -> jedis2.mset(keysAndVals2);\n+    Future<String> future1 = pool.submit(callable1);\n+    Future<String> future2 = pool.submit(callable2);\n+\n+    latch.countDown();\n+\n+    assertThat(future1.get()).isEqualTo(\"OK\");\n+    assertThat(future2.get()).isEqualTo(\"OK\");\n+  }\n+\n+  private String[] DetermineWhichMSetWonTheRace(String[] vals1, String[] vals2,\n+      List<String> actualVals) {\n+    String[] expectedVals;\n+    if (actualVals.get(0).equals(\"FIRSTVALBASE0\")) {\n+      expectedVals = vals1;\n+    } else {\n+      expectedVals = vals2;\n+    }\n+    return expectedVals;\n+  }\n+\n+  @Test\n+  public void testConcurrentDel_differentClients()\n+      throws InterruptedException, ExecutionException {\n+    String keyBaseName = \"DELBASE\";\n+\n+    doABunchOfSets(keyBaseName, jedis);\n+\n+    CountDownLatch latch = new CountDownLatch(1);\n+    ExecutorService pool = Executors.newFixedThreadPool(2);\n+    Callable<Integer> callable1 = () -> doABunchOfDels(keyBaseName, 0, jedis, latch);\n+    Callable<Integer> callable2 = () -> doABunchOfDels(keyBaseName, 1, jedis2, latch);\n+    Future<Integer> future1 = pool.submit(callable1);\n+    Future<Integer> future2 = pool.submit(callable2);\n+\n+    latch.countDown();\n+\n+    assertThat(future1.get() + future2.get()).isEqualTo(ITERATION_COUNT);\n+\n+    for (int i = 0; i < ITERATION_COUNT; i++) {\n+      assertThat(jedis.get(keyBaseName + i)).isNull();\n+    }\n+\n+    pool.shutdown();\n+  }\n+\n+  private void doABunchOfSets(String keyBaseName, Jedis jedis) {\n+    for (int i = 0; i < ITERATION_COUNT; i++) {\n+      jedis.set(keyBaseName + i, \"value\" + i);\n+    }\n+  }\n+\n+  private int doABunchOfDels(String keyBaseName, int start, Jedis jedis, CountDownLatch latch)\n+      throws InterruptedException {\n+    int delCount = 0;\n+    latch.await();\n+\n+    for (int i = start; i < ITERATION_COUNT; i += 2) {\n+      delCount += jedis.del(keyBaseName + i);\n+      Thread.yield();\n+    }\n+    return delCount;\n   }\n \n   @Test\n   public void testMSetNX() {\n-    Set<String> strings = new HashSet<String>();\n-    for (int i = 0; i < 2 * 5; i++)\n-      strings.add(randString());\n-    String[] array = strings.toArray(new String[0]);\n-    long response = jedis.msetnx(array);\n+    Set<String> keysAndVals = new HashSet<String>();\n+    for (int i = 0; i < 2 * 5; i++) {\n+      keysAndVals.add(randString());\n+    }\n+    String[] keysAndValsArray = keysAndVals.toArray(new String[0]);\n+    long response = jedis.msetnx(keysAndValsArray);\n+\n+    assertThat(response).isEqualTo(1);\n+\n+    long response2 = jedis.msetnx(keysAndValsArray[0], randString());\n+\n+    assertThat(response2).isEqualTo(0);\n+    assertThat(keysAndValsArray[1]).isEqualTo(jedis.get(keysAndValsArray[0]));\n+  }\n+\n+  @Test\n+  public void testDecr() {\n+    String oneHundredKey = randString();\n+    String negativeOneHundredKey = randString();\n+    String unsetKey = randString();\n+    final int oneHundredValue = 100;\n+    final int negativeOneHundredValue = -100;\n+    jedis.set(oneHundredKey, Integer.toString(oneHundredValue));\n+    jedis.set(negativeOneHundredKey, Integer.toString(negativeOneHundredValue));\n+\n+    jedis.decr(oneHundredKey);\n+    jedis.decr(negativeOneHundredKey);\n+    jedis.decr(unsetKey);\n+\n+    assertThat(jedis.get(oneHundredKey)).isEqualTo(Integer.toString(oneHundredValue - 1));\n+    assertThat(jedis.get(negativeOneHundredKey))\n+        .isEqualTo(Integer.toString(negativeOneHundredValue - 1));\n+    assertThat(jedis.get(unsetKey)).isEqualTo(Integer.toString(-1));\n+  }\n+\n+  @Test\n+  public void testDecr_shouldBeAtomic() throws ExecutionException, InterruptedException {\n+    jedis.set(\"contestedKey\", \"0\");\n+\n+    CountDownLatch latch = new CountDownLatch(1);\n+    ExecutorService pool = Executors.newFixedThreadPool(2);\n+    Callable<Integer> callable1 = () -> doABunchOfDecrs(jedis, latch);\n+    Callable<Integer> callable2 = () -> doABunchOfDecrs(jedis2, latch);\n+    Future<Integer> future1 = pool.submit(callable1);\n+    Future<Integer> future2 = pool.submit(callable2);\n+\n+    latch.countDown();\n+\n+    future1.get();\n+    future2.get();\n+\n+    assertThat(jedis.get(\"contestedKey\")).isEqualTo(Integer.toString(-2 * ITERATION_COUNT));\n+  }\n+\n+  private Integer doABunchOfDecrs(Jedis jedis, CountDownLatch latch) throws InterruptedException {\n+    latch.await();\n+    for (int i = 0; i < ITERATION_COUNT; i++) {\n+      jedis.decr(\"contestedKey\");\n+    }\n+    return ITERATION_COUNT;\n+  }\n+\n+  @Test\n+  public void testIncr() {\n+    String oneHundredKey = randString();\n+    String negativeOneHundredKey = randString();\n+    String unsetKey = randString();\n+    final int oneHundredValue = 100;\n+    final int negativeOneHundredValue = -100;\n+    jedis.set(oneHundredKey, Integer.toString(oneHundredValue));\n+    jedis.set(negativeOneHundredKey, Integer.toString(negativeOneHundredValue));\n+\n+    jedis.incr(oneHundredKey);\n+    jedis.incr(negativeOneHundredKey);\n+    jedis.incr(unsetKey);\n+\n+    assertThat(jedis.get(oneHundredKey)).isEqualTo(Integer.toString(oneHundredValue + 1));\n+    assertThat(jedis.get(negativeOneHundredKey))\n+        .isEqualTo(Integer.toString(negativeOneHundredValue + 1));\n+    assertThat(jedis.get(unsetKey)).isEqualTo(Integer.toString(1));\n+  }\n+\n+  @Test\n+  public void testIncr_whenOverflow_shouldReturnError() {\n+    String key = \"key\";\n+    String max64BitIntegerValue = \"9223372036854775807\";\n+    jedis.set(key, max64BitIntegerValue);\n+\n+    try {\n+      jedis.incr(key);\n+    } catch (JedisDataException e) {\n+      assertThat(e.getMessage()).contains(\"value is not an integer or out of range\");\n+    }\n+    assertThat(jedis.get(key)).isEqualTo(max64BitIntegerValue);\n+  }\n+\n+  @Test\n+  public void testIncr_whenWrongType_shouldReturnError() {\n+    String key = \"key\";\n+    String nonIntegerValue = \"I am not a number! I am a free man!\";\n+    jedis.set(key, nonIntegerValue);\n+\n+    try {\n+      jedis.incr(key);\n+    } catch (JedisDataException e) {\n+      assertThat(e.getMessage()).contains(RedisConstants.ERROR_WRONG_TYPE);\n+    }\n+    assertThat(jedis.get(key)).isEqualTo(nonIntegerValue);\n+  }\n+\n+  @Test\n+  public void testIncr_shouldBeAtomic() throws ExecutionException, InterruptedException {\n+    jedis.set(\"contestedKey\", \"0\");\n+\n+    CountDownLatch latch = new CountDownLatch(1);\n+    ExecutorService pool = Executors.newFixedThreadPool(2);\n+    Callable<Integer> callable1 = () -> doABunchOfIncrs(jedis, latch);\n+    Callable<Integer> callable2 = () -> doABunchOfIncrs(jedis2, latch);\n+    Future<Integer> future1 = pool.submit(callable1);\n+    Future<Integer> future2 = pool.submit(callable2);\n+\n+    latch.countDown();\n+\n+    future1.get();\n+    future2.get();\n \n-    assertTrue(response == 1);\n+    assertThat(jedis.get(\"contestedKey\")).isEqualTo(Integer.toString(2 * ITERATION_COUNT));\n+  }\n+\n+  @Test\n+  // @todo: not looked over for current release", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8000650443523a0ba2d6f2f0607b8bf9bcd01797"}, "originalPosition": 735}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0NjM3OQ==", "bodyText": "I think this story had gone on a bit longer than was originally planned and the scope kept expanding, so creating stories to go back and review the implementation/tests for the commands that weren't part of this release was a way of reining in the scope.  @ringles may be able to provide more context though.", "url": "https://github.com/apache/geode/pull/4821#discussion_r395646379", "createdAt": "2020-03-20T13:46:49Z", "author": {"login": "sabbey37"}, "path": "geode-redis/src/integrationTest/java/org/apache/geode/redis/StringsIntegrationTest.java", "diffHunk": "@@ -219,30 +351,313 @@ public void testMSetAndGet() {\n       vals[i] = val;\n     }\n \n-    jedis.mset(keyvals);\n+    String resultString = jedis.mset(keyvals);\n+    assertThat(resultString).isEqualTo(\"OK\");\n \n     List<String> ret = jedis.mget(keys);\n     Object[] retArray = ret.toArray();\n \n-    assertTrue(Arrays.equals(vals, retArray));\n+    assertThat(Arrays.equals(vals, retArray)).isTrue();\n+  }\n+\n+  @Test\n+  public void testMGet_requestNonexistentKey_respondsWithNil() {\n+    String key1 = \"existingKey\";\n+    String key2 = \"notReallyAKey\";\n+    String value1 = \"theRealValue\";\n+    String[] keys = new String[2];\n+    String[] expectedVals = new String[2];\n+    keys[0] = key1;\n+    keys[1] = key2;\n+    expectedVals[0] = value1;\n+    expectedVals[1] = null;\n+\n+    jedis.set(key1, value1);\n+\n+    List<String> ret = jedis.mget(keys);\n+    Object[] retArray = ret.toArray();\n+\n+    assertThat(Arrays.equals(expectedVals, retArray)).isTrue();\n+  }\n+\n+  @Test\n+  public void testMGet_concurrentInstances_mustBeAtomic()\n+      throws InterruptedException, ExecutionException {\n+    String keyBaseName = \"MSETBASE\";\n+    String val1BaseName = \"FIRSTVALBASE\";\n+    String val2BaseName = \"SECONDVALBASE\";\n+    String[] keysAndVals1 = new String[(ITERATION_COUNT * 2)];\n+    String[] keysAndVals2 = new String[(ITERATION_COUNT * 2)];\n+    String[] keys = new String[ITERATION_COUNT];\n+    String[] vals1 = new String[ITERATION_COUNT];\n+    String[] vals2 = new String[ITERATION_COUNT];\n+    String[] expectedVals;\n+\n+    SetUpArraysForConcurrentMSet(keyBaseName,\n+        val1BaseName, val2BaseName,\n+        keysAndVals1, keysAndVals2,\n+        keys,\n+        vals1, vals2);\n+\n+    RunTwoMSetsInParallelThreadsAndVerifyReturnValue(keysAndVals1, keysAndVals2);\n+\n+    List<String> actualVals = jedis.mget(keys);\n+    expectedVals = DetermineWhichMSetWonTheRace(vals1, vals2, actualVals);\n+\n+    assertThat(actualVals.toArray(new String[] {})).contains(expectedVals);\n+  }\n+\n+  private void SetUpArraysForConcurrentMSet(String keyBaseName, String val1BaseName,\n+      String val2BaseName, String[] keysAndVals1,\n+      String[] keysAndVals2, String[] keys, String[] vals1,\n+      String[] vals2) {\n+    for (int i = 0; i < ITERATION_COUNT; i++) {\n+      String key = keyBaseName + i;\n+      String value1 = val1BaseName + i;\n+      String value2 = val2BaseName + i;\n+      keysAndVals1[2 * i] = key;\n+      keysAndVals1[2 * i + 1] = value1;\n+      keysAndVals2[2 * i] = key;\n+      keysAndVals2[2 * i + 1] = value2;\n+      keys[i] = key;\n+      vals1[i] = value1;\n+      vals2[i] = value2;\n+    }\n+  }\n+\n+  private void RunTwoMSetsInParallelThreadsAndVerifyReturnValue(String[] keysAndVals1,\n+      String[] keysAndVals2)\n+      throws InterruptedException, ExecutionException {\n+    CountDownLatch latch = new CountDownLatch(1);\n+    ExecutorService pool = Executors.newFixedThreadPool(2);\n+    Callable<String> callable1 = () -> jedis.mset(keysAndVals1);\n+    Callable<String> callable2 = () -> jedis2.mset(keysAndVals2);\n+    Future<String> future1 = pool.submit(callable1);\n+    Future<String> future2 = pool.submit(callable2);\n+\n+    latch.countDown();\n+\n+    assertThat(future1.get()).isEqualTo(\"OK\");\n+    assertThat(future2.get()).isEqualTo(\"OK\");\n+  }\n+\n+  private String[] DetermineWhichMSetWonTheRace(String[] vals1, String[] vals2,\n+      List<String> actualVals) {\n+    String[] expectedVals;\n+    if (actualVals.get(0).equals(\"FIRSTVALBASE0\")) {\n+      expectedVals = vals1;\n+    } else {\n+      expectedVals = vals2;\n+    }\n+    return expectedVals;\n+  }\n+\n+  @Test\n+  public void testConcurrentDel_differentClients()\n+      throws InterruptedException, ExecutionException {\n+    String keyBaseName = \"DELBASE\";\n+\n+    doABunchOfSets(keyBaseName, jedis);\n+\n+    CountDownLatch latch = new CountDownLatch(1);\n+    ExecutorService pool = Executors.newFixedThreadPool(2);\n+    Callable<Integer> callable1 = () -> doABunchOfDels(keyBaseName, 0, jedis, latch);\n+    Callable<Integer> callable2 = () -> doABunchOfDels(keyBaseName, 1, jedis2, latch);\n+    Future<Integer> future1 = pool.submit(callable1);\n+    Future<Integer> future2 = pool.submit(callable2);\n+\n+    latch.countDown();\n+\n+    assertThat(future1.get() + future2.get()).isEqualTo(ITERATION_COUNT);\n+\n+    for (int i = 0; i < ITERATION_COUNT; i++) {\n+      assertThat(jedis.get(keyBaseName + i)).isNull();\n+    }\n+\n+    pool.shutdown();\n+  }\n+\n+  private void doABunchOfSets(String keyBaseName, Jedis jedis) {\n+    for (int i = 0; i < ITERATION_COUNT; i++) {\n+      jedis.set(keyBaseName + i, \"value\" + i);\n+    }\n+  }\n+\n+  private int doABunchOfDels(String keyBaseName, int start, Jedis jedis, CountDownLatch latch)\n+      throws InterruptedException {\n+    int delCount = 0;\n+    latch.await();\n+\n+    for (int i = start; i < ITERATION_COUNT; i += 2) {\n+      delCount += jedis.del(keyBaseName + i);\n+      Thread.yield();\n+    }\n+    return delCount;\n   }\n \n   @Test\n   public void testMSetNX() {\n-    Set<String> strings = new HashSet<String>();\n-    for (int i = 0; i < 2 * 5; i++)\n-      strings.add(randString());\n-    String[] array = strings.toArray(new String[0]);\n-    long response = jedis.msetnx(array);\n+    Set<String> keysAndVals = new HashSet<String>();\n+    for (int i = 0; i < 2 * 5; i++) {\n+      keysAndVals.add(randString());\n+    }\n+    String[] keysAndValsArray = keysAndVals.toArray(new String[0]);\n+    long response = jedis.msetnx(keysAndValsArray);\n+\n+    assertThat(response).isEqualTo(1);\n+\n+    long response2 = jedis.msetnx(keysAndValsArray[0], randString());\n+\n+    assertThat(response2).isEqualTo(0);\n+    assertThat(keysAndValsArray[1]).isEqualTo(jedis.get(keysAndValsArray[0]));\n+  }\n+\n+  @Test\n+  public void testDecr() {\n+    String oneHundredKey = randString();\n+    String negativeOneHundredKey = randString();\n+    String unsetKey = randString();\n+    final int oneHundredValue = 100;\n+    final int negativeOneHundredValue = -100;\n+    jedis.set(oneHundredKey, Integer.toString(oneHundredValue));\n+    jedis.set(negativeOneHundredKey, Integer.toString(negativeOneHundredValue));\n+\n+    jedis.decr(oneHundredKey);\n+    jedis.decr(negativeOneHundredKey);\n+    jedis.decr(unsetKey);\n+\n+    assertThat(jedis.get(oneHundredKey)).isEqualTo(Integer.toString(oneHundredValue - 1));\n+    assertThat(jedis.get(negativeOneHundredKey))\n+        .isEqualTo(Integer.toString(negativeOneHundredValue - 1));\n+    assertThat(jedis.get(unsetKey)).isEqualTo(Integer.toString(-1));\n+  }\n+\n+  @Test\n+  public void testDecr_shouldBeAtomic() throws ExecutionException, InterruptedException {\n+    jedis.set(\"contestedKey\", \"0\");\n+\n+    CountDownLatch latch = new CountDownLatch(1);\n+    ExecutorService pool = Executors.newFixedThreadPool(2);\n+    Callable<Integer> callable1 = () -> doABunchOfDecrs(jedis, latch);\n+    Callable<Integer> callable2 = () -> doABunchOfDecrs(jedis2, latch);\n+    Future<Integer> future1 = pool.submit(callable1);\n+    Future<Integer> future2 = pool.submit(callable2);\n+\n+    latch.countDown();\n+\n+    future1.get();\n+    future2.get();\n+\n+    assertThat(jedis.get(\"contestedKey\")).isEqualTo(Integer.toString(-2 * ITERATION_COUNT));\n+  }\n+\n+  private Integer doABunchOfDecrs(Jedis jedis, CountDownLatch latch) throws InterruptedException {\n+    latch.await();\n+    for (int i = 0; i < ITERATION_COUNT; i++) {\n+      jedis.decr(\"contestedKey\");\n+    }\n+    return ITERATION_COUNT;\n+  }\n+\n+  @Test\n+  public void testIncr() {\n+    String oneHundredKey = randString();\n+    String negativeOneHundredKey = randString();\n+    String unsetKey = randString();\n+    final int oneHundredValue = 100;\n+    final int negativeOneHundredValue = -100;\n+    jedis.set(oneHundredKey, Integer.toString(oneHundredValue));\n+    jedis.set(negativeOneHundredKey, Integer.toString(negativeOneHundredValue));\n+\n+    jedis.incr(oneHundredKey);\n+    jedis.incr(negativeOneHundredKey);\n+    jedis.incr(unsetKey);\n+\n+    assertThat(jedis.get(oneHundredKey)).isEqualTo(Integer.toString(oneHundredValue + 1));\n+    assertThat(jedis.get(negativeOneHundredKey))\n+        .isEqualTo(Integer.toString(negativeOneHundredValue + 1));\n+    assertThat(jedis.get(unsetKey)).isEqualTo(Integer.toString(1));\n+  }\n+\n+  @Test\n+  public void testIncr_whenOverflow_shouldReturnError() {\n+    String key = \"key\";\n+    String max64BitIntegerValue = \"9223372036854775807\";\n+    jedis.set(key, max64BitIntegerValue);\n+\n+    try {\n+      jedis.incr(key);\n+    } catch (JedisDataException e) {\n+      assertThat(e.getMessage()).contains(\"value is not an integer or out of range\");\n+    }\n+    assertThat(jedis.get(key)).isEqualTo(max64BitIntegerValue);\n+  }\n+\n+  @Test\n+  public void testIncr_whenWrongType_shouldReturnError() {\n+    String key = \"key\";\n+    String nonIntegerValue = \"I am not a number! I am a free man!\";\n+    jedis.set(key, nonIntegerValue);\n+\n+    try {\n+      jedis.incr(key);\n+    } catch (JedisDataException e) {\n+      assertThat(e.getMessage()).contains(RedisConstants.ERROR_WRONG_TYPE);\n+    }\n+    assertThat(jedis.get(key)).isEqualTo(nonIntegerValue);\n+  }\n+\n+  @Test\n+  public void testIncr_shouldBeAtomic() throws ExecutionException, InterruptedException {\n+    jedis.set(\"contestedKey\", \"0\");\n+\n+    CountDownLatch latch = new CountDownLatch(1);\n+    ExecutorService pool = Executors.newFixedThreadPool(2);\n+    Callable<Integer> callable1 = () -> doABunchOfIncrs(jedis, latch);\n+    Callable<Integer> callable2 = () -> doABunchOfIncrs(jedis2, latch);\n+    Future<Integer> future1 = pool.submit(callable1);\n+    Future<Integer> future2 = pool.submit(callable2);\n+\n+    latch.countDown();\n+\n+    future1.get();\n+    future2.get();\n \n-    assertTrue(response == 1);\n+    assertThat(jedis.get(\"contestedKey\")).isEqualTo(Integer.toString(2 * ITERATION_COUNT));\n+  }\n+\n+  @Test\n+  // @todo: not looked over for current release", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMxODI1Mw=="}, "originalCommit": {"oid": "8000650443523a0ba2d6f2f0607b8bf9bcd01797"}, "originalPosition": 735}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY1MzY5MA==", "bodyText": "The issue is that there are higher-priority commands that need love and attention before we circle back to these. There are stories in the backlog for them, but they aren't our current top priority.", "url": "https://github.com/apache/geode/pull/4821#discussion_r395653690", "createdAt": "2020-03-20T13:57:58Z", "author": {"login": "ringles"}, "path": "geode-redis/src/integrationTest/java/org/apache/geode/redis/StringsIntegrationTest.java", "diffHunk": "@@ -219,30 +351,313 @@ public void testMSetAndGet() {\n       vals[i] = val;\n     }\n \n-    jedis.mset(keyvals);\n+    String resultString = jedis.mset(keyvals);\n+    assertThat(resultString).isEqualTo(\"OK\");\n \n     List<String> ret = jedis.mget(keys);\n     Object[] retArray = ret.toArray();\n \n-    assertTrue(Arrays.equals(vals, retArray));\n+    assertThat(Arrays.equals(vals, retArray)).isTrue();\n+  }\n+\n+  @Test\n+  public void testMGet_requestNonexistentKey_respondsWithNil() {\n+    String key1 = \"existingKey\";\n+    String key2 = \"notReallyAKey\";\n+    String value1 = \"theRealValue\";\n+    String[] keys = new String[2];\n+    String[] expectedVals = new String[2];\n+    keys[0] = key1;\n+    keys[1] = key2;\n+    expectedVals[0] = value1;\n+    expectedVals[1] = null;\n+\n+    jedis.set(key1, value1);\n+\n+    List<String> ret = jedis.mget(keys);\n+    Object[] retArray = ret.toArray();\n+\n+    assertThat(Arrays.equals(expectedVals, retArray)).isTrue();\n+  }\n+\n+  @Test\n+  public void testMGet_concurrentInstances_mustBeAtomic()\n+      throws InterruptedException, ExecutionException {\n+    String keyBaseName = \"MSETBASE\";\n+    String val1BaseName = \"FIRSTVALBASE\";\n+    String val2BaseName = \"SECONDVALBASE\";\n+    String[] keysAndVals1 = new String[(ITERATION_COUNT * 2)];\n+    String[] keysAndVals2 = new String[(ITERATION_COUNT * 2)];\n+    String[] keys = new String[ITERATION_COUNT];\n+    String[] vals1 = new String[ITERATION_COUNT];\n+    String[] vals2 = new String[ITERATION_COUNT];\n+    String[] expectedVals;\n+\n+    SetUpArraysForConcurrentMSet(keyBaseName,\n+        val1BaseName, val2BaseName,\n+        keysAndVals1, keysAndVals2,\n+        keys,\n+        vals1, vals2);\n+\n+    RunTwoMSetsInParallelThreadsAndVerifyReturnValue(keysAndVals1, keysAndVals2);\n+\n+    List<String> actualVals = jedis.mget(keys);\n+    expectedVals = DetermineWhichMSetWonTheRace(vals1, vals2, actualVals);\n+\n+    assertThat(actualVals.toArray(new String[] {})).contains(expectedVals);\n+  }\n+\n+  private void SetUpArraysForConcurrentMSet(String keyBaseName, String val1BaseName,\n+      String val2BaseName, String[] keysAndVals1,\n+      String[] keysAndVals2, String[] keys, String[] vals1,\n+      String[] vals2) {\n+    for (int i = 0; i < ITERATION_COUNT; i++) {\n+      String key = keyBaseName + i;\n+      String value1 = val1BaseName + i;\n+      String value2 = val2BaseName + i;\n+      keysAndVals1[2 * i] = key;\n+      keysAndVals1[2 * i + 1] = value1;\n+      keysAndVals2[2 * i] = key;\n+      keysAndVals2[2 * i + 1] = value2;\n+      keys[i] = key;\n+      vals1[i] = value1;\n+      vals2[i] = value2;\n+    }\n+  }\n+\n+  private void RunTwoMSetsInParallelThreadsAndVerifyReturnValue(String[] keysAndVals1,\n+      String[] keysAndVals2)\n+      throws InterruptedException, ExecutionException {\n+    CountDownLatch latch = new CountDownLatch(1);\n+    ExecutorService pool = Executors.newFixedThreadPool(2);\n+    Callable<String> callable1 = () -> jedis.mset(keysAndVals1);\n+    Callable<String> callable2 = () -> jedis2.mset(keysAndVals2);\n+    Future<String> future1 = pool.submit(callable1);\n+    Future<String> future2 = pool.submit(callable2);\n+\n+    latch.countDown();\n+\n+    assertThat(future1.get()).isEqualTo(\"OK\");\n+    assertThat(future2.get()).isEqualTo(\"OK\");\n+  }\n+\n+  private String[] DetermineWhichMSetWonTheRace(String[] vals1, String[] vals2,\n+      List<String> actualVals) {\n+    String[] expectedVals;\n+    if (actualVals.get(0).equals(\"FIRSTVALBASE0\")) {\n+      expectedVals = vals1;\n+    } else {\n+      expectedVals = vals2;\n+    }\n+    return expectedVals;\n+  }\n+\n+  @Test\n+  public void testConcurrentDel_differentClients()\n+      throws InterruptedException, ExecutionException {\n+    String keyBaseName = \"DELBASE\";\n+\n+    doABunchOfSets(keyBaseName, jedis);\n+\n+    CountDownLatch latch = new CountDownLatch(1);\n+    ExecutorService pool = Executors.newFixedThreadPool(2);\n+    Callable<Integer> callable1 = () -> doABunchOfDels(keyBaseName, 0, jedis, latch);\n+    Callable<Integer> callable2 = () -> doABunchOfDels(keyBaseName, 1, jedis2, latch);\n+    Future<Integer> future1 = pool.submit(callable1);\n+    Future<Integer> future2 = pool.submit(callable2);\n+\n+    latch.countDown();\n+\n+    assertThat(future1.get() + future2.get()).isEqualTo(ITERATION_COUNT);\n+\n+    for (int i = 0; i < ITERATION_COUNT; i++) {\n+      assertThat(jedis.get(keyBaseName + i)).isNull();\n+    }\n+\n+    pool.shutdown();\n+  }\n+\n+  private void doABunchOfSets(String keyBaseName, Jedis jedis) {\n+    for (int i = 0; i < ITERATION_COUNT; i++) {\n+      jedis.set(keyBaseName + i, \"value\" + i);\n+    }\n+  }\n+\n+  private int doABunchOfDels(String keyBaseName, int start, Jedis jedis, CountDownLatch latch)\n+      throws InterruptedException {\n+    int delCount = 0;\n+    latch.await();\n+\n+    for (int i = start; i < ITERATION_COUNT; i += 2) {\n+      delCount += jedis.del(keyBaseName + i);\n+      Thread.yield();\n+    }\n+    return delCount;\n   }\n \n   @Test\n   public void testMSetNX() {\n-    Set<String> strings = new HashSet<String>();\n-    for (int i = 0; i < 2 * 5; i++)\n-      strings.add(randString());\n-    String[] array = strings.toArray(new String[0]);\n-    long response = jedis.msetnx(array);\n+    Set<String> keysAndVals = new HashSet<String>();\n+    for (int i = 0; i < 2 * 5; i++) {\n+      keysAndVals.add(randString());\n+    }\n+    String[] keysAndValsArray = keysAndVals.toArray(new String[0]);\n+    long response = jedis.msetnx(keysAndValsArray);\n+\n+    assertThat(response).isEqualTo(1);\n+\n+    long response2 = jedis.msetnx(keysAndValsArray[0], randString());\n+\n+    assertThat(response2).isEqualTo(0);\n+    assertThat(keysAndValsArray[1]).isEqualTo(jedis.get(keysAndValsArray[0]));\n+  }\n+\n+  @Test\n+  public void testDecr() {\n+    String oneHundredKey = randString();\n+    String negativeOneHundredKey = randString();\n+    String unsetKey = randString();\n+    final int oneHundredValue = 100;\n+    final int negativeOneHundredValue = -100;\n+    jedis.set(oneHundredKey, Integer.toString(oneHundredValue));\n+    jedis.set(negativeOneHundredKey, Integer.toString(negativeOneHundredValue));\n+\n+    jedis.decr(oneHundredKey);\n+    jedis.decr(negativeOneHundredKey);\n+    jedis.decr(unsetKey);\n+\n+    assertThat(jedis.get(oneHundredKey)).isEqualTo(Integer.toString(oneHundredValue - 1));\n+    assertThat(jedis.get(negativeOneHundredKey))\n+        .isEqualTo(Integer.toString(negativeOneHundredValue - 1));\n+    assertThat(jedis.get(unsetKey)).isEqualTo(Integer.toString(-1));\n+  }\n+\n+  @Test\n+  public void testDecr_shouldBeAtomic() throws ExecutionException, InterruptedException {\n+    jedis.set(\"contestedKey\", \"0\");\n+\n+    CountDownLatch latch = new CountDownLatch(1);\n+    ExecutorService pool = Executors.newFixedThreadPool(2);\n+    Callable<Integer> callable1 = () -> doABunchOfDecrs(jedis, latch);\n+    Callable<Integer> callable2 = () -> doABunchOfDecrs(jedis2, latch);\n+    Future<Integer> future1 = pool.submit(callable1);\n+    Future<Integer> future2 = pool.submit(callable2);\n+\n+    latch.countDown();\n+\n+    future1.get();\n+    future2.get();\n+\n+    assertThat(jedis.get(\"contestedKey\")).isEqualTo(Integer.toString(-2 * ITERATION_COUNT));\n+  }\n+\n+  private Integer doABunchOfDecrs(Jedis jedis, CountDownLatch latch) throws InterruptedException {\n+    latch.await();\n+    for (int i = 0; i < ITERATION_COUNT; i++) {\n+      jedis.decr(\"contestedKey\");\n+    }\n+    return ITERATION_COUNT;\n+  }\n+\n+  @Test\n+  public void testIncr() {\n+    String oneHundredKey = randString();\n+    String negativeOneHundredKey = randString();\n+    String unsetKey = randString();\n+    final int oneHundredValue = 100;\n+    final int negativeOneHundredValue = -100;\n+    jedis.set(oneHundredKey, Integer.toString(oneHundredValue));\n+    jedis.set(negativeOneHundredKey, Integer.toString(negativeOneHundredValue));\n+\n+    jedis.incr(oneHundredKey);\n+    jedis.incr(negativeOneHundredKey);\n+    jedis.incr(unsetKey);\n+\n+    assertThat(jedis.get(oneHundredKey)).isEqualTo(Integer.toString(oneHundredValue + 1));\n+    assertThat(jedis.get(negativeOneHundredKey))\n+        .isEqualTo(Integer.toString(negativeOneHundredValue + 1));\n+    assertThat(jedis.get(unsetKey)).isEqualTo(Integer.toString(1));\n+  }\n+\n+  @Test\n+  public void testIncr_whenOverflow_shouldReturnError() {\n+    String key = \"key\";\n+    String max64BitIntegerValue = \"9223372036854775807\";\n+    jedis.set(key, max64BitIntegerValue);\n+\n+    try {\n+      jedis.incr(key);\n+    } catch (JedisDataException e) {\n+      assertThat(e.getMessage()).contains(\"value is not an integer or out of range\");\n+    }\n+    assertThat(jedis.get(key)).isEqualTo(max64BitIntegerValue);\n+  }\n+\n+  @Test\n+  public void testIncr_whenWrongType_shouldReturnError() {\n+    String key = \"key\";\n+    String nonIntegerValue = \"I am not a number! I am a free man!\";\n+    jedis.set(key, nonIntegerValue);\n+\n+    try {\n+      jedis.incr(key);\n+    } catch (JedisDataException e) {\n+      assertThat(e.getMessage()).contains(RedisConstants.ERROR_WRONG_TYPE);\n+    }\n+    assertThat(jedis.get(key)).isEqualTo(nonIntegerValue);\n+  }\n+\n+  @Test\n+  public void testIncr_shouldBeAtomic() throws ExecutionException, InterruptedException {\n+    jedis.set(\"contestedKey\", \"0\");\n+\n+    CountDownLatch latch = new CountDownLatch(1);\n+    ExecutorService pool = Executors.newFixedThreadPool(2);\n+    Callable<Integer> callable1 = () -> doABunchOfIncrs(jedis, latch);\n+    Callable<Integer> callable2 = () -> doABunchOfIncrs(jedis2, latch);\n+    Future<Integer> future1 = pool.submit(callable1);\n+    Future<Integer> future2 = pool.submit(callable2);\n+\n+    latch.countDown();\n+\n+    future1.get();\n+    future2.get();\n \n-    assertTrue(response == 1);\n+    assertThat(jedis.get(\"contestedKey\")).isEqualTo(Integer.toString(2 * ITERATION_COUNT));\n+  }\n+\n+  @Test\n+  // @todo: not looked over for current release", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMxODI1Mw=="}, "originalCommit": {"oid": "8000650443523a0ba2d6f2f0607b8bf9bcd01797"}, "originalPosition": 735}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4388, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}