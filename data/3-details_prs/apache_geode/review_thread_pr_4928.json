{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAwOTUyNDc4", "number": 4928, "reviewThreads": {"totalCount": 95, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxODoxMToxNlrODz23Xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMjowNzozN1rOD7159g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NzAyODc4OnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueue.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxODoxMToxNlrOGIhSAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwNToyODoxOVrOGIzIrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU4NzA3NA==", "bodyText": "This looks similar to the other peekEventsFromIncompleteTransactions, is there a way to reuse the code?  Although the classes probably already do a lot of duplication ...", "url": "https://github.com/apache/geode/pull/4928#discussion_r411587074", "createdAt": "2020-04-20T18:11:16Z", "author": {"login": "jhuynh1"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueue.java", "diffHunk": "@@ -410,6 +441,53 @@ public Object peek() throws CacheException {\n     // so no need to worry about off-heap refCount.\n   }\n \n+  private void peekEventsFromIncompleteTransactions(List<AsyncEvent> batch,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8e5ff0c9c52ca186289fadef1b6170284a82f6f"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg3OTU5Ng==", "bodyText": "You are right, the code is very similar (just as it happens with the peek method) but the structures on which they operate are different:\nOn the SerialGatewaySenderQueue it operates on a set of transactionIds while on the ParallelGatewaySenderQueue it operates on a map of <TransactionId, bucketId>.\nBesides, the difference between the Serial queue and the parallel queue makes it different the access to them. On the parallel you need to pass the bucketId and the partition region. On the serial one, you need to pass the last accessed key so that you do not go through the same elements over and over because those are not removed immediately when peeked from the queue as it happens with the parallel queue.\nAs a consequence I did not find an easy way to reuse code that did not end up making things more complex.", "url": "https://github.com/apache/geode/pull/4928#discussion_r411879596", "createdAt": "2020-04-21T05:28:19Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueue.java", "diffHunk": "@@ -410,6 +441,53 @@ public Object peek() throws CacheException {\n     // so no need to worry about off-heap refCount.\n   }\n \n+  private void peekEventsFromIncompleteTransactions(List<AsyncEvent> batch,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU4NzA3NA=="}, "originalCommit": {"oid": "e8e5ff0c9c52ca186289fadef1b6170284a82f6f"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MzgyMzM5OnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/resources/org/apache/geode/cache/doc-files/cache8_0.dtd", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMDoyMzo1OVrOGNleKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwMDoxOTowOVrOGPwqNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg5ODYwMQ==", "bodyText": "I'm not sure the cache8_0.dtd should be changed. That implies that this property is supported in earlier versions.", "url": "https://github.com/apache/geode/pull/4928#discussion_r416898601", "createdAt": "2020-04-28T20:23:59Z", "author": {"login": "boglesby"}, "path": "geode-core/src/main/resources/org/apache/geode/cache/doc-files/cache8_0.dtd", "diffHunk": "@@ -675,6 +675,7 @@ As of 6.5 roll-oplogs is deprecated. Use disk-store-name instead.\n   alert-threshold              CDATA #IMPLIED\n   dispatcher-threads           CDATA #IMPLIED\n   order-policy                 CDATA #IMPLIED\n+  group-transaction-events     (false | true) #IMPLIED", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdcf0733380d3f8c7e14e0c39f3572a465bbaa9d"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM3MDUxMQ==", "bodyText": "I was not sure of this. I recall seeing some failures in test cases and changed this and the cache7_0.dtd files that had been recently been updated.\nI would appreciate if you can confirm me if these files or any of them should not be updated.", "url": "https://github.com/apache/geode/pull/4928#discussion_r417370511", "createdAt": "2020-04-29T14:42:10Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/main/resources/org/apache/geode/cache/doc-files/cache8_0.dtd", "diffHunk": "@@ -675,6 +675,7 @@ As of 6.5 roll-oplogs is deprecated. Use disk-store-name instead.\n   alert-threshold              CDATA #IMPLIED\n   dispatcher-threads           CDATA #IMPLIED\n   order-policy                 CDATA #IMPLIED\n+  group-transaction-events     (false | true) #IMPLIED", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg5ODYwMQ=="}, "originalCommit": {"oid": "cdcf0733380d3f8c7e14e0c39f3572a465bbaa9d"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY0NjMwMQ==", "bodyText": "I haven't gotten a definitive answer on this. I guess depending on the exceptions you've seen, I wouldn't update it or the 70 one.", "url": "https://github.com/apache/geode/pull/4928#discussion_r417646301", "createdAt": "2020-04-29T22:19:26Z", "author": {"login": "boglesby"}, "path": "geode-core/src/main/resources/org/apache/geode/cache/doc-files/cache8_0.dtd", "diffHunk": "@@ -675,6 +675,7 @@ As of 6.5 roll-oplogs is deprecated. Use disk-store-name instead.\n   alert-threshold              CDATA #IMPLIED\n   dispatcher-threads           CDATA #IMPLIED\n   order-policy                 CDATA #IMPLIED\n+  group-transaction-events     (false | true) #IMPLIED", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg5ODYwMQ=="}, "originalCommit": {"oid": "cdcf0733380d3f8c7e14e0c39f3572a465bbaa9d"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE3OTA2MA==", "bodyText": "I finally figured out that it was not needed to change the dtd files. But I had to change\nCacheXmlGenerator so that the group-transaction-events attribute was not added to the gateway sender in case the cache.xml version was older than Geode 1.0. Without this change, the following test cases were failing:\norg.apache.geode.cache.CacheXml80GatewayDUnitTest > testGatewaySenderWithSubstitutionFilter FAILED\n    org.apache.geode.cache.CacheXmlException: While reading Cache XML file:/tmp/junit10230339244221650502/XML_8_0/CacheXml80GatewayDUnitTest_testGatewaySenderWithSubstitutionFilter.xml. Error while parsing XML, caused by org.xml.sax.SAXParseException; lineNumber: 4; columnNumber: 458; Attribute \"group-transaction-events\" must be declared for element type \"gateway-sender\".\n\norg.apache.geode.cache.CacheXml70GatewayDUnitTest > testParallelGatewaySender FAILED\n    org.apache.geode.cache.CacheXmlException: While reading Cache XML file:/tmp/junit5316048290838435700/XML_7_0/CacheXml70GatewayDUnitTest_testParallelGatewaySender.xml. Error while parsing XML, caused by org.xml.sax.SAXParseException; lineNumber: 4; columnNumber: 422; Attribute \"group-transaction-events\" must be declared for element type \"gateway-sender\".\n\norg.apache.geode.cache.CacheXml70GatewayDUnitTest > testSerialGatewaySender FAILED\n    org.apache.geode.cache.CacheXmlException: While reading Cache XML file:/tmp/junit13002812494872484215/XML_7_0/CacheXml70GatewayDUnitTest_testSerialGatewaySender.xml. Error while parsing XML, caused by org.xml.sax.SAXParseException; lineNumber: 4; columnNumber: 423; Attribute \"group-transaction-events\" must be declared for element type \"gateway-sender\".", "url": "https://github.com/apache/geode/pull/4928#discussion_r419179060", "createdAt": "2020-05-04T00:19:09Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/main/resources/org/apache/geode/cache/doc-files/cache8_0.dtd", "diffHunk": "@@ -675,6 +675,7 @@ As of 6.5 roll-oplogs is deprecated. Use disk-store-name instead.\n   alert-threshold              CDATA #IMPLIED\n   dispatcher-threads           CDATA #IMPLIED\n   order-policy                 CDATA #IMPLIED\n+  group-transaction-events     (false | true) #IMPLIED", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg5ODYwMQ=="}, "originalCommit": {"oid": "cdcf0733380d3f8c7e14e0c39f3572a465bbaa9d"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5Mzg0MDE4OnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueue.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMDoyODoyOVrOGNlofw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNDo0MTowNFrOGOCNuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkwMTI0Nw==", "bodyText": "Maybe maxRetries should be parameterized.", "url": "https://github.com/apache/geode/pull/4928#discussion_r416901247", "createdAt": "2020-04-28T20:28:29Z", "author": {"login": "boglesby"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueue.java", "diffHunk": "@@ -1282,22 +1277,90 @@ public List peek(int batchSize, int timeToWait) throws InterruptedException, Cac\n           Thread.currentThread().interrupt();\n           break;\n         }\n-        continue;\n       }\n     }\n+\n+    if (batch.size() > 0) {\n+      peekEventsFromIncompleteTransactions(batch, incompleteTransactionsInBatch, prQ);\n+    }\n+\n     if (isDebugEnabled) {\n       logger.debug(\"{}: Peeked a batch of {} entries. The size of the queue is {}. localSize is {}\",\n           this, batch.size(), size(), localSize());\n     }\n+\n     if (batch.size() == 0) {\n       blockProcessorThreadIfRequired();\n     }\n     return batch;\n   }\n \n+  private boolean stopPeekingDueToTime(long currentTime, int timeToWait, long end) {\n+    final boolean isDebugEnabled = logger.isDebugEnabled();\n+    // If time to wait is -1 (don't wait) or time interval has elapsed\n+    if (isDebugEnabled) {\n+      logger.debug(\"{}: Peek current time: {}\", this, currentTime);\n+    }\n+    if (timeToWait == -1 || (end <= currentTime)) {\n+      if (isDebugEnabled) {\n+        logger.debug(\"{}: Peek breaking\", this);\n+      }\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  protected boolean isGroupTransactionEvents() {\n+    return sender.isGroupTransactionEvents();\n+  }\n+\n+  private void peekEventsFromIncompleteTransactions(List<GatewaySenderEventImpl> batch,\n+      Map<TransactionId, Integer> incompleteTransactionIdsInBatch, PartitionedRegion prQ) {\n+    if (!isGroupTransactionEvents()) {\n+      return;\n+    }\n+\n+    if (areAllTransactionsCompleteInBatch(incompleteTransactionIdsInBatch)) {\n+      return;\n+    }\n+\n+    int maxRetries = 2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdcf0733380d3f8c7e14e0c39f3572a465bbaa9d"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM2OTUyOQ==", "bodyText": "I agree. The new commit contains a parameter for this.", "url": "https://github.com/apache/geode/pull/4928#discussion_r417369529", "createdAt": "2020-04-29T14:41:04Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueue.java", "diffHunk": "@@ -1282,22 +1277,90 @@ public List peek(int batchSize, int timeToWait) throws InterruptedException, Cac\n           Thread.currentThread().interrupt();\n           break;\n         }\n-        continue;\n       }\n     }\n+\n+    if (batch.size() > 0) {\n+      peekEventsFromIncompleteTransactions(batch, incompleteTransactionsInBatch, prQ);\n+    }\n+\n     if (isDebugEnabled) {\n       logger.debug(\"{}: Peeked a batch of {} entries. The size of the queue is {}. localSize is {}\",\n           this, batch.size(), size(), localSize());\n     }\n+\n     if (batch.size() == 0) {\n       blockProcessorThreadIfRequired();\n     }\n     return batch;\n   }\n \n+  private boolean stopPeekingDueToTime(long currentTime, int timeToWait, long end) {\n+    final boolean isDebugEnabled = logger.isDebugEnabled();\n+    // If time to wait is -1 (don't wait) or time interval has elapsed\n+    if (isDebugEnabled) {\n+      logger.debug(\"{}: Peek current time: {}\", this, currentTime);\n+    }\n+    if (timeToWait == -1 || (end <= currentTime)) {\n+      if (isDebugEnabled) {\n+        logger.debug(\"{}: Peek breaking\", this);\n+      }\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  protected boolean isGroupTransactionEvents() {\n+    return sender.isGroupTransactionEvents();\n+  }\n+\n+  private void peekEventsFromIncompleteTransactions(List<GatewaySenderEventImpl> batch,\n+      Map<TransactionId, Integer> incompleteTransactionIdsInBatch, PartitionedRegion prQ) {\n+    if (!isGroupTransactionEvents()) {\n+      return;\n+    }\n+\n+    if (areAllTransactionsCompleteInBatch(incompleteTransactionIdsInBatch)) {\n+      return;\n+    }\n+\n+    int maxRetries = 2;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkwMTI0Nw=="}, "originalCommit": {"oid": "cdcf0733380d3f8c7e14e0c39f3572a465bbaa9d"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMjQyNDI5OnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/GatewaySenderEventImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNToyMToyOVrOGRuzVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwOTowNjoyNFrOGR1Yiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI0NTc4MQ==", "bodyText": "Since creation of 1.13 release is ongoing, I assume that this will go in 1.14 release. Do we need to update this method to toDataPre_GEODE_1_14_0_0", "url": "https://github.com/apache/geode/pull/4928#discussion_r421245781", "createdAt": "2020-05-07T05:21:29Z", "author": {"login": "mivanac"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/GatewaySenderEventImpl.java", "diffHunk": "@@ -692,6 +704,17 @@ public int getDSFID() {\n   @Override\n   public void toData(DataOutput out,\n       SerializationContext context) throws IOException {\n+    toDataPre_GEODE_1_13_0_0(out, context);\n+    boolean hasTransaction = this.transactionId != null;\n+    DataSerializer.writeBoolean(hasTransaction, out);\n+    if (hasTransaction) {\n+      DataSerializer.writeBoolean(this.isLastEventInTransaction, out);\n+      context.getSerializer().writeObject(this.transactionId, out);\n+    }\n+  }\n+\n+  public void toDataPre_GEODE_1_13_0_0(DataOutput out,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1MzYxMQ==", "bodyText": "You are right, Mario. I guess I can't do that until version 1.13 is available as I would need the constant for 1.14.", "url": "https://github.com/apache/geode/pull/4928#discussion_r421353611", "createdAt": "2020-05-07T09:06:24Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/GatewaySenderEventImpl.java", "diffHunk": "@@ -692,6 +704,17 @@ public int getDSFID() {\n   @Override\n   public void toData(DataOutput out,\n       SerializationContext context) throws IOException {\n+    toDataPre_GEODE_1_13_0_0(out, context);\n+    boolean hasTransaction = this.transactionId != null;\n+    DataSerializer.writeBoolean(hasTransaction, out);\n+    if (hasTransaction) {\n+      DataSerializer.writeBoolean(this.isLastEventInTransaction, out);\n+      context.getSerializer().writeObject(this.transactionId, out);\n+    }\n+  }\n+\n+  public void toDataPre_GEODE_1_13_0_0(DataOutput out,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI0NTc4MQ=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMjQyNjQ4OnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/GatewaySenderEventImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNToyMjo0NlrOGRu0qQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwOTowNjozNlrOGR1Y-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI0NjEyMQ==", "bodyText": "Same comment as above. Do we need to update this method to fromDataPre_GEODE_1_14_0_0?", "url": "https://github.com/apache/geode/pull/4928#discussion_r421246121", "createdAt": "2020-05-07T05:22:46Z", "author": {"login": "mivanac"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/GatewaySenderEventImpl.java", "diffHunk": "@@ -725,6 +748,18 @@ protected void serializeKey(DataOutput out,\n   @Override\n   public void fromData(DataInput in,\n       DeserializationContext context) throws IOException, ClassNotFoundException {\n+    fromDataPre_GEODE_1_13_0_0(in, context);\n+    if (version >= Version.GEODE_1_13_0.ordinal()) {\n+      boolean hasTransaction = DataSerializer.readBoolean(in);\n+      if (hasTransaction) {\n+        this.isLastEventInTransaction = DataSerializer.readBoolean(in);\n+        this.transactionId = context.getDeserializer().readObject(in);\n+      }\n+    }\n+  }\n+\n+  public void fromDataPre_GEODE_1_13_0_0(DataInput in, DeserializationContext context)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1MzcyMw==", "bodyText": "I agree as above.", "url": "https://github.com/apache/geode/pull/4928#discussion_r421353723", "createdAt": "2020-05-07T09:06:36Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/GatewaySenderEventImpl.java", "diffHunk": "@@ -725,6 +748,18 @@ protected void serializeKey(DataOutput out,\n   @Override\n   public void fromData(DataInput in,\n       DeserializationContext context) throws IOException, ClassNotFoundException {\n+    fromDataPre_GEODE_1_13_0_0(in, context);\n+    if (version >= Version.GEODE_1_13_0.ordinal()) {\n+      boolean hasTransaction = DataSerializer.readBoolean(in);\n+      if (hasTransaction) {\n+        this.isLastEventInTransaction = DataSerializer.readBoolean(in);\n+        this.transactionId = context.getDeserializer().readObject(in);\n+      }\n+    }\n+  }\n+\n+  public void fromDataPre_GEODE_1_13_0_0(DataInput in, DeserializationContext context)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI0NjEyMQ=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTE0OTEwOnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/cache/wan/GatewaySender.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODoyNzozMlrOGSvJsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMDozMzoyMVrOGXGkBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwMDA4Mg==", "bodyText": "gemfire_properties.html.md.erb should be updated to include this new property, as well as any other relevant documentation pages.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422300082", "createdAt": "2020-05-08T18:27:32Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/main/java/org/apache/geode/cache/wan/GatewaySender.java", "diffHunk": "@@ -153,6 +155,13 @@\n       .getInteger(GeodeGlossary.GEMFIRE_PREFIX + \"gateway-connection-retry-interval\", 1000)\n       .intValue();\n \n+  /**\n+   * Number of times to retry to get events for a transaction from the gateway sender queue\n+   */\n+  int GET_TRANSACTION_EVENTS_FROM_QUEUE_RETRIES =\n+      Integer.getInteger(GeodeGlossary.GEMFIRE_PREFIX + \"get-transaction-events-from-queue-retries\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg1MTY0OA==", "bodyText": "I did not document this property as I thought it was too internal to be used by clients just as other properties that are not documented. For example: gateway-connection-retry-interval", "url": "https://github.com/apache/geode/pull/4928#discussion_r422851648", "createdAt": "2020-05-11T07:55:19Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/main/java/org/apache/geode/cache/wan/GatewaySender.java", "diffHunk": "@@ -153,6 +155,13 @@\n       .getInteger(GeodeGlossary.GEMFIRE_PREFIX + \"gateway-connection-retry-interval\", 1000)\n       .intValue();\n \n+  /**\n+   * Number of times to retry to get events for a transaction from the gateway sender queue\n+   */\n+  int GET_TRANSACTION_EVENTS_FROM_QUEUE_RETRIES =\n+      Integer.getInteger(GeodeGlossary.GEMFIRE_PREFIX + \"get-transaction-events-from-queue-retries\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwMDA4Mg=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE0NzcwOA==", "bodyText": "Perhaps @davebarnes97 can shed some light here, as he knows docs stuff better than me. Do we want to document any properties added, or are some okay to leave hidden from users?", "url": "https://github.com/apache/geode/pull/4928#discussion_r423147708", "createdAt": "2020-05-11T16:02:20Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/main/java/org/apache/geode/cache/wan/GatewaySender.java", "diffHunk": "@@ -153,6 +155,13 @@\n       .getInteger(GeodeGlossary.GEMFIRE_PREFIX + \"gateway-connection-retry-interval\", 1000)\n       .intValue();\n \n+  /**\n+   * Number of times to retry to get events for a transaction from the gateway sender queue\n+   */\n+  int GET_TRANSACTION_EVENTS_FROM_QUEUE_RETRIES =\n+      Integer.getInteger(GeodeGlossary.GEMFIRE_PREFIX + \"get-transaction-events-from-queue-retries\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwMDA4Mg=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0OTE1MQ==", "bodyText": "Apache Geode is an open-source repo, so nothing is truly hidden from users. However, there are many examples of properties that intentionally go un-mentioned in the User Guide. Such a property should be briefly commented in code, indicating the use for which it is intended and what its limitations are, so curious browsing developers won't get themselves into trouble.", "url": "https://github.com/apache/geode/pull/4928#discussion_r425949151", "createdAt": "2020-05-15T17:34:28Z", "author": {"login": "davebarnes97"}, "path": "geode-core/src/main/java/org/apache/geode/cache/wan/GatewaySender.java", "diffHunk": "@@ -153,6 +155,13 @@\n       .getInteger(GeodeGlossary.GEMFIRE_PREFIX + \"gateway-connection-retry-interval\", 1000)\n       .intValue();\n \n+  /**\n+   * Number of times to retry to get events for a transaction from the gateway sender queue\n+   */\n+  int GET_TRANSACTION_EVENTS_FROM_QUEUE_RETRIES =\n+      Integer.getInteger(GeodeGlossary.GEMFIRE_PREFIX + \"get-transaction-events-from-queue-retries\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwMDA4Mg=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg3Nzk1Ng==", "bodyText": "I\n\nApache Geode is an open-source repo, so nothing is truly hidden from users. However, there are many examples of properties that intentionally go un-mentioned in the User Guide. Such a property should be briefly commented in code, indicating the use for which it is intended and what its limitations are, so curious browsing developers won't get themselves into trouble.\n\nI have added a longer description in the comments for the property in my last commit.", "url": "https://github.com/apache/geode/pull/4928#discussion_r426877956", "createdAt": "2020-05-18T20:33:21Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/main/java/org/apache/geode/cache/wan/GatewaySender.java", "diffHunk": "@@ -153,6 +155,13 @@\n       .getInteger(GeodeGlossary.GEMFIRE_PREFIX + \"gateway-connection-retry-interval\", 1000)\n       .intValue();\n \n+  /**\n+   * Number of times to retry to get events for a transaction from the gateway sender queue\n+   */\n+  int GET_TRANSACTION_EVENTS_FROM_QUEUE_RETRIES =\n+      Integer.getInteger(GeodeGlossary.GEMFIRE_PREFIX + \"get-transaction-events-from-queue-retries\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwMDA4Mg=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTE5Mjk1OnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/InternalRegion.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODo0MTowNFrOGSvkSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQwODoyMTozOFrOGTRu8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwNjg5MQ==", "bodyText": "Per the recent discussion on the dev list regarding the use of default methods in interfaces, does this absolutely need to be default?", "url": "https://github.com/apache/geode/pull/4928#discussion_r422306891", "createdAt": "2020-05-08T18:41:04Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/InternalRegion.java", "diffHunk": "@@ -307,6 +307,11 @@ void cacheWriteBeforePut(EntryEventImpl event, Set netWriteRecipients, CacheWrit\n \n   void invokeTXCallbacks(EnumListenerEvent afterDestroy, EntryEventImpl ee, boolean b);\n \n+  default void invokeTXCallbacks(EnumListenerEvent afterDestroy, EntryEventImpl ee, boolean b,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg2NjY3Mg==", "bodyText": "It is not. I will remove the default implementation.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422866672", "createdAt": "2020-05-11T08:21:38Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/InternalRegion.java", "diffHunk": "@@ -307,6 +307,11 @@ void cacheWriteBeforePut(EntryEventImpl event, Set netWriteRecipients, CacheWrit\n \n   void invokeTXCallbacks(EnumListenerEvent afterDestroy, EntryEventImpl ee, boolean b);\n \n+  default void invokeTXCallbacks(EnumListenerEvent afterDestroy, EntryEventImpl ee, boolean b,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwNjg5MQ=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTQ2NTA3OnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMDoxMTo0NlrOGSyMlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQwODoyMzoxOVrOGTRy5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM0OTk3Mw==", "bodyText": "Unnecessary semicolon here.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422349973", "createdAt": "2020-05-08T20:11:46Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtils.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.ServiceConfigurationError;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.wan.GatewaySender;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class TXLastEventInTransactionUtils {\n+  private static final Logger logger = LogService.getLogger();\n+\n+  /**\n+   * @param callbacks list of events belonging to a transaction\n+   *\n+   * @return the last event of the transaction.\n+   *         If the regions to which the events belong do not have senders\n+   *         that group transactions it returns null.\n+   *         If the regions to which the\n+   *         events belong have different sets of senders that group transactions\n+   *         then it throws a ServiceConfigurationError exception.\n+   */\n+  public static EntryEventImpl getLastTransactionEvent(List<EntryEventImpl> callbacks,\n+      Cache cache)\n+      throws ServiceConfigurationError {\n+    if (checkNoSendersGroupTransactionEvents(callbacks, cache)) {\n+      return null;\n+    }\n+\n+    List<Set> senderIdsPerEvent = getGroupingSendersPerEvent(callbacks, cache);\n+    if (senderIdsPerEvent.stream().distinct().count() > 1) {\n+      String info = eventsAndSendersPerEventToString(callbacks, senderIdsPerEvent);\n+      throw new ServiceConfigurationError(\n+          \"Not all events go to the same senders that group transactions. \" + info);\n+    } ;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg2NzY4Nw==", "bodyText": "Good eye!", "url": "https://github.com/apache/geode/pull/4928#discussion_r422867687", "createdAt": "2020-05-11T08:23:19Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtils.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.ServiceConfigurationError;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.wan.GatewaySender;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class TXLastEventInTransactionUtils {\n+  private static final Logger logger = LogService.getLogger();\n+\n+  /**\n+   * @param callbacks list of events belonging to a transaction\n+   *\n+   * @return the last event of the transaction.\n+   *         If the regions to which the events belong do not have senders\n+   *         that group transactions it returns null.\n+   *         If the regions to which the\n+   *         events belong have different sets of senders that group transactions\n+   *         then it throws a ServiceConfigurationError exception.\n+   */\n+  public static EntryEventImpl getLastTransactionEvent(List<EntryEventImpl> callbacks,\n+      Cache cache)\n+      throws ServiceConfigurationError {\n+    if (checkNoSendersGroupTransactionEvents(callbacks, cache)) {\n+      return null;\n+    }\n+\n+    List<Set> senderIdsPerEvent = getGroupingSendersPerEvent(callbacks, cache);\n+    if (senderIdsPerEvent.stream().distinct().count() > 1) {\n+      String info = eventsAndSendersPerEventToString(callbacks, senderIdsPerEvent);\n+      throw new ServiceConfigurationError(\n+          \"Not all events go to the same senders that group transactions. \" + info);\n+    } ;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM0OTk3Mw=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTUxMjM2OnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/AbstractGatewaySenderEventProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMDoyODoyNFrOGSypnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQwODo0Nzo1N1rOGTStWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM1NzQwNw==", "bodyText": "Could this comment be cleaned up?", "url": "https://github.com/apache/geode/pull/4928#discussion_r422357407", "createdAt": "2020-05-08T20:28:24Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/AbstractGatewaySenderEventProcessor.java", "diffHunk": "@@ -862,14 +868,14 @@ private void logEvents(String message, List<GatewaySenderEventImpl> events) {\n               event.getRawCallbackArgument(), this.sender.getMyDSId(), allRemoteDSIds);\n           event.setCallbackArgument(geCallbackArg);\n           GatewaySenderEventImpl pdxSenderEvent =\n-              new GatewaySenderEventImpl(EnumListenerEvent.AFTER_UPDATE, event, null); // OFFHEAP:\n-                                                                                       // event for\n-                                                                                       // pdx type\n-                                                                                       // meta data\n-                                                                                       // so it\n-                                                                                       // should\n-                                                                                       // never be\n-                                                                                       // off-heap\n+              new GatewaySenderEventImpl(EnumListenerEvent.AFTER_UPDATE, event, null, false); // OFFHEAP:\n+          // event for\n+          // pdx type\n+          // meta data\n+          // so it\n+          // should\n+          // never be\n+          // off-heap", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg4MjY1MQ==", "bodyText": "I have put it in a single line above the instance creation sentence. I cannot tell if the comment is significant so I do not know if it can be removed.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422882651", "createdAt": "2020-05-11T08:47:57Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/AbstractGatewaySenderEventProcessor.java", "diffHunk": "@@ -862,14 +868,14 @@ private void logEvents(String message, List<GatewaySenderEventImpl> events) {\n               event.getRawCallbackArgument(), this.sender.getMyDSId(), allRemoteDSIds);\n           event.setCallbackArgument(geCallbackArg);\n           GatewaySenderEventImpl pdxSenderEvent =\n-              new GatewaySenderEventImpl(EnumListenerEvent.AFTER_UPDATE, event, null); // OFFHEAP:\n-                                                                                       // event for\n-                                                                                       // pdx type\n-                                                                                       // meta data\n-                                                                                       // so it\n-                                                                                       // should\n-                                                                                       // never be\n-                                                                                       // off-heap\n+              new GatewaySenderEventImpl(EnumListenerEvent.AFTER_UPDATE, event, null, false); // OFFHEAP:\n+          // event for\n+          // pdx type\n+          // meta data\n+          // so it\n+          // should\n+          // never be\n+          // off-heap", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM1NzQwNw=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTUzOTUyOnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMDozNzo0OFrOGSy57g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQwODo1Mzo1N1rOGTS8SA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MTU4Mg==", "bodyText": "Is there a reason for the formatting changes to the method signatures in this class? If not, they should be returned to how they were.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422361582", "createdAt": "2020-05-08T20:37:48Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -373,7 +373,8 @@ public static Integer createSecondRemoteLocator(int dsId, int localPort, int rem\n   }\n \n   public static Integer createSecondRemoteLocatorWithAPI(int dsId, int localPort, int remoteLocPort,\n-      String hostnameForClients) throws IOException {\n+      String hostnameForClients)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg4NjQ3Mg==", "bodyText": "No reason. I did it by mistake. I have reverted the changes.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422886472", "createdAt": "2020-05-11T08:53:57Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -373,7 +373,8 @@ public static Integer createSecondRemoteLocator(int dsId, int localPort, int rem\n   }\n \n   public static Integer createSecondRemoteLocatorWithAPI(int dsId, int localPort, int remoteLocPort,\n-      String hostnameForClients) throws IOException {\n+      String hostnameForClients)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MTU4Mg=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTU0MTk4OnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMDozODozMlrOGSy7XA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMjo0MzozM1rOGTakeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MTk0OA==", "bodyText": "Another possibly unnecessary formatting change.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422361948", "createdAt": "2020-05-08T20:38:32Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -497,7 +498,8 @@ public static void createPersistentReplicatedRegion(String regionName, String se\n   }\n \n   public static void createReplicatedRegionWithAsyncEventQueue(String regionName,\n-      String asyncQueueIds, Boolean offHeap) {\n+      String asyncQueueIds,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMTQ1MA==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423011450", "createdAt": "2020-05-11T12:43:33Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -497,7 +498,8 @@ public static void createPersistentReplicatedRegion(String regionName, String se\n   }\n \n   public static void createReplicatedRegionWithAsyncEventQueue(String regionName,\n-      String asyncQueueIds, Boolean offHeap) {\n+      String asyncQueueIds,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MTk0OA=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTU0MjE1OnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMDozODozN1rOGSy7eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMjo0Mzo0MlrOGTakzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MTk3OA==", "bodyText": "Another possibly unnecessary formatting change.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422361978", "createdAt": "2020-05-08T20:38:37Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -519,7 +521,9 @@ public static void createReplicatedRegionWithAsyncEventQueue(String regionName,\n   }\n \n   public static void createReplicatedRegionWithSenderAndAsyncEventQueue(String regionName,\n-      String senderIds, String asyncChannelId, Boolean offHeap) {\n+      String senderIds,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMTUzNA==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423011534", "createdAt": "2020-05-11T12:43:42Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -519,7 +521,9 @@ public static void createReplicatedRegionWithAsyncEventQueue(String regionName,\n   }\n \n   public static void createReplicatedRegionWithSenderAndAsyncEventQueue(String regionName,\n-      String senderIds, String asyncChannelId, Boolean offHeap) {\n+      String senderIds,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MTk3OA=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTU0MjM2OnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMDozODo0MVrOGSy7nA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMjo0Mzo1MFrOGTalHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjAxMg==", "bodyText": "Another possibly unnecessary formatting change.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422362012", "createdAt": "2020-05-08T20:38:41Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -560,7 +564,8 @@ public static void createReplicatedRegion(String regionName, String senderIds, S\n   }\n \n   public static void createAsyncEventQueue(String asyncChannelId, boolean isParallel,\n-      Integer maxMemory, Integer batchSize, boolean isConflation, boolean isPersistent,\n+      Integer maxMemory, Integer batchSize,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMTYxNA==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423011614", "createdAt": "2020-05-11T12:43:50Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -560,7 +564,8 @@ public static void createReplicatedRegion(String regionName, String senderIds, S\n   }\n \n   public static void createAsyncEventQueue(String asyncChannelId, boolean isParallel,\n-      Integer maxMemory, Integer batchSize, boolean isConflation, boolean isPersistent,\n+      Integer maxMemory, Integer batchSize,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjAxMg=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTU0MjY5OnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMDozODo0NlrOGSy7yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMjo0Mzo1OFrOGTalYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjA1OA==", "bodyText": "Another possibly unnecessary formatting change.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422362058", "createdAt": "2020-05-08T20:38:46Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -589,7 +594,8 @@ public static void createAsyncEventQueue(String asyncChannelId, boolean isParall\n   }\n \n   public static void createPartitionedRegion(String regionName, String senderIds,\n-      Integer redundantCopies, Integer totalNumBuckets, Boolean offHeap) {\n+      Integer redundantCopies, Integer totalNumBuckets,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMTY4Mg==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423011682", "createdAt": "2020-05-11T12:43:58Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -589,7 +594,8 @@ public static void createAsyncEventQueue(String asyncChannelId, boolean isParall\n   }\n \n   public static void createPartitionedRegion(String regionName, String senderIds,\n-      Integer redundantCopies, Integer totalNumBuckets, Boolean offHeap) {\n+      Integer redundantCopies, Integer totalNumBuckets,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjA1OA=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTU0Mjk2OnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMDozODo1MVrOGSy78A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMjo0NDowNVrOGTaloQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjA5Ng==", "bodyText": "Another possibly unnecessary formatting change.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422362096", "createdAt": "2020-05-08T20:38:51Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -619,7 +625,8 @@ public static void createPartitionedRegion(String regionName, String senderIds,\n \n   // TODO:OFFHEAP: add offheap flavor\n   public static void createPartitionedRegionWithPersistence(String regionName, String senderIds,\n-      Integer redundantCopies, Integer totalNumBuckets) {\n+      Integer redundantCopies,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMTc0NQ==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423011745", "createdAt": "2020-05-11T12:44:05Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -619,7 +625,8 @@ public static void createPartitionedRegion(String regionName, String senderIds,\n \n   // TODO:OFFHEAP: add offheap flavor\n   public static void createPartitionedRegionWithPersistence(String regionName, String senderIds,\n-      Integer redundantCopies, Integer totalNumBuckets) {\n+      Integer redundantCopies,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjA5Ng=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTU0MzE4OnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMDozODo1NVrOGSy8Ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMjo0NDoxN1rOGTamBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjEzMQ==", "bodyText": "Another possibly unnecessary formatting change.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422362131", "createdAt": "2020-05-08T20:38:55Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -647,7 +654,9 @@ public static void createPartitionedRegionWithPersistence(String regionName, Str\n   }\n \n   public static void createColocatedPartitionedRegion(String regionName, String senderIds,\n-      Integer redundantCopies, Integer totalNumBuckets, String colocatedWith) {\n+      Integer redundantCopies,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMTg0Ng==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423011846", "createdAt": "2020-05-11T12:44:17Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -647,7 +654,9 @@ public static void createPartitionedRegionWithPersistence(String regionName, Str\n   }\n \n   public static void createColocatedPartitionedRegion(String regionName, String senderIds,\n-      Integer redundantCopies, Integer totalNumBuckets, String colocatedWith) {\n+      Integer redundantCopies,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjEzMQ=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTU0MzUyOnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMDozOTowMVrOGSy8Tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMjo0NDoyMlrOGTamNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjE5MA==", "bodyText": "Another possibly unnecessary formatting change.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422362190", "createdAt": "2020-05-08T20:39:01Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -691,7 +700,8 @@ public static void addAsyncEventQueueThroughAttributesMutator(String regionName,\n   }\n \n   public static void createPartitionedRegionAsAccessor(String regionName, String senderIds,\n-      Integer redundantCopies, Integer totalNumBuckets) {\n+      Integer redundantCopies,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMTg5NQ==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423011895", "createdAt": "2020-05-11T12:44:22Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -691,7 +700,8 @@ public static void addAsyncEventQueueThroughAttributesMutator(String regionName,\n   }\n \n   public static void createPartitionedRegionAsAccessor(String regionName, String senderIds,\n-      Integer redundantCopies, Integer totalNumBuckets) {\n+      Integer redundantCopies,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjE5MA=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTU0Mzc4OnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMDozOTowNlrOGSy8dQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMjo0NDoyOVrOGTamcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjIyOQ==", "bodyText": "Another possibly unnecessary formatting change.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422362229", "createdAt": "2020-05-08T20:39:06Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -709,7 +719,10 @@ public static void createPartitionedRegionAsAccessor(String regionName, String s\n   }\n \n   public static void createPartitionedRegionWithSerialParallelSenderIds(String regionName,\n-      String serialSenderIds, String parallelSenderIds, String colocatedWith, Boolean offHeap) {\n+      String serialSenderIds,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMTk1NQ==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423011955", "createdAt": "2020-05-11T12:44:29Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -709,7 +719,10 @@ public static void createPartitionedRegionAsAccessor(String regionName, String s\n   }\n \n   public static void createPartitionedRegionWithSerialParallelSenderIds(String regionName,\n-      String serialSenderIds, String parallelSenderIds, String colocatedWith, Boolean offHeap) {\n+      String serialSenderIds,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjIyOQ=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTU0MzkxOnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMDozOToxMVrOGSy8jQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMjo0NDozNFrOGTamug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjI1Mw==", "bodyText": "Another possibly unnecessary formatting change.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422362253", "createdAt": "2020-05-08T20:39:11Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -734,7 +747,8 @@ public static void createPartitionedRegionWithSerialParallelSenderIds(String reg\n   }\n \n   public static void createPersistentPartitionedRegion(String regionName, String senderIds,\n-      Integer redundantCopies, Integer totalNumBuckets, Boolean offHeap) {\n+      Integer redundantCopies,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMjAyNg==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423012026", "createdAt": "2020-05-11T12:44:34Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -734,7 +747,8 @@ public static void createPartitionedRegionWithSerialParallelSenderIds(String reg\n   }\n \n   public static void createPersistentPartitionedRegion(String regionName, String senderIds,\n-      Integer redundantCopies, Integer totalNumBuckets, Boolean offHeap) {\n+      Integer redundantCopies,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjI1Mw=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTU0NDA5OnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMDozOToxN1rOGSy8rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMjo0NDo0MFrOGTam7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjI4Ng==", "bodyText": "Another possibly unnecessary formatting change.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422362286", "createdAt": "2020-05-08T20:39:17Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -764,7 +778,9 @@ public static void createPersistentPartitionedRegion(String regionName, String s\n   }\n \n   public static void createCustomerOrderShipmentPartitionedRegion(String senderIds,\n-      Integer redundantCopies, Integer totalNumBuckets, Boolean offHeap) {\n+      Integer redundantCopies,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMjA3OQ==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423012079", "createdAt": "2020-05-11T12:44:40Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -764,7 +778,9 @@ public static void createPersistentPartitionedRegion(String regionName, String s\n   }\n \n   public static void createCustomerOrderShipmentPartitionedRegion(String senderIds,\n-      Integer redundantCopies, Integer totalNumBuckets, Boolean offHeap) {\n+      Integer redundantCopies,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjI4Ng=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTU0NDczOnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMDozOToyOVrOGSy9CA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMjo0NDo0NlrOGTanJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjM3Ng==", "bodyText": "Another possibly unnecessary formatting change.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422362376", "createdAt": "2020-05-08T20:39:29Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -830,7 +846,8 @@ public static void createCustomerOrderShipmentPartitionedRegion(String senderIds\n   }\n \n   public static void createColocatedPartitionedRegions(String regionName, String senderIds,\n-      Integer redundantCopies, Integer totalNumBuckets, Boolean offHeap) {\n+      Integer redundantCopies,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMjEzMg==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423012132", "createdAt": "2020-05-11T12:44:46Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -830,7 +846,8 @@ public static void createCustomerOrderShipmentPartitionedRegion(String senderIds\n   }\n \n   public static void createColocatedPartitionedRegions(String regionName, String senderIds,\n-      Integer redundantCopies, Integer totalNumBuckets, Boolean offHeap) {\n+      Integer redundantCopies,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjM3Ng=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTU0NDc1OnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMDozOTozMFrOGSy9Cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMjo0NDo1MFrOGTanTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjM3OQ==", "bodyText": "Another possibly unnecessary formatting change.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422362379", "createdAt": "2020-05-08T20:39:30Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -858,7 +875,8 @@ public static void createColocatedPartitionedRegions(String regionName, String s\n   }\n \n   public static void createColocatedPartitionedRegions2(String regionName, String senderIds,\n-      Integer redundantCopies, Integer totalNumBuckets, Boolean offHeap) {\n+      Integer redundantCopies,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMjE3Mg==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423012172", "createdAt": "2020-05-11T12:44:50Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -858,7 +875,8 @@ public static void createColocatedPartitionedRegions(String regionName, String s\n   }\n \n   public static void createColocatedPartitionedRegions2(String regionName, String senderIds,\n-      Integer redundantCopies, Integer totalNumBuckets, Boolean offHeap) {\n+      Integer redundantCopies,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjM3OQ=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTc3MDM0OnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueue.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMjowMjoyN1rOGS1BvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMjo0OToxMlrOGTaxDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM5NjM0OA==", "bodyText": "The currentTime argument can be removed and replaced with a call to System.currentTimeMillis() inside the method.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422396348", "createdAt": "2020-05-08T22:02:27Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueue.java", "diffHunk": "@@ -1282,22 +1278,89 @@ public List peek(int batchSize, int timeToWait) throws InterruptedException, Cac\n           Thread.currentThread().interrupt();\n           break;\n         }\n-        continue;\n       }\n     }\n+\n+    if (batch.size() > 0) {\n+      peekEventsFromIncompleteTransactions(batch, incompleteTransactionsInBatch, prQ);\n+    }\n+\n     if (isDebugEnabled) {\n       logger.debug(\"{}: Peeked a batch of {} entries. The size of the queue is {}. localSize is {}\",\n           this, batch.size(), size(), localSize());\n     }\n+\n     if (batch.size() == 0) {\n       blockProcessorThreadIfRequired();\n     }\n     return batch;\n   }\n \n+  private boolean stopPeekingDueToTime(long currentTime, int timeToWait, long end) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxNDY3MA==", "bodyText": "Good point", "url": "https://github.com/apache/geode/pull/4928#discussion_r423014670", "createdAt": "2020-05-11T12:49:12Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueue.java", "diffHunk": "@@ -1282,22 +1278,89 @@ public List peek(int batchSize, int timeToWait) throws InterruptedException, Cac\n           Thread.currentThread().interrupt();\n           break;\n         }\n-        continue;\n       }\n     }\n+\n+    if (batch.size() > 0) {\n+      peekEventsFromIncompleteTransactions(batch, incompleteTransactionsInBatch, prQ);\n+    }\n+\n     if (isDebugEnabled) {\n       logger.debug(\"{}: Peeked a batch of {} entries. The size of the queue is {}. localSize is {}\",\n           this, batch.size(), size(), localSize());\n     }\n+\n     if (batch.size() == 0) {\n       blockProcessorThreadIfRequired();\n     }\n     return batch;\n   }\n \n+  private boolean stopPeekingDueToTime(long currentTime, int timeToWait, long end) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM5NjM0OA=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTc4ODMzOnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueue.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMjoxMjowMlrOGS1M1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjoyNTo1OVrOGTj0XA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM5OTE5MA==", "bodyText": "A more descriptive name for this variable might be lastEventIsPresentInTransaction.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422399190", "createdAt": "2020-05-08T22:12:02Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueue.java", "diffHunk": "@@ -1282,22 +1278,89 @@ public List peek(int batchSize, int timeToWait) throws InterruptedException, Cac\n           Thread.currentThread().interrupt();\n           break;\n         }\n-        continue;\n       }\n     }\n+\n+    if (batch.size() > 0) {\n+      peekEventsFromIncompleteTransactions(batch, incompleteTransactionsInBatch, prQ);\n+    }\n+\n     if (isDebugEnabled) {\n       logger.debug(\"{}: Peeked a batch of {} entries. The size of the queue is {}. localSize is {}\",\n           this, batch.size(), size(), localSize());\n     }\n+\n     if (batch.size() == 0) {\n       blockProcessorThreadIfRequired();\n     }\n     return batch;\n   }\n \n+  private boolean stopPeekingDueToTime(long currentTime, int timeToWait, long end) {\n+    final boolean isDebugEnabled = logger.isDebugEnabled();\n+    // If time to wait is -1 (don't wait) or time interval has elapsed\n+    if (isDebugEnabled) {\n+      logger.debug(\"{}: Peek current time: {}\", this, currentTime);\n+    }\n+    if (timeToWait == -1 || (end <= currentTime)) {\n+      if (isDebugEnabled) {\n+        logger.debug(\"{}: Peek breaking\", this);\n+      }\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  protected boolean isGroupTransactionEvents() {\n+    return sender.isGroupTransactionEvents();\n+  }\n+\n+  private void peekEventsFromIncompleteTransactions(List<GatewaySenderEventImpl> batch,\n+      Map<TransactionId, Integer> incompleteTransactionIdsInBatch, PartitionedRegion prQ) {\n+    if (!isGroupTransactionEvents()) {\n+      return;\n+    }\n+\n+    if (areAllTransactionsCompleteInBatch(incompleteTransactionIdsInBatch)) {\n+      return;\n+    }\n+\n+    for (Map.Entry<TransactionId, Integer> pendingTransaction : incompleteTransactionIdsInBatch\n+        .entrySet()) {\n+      TransactionId transactionId = pendingTransaction.getKey();\n+      int bucketId = pendingTransaction.getValue();\n+      boolean presentLastEventInTransaction = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAyMjIwNw==", "bodyText": "How about areAllEventsForTransactionInBatch?", "url": "https://github.com/apache/geode/pull/4928#discussion_r423022207", "createdAt": "2020-05-11T13:02:32Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueue.java", "diffHunk": "@@ -1282,22 +1278,89 @@ public List peek(int batchSize, int timeToWait) throws InterruptedException, Cac\n           Thread.currentThread().interrupt();\n           break;\n         }\n-        continue;\n       }\n     }\n+\n+    if (batch.size() > 0) {\n+      peekEventsFromIncompleteTransactions(batch, incompleteTransactionsInBatch, prQ);\n+    }\n+\n     if (isDebugEnabled) {\n       logger.debug(\"{}: Peeked a batch of {} entries. The size of the queue is {}. localSize is {}\",\n           this, batch.size(), size(), localSize());\n     }\n+\n     if (batch.size() == 0) {\n       blockProcessorThreadIfRequired();\n     }\n     return batch;\n   }\n \n+  private boolean stopPeekingDueToTime(long currentTime, int timeToWait, long end) {\n+    final boolean isDebugEnabled = logger.isDebugEnabled();\n+    // If time to wait is -1 (don't wait) or time interval has elapsed\n+    if (isDebugEnabled) {\n+      logger.debug(\"{}: Peek current time: {}\", this, currentTime);\n+    }\n+    if (timeToWait == -1 || (end <= currentTime)) {\n+      if (isDebugEnabled) {\n+        logger.debug(\"{}: Peek breaking\", this);\n+      }\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  protected boolean isGroupTransactionEvents() {\n+    return sender.isGroupTransactionEvents();\n+  }\n+\n+  private void peekEventsFromIncompleteTransactions(List<GatewaySenderEventImpl> batch,\n+      Map<TransactionId, Integer> incompleteTransactionIdsInBatch, PartitionedRegion prQ) {\n+    if (!isGroupTransactionEvents()) {\n+      return;\n+    }\n+\n+    if (areAllTransactionsCompleteInBatch(incompleteTransactionIdsInBatch)) {\n+      return;\n+    }\n+\n+    for (Map.Entry<TransactionId, Integer> pendingTransaction : incompleteTransactionIdsInBatch\n+        .entrySet()) {\n+      TransactionId transactionId = pendingTransaction.getKey();\n+      int bucketId = pendingTransaction.getValue();\n+      boolean presentLastEventInTransaction = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM5OTE5MA=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE2Mjk3Mg==", "bodyText": "That sounds good, yeah.", "url": "https://github.com/apache/geode/pull/4928#discussion_r423162972", "createdAt": "2020-05-11T16:25:59Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueue.java", "diffHunk": "@@ -1282,22 +1278,89 @@ public List peek(int batchSize, int timeToWait) throws InterruptedException, Cac\n           Thread.currentThread().interrupt();\n           break;\n         }\n-        continue;\n       }\n     }\n+\n+    if (batch.size() > 0) {\n+      peekEventsFromIncompleteTransactions(batch, incompleteTransactionsInBatch, prQ);\n+    }\n+\n     if (isDebugEnabled) {\n       logger.debug(\"{}: Peeked a batch of {} entries. The size of the queue is {}. localSize is {}\",\n           this, batch.size(), size(), localSize());\n     }\n+\n     if (batch.size() == 0) {\n       blockProcessorThreadIfRequired();\n     }\n     return batch;\n   }\n \n+  private boolean stopPeekingDueToTime(long currentTime, int timeToWait, long end) {\n+    final boolean isDebugEnabled = logger.isDebugEnabled();\n+    // If time to wait is -1 (don't wait) or time interval has elapsed\n+    if (isDebugEnabled) {\n+      logger.debug(\"{}: Peek current time: {}\", this, currentTime);\n+    }\n+    if (timeToWait == -1 || (end <= currentTime)) {\n+      if (isDebugEnabled) {\n+        logger.debug(\"{}: Peek breaking\", this);\n+      }\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  protected boolean isGroupTransactionEvents() {\n+    return sender.isGroupTransactionEvents();\n+  }\n+\n+  private void peekEventsFromIncompleteTransactions(List<GatewaySenderEventImpl> batch,\n+      Map<TransactionId, Integer> incompleteTransactionIdsInBatch, PartitionedRegion prQ) {\n+    if (!isGroupTransactionEvents()) {\n+      return;\n+    }\n+\n+    if (areAllTransactionsCompleteInBatch(incompleteTransactionIdsInBatch)) {\n+      return;\n+    }\n+\n+    for (Map.Entry<TransactionId, Integer> pendingTransaction : incompleteTransactionIdsInBatch\n+        .entrySet()) {\n+      TransactionId transactionId = pendingTransaction.getKey();\n+      int bucketId = pendingTransaction.getValue();\n+      boolean presentLastEventInTransaction = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM5OTE5MA=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTgyMTA4OnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueue.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMjoyODoyNlrOGS1f8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjoyNjoxMVrOGTj06w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwNDA4MQ==", "bodyText": "A more descriptive name for this variable might be lastEventIsPresentInTransaction.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422404081", "createdAt": "2020-05-08T22:28:26Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueue.java", "diffHunk": "@@ -410,6 +442,53 @@ public Object peek() throws CacheException {\n     // so no need to worry about off-heap refCount.\n   }\n \n+  private void peekEventsFromIncompleteTransactions(List<AsyncEvent> batch,\n+      Set<TransactionId> incompleteTransactionIdsInBatch, long lastKey) {\n+    if (!isGroupTransactionEvents()) {\n+      return;\n+    }\n+\n+    if (areAllTransactionsCompleteInBatch(incompleteTransactionIdsInBatch)) {\n+      return;\n+    }\n+\n+    for (TransactionId transactionId : incompleteTransactionIdsInBatch) {\n+      boolean presentLastEventInTransaction = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAyMzQ5NQ==", "bodyText": "How about areAllEventsForTransactionInBatch?", "url": "https://github.com/apache/geode/pull/4928#discussion_r423023495", "createdAt": "2020-05-11T13:04:43Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueue.java", "diffHunk": "@@ -410,6 +442,53 @@ public Object peek() throws CacheException {\n     // so no need to worry about off-heap refCount.\n   }\n \n+  private void peekEventsFromIncompleteTransactions(List<AsyncEvent> batch,\n+      Set<TransactionId> incompleteTransactionIdsInBatch, long lastKey) {\n+    if (!isGroupTransactionEvents()) {\n+      return;\n+    }\n+\n+    if (areAllTransactionsCompleteInBatch(incompleteTransactionIdsInBatch)) {\n+      return;\n+    }\n+\n+    for (TransactionId transactionId : incompleteTransactionIdsInBatch) {\n+      boolean presentLastEventInTransaction = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwNDA4MQ=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE2MzExNQ==", "bodyText": "Sounds good.", "url": "https://github.com/apache/geode/pull/4928#discussion_r423163115", "createdAt": "2020-05-11T16:26:11Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueue.java", "diffHunk": "@@ -410,6 +442,53 @@ public Object peek() throws CacheException {\n     // so no need to worry about off-heap refCount.\n   }\n \n+  private void peekEventsFromIncompleteTransactions(List<AsyncEvent> batch,\n+      Set<TransactionId> incompleteTransactionIdsInBatch, long lastKey) {\n+    if (!isGroupTransactionEvents()) {\n+      return;\n+    }\n+\n+    if (areAllTransactionsCompleteInBatch(incompleteTransactionIdsInBatch)) {\n+      return;\n+    }\n+\n+    for (TransactionId transactionId : incompleteTransactionIdsInBatch) {\n+      boolean presentLastEventInTransaction = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwNDA4MQ=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTgzMjcxOnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/BucketRegionQueueJUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMjozNDoxOFrOGS1mwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMzowNzozOFrOGTbaiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwNTgyNA==", "bodyText": "This try/catch shouldn't be necessary, I think. The test will automatically fail if an exception is thrown. The exception should instead be added to the test method signature.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422405824", "createdAt": "2020-05-08T22:34:18Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/BucketRegionQueueJUnitTest.java", "diffHunk": "@@ -120,4 +137,69 @@ public void testBasicDestroyConflationEnabledAndValueNotInRegion() {\n     // Invoke basicDestroy\n     this.bucketRegionQueue.basicDestroy(event, true, null, false);\n   }\n+\n+  @Test\n+  public void testGetElementsMatching() {\n+    ParallelGatewaySenderEventProcessor processor =\n+        ParallelGatewaySenderHelper.createParallelGatewaySenderEventProcessor(this.sender);\n+\n+    TransactionId tx1 = new TXId(null, 1);\n+    TransactionId tx2 = new TXId(null, 2);\n+    TransactionId tx3 = new TXId(null, 3);\n+\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEvent(1, tx1, false);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEvent(2, tx2, false);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEvent(3, tx1, true);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEvent(4, tx2, true);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEvent(5, tx3, false);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEvent(6, tx3, false);\n+    GatewaySenderEventImpl event7 = createMockGatewaySenderEvent(7, tx1, true);\n+\n+    this.bucketRegionQueue\n+        .cleanUpDestroyedTokensAndMarkGIIComplete(InitialImageOperation.GIIStatus.NO_GII);\n+\n+    try {\n+      this.bucketRegionQueue.addToQueue(Long.valueOf(1), event1);\n+      this.bucketRegionQueue.addToQueue(Long.valueOf(2), event2);\n+      this.bucketRegionQueue.addToQueue(Long.valueOf(3), event3);\n+      this.bucketRegionQueue.addToQueue(Long.valueOf(4), event4);\n+      this.bucketRegionQueue.addToQueue(Long.valueOf(5), event5);\n+      this.bucketRegionQueue.addToQueue(Long.valueOf(6), event6);\n+      this.bucketRegionQueue.addToQueue(Long.valueOf(7), event7);\n+\n+    } catch (ForceReattemptException e) {\n+      fail(\"Exception thrown: \" + e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAyNTI5MQ==", "bodyText": "I agree", "url": "https://github.com/apache/geode/pull/4928#discussion_r423025291", "createdAt": "2020-05-11T13:07:38Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/BucketRegionQueueJUnitTest.java", "diffHunk": "@@ -120,4 +137,69 @@ public void testBasicDestroyConflationEnabledAndValueNotInRegion() {\n     // Invoke basicDestroy\n     this.bucketRegionQueue.basicDestroy(event, true, null, false);\n   }\n+\n+  @Test\n+  public void testGetElementsMatching() {\n+    ParallelGatewaySenderEventProcessor processor =\n+        ParallelGatewaySenderHelper.createParallelGatewaySenderEventProcessor(this.sender);\n+\n+    TransactionId tx1 = new TXId(null, 1);\n+    TransactionId tx2 = new TXId(null, 2);\n+    TransactionId tx3 = new TXId(null, 3);\n+\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEvent(1, tx1, false);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEvent(2, tx2, false);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEvent(3, tx1, true);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEvent(4, tx2, true);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEvent(5, tx3, false);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEvent(6, tx3, false);\n+    GatewaySenderEventImpl event7 = createMockGatewaySenderEvent(7, tx1, true);\n+\n+    this.bucketRegionQueue\n+        .cleanUpDestroyedTokensAndMarkGIIComplete(InitialImageOperation.GIIStatus.NO_GII);\n+\n+    try {\n+      this.bucketRegionQueue.addToQueue(Long.valueOf(1), event1);\n+      this.bucketRegionQueue.addToQueue(Long.valueOf(2), event2);\n+      this.bucketRegionQueue.addToQueue(Long.valueOf(3), event3);\n+      this.bucketRegionQueue.addToQueue(Long.valueOf(4), event4);\n+      this.bucketRegionQueue.addToQueue(Long.valueOf(5), event5);\n+      this.bucketRegionQueue.addToQueue(Long.valueOf(6), event6);\n+      this.bucketRegionQueue.addToQueue(Long.valueOf(7), event7);\n+\n+    } catch (ForceReattemptException e) {\n+      fail(\"Exception thrown: \" + e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwNTgyNA=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTg0NDExOnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/BucketRegionQueueJUnitTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMjo0MDo0OVrOGS1tkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjoyNjo0MlrOGTj2JA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwNzU3MA==", "bodyText": "Can this test have a more descriptive name? Test names should ideally describe what is being tested, what the conditions are, and what the expected result is.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422407570", "createdAt": "2020-05-08T22:40:49Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/BucketRegionQueueJUnitTest.java", "diffHunk": "@@ -120,4 +137,69 @@ public void testBasicDestroyConflationEnabledAndValueNotInRegion() {\n     // Invoke basicDestroy\n     this.bucketRegionQueue.basicDestroy(event, true, null, false);\n   }\n+\n+  @Test\n+  public void testGetElementsMatching() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAzODMyMg==", "bodyText": "How about testGetElementsMatchingWithHasTransactionIdPredicateAndIsLastEventInTransactionPredicate?\nThe test is testing a generic method getElementsMatching using two predicates.", "url": "https://github.com/apache/geode/pull/4928#discussion_r423038322", "createdAt": "2020-05-11T13:27:53Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/BucketRegionQueueJUnitTest.java", "diffHunk": "@@ -120,4 +137,69 @@ public void testBasicDestroyConflationEnabledAndValueNotInRegion() {\n     // Invoke basicDestroy\n     this.bucketRegionQueue.basicDestroy(event, true, null, false);\n   }\n+\n+  @Test\n+  public void testGetElementsMatching() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwNzU3MA=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE2MzQyOA==", "bodyText": "That works for me", "url": "https://github.com/apache/geode/pull/4928#discussion_r423163428", "createdAt": "2020-05-11T16:26:42Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/BucketRegionQueueJUnitTest.java", "diffHunk": "@@ -120,4 +137,69 @@ public void testBasicDestroyConflationEnabledAndValueNotInRegion() {\n     // Invoke basicDestroy\n     this.bucketRegionQueue.basicDestroy(event, true, null, false);\n   }\n+\n+  @Test\n+  public void testGetElementsMatching() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwNzU3MA=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTg0NTc1OnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMjo0MTo0OVrOGS1ugw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjo1MTo0NVrOGTkyUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwNzgxMQ==", "bodyText": "This test name could be more descriptive. Also, an exception is never thrown from this method, so the throws can be removed.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422407811", "createdAt": "2020-05-08T22:41:49Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.AssertionsForClassTypes.assertThatThrownBy;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ServiceConfigurationError;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.wan.GatewaySender;\n+\n+public class TXLastEventInTransactionUtilsTest {\n+\n+  public static final String SENDER_1 = \"sender1\";\n+  public static final String SENDER_2 = \"sender2\";\n+  public static final String SENDER_3 = \"sender3\";\n+  public static final String SENDER_4 = \"sender4\";\n+  public static final String SENDER_5 = \"sender5\";\n+\n+  Cache cache;\n+  InternalRegion region1;\n+  InternalRegion region2;\n+  InternalRegion region3;\n+  InternalRegion region4;\n+  InternalRegion region5;\n+  InternalRegion region6;\n+  InternalRegion region7;\n+  InternalRegion region8;\n+\n+  GatewaySender sender1;\n+  GatewaySender sender2;\n+  GatewaySender sender3;\n+  GatewaySender sender4;\n+\n+  @Before\n+  public void setUp() {\n+    sender1 = mock(GatewaySender.class);\n+    when(sender1.isGroupTransactionEvents()).thenReturn(false);\n+    sender2 = mock(GatewaySender.class);\n+    when(sender2.isGroupTransactionEvents()).thenReturn(false);\n+    sender3 = mock(GatewaySender.class);\n+    when(sender3.isGroupTransactionEvents()).thenReturn(true);\n+    sender4 = mock(GatewaySender.class);\n+    when(sender4.isGroupTransactionEvents()).thenReturn(true);\n+\n+    cache = mock(Cache.class);\n+    when(cache.getGatewaySender(SENDER_1)).thenReturn(sender1);\n+    when(cache.getGatewaySender(SENDER_2)).thenReturn(sender2);\n+    when(cache.getGatewaySender(SENDER_3)).thenReturn(sender3);\n+    when(cache.getGatewaySender(SENDER_4)).thenReturn(sender4);\n+    when(cache.getGatewaySender(SENDER_5)).thenReturn(null);\n+\n+    final String listSenderIdsForRegion1_2[] = {SENDER_1, SENDER_2};\n+    final String listSenderIdsForRegion3_4[] = {SENDER_3, SENDER_4};\n+    final String listSenderIdsForRegion5_6[] = {SENDER_1, SENDER_3};\n+    final String listSenderIdsForRegion7[] = {SENDER_3};\n+    final String listSenderIdsForRegion8[] = {SENDER_5};\n+\n+\n+    Set senderIdsForRegion1_2 = new HashSet(Arrays.asList(listSenderIdsForRegion1_2));\n+    Set senderIdsForRegion3_4 = new HashSet(Arrays.asList(listSenderIdsForRegion3_4));\n+    Set senderIdsForRegion5_6 = new HashSet(Arrays.asList(listSenderIdsForRegion5_6));\n+    Set senderIdsForRegion7 = new HashSet(Arrays.asList(listSenderIdsForRegion7));\n+    Set senderIdsForRegion8 = new HashSet(Arrays.asList(listSenderIdsForRegion8));\n+\n+    region1 = mock(InternalRegion.class);\n+    when(region1.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region2 = mock(InternalRegion.class);\n+    when(region2.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region3 = mock(InternalRegion.class);\n+    when(region3.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region4 = mock(InternalRegion.class);\n+    when(region4.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region5 = mock(InternalRegion.class);\n+    when(region5.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region6 = mock(InternalRegion.class);\n+    when(region6.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region7 = mock(InternalRegion.class);\n+    when(region7.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion7);\n+\n+    region8 = mock(InternalRegion.class);\n+    when(region8.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion8);\n+  }\n+\n+  @Test\n+  public void noSenderGroupingTransactions() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA2NDg2Ng==", "bodyText": "How about getLastTransactionEventThrowsExceptionWhenSenderNotFound?", "url": "https://github.com/apache/geode/pull/4928#discussion_r423064866", "createdAt": "2020-05-11T14:06:28Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.AssertionsForClassTypes.assertThatThrownBy;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ServiceConfigurationError;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.wan.GatewaySender;\n+\n+public class TXLastEventInTransactionUtilsTest {\n+\n+  public static final String SENDER_1 = \"sender1\";\n+  public static final String SENDER_2 = \"sender2\";\n+  public static final String SENDER_3 = \"sender3\";\n+  public static final String SENDER_4 = \"sender4\";\n+  public static final String SENDER_5 = \"sender5\";\n+\n+  Cache cache;\n+  InternalRegion region1;\n+  InternalRegion region2;\n+  InternalRegion region3;\n+  InternalRegion region4;\n+  InternalRegion region5;\n+  InternalRegion region6;\n+  InternalRegion region7;\n+  InternalRegion region8;\n+\n+  GatewaySender sender1;\n+  GatewaySender sender2;\n+  GatewaySender sender3;\n+  GatewaySender sender4;\n+\n+  @Before\n+  public void setUp() {\n+    sender1 = mock(GatewaySender.class);\n+    when(sender1.isGroupTransactionEvents()).thenReturn(false);\n+    sender2 = mock(GatewaySender.class);\n+    when(sender2.isGroupTransactionEvents()).thenReturn(false);\n+    sender3 = mock(GatewaySender.class);\n+    when(sender3.isGroupTransactionEvents()).thenReturn(true);\n+    sender4 = mock(GatewaySender.class);\n+    when(sender4.isGroupTransactionEvents()).thenReturn(true);\n+\n+    cache = mock(Cache.class);\n+    when(cache.getGatewaySender(SENDER_1)).thenReturn(sender1);\n+    when(cache.getGatewaySender(SENDER_2)).thenReturn(sender2);\n+    when(cache.getGatewaySender(SENDER_3)).thenReturn(sender3);\n+    when(cache.getGatewaySender(SENDER_4)).thenReturn(sender4);\n+    when(cache.getGatewaySender(SENDER_5)).thenReturn(null);\n+\n+    final String listSenderIdsForRegion1_2[] = {SENDER_1, SENDER_2};\n+    final String listSenderIdsForRegion3_4[] = {SENDER_3, SENDER_4};\n+    final String listSenderIdsForRegion5_6[] = {SENDER_1, SENDER_3};\n+    final String listSenderIdsForRegion7[] = {SENDER_3};\n+    final String listSenderIdsForRegion8[] = {SENDER_5};\n+\n+\n+    Set senderIdsForRegion1_2 = new HashSet(Arrays.asList(listSenderIdsForRegion1_2));\n+    Set senderIdsForRegion3_4 = new HashSet(Arrays.asList(listSenderIdsForRegion3_4));\n+    Set senderIdsForRegion5_6 = new HashSet(Arrays.asList(listSenderIdsForRegion5_6));\n+    Set senderIdsForRegion7 = new HashSet(Arrays.asList(listSenderIdsForRegion7));\n+    Set senderIdsForRegion8 = new HashSet(Arrays.asList(listSenderIdsForRegion8));\n+\n+    region1 = mock(InternalRegion.class);\n+    when(region1.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region2 = mock(InternalRegion.class);\n+    when(region2.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region3 = mock(InternalRegion.class);\n+    when(region3.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region4 = mock(InternalRegion.class);\n+    when(region4.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region5 = mock(InternalRegion.class);\n+    when(region5.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region6 = mock(InternalRegion.class);\n+    when(region6.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region7 = mock(InternalRegion.class);\n+    when(region7.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion7);\n+\n+    region8 = mock(InternalRegion.class);\n+    when(region8.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion8);\n+  }\n+\n+  @Test\n+  public void noSenderGroupingTransactions() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwNzgxMQ=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE2OTMxMw==", "bodyText": "This test doesn't seem to be asserting that an exception is thrown anywhere, so that name would be confusing. Perhaps getLastTransactionEventReturnsNullWhenGroupTransactionEventsIsFalseForAllSenders?", "url": "https://github.com/apache/geode/pull/4928#discussion_r423169313", "createdAt": "2020-05-11T16:36:14Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.AssertionsForClassTypes.assertThatThrownBy;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ServiceConfigurationError;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.wan.GatewaySender;\n+\n+public class TXLastEventInTransactionUtilsTest {\n+\n+  public static final String SENDER_1 = \"sender1\";\n+  public static final String SENDER_2 = \"sender2\";\n+  public static final String SENDER_3 = \"sender3\";\n+  public static final String SENDER_4 = \"sender4\";\n+  public static final String SENDER_5 = \"sender5\";\n+\n+  Cache cache;\n+  InternalRegion region1;\n+  InternalRegion region2;\n+  InternalRegion region3;\n+  InternalRegion region4;\n+  InternalRegion region5;\n+  InternalRegion region6;\n+  InternalRegion region7;\n+  InternalRegion region8;\n+\n+  GatewaySender sender1;\n+  GatewaySender sender2;\n+  GatewaySender sender3;\n+  GatewaySender sender4;\n+\n+  @Before\n+  public void setUp() {\n+    sender1 = mock(GatewaySender.class);\n+    when(sender1.isGroupTransactionEvents()).thenReturn(false);\n+    sender2 = mock(GatewaySender.class);\n+    when(sender2.isGroupTransactionEvents()).thenReturn(false);\n+    sender3 = mock(GatewaySender.class);\n+    when(sender3.isGroupTransactionEvents()).thenReturn(true);\n+    sender4 = mock(GatewaySender.class);\n+    when(sender4.isGroupTransactionEvents()).thenReturn(true);\n+\n+    cache = mock(Cache.class);\n+    when(cache.getGatewaySender(SENDER_1)).thenReturn(sender1);\n+    when(cache.getGatewaySender(SENDER_2)).thenReturn(sender2);\n+    when(cache.getGatewaySender(SENDER_3)).thenReturn(sender3);\n+    when(cache.getGatewaySender(SENDER_4)).thenReturn(sender4);\n+    when(cache.getGatewaySender(SENDER_5)).thenReturn(null);\n+\n+    final String listSenderIdsForRegion1_2[] = {SENDER_1, SENDER_2};\n+    final String listSenderIdsForRegion3_4[] = {SENDER_3, SENDER_4};\n+    final String listSenderIdsForRegion5_6[] = {SENDER_1, SENDER_3};\n+    final String listSenderIdsForRegion7[] = {SENDER_3};\n+    final String listSenderIdsForRegion8[] = {SENDER_5};\n+\n+\n+    Set senderIdsForRegion1_2 = new HashSet(Arrays.asList(listSenderIdsForRegion1_2));\n+    Set senderIdsForRegion3_4 = new HashSet(Arrays.asList(listSenderIdsForRegion3_4));\n+    Set senderIdsForRegion5_6 = new HashSet(Arrays.asList(listSenderIdsForRegion5_6));\n+    Set senderIdsForRegion7 = new HashSet(Arrays.asList(listSenderIdsForRegion7));\n+    Set senderIdsForRegion8 = new HashSet(Arrays.asList(listSenderIdsForRegion8));\n+\n+    region1 = mock(InternalRegion.class);\n+    when(region1.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region2 = mock(InternalRegion.class);\n+    when(region2.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region3 = mock(InternalRegion.class);\n+    when(region3.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region4 = mock(InternalRegion.class);\n+    when(region4.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region5 = mock(InternalRegion.class);\n+    when(region5.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region6 = mock(InternalRegion.class);\n+    when(region6.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region7 = mock(InternalRegion.class);\n+    when(region7.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion7);\n+\n+    region8 = mock(InternalRegion.class);\n+    when(region8.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion8);\n+  }\n+\n+  @Test\n+  public void noSenderGroupingTransactions() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwNzgxMQ=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE3ODgzNQ==", "bodyText": "I might have added the wrong reply here.\nThe intended proposal was: lastTransactionEventNotFoundWhenNoSenderGroupsTransactions.\nAnyway, I like your proposal so I will stick with it :-)", "url": "https://github.com/apache/geode/pull/4928#discussion_r423178835", "createdAt": "2020-05-11T16:51:45Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.AssertionsForClassTypes.assertThatThrownBy;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ServiceConfigurationError;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.wan.GatewaySender;\n+\n+public class TXLastEventInTransactionUtilsTest {\n+\n+  public static final String SENDER_1 = \"sender1\";\n+  public static final String SENDER_2 = \"sender2\";\n+  public static final String SENDER_3 = \"sender3\";\n+  public static final String SENDER_4 = \"sender4\";\n+  public static final String SENDER_5 = \"sender5\";\n+\n+  Cache cache;\n+  InternalRegion region1;\n+  InternalRegion region2;\n+  InternalRegion region3;\n+  InternalRegion region4;\n+  InternalRegion region5;\n+  InternalRegion region6;\n+  InternalRegion region7;\n+  InternalRegion region8;\n+\n+  GatewaySender sender1;\n+  GatewaySender sender2;\n+  GatewaySender sender3;\n+  GatewaySender sender4;\n+\n+  @Before\n+  public void setUp() {\n+    sender1 = mock(GatewaySender.class);\n+    when(sender1.isGroupTransactionEvents()).thenReturn(false);\n+    sender2 = mock(GatewaySender.class);\n+    when(sender2.isGroupTransactionEvents()).thenReturn(false);\n+    sender3 = mock(GatewaySender.class);\n+    when(sender3.isGroupTransactionEvents()).thenReturn(true);\n+    sender4 = mock(GatewaySender.class);\n+    when(sender4.isGroupTransactionEvents()).thenReturn(true);\n+\n+    cache = mock(Cache.class);\n+    when(cache.getGatewaySender(SENDER_1)).thenReturn(sender1);\n+    when(cache.getGatewaySender(SENDER_2)).thenReturn(sender2);\n+    when(cache.getGatewaySender(SENDER_3)).thenReturn(sender3);\n+    when(cache.getGatewaySender(SENDER_4)).thenReturn(sender4);\n+    when(cache.getGatewaySender(SENDER_5)).thenReturn(null);\n+\n+    final String listSenderIdsForRegion1_2[] = {SENDER_1, SENDER_2};\n+    final String listSenderIdsForRegion3_4[] = {SENDER_3, SENDER_4};\n+    final String listSenderIdsForRegion5_6[] = {SENDER_1, SENDER_3};\n+    final String listSenderIdsForRegion7[] = {SENDER_3};\n+    final String listSenderIdsForRegion8[] = {SENDER_5};\n+\n+\n+    Set senderIdsForRegion1_2 = new HashSet(Arrays.asList(listSenderIdsForRegion1_2));\n+    Set senderIdsForRegion3_4 = new HashSet(Arrays.asList(listSenderIdsForRegion3_4));\n+    Set senderIdsForRegion5_6 = new HashSet(Arrays.asList(listSenderIdsForRegion5_6));\n+    Set senderIdsForRegion7 = new HashSet(Arrays.asList(listSenderIdsForRegion7));\n+    Set senderIdsForRegion8 = new HashSet(Arrays.asList(listSenderIdsForRegion8));\n+\n+    region1 = mock(InternalRegion.class);\n+    when(region1.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region2 = mock(InternalRegion.class);\n+    when(region2.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region3 = mock(InternalRegion.class);\n+    when(region3.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region4 = mock(InternalRegion.class);\n+    when(region4.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region5 = mock(InternalRegion.class);\n+    when(region5.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region6 = mock(InternalRegion.class);\n+    when(region6.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region7 = mock(InternalRegion.class);\n+    when(region7.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion7);\n+\n+    region8 = mock(InternalRegion.class);\n+    when(region8.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion8);\n+  }\n+\n+  @Test\n+  public void noSenderGroupingTransactions() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwNzgxMQ=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTg1Mzk0OnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMjo0Njo1N1rOGS1zag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNDoyNToyMFrOGTepXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwOTA2Ng==", "bodyText": "Can these arrays be declared java-style rather than C-style: String[] listSenderIdsForRegion1_2", "url": "https://github.com/apache/geode/pull/4928#discussion_r422409066", "createdAt": "2020-05-08T22:46:57Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.AssertionsForClassTypes.assertThatThrownBy;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ServiceConfigurationError;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.wan.GatewaySender;\n+\n+public class TXLastEventInTransactionUtilsTest {\n+\n+  public static final String SENDER_1 = \"sender1\";\n+  public static final String SENDER_2 = \"sender2\";\n+  public static final String SENDER_3 = \"sender3\";\n+  public static final String SENDER_4 = \"sender4\";\n+  public static final String SENDER_5 = \"sender5\";\n+\n+  Cache cache;\n+  InternalRegion region1;\n+  InternalRegion region2;\n+  InternalRegion region3;\n+  InternalRegion region4;\n+  InternalRegion region5;\n+  InternalRegion region6;\n+  InternalRegion region7;\n+  InternalRegion region8;\n+\n+  GatewaySender sender1;\n+  GatewaySender sender2;\n+  GatewaySender sender3;\n+  GatewaySender sender4;\n+\n+  @Before\n+  public void setUp() {\n+    sender1 = mock(GatewaySender.class);\n+    when(sender1.isGroupTransactionEvents()).thenReturn(false);\n+    sender2 = mock(GatewaySender.class);\n+    when(sender2.isGroupTransactionEvents()).thenReturn(false);\n+    sender3 = mock(GatewaySender.class);\n+    when(sender3.isGroupTransactionEvents()).thenReturn(true);\n+    sender4 = mock(GatewaySender.class);\n+    when(sender4.isGroupTransactionEvents()).thenReturn(true);\n+\n+    cache = mock(Cache.class);\n+    when(cache.getGatewaySender(SENDER_1)).thenReturn(sender1);\n+    when(cache.getGatewaySender(SENDER_2)).thenReturn(sender2);\n+    when(cache.getGatewaySender(SENDER_3)).thenReturn(sender3);\n+    when(cache.getGatewaySender(SENDER_4)).thenReturn(sender4);\n+    when(cache.getGatewaySender(SENDER_5)).thenReturn(null);\n+\n+    final String listSenderIdsForRegion1_2[] = {SENDER_1, SENDER_2};\n+    final String listSenderIdsForRegion3_4[] = {SENDER_3, SENDER_4};\n+    final String listSenderIdsForRegion5_6[] = {SENDER_1, SENDER_3};\n+    final String listSenderIdsForRegion7[] = {SENDER_3};\n+    final String listSenderIdsForRegion8[] = {SENDER_5};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA3ODIzOQ==", "bodyText": "The idea was to initialize the data statically which is something you would not be able to do with java-style containers.\nAnyway, I have removed the lists and put the elements in the sets directly.", "url": "https://github.com/apache/geode/pull/4928#discussion_r423078239", "createdAt": "2020-05-11T14:25:20Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.AssertionsForClassTypes.assertThatThrownBy;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ServiceConfigurationError;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.wan.GatewaySender;\n+\n+public class TXLastEventInTransactionUtilsTest {\n+\n+  public static final String SENDER_1 = \"sender1\";\n+  public static final String SENDER_2 = \"sender2\";\n+  public static final String SENDER_3 = \"sender3\";\n+  public static final String SENDER_4 = \"sender4\";\n+  public static final String SENDER_5 = \"sender5\";\n+\n+  Cache cache;\n+  InternalRegion region1;\n+  InternalRegion region2;\n+  InternalRegion region3;\n+  InternalRegion region4;\n+  InternalRegion region5;\n+  InternalRegion region6;\n+  InternalRegion region7;\n+  InternalRegion region8;\n+\n+  GatewaySender sender1;\n+  GatewaySender sender2;\n+  GatewaySender sender3;\n+  GatewaySender sender4;\n+\n+  @Before\n+  public void setUp() {\n+    sender1 = mock(GatewaySender.class);\n+    when(sender1.isGroupTransactionEvents()).thenReturn(false);\n+    sender2 = mock(GatewaySender.class);\n+    when(sender2.isGroupTransactionEvents()).thenReturn(false);\n+    sender3 = mock(GatewaySender.class);\n+    when(sender3.isGroupTransactionEvents()).thenReturn(true);\n+    sender4 = mock(GatewaySender.class);\n+    when(sender4.isGroupTransactionEvents()).thenReturn(true);\n+\n+    cache = mock(Cache.class);\n+    when(cache.getGatewaySender(SENDER_1)).thenReturn(sender1);\n+    when(cache.getGatewaySender(SENDER_2)).thenReturn(sender2);\n+    when(cache.getGatewaySender(SENDER_3)).thenReturn(sender3);\n+    when(cache.getGatewaySender(SENDER_4)).thenReturn(sender4);\n+    when(cache.getGatewaySender(SENDER_5)).thenReturn(null);\n+\n+    final String listSenderIdsForRegion1_2[] = {SENDER_1, SENDER_2};\n+    final String listSenderIdsForRegion3_4[] = {SENDER_3, SENDER_4};\n+    final String listSenderIdsForRegion5_6[] = {SENDER_1, SENDER_3};\n+    final String listSenderIdsForRegion7[] = {SENDER_3};\n+    final String listSenderIdsForRegion8[] = {SENDER_5};", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwOTA2Ng=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTg1NTE4OnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMjo0Nzo0OVrOGS10Lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjozNzoyMVrOGTkPqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwOTI2Mg==", "bodyText": "This test name could be more descriptive. Also, an exception is never thrown from this method, so the throws can be removed.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422409262", "createdAt": "2020-05-08T22:47:49Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.AssertionsForClassTypes.assertThatThrownBy;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ServiceConfigurationError;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.wan.GatewaySender;\n+\n+public class TXLastEventInTransactionUtilsTest {\n+\n+  public static final String SENDER_1 = \"sender1\";\n+  public static final String SENDER_2 = \"sender2\";\n+  public static final String SENDER_3 = \"sender3\";\n+  public static final String SENDER_4 = \"sender4\";\n+  public static final String SENDER_5 = \"sender5\";\n+\n+  Cache cache;\n+  InternalRegion region1;\n+  InternalRegion region2;\n+  InternalRegion region3;\n+  InternalRegion region4;\n+  InternalRegion region5;\n+  InternalRegion region6;\n+  InternalRegion region7;\n+  InternalRegion region8;\n+\n+  GatewaySender sender1;\n+  GatewaySender sender2;\n+  GatewaySender sender3;\n+  GatewaySender sender4;\n+\n+  @Before\n+  public void setUp() {\n+    sender1 = mock(GatewaySender.class);\n+    when(sender1.isGroupTransactionEvents()).thenReturn(false);\n+    sender2 = mock(GatewaySender.class);\n+    when(sender2.isGroupTransactionEvents()).thenReturn(false);\n+    sender3 = mock(GatewaySender.class);\n+    when(sender3.isGroupTransactionEvents()).thenReturn(true);\n+    sender4 = mock(GatewaySender.class);\n+    when(sender4.isGroupTransactionEvents()).thenReturn(true);\n+\n+    cache = mock(Cache.class);\n+    when(cache.getGatewaySender(SENDER_1)).thenReturn(sender1);\n+    when(cache.getGatewaySender(SENDER_2)).thenReturn(sender2);\n+    when(cache.getGatewaySender(SENDER_3)).thenReturn(sender3);\n+    when(cache.getGatewaySender(SENDER_4)).thenReturn(sender4);\n+    when(cache.getGatewaySender(SENDER_5)).thenReturn(null);\n+\n+    final String listSenderIdsForRegion1_2[] = {SENDER_1, SENDER_2};\n+    final String listSenderIdsForRegion3_4[] = {SENDER_3, SENDER_4};\n+    final String listSenderIdsForRegion5_6[] = {SENDER_1, SENDER_3};\n+    final String listSenderIdsForRegion7[] = {SENDER_3};\n+    final String listSenderIdsForRegion8[] = {SENDER_5};\n+\n+\n+    Set senderIdsForRegion1_2 = new HashSet(Arrays.asList(listSenderIdsForRegion1_2));\n+    Set senderIdsForRegion3_4 = new HashSet(Arrays.asList(listSenderIdsForRegion3_4));\n+    Set senderIdsForRegion5_6 = new HashSet(Arrays.asList(listSenderIdsForRegion5_6));\n+    Set senderIdsForRegion7 = new HashSet(Arrays.asList(listSenderIdsForRegion7));\n+    Set senderIdsForRegion8 = new HashSet(Arrays.asList(listSenderIdsForRegion8));\n+\n+    region1 = mock(InternalRegion.class);\n+    when(region1.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region2 = mock(InternalRegion.class);\n+    when(region2.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region3 = mock(InternalRegion.class);\n+    when(region3.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region4 = mock(InternalRegion.class);\n+    when(region4.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region5 = mock(InternalRegion.class);\n+    when(region5.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region6 = mock(InternalRegion.class);\n+    when(region6.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region7 = mock(InternalRegion.class);\n+    when(region7.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion7);\n+\n+    region8 = mock(InternalRegion.class);\n+    when(region8.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion8);\n+  }\n+\n+  @Test\n+  public void noSenderGroupingTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region1);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region2);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(null, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void lastEventFoundAllSendersGroupTransactions() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA4NDExNg==", "bodyText": "How about lastTransactionEventFoundWhenAllSendersGroupTransactionEvents?", "url": "https://github.com/apache/geode/pull/4928#discussion_r423084116", "createdAt": "2020-05-11T14:33:15Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.AssertionsForClassTypes.assertThatThrownBy;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ServiceConfigurationError;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.wan.GatewaySender;\n+\n+public class TXLastEventInTransactionUtilsTest {\n+\n+  public static final String SENDER_1 = \"sender1\";\n+  public static final String SENDER_2 = \"sender2\";\n+  public static final String SENDER_3 = \"sender3\";\n+  public static final String SENDER_4 = \"sender4\";\n+  public static final String SENDER_5 = \"sender5\";\n+\n+  Cache cache;\n+  InternalRegion region1;\n+  InternalRegion region2;\n+  InternalRegion region3;\n+  InternalRegion region4;\n+  InternalRegion region5;\n+  InternalRegion region6;\n+  InternalRegion region7;\n+  InternalRegion region8;\n+\n+  GatewaySender sender1;\n+  GatewaySender sender2;\n+  GatewaySender sender3;\n+  GatewaySender sender4;\n+\n+  @Before\n+  public void setUp() {\n+    sender1 = mock(GatewaySender.class);\n+    when(sender1.isGroupTransactionEvents()).thenReturn(false);\n+    sender2 = mock(GatewaySender.class);\n+    when(sender2.isGroupTransactionEvents()).thenReturn(false);\n+    sender3 = mock(GatewaySender.class);\n+    when(sender3.isGroupTransactionEvents()).thenReturn(true);\n+    sender4 = mock(GatewaySender.class);\n+    when(sender4.isGroupTransactionEvents()).thenReturn(true);\n+\n+    cache = mock(Cache.class);\n+    when(cache.getGatewaySender(SENDER_1)).thenReturn(sender1);\n+    when(cache.getGatewaySender(SENDER_2)).thenReturn(sender2);\n+    when(cache.getGatewaySender(SENDER_3)).thenReturn(sender3);\n+    when(cache.getGatewaySender(SENDER_4)).thenReturn(sender4);\n+    when(cache.getGatewaySender(SENDER_5)).thenReturn(null);\n+\n+    final String listSenderIdsForRegion1_2[] = {SENDER_1, SENDER_2};\n+    final String listSenderIdsForRegion3_4[] = {SENDER_3, SENDER_4};\n+    final String listSenderIdsForRegion5_6[] = {SENDER_1, SENDER_3};\n+    final String listSenderIdsForRegion7[] = {SENDER_3};\n+    final String listSenderIdsForRegion8[] = {SENDER_5};\n+\n+\n+    Set senderIdsForRegion1_2 = new HashSet(Arrays.asList(listSenderIdsForRegion1_2));\n+    Set senderIdsForRegion3_4 = new HashSet(Arrays.asList(listSenderIdsForRegion3_4));\n+    Set senderIdsForRegion5_6 = new HashSet(Arrays.asList(listSenderIdsForRegion5_6));\n+    Set senderIdsForRegion7 = new HashSet(Arrays.asList(listSenderIdsForRegion7));\n+    Set senderIdsForRegion8 = new HashSet(Arrays.asList(listSenderIdsForRegion8));\n+\n+    region1 = mock(InternalRegion.class);\n+    when(region1.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region2 = mock(InternalRegion.class);\n+    when(region2.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region3 = mock(InternalRegion.class);\n+    when(region3.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region4 = mock(InternalRegion.class);\n+    when(region4.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region5 = mock(InternalRegion.class);\n+    when(region5.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region6 = mock(InternalRegion.class);\n+    when(region6.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region7 = mock(InternalRegion.class);\n+    when(region7.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion7);\n+\n+    region8 = mock(InternalRegion.class);\n+    when(region8.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion8);\n+  }\n+\n+  @Test\n+  public void noSenderGroupingTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region1);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region2);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(null, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void lastEventFoundAllSendersGroupTransactions() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwOTI2Mg=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE2OTk2MA==", "bodyText": "Sounds good to me", "url": "https://github.com/apache/geode/pull/4928#discussion_r423169960", "createdAt": "2020-05-11T16:37:21Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.AssertionsForClassTypes.assertThatThrownBy;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ServiceConfigurationError;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.wan.GatewaySender;\n+\n+public class TXLastEventInTransactionUtilsTest {\n+\n+  public static final String SENDER_1 = \"sender1\";\n+  public static final String SENDER_2 = \"sender2\";\n+  public static final String SENDER_3 = \"sender3\";\n+  public static final String SENDER_4 = \"sender4\";\n+  public static final String SENDER_5 = \"sender5\";\n+\n+  Cache cache;\n+  InternalRegion region1;\n+  InternalRegion region2;\n+  InternalRegion region3;\n+  InternalRegion region4;\n+  InternalRegion region5;\n+  InternalRegion region6;\n+  InternalRegion region7;\n+  InternalRegion region8;\n+\n+  GatewaySender sender1;\n+  GatewaySender sender2;\n+  GatewaySender sender3;\n+  GatewaySender sender4;\n+\n+  @Before\n+  public void setUp() {\n+    sender1 = mock(GatewaySender.class);\n+    when(sender1.isGroupTransactionEvents()).thenReturn(false);\n+    sender2 = mock(GatewaySender.class);\n+    when(sender2.isGroupTransactionEvents()).thenReturn(false);\n+    sender3 = mock(GatewaySender.class);\n+    when(sender3.isGroupTransactionEvents()).thenReturn(true);\n+    sender4 = mock(GatewaySender.class);\n+    when(sender4.isGroupTransactionEvents()).thenReturn(true);\n+\n+    cache = mock(Cache.class);\n+    when(cache.getGatewaySender(SENDER_1)).thenReturn(sender1);\n+    when(cache.getGatewaySender(SENDER_2)).thenReturn(sender2);\n+    when(cache.getGatewaySender(SENDER_3)).thenReturn(sender3);\n+    when(cache.getGatewaySender(SENDER_4)).thenReturn(sender4);\n+    when(cache.getGatewaySender(SENDER_5)).thenReturn(null);\n+\n+    final String listSenderIdsForRegion1_2[] = {SENDER_1, SENDER_2};\n+    final String listSenderIdsForRegion3_4[] = {SENDER_3, SENDER_4};\n+    final String listSenderIdsForRegion5_6[] = {SENDER_1, SENDER_3};\n+    final String listSenderIdsForRegion7[] = {SENDER_3};\n+    final String listSenderIdsForRegion8[] = {SENDER_5};\n+\n+\n+    Set senderIdsForRegion1_2 = new HashSet(Arrays.asList(listSenderIdsForRegion1_2));\n+    Set senderIdsForRegion3_4 = new HashSet(Arrays.asList(listSenderIdsForRegion3_4));\n+    Set senderIdsForRegion5_6 = new HashSet(Arrays.asList(listSenderIdsForRegion5_6));\n+    Set senderIdsForRegion7 = new HashSet(Arrays.asList(listSenderIdsForRegion7));\n+    Set senderIdsForRegion8 = new HashSet(Arrays.asList(listSenderIdsForRegion8));\n+\n+    region1 = mock(InternalRegion.class);\n+    when(region1.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region2 = mock(InternalRegion.class);\n+    when(region2.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region3 = mock(InternalRegion.class);\n+    when(region3.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region4 = mock(InternalRegion.class);\n+    when(region4.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region5 = mock(InternalRegion.class);\n+    when(region5.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region6 = mock(InternalRegion.class);\n+    when(region6.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region7 = mock(InternalRegion.class);\n+    when(region7.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion7);\n+\n+    region8 = mock(InternalRegion.class);\n+    when(region8.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion8);\n+  }\n+\n+  @Test\n+  public void noSenderGroupingTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region1);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region2);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(null, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void lastEventFoundAllSendersGroupTransactions() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwOTI2Mg=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTg1NjkzOnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMjo0ODo1OFrOGS11RQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjozODoxMVrOGTkRxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwOTU0MQ==", "bodyText": "This test name could be more descriptive. Also, an exception is never thrown from this method, so the throws can be removed.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422409541", "createdAt": "2020-05-08T22:48:58Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.AssertionsForClassTypes.assertThatThrownBy;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ServiceConfigurationError;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.wan.GatewaySender;\n+\n+public class TXLastEventInTransactionUtilsTest {\n+\n+  public static final String SENDER_1 = \"sender1\";\n+  public static final String SENDER_2 = \"sender2\";\n+  public static final String SENDER_3 = \"sender3\";\n+  public static final String SENDER_4 = \"sender4\";\n+  public static final String SENDER_5 = \"sender5\";\n+\n+  Cache cache;\n+  InternalRegion region1;\n+  InternalRegion region2;\n+  InternalRegion region3;\n+  InternalRegion region4;\n+  InternalRegion region5;\n+  InternalRegion region6;\n+  InternalRegion region7;\n+  InternalRegion region8;\n+\n+  GatewaySender sender1;\n+  GatewaySender sender2;\n+  GatewaySender sender3;\n+  GatewaySender sender4;\n+\n+  @Before\n+  public void setUp() {\n+    sender1 = mock(GatewaySender.class);\n+    when(sender1.isGroupTransactionEvents()).thenReturn(false);\n+    sender2 = mock(GatewaySender.class);\n+    when(sender2.isGroupTransactionEvents()).thenReturn(false);\n+    sender3 = mock(GatewaySender.class);\n+    when(sender3.isGroupTransactionEvents()).thenReturn(true);\n+    sender4 = mock(GatewaySender.class);\n+    when(sender4.isGroupTransactionEvents()).thenReturn(true);\n+\n+    cache = mock(Cache.class);\n+    when(cache.getGatewaySender(SENDER_1)).thenReturn(sender1);\n+    when(cache.getGatewaySender(SENDER_2)).thenReturn(sender2);\n+    when(cache.getGatewaySender(SENDER_3)).thenReturn(sender3);\n+    when(cache.getGatewaySender(SENDER_4)).thenReturn(sender4);\n+    when(cache.getGatewaySender(SENDER_5)).thenReturn(null);\n+\n+    final String listSenderIdsForRegion1_2[] = {SENDER_1, SENDER_2};\n+    final String listSenderIdsForRegion3_4[] = {SENDER_3, SENDER_4};\n+    final String listSenderIdsForRegion5_6[] = {SENDER_1, SENDER_3};\n+    final String listSenderIdsForRegion7[] = {SENDER_3};\n+    final String listSenderIdsForRegion8[] = {SENDER_5};\n+\n+\n+    Set senderIdsForRegion1_2 = new HashSet(Arrays.asList(listSenderIdsForRegion1_2));\n+    Set senderIdsForRegion3_4 = new HashSet(Arrays.asList(listSenderIdsForRegion3_4));\n+    Set senderIdsForRegion5_6 = new HashSet(Arrays.asList(listSenderIdsForRegion5_6));\n+    Set senderIdsForRegion7 = new HashSet(Arrays.asList(listSenderIdsForRegion7));\n+    Set senderIdsForRegion8 = new HashSet(Arrays.asList(listSenderIdsForRegion8));\n+\n+    region1 = mock(InternalRegion.class);\n+    when(region1.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region2 = mock(InternalRegion.class);\n+    when(region2.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region3 = mock(InternalRegion.class);\n+    when(region3.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region4 = mock(InternalRegion.class);\n+    when(region4.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region5 = mock(InternalRegion.class);\n+    when(region5.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region6 = mock(InternalRegion.class);\n+    when(region6.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region7 = mock(InternalRegion.class);\n+    when(region7.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion7);\n+\n+    region8 = mock(InternalRegion.class);\n+    when(region8.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion8);\n+  }\n+\n+  @Test\n+  public void noSenderGroupingTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region1);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region2);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(null, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void lastEventFoundAllSendersGroupTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region3);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region4);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(event2, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void lastEventFoundNotAllSendersGroupTransactions() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA4NzcxNA==", "bodyText": "How about lastTransactionEventFoundWhenNotAllSendersGroupTransactionEvents?", "url": "https://github.com/apache/geode/pull/4928#discussion_r423087714", "createdAt": "2020-05-11T14:38:09Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.AssertionsForClassTypes.assertThatThrownBy;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ServiceConfigurationError;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.wan.GatewaySender;\n+\n+public class TXLastEventInTransactionUtilsTest {\n+\n+  public static final String SENDER_1 = \"sender1\";\n+  public static final String SENDER_2 = \"sender2\";\n+  public static final String SENDER_3 = \"sender3\";\n+  public static final String SENDER_4 = \"sender4\";\n+  public static final String SENDER_5 = \"sender5\";\n+\n+  Cache cache;\n+  InternalRegion region1;\n+  InternalRegion region2;\n+  InternalRegion region3;\n+  InternalRegion region4;\n+  InternalRegion region5;\n+  InternalRegion region6;\n+  InternalRegion region7;\n+  InternalRegion region8;\n+\n+  GatewaySender sender1;\n+  GatewaySender sender2;\n+  GatewaySender sender3;\n+  GatewaySender sender4;\n+\n+  @Before\n+  public void setUp() {\n+    sender1 = mock(GatewaySender.class);\n+    when(sender1.isGroupTransactionEvents()).thenReturn(false);\n+    sender2 = mock(GatewaySender.class);\n+    when(sender2.isGroupTransactionEvents()).thenReturn(false);\n+    sender3 = mock(GatewaySender.class);\n+    when(sender3.isGroupTransactionEvents()).thenReturn(true);\n+    sender4 = mock(GatewaySender.class);\n+    when(sender4.isGroupTransactionEvents()).thenReturn(true);\n+\n+    cache = mock(Cache.class);\n+    when(cache.getGatewaySender(SENDER_1)).thenReturn(sender1);\n+    when(cache.getGatewaySender(SENDER_2)).thenReturn(sender2);\n+    when(cache.getGatewaySender(SENDER_3)).thenReturn(sender3);\n+    when(cache.getGatewaySender(SENDER_4)).thenReturn(sender4);\n+    when(cache.getGatewaySender(SENDER_5)).thenReturn(null);\n+\n+    final String listSenderIdsForRegion1_2[] = {SENDER_1, SENDER_2};\n+    final String listSenderIdsForRegion3_4[] = {SENDER_3, SENDER_4};\n+    final String listSenderIdsForRegion5_6[] = {SENDER_1, SENDER_3};\n+    final String listSenderIdsForRegion7[] = {SENDER_3};\n+    final String listSenderIdsForRegion8[] = {SENDER_5};\n+\n+\n+    Set senderIdsForRegion1_2 = new HashSet(Arrays.asList(listSenderIdsForRegion1_2));\n+    Set senderIdsForRegion3_4 = new HashSet(Arrays.asList(listSenderIdsForRegion3_4));\n+    Set senderIdsForRegion5_6 = new HashSet(Arrays.asList(listSenderIdsForRegion5_6));\n+    Set senderIdsForRegion7 = new HashSet(Arrays.asList(listSenderIdsForRegion7));\n+    Set senderIdsForRegion8 = new HashSet(Arrays.asList(listSenderIdsForRegion8));\n+\n+    region1 = mock(InternalRegion.class);\n+    when(region1.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region2 = mock(InternalRegion.class);\n+    when(region2.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region3 = mock(InternalRegion.class);\n+    when(region3.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region4 = mock(InternalRegion.class);\n+    when(region4.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region5 = mock(InternalRegion.class);\n+    when(region5.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region6 = mock(InternalRegion.class);\n+    when(region6.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region7 = mock(InternalRegion.class);\n+    when(region7.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion7);\n+\n+    region8 = mock(InternalRegion.class);\n+    when(region8.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion8);\n+  }\n+\n+  @Test\n+  public void noSenderGroupingTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region1);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region2);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(null, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void lastEventFoundAllSendersGroupTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region3);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region4);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(event2, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void lastEventFoundNotAllSendersGroupTransactions() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwOTU0MQ=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE3MDUwMQ==", "bodyText": "Sounds good", "url": "https://github.com/apache/geode/pull/4928#discussion_r423170501", "createdAt": "2020-05-11T16:38:11Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.AssertionsForClassTypes.assertThatThrownBy;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ServiceConfigurationError;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.wan.GatewaySender;\n+\n+public class TXLastEventInTransactionUtilsTest {\n+\n+  public static final String SENDER_1 = \"sender1\";\n+  public static final String SENDER_2 = \"sender2\";\n+  public static final String SENDER_3 = \"sender3\";\n+  public static final String SENDER_4 = \"sender4\";\n+  public static final String SENDER_5 = \"sender5\";\n+\n+  Cache cache;\n+  InternalRegion region1;\n+  InternalRegion region2;\n+  InternalRegion region3;\n+  InternalRegion region4;\n+  InternalRegion region5;\n+  InternalRegion region6;\n+  InternalRegion region7;\n+  InternalRegion region8;\n+\n+  GatewaySender sender1;\n+  GatewaySender sender2;\n+  GatewaySender sender3;\n+  GatewaySender sender4;\n+\n+  @Before\n+  public void setUp() {\n+    sender1 = mock(GatewaySender.class);\n+    when(sender1.isGroupTransactionEvents()).thenReturn(false);\n+    sender2 = mock(GatewaySender.class);\n+    when(sender2.isGroupTransactionEvents()).thenReturn(false);\n+    sender3 = mock(GatewaySender.class);\n+    when(sender3.isGroupTransactionEvents()).thenReturn(true);\n+    sender4 = mock(GatewaySender.class);\n+    when(sender4.isGroupTransactionEvents()).thenReturn(true);\n+\n+    cache = mock(Cache.class);\n+    when(cache.getGatewaySender(SENDER_1)).thenReturn(sender1);\n+    when(cache.getGatewaySender(SENDER_2)).thenReturn(sender2);\n+    when(cache.getGatewaySender(SENDER_3)).thenReturn(sender3);\n+    when(cache.getGatewaySender(SENDER_4)).thenReturn(sender4);\n+    when(cache.getGatewaySender(SENDER_5)).thenReturn(null);\n+\n+    final String listSenderIdsForRegion1_2[] = {SENDER_1, SENDER_2};\n+    final String listSenderIdsForRegion3_4[] = {SENDER_3, SENDER_4};\n+    final String listSenderIdsForRegion5_6[] = {SENDER_1, SENDER_3};\n+    final String listSenderIdsForRegion7[] = {SENDER_3};\n+    final String listSenderIdsForRegion8[] = {SENDER_5};\n+\n+\n+    Set senderIdsForRegion1_2 = new HashSet(Arrays.asList(listSenderIdsForRegion1_2));\n+    Set senderIdsForRegion3_4 = new HashSet(Arrays.asList(listSenderIdsForRegion3_4));\n+    Set senderIdsForRegion5_6 = new HashSet(Arrays.asList(listSenderIdsForRegion5_6));\n+    Set senderIdsForRegion7 = new HashSet(Arrays.asList(listSenderIdsForRegion7));\n+    Set senderIdsForRegion8 = new HashSet(Arrays.asList(listSenderIdsForRegion8));\n+\n+    region1 = mock(InternalRegion.class);\n+    when(region1.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region2 = mock(InternalRegion.class);\n+    when(region2.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region3 = mock(InternalRegion.class);\n+    when(region3.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region4 = mock(InternalRegion.class);\n+    when(region4.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region5 = mock(InternalRegion.class);\n+    when(region5.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region6 = mock(InternalRegion.class);\n+    when(region6.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region7 = mock(InternalRegion.class);\n+    when(region7.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion7);\n+\n+    region8 = mock(InternalRegion.class);\n+    when(region8.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion8);\n+  }\n+\n+  @Test\n+  public void noSenderGroupingTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region1);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region2);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(null, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void lastEventFoundAllSendersGroupTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region3);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region4);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(event2, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void lastEventFoundNotAllSendersGroupTransactions() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwOTU0MQ=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTg2MDIxOnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMjo1MTowOFrOGS13QA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjozOTowMlrOGTkTpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxMDA0OA==", "bodyText": "This test name could be more descriptive. Also, an exception is never thrown from this method, so the throws can be removed.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422410048", "createdAt": "2020-05-08T22:51:08Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.AssertionsForClassTypes.assertThatThrownBy;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ServiceConfigurationError;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.wan.GatewaySender;\n+\n+public class TXLastEventInTransactionUtilsTest {\n+\n+  public static final String SENDER_1 = \"sender1\";\n+  public static final String SENDER_2 = \"sender2\";\n+  public static final String SENDER_3 = \"sender3\";\n+  public static final String SENDER_4 = \"sender4\";\n+  public static final String SENDER_5 = \"sender5\";\n+\n+  Cache cache;\n+  InternalRegion region1;\n+  InternalRegion region2;\n+  InternalRegion region3;\n+  InternalRegion region4;\n+  InternalRegion region5;\n+  InternalRegion region6;\n+  InternalRegion region7;\n+  InternalRegion region8;\n+\n+  GatewaySender sender1;\n+  GatewaySender sender2;\n+  GatewaySender sender3;\n+  GatewaySender sender4;\n+\n+  @Before\n+  public void setUp() {\n+    sender1 = mock(GatewaySender.class);\n+    when(sender1.isGroupTransactionEvents()).thenReturn(false);\n+    sender2 = mock(GatewaySender.class);\n+    when(sender2.isGroupTransactionEvents()).thenReturn(false);\n+    sender3 = mock(GatewaySender.class);\n+    when(sender3.isGroupTransactionEvents()).thenReturn(true);\n+    sender4 = mock(GatewaySender.class);\n+    when(sender4.isGroupTransactionEvents()).thenReturn(true);\n+\n+    cache = mock(Cache.class);\n+    when(cache.getGatewaySender(SENDER_1)).thenReturn(sender1);\n+    when(cache.getGatewaySender(SENDER_2)).thenReturn(sender2);\n+    when(cache.getGatewaySender(SENDER_3)).thenReturn(sender3);\n+    when(cache.getGatewaySender(SENDER_4)).thenReturn(sender4);\n+    when(cache.getGatewaySender(SENDER_5)).thenReturn(null);\n+\n+    final String listSenderIdsForRegion1_2[] = {SENDER_1, SENDER_2};\n+    final String listSenderIdsForRegion3_4[] = {SENDER_3, SENDER_4};\n+    final String listSenderIdsForRegion5_6[] = {SENDER_1, SENDER_3};\n+    final String listSenderIdsForRegion7[] = {SENDER_3};\n+    final String listSenderIdsForRegion8[] = {SENDER_5};\n+\n+\n+    Set senderIdsForRegion1_2 = new HashSet(Arrays.asList(listSenderIdsForRegion1_2));\n+    Set senderIdsForRegion3_4 = new HashSet(Arrays.asList(listSenderIdsForRegion3_4));\n+    Set senderIdsForRegion5_6 = new HashSet(Arrays.asList(listSenderIdsForRegion5_6));\n+    Set senderIdsForRegion7 = new HashSet(Arrays.asList(listSenderIdsForRegion7));\n+    Set senderIdsForRegion8 = new HashSet(Arrays.asList(listSenderIdsForRegion8));\n+\n+    region1 = mock(InternalRegion.class);\n+    when(region1.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region2 = mock(InternalRegion.class);\n+    when(region2.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region3 = mock(InternalRegion.class);\n+    when(region3.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region4 = mock(InternalRegion.class);\n+    when(region4.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region5 = mock(InternalRegion.class);\n+    when(region5.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region6 = mock(InternalRegion.class);\n+    when(region6.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region7 = mock(InternalRegion.class);\n+    when(region7.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion7);\n+\n+    region8 = mock(InternalRegion.class);\n+    when(region8.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion8);\n+  }\n+\n+  @Test\n+  public void noSenderGroupingTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region1);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region2);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(null, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void lastEventFoundAllSendersGroupTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region3);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region4);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(event2, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void lastEventFoundNotAllSendersGroupTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region5);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region6);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(event2, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void notAllEventsToSameGroupingSenders() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA4ODM4Ng==", "bodyText": "How about getLastTransactionEventThrowsExceptionWhenNotAllEventsToSameGroupingSenders?", "url": "https://github.com/apache/geode/pull/4928#discussion_r423088386", "createdAt": "2020-05-11T14:39:01Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.AssertionsForClassTypes.assertThatThrownBy;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ServiceConfigurationError;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.wan.GatewaySender;\n+\n+public class TXLastEventInTransactionUtilsTest {\n+\n+  public static final String SENDER_1 = \"sender1\";\n+  public static final String SENDER_2 = \"sender2\";\n+  public static final String SENDER_3 = \"sender3\";\n+  public static final String SENDER_4 = \"sender4\";\n+  public static final String SENDER_5 = \"sender5\";\n+\n+  Cache cache;\n+  InternalRegion region1;\n+  InternalRegion region2;\n+  InternalRegion region3;\n+  InternalRegion region4;\n+  InternalRegion region5;\n+  InternalRegion region6;\n+  InternalRegion region7;\n+  InternalRegion region8;\n+\n+  GatewaySender sender1;\n+  GatewaySender sender2;\n+  GatewaySender sender3;\n+  GatewaySender sender4;\n+\n+  @Before\n+  public void setUp() {\n+    sender1 = mock(GatewaySender.class);\n+    when(sender1.isGroupTransactionEvents()).thenReturn(false);\n+    sender2 = mock(GatewaySender.class);\n+    when(sender2.isGroupTransactionEvents()).thenReturn(false);\n+    sender3 = mock(GatewaySender.class);\n+    when(sender3.isGroupTransactionEvents()).thenReturn(true);\n+    sender4 = mock(GatewaySender.class);\n+    when(sender4.isGroupTransactionEvents()).thenReturn(true);\n+\n+    cache = mock(Cache.class);\n+    when(cache.getGatewaySender(SENDER_1)).thenReturn(sender1);\n+    when(cache.getGatewaySender(SENDER_2)).thenReturn(sender2);\n+    when(cache.getGatewaySender(SENDER_3)).thenReturn(sender3);\n+    when(cache.getGatewaySender(SENDER_4)).thenReturn(sender4);\n+    when(cache.getGatewaySender(SENDER_5)).thenReturn(null);\n+\n+    final String listSenderIdsForRegion1_2[] = {SENDER_1, SENDER_2};\n+    final String listSenderIdsForRegion3_4[] = {SENDER_3, SENDER_4};\n+    final String listSenderIdsForRegion5_6[] = {SENDER_1, SENDER_3};\n+    final String listSenderIdsForRegion7[] = {SENDER_3};\n+    final String listSenderIdsForRegion8[] = {SENDER_5};\n+\n+\n+    Set senderIdsForRegion1_2 = new HashSet(Arrays.asList(listSenderIdsForRegion1_2));\n+    Set senderIdsForRegion3_4 = new HashSet(Arrays.asList(listSenderIdsForRegion3_4));\n+    Set senderIdsForRegion5_6 = new HashSet(Arrays.asList(listSenderIdsForRegion5_6));\n+    Set senderIdsForRegion7 = new HashSet(Arrays.asList(listSenderIdsForRegion7));\n+    Set senderIdsForRegion8 = new HashSet(Arrays.asList(listSenderIdsForRegion8));\n+\n+    region1 = mock(InternalRegion.class);\n+    when(region1.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region2 = mock(InternalRegion.class);\n+    when(region2.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region3 = mock(InternalRegion.class);\n+    when(region3.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region4 = mock(InternalRegion.class);\n+    when(region4.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region5 = mock(InternalRegion.class);\n+    when(region5.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region6 = mock(InternalRegion.class);\n+    when(region6.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region7 = mock(InternalRegion.class);\n+    when(region7.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion7);\n+\n+    region8 = mock(InternalRegion.class);\n+    when(region8.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion8);\n+  }\n+\n+  @Test\n+  public void noSenderGroupingTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region1);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region2);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(null, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void lastEventFoundAllSendersGroupTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region3);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region4);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(event2, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void lastEventFoundNotAllSendersGroupTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region5);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region6);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(event2, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void notAllEventsToSameGroupingSenders() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxMDA0OA=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE3MDk4Mg==", "bodyText": "Sounds good", "url": "https://github.com/apache/geode/pull/4928#discussion_r423170982", "createdAt": "2020-05-11T16:39:02Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.AssertionsForClassTypes.assertThatThrownBy;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ServiceConfigurationError;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.wan.GatewaySender;\n+\n+public class TXLastEventInTransactionUtilsTest {\n+\n+  public static final String SENDER_1 = \"sender1\";\n+  public static final String SENDER_2 = \"sender2\";\n+  public static final String SENDER_3 = \"sender3\";\n+  public static final String SENDER_4 = \"sender4\";\n+  public static final String SENDER_5 = \"sender5\";\n+\n+  Cache cache;\n+  InternalRegion region1;\n+  InternalRegion region2;\n+  InternalRegion region3;\n+  InternalRegion region4;\n+  InternalRegion region5;\n+  InternalRegion region6;\n+  InternalRegion region7;\n+  InternalRegion region8;\n+\n+  GatewaySender sender1;\n+  GatewaySender sender2;\n+  GatewaySender sender3;\n+  GatewaySender sender4;\n+\n+  @Before\n+  public void setUp() {\n+    sender1 = mock(GatewaySender.class);\n+    when(sender1.isGroupTransactionEvents()).thenReturn(false);\n+    sender2 = mock(GatewaySender.class);\n+    when(sender2.isGroupTransactionEvents()).thenReturn(false);\n+    sender3 = mock(GatewaySender.class);\n+    when(sender3.isGroupTransactionEvents()).thenReturn(true);\n+    sender4 = mock(GatewaySender.class);\n+    when(sender4.isGroupTransactionEvents()).thenReturn(true);\n+\n+    cache = mock(Cache.class);\n+    when(cache.getGatewaySender(SENDER_1)).thenReturn(sender1);\n+    when(cache.getGatewaySender(SENDER_2)).thenReturn(sender2);\n+    when(cache.getGatewaySender(SENDER_3)).thenReturn(sender3);\n+    when(cache.getGatewaySender(SENDER_4)).thenReturn(sender4);\n+    when(cache.getGatewaySender(SENDER_5)).thenReturn(null);\n+\n+    final String listSenderIdsForRegion1_2[] = {SENDER_1, SENDER_2};\n+    final String listSenderIdsForRegion3_4[] = {SENDER_3, SENDER_4};\n+    final String listSenderIdsForRegion5_6[] = {SENDER_1, SENDER_3};\n+    final String listSenderIdsForRegion7[] = {SENDER_3};\n+    final String listSenderIdsForRegion8[] = {SENDER_5};\n+\n+\n+    Set senderIdsForRegion1_2 = new HashSet(Arrays.asList(listSenderIdsForRegion1_2));\n+    Set senderIdsForRegion3_4 = new HashSet(Arrays.asList(listSenderIdsForRegion3_4));\n+    Set senderIdsForRegion5_6 = new HashSet(Arrays.asList(listSenderIdsForRegion5_6));\n+    Set senderIdsForRegion7 = new HashSet(Arrays.asList(listSenderIdsForRegion7));\n+    Set senderIdsForRegion8 = new HashSet(Arrays.asList(listSenderIdsForRegion8));\n+\n+    region1 = mock(InternalRegion.class);\n+    when(region1.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region2 = mock(InternalRegion.class);\n+    when(region2.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region3 = mock(InternalRegion.class);\n+    when(region3.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region4 = mock(InternalRegion.class);\n+    when(region4.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region5 = mock(InternalRegion.class);\n+    when(region5.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region6 = mock(InternalRegion.class);\n+    when(region6.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region7 = mock(InternalRegion.class);\n+    when(region7.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion7);\n+\n+    region8 = mock(InternalRegion.class);\n+    when(region8.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion8);\n+  }\n+\n+  @Test\n+  public void noSenderGroupingTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region1);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region2);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(null, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void lastEventFoundAllSendersGroupTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region3);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region4);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(event2, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void lastEventFoundNotAllSendersGroupTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region5);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region6);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(event2, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void notAllEventsToSameGroupingSenders() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxMDA0OA=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTg2MDM4OnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMjo1MToxNFrOGS13Ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjozOToxOVrOGTkUYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxMDA3NQ==", "bodyText": "This test name could be more descriptive. Also, an exception is never thrown from this method, so the throws can be removed.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422410075", "createdAt": "2020-05-08T22:51:14Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.AssertionsForClassTypes.assertThatThrownBy;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ServiceConfigurationError;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.wan.GatewaySender;\n+\n+public class TXLastEventInTransactionUtilsTest {\n+\n+  public static final String SENDER_1 = \"sender1\";\n+  public static final String SENDER_2 = \"sender2\";\n+  public static final String SENDER_3 = \"sender3\";\n+  public static final String SENDER_4 = \"sender4\";\n+  public static final String SENDER_5 = \"sender5\";\n+\n+  Cache cache;\n+  InternalRegion region1;\n+  InternalRegion region2;\n+  InternalRegion region3;\n+  InternalRegion region4;\n+  InternalRegion region5;\n+  InternalRegion region6;\n+  InternalRegion region7;\n+  InternalRegion region8;\n+\n+  GatewaySender sender1;\n+  GatewaySender sender2;\n+  GatewaySender sender3;\n+  GatewaySender sender4;\n+\n+  @Before\n+  public void setUp() {\n+    sender1 = mock(GatewaySender.class);\n+    when(sender1.isGroupTransactionEvents()).thenReturn(false);\n+    sender2 = mock(GatewaySender.class);\n+    when(sender2.isGroupTransactionEvents()).thenReturn(false);\n+    sender3 = mock(GatewaySender.class);\n+    when(sender3.isGroupTransactionEvents()).thenReturn(true);\n+    sender4 = mock(GatewaySender.class);\n+    when(sender4.isGroupTransactionEvents()).thenReturn(true);\n+\n+    cache = mock(Cache.class);\n+    when(cache.getGatewaySender(SENDER_1)).thenReturn(sender1);\n+    when(cache.getGatewaySender(SENDER_2)).thenReturn(sender2);\n+    when(cache.getGatewaySender(SENDER_3)).thenReturn(sender3);\n+    when(cache.getGatewaySender(SENDER_4)).thenReturn(sender4);\n+    when(cache.getGatewaySender(SENDER_5)).thenReturn(null);\n+\n+    final String listSenderIdsForRegion1_2[] = {SENDER_1, SENDER_2};\n+    final String listSenderIdsForRegion3_4[] = {SENDER_3, SENDER_4};\n+    final String listSenderIdsForRegion5_6[] = {SENDER_1, SENDER_3};\n+    final String listSenderIdsForRegion7[] = {SENDER_3};\n+    final String listSenderIdsForRegion8[] = {SENDER_5};\n+\n+\n+    Set senderIdsForRegion1_2 = new HashSet(Arrays.asList(listSenderIdsForRegion1_2));\n+    Set senderIdsForRegion3_4 = new HashSet(Arrays.asList(listSenderIdsForRegion3_4));\n+    Set senderIdsForRegion5_6 = new HashSet(Arrays.asList(listSenderIdsForRegion5_6));\n+    Set senderIdsForRegion7 = new HashSet(Arrays.asList(listSenderIdsForRegion7));\n+    Set senderIdsForRegion8 = new HashSet(Arrays.asList(listSenderIdsForRegion8));\n+\n+    region1 = mock(InternalRegion.class);\n+    when(region1.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region2 = mock(InternalRegion.class);\n+    when(region2.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region3 = mock(InternalRegion.class);\n+    when(region3.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region4 = mock(InternalRegion.class);\n+    when(region4.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region5 = mock(InternalRegion.class);\n+    when(region5.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region6 = mock(InternalRegion.class);\n+    when(region6.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region7 = mock(InternalRegion.class);\n+    when(region7.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion7);\n+\n+    region8 = mock(InternalRegion.class);\n+    when(region8.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion8);\n+  }\n+\n+  @Test\n+  public void noSenderGroupingTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region1);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region2);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(null, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void lastEventFoundAllSendersGroupTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region3);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region4);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(event2, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void lastEventFoundNotAllSendersGroupTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region5);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region6);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(event2, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void notAllEventsToSameGroupingSenders() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region3);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region7);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    assertThatThrownBy(() -> TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache))\n+        .isInstanceOf(ServiceConfigurationError.class)\n+        .hasMessageContaining(\"Not all events go to the same senders that group transactions\");\n+  }\n+\n+  @Test\n+  public void senderNotFound() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA4ODc3Mg==", "bodyText": "How about getLastTransactionEventThrowsExceptionWhenSenderNotFound?", "url": "https://github.com/apache/geode/pull/4928#discussion_r423088772", "createdAt": "2020-05-11T14:39:32Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.AssertionsForClassTypes.assertThatThrownBy;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ServiceConfigurationError;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.wan.GatewaySender;\n+\n+public class TXLastEventInTransactionUtilsTest {\n+\n+  public static final String SENDER_1 = \"sender1\";\n+  public static final String SENDER_2 = \"sender2\";\n+  public static final String SENDER_3 = \"sender3\";\n+  public static final String SENDER_4 = \"sender4\";\n+  public static final String SENDER_5 = \"sender5\";\n+\n+  Cache cache;\n+  InternalRegion region1;\n+  InternalRegion region2;\n+  InternalRegion region3;\n+  InternalRegion region4;\n+  InternalRegion region5;\n+  InternalRegion region6;\n+  InternalRegion region7;\n+  InternalRegion region8;\n+\n+  GatewaySender sender1;\n+  GatewaySender sender2;\n+  GatewaySender sender3;\n+  GatewaySender sender4;\n+\n+  @Before\n+  public void setUp() {\n+    sender1 = mock(GatewaySender.class);\n+    when(sender1.isGroupTransactionEvents()).thenReturn(false);\n+    sender2 = mock(GatewaySender.class);\n+    when(sender2.isGroupTransactionEvents()).thenReturn(false);\n+    sender3 = mock(GatewaySender.class);\n+    when(sender3.isGroupTransactionEvents()).thenReturn(true);\n+    sender4 = mock(GatewaySender.class);\n+    when(sender4.isGroupTransactionEvents()).thenReturn(true);\n+\n+    cache = mock(Cache.class);\n+    when(cache.getGatewaySender(SENDER_1)).thenReturn(sender1);\n+    when(cache.getGatewaySender(SENDER_2)).thenReturn(sender2);\n+    when(cache.getGatewaySender(SENDER_3)).thenReturn(sender3);\n+    when(cache.getGatewaySender(SENDER_4)).thenReturn(sender4);\n+    when(cache.getGatewaySender(SENDER_5)).thenReturn(null);\n+\n+    final String listSenderIdsForRegion1_2[] = {SENDER_1, SENDER_2};\n+    final String listSenderIdsForRegion3_4[] = {SENDER_3, SENDER_4};\n+    final String listSenderIdsForRegion5_6[] = {SENDER_1, SENDER_3};\n+    final String listSenderIdsForRegion7[] = {SENDER_3};\n+    final String listSenderIdsForRegion8[] = {SENDER_5};\n+\n+\n+    Set senderIdsForRegion1_2 = new HashSet(Arrays.asList(listSenderIdsForRegion1_2));\n+    Set senderIdsForRegion3_4 = new HashSet(Arrays.asList(listSenderIdsForRegion3_4));\n+    Set senderIdsForRegion5_6 = new HashSet(Arrays.asList(listSenderIdsForRegion5_6));\n+    Set senderIdsForRegion7 = new HashSet(Arrays.asList(listSenderIdsForRegion7));\n+    Set senderIdsForRegion8 = new HashSet(Arrays.asList(listSenderIdsForRegion8));\n+\n+    region1 = mock(InternalRegion.class);\n+    when(region1.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region2 = mock(InternalRegion.class);\n+    when(region2.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region3 = mock(InternalRegion.class);\n+    when(region3.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region4 = mock(InternalRegion.class);\n+    when(region4.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region5 = mock(InternalRegion.class);\n+    when(region5.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region6 = mock(InternalRegion.class);\n+    when(region6.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region7 = mock(InternalRegion.class);\n+    when(region7.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion7);\n+\n+    region8 = mock(InternalRegion.class);\n+    when(region8.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion8);\n+  }\n+\n+  @Test\n+  public void noSenderGroupingTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region1);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region2);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(null, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void lastEventFoundAllSendersGroupTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region3);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region4);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(event2, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void lastEventFoundNotAllSendersGroupTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region5);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region6);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(event2, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void notAllEventsToSameGroupingSenders() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region3);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region7);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    assertThatThrownBy(() -> TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache))\n+        .isInstanceOf(ServiceConfigurationError.class)\n+        .hasMessageContaining(\"Not all events go to the same senders that group transactions\");\n+  }\n+\n+  @Test\n+  public void senderNotFound() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxMDA3NQ=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE3MTE2OA==", "bodyText": "Sounds good", "url": "https://github.com/apache/geode/pull/4928#discussion_r423171168", "createdAt": "2020-05-11T16:39:19Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.AssertionsForClassTypes.assertThatThrownBy;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ServiceConfigurationError;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.wan.GatewaySender;\n+\n+public class TXLastEventInTransactionUtilsTest {\n+\n+  public static final String SENDER_1 = \"sender1\";\n+  public static final String SENDER_2 = \"sender2\";\n+  public static final String SENDER_3 = \"sender3\";\n+  public static final String SENDER_4 = \"sender4\";\n+  public static final String SENDER_5 = \"sender5\";\n+\n+  Cache cache;\n+  InternalRegion region1;\n+  InternalRegion region2;\n+  InternalRegion region3;\n+  InternalRegion region4;\n+  InternalRegion region5;\n+  InternalRegion region6;\n+  InternalRegion region7;\n+  InternalRegion region8;\n+\n+  GatewaySender sender1;\n+  GatewaySender sender2;\n+  GatewaySender sender3;\n+  GatewaySender sender4;\n+\n+  @Before\n+  public void setUp() {\n+    sender1 = mock(GatewaySender.class);\n+    when(sender1.isGroupTransactionEvents()).thenReturn(false);\n+    sender2 = mock(GatewaySender.class);\n+    when(sender2.isGroupTransactionEvents()).thenReturn(false);\n+    sender3 = mock(GatewaySender.class);\n+    when(sender3.isGroupTransactionEvents()).thenReturn(true);\n+    sender4 = mock(GatewaySender.class);\n+    when(sender4.isGroupTransactionEvents()).thenReturn(true);\n+\n+    cache = mock(Cache.class);\n+    when(cache.getGatewaySender(SENDER_1)).thenReturn(sender1);\n+    when(cache.getGatewaySender(SENDER_2)).thenReturn(sender2);\n+    when(cache.getGatewaySender(SENDER_3)).thenReturn(sender3);\n+    when(cache.getGatewaySender(SENDER_4)).thenReturn(sender4);\n+    when(cache.getGatewaySender(SENDER_5)).thenReturn(null);\n+\n+    final String listSenderIdsForRegion1_2[] = {SENDER_1, SENDER_2};\n+    final String listSenderIdsForRegion3_4[] = {SENDER_3, SENDER_4};\n+    final String listSenderIdsForRegion5_6[] = {SENDER_1, SENDER_3};\n+    final String listSenderIdsForRegion7[] = {SENDER_3};\n+    final String listSenderIdsForRegion8[] = {SENDER_5};\n+\n+\n+    Set senderIdsForRegion1_2 = new HashSet(Arrays.asList(listSenderIdsForRegion1_2));\n+    Set senderIdsForRegion3_4 = new HashSet(Arrays.asList(listSenderIdsForRegion3_4));\n+    Set senderIdsForRegion5_6 = new HashSet(Arrays.asList(listSenderIdsForRegion5_6));\n+    Set senderIdsForRegion7 = new HashSet(Arrays.asList(listSenderIdsForRegion7));\n+    Set senderIdsForRegion8 = new HashSet(Arrays.asList(listSenderIdsForRegion8));\n+\n+    region1 = mock(InternalRegion.class);\n+    when(region1.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region2 = mock(InternalRegion.class);\n+    when(region2.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region3 = mock(InternalRegion.class);\n+    when(region3.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region4 = mock(InternalRegion.class);\n+    when(region4.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region5 = mock(InternalRegion.class);\n+    when(region5.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region6 = mock(InternalRegion.class);\n+    when(region6.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region7 = mock(InternalRegion.class);\n+    when(region7.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion7);\n+\n+    region8 = mock(InternalRegion.class);\n+    when(region8.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion8);\n+  }\n+\n+  @Test\n+  public void noSenderGroupingTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region1);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region2);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(null, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void lastEventFoundAllSendersGroupTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region3);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region4);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(event2, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void lastEventFoundNotAllSendersGroupTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region5);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region6);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(event2, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void notAllEventsToSameGroupingSenders() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region3);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region7);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    assertThatThrownBy(() -> TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache))\n+        .isInstanceOf(ServiceConfigurationError.class)\n+        .hasMessageContaining(\"Not all events go to the same senders that group transactions\");\n+  }\n+\n+  @Test\n+  public void senderNotFound() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxMDA3NQ=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 174}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTg4MzE3OnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMzowNjo0N1rOGS2FXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjo0MTo1NlrOGTkanw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxMzY2Mw==", "bodyText": "This test name could be more descriptive.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422413663", "createdAt": "2020-05-08T23:06:47Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {\n     assertThat(queue.isDREvent(cache, event)).isFalse();\n   }\n \n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzEwNTg2MA==", "bodyText": "How about this pretty long name peekGetsExtraEventsWhenMustGroupTransactionEventsAndNotAllEventsForTransactionsInMaxSizeBatch?", "url": "https://github.com/apache/geode/pull/4928#discussion_r423105860", "createdAt": "2020-05-11T15:02:50Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {\n     assertThat(queue.isDREvent(cache, event)).isFalse();\n   }\n \n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxMzY2Mw=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE3Mjc2Nw==", "bodyText": "Sounds good. I will take a long, descriptive test name over a short, vague one any day :)", "url": "https://github.com/apache/geode/pull/4928#discussion_r423172767", "createdAt": "2020-05-11T16:41:56Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {\n     assertThat(queue.isDREvent(cache, event)).isFalse();\n   }\n \n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxMzY2Mw=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTg4NDA3OnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMzowNzoyNVrOGS2F9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjo0MjoyNVrOGTkbyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxMzgxNA==", "bodyText": "This test name could be more descriptive.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422413814", "createdAt": "2020-05-08T23:07:25Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {\n     assertThat(queue.isDREvent(cache, event)).isFalse();\n   }\n \n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsAndTimeout()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzEwNjEwOA==", "bodyText": "How about peekGetsExtraEventsWhenMustGroupTransactionEventsAndNotAllEventsForTransactionsInBatchByTime?", "url": "https://github.com/apache/geode/pull/4928#discussion_r423106108", "createdAt": "2020-05-11T15:03:13Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {\n     assertThat(queue.isDREvent(cache, event)).isFalse();\n   }\n \n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsAndTimeout()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxMzgxNA=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE3MzA2NQ==", "bodyText": "Sounds good", "url": "https://github.com/apache/geode/pull/4928#discussion_r423173065", "createdAt": "2020-05-11T16:42:25Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {\n     assertThat(queue.isDREvent(cache, event)).isFalse();\n   }\n \n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsAndTimeout()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxMzgxNA=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTg4NDI2OnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMzowNzozNlrOGS2GFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjo0Mjo0MlrOGTkccA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxMzg0NQ==", "bodyText": "This test name could be more descriptive.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422413845", "createdAt": "2020-05-08T23:07:36Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {\n     assertThat(queue.isDREvent(cache, event)).isFalse();\n   }\n \n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsAndTimeout()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(null);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(-1, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzEwNjUyNQ==", "bodyText": "How about peekDoesNotGetsExtraEventsWhenNotMustGroupTransactionEventsAndNotAllEventsForTransactionsInBatchMaxSize?", "url": "https://github.com/apache/geode/pull/4928#discussion_r423106525", "createdAt": "2020-05-11T15:03:48Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {\n     assertThat(queue.isDREvent(cache, event)).isFalse();\n   }\n \n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsAndTimeout()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(null);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(-1, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxMzg0NQ=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE3MzIzMg==", "bodyText": "Sounds good", "url": "https://github.com/apache/geode/pull/4928#discussion_r423173232", "createdAt": "2020-05-11T16:42:42Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {\n     assertThat(queue.isDREvent(cache, event)).isFalse();\n   }\n \n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsAndTimeout()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(null);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(-1, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxMzg0NQ=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTkwMjc4OnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMzoyMDoxNVrOGS2Q8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjo0NzoxMFrOGTknTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNjYyNg==", "bodyText": "This method does not need to be static.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422416626", "createdAt": "2020-05-08T23:20:15Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {\n     assertThat(queue.isDREvent(cache, event)).isFalse();\n   }\n \n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsAndTimeout()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(null);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(-1, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(2, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(3, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  private static GatewaySenderEventImpl createGatewaySenderEventImpl(int transactionId,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzExOTg3Ng==", "bodyText": "That's true. Anyway, do you see any drawback in it being static?", "url": "https://github.com/apache/geode/pull/4928#discussion_r423119876", "createdAt": "2020-05-11T15:22:27Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {\n     assertThat(queue.isDREvent(cache, event)).isFalse();\n   }\n \n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsAndTimeout()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(null);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(-1, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(2, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(3, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  private static GatewaySenderEventImpl createGatewaySenderEventImpl(int transactionId,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNjYyNg=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE3NjAxNA==", "bodyText": "No drawback, it just keeps things more consistent within the test if all the helper methods follow the same pattern, and none of the other ones are static.", "url": "https://github.com/apache/geode/pull/4928#discussion_r423176014", "createdAt": "2020-05-11T16:47:10Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {\n     assertThat(queue.isDREvent(cache, event)).isFalse();\n   }\n \n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsAndTimeout()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(null);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(-1, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(2, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(3, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  private static GatewaySenderEventImpl createGatewaySenderEventImpl(int transactionId,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNjYyNg=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTkwNTg1OnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMzoyMjozOVrOGS2S1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNTo1Nzo0NFrOGTisQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNzEwOA==", "bodyText": "Does the value of timeToWait here need to be so large? Unit tests should typically be expected to complete in milliseconds, so having an entire second timeout seems excessive. Also, is there a reason for this value of 1000 specifically being used? It seems arbitrary.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422417108", "createdAt": "2020-05-08T23:22:39Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {\n     assertThat(queue.isDREvent(cache, event)).isFalse();\n   }\n \n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE0NDUxMg==", "bodyText": "Not really. The value is not relevant in this case where a value for max batch size has been set.\nI have changed it to 100ms.", "url": "https://github.com/apache/geode/pull/4928#discussion_r423144512", "createdAt": "2020-05-11T15:57:44Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {\n     assertThat(queue.isDREvent(cache, event)).isFalse();\n   }\n \n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNzEwOA=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTkwNjA3OnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMzoyMjo1NlrOGS2S-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNTo1Nzo1NVrOGTis8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNzE0Ng==", "bodyText": "Another large, apparently arbitrary timeToWait value.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422417146", "createdAt": "2020-05-08T23:22:56Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {\n     assertThat(queue.isDREvent(cache, event)).isFalse();\n   }\n \n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE0NDY4OQ==", "bodyText": "Same as above.", "url": "https://github.com/apache/geode/pull/4928#discussion_r423144689", "createdAt": "2020-05-11T15:57:55Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {\n     assertThat(queue.isDREvent(cache, event)).isFalse();\n   }\n \n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNzE0Ng=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTkwNjk5OnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMzoyMzoyOVrOGS2TeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNTo1ODowM1rOGTitOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNzI3Mw==", "bodyText": "Another large, apparently arbitrary timeToWait value.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422417273", "createdAt": "2020-05-08T23:23:29Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {\n     assertThat(queue.isDREvent(cache, event)).isFalse();\n   }\n \n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsAndTimeout()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(null);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(-1, 1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE0NDc2Mw==", "bodyText": "Same as above.", "url": "https://github.com/apache/geode/pull/4928#discussion_r423144763", "createdAt": "2020-05-11T15:58:03Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {\n     assertThat(queue.isDREvent(cache, event)).isFalse();\n   }\n \n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsAndTimeout()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(null);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(-1, 1000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNzI3Mw=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTkwNzc1OnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMzoyMzo1OFrOGS2T5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNTo1ODoxMlrOGTitow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNzM4MA==", "bodyText": "Another large, apparently arbitrary timeToWait value.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422417380", "createdAt": "2020-05-08T23:23:58Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {\n     assertThat(queue.isDREvent(cache, event)).isFalse();\n   }\n \n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsAndTimeout()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(null);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(-1, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(2, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE0NDg2Nw==", "bodyText": "Same as above.", "url": "https://github.com/apache/geode/pull/4928#discussion_r423144867", "createdAt": "2020-05-11T15:58:12Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {\n     assertThat(queue.isDREvent(cache, event)).isFalse();\n   }\n \n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsAndTimeout()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(null);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(-1, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(2, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNzM4MA=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTkwNzg1OnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMzoyNDowNFrOGS2T8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNTo1ODoxOVrOGTiuCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNzM5Mw==", "bodyText": "Another large, apparently arbitrary timeToWait value.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422417393", "createdAt": "2020-05-08T23:24:04Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {\n     assertThat(queue.isDREvent(cache, event)).isFalse();\n   }\n \n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsAndTimeout()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(null);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(-1, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(2, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(3, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE0NDk2OQ==", "bodyText": "Same as above.", "url": "https://github.com/apache/geode/pull/4928#discussion_r423144969", "createdAt": "2020-05-11T15:58:19Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {\n     assertThat(queue.isDREvent(cache, event)).isFalse();\n   }\n \n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsAndTimeout()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(null);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(-1, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(2, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(3, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNzM5Mw=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTkwODUwOnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMzoyNDozMlrOGS2UWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjowNToxNlrOGTjANQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNzQ5Ng==", "bodyText": "What is the purpose of waiting here? Thread.sleep() should be avoided in tests as it leads to flakiness, so is there something that can be used with GeodeAwaitility.await() instead?", "url": "https://github.com/apache/geode/pull/4928#discussion_r422417496", "createdAt": "2020-05-08T23:24:32Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -201,18 +306,40 @@ private BucketRegionQueue mockBucketRegionQueue(final Queue backingList) {\n     // mocked pr region\n     when(mockBucketRegion.getLocalMaxMemory()).thenReturn(100);\n     when(mockBucketRegion.size()).thenReturn(backingList.size());\n-\n     BucketRegionQueue bucketRegionQueue = mock(BucketRegionQueue.class);\n     when(bucketRegionQueue.getPartitionedRegion()).thenReturn(mockBucketRegion);\n-    when(bucketRegionQueue.peek()).thenAnswer((Answer) invocation -> backingList.poll());\n+    when(bucketRegionQueue.peek())\n+        .thenAnswer((Answer) invocation -> pollAndWaitIfNull(backingList));\n+    when(bucketRegionQueue.getElementsMatching(any(), any()))\n+        .thenAnswer((Answer) invocation -> Arrays\n+            .asList(new Object[] {getFirstNotNull(backingList)}));\n     return bucketRegionQueue;\n   }\n \n+  private Object pollAndWaitIfNull(Queue queue) {\n+    Object object = queue.poll();\n+    if (object == null) {\n+      try {\n+        Thread.sleep(10);\n+      } catch (InterruptedException e) {\n+        e.printStackTrace();\n+      }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE0OTYyMQ==", "bodyText": "It is a way to simulate some delay in the arrival of events to the queue. If a null element is found in the queue, some delay is added to the polling execution in order to be used in cases where the batch must be finished, not because the max size was reached but because the peeking took longer than the timeToWait passed.", "url": "https://github.com/apache/geode/pull/4928#discussion_r423149621", "createdAt": "2020-05-11T16:05:16Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -201,18 +306,40 @@ private BucketRegionQueue mockBucketRegionQueue(final Queue backingList) {\n     // mocked pr region\n     when(mockBucketRegion.getLocalMaxMemory()).thenReturn(100);\n     when(mockBucketRegion.size()).thenReturn(backingList.size());\n-\n     BucketRegionQueue bucketRegionQueue = mock(BucketRegionQueue.class);\n     when(bucketRegionQueue.getPartitionedRegion()).thenReturn(mockBucketRegion);\n-    when(bucketRegionQueue.peek()).thenAnswer((Answer) invocation -> backingList.poll());\n+    when(bucketRegionQueue.peek())\n+        .thenAnswer((Answer) invocation -> pollAndWaitIfNull(backingList));\n+    when(bucketRegionQueue.getElementsMatching(any(), any()))\n+        .thenAnswer((Answer) invocation -> Arrays\n+            .asList(new Object[] {getFirstNotNull(backingList)}));\n     return bucketRegionQueue;\n   }\n \n+  private Object pollAndWaitIfNull(Queue queue) {\n+    Object object = queue.poll();\n+    if (object == null) {\n+      try {\n+        Thread.sleep(10);\n+      } catch (InterruptedException e) {\n+        e.printStackTrace();\n+      }\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNzQ5Ng=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTkxMzk4OnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMzoyODozN1rOGS2Xmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjo1NzoxMFrOGTlAHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODMzMA==", "bodyText": "This test name could be more descriptive. Also, an exception is never thrown from this method, so the throws can be removed.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422418330", "createdAt": "2020-05-08T23:28:37Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE1MDUyOA==", "bodyText": "How about peekGetsExtraEventsWhenMustGroupTransactionEventsAndNotAllEventsForTransactionsInMaxSizeBatch?", "url": "https://github.com/apache/geode/pull/4928#discussion_r423150528", "createdAt": "2020-05-11T16:06:39Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODMzMA=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4MjM2NQ==", "bodyText": "Sounds good", "url": "https://github.com/apache/geode/pull/4928#discussion_r423182365", "createdAt": "2020-05-11T16:57:10Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODMzMA=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTkxNDEwOnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMzoyODo0MlrOGS2XrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjo1NzoyNlrOGTlAxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODM0OA==", "bodyText": "This test name could be more descriptive. Also, an exception is never thrown from this method, so the throws can be removed.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422418348", "createdAt": "2020-05-08T23:28:42Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+    queue.put(event6);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsTimeout()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE1MDkwMA==", "bodyText": "How about peekGetsExtraEventsWhenMustGroupTransactionEventsAndNotAllEventsForTransactionsInBatchByTime?", "url": "https://github.com/apache/geode/pull/4928#discussion_r423150900", "createdAt": "2020-05-11T16:07:13Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+    queue.put(event6);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsTimeout()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODM0OA=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4MjUzMg==", "bodyText": "Sounds good", "url": "https://github.com/apache/geode/pull/4928#discussion_r423182532", "createdAt": "2020-05-11T16:57:26Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+    queue.put(event6);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsTimeout()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODM0OA=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTkxNDQyOnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMzoyODo1MFrOGS2X1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjo1Nzo0N1rOGTlB4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODM5MA==", "bodyText": "This test name could be more descriptive. Also, an exception is never thrown from this method, so the throws can be removed.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422418390", "createdAt": "2020-05-08T23:28:50Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+    queue.put(event6);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsTimeout()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair1 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(0L, event1);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair2 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(1L, event2);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair3 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(2L, event3);\n+\n+    TestableSerialGatewaySenderQueue realQueue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    TestableSerialGatewaySenderQueue queue = spy(realQueue);\n+    queue.setGroupTransactionEvents(true);\n+\n+    doAnswer(invocation -> eventPair1)\n+        .doAnswer(invocation -> eventPair2)\n+        .doAnswer(invocation -> eventPair3)\n+        .doAnswer(invocation -> null)\n+        .when(queue).peekAhead();\n+\n+    doAnswer(invocation -> new SerialGatewaySenderQueue.EventsAndLastKey(\n+        Arrays.asList(new Object[] {event4}), 2L))\n+            .when(queue).getElementsMatching(any(), any(), anyLong());\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE1MjA1OQ==", "bodyText": "How about peekDoesNotGetExtraEventsWhenNotMustGroupTransactionEventsAndNotAllEventsForTransactionsInBatchMaxSize?", "url": "https://github.com/apache/geode/pull/4928#discussion_r423152059", "createdAt": "2020-05-11T16:08:56Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+    queue.put(event6);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsTimeout()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair1 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(0L, event1);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair2 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(1L, event2);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair3 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(2L, event3);\n+\n+    TestableSerialGatewaySenderQueue realQueue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    TestableSerialGatewaySenderQueue queue = spy(realQueue);\n+    queue.setGroupTransactionEvents(true);\n+\n+    doAnswer(invocation -> eventPair1)\n+        .doAnswer(invocation -> eventPair2)\n+        .doAnswer(invocation -> eventPair3)\n+        .doAnswer(invocation -> null)\n+        .when(queue).peekAhead();\n+\n+    doAnswer(invocation -> new SerialGatewaySenderQueue.EventsAndLastKey(\n+        Arrays.asList(new Object[] {event4}), 2L))\n+            .when(queue).getElementsMatching(any(), any(), anyLong());\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODM5MA=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4MjgxNw==", "bodyText": "Sounds good", "url": "https://github.com/apache/geode/pull/4928#discussion_r423182817", "createdAt": "2020-05-11T16:57:47Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+    queue.put(event6);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsTimeout()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair1 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(0L, event1);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair2 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(1L, event2);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair3 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(2L, event3);\n+\n+    TestableSerialGatewaySenderQueue realQueue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    TestableSerialGatewaySenderQueue queue = spy(realQueue);\n+    queue.setGroupTransactionEvents(true);\n+\n+    doAnswer(invocation -> eventPair1)\n+        .doAnswer(invocation -> eventPair2)\n+        .doAnswer(invocation -> eventPair3)\n+        .doAnswer(invocation -> null)\n+        .when(queue).peekAhead();\n+\n+    doAnswer(invocation -> new SerialGatewaySenderQueue.EventsAndLastKey(\n+        Arrays.asList(new Object[] {event4}), 2L))\n+            .when(queue).getElementsMatching(any(), any(), anyLong());\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODM5MA=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 173}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTkxNjA4OnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMzoyOTo1M1rOGS2YvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjo1ODoyNlrOGTlDgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODYyMQ==", "bodyText": "This method doesn't need to be static.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422418621", "createdAt": "2020-05-08T23:29:53Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+    queue.put(event6);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsTimeout()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair1 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(0L, event1);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair2 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(1L, event2);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair3 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(2L, event3);\n+\n+    TestableSerialGatewaySenderQueue realQueue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    TestableSerialGatewaySenderQueue queue = spy(realQueue);\n+    queue.setGroupTransactionEvents(true);\n+\n+    doAnswer(invocation -> eventPair1)\n+        .doAnswer(invocation -> eventPair2)\n+        .doAnswer(invocation -> eventPair3)\n+        .doAnswer(invocation -> null)\n+        .when(queue).peekAhead();\n+\n+    doAnswer(invocation -> new SerialGatewaySenderQueue.EventsAndLastKey(\n+        Arrays.asList(new Object[] {event4}), 2L))\n+            .when(queue).getElementsMatching(any(), any(), anyLong());\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(2, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(3, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  private static GatewaySenderEventImpl createMockGatewaySenderEventImpl(int transactionId,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE1MjI4Nw==", "bodyText": "True. Any drawback?", "url": "https://github.com/apache/geode/pull/4928#discussion_r423152287", "createdAt": "2020-05-11T16:09:16Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+    queue.put(event6);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsTimeout()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair1 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(0L, event1);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair2 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(1L, event2);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair3 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(2L, event3);\n+\n+    TestableSerialGatewaySenderQueue realQueue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    TestableSerialGatewaySenderQueue queue = spy(realQueue);\n+    queue.setGroupTransactionEvents(true);\n+\n+    doAnswer(invocation -> eventPair1)\n+        .doAnswer(invocation -> eventPair2)\n+        .doAnswer(invocation -> eventPair3)\n+        .doAnswer(invocation -> null)\n+        .when(queue).peekAhead();\n+\n+    doAnswer(invocation -> new SerialGatewaySenderQueue.EventsAndLastKey(\n+        Arrays.asList(new Object[] {event4}), 2L))\n+            .when(queue).getElementsMatching(any(), any(), anyLong());\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(2, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(3, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  private static GatewaySenderEventImpl createMockGatewaySenderEventImpl(int transactionId,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODYyMQ=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4MzIzMg==", "bodyText": "Just for consistency with other helper methods in the class.", "url": "https://github.com/apache/geode/pull/4928#discussion_r423183232", "createdAt": "2020-05-11T16:58:26Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+    queue.put(event6);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsTimeout()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair1 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(0L, event1);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair2 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(1L, event2);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair3 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(2L, event3);\n+\n+    TestableSerialGatewaySenderQueue realQueue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    TestableSerialGatewaySenderQueue queue = spy(realQueue);\n+    queue.setGroupTransactionEvents(true);\n+\n+    doAnswer(invocation -> eventPair1)\n+        .doAnswer(invocation -> eventPair2)\n+        .doAnswer(invocation -> eventPair3)\n+        .doAnswer(invocation -> null)\n+        .when(queue).peekAhead();\n+\n+    doAnswer(invocation -> new SerialGatewaySenderQueue.EventsAndLastKey(\n+        Arrays.asList(new Object[] {event4}), 2L))\n+            .when(queue).getElementsMatching(any(), any(), anyLong());\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(2, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(3, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  private static GatewaySenderEventImpl createMockGatewaySenderEventImpl(int transactionId,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODYyMQ=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 196}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTkxNzIzOnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMzozMDo0MlrOGS2ZYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjoxMzo1NVrOGTjWBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODc4Ng==", "bodyText": "Does the value of timeToWait here need to be so large? Unit tests should typically be expected to complete in milliseconds, so having an entire second timeout seems excessive. Also, is there a reason for this value of 1000 specifically being used? It seems arbitrary.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422418786", "createdAt": "2020-05-08T23:30:42Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+    queue.put(event6);\n+\n+    List peeked = queue.peek(3, 1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE1NTIwNg==", "bodyText": "Not really. The same comment applies here to what was explained for ParallelGatewaySenderQueueJunitTest", "url": "https://github.com/apache/geode/pull/4928#discussion_r423155206", "createdAt": "2020-05-11T16:13:55Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+    queue.put(event6);\n+\n+    List peeked = queue.peek(3, 1000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODc4Ng=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTkxNzY4OnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMzozMTowM1rOGS2Zqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjoxNDowOFrOGTjWkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODg1OA==", "bodyText": "Another large, seemingly arbitrary timeToWait value.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422418858", "createdAt": "2020-05-08T23:31:03Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+    queue.put(event6);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE1NTM0Nw==", "bodyText": "Same as above.", "url": "https://github.com/apache/geode/pull/4928#discussion_r423155347", "createdAt": "2020-05-11T16:14:08Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+    queue.put(event6);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODg1OA=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTkxODAzOnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMzozMToxOFrOGS2Z3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjoxNDoxNlrOGTjW_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODkxMQ==", "bodyText": "Another large, seemingly arbitrary timeToWait value.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422418911", "createdAt": "2020-05-08T23:31:18Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+    queue.put(event6);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsTimeout()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair1 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(0L, event1);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair2 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(1L, event2);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair3 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(2L, event3);\n+\n+    TestableSerialGatewaySenderQueue realQueue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    TestableSerialGatewaySenderQueue queue = spy(realQueue);\n+    queue.setGroupTransactionEvents(true);\n+\n+    doAnswer(invocation -> eventPair1)\n+        .doAnswer(invocation -> eventPair2)\n+        .doAnswer(invocation -> eventPair3)\n+        .doAnswer(invocation -> null)\n+        .when(queue).peekAhead();\n+\n+    doAnswer(invocation -> new SerialGatewaySenderQueue.EventsAndLastKey(\n+        Arrays.asList(new Object[] {event4}), 2L))\n+            .when(queue).getElementsMatching(any(), any(), anyLong());\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(2, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+\n+    List peeked = queue.peek(3, 1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE1NTQ1Mg==", "bodyText": "Same as above.", "url": "https://github.com/apache/geode/pull/4928#discussion_r423155452", "createdAt": "2020-05-11T16:14:16Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+    queue.put(event6);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsTimeout()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair1 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(0L, event1);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair2 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(1L, event2);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair3 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(2L, event3);\n+\n+    TestableSerialGatewaySenderQueue realQueue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    TestableSerialGatewaySenderQueue queue = spy(realQueue);\n+    queue.setGroupTransactionEvents(true);\n+\n+    doAnswer(invocation -> eventPair1)\n+        .doAnswer(invocation -> eventPair2)\n+        .doAnswer(invocation -> eventPair3)\n+        .doAnswer(invocation -> null)\n+        .when(queue).peekAhead();\n+\n+    doAnswer(invocation -> new SerialGatewaySenderQueue.EventsAndLastKey(\n+        Arrays.asList(new Object[] {event4}), 2L))\n+            .when(queue).getElementsMatching(any(), any(), anyLong());\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(2, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+\n+    List peeked = queue.peek(3, 1000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODkxMQ=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 190}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTkxODA4OnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMzozMToyMlrOGS2Z5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjoxNDozNVrOGTjXrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODkxOQ==", "bodyText": "Another large, seemingly arbitrary timeToWait value.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422418919", "createdAt": "2020-05-08T23:31:22Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+    queue.put(event6);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsTimeout()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair1 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(0L, event1);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair2 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(1L, event2);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair3 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(2L, event3);\n+\n+    TestableSerialGatewaySenderQueue realQueue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    TestableSerialGatewaySenderQueue queue = spy(realQueue);\n+    queue.setGroupTransactionEvents(true);\n+\n+    doAnswer(invocation -> eventPair1)\n+        .doAnswer(invocation -> eventPair2)\n+        .doAnswer(invocation -> eventPair3)\n+        .doAnswer(invocation -> null)\n+        .when(queue).peekAhead();\n+\n+    doAnswer(invocation -> new SerialGatewaySenderQueue.EventsAndLastKey(\n+        Arrays.asList(new Object[] {event4}), 2L))\n+            .when(queue).getElementsMatching(any(), any(), anyLong());\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(2, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(3, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE1NTYyOA==", "bodyText": "Same as above.", "url": "https://github.com/apache/geode/pull/4928#discussion_r423155628", "createdAt": "2020-05-11T16:14:35Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+    queue.put(event6);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsTimeout()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair1 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(0L, event1);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair2 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(1L, event2);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair3 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(2L, event3);\n+\n+    TestableSerialGatewaySenderQueue realQueue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    TestableSerialGatewaySenderQueue queue = spy(realQueue);\n+    queue.setGroupTransactionEvents(true);\n+\n+    doAnswer(invocation -> eventPair1)\n+        .doAnswer(invocation -> eventPair2)\n+        .doAnswer(invocation -> eventPair3)\n+        .doAnswer(invocation -> null)\n+        .when(queue).peekAhead();\n+\n+    doAnswer(invocation -> new SerialGatewaySenderQueue.EventsAndLastKey(\n+        Arrays.asList(new Object[] {event4}), 2L))\n+            .when(queue).getElementsMatching(any(), any(), anyLong());\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(2, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(3, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODkxOQ=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 192}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTkyNjQ4OnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMzozNzozMlrOGS2euA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxODo1MTowN1rOGUUZJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMDE1Mg==", "bodyText": "Is there a way to test the new behaviour in SerialGatewaySenderQueue without creating an entire LocalRegion object here? Huge amounts of code that doesn't belong to SerialGatewaySenderQueue are being included in this test due to creating a real LocalRegion. If not, then this test should be an integration test rather than a unit test.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422420152", "createdAt": "2020-05-08T23:37:32Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+    queue.put(event6);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsTimeout()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair1 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(0L, event1);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair2 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(1L, event2);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair3 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(2L, event3);\n+\n+    TestableSerialGatewaySenderQueue realQueue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    TestableSerialGatewaySenderQueue queue = spy(realQueue);\n+    queue.setGroupTransactionEvents(true);\n+\n+    doAnswer(invocation -> eventPair1)\n+        .doAnswer(invocation -> eventPair2)\n+        .doAnswer(invocation -> eventPair3)\n+        .doAnswer(invocation -> null)\n+        .when(queue).peekAhead();\n+\n+    doAnswer(invocation -> new SerialGatewaySenderQueue.EventsAndLastKey(\n+        Arrays.asList(new Object[] {event4}), 2L))\n+            .when(queue).getElementsMatching(any(), any(), anyLong());\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(2, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(3, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  private static GatewaySenderEventImpl createMockGatewaySenderEventImpl(int transactionId,\n+      boolean isLastEventInTransaction, Region region) {\n+    GatewaySenderEventImpl event = mock(GatewaySenderEventImpl.class);\n+    when(event.getTransactionId()).thenReturn(new TXId(null, transactionId));\n+    when(event.makeHeapCopyIfOffHeap()).thenReturn(event);\n+    when(event.isLastEventInTransaction()).thenReturn(isLastEventInTransaction);\n+    when(event.getRegion()).thenReturn(region);\n+    return event;\n+  }\n+\n+  private Region createDistributedRegion(String regionName, Cache cache) {\n+    AttributesFactory factory = new AttributesFactory();\n+    factory.setScope(Scope.DISTRIBUTED_ACK);\n+    factory.setDataPolicy(DataPolicy.NORMAL);\n+    RegionAttributes attrs = factory.create();\n+    InternalRegionArguments internalRegionArgs = new InternalRegionArguments();\n+    return new TestLocalRegion(regionName, attrs, null, (InternalCache) cache, internalRegionArgs,\n+        new TestStatisticsClock());\n+  }\n+\n+  public class TestLocalRegion extends LocalRegion {\n+    Map map = new ConcurrentHashMap();\n+\n+    public TestLocalRegion(String regionName, RegionAttributes attrs,\n+        LocalRegion parentRegion, InternalCache cache,\n+        InternalRegionArguments internalRegionArgs,\n+        StatisticsClock statisticsClock) {\n+      super(regionName, attrs, parentRegion, cache, internalRegionArgs, statisticsClock);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzczMzc2OQ==", "bodyText": "I did not find a way to test SerialGatewaySenderQueue without creating a LocalRegion. The thing is the queue is backed up by a Region while in the ParallelGatewaySenderQueue it is an easily mockable class.\nI could try mocking the LocalRegion but not sure how complex the mock would be.\nI will give it a try.\nI checked to see what an alternative integration test would look like but it looked to me it would need a lot of code too and did not find any example to have a clear idea on how to start.\nI think it is best to try to have this as a unit test. Plus, I think it is cool that we also have the JUnit version for the SerialGatewaySenderQueue just as we do with the ParallelGatewaySenderQueue.", "url": "https://github.com/apache/geode/pull/4928#discussion_r423733769", "createdAt": "2020-05-12T13:30:20Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+    queue.put(event6);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsTimeout()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair1 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(0L, event1);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair2 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(1L, event2);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair3 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(2L, event3);\n+\n+    TestableSerialGatewaySenderQueue realQueue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    TestableSerialGatewaySenderQueue queue = spy(realQueue);\n+    queue.setGroupTransactionEvents(true);\n+\n+    doAnswer(invocation -> eventPair1)\n+        .doAnswer(invocation -> eventPair2)\n+        .doAnswer(invocation -> eventPair3)\n+        .doAnswer(invocation -> null)\n+        .when(queue).peekAhead();\n+\n+    doAnswer(invocation -> new SerialGatewaySenderQueue.EventsAndLastKey(\n+        Arrays.asList(new Object[] {event4}), 2L))\n+            .when(queue).getElementsMatching(any(), any(), anyLong());\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(2, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(3, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  private static GatewaySenderEventImpl createMockGatewaySenderEventImpl(int transactionId,\n+      boolean isLastEventInTransaction, Region region) {\n+    GatewaySenderEventImpl event = mock(GatewaySenderEventImpl.class);\n+    when(event.getTransactionId()).thenReturn(new TXId(null, transactionId));\n+    when(event.makeHeapCopyIfOffHeap()).thenReturn(event);\n+    when(event.isLastEventInTransaction()).thenReturn(isLastEventInTransaction);\n+    when(event.getRegion()).thenReturn(region);\n+    return event;\n+  }\n+\n+  private Region createDistributedRegion(String regionName, Cache cache) {\n+    AttributesFactory factory = new AttributesFactory();\n+    factory.setScope(Scope.DISTRIBUTED_ACK);\n+    factory.setDataPolicy(DataPolicy.NORMAL);\n+    RegionAttributes attrs = factory.create();\n+    InternalRegionArguments internalRegionArgs = new InternalRegionArguments();\n+    return new TestLocalRegion(regionName, attrs, null, (InternalCache) cache, internalRegionArgs,\n+        new TestStatisticsClock());\n+  }\n+\n+  public class TestLocalRegion extends LocalRegion {\n+    Map map = new ConcurrentHashMap();\n+\n+    public TestLocalRegion(String regionName, RegionAttributes attrs,\n+        LocalRegion parentRegion, InternalCache cache,\n+        InternalRegionArguments internalRegionArgs,\n+        StatisticsClock statisticsClock) {\n+      super(regionName, attrs, parentRegion, cache, internalRegionArgs, statisticsClock);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMDE1Mg=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5MjQ5MA==", "bodyText": "Okay, if it's too much work to mock out the LocalRegion then this test can stay as it is. There are a lot of classes in Geode which are hard to unit test, and this PR isn't about trying to refactor them.", "url": "https://github.com/apache/geode/pull/4928#discussion_r423892490", "createdAt": "2020-05-12T17:01:51Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+    queue.put(event6);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsTimeout()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair1 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(0L, event1);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair2 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(1L, event2);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair3 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(2L, event3);\n+\n+    TestableSerialGatewaySenderQueue realQueue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    TestableSerialGatewaySenderQueue queue = spy(realQueue);\n+    queue.setGroupTransactionEvents(true);\n+\n+    doAnswer(invocation -> eventPair1)\n+        .doAnswer(invocation -> eventPair2)\n+        .doAnswer(invocation -> eventPair3)\n+        .doAnswer(invocation -> null)\n+        .when(queue).peekAhead();\n+\n+    doAnswer(invocation -> new SerialGatewaySenderQueue.EventsAndLastKey(\n+        Arrays.asList(new Object[] {event4}), 2L))\n+            .when(queue).getElementsMatching(any(), any(), anyLong());\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(2, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(3, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  private static GatewaySenderEventImpl createMockGatewaySenderEventImpl(int transactionId,\n+      boolean isLastEventInTransaction, Region region) {\n+    GatewaySenderEventImpl event = mock(GatewaySenderEventImpl.class);\n+    when(event.getTransactionId()).thenReturn(new TXId(null, transactionId));\n+    when(event.makeHeapCopyIfOffHeap()).thenReturn(event);\n+    when(event.isLastEventInTransaction()).thenReturn(isLastEventInTransaction);\n+    when(event.getRegion()).thenReturn(region);\n+    return event;\n+  }\n+\n+  private Region createDistributedRegion(String regionName, Cache cache) {\n+    AttributesFactory factory = new AttributesFactory();\n+    factory.setScope(Scope.DISTRIBUTED_ACK);\n+    factory.setDataPolicy(DataPolicy.NORMAL);\n+    RegionAttributes attrs = factory.create();\n+    InternalRegionArguments internalRegionArgs = new InternalRegionArguments();\n+    return new TestLocalRegion(regionName, attrs, null, (InternalCache) cache, internalRegionArgs,\n+        new TestStatisticsClock());\n+  }\n+\n+  public class TestLocalRegion extends LocalRegion {\n+    Map map = new ConcurrentHashMap();\n+\n+    public TestLocalRegion(String regionName, RegionAttributes attrs,\n+        LocalRegion parentRegion, InternalCache cache,\n+        InternalRegionArguments internalRegionArgs,\n+        StatisticsClock statisticsClock) {\n+      super(regionName, attrs, parentRegion, cache, internalRegionArgs, statisticsClock);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMDE1Mg=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkwMjQ2NQ==", "bodyText": "I managed to mock the LocalRegion without much work. I will push a new commit shortly.", "url": "https://github.com/apache/geode/pull/4928#discussion_r423902465", "createdAt": "2020-05-12T17:18:17Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+    queue.put(event6);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsTimeout()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair1 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(0L, event1);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair2 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(1L, event2);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair3 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(2L, event3);\n+\n+    TestableSerialGatewaySenderQueue realQueue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    TestableSerialGatewaySenderQueue queue = spy(realQueue);\n+    queue.setGroupTransactionEvents(true);\n+\n+    doAnswer(invocation -> eventPair1)\n+        .doAnswer(invocation -> eventPair2)\n+        .doAnswer(invocation -> eventPair3)\n+        .doAnswer(invocation -> null)\n+        .when(queue).peekAhead();\n+\n+    doAnswer(invocation -> new SerialGatewaySenderQueue.EventsAndLastKey(\n+        Arrays.asList(new Object[] {event4}), 2L))\n+            .when(queue).getElementsMatching(any(), any(), anyLong());\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(2, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(3, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  private static GatewaySenderEventImpl createMockGatewaySenderEventImpl(int transactionId,\n+      boolean isLastEventInTransaction, Region region) {\n+    GatewaySenderEventImpl event = mock(GatewaySenderEventImpl.class);\n+    when(event.getTransactionId()).thenReturn(new TXId(null, transactionId));\n+    when(event.makeHeapCopyIfOffHeap()).thenReturn(event);\n+    when(event.isLastEventInTransaction()).thenReturn(isLastEventInTransaction);\n+    when(event.getRegion()).thenReturn(region);\n+    return event;\n+  }\n+\n+  private Region createDistributedRegion(String regionName, Cache cache) {\n+    AttributesFactory factory = new AttributesFactory();\n+    factory.setScope(Scope.DISTRIBUTED_ACK);\n+    factory.setDataPolicy(DataPolicy.NORMAL);\n+    RegionAttributes attrs = factory.create();\n+    InternalRegionArguments internalRegionArgs = new InternalRegionArguments();\n+    return new TestLocalRegion(regionName, attrs, null, (InternalCache) cache, internalRegionArgs,\n+        new TestStatisticsClock());\n+  }\n+\n+  public class TestLocalRegion extends LocalRegion {\n+    Map map = new ConcurrentHashMap();\n+\n+    public TestLocalRegion(String regionName, RegionAttributes attrs,\n+        LocalRegion parentRegion, InternalCache cache,\n+        InternalRegionArguments internalRegionArgs,\n+        StatisticsClock statisticsClock) {\n+      super(regionName, attrs, parentRegion, cache, internalRegionArgs, statisticsClock);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMDE1Mg=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk1ODgyMg==", "bodyText": "Perfect! Thanks for taking the time to do this.", "url": "https://github.com/apache/geode/pull/4928#discussion_r423958822", "createdAt": "2020-05-12T18:51:07Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+    queue.put(event6);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsTimeout()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair1 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(0L, event1);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair2 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(1L, event2);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair3 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(2L, event3);\n+\n+    TestableSerialGatewaySenderQueue realQueue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    TestableSerialGatewaySenderQueue queue = spy(realQueue);\n+    queue.setGroupTransactionEvents(true);\n+\n+    doAnswer(invocation -> eventPair1)\n+        .doAnswer(invocation -> eventPair2)\n+        .doAnswer(invocation -> eventPair3)\n+        .doAnswer(invocation -> null)\n+        .when(queue).peekAhead();\n+\n+    doAnswer(invocation -> new SerialGatewaySenderQueue.EventsAndLastKey(\n+        Arrays.asList(new Object[] {event4}), 2L))\n+            .when(queue).getElementsMatching(any(), any(), anyLong());\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(2, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(3, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  private static GatewaySenderEventImpl createMockGatewaySenderEventImpl(int transactionId,\n+      boolean isLastEventInTransaction, Region region) {\n+    GatewaySenderEventImpl event = mock(GatewaySenderEventImpl.class);\n+    when(event.getTransactionId()).thenReturn(new TXId(null, transactionId));\n+    when(event.makeHeapCopyIfOffHeap()).thenReturn(event);\n+    when(event.isLastEventInTransaction()).thenReturn(isLastEventInTransaction);\n+    when(event.getRegion()).thenReturn(region);\n+    return event;\n+  }\n+\n+  private Region createDistributedRegion(String regionName, Cache cache) {\n+    AttributesFactory factory = new AttributesFactory();\n+    factory.setScope(Scope.DISTRIBUTED_ACK);\n+    factory.setDataPolicy(DataPolicy.NORMAL);\n+    RegionAttributes attrs = factory.create();\n+    InternalRegionArguments internalRegionArgs = new InternalRegionArguments();\n+    return new TestLocalRegion(regionName, attrs, null, (InternalCache) cache, internalRegionArgs,\n+        new TestStatisticsClock());\n+  }\n+\n+  public class TestLocalRegion extends LocalRegion {\n+    Map map = new ConcurrentHashMap();\n+\n+    public TestLocalRegion(String regionName, RegionAttributes attrs,\n+        LocalRegion parentRegion, InternalCache cache,\n+        InternalRegionArguments internalRegionArgs,\n+        StatisticsClock statisticsClock) {\n+      super(regionName, attrs, parentRegion, cache, internalRegionArgs, statisticsClock);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMDE1Mg=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 223}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk0ODUwOnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMzo1NDozNFrOGS2rPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNzo0ODo1OFrOGTm4_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMzM1Nw==", "bodyText": "This test name could be more descriptive. Also an Exception is never thrown from this method, so the throws can be removed.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422423357", "createdAt": "2020-05-08T23:54:34Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE5NDA2OA==", "bodyText": "How about testReplicatedSerialPropagationWithoutGroupTransactionEventsSendsBatchesWithIncompleteTransactions?", "url": "https://github.com/apache/geode/pull/4928#discussion_r423194068", "createdAt": "2020-05-11T17:16:04Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMzM1Nw=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIxMzMxMQ==", "bodyText": "Sounds good", "url": "https://github.com/apache/geode/pull/4928#discussion_r423213311", "createdAt": "2020-05-11T17:48:58Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMzM1Nw=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk1MDEyOnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMzo1NTo1NFrOGS2sLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMTo1NzowMVrOGUDESw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMzU5Nw==", "bodyText": "This test name could be more descriptive. Also an Exception is never thrown from this method, so the throws can be removed.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422423597", "createdAt": "2020-05-08T23:55:54Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE5NDM0OQ==", "bodyText": "How about testReplicatedSerialPropagationWithGroupTransactionEventsSendsBatchesWithoutIncompleteTransactions?", "url": "https://github.com/apache/geode/pull/4928#discussion_r423194349", "createdAt": "2020-05-11T17:16:31Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMzU5Nw=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIxNjA0OA==", "bodyText": "It might be clearer with \"SendsBatchesWithCompleteTransactions,\" but either would be okay.", "url": "https://github.com/apache/geode/pull/4928#discussion_r423216048", "createdAt": "2020-05-11T17:53:58Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMzU5Nw=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY3NDk1NQ==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423674955", "createdAt": "2020-05-12T11:57:01Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMzU5Nw=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk1MjY1OnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMzo1ODoxNFrOGS2ttw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNzoyMzoyMlrOGTl-xA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMzk5MQ==", "bodyText": "These casts to Integer are redundant.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422423991", "createdAt": "2020-05-08T23:58:14Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE5ODQwNA==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423198404", "createdAt": "2020-05-11T17:23:22Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMzk5MQ=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk1Nzg5OnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDowMjoyMFrOGS2wvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwODozMDowNFrOGT70MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNDc2NQ==", "bodyText": "This method is deprecated and so should not be used. GeodeAwaitility.await() should be used when tests need to wait for some condition to be met before continuing.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422424765", "createdAt": "2020-05-09T00:02:20Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU1NjE0NQ==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423556145", "createdAt": "2020-05-12T08:30:04Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNDc2NQ=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk1ODg2OnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDowMjo1OVrOGS2xPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwODozMjowM1rOGT75Zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNDg5NQ==", "bodyText": "Redundant cast to Integer.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422424895", "createdAt": "2020-05-09T00:02:59Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU1NzQ3OA==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423557478", "createdAt": "2020-05-12T08:32:03Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNDg5NQ=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk2MDA3OnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDowMzozOFrOGS2x2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwODozMzoxNFrOGT78KQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTA1MQ==", "bodyText": "Deprecated method.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422425051", "createdAt": "2020-05-09T00:03:38Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 4 transactions of 3 events each are sent so that the first batch\n+    // would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // events of the third transaction are added to the batch which makes\n+    // that the batch is sent with 12 events.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU1ODE4NQ==", "bodyText": "ok. Changed to vm2.invoke(() -> WANTestBase.validateRegionSize(...)", "url": "https://github.com/apache/geode/pull/4928#discussion_r423558185", "createdAt": "2020-05-12T08:33:14Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 4 transactions of 3 events each are sent so that the first batch\n+    // would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // events of the third transaction are added to the batch which makes\n+    // that the batch is sent with 12 events.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTA1MQ=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk2MDcyOnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDowMzo1N1rOGS2yLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNjo0NTozNVrOGUPrSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTEzNA==", "bodyText": "This test name could be more descriptive.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422425134", "createdAt": "2020-05-09T00:03:57Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 4 transactions of 3 events each are sent so that the first batch\n+    // would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // events of the third transaction are added to the batch which makes\n+    // that the batch is sent with 12 events.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 1, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0, true));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU3NDkzMw==", "bodyText": "How about testReplicatedSerialPropagationWithBatchRedistWithoutGroupTransactionEventsSendsBatchesWithIncompleteTransactions?\n(world record in length but I could not come up with any shorter :-))", "url": "https://github.com/apache/geode/pull/4928#discussion_r423574933", "createdAt": "2020-05-12T08:58:21Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 4 transactions of 3 events each are sent so that the first batch\n+    // would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // events of the third transaction are added to the batch which makes\n+    // that the batch is sent with 12 events.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 1, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0, true));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTEzNA=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg4MTU0NA==", "bodyText": "Sounds good. I actually got curious about the longest test name in Geode, so I searched, and the record is replicatedRegionWithPersistentSerialAsyncEventQueueAndConflationEnabledShouldNotLooseEventsNorThrowNullPointerExceptionsWhenMemberIsRestartedWhileEventsAreStillOnTheQueue at 170 characters, so you have some way to go if you want to beat that :P", "url": "https://github.com/apache/geode/pull/4928#discussion_r423881544", "createdAt": "2020-05-12T16:45:35Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 4 transactions of 3 events each are sent so that the first batch\n+    // would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // events of the third transaction are added to the batch which makes\n+    // that the batch is sent with 12 events.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 1, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0, true));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTEzNA=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk2MDk4OnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDowNDowOVrOGS2yVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwODo1ODoyN1rOGT891A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTE3Mw==", "bodyText": "Redundant cast to Integer.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422425173", "createdAt": "2020-05-09T00:04:09Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 4 transactions of 3 events each are sent so that the first batch\n+    // would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // events of the third transaction are added to the batch which makes\n+    // that the batch is sent with 12 events.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 1, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0, true));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU3NDk5Ng==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423574996", "createdAt": "2020-05-12T08:58:27Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 4 transactions of 3 events each are sent so that the first batch\n+    // would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // events of the third transaction are added to the batch which makes\n+    // that the batch is sent with 12 events.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 1, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0, true));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTE3Mw=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk2MjUzOnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDowNToxMlrOGS2zKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwODo1ODo1NlrOGT8_BQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTM4NA==", "bodyText": "Thread.sleep() should be avoided in tests as it can lead to flakiness. GeodeAwaitility.await() should be used instead.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422425384", "createdAt": "2020-05-09T00:05:12Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 4 transactions of 3 events each are sent so that the first batch\n+    // would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // events of the third transaction are added to the batch which makes\n+    // that the batch is sent with 12 events.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 1, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0, true));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 24;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU3NTMwMQ==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423575301", "createdAt": "2020-05-12T08:58:56Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 4 transactions of 3 events each are sent so that the first batch\n+    // would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // events of the third transaction are added to the batch which makes\n+    // that the batch is sent with 12 events.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 1, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0, true));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 24;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTM4NA=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 177}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk2MjY4OnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDowNToyMFrOGS2zPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwODo1OTo1OVrOGT9Bww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTQwNg==", "bodyText": "Deprecated method.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422425406", "createdAt": "2020-05-09T00:05:20Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 4 transactions of 3 events each are sent so that the first batch\n+    // would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // events of the third transaction are added to the batch which makes\n+    // that the batch is sent with 12 events.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 1, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0, true));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 24;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU3NjAwMw==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423576003", "createdAt": "2020-05-12T08:59:59Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 4 transactions of 3 events each are sent so that the first batch\n+    // would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // events of the third transaction are added to the batch which makes\n+    // that the batch is sent with 12 events.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 1, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0, true));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 24;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTQwNg=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk2MzA3OnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDowNTo0M1rOGS2zfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNjo0NjowN1rOGUPsmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTQ2OQ==", "bodyText": "This test name could be more descriptive.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422425469", "createdAt": "2020-05-09T00:05:43Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 4 transactions of 3 events each are sent so that the first batch\n+    // would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // events of the third transaction are added to the batch which makes\n+    // that the batch is sent with 12 events.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 1, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0, true));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 24;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(3, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 3, true, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedGroupTransactions()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU3NzE1MQ==", "bodyText": "How about testReplicatedSerialPropagationWithBatchRedistWithGroupTransactionEventsSendsBatchesWithoutIncompleteTransactions?", "url": "https://github.com/apache/geode/pull/4928#discussion_r423577151", "createdAt": "2020-05-12T09:01:42Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 4 transactions of 3 events each are sent so that the first batch\n+    // would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // events of the third transaction are added to the batch which makes\n+    // that the batch is sent with 12 events.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 1, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0, true));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 24;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(3, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 3, true, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedGroupTransactions()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTQ2OQ=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg4MTg4MQ==", "bodyText": "Sounds good", "url": "https://github.com/apache/geode/pull/4928#discussion_r423881881", "createdAt": "2020-05-12T16:46:07Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 4 transactions of 3 events each are sent so that the first batch\n+    // would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // events of the third transaction are added to the batch which makes\n+    // that the batch is sent with 12 events.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 1, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0, true));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 24;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(3, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 3, true, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedGroupTransactions()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTQ2OQ=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 193}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk2MzM1OnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDowNTo1NFrOGS2znw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwOTowMTo1MVrOGT9GmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTUwMw==", "bodyText": "Redundant cast to Integer.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422425503", "createdAt": "2020-05-09T00:05:54Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 4 transactions of 3 events each are sent so that the first batch\n+    // would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // events of the third transaction are added to the batch which makes\n+    // that the batch is sent with 12 events.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 1, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0, true));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 24;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(3, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 3, true, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU3NzI0MQ==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423577241", "createdAt": "2020-05-12T09:01:51Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 4 transactions of 3 events each are sent so that the first batch\n+    // would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // events of the third transaction are added to the batch which makes\n+    // that the batch is sent with 12 events.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 1, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0, true));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 24;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(3, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 3, true, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTUwMw=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 196}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk2NDA5OnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDowNjoyN1rOGS20Dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwOTowMjoxOFrOGT9HlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTYxNA==", "bodyText": "Use GeodeAwaitility.await() instead.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422425614", "createdAt": "2020-05-09T00:06:27Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 4 transactions of 3 events each are sent so that the first batch\n+    // would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // events of the third transaction are added to the batch which makes\n+    // that the batch is sent with 12 events.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 1, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0, true));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 24;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(3, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 3, true, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 24;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 8 transactions of 3 events each are sent so that the first batch\n+    // events would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // event of the third transaction is added to the batch which makes\n+    // that the first batch is sent with 12 events. The same happens with the\n+    // second batch which will contain 12 events too.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU3NzQ5Mg==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423577492", "createdAt": "2020-05-12T09:02:18Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 4 transactions of 3 events each are sent so that the first batch\n+    // would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // events of the third transaction are added to the batch which makes\n+    // that the batch is sent with 12 events.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 1, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0, true));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 24;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(3, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 3, true, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 24;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 8 transactions of 3 events each are sent so that the first batch\n+    // events would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // event of the third transaction is added to the batch which makes\n+    // that the first batch is sent with 12 events. The same happens with the\n+    // second batch which will contain 12 events too.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTYxNA=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 248}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk2NDMwOnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDowNjozOFrOGS20Lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwOTowMjoyOVrOGT9IIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTY0Ng==", "bodyText": "Deprecated method.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422425646", "createdAt": "2020-05-09T00:06:38Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 4 transactions of 3 events each are sent so that the first batch\n+    // would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // events of the third transaction are added to the batch which makes\n+    // that the batch is sent with 12 events.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 1, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0, true));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 24;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(3, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 3, true, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 24;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 8 transactions of 3 events each are sent so that the first batch\n+    // events would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // event of the third transaction is added to the batch which makes\n+    // that the first batch is sent with 12 events. The same happens with the\n+    // second batch which will contain 12 events too.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU3NzYzNQ==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423577635", "createdAt": "2020-05-12T09:02:29Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 4 transactions of 3 events each are sent so that the first batch\n+    // would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // events of the third transaction are added to the batch which makes\n+    // that the batch is sent with 12 events.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 1, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0, true));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 24;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(3, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 3, true, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 24;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 8 transactions of 3 events each are sent so that the first batch\n+    // events would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // event of the third transaction is added to the batch which makes\n+    // that the first batch is sent with 12 events. The same happens with the\n+    // second batch which will contain 12 events too.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTY0Ng=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 253}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk2NzEzOnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/wancommand/CreateDestroyGatewaySenderCommandDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDowODo1NVrOGS21uA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwOToxNDoxOVrOGT9lfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjA0MA==", "bodyText": "Since the default unspecified value of group-transaction-events is false, does it need to be specified in the gfsh command here?", "url": "https://github.com/apache/geode/pull/4928#discussion_r422426040", "createdAt": "2020-05-09T00:08:55Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/wancommand/CreateDestroyGatewaySenderCommandDUnitTest.java", "diffHunk": "@@ -155,7 +155,8 @@ public void testCreateDestroyGatewaySender() {\n         + CliStrings.CREATE_GATEWAYSENDER__MAXQUEUEMEMORY + \"=1000\" + \" --\"\n         + CliStrings.CREATE_GATEWAYSENDER__ALERTTHRESHOLD + \"=100\" + \" --\"\n         + CliStrings.CREATE_GATEWAYSENDER__DISPATCHERTHREADS + \"=2\" + \" --\"\n-        + CliStrings.CREATE_GATEWAYSENDER__ORDERPOLICY + \"=THREAD\";\n+        + CliStrings.CREATE_GATEWAYSENDER__ORDERPOLICY + \"=THREAD\" + \" --\"\n+        + CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS + \"=false\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4NTE0OA==", "bodyText": "It does not. I will remove it.", "url": "https://github.com/apache/geode/pull/4928#discussion_r423585148", "createdAt": "2020-05-12T09:14:19Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/wancommand/CreateDestroyGatewaySenderCommandDUnitTest.java", "diffHunk": "@@ -155,7 +155,8 @@ public void testCreateDestroyGatewaySender() {\n         + CliStrings.CREATE_GATEWAYSENDER__MAXQUEUEMEMORY + \"=1000\" + \" --\"\n         + CliStrings.CREATE_GATEWAYSENDER__ALERTTHRESHOLD + \"=100\" + \" --\"\n         + CliStrings.CREATE_GATEWAYSENDER__DISPATCHERTHREADS + \"=2\" + \" --\"\n-        + CliStrings.CREATE_GATEWAYSENDER__ORDERPOLICY + \"=THREAD\";\n+        + CliStrings.CREATE_GATEWAYSENDER__ORDERPOLICY + \"=THREAD\" + \" --\"\n+        + CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS + \"=false\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjA0MA=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk2ODgzOnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/wancommand/CreateDestroyGatewaySenderCommandDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDowOTo1N1rOGS22mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwOToxNDo1NlrOGT9m_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjI2Nw==", "bodyText": "Specifying the default value here is redundant.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422426267", "createdAt": "2020-05-09T00:09:57Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/wancommand/CreateDestroyGatewaySenderCommandDUnitTest.java", "diffHunk": "@@ -239,6 +241,7 @@ public void testCreateDestroyGatewaySenderWithGatewayEventFilters() {\n         + CliStrings.CREATE_GATEWAYSENDER__ALERTTHRESHOLD + \"=100\" + \" --\"\n         + CliStrings.CREATE_GATEWAYSENDER__DISPATCHERTHREADS + \"=2\" + \" --\"\n         + CliStrings.CREATE_GATEWAYSENDER__ORDERPOLICY + \"=THREAD\" + \" --\"\n+        + CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS + \"=false\" + \" --\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4NTUzNA==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423585534", "createdAt": "2020-05-12T09:14:56Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/wancommand/CreateDestroyGatewaySenderCommandDUnitTest.java", "diffHunk": "@@ -239,6 +241,7 @@ public void testCreateDestroyGatewaySenderWithGatewayEventFilters() {\n         + CliStrings.CREATE_GATEWAYSENDER__ALERTTHRESHOLD + \"=100\" + \" --\"\n         + CliStrings.CREATE_GATEWAYSENDER__DISPATCHERTHREADS + \"=2\" + \" --\"\n         + CliStrings.CREATE_GATEWAYSENDER__ORDERPOLICY + \"=THREAD\" + \" --\"\n+        + CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS + \"=false\" + \" --\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjI2Nw=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk2OTIwOnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/wancommand/CreateDestroyGatewaySenderCommandDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDoxMDoxMlrOGS220Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwOToxNjozM1rOGT9q9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjMyMQ==", "bodyText": "Specifying the default value here is redundant.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422426321", "createdAt": "2020-05-09T00:10:12Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/wancommand/CreateDestroyGatewaySenderCommandDUnitTest.java", "diffHunk": "@@ -292,6 +295,7 @@ public void testCreateDestroyGatewaySenderWithGatewayTransportFilters() {\n         + CliStrings.CREATE_GATEWAYSENDER__ALERTTHRESHOLD + \"=100\" + \" --\"\n         + CliStrings.CREATE_GATEWAYSENDER__DISPATCHERTHREADS + \"=2\" + \" --\"\n         + CliStrings.CREATE_GATEWAYSENDER__ORDERPOLICY + \"=THREAD\" + \" --\"\n+        + CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS + \"=false\" + \" --\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4NjU1MQ==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423586551", "createdAt": "2020-05-12T09:16:33Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/wancommand/CreateDestroyGatewaySenderCommandDUnitTest.java", "diffHunk": "@@ -292,6 +295,7 @@ public void testCreateDestroyGatewaySenderWithGatewayTransportFilters() {\n         + CliStrings.CREATE_GATEWAYSENDER__ALERTTHRESHOLD + \"=100\" + \" --\"\n         + CliStrings.CREATE_GATEWAYSENDER__DISPATCHERTHREADS + \"=2\" + \" --\"\n         + CliStrings.CREATE_GATEWAYSENDER__ORDERPOLICY + \"=THREAD\" + \" --\"\n+        + CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS + \"=false\" + \" --\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjMyMQ=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk3MDU5OnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDoxMToxM1rOGS23mA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwOToyMDowM1rOGT90Kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjUyMA==", "bodyText": "Can these comments be cleaned up a bit?", "url": "https://github.com/apache/geode/pull/4928#discussion_r422426520", "createdAt": "2020-05-09T00:11:13Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -102,15 +108,18 @@ public void testQueueSizeInSecondaryBucketRegionQueuesWithMemberRestart() throws\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", NUM_PUTS));\n \n     assertEquals(NUM_PUTS, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue\n-                                                                                           // size\n-    assertEquals(NUM_PUTS * 2, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n-    assertEquals(NUM_PUTS * 2, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                               // queued\n+    // size\n+    assertEquals(NUM_PUTS * 2,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS * 2,\n+        v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n     assertEquals(0, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                    // distributed\n-    assertEquals(NUM_PUTS, v4List.get(10) + v5List.get(10) + v6List.get(10) + v7List.get(10)); // secondary\n-                                                                                               // queue\n-                                                                                               // size\n+    // distributed\n+    assertEquals(NUM_PUTS,\n+        v4List.get(10) + v5List.get(10) + v6List.get(10) + v7List.get(10)); // secondary\n+    // queue\n+    // size", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4ODkwNw==", "bodyText": "I have removed them. I do not think they provide any useful information.", "url": "https://github.com/apache/geode/pull/4928#discussion_r423588907", "createdAt": "2020-05-12T09:20:03Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -102,15 +108,18 @@ public void testQueueSizeInSecondaryBucketRegionQueuesWithMemberRestart() throws\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", NUM_PUTS));\n \n     assertEquals(NUM_PUTS, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue\n-                                                                                           // size\n-    assertEquals(NUM_PUTS * 2, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n-    assertEquals(NUM_PUTS * 2, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                               // queued\n+    // size\n+    assertEquals(NUM_PUTS * 2,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS * 2,\n+        v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n     assertEquals(0, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                    // distributed\n-    assertEquals(NUM_PUTS, v4List.get(10) + v5List.get(10) + v6List.get(10) + v7List.get(10)); // secondary\n-                                                                                               // queue\n-                                                                                               // size\n+    // distributed\n+    assertEquals(NUM_PUTS,\n+        v4List.get(10) + v5List.get(10) + v6List.get(10) + v7List.get(10)); // secondary\n+    // queue\n+    // size", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjUyMA=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk3MTU0OnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDoxMTo0OVrOGS24Ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwOToyMjowMFrOGT94yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjY0Mw==", "bodyText": "More untidy comments.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422426643", "createdAt": "2020-05-09T00:11:49Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -137,7 +146,8 @@ public void testQueueSizeInSecondaryBucketRegionQueuesWithMemberRestart() throws\n     v5List = (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", NUM_PUTS));\n     v6List = (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", NUM_PUTS));\n     v7List = (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", NUM_PUTS));\n-    assertEquals(NUM_PUTS, v4List.get(10) + v5List.get(10) + v6List.get(10) + v7List.get(10)); // secondary\n+    assertEquals(NUM_PUTS,\n+        v4List.get(10) + v5List.get(10) + v6List.get(10) + v7List.get(10)); // secondary", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU5MDA5MQ==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423590091", "createdAt": "2020-05-12T09:22:00Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -137,7 +146,8 @@ public void testQueueSizeInSecondaryBucketRegionQueuesWithMemberRestart() throws\n     v5List = (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", NUM_PUTS));\n     v6List = (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", NUM_PUTS));\n     v7List = (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", NUM_PUTS));\n-    assertEquals(NUM_PUTS, v4List.get(10) + v5List.get(10) + v6List.get(10) + v7List.get(10)); // secondary\n+    assertEquals(NUM_PUTS,\n+        v4List.get(10) + v5List.get(10) + v6List.get(10) + v7List.get(10)); // secondary", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjY0Mw=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk3MTg3OnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDoxMTo1NlrOGS24Ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwOToyNDo0NlrOGT9_Pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjY4Mw==", "bodyText": "More untidy comments.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422426683", "createdAt": "2020-05-09T00:11:56Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -159,10 +169,10 @@ public void testQueueSizeInSecondaryBucketRegionQueuesWithMemberRestart() throws\n     v7List = (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertEquals(0, v4List.get(10) + v5List.get(10) + v6List.get(10) + v7List.get(10)); // secondary\n-                                                                                        // queue\n-                                                                                        // size\n+    // queue\n+    // size", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU5MTc0Mg==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423591742", "createdAt": "2020-05-12T09:24:46Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -159,10 +169,10 @@ public void testQueueSizeInSecondaryBucketRegionQueuesWithMemberRestart() throws\n     v7List = (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertEquals(0, v4List.get(10) + v5List.get(10) + v6List.get(10) + v7List.get(10)); // secondary\n-                                                                                        // queue\n-                                                                                        // size\n+    // queue\n+    // size", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjY4Mw=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk3MjA4OnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDoxMjowNFrOGS24Wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwOToyNDo1NVrOGT9_lQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjcxNA==", "bodyText": "More untidy comments.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422426714", "createdAt": "2020-05-09T00:12:04Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -194,15 +204,18 @@ public void testQueueSizeInSecondaryWithPrimarySwitch() throws Exception {\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", NUM_PUTS));\n \n     assertEquals(NUM_PUTS, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue\n-                                                                                           // size\n-    assertEquals(NUM_PUTS * 2, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n-    assertEquals(NUM_PUTS * 2, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                               // queued\n+    // size\n+    assertEquals(NUM_PUTS * 2,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS * 2,\n+        v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n     assertEquals(0, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                    // distributed\n-    assertEquals(NUM_PUTS, v4List.get(10) + v5List.get(10) + v6List.get(10) + v7List.get(10)); // secondary\n-                                                                                               // queue\n-                                                                                               // size\n+    // distributed\n+    assertEquals(NUM_PUTS,\n+        v4List.get(10) + v5List.get(10) + v6List.get(10) + v7List.get(10)); // secondary\n+    // queue\n+    // size", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU5MTgyOQ==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423591829", "createdAt": "2020-05-12T09:24:55Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -194,15 +204,18 @@ public void testQueueSizeInSecondaryWithPrimarySwitch() throws Exception {\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", NUM_PUTS));\n \n     assertEquals(NUM_PUTS, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue\n-                                                                                           // size\n-    assertEquals(NUM_PUTS * 2, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n-    assertEquals(NUM_PUTS * 2, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                               // queued\n+    // size\n+    assertEquals(NUM_PUTS * 2,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS * 2,\n+        v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n     assertEquals(0, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                    // distributed\n-    assertEquals(NUM_PUTS, v4List.get(10) + v5List.get(10) + v6List.get(10) + v7List.get(10)); // secondary\n-                                                                                               // queue\n-                                                                                               // size\n+    // distributed\n+    assertEquals(NUM_PUTS,\n+        v4List.get(10) + v5List.get(10) + v6List.get(10) + v7List.get(10)); // secondary\n+    // queue\n+    // size", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjcxNA=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk3MjQ0OnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDoxMjoxOFrOGS24ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwOToyNTowMVrOGT9_1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjc2Mg==", "bodyText": "More untidy comments.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422426762", "createdAt": "2020-05-09T00:12:18Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -219,10 +232,10 @@ public void testQueueSizeInSecondaryWithPrimarySwitch() throws Exception {\n     v7List = (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertEquals(0, v4List.get(10) + v5List.get(10) + v6List.get(10) + v7List.get(10)); // secondary\n-                                                                                        // queue\n-                                                                                        // size\n+    // queue\n+    // size", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU5MTg5NA==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423591894", "createdAt": "2020-05-12T09:25:01Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -219,10 +232,10 @@ public void testQueueSizeInSecondaryWithPrimarySwitch() throws Exception {\n     v7List = (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertEquals(0, v4List.get(10) + v5List.get(10) + v6List.get(10) + v7List.get(10)); // secondary\n-                                                                                        // queue\n-                                                                                        // size\n+    // queue\n+    // size", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjc2Mg=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk3MjUyOnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDoxMjoyMlrOGS24mQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwOToyNToxNlrOGT-AkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjc3Nw==", "bodyText": "More untidy comments.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422426777", "createdAt": "2020-05-09T00:12:22Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -254,16 +267,17 @@ public void testPartitionedRegionParallelPropagation_BeforeDispatch() throws Exc\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", NUM_PUTS));\n \n     assertEquals(NUM_PUTS, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue\n-                                                                                           // size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    // size\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(0, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                    // distributed\n+    // distributed\n     assertEquals(0, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n-                                                                                    // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU5MjA4MA==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423592080", "createdAt": "2020-05-12T09:25:16Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -254,16 +267,17 @@ public void testPartitionedRegionParallelPropagation_BeforeDispatch() throws Exc\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", NUM_PUTS));\n \n     assertEquals(NUM_PUTS, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue\n-                                                                                           // size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    // size\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(0, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                    // distributed\n+    // distributed\n     assertEquals(0, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n-                                                                                    // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjc3Nw=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk3MjcxOnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDoxMjozMVrOGS24sA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwOToyNTozOFrOGT-BZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjgwMA==", "bodyText": "More untidy comments.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422426800", "createdAt": "2020-05-09T00:12:31Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU5MjI5Mw==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423592293", "createdAt": "2020-05-12T09:25:38Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjgwMA=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk3NDA3OnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDoxMzoxOFrOGS25Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNjo0NzowM1rOGUPvBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjk2Ng==", "bodyText": "This test name could be more descriptive. Also, the throws is not necessary.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422426966", "createdAt": "2020-05-09T00:13:18Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU5NzMyMg==", "bodyText": "How about testPRParallelPropagationWithoutGroupTransactionEventsSendsBatchesWithIncompleteTransactions?", "url": "https://github.com/apache/geode/pull/4928#discussion_r423597322", "createdAt": "2020-05-12T09:33:20Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjk2Ng=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg4MjUwMQ==", "bodyText": "Sounds good", "url": "https://github.com/apache/geode/pull/4928#discussion_r423882501", "createdAt": "2020-05-12T16:47:03Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjk2Ng=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 161}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk3NTA0OnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDoxMzo1MlrOGS25zQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwOTozNTowMlrOGT-Y8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzA4NQ==", "bodyText": "Redundant case to Integer.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427085", "createdAt": "2020-05-09T00:13:52Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU5ODMyMg==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423598322", "createdAt": "2020-05-12T09:35:02Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzA4NQ=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 164}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk3NTkzOnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDoxNDoyNFrOGS26QQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwOTozNzowM1rOGT-dsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzIwMQ==", "bodyText": "More untidy comments.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427201", "createdAt": "2020-05-09T00:14:24Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU5OTUzNw==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423599537", "createdAt": "2020-05-12T09:37:03Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzIwMQ=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 225}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk3NjI2OnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDoxNDo0NVrOGS26fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNjo0Nzo0NVrOGUPwyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzI2Mg==", "bodyText": "This test name could be more descriptive. Also, the throws is not needed.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427262", "createdAt": "2020-05-09T00:14:45Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzYwMTE4MQ==", "bodyText": "How about testPRParallelPropagationWithGroupTransactionEventsSendsBatchesWithoutIncompleteTransactions?", "url": "https://github.com/apache/geode/pull/4928#discussion_r423601181", "createdAt": "2020-05-12T09:39:44Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzI2Mg=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg4Mjk1Mg==", "bodyText": "Sounds good", "url": "https://github.com/apache/geode/pull/4928#discussion_r423882952", "createdAt": "2020-05-12T16:47:45Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzI2Mg=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 229}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk3NjY0OnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDoxNDo1OFrOGS26rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwOTozOTo0OVrOGT-kSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzMxMQ==", "bodyText": "Redundant cast to Integer.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427311", "createdAt": "2020-05-09T00:14:58Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzYwMTIyNg==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423601226", "createdAt": "2020-05-12T09:39:49Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzMxMQ=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 232}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk3NzcwOnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDoxNTo0M1rOGS27LQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwOTozOTo1OFrOGT-kpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzQzNw==", "bodyText": "More untidy comments.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427437", "createdAt": "2020-05-09T00:15:43Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 3 transactions of 4 events each are sent so that the batch would\n+    // initially contain the first 2 transactions complete and the first\n+    // 2 events of the last transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the last transaction are added to the batch which makes\n+    // that only one batch of 12 events is sent.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 301}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzYwMTMxNw==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423601317", "createdAt": "2020-05-12T09:39:58Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 3 transactions of 4 events each are sent so that the batch would\n+    // initially contain the first 2 transactions complete and the first\n+    // 2 events of the last transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the last transaction are added to the batch which makes\n+    // that only one batch of 12 events is sent.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzQzNw=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 301}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk3ODAzOnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDoxNTo1NlrOGS27Ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNjo0Nzo1OFrOGUPxZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzQ4Mw==", "bodyText": "This test name could be more descriptive.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427483", "createdAt": "2020-05-09T00:15:56Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 3 transactions of 4 events each are sent so that the batch would\n+    // initially contain the first 2 transactions complete and the first\n+    // 2 events of the last transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the last transaction are added to the batch which makes\n+    // that only one batch of 12 events is sent.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 305}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzYwMTcxMw==", "bodyText": "How about testPRParallelPropagationWithBatchRedistWithoutGroupTransactionEventsSendsBatchesWithIncompleteTransactions", "url": "https://github.com/apache/geode/pull/4928#discussion_r423601713", "createdAt": "2020-05-12T09:40:34Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 3 transactions of 4 events each are sent so that the batch would\n+    // initially contain the first 2 transactions complete and the first\n+    // 2 events of the last transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the last transaction are added to the batch which makes\n+    // that only one batch of 12 events is sent.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzQ4Mw=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 305}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg4MzExMQ==", "bodyText": "Sounds good", "url": "https://github.com/apache/geode/pull/4928#discussion_r423883111", "createdAt": "2020-05-12T16:47:58Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 3 transactions of 4 events each are sent so that the batch would\n+    // initially contain the first 2 transactions complete and the first\n+    // 2 events of the last transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the last transaction are added to the batch which makes\n+    // that only one batch of 12 events is sent.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzQ4Mw=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 305}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk3ODQzOnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDoxNjowN1rOGS27iQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwOTo0MDo0MFrOGT-mZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzUyOQ==", "bodyText": "Redundant cast to Integer.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427529", "createdAt": "2020-05-09T00:16:07Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 3 transactions of 4 events each are sent so that the batch would\n+    // initially contain the first 2 transactions complete and the first\n+    // 2 events of the last transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the last transaction are added to the batch which makes\n+    // that only one batch of 12 events is sent.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 308}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzYwMTc2Ng==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423601766", "createdAt": "2020-05-12T09:40:40Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 3 transactions of 4 events each are sent so that the batch would\n+    // initially contain the first 2 transactions complete and the first\n+    // 2 events of the last transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the last transaction are added to the batch which makes\n+    // that only one batch of 12 events is sent.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzUyOQ=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 308}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk3OTAxOnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDoxNjozMlrOGS27zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwOTo0MTo0MlrOGT-o2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzU5OA==", "bodyText": "Use GeodeAwaitlity.await() instead.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427598", "createdAt": "2020-05-09T00:16:32Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 3 transactions of 4 events each are sent so that the batch would\n+    // initially contain the first 2 transactions complete and the first\n+    // 2 events of the last transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the last transaction are added to the batch which makes\n+    // that only one batch of 12 events is sent.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 6;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 345}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzYwMjM5NA==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423602394", "createdAt": "2020-05-12T09:41:42Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 3 transactions of 4 events each are sent so that the batch would\n+    // initially contain the first 2 transactions complete and the first\n+    // 2 events of the last transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the last transaction are added to the batch which makes\n+    // that only one batch of 12 events is sent.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 6;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzU5OA=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 345}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk3OTQ2OnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDoxNjo1MlrOGS28CQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwOTo0MTo1MFrOGT-pMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzY1Nw==", "bodyText": "More untidy comments.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427657", "createdAt": "2020-05-09T00:16:52Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 3 transactions of 4 events each are sent so that the batch would\n+    // initially contain the first 2 transactions complete and the first\n+    // 2 events of the last transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the last transaction are added to the batch which makes\n+    // that only one batch of 12 events is sent.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 6;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(3, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertTrue(\"Batch was not redistributed\",\n+        (v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)) > 0); // batches\n+    // redistributed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 372}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzYwMjQ4Mw==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423602483", "createdAt": "2020-05-12T09:41:50Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 3 transactions of 4 events each are sent so that the batch would\n+    // initially contain the first 2 transactions complete and the first\n+    // 2 events of the last transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the last transaction are added to the batch which makes\n+    // that only one batch of 12 events is sent.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 6;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(3, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertTrue(\"Batch was not redistributed\",\n+        (v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)) > 0); // batches\n+    // redistributed", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzY1Nw=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 372}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk3OTgxOnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDoxNzoxMVrOGS28PQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNjo0ODowOFrOGUPx3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzcwOQ==", "bodyText": "This test name could be more descriptive.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427709", "createdAt": "2020-05-09T00:17:11Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 3 transactions of 4 events each are sent so that the batch would\n+    // initially contain the first 2 transactions complete and the first\n+    // 2 events of the last transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the last transaction are added to the batch which makes\n+    // that only one batch of 12 events is sent.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 6;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(3, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertTrue(\"Batch was not redistributed\",\n+        (v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)) > 0); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_GroupTransactionEvents()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 376}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzYwMjgzNg==", "bodyText": "How about testPRParallelPropagationWithBatchRedistWithGroupTransactionEventsSendsBatchesWithoutIncompleteTransactions?", "url": "https://github.com/apache/geode/pull/4928#discussion_r423602836", "createdAt": "2020-05-12T09:42:23Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 3 transactions of 4 events each are sent so that the batch would\n+    // initially contain the first 2 transactions complete and the first\n+    // 2 events of the last transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the last transaction are added to the batch which makes\n+    // that only one batch of 12 events is sent.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 6;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(3, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertTrue(\"Batch was not redistributed\",\n+        (v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)) > 0); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_GroupTransactionEvents()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzcwOQ=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 376}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg4MzIzMA==", "bodyText": "Sounds good", "url": "https://github.com/apache/geode/pull/4928#discussion_r423883230", "createdAt": "2020-05-12T16:48:08Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 3 transactions of 4 events each are sent so that the batch would\n+    // initially contain the first 2 transactions complete and the first\n+    // 2 events of the last transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the last transaction are added to the batch which makes\n+    // that only one batch of 12 events is sent.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 6;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(3, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertTrue(\"Batch was not redistributed\",\n+        (v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)) > 0); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_GroupTransactionEvents()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzcwOQ=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 376}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk4MDExOnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDoxNzoyM1rOGS28ZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwOTo0MjozMVrOGT-q4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzc0OA==", "bodyText": "Redundant cast to Integer.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427748", "createdAt": "2020-05-09T00:17:23Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 3 transactions of 4 events each are sent so that the batch would\n+    // initially contain the first 2 transactions complete and the first\n+    // 2 events of the last transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the last transaction are added to the batch which makes\n+    // that only one batch of 12 events is sent.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 6;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(3, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertTrue(\"Batch was not redistributed\",\n+        (v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)) > 0); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 379}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzYwMjkxNQ==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423602915", "createdAt": "2020-05-12T09:42:31Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 3 transactions of 4 events each are sent so that the batch would\n+    // initially contain the first 2 transactions complete and the first\n+    // 2 events of the last transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the last transaction are added to the batch which makes\n+    // that only one batch of 12 events is sent.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 6;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(3, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertTrue(\"Batch was not redistributed\",\n+        (v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)) > 0); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzc0OA=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 379}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk4MTAyOnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDoxNzo1NFrOGS280g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMjoxMToxMVrOGTZhLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzg1OA==", "bodyText": "Use GeodeAwaitility.await() instead.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427858", "createdAt": "2020-05-09T00:17:54Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 3 transactions of 4 events each are sent so that the batch would\n+    // initially contain the first 2 transactions complete and the first\n+    // 2 events of the last transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the last transaction are added to the batch which makes\n+    // that only one batch of 12 events is sent.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 6;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(3, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertTrue(\"Batch was not redistributed\",\n+        (v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)) > 0); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 6;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 6 transactions of 4 events each are sent so that the first batch\n+    // would initially contain the first 2 transactions complete and the first\n+    // 2 events of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the second transaction are added to the batch which makes\n+    // that the first batch is sent with 12 events. The same happens with the\n+    // second batch which will contain 12 events too.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 426}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk5NDIyMw==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r422994223", "createdAt": "2020-05-11T12:11:11Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 3 transactions of 4 events each are sent so that the batch would\n+    // initially contain the first 2 transactions complete and the first\n+    // 2 events of the last transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the last transaction are added to the batch which makes\n+    // that only one batch of 12 events is sent.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 6;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(3, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertTrue(\"Batch was not redistributed\",\n+        (v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)) > 0); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 6;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 6 transactions of 4 events each are sent so that the first batch\n+    // would initially contain the first 2 transactions complete and the first\n+    // 2 events of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the second transaction are added to the batch which makes\n+    // that the first batch is sent with 12 events. The same happens with the\n+    // second batch which will contain 12 events too.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzg1OA=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 426}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk4MTMwOnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDoxODowOFrOGS289Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMjo0MjoxNlrOGTahvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzg5Mw==", "bodyText": "More untidy comments.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427893", "createdAt": "2020-05-09T00:18:08Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 3 transactions of 4 events each are sent so that the batch would\n+    // initially contain the first 2 transactions complete and the first\n+    // 2 events of the last transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the last transaction are added to the batch which makes\n+    // that only one batch of 12 events is sent.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 6;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(3, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertTrue(\"Batch was not redistributed\",\n+        (v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)) > 0); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 6;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 6 transactions of 4 events each are sent so that the first batch\n+    // would initially contain the first 2 transactions complete and the first\n+    // 2 events of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the second transaction are added to the batch which makes\n+    // that the first batch is sent with 12 events. The same happens with the\n+    // second batch which will contain 12 events too.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    createReceiverInVMs(vm2);\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertTrue(\"Batch was not redistributed\",\n+        (v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)) > 0); // batches\n+    // redistributed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 453}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMDc0OQ==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423010749", "createdAt": "2020-05-11T12:42:16Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 3 transactions of 4 events each are sent so that the batch would\n+    // initially contain the first 2 transactions complete and the first\n+    // 2 events of the last transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the last transaction are added to the batch which makes\n+    // that only one batch of 12 events is sent.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 6;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(3, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertTrue(\"Batch was not redistributed\",\n+        (v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)) > 0); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 6;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 6 transactions of 4 events each are sent so that the first batch\n+    // would initially contain the first 2 transactions complete and the first\n+    // 2 events of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the second transaction are added to the batch which makes\n+    // that the first batch is sent with 12 events. The same happens with the\n+    // second batch which will contain 12 events too.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    createReceiverInVMs(vm2);\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertTrue(\"Batch was not redistributed\",\n+        (v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)) > 0); // batches\n+    // redistributed", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzg5Mw=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 453}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk4MTQ3OnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDoxODoxN1rOGS29EA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMjo0MjoyNlrOGTaiCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzkyMA==", "bodyText": "More untidy comments.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427920", "createdAt": "2020-05-09T00:18:17Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -343,15 +653,16 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_Redundancy_3(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(400, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(400,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(400, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                      // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 477}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMDgyNw==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423010827", "createdAt": "2020-05-11T12:42:26Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -343,15 +653,16 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_Redundancy_3(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(400, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(400,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(400, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                      // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzkyMA=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 477}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk4MTY5OnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDoxODozM1rOGS29NA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMjo0MjozOFrOGTaiew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzk1Ng==", "bodyText": "More untidy comments.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427956", "createdAt": "2020-05-09T00:18:33Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -503,17 +815,16 @@ public void testParallelPropagationWithRemoteRegionDestroy() throws Exception {\n     ArrayList<Integer> v7List =\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", -1));\n \n-\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 1); // batches\n-                                                                                    // distributed :\n-                                                                                    // its quite\n-                                                                                    // possible that\n-                                                                                    // vm4 has\n-                                                                                    // distributed\n-                                                                                    // some of the\n-                                                                                    // batches.\n+    // distributed :\n+    // its quite\n+    // possible that\n+    // vm4 has\n+    // distributed\n+    // some of the\n+    // batches.\n     assertTrue(v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5) >= 1); // batches\n-                                                                                    // redistributed\n+    // redistributed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 525}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMDkzOQ==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423010939", "createdAt": "2020-05-11T12:42:38Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -503,17 +815,16 @@ public void testParallelPropagationWithRemoteRegionDestroy() throws Exception {\n     ArrayList<Integer> v7List =\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", -1));\n \n-\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 1); // batches\n-                                                                                    // distributed :\n-                                                                                    // its quite\n-                                                                                    // possible that\n-                                                                                    // vm4 has\n-                                                                                    // distributed\n-                                                                                    // some of the\n-                                                                                    // batches.\n+    // distributed :\n+    // its quite\n+    // possible that\n+    // vm4 has\n+    // distributed\n+    // some of the\n+    // batches.\n     assertTrue(v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5) >= 1); // batches\n-                                                                                    // redistributed\n+    // redistributed", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzk1Ng=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 525}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTk4MjA5OnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDoxODo0M1rOGS29aA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMjo0Mjo0NlrOGTaizw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyODAwOA==", "bodyText": "More untidy comments.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422428008", "createdAt": "2020-05-09T00:18:43Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -559,17 +868,18 @@ public void testParallelPropagationWithFilter() throws Exception {\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(1000, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(1000,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(900, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                      // queued\n+    // queued\n     assertEquals(800, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                      // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 80); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n     assertEquals(200, v4List.get(6) + v5List.get(6) + v6List.get(6) + v7List.get(6)); // events\n-                                                                                      // filtered\n+    // filtered", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 559}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMTAyMw==", "bodyText": "ok", "url": "https://github.com/apache/geode/pull/4928#discussion_r423011023", "createdAt": "2020-05-11T12:42:46Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -559,17 +868,18 @@ public void testParallelPropagationWithFilter() throws Exception {\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(1000, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(1000,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(900, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                      // queued\n+    // queued\n     assertEquals(800, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                      // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 80); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n     assertEquals(200, v4List.get(6) + v5List.get(6) + v6List.get(6) + v7List.get(6)); // events\n-                                                                                      // filtered\n+    // filtered", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyODAwOA=="}, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 559}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzOTczODAxOnYy", "diffSide": "RIGHT", "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/CreateGatewaySenderCommand.java", "isResolved": false, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNzowNjowN1rOGUQf8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTo0MDoxMVrOGZbnfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5NTAyNw==", "bodyText": "This new option should be added to the docs for the create gateway-sender gfsh command in create.html.md.erb.", "url": "https://github.com/apache/geode/pull/4928#discussion_r423895027", "createdAt": "2020-05-12T17:06:07Z", "author": {"login": "DonalEvans"}, "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/CreateGatewaySenderCommand.java", "diffHunk": "@@ -75,6 +75,11 @@ public ResultModel createGatewaySender(\n           mandatory = true,\n           help = CliStrings.CREATE_GATEWAYSENDER__REMOTEDISTRIBUTEDSYSTEMID__HELP) Integer remoteDistributedSystemId,\n \n+      @CliOption(key = CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS,\n+          specifiedDefaultValue = \"true\",\n+          unspecifiedDefaultValue = \"false\",\n+          help = CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS__HELP) boolean groupTransactionEvents,\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d02bba6ade5d8aea068ee856ec8e5bbbcfe62f4"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAxODE5NA==", "bodyText": "Yep", "url": "https://github.com/apache/geode/pull/4928#discussion_r424018194", "createdAt": "2020-05-12T20:37:26Z", "author": {"login": "albertogpz"}, "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/CreateGatewaySenderCommand.java", "diffHunk": "@@ -75,6 +75,11 @@ public ResultModel createGatewaySender(\n           mandatory = true,\n           help = CliStrings.CREATE_GATEWAYSENDER__REMOTEDISTRIBUTEDSYSTEMID__HELP) Integer remoteDistributedSystemId,\n \n+      @CliOption(key = CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS,\n+          specifiedDefaultValue = \"true\",\n+          unspecifiedDefaultValue = \"false\",\n+          help = CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS__HELP) boolean groupTransactionEvents,\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5NTAyNw=="}, "originalCommit": {"oid": "8d02bba6ade5d8aea068ee856ec8e5bbbcfe62f4"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4Mzk5NQ==", "bodyText": "Note that the GatewaySender can be configured via the Java API ... not just through gfsh.  This is where I was hoping to get that check to ensure the user is configuring a valid GatewaySender (Serial GatewaySender).\nAlso, during internal testing with HA (killing servers) we've noticed data inconsistency between WAN Sites with groupTransactionEvents enabled.  In addition, I've seen the primary Serial GatewaySender AEQ not drain (again, with this attribute enabled).\nDo you have any DUnit Tests with HA (to verify that we still have consistency between wan sites and queues being drained when groupTransactionEvents is enabled)?\nWe are still investigating this and will update this PR as we narrow in on the root cause.", "url": "https://github.com/apache/geode/pull/4928#discussion_r424083995", "createdAt": "2020-05-12T23:07:49Z", "author": {"login": "ladyVader"}, "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/CreateGatewaySenderCommand.java", "diffHunk": "@@ -75,6 +75,11 @@ public ResultModel createGatewaySender(\n           mandatory = true,\n           help = CliStrings.CREATE_GATEWAYSENDER__REMOTEDISTRIBUTEDSYSTEMID__HELP) Integer remoteDistributedSystemId,\n \n+      @CliOption(key = CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS,\n+          specifiedDefaultValue = \"true\",\n+          unspecifiedDefaultValue = \"false\",\n+          help = CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS__HELP) boolean groupTransactionEvents,\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5NTAyNw=="}, "originalCommit": {"oid": "8d02bba6ade5d8aea068ee856ec8e5bbbcfe62f4"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMxNTk5NA==", "bodyText": "I forgot to add the check for the creation of the GatewaySender via the Java API.\nI have just pushed a new commit with this check in GatewaySenderFactoryImpl.\nRegarding your question about DUnit Tests with HA, I have not written any. I will try to investigate from my side the problems you have encountered.", "url": "https://github.com/apache/geode/pull/4928#discussion_r424315994", "createdAt": "2020-05-13T09:53:40Z", "author": {"login": "albertogpz"}, "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/CreateGatewaySenderCommand.java", "diffHunk": "@@ -75,6 +75,11 @@ public ResultModel createGatewaySender(\n           mandatory = true,\n           help = CliStrings.CREATE_GATEWAYSENDER__REMOTEDISTRIBUTEDSYSTEMID__HELP) Integer remoteDistributedSystemId,\n \n+      @CliOption(key = CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS,\n+          specifiedDefaultValue = \"true\",\n+          unspecifiedDefaultValue = \"false\",\n+          help = CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS__HELP) boolean groupTransactionEvents,\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5NTAyNw=="}, "originalCommit": {"oid": "8d02bba6ade5d8aea068ee856ec8e5bbbcfe62f4"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM0MTA0Mg==", "bodyText": "I ran both ParallelWANStatsDUnitTest::testParallelPropagationHA() and SerialWANStatsDUnitTest::testReplicatedSerialPropagationHA() but setting group-transaction-events to true in the gateway-senders used and both test cases passed too.", "url": "https://github.com/apache/geode/pull/4928#discussion_r424341042", "createdAt": "2020-05-13T10:39:38Z", "author": {"login": "albertogpz"}, "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/CreateGatewaySenderCommand.java", "diffHunk": "@@ -75,6 +75,11 @@ public ResultModel createGatewaySender(\n           mandatory = true,\n           help = CliStrings.CREATE_GATEWAYSENDER__REMOTEDISTRIBUTEDSYSTEMID__HELP) Integer remoteDistributedSystemId,\n \n+      @CliOption(key = CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS,\n+          specifiedDefaultValue = \"true\",\n+          unspecifiedDefaultValue = \"false\",\n+          help = CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS__HELP) boolean groupTransactionEvents,\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5NTAyNw=="}, "originalCommit": {"oid": "8d02bba6ade5d8aea068ee856ec8e5bbbcfe62f4"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg2OTgyMw==", "bodyText": "Note that the GatewaySender can be configured via the Java API ... not just through gfsh. This is where I was hoping to get that check to ensure the user is configuring a valid GatewaySender (Serial GatewaySender).\nAlso, during internal testing with HA (killing servers) we've noticed data inconsistency between WAN Sites with groupTransactionEvents enabled. In addition, I've seen the primary Serial GatewaySender AEQ not drain (again, with this attribute enabled).\nDo you have any DUnit Tests with HA (to verify that we still have consistency between wan sites and queues being drained when groupTransactionEvents is enabled)?\nWe are still investigating this and will update this PR as we narrow in on the root cause.\n\nI think I found the problem. There was a bug in the SerialGatewaySenderQueue handling of events that had to be added to the batch in order to complete a transaction that under high load and concurrency caused that some events were not propagated.\nI have added DUnit tests with HA for the serial and parallel gateway senders. The one for the SerialGatewaySender was failing before my fix.\nPlease, let me know if the new commit fixes the problem you encountered.", "url": "https://github.com/apache/geode/pull/4928#discussion_r425869823", "createdAt": "2020-05-15T15:13:32Z", "author": {"login": "albertogpz"}, "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/CreateGatewaySenderCommand.java", "diffHunk": "@@ -75,6 +75,11 @@ public ResultModel createGatewaySender(\n           mandatory = true,\n           help = CliStrings.CREATE_GATEWAYSENDER__REMOTEDISTRIBUTEDSYSTEMID__HELP) Integer remoteDistributedSystemId,\n \n+      @CliOption(key = CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS,\n+          specifiedDefaultValue = \"true\",\n+          unspecifiedDefaultValue = \"false\",\n+          help = CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS__HELP) boolean groupTransactionEvents,\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5NTAyNw=="}, "originalCommit": {"oid": "8d02bba6ade5d8aea068ee856ec8e5bbbcfe62f4"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgzMjUwNQ==", "bodyText": "@ladyVader Any news after the data inconsistency you found after having pushed my fix?", "url": "https://github.com/apache/geode/pull/4928#discussion_r427832505", "createdAt": "2020-05-20T08:30:18Z", "author": {"login": "albertogpz"}, "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/CreateGatewaySenderCommand.java", "diffHunk": "@@ -75,6 +75,11 @@ public ResultModel createGatewaySender(\n           mandatory = true,\n           help = CliStrings.CREATE_GATEWAYSENDER__REMOTEDISTRIBUTEDSYSTEMID__HELP) Integer remoteDistributedSystemId,\n \n+      @CliOption(key = CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS,\n+          specifiedDefaultValue = \"true\",\n+          unspecifiedDefaultValue = \"false\",\n+          help = CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS__HELP) boolean groupTransactionEvents,\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5NTAyNw=="}, "originalCommit": {"oid": "8d02bba6ade5d8aea068ee856ec8e5bbbcfe62f4"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMyMDA2MA==", "bodyText": "Thanks for both the new Exception on misconfiguring the SerialGatewaySender with groupTransactionEvents enabled + dispatcherThreads > 1.\nIn addition, I'm no longer seeing the data inconsistencies or hangs waiting for the primary gateway sender queue to drain.", "url": "https://github.com/apache/geode/pull/4928#discussion_r429320060", "createdAt": "2020-05-22T15:40:11Z", "author": {"login": "ladyVader"}, "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/CreateGatewaySenderCommand.java", "diffHunk": "@@ -75,6 +75,11 @@ public ResultModel createGatewaySender(\n           mandatory = true,\n           help = CliStrings.CREATE_GATEWAYSENDER__REMOTEDISTRIBUTEDSYSTEMID__HELP) Integer remoteDistributedSystemId,\n \n+      @CliOption(key = CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS,\n+          specifiedDefaultValue = \"true\",\n+          unspecifiedDefaultValue = \"false\",\n+          help = CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS__HELP) boolean groupTransactionEvents,\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5NTAyNw=="}, "originalCommit": {"oid": "8d02bba6ade5d8aea068ee856ec8e5bbbcfe62f4"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDc1NzY2OnYy", "diffSide": "RIGHT", "path": "geode-docs/tools_modules/gfsh/command-pages/create.html.md.erb", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMjowNzozN1rOGUasGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwOTo1MToxOVrOGUqG9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA2MTk3Ng==", "bodyText": "I think this should be --group-transaction-events(=value)? , since the value has a specified default value of true and so doesn't need to be included in all cases.", "url": "https://github.com/apache/geode/pull/4928#discussion_r424061976", "createdAt": "2020-05-12T22:07:37Z", "author": {"login": "DonalEvans"}, "path": "geode-docs/tools_modules/gfsh/command-pages/create.html.md.erb", "diffHunk": "@@ -504,6 +504,7 @@ create gateway-sender --id=value --remote-distributed-system-id=value\n    [--maximum-queue-memory=value] [--alert-threshold=value] [--dispatcher-threads=value] \n    [--order-policy=value][--gateway-event-filter=value(,value)*] \n    [--gateway-transport-filter=value(,value)*]\n+   [--group-transaction-events=value]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92b897bc0cd7dd914d06273df9018f9aae11b3aa"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIwODQxOA==", "bodyText": "You are right. The same should apply to --parallel. Right?", "url": "https://github.com/apache/geode/pull/4928#discussion_r424208418", "createdAt": "2020-05-13T06:49:29Z", "author": {"login": "albertogpz"}, "path": "geode-docs/tools_modules/gfsh/command-pages/create.html.md.erb", "diffHunk": "@@ -504,6 +504,7 @@ create gateway-sender --id=value --remote-distributed-system-id=value\n    [--maximum-queue-memory=value] [--alert-threshold=value] [--dispatcher-threads=value] \n    [--order-policy=value][--gateway-event-filter=value(,value)*] \n    [--gateway-transport-filter=value(,value)*]\n+   [--group-transaction-events=value]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA2MTk3Ng=="}, "originalCommit": {"oid": "92b897bc0cd7dd914d06273df9018f9aae11b3aa"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMxNDYxMw==", "bodyText": "You are right.\nIt should also be so in --parallel so I have corrected the documentation there too.", "url": "https://github.com/apache/geode/pull/4928#discussion_r424314613", "createdAt": "2020-05-13T09:51:19Z", "author": {"login": "albertogpz"}, "path": "geode-docs/tools_modules/gfsh/command-pages/create.html.md.erb", "diffHunk": "@@ -504,6 +504,7 @@ create gateway-sender --id=value --remote-distributed-system-id=value\n    [--maximum-queue-memory=value] [--alert-threshold=value] [--dispatcher-threads=value] \n    [--order-policy=value][--gateway-event-filter=value(,value)*] \n    [--gateway-transport-filter=value(,value)*]\n+   [--group-transaction-events=value]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA2MTk3Ng=="}, "originalCommit": {"oid": "92b897bc0cd7dd914d06273df9018f9aae11b3aa"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4286, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}