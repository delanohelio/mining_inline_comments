{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA2NjMwMDky", "number": 4978, "reviewThreads": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOTozNTo0N1rOD0qTkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNTo0OTo0MVrOD5dxsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NTQ1NjgyOnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/cache/client/internal/PingOp.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOTozNTo0N1rOGJtBcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNjoyODo0M1rOGJ_hBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgyODAxOQ==", "bodyText": "The above fields are not used anywhere, can we just remove them?, or am I missing something?.", "url": "https://github.com/apache/geode/pull/4978#discussion_r412828019", "createdAt": "2020-04-22T09:35:47Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/main/java/org/apache/geode/cache/client/internal/PingOp.java", "diffHunk": "@@ -43,12 +45,16 @@ private PingOp() {\n   static class PingOpImpl extends AbstractOp {\n \n     private long startTime;\n+    private ServerLocation location;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23a1eb1eb0d4861568be6bf5acbcc9055837b070"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEzMTAxMw==", "bodyText": "You are right, it seems they are not used, I will remove them.", "url": "https://github.com/apache/geode/pull/4978#discussion_r413131013", "createdAt": "2020-04-22T16:28:43Z", "author": {"login": "alb3rtobr"}, "path": "geode-core/src/main/java/org/apache/geode/cache/client/internal/PingOp.java", "diffHunk": "@@ -43,12 +45,16 @@ private PingOp() {\n   static class PingOpImpl extends AbstractOp {\n \n     private long startTime;\n+    private ServerLocation location;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgyODAxOQ=="}, "originalCommit": {"oid": "23a1eb1eb0d4861568be6bf5acbcc9055837b070"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NTUwNTg3OnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/cache/client/internal/PingOp.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOTo0Njo0M1rOGJtfnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwODo0ODowOFrOGLNUJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgzNTc0MQ==", "bodyText": "These operations can be directly executed within the PingOpImpl constructor, as we do with the rest of the messages. I've also noted that you changed the clearMessage flag from false to true as well, any reasons behind that?.", "url": "https://github.com/apache/geode/pull/4978#discussion_r412835741", "createdAt": "2020-04-22T09:46:43Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/main/java/org/apache/geode/cache/client/internal/PingOp.java", "diffHunk": "@@ -65,8 +71,9 @@ protected boolean needsUserId() {\n     @Override\n     protected void sendMessage(Connection cnx) throws Exception {\n       getMessage().clearMessageHasSecurePartFlag();\n-      this.startTime = System.currentTimeMillis();\n-      getMessage().send(false);\n+      getMessage().setNumberOfParts(1);\n+      getMessage().addObjPart(serverID);\n+      getMessage().send(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23a1eb1eb0d4861568be6bf5acbcc9055837b070"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE0MDU2OA==", "bodyText": "Im afraid I dont have a reason to explain that change. I used a draft from @bschuchardt when implementing this, and I didnt realize about it. Bruce, could you help with this please?", "url": "https://github.com/apache/geode/pull/4978#discussion_r414140568", "createdAt": "2020-04-23T21:36:07Z", "author": {"login": "alb3rtobr"}, "path": "geode-core/src/main/java/org/apache/geode/cache/client/internal/PingOp.java", "diffHunk": "@@ -65,8 +71,9 @@ protected boolean needsUserId() {\n     @Override\n     protected void sendMessage(Connection cnx) throws Exception {\n       getMessage().clearMessageHasSecurePartFlag();\n-      this.startTime = System.currentTimeMillis();\n-      getMessage().send(false);\n+      getMessage().setNumberOfParts(1);\n+      getMessage().addObjPart(serverID);\n+      getMessage().send(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgzNTc0MQ=="}, "originalCommit": {"oid": "23a1eb1eb0d4861568be6bf5acbcc9055837b070"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1MjA1MA==", "bodyText": "Ops that configure their message in constructors use AbstractOp.sendMessage().  This class already overrode that method so there's no reason to configure the message in the constructor.  That could be done though - is it a problem?\nMaybe we don't have to clear the message in Message.send(boolean) but the default implementation, Message.send(), does this and since we've introduced a Part to this message I thought it prudent to clear it.", "url": "https://github.com/apache/geode/pull/4978#discussion_r414152050", "createdAt": "2020-04-23T21:58:36Z", "author": {"login": "bschuchardt"}, "path": "geode-core/src/main/java/org/apache/geode/cache/client/internal/PingOp.java", "diffHunk": "@@ -65,8 +71,9 @@ protected boolean needsUserId() {\n     @Override\n     protected void sendMessage(Connection cnx) throws Exception {\n       getMessage().clearMessageHasSecurePartFlag();\n-      this.startTime = System.currentTimeMillis();\n-      getMessage().send(false);\n+      getMessage().setNumberOfParts(1);\n+      getMessage().addObjPart(serverID);\n+      getMessage().send(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgzNTc0MQ=="}, "originalCommit": {"oid": "23a1eb1eb0d4861568be6bf5acbcc9055837b070"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM4NTcxNQ==", "bodyText": "No problem at all, I was just checking as I saw other messages execute the entire configuration logic (set number of parts, adding parts, etc.) directly in the constructor.", "url": "https://github.com/apache/geode/pull/4978#discussion_r414385715", "createdAt": "2020-04-24T08:17:13Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/main/java/org/apache/geode/cache/client/internal/PingOp.java", "diffHunk": "@@ -65,8 +71,9 @@ protected boolean needsUserId() {\n     @Override\n     protected void sendMessage(Connection cnx) throws Exception {\n       getMessage().clearMessageHasSecurePartFlag();\n-      this.startTime = System.currentTimeMillis();\n-      getMessage().send(false);\n+      getMessage().setNumberOfParts(1);\n+      getMessage().addObjPart(serverID);\n+      getMessage().send(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgzNTc0MQ=="}, "originalCommit": {"oid": "23a1eb1eb0d4861568be6bf5acbcc9055837b070"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQwNTY2OA==", "bodyText": "thanks @bschuchardt", "url": "https://github.com/apache/geode/pull/4978#discussion_r414405668", "createdAt": "2020-04-24T08:48:08Z", "author": {"login": "alb3rtobr"}, "path": "geode-core/src/main/java/org/apache/geode/cache/client/internal/PingOp.java", "diffHunk": "@@ -65,8 +71,9 @@ protected boolean needsUserId() {\n     @Override\n     protected void sendMessage(Connection cnx) throws Exception {\n       getMessage().clearMessageHasSecurePartFlag();\n-      this.startTime = System.currentTimeMillis();\n-      getMessage().send(false);\n+      getMessage().setNumberOfParts(1);\n+      getMessage().addObjPart(serverID);\n+      getMessage().send(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgzNTc0MQ=="}, "originalCommit": {"oid": "23a1eb1eb0d4861568be6bf5acbcc9055837b070"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3Njg0MjAwOnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/membership/InternalDistributedMember.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxMjoxOTozMFrOGLVBIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxMjoxOTozMFrOGLVBIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUzMTg3Mw==", "bodyText": "You don't need to expose the MemberIdentifier here, you can directly use InternalDistributedMember.compareTo(DistributedMember o, boolean compareMemberData, boolean compareViewIds), which internally delegates to the MemberIdentifier class.", "url": "https://github.com/apache/geode/pull/4978#discussion_r414531873", "createdAt": "2020-04-24T12:19:30Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/membership/InternalDistributedMember.java", "diffHunk": "@@ -641,4 +641,8 @@ public UUID getUUID() {\n   public interface HostnameResolver {\n     InetAddress getInetAddress(ServerLocation location) throws UnknownHostException;\n   }\n+\n+  public MemberIdentifier getMemberIdentifier() {\n+    return memberIdentifier;\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e0e44ca076883fb21d6d3f8be227a50dcd0f577"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3Njg2Njk5OnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/tier/sockets/command/Ping.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxMjoyNTo0M1rOGLVPxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxMjoyNTo0M1rOGLVPxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUzNTYyMA==", "bodyText": "The issue described here still remains, you're comparing myID (instance of InternalDistributedMember) against targetServer.getMemberIdentifier() (instance of MemberIdentifier), so the comparison fails with a ClassCastException and the client logs the following:\n[warn 2020/04/24 01:33:02.869 PDT <poolTimer-edgeDescript-29> tid=0x112] Pool unexpected java.lang.ClassCastException: [B cannot be cast to java.lang.Throwable connection=Pooled Connection to rs-GEM-2885-0120a0i32xlarge-hydra-client-4:20245: Connection[DESTROYED]). Server unreachable: could not connect after 1 attempts", "url": "https://github.com/apache/geode/pull/4978#discussion_r414535620", "createdAt": "2020-04-24T12:25:43Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/tier/sockets/command/Ping.java", "diffHunk": "@@ -50,11 +51,17 @@ public void cmdExecute(final Message clientMessage, final ServerConnection serve\n     }\n     if (clientMessage.getNumberOfParts() > 0) {\n       try {\n-        DistributedMember targetServer = (DistributedMember) clientMessage.getPart(0).getObject();\n-        DistributedMember myID = serverConnection.getCache().getMyId();\n+        InternalDistributedMember targetServer =\n+            (InternalDistributedMember) clientMessage.getPart(0).getObject();\n+        InternalDistributedMember myID = serverConnection.getCache().getMyId();\n         if (!myID.equals(targetServer)) {\n-          pingCorrectServer(clientMessage, targetServer, serverConnection);\n-          writeReply(clientMessage, serverConnection);\n+          if (myID.compareTo(targetServer.getMemberIdentifier(), true, false) == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e0e44ca076883fb21d6d3f8be227a50dcd0f577"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NzA3ODEzOnYy", "diffSide": "LEFT", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/tier/sockets/command/Ping.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxMzoxNjoxOFrOGLXLfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxMzoxNjoxOFrOGLXLfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU2NzI5NQ==", "bodyText": "@jujoramos Implementing tests I realized this writeReply here is duplicated, pingCorrectServer is already calling it when the ping is forwarded. So this should be the cause for the error you saw about an unexpected REPLY message.", "url": "https://github.com/apache/geode/pull/4978#discussion_r414567295", "createdAt": "2020-04-24T13:16:18Z", "author": {"login": "alb3rtobr"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/tier/sockets/command/Ping.java", "diffHunk": "@@ -55,12 +55,11 @@ public void cmdExecute(final Message clientMessage, final ServerConnection serve\n             (InternalDistributedMember) clientMessage.getPart(0).getObject();\n         InternalDistributedMember myID = serverConnection.getCache().getMyId();\n         if (!myID.equals(targetServer)) {\n-          if (myID.compareTo(targetServer.getMemberIdentifier(), true, false) == 0) {\n+          if (myID.compareTo(targetServer, true, false) == 0) {\n             logger.warn(\"Target server {} has different viewId {}\", targetServer, myID);\n             writeErrorResponse(clientMessage, MessageType.EXCEPTION, serverConnection);\n           } else {\n             pingCorrectServer(clientMessage, targetServer, serverConnection);\n-            writeReply(clientMessage, serverConnection);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5105b6424f1c38e13ccd10d61ac6d7b185208010"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4Njk5OTkzOnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/LocatorLoadSnapshot.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNDozMTo1MFrOGMmTTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNDozMTo1MFrOGMmTTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg2MzYyOA==", "bodyText": "This entire class has several modifications and new non-trivial methods, we should add tests to verify the correct behaviour.", "url": "https://github.com/apache/geode/pull/4978#discussion_r415863628", "createdAt": "2020-04-27T14:31:50Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/LocatorLoadSnapshot.java", "diffHunk": "@@ -50,7 +50,8 @@\n \n   private final Map<ServerLocation, String[]> serverGroupMap = new HashMap<>();\n \n-  private final Map<String, Map<ServerLocation, LoadHolder>> connectionLoadMap = new HashMap<>();\n+  private final Map<String, Map<ServerLocationAndMemberId, LoadHolder>> connectionLoadMap =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "086b36a6265fd3aade6e1e2b2c3ab5c501e8374b"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NzAwMzU1OnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/membership/InternalDistributedMember.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNDozMjozNlrOGMmVfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNDozMjozNlrOGMmVfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg2NDE4OQ==", "bodyText": "Unnecessary empty line here.", "url": "https://github.com/apache/geode/pull/4978#discussion_r415864189", "createdAt": "2020-04-27T14:32:36Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/membership/InternalDistributedMember.java", "diffHunk": "@@ -641,4 +641,5 @@ public UUID getUUID() {\n   public interface HostnameResolver {\n     InetAddress getInetAddress(ServerLocation location) throws UnknownHostException;\n   }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "086b36a6265fd3aade6e1e2b2c3ab5c501e8374b"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NzAwNzc2OnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/DistributedPingMessage.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNDozMzoyMFrOGMmX_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNDoyNzoyMFrOGOr3Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg2NDgyOQ==", "bodyText": "This is a new class, unit and distribution tests are required.", "url": "https://github.com/apache/geode/pull/4978#discussion_r415864829", "createdAt": "2020-04-27T14:33:20Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/DistributedPingMessage.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.HighPriorityDistributionMessage;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.tier.sockets.ClientHealthMonitor;\n+import org.apache.geode.internal.cache.tier.sockets.ClientProxyMembershipID;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.internal.serialization.Version;\n+\n+public class DistributedPingMessage extends HighPriorityDistributionMessage {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "086b36a6265fd3aade6e1e2b2c3ab5c501e8374b"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA0MTk4NQ==", "bodyText": "Do you think its enough with the distributed tests added? I think the class so simple that there is nothing I could test with unit test that is not already tested by the distributed tests.", "url": "https://github.com/apache/geode/pull/4978#discussion_r418041985", "createdAt": "2020-04-30T14:14:02Z", "author": {"login": "alb3rtobr"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/DistributedPingMessage.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.HighPriorityDistributionMessage;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.tier.sockets.ClientHealthMonitor;\n+import org.apache.geode.internal.cache.tier.sockets.ClientProxyMembershipID;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.internal.serialization.Version;\n+\n+public class DistributedPingMessage extends HighPriorityDistributionMessage {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg2NDgyOQ=="}, "originalCommit": {"oid": "086b36a6265fd3aade6e1e2b2c3ab5c501e8374b"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA1MTg5NQ==", "bodyText": "Hey @alb3rtobr\nAgreed, the class itself is pretty simple... Having extra unit tests is harmless (and beneficial), however, so I'd say go ahead and add them, it shouldn't take long :-).", "url": "https://github.com/apache/geode/pull/4978#discussion_r418051895", "createdAt": "2020-04-30T14:27:20Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/DistributedPingMessage.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.HighPriorityDistributionMessage;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.tier.sockets.ClientHealthMonitor;\n+import org.apache.geode.internal.cache.tier.sockets.ClientProxyMembershipID;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.internal.serialization.Version;\n+\n+public class DistributedPingMessage extends HighPriorityDistributionMessage {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg2NDgyOQ=="}, "originalCommit": {"oid": "086b36a6265fd3aade6e1e2b2c3ab5c501e8374b"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNDA1MjA4OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/tier/sockets/PingOpDistributedTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxMTowNjoxN1rOGPHUDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxMTowNjoxN1rOGPHUDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUwMTY0NA==", "bodyText": "The exception is not thrown anywhere in the method, it can be removed.", "url": "https://github.com/apache/geode/pull/4978#discussion_r418501644", "createdAt": "2020-05-01T11:06:17Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/tier/sockets/PingOpDistributedTest.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.tier.sockets;\n+\n+import static java.util.Arrays.asList;\n+import static org.apache.geode.internal.AvailablePortHelper.getRandomAvailableTCPPortsForDUnitSite;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.client.ClientCacheFactory;\n+import org.apache.geode.cache.client.PoolFactory;\n+import org.apache.geode.cache.client.PoolManager;\n+import org.apache.geode.cache.client.ServerOperationException;\n+import org.apache.geode.cache.client.internal.PingOp;\n+import org.apache.geode.cache.client.internal.PoolImpl;\n+import org.apache.geode.cache.server.CacheServer;\n+import org.apache.geode.distributed.internal.ServerLocation;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.test.awaitility.GeodeAwaitility;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.ClientCacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+import org.apache.geode.test.junit.rules.serializable.SerializableTemporaryFolder;\n+import org.apache.geode.test.junit.rules.serializable.SerializableTestName;\n+\n+public class PingOpDistributedTest implements Serializable {\n+\n+  @Rule\n+  public CacheRule cacheRule = new CacheRule();\n+\n+  @Rule\n+  public ClientCacheRule clientCacheRule = new ClientCacheRule();\n+\n+  @Rule\n+  public SerializableTestName testName = new SerializableTestName();\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(2);\n+\n+  @Rule\n+  public SerializableTemporaryFolder folder = new SerializableTemporaryFolder();\n+\n+  private VM client;\n+  private VM server1, server2;\n+  private int server1Port, server2Port;\n+\n+\n+  private void initServer(int serverPort) throws IOException {\n+    cacheRule.createCache();\n+    CacheServer cacheServer = cacheRule.getCache().addCacheServer();\n+    cacheServer.setPort(serverPort);\n+\n+    // \"Disable\" the auto-ping for the duration of this test.\n+    cacheServer.setMaximumTimeBetweenPings((int) GeodeAwaitility.getTimeout().toMillis());\n+    cacheServer.start();\n+  }\n+\n+  private void initClient(String poolName, List<Integer> serverPorts) {\n+    final ClientCacheFactory clientCacheFactory = new ClientCacheFactory();\n+    clientCacheFactory.create();\n+\n+    PoolFactory poolFactory = PoolManager.createFactory();\n+    serverPorts.forEach(serverPort -> poolFactory.addServer(\"localhost\", serverPort));\n+\n+    // \"Disable\" the auto-ping for the duration of this test.\n+    poolFactory.setPingInterval((int) GeodeAwaitility.getTimeout().toMillis());\n+    poolFactory.create(poolName);\n+  }\n+\n+  @Before\n+  public void setUp() throws IOException {\n+    int[] ports = getRandomAvailableTCPPortsForDUnitSite(2);\n+\n+    client = getVM(0);\n+    server1 = getVM(1);\n+    server2 = getVM(2);\n+    server1Port = ports[0];\n+    server2Port = ports[1];\n+    server1.invoke(() -> initServer(server1Port));\n+    server2.invoke(() -> initServer(server2Port));\n+  }\n+\n+  void parametrizedSetUp(String poolName, List<Integer> serverPorts) {\n+    client.invoke(() -> initClient(poolName, serverPorts));\n+  }\n+\n+  public void executePing(String poolName, int serverPort,\n+      InternalDistributedMember distributedMember) {\n+    PoolImpl poolImpl = (PoolImpl) PoolManager.find(poolName);\n+    PingOp.execute(poolImpl, new ServerLocation(\"localhost\", serverPort), distributedMember);\n+  }\n+\n+  public Long getSingleHeartBeat() {\n+    ClientHealthMonitor chm = ClientHealthMonitor.getInstance();\n+    if (chm.getClientHeartbeats().size() == 0) {\n+      return 0L;\n+    }\n+    assertThat(chm.getClientHeartbeats()).isNotEmpty().hasSize(1);\n+\n+    return chm.getClientHeartbeats().entrySet().iterator().next().getValue();\n+  }\n+\n+  @Test\n+  public void regularPingFlow() {\n+    final String poolName = testName.getMethodName();\n+    parametrizedSetUp(poolName, Collections.singletonList(server1Port));\n+    InternalDistributedMember distributedMember1 = (InternalDistributedMember) server1\n+        .invoke(() -> cacheRule.getCache().getDistributedSystem().getDistributedMember());\n+\n+    client.invoke(() -> executePing(poolName, server1Port, distributedMember1));\n+    Long firstHeartbeat = server1.invoke(this::getSingleHeartBeat);\n+\n+    client.invoke(() -> executePing(poolName, server1Port, distributedMember1));\n+    Long secondHeartbeat = server1.invoke(this::getSingleHeartBeat);\n+\n+    assertThat(secondHeartbeat).isGreaterThan(firstHeartbeat);\n+\n+  }\n+\n+  @Test\n+  public void memberShouldNotRedirectPingMessageWhenClientCachedViewIdIsWrong() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "759492734e2fe7877b995429b45c7ff3cd072c9e"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNDA1MzI0OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/tier/sockets/PingOpDistributedTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxMTowNjo0N1rOGPHUpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxMTowNjo0N1rOGPHUpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUwMTc5Ng==", "bodyText": "The exception is not thrown anywhere in the method, it can be removed.", "url": "https://github.com/apache/geode/pull/4978#discussion_r418501796", "createdAt": "2020-05-01T11:06:47Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/tier/sockets/PingOpDistributedTest.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.tier.sockets;\n+\n+import static java.util.Arrays.asList;\n+import static org.apache.geode.internal.AvailablePortHelper.getRandomAvailableTCPPortsForDUnitSite;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.client.ClientCacheFactory;\n+import org.apache.geode.cache.client.PoolFactory;\n+import org.apache.geode.cache.client.PoolManager;\n+import org.apache.geode.cache.client.ServerOperationException;\n+import org.apache.geode.cache.client.internal.PingOp;\n+import org.apache.geode.cache.client.internal.PoolImpl;\n+import org.apache.geode.cache.server.CacheServer;\n+import org.apache.geode.distributed.internal.ServerLocation;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.test.awaitility.GeodeAwaitility;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.ClientCacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+import org.apache.geode.test.junit.rules.serializable.SerializableTemporaryFolder;\n+import org.apache.geode.test.junit.rules.serializable.SerializableTestName;\n+\n+public class PingOpDistributedTest implements Serializable {\n+\n+  @Rule\n+  public CacheRule cacheRule = new CacheRule();\n+\n+  @Rule\n+  public ClientCacheRule clientCacheRule = new ClientCacheRule();\n+\n+  @Rule\n+  public SerializableTestName testName = new SerializableTestName();\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(2);\n+\n+  @Rule\n+  public SerializableTemporaryFolder folder = new SerializableTemporaryFolder();\n+\n+  private VM client;\n+  private VM server1, server2;\n+  private int server1Port, server2Port;\n+\n+\n+  private void initServer(int serverPort) throws IOException {\n+    cacheRule.createCache();\n+    CacheServer cacheServer = cacheRule.getCache().addCacheServer();\n+    cacheServer.setPort(serverPort);\n+\n+    // \"Disable\" the auto-ping for the duration of this test.\n+    cacheServer.setMaximumTimeBetweenPings((int) GeodeAwaitility.getTimeout().toMillis());\n+    cacheServer.start();\n+  }\n+\n+  private void initClient(String poolName, List<Integer> serverPorts) {\n+    final ClientCacheFactory clientCacheFactory = new ClientCacheFactory();\n+    clientCacheFactory.create();\n+\n+    PoolFactory poolFactory = PoolManager.createFactory();\n+    serverPorts.forEach(serverPort -> poolFactory.addServer(\"localhost\", serverPort));\n+\n+    // \"Disable\" the auto-ping for the duration of this test.\n+    poolFactory.setPingInterval((int) GeodeAwaitility.getTimeout().toMillis());\n+    poolFactory.create(poolName);\n+  }\n+\n+  @Before\n+  public void setUp() throws IOException {\n+    int[] ports = getRandomAvailableTCPPortsForDUnitSite(2);\n+\n+    client = getVM(0);\n+    server1 = getVM(1);\n+    server2 = getVM(2);\n+    server1Port = ports[0];\n+    server2Port = ports[1];\n+    server1.invoke(() -> initServer(server1Port));\n+    server2.invoke(() -> initServer(server2Port));\n+  }\n+\n+  void parametrizedSetUp(String poolName, List<Integer> serverPorts) {\n+    client.invoke(() -> initClient(poolName, serverPorts));\n+  }\n+\n+  public void executePing(String poolName, int serverPort,\n+      InternalDistributedMember distributedMember) {\n+    PoolImpl poolImpl = (PoolImpl) PoolManager.find(poolName);\n+    PingOp.execute(poolImpl, new ServerLocation(\"localhost\", serverPort), distributedMember);\n+  }\n+\n+  public Long getSingleHeartBeat() {\n+    ClientHealthMonitor chm = ClientHealthMonitor.getInstance();\n+    if (chm.getClientHeartbeats().size() == 0) {\n+      return 0L;\n+    }\n+    assertThat(chm.getClientHeartbeats()).isNotEmpty().hasSize(1);\n+\n+    return chm.getClientHeartbeats().entrySet().iterator().next().getValue();\n+  }\n+\n+  @Test\n+  public void regularPingFlow() {\n+    final String poolName = testName.getMethodName();\n+    parametrizedSetUp(poolName, Collections.singletonList(server1Port));\n+    InternalDistributedMember distributedMember1 = (InternalDistributedMember) server1\n+        .invoke(() -> cacheRule.getCache().getDistributedSystem().getDistributedMember());\n+\n+    client.invoke(() -> executePing(poolName, server1Port, distributedMember1));\n+    Long firstHeartbeat = server1.invoke(this::getSingleHeartBeat);\n+\n+    client.invoke(() -> executePing(poolName, server1Port, distributedMember1));\n+    Long secondHeartbeat = server1.invoke(this::getSingleHeartBeat);\n+\n+    assertThat(secondHeartbeat).isGreaterThan(firstHeartbeat);\n+\n+  }\n+\n+  @Test\n+  public void memberShouldNotRedirectPingMessageWhenClientCachedViewIdIsWrong() throws IOException {\n+    final String poolName = testName.getMethodName();\n+    parametrizedSetUp(poolName, Collections.singletonList(server1Port));\n+    InternalDistributedMember distributedMember1 = (InternalDistributedMember) server1\n+        .invoke(() -> cacheRule.getCache().getDistributedSystem().getDistributedMember());\n+\n+    client.invoke(() -> {\n+      PoolImpl poolImpl = (PoolImpl) PoolManager.find(poolName);\n+      distributedMember1.setVmViewId(distributedMember1.getVmViewId() + 1);\n+      assertThatThrownBy(() -> {\n+        PingOp.execute(poolImpl, new ServerLocation(\"localhost\", server1Port), distributedMember1);\n+      }).isInstanceOf(ServerOperationException.class).hasMessageContaining(\"has different viewId:\");\n+    });\n+  }\n+\n+  @Test\n+  public void pingReturnsErrorIfTheTargetServerIsNotAMember() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "759492734e2fe7877b995429b45c7ff3cd072c9e"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNDA1NjY4OnYy", "diffSide": "RIGHT", "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/tier/sockets/PingOpDistributedTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxMTowODo0MVrOGPHWfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxMTowODo0MVrOGPHWfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUwMjI2OQ==", "bodyText": "The exceptions are not thrown anywhere in the method, they can be removed.", "url": "https://github.com/apache/geode/pull/4978#discussion_r418502269", "createdAt": "2020-05-01T11:08:41Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/internal/cache/tier/sockets/PingOpDistributedTest.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.tier.sockets;\n+\n+import static java.util.Arrays.asList;\n+import static org.apache.geode.internal.AvailablePortHelper.getRandomAvailableTCPPortsForDUnitSite;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.client.ClientCacheFactory;\n+import org.apache.geode.cache.client.PoolFactory;\n+import org.apache.geode.cache.client.PoolManager;\n+import org.apache.geode.cache.client.ServerOperationException;\n+import org.apache.geode.cache.client.internal.PingOp;\n+import org.apache.geode.cache.client.internal.PoolImpl;\n+import org.apache.geode.cache.server.CacheServer;\n+import org.apache.geode.distributed.internal.ServerLocation;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.test.awaitility.GeodeAwaitility;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.ClientCacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+import org.apache.geode.test.junit.rules.serializable.SerializableTemporaryFolder;\n+import org.apache.geode.test.junit.rules.serializable.SerializableTestName;\n+\n+public class PingOpDistributedTest implements Serializable {\n+\n+  @Rule\n+  public CacheRule cacheRule = new CacheRule();\n+\n+  @Rule\n+  public ClientCacheRule clientCacheRule = new ClientCacheRule();\n+\n+  @Rule\n+  public SerializableTestName testName = new SerializableTestName();\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule(2);\n+\n+  @Rule\n+  public SerializableTemporaryFolder folder = new SerializableTemporaryFolder();\n+\n+  private VM client;\n+  private VM server1, server2;\n+  private int server1Port, server2Port;\n+\n+\n+  private void initServer(int serverPort) throws IOException {\n+    cacheRule.createCache();\n+    CacheServer cacheServer = cacheRule.getCache().addCacheServer();\n+    cacheServer.setPort(serverPort);\n+\n+    // \"Disable\" the auto-ping for the duration of this test.\n+    cacheServer.setMaximumTimeBetweenPings((int) GeodeAwaitility.getTimeout().toMillis());\n+    cacheServer.start();\n+  }\n+\n+  private void initClient(String poolName, List<Integer> serverPorts) {\n+    final ClientCacheFactory clientCacheFactory = new ClientCacheFactory();\n+    clientCacheFactory.create();\n+\n+    PoolFactory poolFactory = PoolManager.createFactory();\n+    serverPorts.forEach(serverPort -> poolFactory.addServer(\"localhost\", serverPort));\n+\n+    // \"Disable\" the auto-ping for the duration of this test.\n+    poolFactory.setPingInterval((int) GeodeAwaitility.getTimeout().toMillis());\n+    poolFactory.create(poolName);\n+  }\n+\n+  @Before\n+  public void setUp() throws IOException {\n+    int[] ports = getRandomAvailableTCPPortsForDUnitSite(2);\n+\n+    client = getVM(0);\n+    server1 = getVM(1);\n+    server2 = getVM(2);\n+    server1Port = ports[0];\n+    server2Port = ports[1];\n+    server1.invoke(() -> initServer(server1Port));\n+    server2.invoke(() -> initServer(server2Port));\n+  }\n+\n+  void parametrizedSetUp(String poolName, List<Integer> serverPorts) {\n+    client.invoke(() -> initClient(poolName, serverPorts));\n+  }\n+\n+  public void executePing(String poolName, int serverPort,\n+      InternalDistributedMember distributedMember) {\n+    PoolImpl poolImpl = (PoolImpl) PoolManager.find(poolName);\n+    PingOp.execute(poolImpl, new ServerLocation(\"localhost\", serverPort), distributedMember);\n+  }\n+\n+  public Long getSingleHeartBeat() {\n+    ClientHealthMonitor chm = ClientHealthMonitor.getInstance();\n+    if (chm.getClientHeartbeats().size() == 0) {\n+      return 0L;\n+    }\n+    assertThat(chm.getClientHeartbeats()).isNotEmpty().hasSize(1);\n+\n+    return chm.getClientHeartbeats().entrySet().iterator().next().getValue();\n+  }\n+\n+  @Test\n+  public void regularPingFlow() {\n+    final String poolName = testName.getMethodName();\n+    parametrizedSetUp(poolName, Collections.singletonList(server1Port));\n+    InternalDistributedMember distributedMember1 = (InternalDistributedMember) server1\n+        .invoke(() -> cacheRule.getCache().getDistributedSystem().getDistributedMember());\n+\n+    client.invoke(() -> executePing(poolName, server1Port, distributedMember1));\n+    Long firstHeartbeat = server1.invoke(this::getSingleHeartBeat);\n+\n+    client.invoke(() -> executePing(poolName, server1Port, distributedMember1));\n+    Long secondHeartbeat = server1.invoke(this::getSingleHeartBeat);\n+\n+    assertThat(secondHeartbeat).isGreaterThan(firstHeartbeat);\n+\n+  }\n+\n+  @Test\n+  public void memberShouldNotRedirectPingMessageWhenClientCachedViewIdIsWrong() throws IOException {\n+    final String poolName = testName.getMethodName();\n+    parametrizedSetUp(poolName, Collections.singletonList(server1Port));\n+    InternalDistributedMember distributedMember1 = (InternalDistributedMember) server1\n+        .invoke(() -> cacheRule.getCache().getDistributedSystem().getDistributedMember());\n+\n+    client.invoke(() -> {\n+      PoolImpl poolImpl = (PoolImpl) PoolManager.find(poolName);\n+      distributedMember1.setVmViewId(distributedMember1.getVmViewId() + 1);\n+      assertThatThrownBy(() -> {\n+        PingOp.execute(poolImpl, new ServerLocation(\"localhost\", server1Port), distributedMember1);\n+      }).isInstanceOf(ServerOperationException.class).hasMessageContaining(\"has different viewId:\");\n+    });\n+  }\n+\n+  @Test\n+  public void pingReturnsErrorIfTheTargetServerIsNotAMember() throws IOException {\n+    final String poolName = testName.getMethodName();\n+    parametrizedSetUp(poolName, Collections.singletonList(server1Port));\n+    int notUsedPort = getRandomAvailableTCPPortsForDUnitSite(1)[0];\n+    InternalDistributedMember fakeDistributedMember =\n+        new InternalDistributedMember(\"localhost\", notUsedPort);\n+    client.invoke(() -> {\n+      PoolImpl poolImpl = (PoolImpl) PoolManager.find(poolName);\n+      assertThatThrownBy(() -> {\n+        PingOp.execute(poolImpl, new ServerLocation(\"localhost\", server1Port),\n+            fakeDistributedMember);\n+      }).isInstanceOf(ServerOperationException.class)\n+          .hasMessageContaining(\"Unable to ping non-member\");\n+    });\n+  }\n+\n+  @Test\n+  public void memberShouldCorrectlyRedirectPingMessage() throws IOException, InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "759492734e2fe7877b995429b45c7ff3cd072c9e"}, "originalPosition": 177}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNDA3NTgyOnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/cache/client/internal/PingOp.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxMToxOTozMlrOGPHhVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxNDoxMzozMlrOGPKzZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUwNTA0Ng==", "bodyText": "I'm not sure it is entirely correct to override the procesAck method... Looking through the source code, there's only one operation overriding this (TXSynchronizationOp) and it ends up delegating to the super class method whenever the exception is not the one it knows how to handle. There's also a comment regarding c++ clients in AbstractOp.processAck(), we should be careful not to break those clients as well.\n@bschuchardt: thoughts on this one?.", "url": "https://github.com/apache/geode/pull/4978#discussion_r418505046", "createdAt": "2020-05-01T11:19:32Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/main/java/org/apache/geode/cache/client/internal/PingOp.java", "diffHunk": "@@ -65,17 +71,33 @@ protected boolean needsUserId() {\n     @Override\n     protected void sendMessage(Connection cnx) throws Exception {\n       getMessage().clearMessageHasSecurePartFlag();\n-      this.startTime = System.currentTimeMillis();\n-      getMessage().send(false);\n+      getMessage().setNumberOfParts(1);\n+      getMessage().addObjPart(serverID);\n+      getMessage().send(true);\n       Message.MESSAGE_TYPE.set(MessageType.PING);\n     }\n \n     @Override\n     protected Object processResponse(Message msg) throws Exception {\n-      processAck(msg, \"ping\");\n+      processAck(msg);\n       return null;\n     }\n \n+    private void processAck(Message msg) throws Exception {\n+      final int msgType = msg.getMessageType();\n+      if (msgType != MessageType.REPLY) {\n+        Part part = msg.getPart(0);\n+        if (msgType == MessageType.EXCEPTION) {\n+          Throwable t = (Throwable) part.getObject();\n+          throw new ServerOperationException(\"While performing a remote ping: \" + t.getMessage(),\n+              t);\n+        } else {\n+          throw new InternalGemFireError(\n+              \"Unexpected message type \" + MessageType.getString(msgType));\n+        }\n+      }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "759492734e2fe7877b995429b45c7ff3cd072c9e"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU1ODgyMw==", "bodyText": "This method is not necessary. I started with a different method, but at the end, its doing the same as AbstractOp.processAck(), I will remove it.", "url": "https://github.com/apache/geode/pull/4978#discussion_r418558823", "createdAt": "2020-05-01T14:13:32Z", "author": {"login": "alb3rtobr"}, "path": "geode-core/src/main/java/org/apache/geode/cache/client/internal/PingOp.java", "diffHunk": "@@ -65,17 +71,33 @@ protected boolean needsUserId() {\n     @Override\n     protected void sendMessage(Connection cnx) throws Exception {\n       getMessage().clearMessageHasSecurePartFlag();\n-      this.startTime = System.currentTimeMillis();\n-      getMessage().send(false);\n+      getMessage().setNumberOfParts(1);\n+      getMessage().addObjPart(serverID);\n+      getMessage().send(true);\n       Message.MESSAGE_TYPE.set(MessageType.PING);\n     }\n \n     @Override\n     protected Object processResponse(Message msg) throws Exception {\n-      processAck(msg, \"ping\");\n+      processAck(msg);\n       return null;\n     }\n \n+    private void processAck(Message msg) throws Exception {\n+      final int msgType = msg.getMessageType();\n+      if (msgType != MessageType.REPLY) {\n+        Part part = msg.getPart(0);\n+        if (msgType == MessageType.EXCEPTION) {\n+          Throwable t = (Throwable) part.getObject();\n+          throw new ServerOperationException(\"While performing a remote ping: \" + t.getMessage(),\n+              t);\n+        } else {\n+          throw new InternalGemFireError(\n+              \"Unexpected message type \" + MessageType.getString(msgType));\n+        }\n+      }\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUwNTA0Ng=="}, "originalCommit": {"oid": "759492734e2fe7877b995429b45c7ff3cd072c9e"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNDA4MTUyOnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/ServerLocationAndMemberId.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxMToyMjo0OFrOGPHklQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxMToyMjo0OFrOGPHklQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUwNTg3Nw==", "bodyText": "Can these two fields be declared as final?.", "url": "https://github.com/apache/geode/pull/4978#discussion_r418505877", "createdAt": "2020-05-01T11:22:48Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/ServerLocationAndMemberId.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.distributed.internal;\n+\n+public class ServerLocationAndMemberId {\n+\n+  private ServerLocation serverLocation;\n+  private String memberId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "759492734e2fe7877b995429b45c7ff3cd072c9e"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNDExNjk4OnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/GridAdvisor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxMTo0NTozNVrOGPH4bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxNDo1Nzo1OFrOGPMA7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUxMDk1OA==", "bodyText": "Should we use getMemberId().getUniqueId() here instead of just getMemberId(), as that's what we are using to calculate the hashCode?.", "url": "https://github.com/apache/geode/pull/4978#discussion_r418510958", "createdAt": "2020-05-01T11:45:35Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/GridAdvisor.java", "diffHunk": "@@ -418,18 +418,24 @@ public String toString() {\n     public int hashCode() {\n       final String thisHost = this.gp.getHost();\n       final int thisPort = this.gp.getPort();\n-      return thisHost != null ? (thisHost.hashCode() ^ thisPort) : thisPort;\n+      final String thisMemberId = this.getMemberId().getUniqueId();\n+      final int thisMemberIdHashCode = (thisMemberId != null) ? thisMemberId.hashCode() : 0;\n+      return thisHost != null ? (thisHost.hashCode() ^ thisPort) + thisMemberIdHashCode\n+          : thisPort + thisMemberIdHashCode;\n     }\n \n     @Override\n     public boolean equals(Object obj) {\n       if (obj instanceof GridProfileId) {\n         final GridProfileId other = (GridProfileId) obj;\n+\n         if (this.gp.getPort() == other.gp.getPort()) {\n           final String thisHost = this.gp.getHost();\n           final String otherHost = other.gp.getHost();\n           if (thisHost != null) {\n-            return thisHost.equals(otherHost);\n+            if (thisHost.equals(otherHost)) {\n+              return this.getMemberId().equals(other.getMemberId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "759492734e2fe7877b995429b45c7ff3cd072c9e"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU3ODY2OQ==", "bodyText": "Good catch!", "url": "https://github.com/apache/geode/pull/4978#discussion_r418578669", "createdAt": "2020-05-01T14:57:58Z", "author": {"login": "alb3rtobr"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/GridAdvisor.java", "diffHunk": "@@ -418,18 +418,24 @@ public String toString() {\n     public int hashCode() {\n       final String thisHost = this.gp.getHost();\n       final int thisPort = this.gp.getPort();\n-      return thisHost != null ? (thisHost.hashCode() ^ thisPort) : thisPort;\n+      final String thisMemberId = this.getMemberId().getUniqueId();\n+      final int thisMemberIdHashCode = (thisMemberId != null) ? thisMemberId.hashCode() : 0;\n+      return thisHost != null ? (thisHost.hashCode() ^ thisPort) + thisMemberIdHashCode\n+          : thisPort + thisMemberIdHashCode;\n     }\n \n     @Override\n     public boolean equals(Object obj) {\n       if (obj instanceof GridProfileId) {\n         final GridProfileId other = (GridProfileId) obj;\n+\n         if (this.gp.getPort() == other.gp.getPort()) {\n           final String thisHost = this.gp.getHost();\n           final String otherHost = other.gp.getHost();\n           if (thisHost != null) {\n-            return thisHost.equals(otherHost);\n+            if (thisHost.equals(otherHost)) {\n+              return this.getMemberId().equals(other.getMemberId());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUxMDk1OA=="}, "originalCommit": {"oid": "759492734e2fe7877b995429b45c7ff3cd072c9e"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNDExODI4OnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/tier/sockets/command/Ping.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxMTo0NjoyNlrOGPH5MQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxMTo0NjoyNlrOGPH5MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUxMTE1Mw==", "bodyText": "No need to use format as we are not using parameters, just concatenating String objects.", "url": "https://github.com/apache/geode/pull/4978#discussion_r418511153", "createdAt": "2020-05-01T11:46:26Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/tier/sockets/command/Ping.java", "diffHunk": "@@ -47,10 +50,37 @@ public void cmdExecute(final Message clientMessage, final ServerConnection serve\n           clientMessage.getTransactionId(), serverConnection.getSocketString(),\n           (DistributionStats.getStatTime() - start));\n     }\n+    if (clientMessage.getNumberOfParts() > 0) {\n+      try {\n+        InternalDistributedMember targetServer =\n+            (InternalDistributedMember) clientMessage.getPart(0).getObject();\n+        InternalDistributedMember myID = serverConnection.getCache().getMyId();\n+        if (!myID.equals(targetServer)) {\n+          if (myID.compareTo(targetServer, true, false) == 0) {\n+            String errorMessage =\n+                String.format(\"Target server \" + targetServer + \" has different viewId: \" + myID);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "759492734e2fe7877b995429b45c7ff3cd072c9e"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNDEzNDIzOnYy", "diffSide": "RIGHT", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/tier/sockets/command/PingTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxMTo1NjoyMVrOGPICEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxNjo1NjoxNFrOGPPPJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUxMzQyNw==", "bodyText": "Tests could be improved to also assert that the receivedPing method from the ClientHealthMonitor class has been invoked when required. Just a suggestion, anyways.", "url": "https://github.com/apache/geode/pull/4978#discussion_r418513427", "createdAt": "2020-05-01T11:56:21Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/tier/sockets/command/PingTest.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.tier.sockets.command;\n+\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.ServerLocation;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.tier.sockets.Message;\n+import org.apache.geode.internal.cache.tier.sockets.Part;\n+import org.apache.geode.internal.cache.tier.sockets.ServerConnection;\n+\n+public class PingTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "759492734e2fe7877b995429b45c7ff3cd072c9e"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU3NjgzNw==", "bodyText": "Im not sure if it can be done. The ClientHealthMonitor object is obtained using a static method, which cannot be mocked.", "url": "https://github.com/apache/geode/pull/4978#discussion_r418576837", "createdAt": "2020-05-01T14:53:53Z", "author": {"login": "alb3rtobr"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/tier/sockets/command/PingTest.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.tier.sockets.command;\n+\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.ServerLocation;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.tier.sockets.Message;\n+import org.apache.geode.internal.cache.tier.sockets.Part;\n+import org.apache.geode.internal.cache.tier.sockets.ServerConnection;\n+\n+public class PingTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUxMzQyNw=="}, "originalCommit": {"oid": "759492734e2fe7877b995429b45c7ff3cd072c9e"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU3OTY0NA==", "bodyText": "Agreed, but you could easily move the whole logic about getting ClientHealthMonitor and updating the ping received to an extra method, which can be mocked and/or spied.\nAnother option would be to move the retrieval of the ClientHealthMonitor class to an extra method and mock that method to return your own spied ClientHealthMonitor, which can be checked afterwards.", "url": "https://github.com/apache/geode/pull/4978#discussion_r418579644", "createdAt": "2020-05-01T15:00:16Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/tier/sockets/command/PingTest.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.tier.sockets.command;\n+\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.ServerLocation;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.tier.sockets.Message;\n+import org.apache.geode.internal.cache.tier.sockets.Part;\n+import org.apache.geode.internal.cache.tier.sockets.ServerConnection;\n+\n+public class PingTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUxMzQyNw=="}, "originalCommit": {"oid": "759492734e2fe7877b995429b45c7ff3cd072c9e"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYzMTQ2Mw==", "bodyText": "done!", "url": "https://github.com/apache/geode/pull/4978#discussion_r418631463", "createdAt": "2020-05-01T16:56:14Z", "author": {"login": "alb3rtobr"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/tier/sockets/command/PingTest.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.tier.sockets.command;\n+\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.ServerLocation;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.tier.sockets.Message;\n+import org.apache.geode.internal.cache.tier.sockets.Part;\n+import org.apache.geode.internal.cache.tier.sockets.ServerConnection;\n+\n+public class PingTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUxMzQyNw=="}, "originalCommit": {"oid": "759492734e2fe7877b995429b45c7ff3cd072c9e"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNDQ3OTc1OnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/ServerLocationAndMemberId.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMDowNzozNFrOGQitJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMzoyMjoyNVrOGQpHDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk5OTAxMg==", "bodyText": "This constructor doesn't seem to be used anywhere, so we could just delete it.", "url": "https://github.com/apache/geode/pull/4978#discussion_r419999012", "createdAt": "2020-05-05T10:07:34Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/ServerLocationAndMemberId.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.distributed.internal;\n+\n+public class ServerLocationAndMemberId {\n+\n+  private final ServerLocation serverLocation;\n+  private final String memberId;\n+\n+  public ServerLocationAndMemberId() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a005b9096dc4c2fcacc6a8ee52eb8a7236d6667a"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDEwMzk0OA==", "bodyText": "done. After removing this constructor I was able to remove other one more.", "url": "https://github.com/apache/geode/pull/4978#discussion_r420103948", "createdAt": "2020-05-05T13:22:25Z", "author": {"login": "alb3rtobr"}, "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/ServerLocationAndMemberId.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.distributed.internal;\n+\n+public class ServerLocationAndMemberId {\n+\n+  private final ServerLocation serverLocation;\n+  private final String memberId;\n+\n+  public ServerLocationAndMemberId() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk5OTAxMg=="}, "originalCommit": {"oid": "a005b9096dc4c2fcacc6a8ee52eb8a7236d6667a"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNDUyMTIxOnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/LocatorLoadSnapshot.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMDoyMDoyNFrOGQjGmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNDoxNjowNVrOGQribQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAwNTUyOA==", "bodyText": "This is a new method and should be, at leat, unit tested.\nYou can make it package private, annotate it with @VisibleForTesting and access it directly from LocatorLoadSnapshotJUnitTest and/or LocatorLoadSnapshotIntegrationTest.", "url": "https://github.com/apache/geode/pull/4978#discussion_r420005528", "createdAt": "2020-05-05T10:20:24Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/LocatorLoadSnapshot.java", "diffHunk": "@@ -425,6 +429,22 @@ private void addGroups(Map<String, Map<ServerLocation, LoadHolder>> map, String[\n     }\n   }\n \n+  private void addGroups(Map<String, Map<ServerLocationAndMemberId, LoadHolder>> map,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a005b9096dc4c2fcacc6a8ee52eb8a7236d6667a"}, "originalPosition": 187}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE0MzcyNQ==", "bodyText": "done", "url": "https://github.com/apache/geode/pull/4978#discussion_r420143725", "createdAt": "2020-05-05T14:16:05Z", "author": {"login": "alb3rtobr"}, "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/LocatorLoadSnapshot.java", "diffHunk": "@@ -425,6 +429,22 @@ private void addGroups(Map<String, Map<ServerLocation, LoadHolder>> map, String[\n     }\n   }\n \n+  private void addGroups(Map<String, Map<ServerLocationAndMemberId, LoadHolder>> map,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAwNTUyOA=="}, "originalCommit": {"oid": "a005b9096dc4c2fcacc6a8ee52eb8a7236d6667a"}, "originalPosition": 187}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNDUyMTYzOnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/LocatorLoadSnapshot.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMDoyMDozMVrOGQjG0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNDoxNTo1NVrOGQrh7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAwNTU4NQ==", "bodyText": "This is a new method and should be, at leat, unit tested.\nYou can make it package private, annotate it with @VisibleForTesting and access it directly from LocatorLoadSnapshotJUnitTest and/or LocatorLoadSnapshotIntegrationTest.", "url": "https://github.com/apache/geode/pull/4978#discussion_r420005585", "createdAt": "2020-05-05T10:20:31Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/LocatorLoadSnapshot.java", "diffHunk": "@@ -440,6 +460,24 @@ private void removeFromMap(Map<String, Map<ServerLocation, LoadHolder>> map, Str\n     groupMap.remove(location);\n   }\n \n+  private void removeFromMap(Map<String, Map<ServerLocationAndMemberId, LoadHolder>> map,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a005b9096dc4c2fcacc6a8ee52eb8a7236d6667a"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE0MzU5OQ==", "bodyText": "done", "url": "https://github.com/apache/geode/pull/4978#discussion_r420143599", "createdAt": "2020-05-05T14:15:55Z", "author": {"login": "alb3rtobr"}, "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/LocatorLoadSnapshot.java", "diffHunk": "@@ -440,6 +460,24 @@ private void removeFromMap(Map<String, Map<ServerLocation, LoadHolder>> map, Str\n     groupMap.remove(location);\n   }\n \n+  private void removeFromMap(Map<String, Map<ServerLocationAndMemberId, LoadHolder>> map,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAwNTU4NQ=="}, "originalCommit": {"oid": "a005b9096dc4c2fcacc6a8ee52eb8a7236d6667a"}, "originalPosition": 210}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNDUyMjIzOnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/LocatorLoadSnapshot.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMDoyMDozOVrOGQjHHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMzoyMTo0OVrOGQpFYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAwNTY2MQ==", "bodyText": "This is a new method and should be, at leat, unit tested.\nYou can make it package private, annotate it with @VisibleForTesting and access it directly from LocatorLoadSnapshotJUnitTest and/or LocatorLoadSnapshotIntegrationTest.", "url": "https://github.com/apache/geode/pull/4978#discussion_r420005661", "createdAt": "2020-05-05T10:20:39Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/LocatorLoadSnapshot.java", "diffHunk": "@@ -448,14 +486,28 @@ private void updateMap(Map map, ServerLocation location, float load, float loadP\n     }\n   }\n \n+  private void updateMap(Map map, ServerLocation location, String memberId, float load,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a005b9096dc4c2fcacc6a8ee52eb8a7236d6667a"}, "originalPosition": 235}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDEwMzUyMg==", "bodyText": "done", "url": "https://github.com/apache/geode/pull/4978#discussion_r420103522", "createdAt": "2020-05-05T13:21:49Z", "author": {"login": "alb3rtobr"}, "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/LocatorLoadSnapshot.java", "diffHunk": "@@ -448,14 +486,28 @@ private void updateMap(Map map, ServerLocation location, float load, float loadP\n     }\n   }\n \n+  private void updateMap(Map map, ServerLocation location, String memberId, float load,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAwNTY2MQ=="}, "originalCommit": {"oid": "a005b9096dc4c2fcacc6a8ee52eb8a7236d6667a"}, "originalPosition": 235}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNDUyNTQzOnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/LocatorLoadSnapshot.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMDoyMTo0MlrOGQjJJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMzoyMTozN1rOGQpExw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAwNjE4MQ==", "bodyText": "Not a new method but significantly changed, it should be, at leat, unit tested.\nYou can make it package private, annotate it with @VisibleForTesting and access it directly from LocatorLoadSnapshotJUnitTest and/or LocatorLoadSnapshotIntegrationTest.", "url": "https://github.com/apache/geode/pull/4978#discussion_r420006181", "createdAt": "2020-05-05T10:21:42Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/LocatorLoadSnapshot.java", "diffHunk": "@@ -448,14 +486,28 @@ private void updateMap(Map map, ServerLocation location, float load, float loadP\n     }\n   }\n \n+  private void updateMap(Map map, ServerLocation location, String memberId, float load,\n+      float loadPerConnection) {\n+    Map groupMap = (Map) map.get(null);\n+    ServerLocationAndMemberId locationAndMemberId =\n+        new ServerLocationAndMemberId(location, memberId);\n+    LoadHolder holder =\n+        (LoadHolder) groupMap.get(locationAndMemberId);\n+\n+    if (holder != null) {\n+      holder.setLoad(load, loadPerConnection);\n+    }\n+  }\n+\n   /**\n    *\n    * @param groupServers the servers to consider\n    * @param excludedServers servers to exclude\n    * @param count how many you want. a negative number means all of them in order of best to worst\n    * @return a list of best...worst server LoadHolders\n    */\n-  private List<LoadHolder> findBestServers(Map<ServerLocation, LoadHolder> groupServers,\n+  private List<LoadHolder> findBestServers(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a005b9096dc4c2fcacc6a8ee52eb8a7236d6667a"}, "originalPosition": 256}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDEwMzM2Nw==", "bodyText": "done", "url": "https://github.com/apache/geode/pull/4978#discussion_r420103367", "createdAt": "2020-05-05T13:21:37Z", "author": {"login": "alb3rtobr"}, "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/LocatorLoadSnapshot.java", "diffHunk": "@@ -448,14 +486,28 @@ private void updateMap(Map map, ServerLocation location, float load, float loadP\n     }\n   }\n \n+  private void updateMap(Map map, ServerLocation location, String memberId, float load,\n+      float loadPerConnection) {\n+    Map groupMap = (Map) map.get(null);\n+    ServerLocationAndMemberId locationAndMemberId =\n+        new ServerLocationAndMemberId(location, memberId);\n+    LoadHolder holder =\n+        (LoadHolder) groupMap.get(locationAndMemberId);\n+\n+    if (holder != null) {\n+      holder.setLoad(load, loadPerConnection);\n+    }\n+  }\n+\n   /**\n    *\n    * @param groupServers the servers to consider\n    * @param excludedServers servers to exclude\n    * @param count how many you want. a negative number means all of them in order of best to worst\n    * @return a list of best...worst server LoadHolders\n    */\n-  private List<LoadHolder> findBestServers(Map<ServerLocation, LoadHolder> groupServers,\n+  private List<LoadHolder> findBestServers(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAwNjE4MQ=="}, "originalCommit": {"oid": "a005b9096dc4c2fcacc6a8ee52eb8a7236d6667a"}, "originalPosition": 256}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNDU0OTcwOnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/LocatorLoadSnapshot.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMDoyOTowNVrOGQjXcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMzoyMToxN1rOGQpD7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAwOTg0Mg==", "bodyText": "Not a new method but significantly changed, it should be, at leat, unit tested.\nYou can make it package private, annotate it with @VisibleForTesting and access it directly from LocatorLoadSnapshotJUnitTest and/or LocatorLoadSnapshotIntegrationTest.", "url": "https://github.com/apache/geode/pull/4978#discussion_r420009842", "createdAt": "2020-05-05T10:29:05Z", "author": {"login": "jujoramos"}, "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/LocatorLoadSnapshot.java", "diffHunk": "@@ -497,13 +558,21 @@ private void updateMap(Map map, ServerLocation location, float load, float loadP\n    * If it is most loaded then return its LoadHolder; otherwise return null;\n    */\n   private LoadHolder isCurrentServerMostLoaded(ServerLocation currentServer,\n-      Map<ServerLocation, LoadHolder> groupServers) {\n-    final LoadHolder currentLH = groupServers.get(currentServer);\n+      Map<ServerLocationAndMemberId, LoadHolder> groupServers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a005b9096dc4c2fcacc6a8ee52eb8a7236d6667a"}, "originalPosition": 287}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDEwMzE1MQ==", "bodyText": "done!", "url": "https://github.com/apache/geode/pull/4978#discussion_r420103151", "createdAt": "2020-05-05T13:21:17Z", "author": {"login": "alb3rtobr"}, "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/LocatorLoadSnapshot.java", "diffHunk": "@@ -497,13 +558,21 @@ private void updateMap(Map map, ServerLocation location, float load, float loadP\n    * If it is most loaded then return its LoadHolder; otherwise return null;\n    */\n   private LoadHolder isCurrentServerMostLoaded(ServerLocation currentServer,\n-      Map<ServerLocation, LoadHolder> groupServers) {\n-    final LoadHolder currentLH = groupServers.get(currentServer);\n+      Map<ServerLocationAndMemberId, LoadHolder> groupServers) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAwOTg0Mg=="}, "originalCommit": {"oid": "a005b9096dc4c2fcacc6a8ee52eb8a7236d6667a"}, "originalPosition": 287}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNTgwOTc1OnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/ServerLocationAndMemberId.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNTo0NDo1MlrOGQvpgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNzoyNjowNFrOGQz7PA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDIxMTA3NA==", "bodyText": "There is a null check for memberId in hashCode() but not in equals().  If it's possible for memberId to be null then you should add a null check to equals().", "url": "https://github.com/apache/geode/pull/4978#discussion_r420211074", "createdAt": "2020-05-05T15:44:52Z", "author": {"login": "bschuchardt"}, "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/ServerLocationAndMemberId.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.distributed.internal;\n+\n+public class ServerLocationAndMemberId {\n+\n+  private final ServerLocation serverLocation;\n+  private final String memberId;\n+\n+  public ServerLocationAndMemberId(ServerLocation serverLocation, String memberId) {\n+    this.serverLocation = serverLocation;\n+    this.memberId = memberId;\n+  }\n+\n+  public ServerLocation getServerLocation() {\n+    return this.serverLocation;\n+  }\n+\n+  public String getMemberId() {\n+    return this.memberId;\n+  }\n+\n+  @Override\n+  public boolean equals(Object obj) {\n+    if (this == obj)\n+      return true;\n+    if (obj == null)\n+      return false;\n+    if (!(obj instanceof ServerLocationAndMemberId))\n+      return false;\n+    final ServerLocationAndMemberId other = (ServerLocationAndMemberId) obj;\n+\n+    if (!this.serverLocation.equals(other.getServerLocation())) {\n+      return false;\n+    }\n+\n+    return this.memberId.equals(other.getMemberId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a154a1328ffe406f223749fd7b900257478ac57a"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI4MTE0OA==", "bodyText": "Fixed, thanks!", "url": "https://github.com/apache/geode/pull/4978#discussion_r420281148", "createdAt": "2020-05-05T17:26:04Z", "author": {"login": "alb3rtobr"}, "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/ServerLocationAndMemberId.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.distributed.internal;\n+\n+public class ServerLocationAndMemberId {\n+\n+  private final ServerLocation serverLocation;\n+  private final String memberId;\n+\n+  public ServerLocationAndMemberId(ServerLocation serverLocation, String memberId) {\n+    this.serverLocation = serverLocation;\n+    this.memberId = memberId;\n+  }\n+\n+  public ServerLocation getServerLocation() {\n+    return this.serverLocation;\n+  }\n+\n+  public String getMemberId() {\n+    return this.memberId;\n+  }\n+\n+  @Override\n+  public boolean equals(Object obj) {\n+    if (this == obj)\n+      return true;\n+    if (obj == null)\n+      return false;\n+    if (!(obj instanceof ServerLocationAndMemberId))\n+      return false;\n+    final ServerLocationAndMemberId other = (ServerLocationAndMemberId) obj;\n+\n+    if (!this.serverLocation.equals(other.getServerLocation())) {\n+      return false;\n+    }\n+\n+    return this.memberId.equals(other.getMemberId());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDIxMTA3NA=="}, "originalCommit": {"oid": "a154a1328ffe406f223749fd7b900257478ac57a"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNTgzMjgzOnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/GridAdvisor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNTo0OTo0MVrOGQv3eQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNzoyNjoxMlrOGQz7nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDIxNDY0OQ==", "bodyText": "This pair of equals()/hashCode() methods has the same problem.", "url": "https://github.com/apache/geode/pull/4978#discussion_r420214649", "createdAt": "2020-05-05T15:49:41Z", "author": {"login": "bschuchardt"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/GridAdvisor.java", "diffHunk": "@@ -418,18 +418,24 @@ public String toString() {\n     public int hashCode() {\n       final String thisHost = this.gp.getHost();\n       final int thisPort = this.gp.getPort();\n-      return thisHost != null ? (thisHost.hashCode() ^ thisPort) : thisPort;\n+      final String thisMemberId = this.getMemberId().getUniqueId();\n+      final int thisMemberIdHashCode = (thisMemberId != null) ? thisMemberId.hashCode() : 0;\n+      return thisHost != null ? (thisHost.hashCode() ^ thisPort) + thisMemberIdHashCode\n+          : thisPort + thisMemberIdHashCode;\n     }\n \n     @Override\n     public boolean equals(Object obj) {\n       if (obj instanceof GridProfileId) {\n         final GridProfileId other = (GridProfileId) obj;\n+\n         if (this.gp.getPort() == other.gp.getPort()) {\n           final String thisHost = this.gp.getHost();\n           final String otherHost = other.gp.getHost();\n           if (thisHost != null) {\n-            return thisHost.equals(otherHost);\n+            if (thisHost.equals(otherHost)) {\n+              return this.getMemberId().getUniqueId().equals(other.getMemberId().getUniqueId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a154a1328ffe406f223749fd7b900257478ac57a"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI4MTI0Nw==", "bodyText": "Fixed, thanks!", "url": "https://github.com/apache/geode/pull/4978#discussion_r420281247", "createdAt": "2020-05-05T17:26:12Z", "author": {"login": "alb3rtobr"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/GridAdvisor.java", "diffHunk": "@@ -418,18 +418,24 @@ public String toString() {\n     public int hashCode() {\n       final String thisHost = this.gp.getHost();\n       final int thisPort = this.gp.getPort();\n-      return thisHost != null ? (thisHost.hashCode() ^ thisPort) : thisPort;\n+      final String thisMemberId = this.getMemberId().getUniqueId();\n+      final int thisMemberIdHashCode = (thisMemberId != null) ? thisMemberId.hashCode() : 0;\n+      return thisHost != null ? (thisHost.hashCode() ^ thisPort) + thisMemberIdHashCode\n+          : thisPort + thisMemberIdHashCode;\n     }\n \n     @Override\n     public boolean equals(Object obj) {\n       if (obj instanceof GridProfileId) {\n         final GridProfileId other = (GridProfileId) obj;\n+\n         if (this.gp.getPort() == other.gp.getPort()) {\n           final String thisHost = this.gp.getHost();\n           final String otherHost = other.gp.getHost();\n           if (thisHost != null) {\n-            return thisHost.equals(otherHost);\n+            if (thisHost.equals(otherHost)) {\n+              return this.getMemberId().getUniqueId().equals(other.getMemberId().getUniqueId());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDIxNDY0OQ=="}, "originalCommit": {"oid": "a154a1328ffe406f223749fd7b900257478ac57a"}, "originalPosition": 22}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4352, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}