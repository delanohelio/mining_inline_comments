{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM0MzI2NTUw", "number": 5249, "title": "GEODE-8272 Refactor Restore Redundancy Command", "bodyText": "This set of changes is to refactor the Restore Redundancy Command in GFSH through to the actual Restore Redundancy Operation that is performed.", "createdAt": "2020-06-15T06:48:11Z", "url": "https://github.com/apache/geode/pull/5249", "merged": true, "mergeCommit": {"oid": "84ab66b062349caeed8ff648a15c5c65d3d137c7"}, "closed": true, "closedAt": "2020-06-19T05:06:10Z", "author": {"login": "mhansonp"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcrkPLNgH2gAyNDM0MzI2NTUwOjNlOGM0NWIxNzhiM2E5YmExOTc5ZWIyNWZiOTMxNWZmMmUxYjVmYjE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcslzodAFqTQzMzY3NzQwMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "3e8c45b178b3a9ba1979eb25fb9315ff2e1b5fb1", "author": {"user": {"login": "jinmeiliao", "name": "Jinmei Liao"}}, "url": "https://github.com/apache/geode/commit/3e8c45b178b3a9ba1979eb25fb9315ff2e1b5fb1", "committedDate": "2020-06-15T17:37:59Z", "message": "reimplement RedundancyCommand with OperationPerformer"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "17e668f5d8ec35710e56cceeaed763e714033f0c", "author": {"user": {"login": "mhansonp", "name": null}}, "url": "https://github.com/apache/geode/commit/17e668f5d8ec35710e56cceeaed763e714033f0c", "committedDate": "2020-06-15T17:13:11Z", "message": "Cleanout log messages."}, "afterCommit": {"oid": "3e8c45b178b3a9ba1979eb25fb9315ff2e1b5fb1", "author": {"user": {"login": "jinmeiliao", "name": "Jinmei Liao"}}, "url": "https://github.com/apache/geode/commit/3e8c45b178b3a9ba1979eb25fb9315ff2e1b5fb1", "committedDate": "2020-06-15T17:37:59Z", "message": "reimplement RedundancyCommand with OperationPerformer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5fb8221b49e2d55ab8e476c6e5ba52e5b46558b", "author": {"user": {"login": "mhansonp", "name": null}}, "url": "https://github.com/apache/geode/commit/f5fb8221b49e2d55ab8e476c6e5ba52e5b46558b", "committedDate": "2020-06-15T22:51:48Z", "message": "dealing serializer restrictions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031", "author": {"user": {"login": "mhansonp", "name": null}}, "url": "https://github.com/apache/geode/commit/ea31eacc86591ebdcf28f57cc372eb6cd0a25031", "committedDate": "2020-06-16T00:52:52Z", "message": "cleaning up one last sanctionedDataSerializables.txt file."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTMwNzg1", "url": "https://github.com/apache/geode/pull/5249#pullrequestreview-431930785", "createdAt": "2020-06-16T22:17:04Z", "commit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 34, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMjoxNzowNFrOGkvFFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyNDoyMVrOGkwdfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE3MzI2OQ==", "bodyText": "Variable names should start with lowercase: dsMember", "url": "https://github.com/apache/geode/pull/5249#discussion_r441173269", "createdAt": "2020-06-16T22:17:04Z", "author": {"login": "kirklund"}, "path": "geode-core/src/main/java/org/apache/geode/management/internal/operation/RebalanceOperationPerformer.java", "diffHunk": "@@ -189,16 +189,16 @@ public static DistributedMember getAssociatedMembers(String region, final Intern\n \n     String[] membersName = bean.getMembers();\n     Set<DistributedMember> dsMembers = ManagementUtils.getAllMembers(cache);\n-    Iterator it = dsMembers.iterator();\n+    Iterator<DistributedMember> it = dsMembers.iterator();\n \n     boolean matchFound = false;\n \n     if (membersName.length > 1) {\n       while (it.hasNext() && !matchFound) {\n-        DistributedMember dsmember = (DistributedMember) it.next();\n+        DistributedMember DSMember = it.next();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE3NDI4Mw==", "bodyText": "Using import static for all of these Mockito methods should improve readability a little.", "url": "https://github.com/apache/geode/pull/5249#discussion_r441174283", "createdAt": "2020-06-16T22:19:34Z", "author": {"login": "kirklund"}, "path": "geode-core/src/test/java/org/apache/geode/management/internal/operation/RestoreRedundancyPerformerTest.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.apache.geode.management.internal.operation;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalCacheForClientAccess;\n+import org.apache.geode.internal.serialization.Version;\n+import org.apache.geode.management.DistributedRegionMXBean;\n+import org.apache.geode.management.DistributedSystemMXBean;\n+import org.apache.geode.management.internal.BaseManagementService;\n+import org.apache.geode.management.internal.functions.RestoreRedundancyFunction;\n+import org.apache.geode.management.operation.RestoreRedundancyRequest;\n+import org.apache.geode.management.runtime.RegionRedundancyStatus;\n+import org.apache.geode.management.runtime.RestoreRedundancyResults;\n+\n+public class RestoreRedundancyPerformerTest {\n+\n+  public static final String DS_MEMBER_NAME_SERVER1 = \"server1\";\n+  public static final String DS_MEMBER_NAME_SERVER2 = \"server2\";\n+\n+  public static final String REGION_1 = \"region1\";\n+  public static final String BOGUS_PASS_MESSAGE = \"Bogus pass message\";\n+  private InternalDistributedMember server1;\n+  private InternalDistributedMember server2;\n+  private InternalCacheForClientAccess internalCacheForClientAccess;\n+  private RestoreRedundancyPerformer restoreRedundancyPerformer;\n+\n+  @Before\n+  public void setup() {\n+    BaseManagementService baseManagementService = mock(BaseManagementService.class);\n+    DistributedSystemMXBean distributedSystemMXBean = mock(DistributedSystemMXBean.class);\n+    DistributedRegionMXBean distributedRegionMXBean = mock(DistributedRegionMXBean.class);\n+    server1 = mock(InternalDistributedMember.class);\n+    server2 = mock(InternalDistributedMember.class);\n+    internalCacheForClientAccess = mock(InternalCacheForClientAccess.class);\n+    InternalDistributedSystem internalDistributedSystem = mock(InternalDistributedSystem.class);\n+    DistributionManager distributionManager = mock(DistributionManager.class);\n+    when(baseManagementService.getDistributedSystemMXBean()).thenReturn(distributedSystemMXBean);\n+    when(baseManagementService.getDistributedRegionMXBean(Mockito.anyString()))\n+        .thenReturn(distributedRegionMXBean);\n+    when(distributedRegionMXBean.getRegionType()).thenReturn(String.valueOf(DataPolicy.PARTITION));\n+    when(distributedRegionMXBean.getMembers())\n+        .thenReturn(new String[] {DS_MEMBER_NAME_SERVER1, DS_MEMBER_NAME_SERVER2});\n+    when(server1.getName()).thenReturn(DS_MEMBER_NAME_SERVER1);\n+    when(server2.getName()).thenReturn(DS_MEMBER_NAME_SERVER2);\n+    when(distributedSystemMXBean.listRegions()).thenReturn(new String[] {REGION_1});\n+    when(internalDistributedSystem.getDistributionManager())\n+        .thenReturn(distributionManager);\n+    Set<InternalDistributedMember> dsMembers = new HashSet<>();\n+    dsMembers.add(server1);\n+    dsMembers.add(server2);\n+    when(distributionManager.getDistributionManagerIds()).thenReturn(dsMembers);\n+    BaseManagementService.setManagementService(internalCacheForClientAccess, baseManagementService);\n+\n+    when(((InternalCache) internalCacheForClientAccess).getCacheForProcessingClientRequests())\n+        .thenReturn(internalCacheForClientAccess);\n+    when(internalCacheForClientAccess.getInternalDistributedSystem())\n+        .thenReturn(internalDistributedSystem);\n+\n+    when(server1.getVersionObject())\n+        .thenReturn(RestoreRedundancyPerformer.ADDED_VERSION);\n+    when(server2.getVersionObject())\n+        .thenReturn(RestoreRedundancyPerformer.ADDED_VERSION);\n+\n+    restoreRedundancyPerformer = new RestoreRedundancyPerformer();\n+  }\n+\n+  @Test\n+  public void executePerformWithIncludeRegionsSuccess() {\n+    // Setup a request to restore redundancy for region 1\n+    RestoreRedundancyRequest restoreRedundancyRequest = new RestoreRedundancyRequest();\n+    restoreRedundancyRequest.setReassignPrimaries(true);\n+    restoreRedundancyRequest.setIncludeRegions(Collections.singletonList(REGION_1));\n+    restoreRedundancyRequest.setExcludeRegions(new ArrayList<>());\n+\n+\n+    // Setup a successful response from executeFunctionAndGetFunctionResult\n+    RestoreRedundancyResultsImpl restoreRedundancyResultsImpl = new RestoreRedundancyResultsImpl();\n+    restoreRedundancyResultsImpl.setStatusMessage(BOGUS_PASS_MESSAGE);\n+    restoreRedundancyResultsImpl.setSuccess(true);\n+\n+    Map<String, RegionRedundancyStatus> satisfied =\n+        restoreRedundancyResultsImpl.getSatisfiedRedundancyRegionResults();\n+\n+    // Create and add the RegionRedundancyStatus to the response\n+    RegionRedundancyStatusImpl regionRedundancyStatusImpl = new RegionRedundancyStatusImpl(1, 1,\n+        REGION_1, RegionRedundancyStatus.RedundancyStatus.SATISFIED);\n+\n+    satisfied.put(REGION_1, regionRedundancyStatusImpl);\n+\n+    // intercept the executeFunctionAndGetFunctionResult method call on the performer\n+    RestoreRedundancyPerformer spyRedundancyPerformer = Mockito.spy(restoreRedundancyPerformer);\n+    Mockito.doReturn(restoreRedundancyResultsImpl).when(spyRedundancyPerformer)\n+        .executeFunctionAndGetFunctionResult(Mockito.any(RestoreRedundancyFunction.class),\n+            Mockito.any(Object.class),\n+            Mockito.any(\n+                DistributedMember.class));\n+\n+    // invoke perform\n+    RestoreRedundancyResults restoreRedundancyResult = spyRedundancyPerformer\n+        .perform(internalCacheForClientAccess, restoreRedundancyRequest, false);\n+\n+    assertThat(restoreRedundancyResult.getSuccess()).isTrue();\n+  }\n+\n+  @Test\n+  public void executePerformWithNoIncludeRegionsSuccess() {\n+    // Setup a request to restore redundancy for region 1\n+    RestoreRedundancyRequest restoreRedundancyRequest = new RestoreRedundancyRequest();\n+    restoreRedundancyRequest.setReassignPrimaries(true);\n+\n+\n+    // Setup a successful response from executeFunctionAndGetFunctionResult\n+    RestoreRedundancyResultsImpl restoreRedundancyResultsImpl = new RestoreRedundancyResultsImpl();\n+    restoreRedundancyResultsImpl.setStatusMessage(BOGUS_PASS_MESSAGE);\n+    restoreRedundancyResultsImpl.setSuccess(true);\n+\n+    Map<String, RegionRedundancyStatus> satisfied =\n+        restoreRedundancyResultsImpl.getSatisfiedRedundancyRegionResults();\n+\n+    // Create and add the RegionRedundancyStatus to the response\n+    RegionRedundancyStatusImpl regionRedundancyStatusImpl = new RegionRedundancyStatusImpl(1, 1,\n+        REGION_1, RegionRedundancyStatus.RedundancyStatus.SATISFIED);\n+\n+    satisfied.put(REGION_1, regionRedundancyStatusImpl);\n+\n+    // intercept the executeFunctionAndGetFunctionResult method call on the performer\n+    RestoreRedundancyPerformer spyRedundancyPerformer = Mockito.spy(restoreRedundancyPerformer);\n+    Mockito.doReturn(restoreRedundancyResultsImpl).when(spyRedundancyPerformer)\n+        .executeFunctionAndGetFunctionResult(Mockito.any(RestoreRedundancyFunction.class),\n+            Mockito.any(Object.class),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE3NTY4OQ==", "bodyText": "Don't forget to add a paragraph to the javadocs about this API being experimental. See other classes that use @Experimental for examples.", "url": "https://github.com/apache/geode/pull/5249#discussion_r441175689", "createdAt": "2020-06-16T22:23:22Z", "author": {"login": "kirklund"}, "path": "geode-management/src/main/java/org/apache/geode/management/operation/RestoreRedundancyRequest.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.management.operation;\n+\n+import java.util.List;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+\n+import org.apache.geode.annotations.Experimental;\n+import org.apache.geode.management.api.ClusterManagementOperation;\n+import org.apache.geode.management.runtime.RestoreRedundancyResults;\n+\n+/**\n+ * Defines a distributed system request to optimize bucket allocation across members.\n+ */\n+@Experimental", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE3NzMyMA==", "bodyText": "Since this is a product class, you should have IntelliJ generate the serialVersionUID for you. I think you'll need the corresponding inspection enabled: https://stackoverflow.com/questions/24573643/how-to-generate-serial-version-uid-in-intellij\nIt's theoretically ok to have it set to 1L but the generated number is more correct.", "url": "https://github.com/apache/geode/pull/5249#discussion_r441177320", "createdAt": "2020-06-16T22:28:03Z", "author": {"login": "kirklund"}, "path": "geode-core/src/main/java/org/apache/geode/management/internal/functions/RestoreRedundancyFunction.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.management.internal.functions;\n+\n+import static org.apache.geode.management.runtime.RestoreRedundancyResults.Status.ERROR;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.Logger;\n+\n+import org.apache.geode.cache.control.RestoreRedundancyOperation;\n+import org.apache.geode.cache.execute.FunctionContext;\n+import org.apache.geode.internal.cache.control.SerializableRestoreRedundancyResultsImpl;\n+import org.apache.geode.internal.cache.execute.InternalFunction;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+import org.apache.geode.management.internal.operation.RestoreRedundancyResultsImpl;\n+import org.apache.geode.management.operation.RestoreRedundancyRequest;\n+\n+\n+public class RestoreRedundancyFunction implements InternalFunction<Object[]> {\n+  private static final Logger logger = LogService.getLogger();\n+\n+  public static final String ID = RestoreRedundancyFunction.class.getName();\n+\n+\n+  private static final long serialVersionUID = 1L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE3NzQ5Mg==", "bodyText": "Remove initials.", "url": "https://github.com/apache/geode/pull/5249#discussion_r441177492", "createdAt": "2020-06-16T22:28:27Z", "author": {"login": "kirklund"}, "path": "geode-core/src/main/java/org/apache/geode/management/internal/functions/RestoreRedundancyFunction.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.management.internal.functions;\n+\n+import static org.apache.geode.management.runtime.RestoreRedundancyResults.Status.ERROR;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.Logger;\n+\n+import org.apache.geode.cache.control.RestoreRedundancyOperation;\n+import org.apache.geode.cache.execute.FunctionContext;\n+import org.apache.geode.internal.cache.control.SerializableRestoreRedundancyResultsImpl;\n+import org.apache.geode.internal.cache.execute.InternalFunction;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+import org.apache.geode.management.internal.operation.RestoreRedundancyResultsImpl;\n+import org.apache.geode.management.operation.RestoreRedundancyRequest;\n+\n+\n+public class RestoreRedundancyFunction implements InternalFunction<Object[]> {\n+  private static final Logger logger = LogService.getLogger();\n+\n+  public static final String ID = RestoreRedundancyFunction.class.getName();\n+\n+\n+  private static final long serialVersionUID = 1L;\n+\n+  @Override\n+  // this would return the RestoreRedundancyResults if successful,\n+  // it will return an exception to the caller if status is failure or any exception happens\n+  public void execute(FunctionContext<Object[]> context) {\n+    Object[] arguments = context.getArguments();\n+    RestoreRedundancyRequest request = (RestoreRedundancyRequest) arguments[0];\n+    boolean isStatusCommand = (boolean) arguments[1];\n+    RestoreRedundancyOperation redundancyOperation =\n+        context.getCache().getResourceManager().createRestoreRedundancyOperation();\n+    Set<String> includeRegionsSet = null;\n+    if (request.getIncludeRegions() != null) {\n+      includeRegionsSet = new HashSet<>(request.getIncludeRegions());\n+    }\n+    Set<String> excludeRegionsSet = null;\n+    if (request.getExcludeRegions() != null) {\n+      excludeRegionsSet = new HashSet<>(request.getExcludeRegions());\n+    }\n+    redundancyOperation.includeRegions(includeRegionsSet);\n+    redundancyOperation.excludeRegions(excludeRegionsSet);\n+    RestoreRedundancyResultsImpl results;\n+\n+    try {\n+      if (isStatusCommand) {\n+        results = (RestoreRedundancyResultsImpl) redundancyOperation.redundancyStatus();\n+      } else {\n+        redundancyOperation.shouldReassignPrimaries(request.getReassignPrimaries());\n+        results = (RestoreRedundancyResultsImpl) redundancyOperation.start().join();\n+      }\n+      if (results.getRegionOperationStatus().equals(ERROR)) {\n+        Exception e = new Exception(results.getRegionOperationMessage());\n+        throw e;\n+      }\n+      results.setSuccess(true);\n+      results.setStatusMessage(\"Success\"); // MLH change this", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE3OTU1NQ==", "bodyText": "This is ok either way, but you could combine these if-blocks if you want to:\nif (regionName.startsWith(SEPARATOR) && !excludedRegion.startsWith(SEPARATOR)) {\n  excludedRegion = SEPARATOR + excludedRegion;\n}\n\nAnd the next block:\nif (excludedRegion.startsWith(SEPARATOR) && !regionName.startsWith(SEPARATOR)) {\n  regionName = SEPARATOR + regionName;\n}", "url": "https://github.com/apache/geode/pull/5249#discussion_r441179555", "createdAt": "2020-06-16T22:34:07Z", "author": {"login": "kirklund"}, "path": "geode-core/src/main/java/org/apache/geode/management/internal/operation/RebalanceOperationPerformer.java", "diffHunk": "@@ -219,24 +219,26 @@ public static DistributedMember getAssociatedMembers(String region, final Intern\n     for (String regionName : listDSRegions) {\n       // check for excluded regions\n       boolean excludedRegionMatch = false;\n-      for (String aListExcludedRegion : listExcludedRegion) {\n-        // this is needed since region name may start with / or without it\n-        // also\n-        String excludedRegion = aListExcludedRegion.trim();\n-        if (regionName.startsWith(SEPARATOR)) {\n-          if (!excludedRegion.startsWith(SEPARATOR)) {\n-            excludedRegion = SEPARATOR + excludedRegion;\n+      if (listExcludedRegion != null) {\n+        for (String aListExcludedRegion : listExcludedRegion) {\n+          // this is needed since region name may start with / or without it\n+          // also\n+          String excludedRegion = aListExcludedRegion.trim();\n+          if (regionName.startsWith(SEPARATOR)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE3OTg1NQ==", "bodyText": "Change to:\nif (!viableMembers.isEmpty()) {", "url": "https://github.com/apache/geode/pull/5249#discussion_r441179855", "createdAt": "2020-06-16T22:34:59Z", "author": {"login": "kirklund"}, "path": "geode-core/src/main/java/org/apache/geode/management/internal/operation/RestoreRedundancyPerformer.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.management.internal.operation;\n+\n+import static org.apache.geode.cache.Region.SEPARATOR;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.geode.annotations.Immutable;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.ResultCollector;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.serialization.Version;\n+import org.apache.geode.management.ManagementService;\n+import org.apache.geode.management.internal.functions.RestoreRedundancyFunction;\n+import org.apache.geode.management.internal.util.ManagementUtils;\n+import org.apache.geode.management.operation.RestoreRedundancyRequest;\n+import org.apache.geode.management.runtime.RestoreRedundancyResults;\n+\n+public class RestoreRedundancyPerformer\n+    implements OperationPerformer<RestoreRedundancyRequest, RestoreRedundancyResults> {\n+  @Immutable\n+  public static final Version ADDED_VERSION = Version.GEODE_1_13_0;\n+  public static final String NO_MEMBERS_WITH_VERSION_FOR_REGION =\n+      \"No members with a version greater than or equal to %s were found for region %s\";\n+  public static final String EXCEPTION_MEMBER_MESSAGE = \"Exception occurred on member %s: %s\";\n+\n+  @Override\n+  public RestoreRedundancyResults perform(Cache cache, RestoreRedundancyRequest operation) {\n+    return perform(cache, operation, false);\n+  }\n+\n+  public RestoreRedundancyResults perform(Cache cache, RestoreRedundancyRequest operation,\n+      boolean checkStatus) {\n+    List<RebalanceOperationPerformer.MemberPRInfo> membersForEachRegion = new ArrayList<>();\n+    List<String> includedRegionsWithNoMembers = new ArrayList<>();\n+\n+    populateLists(membersForEachRegion, includedRegionsWithNoMembers, operation.getIncludeRegions(),\n+        operation.getExcludeRegions(), (InternalCache) cache);\n+\n+    for (RebalanceOperationPerformer.MemberPRInfo prInfo : membersForEachRegion) {\n+      // Filter out any members using older versions of Geode\n+      List<DistributedMember> viableMembers = filterViableMembers(prInfo);\n+\n+      if (viableMembers.size() != 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4MDA1Mw==", "bodyText": "In theory the implementation could optimize isEmpty() to not require size().", "url": "https://github.com/apache/geode/pull/5249#discussion_r441180053", "createdAt": "2020-06-16T22:35:38Z", "author": {"login": "kirklund"}, "path": "geode-core/src/main/java/org/apache/geode/management/internal/operation/RestoreRedundancyPerformer.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.management.internal.operation;\n+\n+import static org.apache.geode.cache.Region.SEPARATOR;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.geode.annotations.Immutable;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.ResultCollector;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.serialization.Version;\n+import org.apache.geode.management.ManagementService;\n+import org.apache.geode.management.internal.functions.RestoreRedundancyFunction;\n+import org.apache.geode.management.internal.util.ManagementUtils;\n+import org.apache.geode.management.operation.RestoreRedundancyRequest;\n+import org.apache.geode.management.runtime.RestoreRedundancyResults;\n+\n+public class RestoreRedundancyPerformer\n+    implements OperationPerformer<RestoreRedundancyRequest, RestoreRedundancyResults> {\n+  @Immutable\n+  public static final Version ADDED_VERSION = Version.GEODE_1_13_0;\n+  public static final String NO_MEMBERS_WITH_VERSION_FOR_REGION =\n+      \"No members with a version greater than or equal to %s were found for region %s\";\n+  public static final String EXCEPTION_MEMBER_MESSAGE = \"Exception occurred on member %s: %s\";\n+\n+  @Override\n+  public RestoreRedundancyResults perform(Cache cache, RestoreRedundancyRequest operation) {\n+    return perform(cache, operation, false);\n+  }\n+\n+  public RestoreRedundancyResults perform(Cache cache, RestoreRedundancyRequest operation,\n+      boolean checkStatus) {\n+    List<RebalanceOperationPerformer.MemberPRInfo> membersForEachRegion = new ArrayList<>();\n+    List<String> includedRegionsWithNoMembers = new ArrayList<>();\n+\n+    populateLists(membersForEachRegion, includedRegionsWithNoMembers, operation.getIncludeRegions(),\n+        operation.getExcludeRegions(), (InternalCache) cache);\n+\n+    for (RebalanceOperationPerformer.MemberPRInfo prInfo : membersForEachRegion) {\n+      // Filter out any members using older versions of Geode\n+      List<DistributedMember> viableMembers = filterViableMembers(prInfo);\n+\n+      if (viableMembers.size() != 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE3OTg1NQ=="}, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4MjM0Mw==", "bodyText": "Maybe remove all of these unnecessary this. qualifiers? They show up as unnecessary in my IDE.", "url": "https://github.com/apache/geode/pull/5249#discussion_r441182343", "createdAt": "2020-06-16T22:42:13Z", "author": {"login": "kirklund"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/control/SerializableRestoreRedundancyResultsImpl.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.control;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.cache.partition.PartitionRebalanceInfo;\n+import org.apache.geode.internal.serialization.DataSerializableFixedID;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.internal.serialization.Version;\n+import org.apache.geode.management.internal.operation.RestoreRedundancyResultsImpl;\n+\n+/**\n+ * result object produced by the servers. These need to be transferred to the locators\n+ * via functions so they need to be DataSerializable\n+ */\n+public class SerializableRestoreRedundancyResultsImpl\n+    extends RestoreRedundancyResultsImpl\n+    implements DataSerializableFixedID {\n+\n+  public void addPrimaryReassignmentDetails(PartitionRebalanceInfo details) {\n+    this.totalPrimaryTransfersCompleted += details.getPrimaryTransfersCompleted();\n+    this.totalPrimaryTransferTime =\n+        this.totalPrimaryTransferTime.plusMillis(details.getPrimaryTransferTime());\n+  }\n+\n+  @Override\n+  public int getDSFID() {\n+    return RESTORE_REDUNDANCY_RESULTS;\n+  }\n+\n+  @Override\n+  public void toData(DataOutput out, SerializationContext context) throws IOException {\n+    DataSerializer.writeHashMap(satisfiedRedundancyRegions, out);\n+    DataSerializer.writeHashMap(underRedundancyRegions, out);\n+    DataSerializer.writeHashMap(zeroRedundancyRegions, out);\n+    out.writeInt(totalPrimaryTransfersCompleted);\n+    DataSerializer.writeObject(totalPrimaryTransferTime, out);\n+    out.writeBoolean(success);\n+    DataSerializer.writeString(statusMessage, out);\n+  }\n+\n+  @Override\n+  public void fromData(DataInput in, DeserializationContext context)\n+      throws IOException, ClassNotFoundException {\n+    this.satisfiedRedundancyRegions = DataSerializer.readHashMap(in);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4MzMwMQ==", "bodyText": "Doesn't need the RestoreRedundancyFunction. qualifier.", "url": "https://github.com/apache/geode/pull/5249#discussion_r441183301", "createdAt": "2020-06-16T22:45:09Z", "author": {"login": "kirklund"}, "path": "geode-core/src/main/java/org/apache/geode/management/internal/functions/RestoreRedundancyFunction.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.management.internal.functions;\n+\n+import static org.apache.geode.management.runtime.RestoreRedundancyResults.Status.ERROR;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.Logger;\n+\n+import org.apache.geode.cache.control.RestoreRedundancyOperation;\n+import org.apache.geode.cache.execute.FunctionContext;\n+import org.apache.geode.internal.cache.control.SerializableRestoreRedundancyResultsImpl;\n+import org.apache.geode.internal.cache.execute.InternalFunction;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+import org.apache.geode.management.internal.operation.RestoreRedundancyResultsImpl;\n+import org.apache.geode.management.operation.RestoreRedundancyRequest;\n+\n+\n+public class RestoreRedundancyFunction implements InternalFunction<Object[]> {\n+  private static final Logger logger = LogService.getLogger();\n+\n+  public static final String ID = RestoreRedundancyFunction.class.getName();\n+\n+\n+  private static final long serialVersionUID = 1L;\n+\n+  @Override\n+  // this would return the RestoreRedundancyResults if successful,\n+  // it will return an exception to the caller if status is failure or any exception happens\n+  public void execute(FunctionContext<Object[]> context) {\n+    Object[] arguments = context.getArguments();\n+    RestoreRedundancyRequest request = (RestoreRedundancyRequest) arguments[0];\n+    boolean isStatusCommand = (boolean) arguments[1];\n+    RestoreRedundancyOperation redundancyOperation =\n+        context.getCache().getResourceManager().createRestoreRedundancyOperation();\n+    Set<String> includeRegionsSet = null;\n+    if (request.getIncludeRegions() != null) {\n+      includeRegionsSet = new HashSet<>(request.getIncludeRegions());\n+    }\n+    Set<String> excludeRegionsSet = null;\n+    if (request.getExcludeRegions() != null) {\n+      excludeRegionsSet = new HashSet<>(request.getExcludeRegions());\n+    }\n+    redundancyOperation.includeRegions(includeRegionsSet);\n+    redundancyOperation.excludeRegions(excludeRegionsSet);\n+    RestoreRedundancyResultsImpl results;\n+\n+    try {\n+      if (isStatusCommand) {\n+        results = (RestoreRedundancyResultsImpl) redundancyOperation.redundancyStatus();\n+      } else {\n+        redundancyOperation.shouldReassignPrimaries(request.getReassignPrimaries());\n+        results = (RestoreRedundancyResultsImpl) redundancyOperation.start().join();\n+      }\n+      if (results.getRegionOperationStatus().equals(ERROR)) {\n+        Exception e = new Exception(results.getRegionOperationMessage());\n+        throw e;\n+      }\n+      results.setSuccess(true);\n+      results.setStatusMessage(\"Success\"); // MLH change this\n+    } catch (Exception e) {\n+      results =\n+          new SerializableRestoreRedundancyResultsImpl();\n+      results.setSuccess(false);\n+      results.setStatusMessage(e.getMessage());\n+    }\n+    context.getResultSender().lastResult(results);\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return RestoreRedundancyFunction.ID;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4MzgwOA==", "bodyText": "I would use a subclass of Exception and inline throwing it:\nthrow new IllegalStateException(results.getRegionOperationMessage());", "url": "https://github.com/apache/geode/pull/5249#discussion_r441183808", "createdAt": "2020-06-16T22:46:36Z", "author": {"login": "kirklund"}, "path": "geode-core/src/main/java/org/apache/geode/management/internal/functions/RestoreRedundancyFunction.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.management.internal.functions;\n+\n+import static org.apache.geode.management.runtime.RestoreRedundancyResults.Status.ERROR;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.Logger;\n+\n+import org.apache.geode.cache.control.RestoreRedundancyOperation;\n+import org.apache.geode.cache.execute.FunctionContext;\n+import org.apache.geode.internal.cache.control.SerializableRestoreRedundancyResultsImpl;\n+import org.apache.geode.internal.cache.execute.InternalFunction;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+import org.apache.geode.management.internal.operation.RestoreRedundancyResultsImpl;\n+import org.apache.geode.management.operation.RestoreRedundancyRequest;\n+\n+\n+public class RestoreRedundancyFunction implements InternalFunction<Object[]> {\n+  private static final Logger logger = LogService.getLogger();\n+\n+  public static final String ID = RestoreRedundancyFunction.class.getName();\n+\n+\n+  private static final long serialVersionUID = 1L;\n+\n+  @Override\n+  // this would return the RestoreRedundancyResults if successful,\n+  // it will return an exception to the caller if status is failure or any exception happens\n+  public void execute(FunctionContext<Object[]> context) {\n+    Object[] arguments = context.getArguments();\n+    RestoreRedundancyRequest request = (RestoreRedundancyRequest) arguments[0];\n+    boolean isStatusCommand = (boolean) arguments[1];\n+    RestoreRedundancyOperation redundancyOperation =\n+        context.getCache().getResourceManager().createRestoreRedundancyOperation();\n+    Set<String> includeRegionsSet = null;\n+    if (request.getIncludeRegions() != null) {\n+      includeRegionsSet = new HashSet<>(request.getIncludeRegions());\n+    }\n+    Set<String> excludeRegionsSet = null;\n+    if (request.getExcludeRegions() != null) {\n+      excludeRegionsSet = new HashSet<>(request.getExcludeRegions());\n+    }\n+    redundancyOperation.includeRegions(includeRegionsSet);\n+    redundancyOperation.excludeRegions(excludeRegionsSet);\n+    RestoreRedundancyResultsImpl results;\n+\n+    try {\n+      if (isStatusCommand) {\n+        results = (RestoreRedundancyResultsImpl) redundancyOperation.redundancyStatus();\n+      } else {\n+        redundancyOperation.shouldReassignPrimaries(request.getReassignPrimaries());\n+        results = (RestoreRedundancyResultsImpl) redundancyOperation.start().join();\n+      }\n+      if (results.getRegionOperationStatus().equals(ERROR)) {\n+        Exception e = new Exception(results.getRegionOperationMessage());\n+        throw e;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4NDEyNw==", "bodyText": "Delete // also? Or finish comment?", "url": "https://github.com/apache/geode/pull/5249#discussion_r441184127", "createdAt": "2020-06-16T22:47:33Z", "author": {"login": "kirklund"}, "path": "geode-core/src/main/java/org/apache/geode/management/internal/operation/RebalanceOperationPerformer.java", "diffHunk": "@@ -219,24 +219,26 @@ public static DistributedMember getAssociatedMembers(String region, final Intern\n     for (String regionName : listDSRegions) {\n       // check for excluded regions\n       boolean excludedRegionMatch = false;\n-      for (String aListExcludedRegion : listExcludedRegion) {\n-        // this is needed since region name may start with / or without it\n-        // also\n-        String excludedRegion = aListExcludedRegion.trim();\n-        if (regionName.startsWith(SEPARATOR)) {\n-          if (!excludedRegion.startsWith(SEPARATOR)) {\n-            excludedRegion = SEPARATOR + excludedRegion;\n+      if (listExcludedRegion != null) {\n+        for (String aListExcludedRegion : listExcludedRegion) {\n+          // this is needed since region name may start with / or without it\n+          // also", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4NTMxMw==", "bodyText": "Visibility on the constants is public when they don't need to be.\nADDED_VERSION should be package-private (no qualifier) and add the annotation @VisibleForTesting:\n@Immutable\n@VisibleForTesting\nstatic final Version ADDED_VERSION = Version.GEODE_1_13_0;\n\nNO_MEMBERS_WITH_VERSION_FOR_REGION and EXCEPTION_MEMBER_MESSAGE should be private until something outside the package needs to reference them.", "url": "https://github.com/apache/geode/pull/5249#discussion_r441185313", "createdAt": "2020-06-16T22:51:04Z", "author": {"login": "kirklund"}, "path": "geode-core/src/main/java/org/apache/geode/management/internal/operation/RestoreRedundancyPerformer.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.management.internal.operation;\n+\n+import static org.apache.geode.cache.Region.SEPARATOR;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.geode.annotations.Immutable;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.ResultCollector;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.serialization.Version;\n+import org.apache.geode.management.ManagementService;\n+import org.apache.geode.management.internal.functions.RestoreRedundancyFunction;\n+import org.apache.geode.management.internal.util.ManagementUtils;\n+import org.apache.geode.management.operation.RestoreRedundancyRequest;\n+import org.apache.geode.management.runtime.RestoreRedundancyResults;\n+\n+public class RestoreRedundancyPerformer\n+    implements OperationPerformer<RestoreRedundancyRequest, RestoreRedundancyResults> {\n+  @Immutable\n+  public static final Version ADDED_VERSION = Version.GEODE_1_13_0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4NTg4OA==", "bodyText": "executeFunctionAndGetFunctionResult should be package-private (no qualifier) instead of public.", "url": "https://github.com/apache/geode/pull/5249#discussion_r441185888", "createdAt": "2020-06-16T22:52:50Z", "author": {"login": "kirklund"}, "path": "geode-core/src/main/java/org/apache/geode/management/internal/operation/RestoreRedundancyPerformer.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.management.internal.operation;\n+\n+import static org.apache.geode.cache.Region.SEPARATOR;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.geode.annotations.Immutable;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.ResultCollector;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.serialization.Version;\n+import org.apache.geode.management.ManagementService;\n+import org.apache.geode.management.internal.functions.RestoreRedundancyFunction;\n+import org.apache.geode.management.internal.util.ManagementUtils;\n+import org.apache.geode.management.operation.RestoreRedundancyRequest;\n+import org.apache.geode.management.runtime.RestoreRedundancyResults;\n+\n+public class RestoreRedundancyPerformer\n+    implements OperationPerformer<RestoreRedundancyRequest, RestoreRedundancyResults> {\n+  @Immutable\n+  public static final Version ADDED_VERSION = Version.GEODE_1_13_0;\n+  public static final String NO_MEMBERS_WITH_VERSION_FOR_REGION =\n+      \"No members with a version greater than or equal to %s were found for region %s\";\n+  public static final String EXCEPTION_MEMBER_MESSAGE = \"Exception occurred on member %s: %s\";\n+\n+  @Override\n+  public RestoreRedundancyResults perform(Cache cache, RestoreRedundancyRequest operation) {\n+    return perform(cache, operation, false);\n+  }\n+\n+  public RestoreRedundancyResults perform(Cache cache, RestoreRedundancyRequest operation,\n+      boolean checkStatus) {\n+    List<RebalanceOperationPerformer.MemberPRInfo> membersForEachRegion = new ArrayList<>();\n+    List<String> includedRegionsWithNoMembers = new ArrayList<>();\n+\n+    populateLists(membersForEachRegion, includedRegionsWithNoMembers, operation.getIncludeRegions(),\n+        operation.getExcludeRegions(), (InternalCache) cache);\n+\n+    for (RebalanceOperationPerformer.MemberPRInfo prInfo : membersForEachRegion) {\n+      // Filter out any members using older versions of Geode\n+      List<DistributedMember> viableMembers = filterViableMembers(prInfo);\n+\n+      if (viableMembers.size() != 0) {\n+        // Update the MemberPRInfo with the viable members\n+        prInfo.dsMemberList = viableMembers;\n+      } else {\n+        RestoreRedundancyResultsImpl results = new RestoreRedundancyResultsImpl();\n+        results.setStatusMessage(String.format(NO_MEMBERS_WITH_VERSION_FOR_REGION,\n+            ADDED_VERSION.getName(), prInfo.region));\n+        results.setSuccess(false);\n+        return results;\n+      }\n+    }\n+\n+    List<RestoreRedundancyResults> functionResults = new ArrayList<>();\n+    Object[] functionArgs = new Object[] {operation, checkStatus};\n+    List<DistributedMember> completedMembers = new ArrayList<>();\n+    for (RebalanceOperationPerformer.MemberPRInfo memberPRInfo : membersForEachRegion) {\n+      // Check to see if an earlier function execution has already targeted a member hosting this\n+      // region. If one has, there is no point sending a function for this region as it has already\n+      // had redundancy restored\n+      if (!Collections.disjoint(completedMembers, memberPRInfo.dsMemberList)) {\n+        continue;\n+      }\n+      // Try the function on the first member for this region\n+      DistributedMember targetMember = memberPRInfo.dsMemberList.get(0);\n+      RestoreRedundancyResults functionResult = executeFunctionAndGetFunctionResult(\n+          new RestoreRedundancyFunction(), functionArgs, targetMember);\n+      if (!functionResult.getSuccess()) {\n+        // Record the error and then give up\n+        RestoreRedundancyResultsImpl results = new RestoreRedundancyResultsImpl();\n+        results.setSuccess(false);\n+        String errorString =\n+            String.format(EXCEPTION_MEMBER_MESSAGE, targetMember.getName(),\n+                functionResult.getStatusMessage());\n+        results.setStatusMessage(errorString);\n+        results.setSuccess(false);\n+        return results;\n+      }\n+      functionResults.add(functionResult);\n+      completedMembers.add(targetMember);\n+    }\n+\n+    RestoreRedundancyResultsImpl finalResult = new RestoreRedundancyResultsImpl();\n+    finalResult.addIncludedRegionsWithNoMembers(includedRegionsWithNoMembers);\n+    for (RestoreRedundancyResults functionResult : functionResults) {\n+      finalResult.addRegionResults(functionResult);\n+      finalResult.setSuccess(functionResult.getSuccess());\n+      finalResult.setStatusMessage(functionResult.getStatusMessage());\n+    }\n+    return finalResult;\n+  }\n+\n+  // this returns either an Exception or RestoreRedundancyResults\n+  public RestoreRedundancyResults executeFunctionAndGetFunctionResult(Function<?> function,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4NjIxMw==", "bodyText": "getMembersForEachRegion can be private until you need to make it @VisibleForTesting. Currently there's no test using the method though.", "url": "https://github.com/apache/geode/pull/5249#discussion_r441186213", "createdAt": "2020-06-16T22:53:45Z", "author": {"login": "kirklund"}, "path": "geode-core/src/main/java/org/apache/geode/management/internal/operation/RestoreRedundancyPerformer.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.management.internal.operation;\n+\n+import static org.apache.geode.cache.Region.SEPARATOR;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.geode.annotations.Immutable;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.ResultCollector;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.serialization.Version;\n+import org.apache.geode.management.ManagementService;\n+import org.apache.geode.management.internal.functions.RestoreRedundancyFunction;\n+import org.apache.geode.management.internal.util.ManagementUtils;\n+import org.apache.geode.management.operation.RestoreRedundancyRequest;\n+import org.apache.geode.management.runtime.RestoreRedundancyResults;\n+\n+public class RestoreRedundancyPerformer\n+    implements OperationPerformer<RestoreRedundancyRequest, RestoreRedundancyResults> {\n+  @Immutable\n+  public static final Version ADDED_VERSION = Version.GEODE_1_13_0;\n+  public static final String NO_MEMBERS_WITH_VERSION_FOR_REGION =\n+      \"No members with a version greater than or equal to %s were found for region %s\";\n+  public static final String EXCEPTION_MEMBER_MESSAGE = \"Exception occurred on member %s: %s\";\n+\n+  @Override\n+  public RestoreRedundancyResults perform(Cache cache, RestoreRedundancyRequest operation) {\n+    return perform(cache, operation, false);\n+  }\n+\n+  public RestoreRedundancyResults perform(Cache cache, RestoreRedundancyRequest operation,\n+      boolean checkStatus) {\n+    List<RebalanceOperationPerformer.MemberPRInfo> membersForEachRegion = new ArrayList<>();\n+    List<String> includedRegionsWithNoMembers = new ArrayList<>();\n+\n+    populateLists(membersForEachRegion, includedRegionsWithNoMembers, operation.getIncludeRegions(),\n+        operation.getExcludeRegions(), (InternalCache) cache);\n+\n+    for (RebalanceOperationPerformer.MemberPRInfo prInfo : membersForEachRegion) {\n+      // Filter out any members using older versions of Geode\n+      List<DistributedMember> viableMembers = filterViableMembers(prInfo);\n+\n+      if (viableMembers.size() != 0) {\n+        // Update the MemberPRInfo with the viable members\n+        prInfo.dsMemberList = viableMembers;\n+      } else {\n+        RestoreRedundancyResultsImpl results = new RestoreRedundancyResultsImpl();\n+        results.setStatusMessage(String.format(NO_MEMBERS_WITH_VERSION_FOR_REGION,\n+            ADDED_VERSION.getName(), prInfo.region));\n+        results.setSuccess(false);\n+        return results;\n+      }\n+    }\n+\n+    List<RestoreRedundancyResults> functionResults = new ArrayList<>();\n+    Object[] functionArgs = new Object[] {operation, checkStatus};\n+    List<DistributedMember> completedMembers = new ArrayList<>();\n+    for (RebalanceOperationPerformer.MemberPRInfo memberPRInfo : membersForEachRegion) {\n+      // Check to see if an earlier function execution has already targeted a member hosting this\n+      // region. If one has, there is no point sending a function for this region as it has already\n+      // had redundancy restored\n+      if (!Collections.disjoint(completedMembers, memberPRInfo.dsMemberList)) {\n+        continue;\n+      }\n+      // Try the function on the first member for this region\n+      DistributedMember targetMember = memberPRInfo.dsMemberList.get(0);\n+      RestoreRedundancyResults functionResult = executeFunctionAndGetFunctionResult(\n+          new RestoreRedundancyFunction(), functionArgs, targetMember);\n+      if (!functionResult.getSuccess()) {\n+        // Record the error and then give up\n+        RestoreRedundancyResultsImpl results = new RestoreRedundancyResultsImpl();\n+        results.setSuccess(false);\n+        String errorString =\n+            String.format(EXCEPTION_MEMBER_MESSAGE, targetMember.getName(),\n+                functionResult.getStatusMessage());\n+        results.setStatusMessage(errorString);\n+        results.setSuccess(false);\n+        return results;\n+      }\n+      functionResults.add(functionResult);\n+      completedMembers.add(targetMember);\n+    }\n+\n+    RestoreRedundancyResultsImpl finalResult = new RestoreRedundancyResultsImpl();\n+    finalResult.addIncludedRegionsWithNoMembers(includedRegionsWithNoMembers);\n+    for (RestoreRedundancyResults functionResult : functionResults) {\n+      finalResult.addRegionResults(functionResult);\n+      finalResult.setSuccess(functionResult.getSuccess());\n+      finalResult.setStatusMessage(functionResult.getStatusMessage());\n+    }\n+    return finalResult;\n+  }\n+\n+  // this returns either an Exception or RestoreRedundancyResults\n+  public RestoreRedundancyResults executeFunctionAndGetFunctionResult(Function<?> function,\n+      Object args,\n+      final DistributedMember targetMember) {\n+    ResultCollector<?, ?> rc =\n+        ManagementUtils.executeFunction(function, args, Collections.singleton(targetMember));\n+    List<RestoreRedundancyResults> results = (List<RestoreRedundancyResults>) rc.getResult();\n+    return results.size() > 0 ? results.get(0) : null;\n+  }\n+\n+\n+  List<DistributedMember> filterViableMembers(\n+      RebalanceOperationPerformer.MemberPRInfo prInfo) {\n+    return prInfo.dsMemberList.stream()\n+        .map(InternalDistributedMember.class::cast)\n+        .filter(member -> member.getVersionObject().compareTo(ADDED_VERSION) >= 0)\n+        .collect(Collectors.toList());\n+  }\n+\n+  void populateLists(List<RebalanceOperationPerformer.MemberPRInfo> membersForEachRegion,\n+      List<String> noMemberRegions, List<String> includeRegions, List<String> excludeRegions,\n+      InternalCache cache) {\n+    // Include all regions\n+    if (includeRegions == null) {\n+      // Exclude these regions\n+      List<RebalanceOperationPerformer.MemberPRInfo> memberRegionList =\n+          getMembersForEachRegion(cache, excludeRegions);\n+      membersForEachRegion.addAll(memberRegionList);\n+    } else {\n+      for (String regionName : includeRegions) {\n+        DistributedMember memberForRegion = getOneMemberForRegion(cache, regionName);\n+\n+        // If we did not find a member for this region name, add it to the list of regions with no\n+        // members\n+        if (memberForRegion == null) {\n+          noMemberRegions.add(regionName);\n+        } else {\n+          RebalanceOperationPerformer.MemberPRInfo memberPRInfo =\n+              new RebalanceOperationPerformer.MemberPRInfo();\n+          memberPRInfo.region = regionName;\n+          memberPRInfo.dsMemberList.add(memberForRegion);\n+          membersForEachRegion.add(memberPRInfo);\n+        }\n+      }\n+    }\n+  }\n+\n+  // Extracted for testing\n+  List<RebalanceOperationPerformer.MemberPRInfo> getMembersForEachRegion(InternalCache cache,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4NjI2Mg==", "bodyText": "getOneMemberForRegion can be private until you need to make it @VisibleForTesting. Currently there's no test using the method though.", "url": "https://github.com/apache/geode/pull/5249#discussion_r441186262", "createdAt": "2020-06-16T22:53:56Z", "author": {"login": "kirklund"}, "path": "geode-core/src/main/java/org/apache/geode/management/internal/operation/RestoreRedundancyPerformer.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.management.internal.operation;\n+\n+import static org.apache.geode.cache.Region.SEPARATOR;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.geode.annotations.Immutable;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.ResultCollector;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.serialization.Version;\n+import org.apache.geode.management.ManagementService;\n+import org.apache.geode.management.internal.functions.RestoreRedundancyFunction;\n+import org.apache.geode.management.internal.util.ManagementUtils;\n+import org.apache.geode.management.operation.RestoreRedundancyRequest;\n+import org.apache.geode.management.runtime.RestoreRedundancyResults;\n+\n+public class RestoreRedundancyPerformer\n+    implements OperationPerformer<RestoreRedundancyRequest, RestoreRedundancyResults> {\n+  @Immutable\n+  public static final Version ADDED_VERSION = Version.GEODE_1_13_0;\n+  public static final String NO_MEMBERS_WITH_VERSION_FOR_REGION =\n+      \"No members with a version greater than or equal to %s were found for region %s\";\n+  public static final String EXCEPTION_MEMBER_MESSAGE = \"Exception occurred on member %s: %s\";\n+\n+  @Override\n+  public RestoreRedundancyResults perform(Cache cache, RestoreRedundancyRequest operation) {\n+    return perform(cache, operation, false);\n+  }\n+\n+  public RestoreRedundancyResults perform(Cache cache, RestoreRedundancyRequest operation,\n+      boolean checkStatus) {\n+    List<RebalanceOperationPerformer.MemberPRInfo> membersForEachRegion = new ArrayList<>();\n+    List<String> includedRegionsWithNoMembers = new ArrayList<>();\n+\n+    populateLists(membersForEachRegion, includedRegionsWithNoMembers, operation.getIncludeRegions(),\n+        operation.getExcludeRegions(), (InternalCache) cache);\n+\n+    for (RebalanceOperationPerformer.MemberPRInfo prInfo : membersForEachRegion) {\n+      // Filter out any members using older versions of Geode\n+      List<DistributedMember> viableMembers = filterViableMembers(prInfo);\n+\n+      if (viableMembers.size() != 0) {\n+        // Update the MemberPRInfo with the viable members\n+        prInfo.dsMemberList = viableMembers;\n+      } else {\n+        RestoreRedundancyResultsImpl results = new RestoreRedundancyResultsImpl();\n+        results.setStatusMessage(String.format(NO_MEMBERS_WITH_VERSION_FOR_REGION,\n+            ADDED_VERSION.getName(), prInfo.region));\n+        results.setSuccess(false);\n+        return results;\n+      }\n+    }\n+\n+    List<RestoreRedundancyResults> functionResults = new ArrayList<>();\n+    Object[] functionArgs = new Object[] {operation, checkStatus};\n+    List<DistributedMember> completedMembers = new ArrayList<>();\n+    for (RebalanceOperationPerformer.MemberPRInfo memberPRInfo : membersForEachRegion) {\n+      // Check to see if an earlier function execution has already targeted a member hosting this\n+      // region. If one has, there is no point sending a function for this region as it has already\n+      // had redundancy restored\n+      if (!Collections.disjoint(completedMembers, memberPRInfo.dsMemberList)) {\n+        continue;\n+      }\n+      // Try the function on the first member for this region\n+      DistributedMember targetMember = memberPRInfo.dsMemberList.get(0);\n+      RestoreRedundancyResults functionResult = executeFunctionAndGetFunctionResult(\n+          new RestoreRedundancyFunction(), functionArgs, targetMember);\n+      if (!functionResult.getSuccess()) {\n+        // Record the error and then give up\n+        RestoreRedundancyResultsImpl results = new RestoreRedundancyResultsImpl();\n+        results.setSuccess(false);\n+        String errorString =\n+            String.format(EXCEPTION_MEMBER_MESSAGE, targetMember.getName(),\n+                functionResult.getStatusMessage());\n+        results.setStatusMessage(errorString);\n+        results.setSuccess(false);\n+        return results;\n+      }\n+      functionResults.add(functionResult);\n+      completedMembers.add(targetMember);\n+    }\n+\n+    RestoreRedundancyResultsImpl finalResult = new RestoreRedundancyResultsImpl();\n+    finalResult.addIncludedRegionsWithNoMembers(includedRegionsWithNoMembers);\n+    for (RestoreRedundancyResults functionResult : functionResults) {\n+      finalResult.addRegionResults(functionResult);\n+      finalResult.setSuccess(functionResult.getSuccess());\n+      finalResult.setStatusMessage(functionResult.getStatusMessage());\n+    }\n+    return finalResult;\n+  }\n+\n+  // this returns either an Exception or RestoreRedundancyResults\n+  public RestoreRedundancyResults executeFunctionAndGetFunctionResult(Function<?> function,\n+      Object args,\n+      final DistributedMember targetMember) {\n+    ResultCollector<?, ?> rc =\n+        ManagementUtils.executeFunction(function, args, Collections.singleton(targetMember));\n+    List<RestoreRedundancyResults> results = (List<RestoreRedundancyResults>) rc.getResult();\n+    return results.size() > 0 ? results.get(0) : null;\n+  }\n+\n+\n+  List<DistributedMember> filterViableMembers(\n+      RebalanceOperationPerformer.MemberPRInfo prInfo) {\n+    return prInfo.dsMemberList.stream()\n+        .map(InternalDistributedMember.class::cast)\n+        .filter(member -> member.getVersionObject().compareTo(ADDED_VERSION) >= 0)\n+        .collect(Collectors.toList());\n+  }\n+\n+  void populateLists(List<RebalanceOperationPerformer.MemberPRInfo> membersForEachRegion,\n+      List<String> noMemberRegions, List<String> includeRegions, List<String> excludeRegions,\n+      InternalCache cache) {\n+    // Include all regions\n+    if (includeRegions == null) {\n+      // Exclude these regions\n+      List<RebalanceOperationPerformer.MemberPRInfo> memberRegionList =\n+          getMembersForEachRegion(cache, excludeRegions);\n+      membersForEachRegion.addAll(memberRegionList);\n+    } else {\n+      for (String regionName : includeRegions) {\n+        DistributedMember memberForRegion = getOneMemberForRegion(cache, regionName);\n+\n+        // If we did not find a member for this region name, add it to the list of regions with no\n+        // members\n+        if (memberForRegion == null) {\n+          noMemberRegions.add(regionName);\n+        } else {\n+          RebalanceOperationPerformer.MemberPRInfo memberPRInfo =\n+              new RebalanceOperationPerformer.MemberPRInfo();\n+          memberPRInfo.region = regionName;\n+          memberPRInfo.dsMemberList.add(memberForRegion);\n+          membersForEachRegion.add(memberPRInfo);\n+        }\n+      }\n+    }\n+  }\n+\n+  // Extracted for testing\n+  List<RebalanceOperationPerformer.MemberPRInfo> getMembersForEachRegion(InternalCache cache,\n+      List<String> excludedRegionList) {\n+    return RebalanceOperationPerformer.getMemberRegionList(\n+        ManagementService.getManagementService(cache), cache, excludedRegionList);\n+  }\n+\n+  // Extracted for testing\n+  DistributedMember getOneMemberForRegion(InternalCache cache, String regionName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4NzA2Nw==", "bodyText": "This line generates unchecked cast warning. You can change it to this if you want:\nimport static org.apache.geode.util.internal.UncheckedUtils.uncheckedCast;\n\n    List<RestoreRedundancyResults> results = uncheckedCast(rc.getResult());", "url": "https://github.com/apache/geode/pull/5249#discussion_r441187067", "createdAt": "2020-06-16T22:56:18Z", "author": {"login": "kirklund"}, "path": "geode-core/src/main/java/org/apache/geode/management/internal/operation/RestoreRedundancyPerformer.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.management.internal.operation;\n+\n+import static org.apache.geode.cache.Region.SEPARATOR;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.geode.annotations.Immutable;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.ResultCollector;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.serialization.Version;\n+import org.apache.geode.management.ManagementService;\n+import org.apache.geode.management.internal.functions.RestoreRedundancyFunction;\n+import org.apache.geode.management.internal.util.ManagementUtils;\n+import org.apache.geode.management.operation.RestoreRedundancyRequest;\n+import org.apache.geode.management.runtime.RestoreRedundancyResults;\n+\n+public class RestoreRedundancyPerformer\n+    implements OperationPerformer<RestoreRedundancyRequest, RestoreRedundancyResults> {\n+  @Immutable\n+  public static final Version ADDED_VERSION = Version.GEODE_1_13_0;\n+  public static final String NO_MEMBERS_WITH_VERSION_FOR_REGION =\n+      \"No members with a version greater than or equal to %s were found for region %s\";\n+  public static final String EXCEPTION_MEMBER_MESSAGE = \"Exception occurred on member %s: %s\";\n+\n+  @Override\n+  public RestoreRedundancyResults perform(Cache cache, RestoreRedundancyRequest operation) {\n+    return perform(cache, operation, false);\n+  }\n+\n+  public RestoreRedundancyResults perform(Cache cache, RestoreRedundancyRequest operation,\n+      boolean checkStatus) {\n+    List<RebalanceOperationPerformer.MemberPRInfo> membersForEachRegion = new ArrayList<>();\n+    List<String> includedRegionsWithNoMembers = new ArrayList<>();\n+\n+    populateLists(membersForEachRegion, includedRegionsWithNoMembers, operation.getIncludeRegions(),\n+        operation.getExcludeRegions(), (InternalCache) cache);\n+\n+    for (RebalanceOperationPerformer.MemberPRInfo prInfo : membersForEachRegion) {\n+      // Filter out any members using older versions of Geode\n+      List<DistributedMember> viableMembers = filterViableMembers(prInfo);\n+\n+      if (viableMembers.size() != 0) {\n+        // Update the MemberPRInfo with the viable members\n+        prInfo.dsMemberList = viableMembers;\n+      } else {\n+        RestoreRedundancyResultsImpl results = new RestoreRedundancyResultsImpl();\n+        results.setStatusMessage(String.format(NO_MEMBERS_WITH_VERSION_FOR_REGION,\n+            ADDED_VERSION.getName(), prInfo.region));\n+        results.setSuccess(false);\n+        return results;\n+      }\n+    }\n+\n+    List<RestoreRedundancyResults> functionResults = new ArrayList<>();\n+    Object[] functionArgs = new Object[] {operation, checkStatus};\n+    List<DistributedMember> completedMembers = new ArrayList<>();\n+    for (RebalanceOperationPerformer.MemberPRInfo memberPRInfo : membersForEachRegion) {\n+      // Check to see if an earlier function execution has already targeted a member hosting this\n+      // region. If one has, there is no point sending a function for this region as it has already\n+      // had redundancy restored\n+      if (!Collections.disjoint(completedMembers, memberPRInfo.dsMemberList)) {\n+        continue;\n+      }\n+      // Try the function on the first member for this region\n+      DistributedMember targetMember = memberPRInfo.dsMemberList.get(0);\n+      RestoreRedundancyResults functionResult = executeFunctionAndGetFunctionResult(\n+          new RestoreRedundancyFunction(), functionArgs, targetMember);\n+      if (!functionResult.getSuccess()) {\n+        // Record the error and then give up\n+        RestoreRedundancyResultsImpl results = new RestoreRedundancyResultsImpl();\n+        results.setSuccess(false);\n+        String errorString =\n+            String.format(EXCEPTION_MEMBER_MESSAGE, targetMember.getName(),\n+                functionResult.getStatusMessage());\n+        results.setStatusMessage(errorString);\n+        results.setSuccess(false);\n+        return results;\n+      }\n+      functionResults.add(functionResult);\n+      completedMembers.add(targetMember);\n+    }\n+\n+    RestoreRedundancyResultsImpl finalResult = new RestoreRedundancyResultsImpl();\n+    finalResult.addIncludedRegionsWithNoMembers(includedRegionsWithNoMembers);\n+    for (RestoreRedundancyResults functionResult : functionResults) {\n+      finalResult.addRegionResults(functionResult);\n+      finalResult.setSuccess(functionResult.getSuccess());\n+      finalResult.setStatusMessage(functionResult.getStatusMessage());\n+    }\n+    return finalResult;\n+  }\n+\n+  // this returns either an Exception or RestoreRedundancyResults\n+  public RestoreRedundancyResults executeFunctionAndGetFunctionResult(Function<?> function,\n+      Object args,\n+      final DistributedMember targetMember) {\n+    ResultCollector<?, ?> rc =\n+        ManagementUtils.executeFunction(function, args, Collections.singleton(targetMember));\n+    List<RestoreRedundancyResults> results = (List<RestoreRedundancyResults>) rc.getResult();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4ODAyNA==", "bodyText": "Another size() call that can be changed to use isEmpty():\nreturn !results.isEmpty() ? results.get(0) : null;\n\nOr even better:\nreturn results.isEmpty() ? null : results.get(0);\n\nIntelliJ has an inspection you can turn on that allows you to automatically make this change.", "url": "https://github.com/apache/geode/pull/5249#discussion_r441188024", "createdAt": "2020-06-16T22:59:27Z", "author": {"login": "kirklund"}, "path": "geode-core/src/main/java/org/apache/geode/management/internal/operation/RestoreRedundancyPerformer.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.management.internal.operation;\n+\n+import static org.apache.geode.cache.Region.SEPARATOR;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.geode.annotations.Immutable;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.ResultCollector;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.serialization.Version;\n+import org.apache.geode.management.ManagementService;\n+import org.apache.geode.management.internal.functions.RestoreRedundancyFunction;\n+import org.apache.geode.management.internal.util.ManagementUtils;\n+import org.apache.geode.management.operation.RestoreRedundancyRequest;\n+import org.apache.geode.management.runtime.RestoreRedundancyResults;\n+\n+public class RestoreRedundancyPerformer\n+    implements OperationPerformer<RestoreRedundancyRequest, RestoreRedundancyResults> {\n+  @Immutable\n+  public static final Version ADDED_VERSION = Version.GEODE_1_13_0;\n+  public static final String NO_MEMBERS_WITH_VERSION_FOR_REGION =\n+      \"No members with a version greater than or equal to %s were found for region %s\";\n+  public static final String EXCEPTION_MEMBER_MESSAGE = \"Exception occurred on member %s: %s\";\n+\n+  @Override\n+  public RestoreRedundancyResults perform(Cache cache, RestoreRedundancyRequest operation) {\n+    return perform(cache, operation, false);\n+  }\n+\n+  public RestoreRedundancyResults perform(Cache cache, RestoreRedundancyRequest operation,\n+      boolean checkStatus) {\n+    List<RebalanceOperationPerformer.MemberPRInfo> membersForEachRegion = new ArrayList<>();\n+    List<String> includedRegionsWithNoMembers = new ArrayList<>();\n+\n+    populateLists(membersForEachRegion, includedRegionsWithNoMembers, operation.getIncludeRegions(),\n+        operation.getExcludeRegions(), (InternalCache) cache);\n+\n+    for (RebalanceOperationPerformer.MemberPRInfo prInfo : membersForEachRegion) {\n+      // Filter out any members using older versions of Geode\n+      List<DistributedMember> viableMembers = filterViableMembers(prInfo);\n+\n+      if (viableMembers.size() != 0) {\n+        // Update the MemberPRInfo with the viable members\n+        prInfo.dsMemberList = viableMembers;\n+      } else {\n+        RestoreRedundancyResultsImpl results = new RestoreRedundancyResultsImpl();\n+        results.setStatusMessage(String.format(NO_MEMBERS_WITH_VERSION_FOR_REGION,\n+            ADDED_VERSION.getName(), prInfo.region));\n+        results.setSuccess(false);\n+        return results;\n+      }\n+    }\n+\n+    List<RestoreRedundancyResults> functionResults = new ArrayList<>();\n+    Object[] functionArgs = new Object[] {operation, checkStatus};\n+    List<DistributedMember> completedMembers = new ArrayList<>();\n+    for (RebalanceOperationPerformer.MemberPRInfo memberPRInfo : membersForEachRegion) {\n+      // Check to see if an earlier function execution has already targeted a member hosting this\n+      // region. If one has, there is no point sending a function for this region as it has already\n+      // had redundancy restored\n+      if (!Collections.disjoint(completedMembers, memberPRInfo.dsMemberList)) {\n+        continue;\n+      }\n+      // Try the function on the first member for this region\n+      DistributedMember targetMember = memberPRInfo.dsMemberList.get(0);\n+      RestoreRedundancyResults functionResult = executeFunctionAndGetFunctionResult(\n+          new RestoreRedundancyFunction(), functionArgs, targetMember);\n+      if (!functionResult.getSuccess()) {\n+        // Record the error and then give up\n+        RestoreRedundancyResultsImpl results = new RestoreRedundancyResultsImpl();\n+        results.setSuccess(false);\n+        String errorString =\n+            String.format(EXCEPTION_MEMBER_MESSAGE, targetMember.getName(),\n+                functionResult.getStatusMessage());\n+        results.setStatusMessage(errorString);\n+        results.setSuccess(false);\n+        return results;\n+      }\n+      functionResults.add(functionResult);\n+      completedMembers.add(targetMember);\n+    }\n+\n+    RestoreRedundancyResultsImpl finalResult = new RestoreRedundancyResultsImpl();\n+    finalResult.addIncludedRegionsWithNoMembers(includedRegionsWithNoMembers);\n+    for (RestoreRedundancyResults functionResult : functionResults) {\n+      finalResult.addRegionResults(functionResult);\n+      finalResult.setSuccess(functionResult.getSuccess());\n+      finalResult.setStatusMessage(functionResult.getStatusMessage());\n+    }\n+    return finalResult;\n+  }\n+\n+  // this returns either an Exception or RestoreRedundancyResults\n+  public RestoreRedundancyResults executeFunctionAndGetFunctionResult(Function<?> function,\n+      Object args,\n+      final DistributedMember targetMember) {\n+    ResultCollector<?, ?> rc =\n+        ManagementUtils.executeFunction(function, args, Collections.singleton(targetMember));\n+    List<RestoreRedundancyResults> results = (List<RestoreRedundancyResults>) rc.getResult();\n+    return results.size() > 0 ? results.get(0) : null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4ODM0NQ==", "bodyText": "Let's make all of these fields private. There's an inspection that finds and automates this.", "url": "https://github.com/apache/geode/pull/5249#discussion_r441188345", "createdAt": "2020-06-16T23:00:22Z", "author": {"login": "kirklund"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/control/RestoreRedundancyOperationImplTest.java", "diffHunk": "@@ -38,19 +38,19 @@\n import org.junit.Test;\n \n import org.apache.geode.cache.RegionDestroyedException;\n-import org.apache.geode.cache.control.RegionRedundancyStatus;\n-import org.apache.geode.cache.control.RestoreRedundancyResults;\n import org.apache.geode.cache.partition.PartitionRebalanceInfo;\n import org.apache.geode.internal.cache.InternalCache;\n import org.apache.geode.internal.cache.PartitionedRegion;\n import org.apache.geode.internal.cache.partitioned.PartitionedRegionRebalanceOp;\n+import org.apache.geode.management.runtime.RegionRedundancyStatus;\n+import org.apache.geode.management.runtime.RestoreRedundancyResults;\n \n public class RestoreRedundancyOperationImplTest {\n   InternalCache cache;\n   InternalResourceManager manager;\n   ResourceManagerStats stats;\n   RestoreRedundancyOperationImpl operation;\n-  RestoreRedundancyResultsImpl emptyResults;\n+  SerializableRestoreRedundancyResultsImpl emptyResults;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4OTI2OQ==", "bodyText": "This is untouched code, but we should change all \"\\n\" uses with System.lineSeparator() to ensure it is platform independent.", "url": "https://github.com/apache/geode/pull/5249#discussion_r441189269", "createdAt": "2020-06-16T23:03:10Z", "author": {"login": "kirklund"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/control/RestoreRedundancyResultsImplTest.java", "diffHunk": "@@ -102,7 +108,7 @@ public void getMessageReturnsStatusForAllRegionsAndPrimaryInfo() {\n \n     results.addPrimaryReassignmentDetails(details);\n \n-    String message = results.getMessage();\n+    String message = results.getRegionOperationMessage();\n     List<String> messageLines = Arrays.asList(message.split(\"\\n\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4OTQ3MA==", "bodyText": "You can delete the throws Exception.", "url": "https://github.com/apache/geode/pull/5249#discussion_r441189470", "createdAt": "2020-06-16T23:03:53Z", "author": {"login": "kirklund"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/control/RestoreRedundancyResultsImplTest.java", "diffHunk": "@@ -68,30 +68,36 @@ public void setUp() {\n     when(zeroRedundancyRegionResult.getRegionName()).thenReturn(zeroRedundancyRegionName);\n     when(details.getPrimaryTransfersCompleted()).thenReturn(transfersCompleted);\n     when(details.getPrimaryTransferTime()).thenReturn(transferTime);\n-    results = new RestoreRedundancyResultsImpl();\n+    results = new SerializableRestoreRedundancyResultsImpl();\n+  }\n+\n+  @Test\n+  public void initialStateIsSuccess() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4OTYyMQ==", "bodyText": "Please make all the constants in this test private.", "url": "https://github.com/apache/geode/pull/5249#discussion_r441189621", "createdAt": "2020-06-16T23:04:27Z", "author": {"login": "kirklund"}, "path": "geode-core/src/test/java/org/apache/geode/management/internal/operation/RestoreRedundancyPerformerTest.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.apache.geode.management.internal.operation;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalCacheForClientAccess;\n+import org.apache.geode.internal.serialization.Version;\n+import org.apache.geode.management.DistributedRegionMXBean;\n+import org.apache.geode.management.DistributedSystemMXBean;\n+import org.apache.geode.management.internal.BaseManagementService;\n+import org.apache.geode.management.internal.functions.RestoreRedundancyFunction;\n+import org.apache.geode.management.operation.RestoreRedundancyRequest;\n+import org.apache.geode.management.runtime.RegionRedundancyStatus;\n+import org.apache.geode.management.runtime.RestoreRedundancyResults;\n+\n+public class RestoreRedundancyPerformerTest {\n+\n+  public static final String DS_MEMBER_NAME_SERVER1 = \"server1\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5MDI3OQ==", "bodyText": "All of the Mockito.***** matchers in this class are actually owned by org.mockito.ArgumentMatchers. I would recommend just converting them all to static import which should switch them to importing from ArgumentMatchers.", "url": "https://github.com/apache/geode/pull/5249#discussion_r441190279", "createdAt": "2020-06-16T23:06:25Z", "author": {"login": "kirklund"}, "path": "geode-core/src/test/java/org/apache/geode/management/internal/operation/RestoreRedundancyPerformerTest.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package org.apache.geode.management.internal.operation;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalCacheForClientAccess;\n+import org.apache.geode.internal.serialization.Version;\n+import org.apache.geode.management.DistributedRegionMXBean;\n+import org.apache.geode.management.DistributedSystemMXBean;\n+import org.apache.geode.management.internal.BaseManagementService;\n+import org.apache.geode.management.internal.functions.RestoreRedundancyFunction;\n+import org.apache.geode.management.operation.RestoreRedundancyRequest;\n+import org.apache.geode.management.runtime.RegionRedundancyStatus;\n+import org.apache.geode.management.runtime.RestoreRedundancyResults;\n+\n+public class RestoreRedundancyPerformerTest {\n+\n+  public static final String DS_MEMBER_NAME_SERVER1 = \"server1\";\n+  public static final String DS_MEMBER_NAME_SERVER2 = \"server2\";\n+\n+  public static final String REGION_1 = \"region1\";\n+  public static final String BOGUS_PASS_MESSAGE = \"Bogus pass message\";\n+  private InternalDistributedMember server1;\n+  private InternalDistributedMember server2;\n+  private InternalCacheForClientAccess internalCacheForClientAccess;\n+  private RestoreRedundancyPerformer restoreRedundancyPerformer;\n+\n+  @Before\n+  public void setup() {\n+    BaseManagementService baseManagementService = mock(BaseManagementService.class);\n+    DistributedSystemMXBean distributedSystemMXBean = mock(DistributedSystemMXBean.class);\n+    DistributedRegionMXBean distributedRegionMXBean = mock(DistributedRegionMXBean.class);\n+    server1 = mock(InternalDistributedMember.class);\n+    server2 = mock(InternalDistributedMember.class);\n+    internalCacheForClientAccess = mock(InternalCacheForClientAccess.class);\n+    InternalDistributedSystem internalDistributedSystem = mock(InternalDistributedSystem.class);\n+    DistributionManager distributionManager = mock(DistributionManager.class);\n+    when(baseManagementService.getDistributedSystemMXBean()).thenReturn(distributedSystemMXBean);\n+    when(baseManagementService.getDistributedRegionMXBean(Mockito.anyString()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5MTc2Mw==", "bodyText": "buildResultModelFromFunctionResults should be private until something outside the class needs to reference it.", "url": "https://github.com/apache/geode/pull/5249#discussion_r441191763", "createdAt": "2020-06-16T23:10:44Z", "author": {"login": "kirklund"}, "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/RedundancyCommand.java", "diffHunk": "@@ -148,81 +126,37 @@ void populateLists(List<RebalanceOperationPerformer.MemberPRInfo> membersForEach\n     }\n   }\n \n-  List<CliFunctionResult> executeFunctionOnMembers(String[] includeRegions, String[] excludeRegions,\n-      boolean reassignPrimaries, boolean isStatusCommand,\n-      List<RebalanceOperationPerformer.MemberPRInfo> membersForEachRegion) {\n-    List<CliFunctionResult> functionResults = new ArrayList<>();\n-    Object[] functionArgs =\n-        new Object[] {includeRegions, excludeRegions, reassignPrimaries, isStatusCommand};\n-    List<DistributedMember> completedMembers = new ArrayList<>();\n-    for (RebalanceOperationPerformer.MemberPRInfo memberPRInfo : membersForEachRegion) {\n-      // Check to see if an earlier function execution has already targeted a member hosting this\n-      // region. If one has, there is no point sending a function for this region as it has already\n-      // had redundancy restored\n-      if (!Collections.disjoint(completedMembers, memberPRInfo.dsMemberList)) {\n-        continue;\n-      }\n-      // Try the function on the first member for this region\n-      DistributedMember targetMember = memberPRInfo.dsMemberList.get(0);\n-      CliFunctionResult functionResult = executeFunctionAndGetFunctionResult(\n-          new RedundancyCommandFunction(), functionArgs, targetMember);\n-      if (functionResult.getStatus().equals(ERROR.name())) {\n-        // Record the error and then give up\n-        functionResults.add(functionResult);\n-        break;\n-      }\n-      functionResults.add(functionResult);\n-      completedMembers.add(targetMember);\n-    }\n-    return functionResults;\n-  }\n-\n-  ResultModel buildResultModelFromFunctionResults(List<CliFunctionResult> functionResults,\n-      List<String> includedRegionsWithNoMembers, boolean isStatusCommand) {\n+  ResultModel buildResultModelFromFunctionResults(RestoreRedundancyResults results,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5MjI4Ng==", "bodyText": "Optional: RedundancyCommand has unused methods and one constant that can be deleted. It also has constants and other methods that should be changed to private sometime. Most of this is untouched code.", "url": "https://github.com/apache/geode/pull/5249#discussion_r441192286", "createdAt": "2020-06-16T23:12:20Z", "author": {"login": "kirklund"}, "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/RedundancyCommand.java", "diffHunk": "@@ -15,35 +15,33 @@\n package org.apache.geode.management.internal.cli.commands;\n \n import static org.apache.geode.cache.Region.SEPARATOR;\n-import static org.apache.geode.internal.cache.control.RestoreRedundancyResultsImpl.NO_REDUNDANT_COPIES_FOR_REGIONS;\n-import static org.apache.geode.internal.cache.control.RestoreRedundancyResultsImpl.PRIMARY_TRANSFERS_COMPLETED;\n-import static org.apache.geode.internal.cache.control.RestoreRedundancyResultsImpl.PRIMARY_TRANSFER_TIME;\n-import static org.apache.geode.internal.cache.control.RestoreRedundancyResultsImpl.REDUNDANCY_NOT_SATISFIED_FOR_REGIONS;\n-import static org.apache.geode.internal.cache.control.RestoreRedundancyResultsImpl.REDUNDANCY_SATISFIED_FOR_REGIONS;\n-import static org.apache.geode.management.internal.functions.CliFunctionResult.StatusState.ERROR;\n+import static org.apache.geode.internal.cache.control.SerializableRestoreRedundancyResultsImpl.NO_REDUNDANT_COPIES_FOR_REGIONS;\n+import static org.apache.geode.internal.cache.control.SerializableRestoreRedundancyResultsImpl.PRIMARY_TRANSFERS_COMPLETED;\n+import static org.apache.geode.internal.cache.control.SerializableRestoreRedundancyResultsImpl.PRIMARY_TRANSFER_TIME;\n+import static org.apache.geode.internal.cache.control.SerializableRestoreRedundancyResultsImpl.REDUNDANCY_NOT_SATISFIED_FOR_REGIONS;\n+import static org.apache.geode.internal.cache.control.SerializableRestoreRedundancyResultsImpl.REDUNDANCY_SATISFIED_FOR_REGIONS;\n \n import java.util.ArrayList;\n import java.util.Arrays;\n-import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n import java.util.stream.Collectors;\n \n-import org.apache.geode.cache.control.RegionRedundancyStatus;\n-import org.apache.geode.cache.control.RestoreRedundancyResults;\n import org.apache.geode.distributed.DistributedMember;\n import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n import org.apache.geode.internal.cache.InternalCache;\n-import org.apache.geode.internal.cache.control.RestoreRedundancyResultsImpl;\n+import org.apache.geode.internal.cache.control.SerializableRestoreRedundancyResultsImpl;\n import org.apache.geode.internal.serialization.Version;\n import org.apache.geode.management.ManagementService;\n import org.apache.geode.management.cli.GfshCommand;\n import org.apache.geode.management.cli.Result;\n-import org.apache.geode.management.internal.cli.functions.RedundancyCommandFunction;\n import org.apache.geode.management.internal.cli.result.model.InfoResultModel;\n import org.apache.geode.management.internal.cli.result.model.ResultModel;\n-import org.apache.geode.management.internal.functions.CliFunctionResult;\n import org.apache.geode.management.internal.operation.RebalanceOperationPerformer;\n+import org.apache.geode.management.internal.operation.RestoreRedundancyPerformer;\n+import org.apache.geode.management.operation.RestoreRedundancyRequest;\n+import org.apache.geode.management.runtime.RegionRedundancyStatus;\n+import org.apache.geode.management.runtime.RestoreRedundancyResults;\n \n public class RedundancyCommand extends GfshCommand {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5MjUwMA==", "bodyText": "This class has size()\u00a0calls that would be more appropriate as sEmpty() calls.", "url": "https://github.com/apache/geode/pull/5249#discussion_r441192500", "createdAt": "2020-06-16T23:13:02Z", "author": {"login": "kirklund"}, "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/RedundancyCommand.java", "diffHunk": "@@ -148,81 +126,37 @@ void populateLists(List<RebalanceOperationPerformer.MemberPRInfo> membersForEach\n     }\n   }\n \n-  List<CliFunctionResult> executeFunctionOnMembers(String[] includeRegions, String[] excludeRegions,\n-      boolean reassignPrimaries, boolean isStatusCommand,\n-      List<RebalanceOperationPerformer.MemberPRInfo> membersForEachRegion) {\n-    List<CliFunctionResult> functionResults = new ArrayList<>();\n-    Object[] functionArgs =\n-        new Object[] {includeRegions, excludeRegions, reassignPrimaries, isStatusCommand};\n-    List<DistributedMember> completedMembers = new ArrayList<>();\n-    for (RebalanceOperationPerformer.MemberPRInfo memberPRInfo : membersForEachRegion) {\n-      // Check to see if an earlier function execution has already targeted a member hosting this\n-      // region. If one has, there is no point sending a function for this region as it has already\n-      // had redundancy restored\n-      if (!Collections.disjoint(completedMembers, memberPRInfo.dsMemberList)) {\n-        continue;\n-      }\n-      // Try the function on the first member for this region\n-      DistributedMember targetMember = memberPRInfo.dsMemberList.get(0);\n-      CliFunctionResult functionResult = executeFunctionAndGetFunctionResult(\n-          new RedundancyCommandFunction(), functionArgs, targetMember);\n-      if (functionResult.getStatus().equals(ERROR.name())) {\n-        // Record the error and then give up\n-        functionResults.add(functionResult);\n-        break;\n-      }\n-      functionResults.add(functionResult);\n-      completedMembers.add(targetMember);\n-    }\n-    return functionResults;\n-  }\n-\n-  ResultModel buildResultModelFromFunctionResults(List<CliFunctionResult> functionResults,\n-      List<String> includedRegionsWithNoMembers, boolean isStatusCommand) {\n+  ResultModel buildResultModelFromFunctionResults(RestoreRedundancyResults results,\n+      boolean isStatusCommand) {\n     // No members hosting partitioned regions were found, but no regions were explicitly included,\n     // so return OK status\n-    if (functionResults.size() == 0 && includedRegionsWithNoMembers.size() == 0) {\n+    if (results.getRegionResults().size() == 0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5Mjc3OQ==", "bodyText": "OUTPUT_STRING should be protected instead of public.", "url": "https://github.com/apache/geode/pull/5249#discussion_r441192779", "createdAt": "2020-06-16T23:13:59Z", "author": {"login": "kirklund"}, "path": "geode-management/src/main/java/org/apache/geode/management/internal/operation/RegionRedundancyStatusImpl.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.management.internal.operation;\n+\n+import org.apache.geode.management.runtime.RegionRedundancyStatus;\n+\n+/**\n+ * result object used by the cms that only needs to be json serializable\n+ */\n+public class RegionRedundancyStatusImpl implements RegionRedundancyStatus {\n+\n+  public static final String OUTPUT_STRING =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5MzA0OA==", "bodyText": "The non-default constructor should be package-private (no qualifier) with the annotation @VisibleForTesting", "url": "https://github.com/apache/geode/pull/5249#discussion_r441193048", "createdAt": "2020-06-16T23:14:52Z", "author": {"login": "kirklund"}, "path": "geode-management/src/main/java/org/apache/geode/management/internal/operation/RegionRedundancyStatusImpl.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.management.internal.operation;\n+\n+import org.apache.geode.management.runtime.RegionRedundancyStatus;\n+\n+/**\n+ * result object used by the cms that only needs to be json serializable\n+ */\n+public class RegionRedundancyStatusImpl implements RegionRedundancyStatus {\n+\n+  public static final String OUTPUT_STRING =\n+      \"%s redundancy status: %s. Desired redundancy is %s and actual redundancy is %s.\";\n+\n+  /**\n+   * The name of the region used to create this object.\n+   */\n+  protected String regionName;\n+\n+  /**\n+   * The configured redundancy of the region used to create this object.\n+   */\n+  protected int configuredRedundancy;\n+\n+  /**\n+   * The actual redundancy of the region used to create this object at time of creation.\n+   */\n+  protected int actualRedundancy;\n+\n+  /**\n+   * The {@link RedundancyStatus} of the region used to create this object at time of creation.\n+   */\n+  protected RedundancyStatus status;\n+\n+  /**\n+   * Default constructor used for serialization\n+   */\n+  public RegionRedundancyStatusImpl() {}\n+\n+  public RegionRedundancyStatusImpl(int configuredRedundancy, int actualRedundancy,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5MzE0Ng==", "bodyText": "determineStatus is unused.", "url": "https://github.com/apache/geode/pull/5249#discussion_r441193146", "createdAt": "2020-06-16T23:15:11Z", "author": {"login": "kirklund"}, "path": "geode-management/src/main/java/org/apache/geode/management/internal/operation/RegionRedundancyStatusImpl.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.management.internal.operation;\n+\n+import org.apache.geode.management.runtime.RegionRedundancyStatus;\n+\n+/**\n+ * result object used by the cms that only needs to be json serializable\n+ */\n+public class RegionRedundancyStatusImpl implements RegionRedundancyStatus {\n+\n+  public static final String OUTPUT_STRING =\n+      \"%s redundancy status: %s. Desired redundancy is %s and actual redundancy is %s.\";\n+\n+  /**\n+   * The name of the region used to create this object.\n+   */\n+  protected String regionName;\n+\n+  /**\n+   * The configured redundancy of the region used to create this object.\n+   */\n+  protected int configuredRedundancy;\n+\n+  /**\n+   * The actual redundancy of the region used to create this object at time of creation.\n+   */\n+  protected int actualRedundancy;\n+\n+  /**\n+   * The {@link RedundancyStatus} of the region used to create this object at time of creation.\n+   */\n+  protected RedundancyStatus status;\n+\n+  /**\n+   * Default constructor used for serialization\n+   */\n+  public RegionRedundancyStatusImpl() {}\n+\n+  public RegionRedundancyStatusImpl(int configuredRedundancy, int actualRedundancy,\n+      String regionName, RedundancyStatus status) {\n+    this.configuredRedundancy = configuredRedundancy;\n+    this.actualRedundancy = actualRedundancy;\n+    this.regionName = regionName;\n+    this.status = status;\n+  }\n+\n+  @Override\n+  public String getRegionName() {\n+    return regionName;\n+  }\n+\n+  @Override\n+  public int getConfiguredRedundancy() {\n+    return configuredRedundancy;\n+  }\n+\n+  @Override\n+  public int getActualRedundancy() {\n+    return actualRedundancy;\n+  }\n+\n+  @Override\n+  public RedundancyStatus getStatus() {\n+    return status;\n+  }\n+\n+\n+  /**\n+   * Determines the {@link RedundancyStatus} for the region. If redundancy is not configured (i.e.\n+   * configured redundancy = 0), this always returns {@link RedundancyStatus#SATISFIED}.\n+   *\n+   * @param desiredRedundancy The configured redundancy of the region.\n+   * @param actualRedundancy The actual redundancy of the region.\n+   * @return The {@link RedundancyStatus} for the region.\n+   */\n+  private RedundancyStatus determineStatus(int desiredRedundancy, int actualRedundancy) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5NTAwNQ==", "bodyText": "Optional: This class has some size() calls that could be changed to use isEmpty() if you want. Also some unused code and overly public constants and methods.", "url": "https://github.com/apache/geode/pull/5249#discussion_r441195005", "createdAt": "2020-06-16T23:21:15Z", "author": {"login": "kirklund"}, "path": "geode-management/src/main/java/org/apache/geode/management/internal/operation/RestoreRedundancyResultsImpl.java", "diffHunk": "@@ -12,29 +12,22 @@\n  * or implied. See the License for the specific language governing permissions and limitations under\n  * the License.\n  */\n-package org.apache.geode.internal.cache.control;\n+package org.apache.geode.management.internal.operation;\n \n-import java.io.DataInput;\n-import java.io.DataOutput;\n-import java.io.IOException;\n import java.time.Duration;\n import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.stream.Collectors;\n \n-import org.apache.geode.DataSerializer;\n-import org.apache.geode.cache.control.RegionRedundancyStatus;\n-import org.apache.geode.cache.control.RestoreRedundancyResults;\n-import org.apache.geode.cache.partition.PartitionRebalanceInfo;\n-import org.apache.geode.internal.serialization.DataSerializableFixedID;\n-import org.apache.geode.internal.serialization.DeserializationContext;\n-import org.apache.geode.internal.serialization.SerializationContext;\n-import org.apache.geode.internal.serialization.Version;\n-\n-public class RestoreRedundancyResultsImpl\n-    implements RestoreRedundancyResults, DataSerializableFixedID {\n+import org.apache.geode.management.runtime.RegionRedundancyStatus;\n+import org.apache.geode.management.runtime.RestoreRedundancyResults;\n+\n+/**\n+ * result object used by the cms that only needs to be json serializable\n+ */\n+public class RestoreRedundancyResultsImpl implements RestoreRedundancyResults {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5NTUxOA==", "bodyText": "This is a dangling comment which can be orphaned easily if you move code around. I would make it a javadoc so that it \"sticks\" to the field:\n/** null means all regions included */\nprivate List<String> includeRegions;\n\nSame thing for the comment above excludeRegions.", "url": "https://github.com/apache/geode/pull/5249#discussion_r441195518", "createdAt": "2020-06-16T23:22:54Z", "author": {"login": "kirklund"}, "path": "geode-management/src/main/java/org/apache/geode/management/operation/RestoreRedundancyRequest.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.management.operation;\n+\n+import java.util.List;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+\n+import org.apache.geode.annotations.Experimental;\n+import org.apache.geode.management.api.ClusterManagementOperation;\n+import org.apache.geode.management.runtime.RestoreRedundancyResults;\n+\n+/**\n+ * Defines a distributed system request to optimize bucket allocation across members.\n+ */\n+@Experimental\n+public class RestoreRedundancyRequest\n+    implements ClusterManagementOperation<RestoreRedundancyResults> {\n+\n+  /**\n+   * see {@link #getEndpoint()}\n+   */\n+  public static final String RESTORE_REDUNDANCY_REBALANCE_ENDPOINT =\n+      \"/operations/restoreRedundancy\";\n+  // null means all regions included", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5NTY0NA==", "bodyText": "RESTORE_REDUNDANCY_REBALANCE_ENDPOINT should be private.", "url": "https://github.com/apache/geode/pull/5249#discussion_r441195644", "createdAt": "2020-06-16T23:23:21Z", "author": {"login": "kirklund"}, "path": "geode-management/src/main/java/org/apache/geode/management/operation/RestoreRedundancyRequest.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.management.operation;\n+\n+import java.util.List;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+\n+import org.apache.geode.annotations.Experimental;\n+import org.apache.geode.management.api.ClusterManagementOperation;\n+import org.apache.geode.management.runtime.RestoreRedundancyResults;\n+\n+/**\n+ * Defines a distributed system request to optimize bucket allocation across members.\n+ */\n+@Experimental\n+public class RestoreRedundancyRequest\n+    implements ClusterManagementOperation<RestoreRedundancyResults> {\n+\n+  /**\n+   * see {@link #getEndpoint()}\n+   */\n+  public static final String RESTORE_REDUNDANCY_REBALANCE_ENDPOINT =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5NTc1Nw==", "bodyText": "Lots of unnecessary this. qualifiers.", "url": "https://github.com/apache/geode/pull/5249#discussion_r441195757", "createdAt": "2020-06-16T23:23:46Z", "author": {"login": "kirklund"}, "path": "geode-management/src/main/java/org/apache/geode/management/operation/RestoreRedundancyRequest.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.management.operation;\n+\n+import java.util.List;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+\n+import org.apache.geode.annotations.Experimental;\n+import org.apache.geode.management.api.ClusterManagementOperation;\n+import org.apache.geode.management.runtime.RestoreRedundancyResults;\n+\n+/**\n+ * Defines a distributed system request to optimize bucket allocation across members.\n+ */\n+@Experimental\n+public class RestoreRedundancyRequest\n+    implements ClusterManagementOperation<RestoreRedundancyResults> {\n+\n+  /**\n+   * see {@link #getEndpoint()}\n+   */\n+  public static final String RESTORE_REDUNDANCY_REBALANCE_ENDPOINT =\n+      \"/operations/restoreRedundancy\";\n+  // null means all regions included\n+  private List<String> includeRegions;\n+  // null means don't exclude any regions\n+  private List<String> excludeRegions;\n+  private boolean reassignPrimaries = true;\n+  private String operator;\n+\n+  /**\n+   * by default, requests all partitioned regions to be rebalanced\n+   */\n+  public RestoreRedundancyRequest() {}\n+\n+  /**\n+   * copy constructor\n+   */\n+  public RestoreRedundancyRequest(\n+      RestoreRedundancyRequest other) {\n+    this.setExcludeRegions(other.getExcludeRegions());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5NTkwMA==", "bodyText": "setOperator is unused.", "url": "https://github.com/apache/geode/pull/5249#discussion_r441195900", "createdAt": "2020-06-16T23:24:21Z", "author": {"login": "kirklund"}, "path": "geode-management/src/main/java/org/apache/geode/management/operation/RestoreRedundancyRequest.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.management.operation;\n+\n+import java.util.List;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+\n+import org.apache.geode.annotations.Experimental;\n+import org.apache.geode.management.api.ClusterManagementOperation;\n+import org.apache.geode.management.runtime.RestoreRedundancyResults;\n+\n+/**\n+ * Defines a distributed system request to optimize bucket allocation across members.\n+ */\n+@Experimental\n+public class RestoreRedundancyRequest\n+    implements ClusterManagementOperation<RestoreRedundancyResults> {\n+\n+  /**\n+   * see {@link #getEndpoint()}\n+   */\n+  public static final String RESTORE_REDUNDANCY_REBALANCE_ENDPOINT =\n+      \"/operations/restoreRedundancy\";\n+  // null means all regions included\n+  private List<String> includeRegions;\n+  // null means don't exclude any regions\n+  private List<String> excludeRegions;\n+  private boolean reassignPrimaries = true;\n+  private String operator;\n+\n+  /**\n+   * by default, requests all partitioned regions to be rebalanced\n+   */\n+  public RestoreRedundancyRequest() {}\n+\n+  /**\n+   * copy constructor\n+   */\n+  public RestoreRedundancyRequest(\n+      RestoreRedundancyRequest other) {\n+    this.setExcludeRegions(other.getExcludeRegions());\n+    this.setIncludeRegions(other.getIncludeRegions());\n+    this.setReassignPrimaries(other.getReassignPrimaries());\n+    this.operator = other.getOperator();\n+  }\n+\n+  /***\n+   * Returns the list of regions to be rebalanced (or an empty list for all-except-excluded)\n+   */\n+  public List<String> getIncludeRegions() {\n+    return includeRegions;\n+  }\n+\n+  /**\n+   * requests rebalance of the specified region(s) only. When at least one region is specified, this\n+   * takes precedence over any excluded regions.\n+   */\n+  public void setIncludeRegions(List<String> includeRegions) {\n+    this.includeRegions = includeRegions;\n+  }\n+\n+  /***\n+   * Returns the list of regions NOT to be rebalanced (iff {@link #getIncludeRegions()} is empty)\n+   */\n+  public List<String> getExcludeRegions() {\n+    return excludeRegions;\n+  }\n+\n+  /**\n+   * excludes specific regions from the rebalance, if {@link #getIncludeRegions()} is empty,\n+   * otherwise has no effect\n+   * default: no regions are excluded\n+   */\n+  public void setExcludeRegions(List<String> excludeRegions) {\n+    this.excludeRegions = excludeRegions;\n+  }\n+\n+  public void setReassignPrimaries(boolean reassignPrimaries) {\n+    this.reassignPrimaries = reassignPrimaries;\n+  }\n+\n+  public boolean getReassignPrimaries() {\n+    return reassignPrimaries;\n+  }\n+\n+  @Override\n+  @JsonIgnore\n+  public String getEndpoint() {\n+    return RESTORE_REDUNDANCY_REBALANCE_ENDPOINT;\n+  }\n+\n+  @Override\n+  public String getOperator() {\n+    return operator;\n+  }\n+\n+  public void setOperator(String operator) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 110}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxNzkzMDMz", "url": "https://github.com/apache/geode/pull/5249#pullrequestreview-431793033", "createdAt": "2020-06-16T18:40:53Z", "commit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODo0MDo1M1rOGkogeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwMDoyMjo1MlrOGkxeGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA2NTU5NA==", "bodyText": "I think that variable names should start with a lower-case letter.", "url": "https://github.com/apache/geode/pull/5249#discussion_r441065594", "createdAt": "2020-06-16T18:40:53Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/main/java/org/apache/geode/management/internal/operation/RebalanceOperationPerformer.java", "diffHunk": "@@ -189,16 +189,16 @@ public static DistributedMember getAssociatedMembers(String region, final Intern\n \n     String[] membersName = bean.getMembers();\n     Set<DistributedMember> dsMembers = ManagementUtils.getAllMembers(cache);\n-    Iterator it = dsMembers.iterator();\n+    Iterator<DistributedMember> it = dsMembers.iterator();\n \n     boolean matchFound = false;\n \n     if (membersName.length > 1) {\n       while (it.hasNext() && !matchFound) {\n-        DistributedMember dsmember = (DistributedMember) it.next();\n+        DistributedMember DSMember = it.next();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA2NzcyNg==", "bodyText": "This comment should be removed.", "url": "https://github.com/apache/geode/pull/5249#discussion_r441067726", "createdAt": "2020-06-16T18:44:49Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/main/java/org/apache/geode/management/internal/functions/RestoreRedundancyFunction.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.management.internal.functions;\n+\n+import static org.apache.geode.management.runtime.RestoreRedundancyResults.Status.ERROR;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.Logger;\n+\n+import org.apache.geode.cache.control.RestoreRedundancyOperation;\n+import org.apache.geode.cache.execute.FunctionContext;\n+import org.apache.geode.internal.cache.control.SerializableRestoreRedundancyResultsImpl;\n+import org.apache.geode.internal.cache.execute.InternalFunction;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+import org.apache.geode.management.internal.operation.RestoreRedundancyResultsImpl;\n+import org.apache.geode.management.operation.RestoreRedundancyRequest;\n+\n+\n+public class RestoreRedundancyFunction implements InternalFunction<Object[]> {\n+  private static final Logger logger = LogService.getLogger();\n+\n+  public static final String ID = RestoreRedundancyFunction.class.getName();\n+\n+\n+  private static final long serialVersionUID = 1L;\n+\n+  @Override\n+  // this would return the RestoreRedundancyResults if successful,\n+  // it will return an exception to the caller if status is failure or any exception happens\n+  public void execute(FunctionContext<Object[]> context) {\n+    Object[] arguments = context.getArguments();\n+    RestoreRedundancyRequest request = (RestoreRedundancyRequest) arguments[0];\n+    boolean isStatusCommand = (boolean) arguments[1];\n+    RestoreRedundancyOperation redundancyOperation =\n+        context.getCache().getResourceManager().createRestoreRedundancyOperation();\n+    Set<String> includeRegionsSet = null;\n+    if (request.getIncludeRegions() != null) {\n+      includeRegionsSet = new HashSet<>(request.getIncludeRegions());\n+    }\n+    Set<String> excludeRegionsSet = null;\n+    if (request.getExcludeRegions() != null) {\n+      excludeRegionsSet = new HashSet<>(request.getExcludeRegions());\n+    }\n+    redundancyOperation.includeRegions(includeRegionsSet);\n+    redundancyOperation.excludeRegions(excludeRegionsSet);\n+    RestoreRedundancyResultsImpl results;\n+\n+    try {\n+      if (isStatusCommand) {\n+        results = (RestoreRedundancyResultsImpl) redundancyOperation.redundancyStatus();\n+      } else {\n+        redundancyOperation.shouldReassignPrimaries(request.getReassignPrimaries());\n+        results = (RestoreRedundancyResultsImpl) redundancyOperation.start().join();\n+      }\n+      if (results.getRegionOperationStatus().equals(ERROR)) {\n+        Exception e = new Exception(results.getRegionOperationMessage());\n+        throw e;\n+      }\n+      results.setSuccess(true);\n+      results.setStatusMessage(\"Success\"); // MLH change this", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA3NTExNA==", "bodyText": "There is a redundant call to setSuccess(false) here, since it's already been called a few lines above.", "url": "https://github.com/apache/geode/pull/5249#discussion_r441075114", "createdAt": "2020-06-16T18:58:14Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/main/java/org/apache/geode/management/internal/operation/RestoreRedundancyPerformer.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.management.internal.operation;\n+\n+import static org.apache.geode.cache.Region.SEPARATOR;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.geode.annotations.Immutable;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.ResultCollector;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.serialization.Version;\n+import org.apache.geode.management.ManagementService;\n+import org.apache.geode.management.internal.functions.RestoreRedundancyFunction;\n+import org.apache.geode.management.internal.util.ManagementUtils;\n+import org.apache.geode.management.operation.RestoreRedundancyRequest;\n+import org.apache.geode.management.runtime.RestoreRedundancyResults;\n+\n+public class RestoreRedundancyPerformer\n+    implements OperationPerformer<RestoreRedundancyRequest, RestoreRedundancyResults> {\n+  @Immutable\n+  public static final Version ADDED_VERSION = Version.GEODE_1_13_0;\n+  public static final String NO_MEMBERS_WITH_VERSION_FOR_REGION =\n+      \"No members with a version greater than or equal to %s were found for region %s\";\n+  public static final String EXCEPTION_MEMBER_MESSAGE = \"Exception occurred on member %s: %s\";\n+\n+  @Override\n+  public RestoreRedundancyResults perform(Cache cache, RestoreRedundancyRequest operation) {\n+    return perform(cache, operation, false);\n+  }\n+\n+  public RestoreRedundancyResults perform(Cache cache, RestoreRedundancyRequest operation,\n+      boolean checkStatus) {\n+    List<RebalanceOperationPerformer.MemberPRInfo> membersForEachRegion = new ArrayList<>();\n+    List<String> includedRegionsWithNoMembers = new ArrayList<>();\n+\n+    populateLists(membersForEachRegion, includedRegionsWithNoMembers, operation.getIncludeRegions(),\n+        operation.getExcludeRegions(), (InternalCache) cache);\n+\n+    for (RebalanceOperationPerformer.MemberPRInfo prInfo : membersForEachRegion) {\n+      // Filter out any members using older versions of Geode\n+      List<DistributedMember> viableMembers = filterViableMembers(prInfo);\n+\n+      if (viableMembers.size() != 0) {\n+        // Update the MemberPRInfo with the viable members\n+        prInfo.dsMemberList = viableMembers;\n+      } else {\n+        RestoreRedundancyResultsImpl results = new RestoreRedundancyResultsImpl();\n+        results.setStatusMessage(String.format(NO_MEMBERS_WITH_VERSION_FOR_REGION,\n+            ADDED_VERSION.getName(), prInfo.region));\n+        results.setSuccess(false);\n+        return results;\n+      }\n+    }\n+\n+    List<RestoreRedundancyResults> functionResults = new ArrayList<>();\n+    Object[] functionArgs = new Object[] {operation, checkStatus};\n+    List<DistributedMember> completedMembers = new ArrayList<>();\n+    for (RebalanceOperationPerformer.MemberPRInfo memberPRInfo : membersForEachRegion) {\n+      // Check to see if an earlier function execution has already targeted a member hosting this\n+      // region. If one has, there is no point sending a function for this region as it has already\n+      // had redundancy restored\n+      if (!Collections.disjoint(completedMembers, memberPRInfo.dsMemberList)) {\n+        continue;\n+      }\n+      // Try the function on the first member for this region\n+      DistributedMember targetMember = memberPRInfo.dsMemberList.get(0);\n+      RestoreRedundancyResults functionResult = executeFunctionAndGetFunctionResult(\n+          new RestoreRedundancyFunction(), functionArgs, targetMember);\n+      if (!functionResult.getSuccess()) {\n+        // Record the error and then give up\n+        RestoreRedundancyResultsImpl results = new RestoreRedundancyResultsImpl();\n+        results.setSuccess(false);\n+        String errorString =\n+            String.format(EXCEPTION_MEMBER_MESSAGE, targetMember.getName(),\n+                functionResult.getStatusMessage());\n+        results.setStatusMessage(errorString);\n+        results.setSuccess(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE1NjU1Nw==", "bodyText": "These lines appear to be redundant within the for loop, since in order to reach this point, all function results must be successful. These calls to setSuccess() and setStatusMessage() could be moved outside the for loop and only called once.", "url": "https://github.com/apache/geode/pull/5249#discussion_r441156557", "createdAt": "2020-06-16T21:36:57Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/main/java/org/apache/geode/management/internal/operation/RestoreRedundancyPerformer.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.management.internal.operation;\n+\n+import static org.apache.geode.cache.Region.SEPARATOR;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.geode.annotations.Immutable;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.ResultCollector;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.serialization.Version;\n+import org.apache.geode.management.ManagementService;\n+import org.apache.geode.management.internal.functions.RestoreRedundancyFunction;\n+import org.apache.geode.management.internal.util.ManagementUtils;\n+import org.apache.geode.management.operation.RestoreRedundancyRequest;\n+import org.apache.geode.management.runtime.RestoreRedundancyResults;\n+\n+public class RestoreRedundancyPerformer\n+    implements OperationPerformer<RestoreRedundancyRequest, RestoreRedundancyResults> {\n+  @Immutable\n+  public static final Version ADDED_VERSION = Version.GEODE_1_13_0;\n+  public static final String NO_MEMBERS_WITH_VERSION_FOR_REGION =\n+      \"No members with a version greater than or equal to %s were found for region %s\";\n+  public static final String EXCEPTION_MEMBER_MESSAGE = \"Exception occurred on member %s: %s\";\n+\n+  @Override\n+  public RestoreRedundancyResults perform(Cache cache, RestoreRedundancyRequest operation) {\n+    return perform(cache, operation, false);\n+  }\n+\n+  public RestoreRedundancyResults perform(Cache cache, RestoreRedundancyRequest operation,\n+      boolean checkStatus) {\n+    List<RebalanceOperationPerformer.MemberPRInfo> membersForEachRegion = new ArrayList<>();\n+    List<String> includedRegionsWithNoMembers = new ArrayList<>();\n+\n+    populateLists(membersForEachRegion, includedRegionsWithNoMembers, operation.getIncludeRegions(),\n+        operation.getExcludeRegions(), (InternalCache) cache);\n+\n+    for (RebalanceOperationPerformer.MemberPRInfo prInfo : membersForEachRegion) {\n+      // Filter out any members using older versions of Geode\n+      List<DistributedMember> viableMembers = filterViableMembers(prInfo);\n+\n+      if (viableMembers.size() != 0) {\n+        // Update the MemberPRInfo with the viable members\n+        prInfo.dsMemberList = viableMembers;\n+      } else {\n+        RestoreRedundancyResultsImpl results = new RestoreRedundancyResultsImpl();\n+        results.setStatusMessage(String.format(NO_MEMBERS_WITH_VERSION_FOR_REGION,\n+            ADDED_VERSION.getName(), prInfo.region));\n+        results.setSuccess(false);\n+        return results;\n+      }\n+    }\n+\n+    List<RestoreRedundancyResults> functionResults = new ArrayList<>();\n+    Object[] functionArgs = new Object[] {operation, checkStatus};\n+    List<DistributedMember> completedMembers = new ArrayList<>();\n+    for (RebalanceOperationPerformer.MemberPRInfo memberPRInfo : membersForEachRegion) {\n+      // Check to see if an earlier function execution has already targeted a member hosting this\n+      // region. If one has, there is no point sending a function for this region as it has already\n+      // had redundancy restored\n+      if (!Collections.disjoint(completedMembers, memberPRInfo.dsMemberList)) {\n+        continue;\n+      }\n+      // Try the function on the first member for this region\n+      DistributedMember targetMember = memberPRInfo.dsMemberList.get(0);\n+      RestoreRedundancyResults functionResult = executeFunctionAndGetFunctionResult(\n+          new RestoreRedundancyFunction(), functionArgs, targetMember);\n+      if (!functionResult.getSuccess()) {\n+        // Record the error and then give up\n+        RestoreRedundancyResultsImpl results = new RestoreRedundancyResultsImpl();\n+        results.setSuccess(false);\n+        String errorString =\n+            String.format(EXCEPTION_MEMBER_MESSAGE, targetMember.getName(),\n+                functionResult.getStatusMessage());\n+        results.setStatusMessage(errorString);\n+        results.setSuccess(false);\n+        return results;\n+      }\n+      functionResults.add(functionResult);\n+      completedMembers.add(targetMember);\n+    }\n+\n+    RestoreRedundancyResultsImpl finalResult = new RestoreRedundancyResultsImpl();\n+    finalResult.addIncludedRegionsWithNoMembers(includedRegionsWithNoMembers);\n+    for (RestoreRedundancyResults functionResult : functionResults) {\n+      finalResult.addRegionResults(functionResult);\n+      finalResult.setSuccess(functionResult.getSuccess());\n+      finalResult.setStatusMessage(functionResult.getStatusMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE2Mjg3OQ==", "bodyText": "I'm not sure I understand why in the case that an exception is thrown, a SerializableRestoreRedundancyResultsImpl is returned here instead of a RestoreRedundancyResultsImpl.", "url": "https://github.com/apache/geode/pull/5249#discussion_r441162879", "createdAt": "2020-06-16T21:51:30Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/main/java/org/apache/geode/management/internal/functions/RestoreRedundancyFunction.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.management.internal.functions;\n+\n+import static org.apache.geode.management.runtime.RestoreRedundancyResults.Status.ERROR;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.Logger;\n+\n+import org.apache.geode.cache.control.RestoreRedundancyOperation;\n+import org.apache.geode.cache.execute.FunctionContext;\n+import org.apache.geode.internal.cache.control.SerializableRestoreRedundancyResultsImpl;\n+import org.apache.geode.internal.cache.execute.InternalFunction;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+import org.apache.geode.management.internal.operation.RestoreRedundancyResultsImpl;\n+import org.apache.geode.management.operation.RestoreRedundancyRequest;\n+\n+\n+public class RestoreRedundancyFunction implements InternalFunction<Object[]> {\n+  private static final Logger logger = LogService.getLogger();\n+\n+  public static final String ID = RestoreRedundancyFunction.class.getName();\n+\n+\n+  private static final long serialVersionUID = 1L;\n+\n+  @Override\n+  // this would return the RestoreRedundancyResults if successful,\n+  // it will return an exception to the caller if status is failure or any exception happens\n+  public void execute(FunctionContext<Object[]> context) {\n+    Object[] arguments = context.getArguments();\n+    RestoreRedundancyRequest request = (RestoreRedundancyRequest) arguments[0];\n+    boolean isStatusCommand = (boolean) arguments[1];\n+    RestoreRedundancyOperation redundancyOperation =\n+        context.getCache().getResourceManager().createRestoreRedundancyOperation();\n+    Set<String> includeRegionsSet = null;\n+    if (request.getIncludeRegions() != null) {\n+      includeRegionsSet = new HashSet<>(request.getIncludeRegions());\n+    }\n+    Set<String> excludeRegionsSet = null;\n+    if (request.getExcludeRegions() != null) {\n+      excludeRegionsSet = new HashSet<>(request.getExcludeRegions());\n+    }\n+    redundancyOperation.includeRegions(includeRegionsSet);\n+    redundancyOperation.excludeRegions(excludeRegionsSet);\n+    RestoreRedundancyResultsImpl results;\n+\n+    try {\n+      if (isStatusCommand) {\n+        results = (RestoreRedundancyResultsImpl) redundancyOperation.redundancyStatus();\n+      } else {\n+        redundancyOperation.shouldReassignPrimaries(request.getReassignPrimaries());\n+        results = (RestoreRedundancyResultsImpl) redundancyOperation.start().join();\n+      }\n+      if (results.getRegionOperationStatus().equals(ERROR)) {\n+        Exception e = new Exception(results.getRegionOperationMessage());\n+        throw e;\n+      }\n+      results.setSuccess(true);\n+      results.setStatusMessage(\"Success\"); // MLH change this\n+    } catch (Exception e) {\n+      results =\n+          new SerializableRestoreRedundancyResultsImpl();\n+      results.setSuccess(false);\n+      results.setStatusMessage(e.getMessage());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE3NDYxNw==", "bodyText": "Remove this commented out code.", "url": "https://github.com/apache/geode/pull/5249#discussion_r441174617", "createdAt": "2020-06-16T22:20:25Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/management/internal/functions/RestoreRedundancyFunctionTest.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.management.internal.functions;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.control.RestoreRedundancyOperation;\n+import org.apache.geode.cache.execute.FunctionContext;\n+import org.apache.geode.cache.execute.ResultSender;\n+import org.apache.geode.internal.cache.control.SerializableRestoreRedundancyResultsImpl;\n+import org.apache.geode.management.operation.RestoreRedundancyRequest;\n+import org.apache.geode.management.runtime.RestoreRedundancyResults;\n+\n+public class RestoreRedundancyFunctionTest {\n+  @SuppressWarnings(\"unchecked\")\n+  private final FunctionContext<Object[]> mockContext = mock(FunctionContext.class);\n+  private final Cache mockCache = mock(Cache.class, RETURNS_DEEP_STUBS);\n+  private final RestoreRedundancyOperation mockOperation =\n+      mock(RestoreRedundancyOperation.class, RETURNS_DEEP_STUBS);\n+  private final SerializableRestoreRedundancyResultsImpl mockResults =\n+      mock(SerializableRestoreRedundancyResultsImpl.class);\n+  private final String message = \"expected message\";\n+  private RestoreRedundancyFunction function;\n+  private ResultSender resultSender;\n+  private ArgumentCaptor<SerializableRestoreRedundancyResultsImpl> argumentCaptor;\n+  private RestoreRedundancyRequest request;\n+\n+  @Before\n+  public void setUp() throws InterruptedException, ExecutionException {\n+    function = new RestoreRedundancyFunction();\n+    when(mockContext.getCache()).thenReturn(mockCache);\n+    request = new RestoreRedundancyRequest();\n+    request.setReassignPrimaries(true);\n+\n+    when(mockContext.getArguments()).thenReturn(new Object[] {request, false});\n+    when(mockCache.getResourceManager().createRestoreRedundancyOperation())\n+        .thenReturn(mockOperation);\n+    CompletableFuture<RestoreRedundancyResults> future =\n+        CompletableFuture.completedFuture(mockResults);\n+    when(mockOperation.start()).thenReturn(future);\n+    when(mockResults.getRegionOperationMessage()).thenReturn(message);\n+    // when(mockResults.getStatusMessage()).thenReturn(message);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE3NzU0OA==", "bodyText": "Can this RestoreRedundancyRequest object be replaced with a mock, to avoid testing the behaviour of both it and the RestoreRedundancyFunction class in this unit test?", "url": "https://github.com/apache/geode/pull/5249#discussion_r441177548", "createdAt": "2020-06-16T22:28:36Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/management/internal/functions/RestoreRedundancyFunctionTest.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.management.internal.functions;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.control.RestoreRedundancyOperation;\n+import org.apache.geode.cache.execute.FunctionContext;\n+import org.apache.geode.cache.execute.ResultSender;\n+import org.apache.geode.internal.cache.control.SerializableRestoreRedundancyResultsImpl;\n+import org.apache.geode.management.operation.RestoreRedundancyRequest;\n+import org.apache.geode.management.runtime.RestoreRedundancyResults;\n+\n+public class RestoreRedundancyFunctionTest {\n+  @SuppressWarnings(\"unchecked\")\n+  private final FunctionContext<Object[]> mockContext = mock(FunctionContext.class);\n+  private final Cache mockCache = mock(Cache.class, RETURNS_DEEP_STUBS);\n+  private final RestoreRedundancyOperation mockOperation =\n+      mock(RestoreRedundancyOperation.class, RETURNS_DEEP_STUBS);\n+  private final SerializableRestoreRedundancyResultsImpl mockResults =\n+      mock(SerializableRestoreRedundancyResultsImpl.class);\n+  private final String message = \"expected message\";\n+  private RestoreRedundancyFunction function;\n+  private ResultSender resultSender;\n+  private ArgumentCaptor<SerializableRestoreRedundancyResultsImpl> argumentCaptor;\n+  private RestoreRedundancyRequest request;\n+\n+  @Before\n+  public void setUp() throws InterruptedException, ExecutionException {\n+    function = new RestoreRedundancyFunction();\n+    when(mockContext.getCache()).thenReturn(mockCache);\n+    request = new RestoreRedundancyRequest();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIwMzE5MA==", "bodyText": "This variable is set in RestoreRedundancyPerformer using the name checkStatus. It might be best to have consistency between classes in terms of naming, for clarity.", "url": "https://github.com/apache/geode/pull/5249#discussion_r441203190", "createdAt": "2020-06-16T23:49:49Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/main/java/org/apache/geode/management/internal/functions/RestoreRedundancyFunction.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.management.internal.functions;\n+\n+import static org.apache.geode.management.runtime.RestoreRedundancyResults.Status.ERROR;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.Logger;\n+\n+import org.apache.geode.cache.control.RestoreRedundancyOperation;\n+import org.apache.geode.cache.execute.FunctionContext;\n+import org.apache.geode.internal.cache.control.SerializableRestoreRedundancyResultsImpl;\n+import org.apache.geode.internal.cache.execute.InternalFunction;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+import org.apache.geode.management.internal.operation.RestoreRedundancyResultsImpl;\n+import org.apache.geode.management.operation.RestoreRedundancyRequest;\n+\n+\n+public class RestoreRedundancyFunction implements InternalFunction<Object[]> {\n+  private static final Logger logger = LogService.getLogger();\n+\n+  public static final String ID = RestoreRedundancyFunction.class.getName();\n+\n+\n+  private static final long serialVersionUID = 1L;\n+\n+  @Override\n+  // this would return the RestoreRedundancyResults if successful,\n+  // it will return an exception to the caller if status is failure or any exception happens\n+  public void execute(FunctionContext<Object[]> context) {\n+    Object[] arguments = context.getArguments();\n+    RestoreRedundancyRequest request = (RestoreRedundancyRequest) arguments[0];\n+    boolean isStatusCommand = (boolean) arguments[1];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIwMzcyNQ==", "bodyText": "This comment is no longer correct. The argument that controls whether or not the function should restore redundancy or just check the redundancy status is now the second argument. Also, see the comment in RestoreRedundancyFunction regarding the name of this variable.", "url": "https://github.com/apache/geode/pull/5249#discussion_r441203725", "createdAt": "2020-06-16T23:51:45Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/management/internal/functions/RestoreRedundancyFunctionTest.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.management.internal.functions;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.control.RestoreRedundancyOperation;\n+import org.apache.geode.cache.execute.FunctionContext;\n+import org.apache.geode.cache.execute.ResultSender;\n+import org.apache.geode.internal.cache.control.SerializableRestoreRedundancyResultsImpl;\n+import org.apache.geode.management.operation.RestoreRedundancyRequest;\n+import org.apache.geode.management.runtime.RestoreRedundancyResults;\n+\n+public class RestoreRedundancyFunctionTest {\n+  @SuppressWarnings(\"unchecked\")\n+  private final FunctionContext<Object[]> mockContext = mock(FunctionContext.class);\n+  private final Cache mockCache = mock(Cache.class, RETURNS_DEEP_STUBS);\n+  private final RestoreRedundancyOperation mockOperation =\n+      mock(RestoreRedundancyOperation.class, RETURNS_DEEP_STUBS);\n+  private final SerializableRestoreRedundancyResultsImpl mockResults =\n+      mock(SerializableRestoreRedundancyResultsImpl.class);\n+  private final String message = \"expected message\";\n+  private RestoreRedundancyFunction function;\n+  private ResultSender resultSender;\n+  private ArgumentCaptor<SerializableRestoreRedundancyResultsImpl> argumentCaptor;\n+  private RestoreRedundancyRequest request;\n+\n+  @Before\n+  public void setUp() throws InterruptedException, ExecutionException {\n+    function = new RestoreRedundancyFunction();\n+    when(mockContext.getCache()).thenReturn(mockCache);\n+    request = new RestoreRedundancyRequest();\n+    request.setReassignPrimaries(true);\n+\n+    when(mockContext.getArguments()).thenReturn(new Object[] {request, false});\n+    when(mockCache.getResourceManager().createRestoreRedundancyOperation())\n+        .thenReturn(mockOperation);\n+    CompletableFuture<RestoreRedundancyResults> future =\n+        CompletableFuture.completedFuture(mockResults);\n+    when(mockOperation.start()).thenReturn(future);\n+    when(mockResults.getRegionOperationMessage()).thenReturn(message);\n+    // when(mockResults.getStatusMessage()).thenReturn(message);\n+    resultSender = mock(ResultSender.class);\n+    when(mockContext.getResultSender()).thenReturn(resultSender);\n+    argumentCaptor = ArgumentCaptor.forClass(SerializableRestoreRedundancyResultsImpl.class);\n+  }\n+\n+  @Test\n+  public void executeFunctionSetsFieldsOnRestoreRedundancyOperation() {\n+    String[] includeRegions = {\"includedRegion1\", \"includedRegion2\"};\n+    String[] excludeRegions = {\"excludedRegion1\", \"excludedRegion2\"};\n+    request.setExcludeRegions(Arrays.asList(excludeRegions));\n+    request.setIncludeRegions(Arrays.asList(includeRegions));\n+\n+    function.execute(mockContext);\n+\n+    verify(mockOperation).includeRegions(new HashSet<>(request.getIncludeRegions()));\n+    verify(mockOperation).excludeRegions(new HashSet<>(request.getExcludeRegions()));\n+    verify(mockOperation).shouldReassignPrimaries(request.getReassignPrimaries());\n+  }\n+\n+  @Test\n+  public void executeFunctionSetsIncludedAndExcludedRegionsOnRestoreRedundancyOperationWhenNull() {\n+    function.execute(mockContext);\n+\n+    verify(mockOperation).includeRegions(null);\n+    verify(mockOperation).excludeRegions(null);\n+    verify(mockOperation).shouldReassignPrimaries(true);\n+  }\n+\n+  @Test\n+  public void executeFunctionUsesStatusMethodWhenIsStatusCommandIsTrue() {\n+    when(mockOperation.redundancyStatus()).thenReturn(mockResults);\n+    when(mockResults.getRegionOperationStatus())\n+        .thenReturn(RestoreRedundancyResults.Status.SUCCESS);\n+    // isStatusCommand is the fourth argument passed to the function", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIwNjI1MA==", "bodyText": "This test name could be a little more descriptive, saying what the expected behaviour is given the test conditions, such as \"executeFunctionReturnsFailureResultWhenExceptionIsThrownDuringOperation\". Also, an exception is never thrown from this method, so the throws Exception can be removed from the method signature.", "url": "https://github.com/apache/geode/pull/5249#discussion_r441206250", "createdAt": "2020-06-17T00:00:15Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/management/internal/functions/RestoreRedundancyFunctionTest.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.management.internal.functions;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.control.RestoreRedundancyOperation;\n+import org.apache.geode.cache.execute.FunctionContext;\n+import org.apache.geode.cache.execute.ResultSender;\n+import org.apache.geode.internal.cache.control.SerializableRestoreRedundancyResultsImpl;\n+import org.apache.geode.management.operation.RestoreRedundancyRequest;\n+import org.apache.geode.management.runtime.RestoreRedundancyResults;\n+\n+public class RestoreRedundancyFunctionTest {\n+  @SuppressWarnings(\"unchecked\")\n+  private final FunctionContext<Object[]> mockContext = mock(FunctionContext.class);\n+  private final Cache mockCache = mock(Cache.class, RETURNS_DEEP_STUBS);\n+  private final RestoreRedundancyOperation mockOperation =\n+      mock(RestoreRedundancyOperation.class, RETURNS_DEEP_STUBS);\n+  private final SerializableRestoreRedundancyResultsImpl mockResults =\n+      mock(SerializableRestoreRedundancyResultsImpl.class);\n+  private final String message = \"expected message\";\n+  private RestoreRedundancyFunction function;\n+  private ResultSender resultSender;\n+  private ArgumentCaptor<SerializableRestoreRedundancyResultsImpl> argumentCaptor;\n+  private RestoreRedundancyRequest request;\n+\n+  @Before\n+  public void setUp() throws InterruptedException, ExecutionException {\n+    function = new RestoreRedundancyFunction();\n+    when(mockContext.getCache()).thenReturn(mockCache);\n+    request = new RestoreRedundancyRequest();\n+    request.setReassignPrimaries(true);\n+\n+    when(mockContext.getArguments()).thenReturn(new Object[] {request, false});\n+    when(mockCache.getResourceManager().createRestoreRedundancyOperation())\n+        .thenReturn(mockOperation);\n+    CompletableFuture<RestoreRedundancyResults> future =\n+        CompletableFuture.completedFuture(mockResults);\n+    when(mockOperation.start()).thenReturn(future);\n+    when(mockResults.getRegionOperationMessage()).thenReturn(message);\n+    // when(mockResults.getStatusMessage()).thenReturn(message);\n+    resultSender = mock(ResultSender.class);\n+    when(mockContext.getResultSender()).thenReturn(resultSender);\n+    argumentCaptor = ArgumentCaptor.forClass(SerializableRestoreRedundancyResultsImpl.class);\n+  }\n+\n+  @Test\n+  public void executeFunctionSetsFieldsOnRestoreRedundancyOperation() {\n+    String[] includeRegions = {\"includedRegion1\", \"includedRegion2\"};\n+    String[] excludeRegions = {\"excludedRegion1\", \"excludedRegion2\"};\n+    request.setExcludeRegions(Arrays.asList(excludeRegions));\n+    request.setIncludeRegions(Arrays.asList(includeRegions));\n+\n+    function.execute(mockContext);\n+\n+    verify(mockOperation).includeRegions(new HashSet<>(request.getIncludeRegions()));\n+    verify(mockOperation).excludeRegions(new HashSet<>(request.getExcludeRegions()));\n+    verify(mockOperation).shouldReassignPrimaries(request.getReassignPrimaries());\n+  }\n+\n+  @Test\n+  public void executeFunctionSetsIncludedAndExcludedRegionsOnRestoreRedundancyOperationWhenNull() {\n+    function.execute(mockContext);\n+\n+    verify(mockOperation).includeRegions(null);\n+    verify(mockOperation).excludeRegions(null);\n+    verify(mockOperation).shouldReassignPrimaries(true);\n+  }\n+\n+  @Test\n+  public void executeFunctionUsesStatusMethodWhenIsStatusCommandIsTrue() {\n+    when(mockOperation.redundancyStatus()).thenReturn(mockResults);\n+    when(mockResults.getRegionOperationStatus())\n+        .thenReturn(RestoreRedundancyResults.Status.SUCCESS);\n+    // isStatusCommand is the fourth argument passed to the function\n+    when(mockContext.getArguments()).thenReturn(new Object[] {request, true});\n+\n+    function.execute(mockContext);\n+\n+    verify(mockOperation, times(1)).redundancyStatus();\n+    verify(mockOperation, times(0)).start();\n+  }\n+\n+  @Test\n+  public void executeFunctionReturnsErrorWhenResultStatusIsError() {\n+    when(mockResults.getRegionOperationStatus()).thenReturn(RestoreRedundancyResults.Status.ERROR);\n+    function.execute(mockContext);\n+    verify(resultSender).lastResult(argumentCaptor.capture());\n+\n+    RestoreRedundancyResults result = argumentCaptor.getValue();\n+    assertThat(result.getSuccess()).isFalse();\n+    assertThat(result.getStatusMessage()).isEqualTo(message);\n+  }\n+\n+  @Test\n+  // The function was able to execute successfully but redundancy was not able to be established for\n+  // at least one region\n+  public void executeFunctionReturnsOkWhenResultStatusIsFailure() {\n+    when(mockResults.getRegionOperationStatus())\n+        .thenReturn(RestoreRedundancyResults.Status.FAILURE);\n+    function.execute(mockContext);\n+    verify(resultSender).lastResult(argumentCaptor.capture());\n+\n+    SerializableRestoreRedundancyResultsImpl result = argumentCaptor.getValue();\n+    verify(result).setSuccess(true);\n+    assertThat(result.getRegionOperationStatus())\n+        .isEqualTo(RestoreRedundancyResults.Status.FAILURE);\n+    assertThat(result).isSameAs(mockResults);\n+  }\n+\n+  @Test\n+  public void executeFunctionReturnsOkWhenResultStatusIsSuccess() {\n+    when(mockResults.getRegionOperationStatus())\n+        .thenReturn(RestoreRedundancyResults.Status.SUCCESS);\n+    function.execute(mockContext);\n+    verify(resultSender).lastResult(argumentCaptor.capture());\n+\n+    SerializableRestoreRedundancyResultsImpl result = argumentCaptor.getValue();\n+    verify(result).setSuccess(true);\n+    assertThat(result.getRegionOperationStatus())\n+        .isEqualTo(RestoreRedundancyResults.Status.SUCCESS);\n+    assertThat(result).isSameAs(mockResults);\n+  }\n+\n+  @Test\n+  public void whenFunctionThrowException() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMjQ0MQ==", "bodyText": "This comment does not seem entirely accurate. The method either returns null or a RestoreRedundancyResults object.", "url": "https://github.com/apache/geode/pull/5249#discussion_r441212441", "createdAt": "2020-06-17T00:22:52Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/main/java/org/apache/geode/management/internal/operation/RestoreRedundancyPerformer.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.management.internal.operation;\n+\n+import static org.apache.geode.cache.Region.SEPARATOR;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.geode.annotations.Immutable;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.ResultCollector;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.serialization.Version;\n+import org.apache.geode.management.ManagementService;\n+import org.apache.geode.management.internal.functions.RestoreRedundancyFunction;\n+import org.apache.geode.management.internal.util.ManagementUtils;\n+import org.apache.geode.management.operation.RestoreRedundancyRequest;\n+import org.apache.geode.management.runtime.RestoreRedundancyResults;\n+\n+public class RestoreRedundancyPerformer\n+    implements OperationPerformer<RestoreRedundancyRequest, RestoreRedundancyResults> {\n+  @Immutable\n+  public static final Version ADDED_VERSION = Version.GEODE_1_13_0;\n+  public static final String NO_MEMBERS_WITH_VERSION_FOR_REGION =\n+      \"No members with a version greater than or equal to %s were found for region %s\";\n+  public static final String EXCEPTION_MEMBER_MESSAGE = \"Exception occurred on member %s: %s\";\n+\n+  @Override\n+  public RestoreRedundancyResults perform(Cache cache, RestoreRedundancyRequest operation) {\n+    return perform(cache, operation, false);\n+  }\n+\n+  public RestoreRedundancyResults perform(Cache cache, RestoreRedundancyRequest operation,\n+      boolean checkStatus) {\n+    List<RebalanceOperationPerformer.MemberPRInfo> membersForEachRegion = new ArrayList<>();\n+    List<String> includedRegionsWithNoMembers = new ArrayList<>();\n+\n+    populateLists(membersForEachRegion, includedRegionsWithNoMembers, operation.getIncludeRegions(),\n+        operation.getExcludeRegions(), (InternalCache) cache);\n+\n+    for (RebalanceOperationPerformer.MemberPRInfo prInfo : membersForEachRegion) {\n+      // Filter out any members using older versions of Geode\n+      List<DistributedMember> viableMembers = filterViableMembers(prInfo);\n+\n+      if (viableMembers.size() != 0) {\n+        // Update the MemberPRInfo with the viable members\n+        prInfo.dsMemberList = viableMembers;\n+      } else {\n+        RestoreRedundancyResultsImpl results = new RestoreRedundancyResultsImpl();\n+        results.setStatusMessage(String.format(NO_MEMBERS_WITH_VERSION_FOR_REGION,\n+            ADDED_VERSION.getName(), prInfo.region));\n+        results.setSuccess(false);\n+        return results;\n+      }\n+    }\n+\n+    List<RestoreRedundancyResults> functionResults = new ArrayList<>();\n+    Object[] functionArgs = new Object[] {operation, checkStatus};\n+    List<DistributedMember> completedMembers = new ArrayList<>();\n+    for (RebalanceOperationPerformer.MemberPRInfo memberPRInfo : membersForEachRegion) {\n+      // Check to see if an earlier function execution has already targeted a member hosting this\n+      // region. If one has, there is no point sending a function for this region as it has already\n+      // had redundancy restored\n+      if (!Collections.disjoint(completedMembers, memberPRInfo.dsMemberList)) {\n+        continue;\n+      }\n+      // Try the function on the first member for this region\n+      DistributedMember targetMember = memberPRInfo.dsMemberList.get(0);\n+      RestoreRedundancyResults functionResult = executeFunctionAndGetFunctionResult(\n+          new RestoreRedundancyFunction(), functionArgs, targetMember);\n+      if (!functionResult.getSuccess()) {\n+        // Record the error and then give up\n+        RestoreRedundancyResultsImpl results = new RestoreRedundancyResultsImpl();\n+        results.setSuccess(false);\n+        String errorString =\n+            String.format(EXCEPTION_MEMBER_MESSAGE, targetMember.getName(),\n+                functionResult.getStatusMessage());\n+        results.setStatusMessage(errorString);\n+        results.setSuccess(false);\n+        return results;\n+      }\n+      functionResults.add(functionResult);\n+      completedMembers.add(targetMember);\n+    }\n+\n+    RestoreRedundancyResultsImpl finalResult = new RestoreRedundancyResultsImpl();\n+    finalResult.addIncludedRegionsWithNoMembers(includedRegionsWithNoMembers);\n+    for (RestoreRedundancyResults functionResult : functionResults) {\n+      finalResult.addRegionResults(functionResult);\n+      finalResult.setSuccess(functionResult.getSuccess());\n+      finalResult.setStatusMessage(functionResult.getStatusMessage());\n+    }\n+    return finalResult;\n+  }\n+\n+  // this returns either an Exception or RestoreRedundancyResults", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea31eacc86591ebdcf28f57cc372eb6cd0a25031"}, "originalPosition": 115}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1bbd760f1cdfe7372901666c08308f3108fe77d0", "author": {"user": {"login": "mhansonp", "name": null}}, "url": "https://github.com/apache/geode/commit/1bbd760f1cdfe7372901666c08308f3108fe77d0", "committedDate": "2020-06-17T21:52:52Z", "message": "Making requested changes."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2a78cd39a34d40db36099aaa32644aa08e5be13", "author": {"user": {"login": "mhansonp", "name": null}}, "url": "https://github.com/apache/geode/commit/e2a78cd39a34d40db36099aaa32644aa08e5be13", "committedDate": "2020-06-17T22:34:44Z", "message": "Making requested changes part 2"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyODI3MDAw", "url": "https://github.com/apache/geode/pull/5249#pullrequestreview-432827000", "createdAt": "2020-06-17T22:45:01Z", "commit": {"oid": "1bbd760f1cdfe7372901666c08308f3108fe77d0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMjo0NTowMVrOGlZ18g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMjo0NTowMVrOGlZ18g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg3MzkwNg==", "bodyText": "Incomplete comment here?", "url": "https://github.com/apache/geode/pull/5249#discussion_r441873906", "createdAt": "2020-06-17T22:45:01Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/main/java/org/apache/geode/management/internal/operation/RestoreRedundancyPerformer.java", "diffHunk": "@@ -112,14 +114,14 @@ public RestoreRedundancyResults perform(Cache cache, RestoreRedundancyRequest op\n     return finalResult;\n   }\n \n-  // this returns either an Exception or RestoreRedundancyResults\n+  // this returns RestoreRedundancyResults or null based on", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bbd760f1cdfe7372901666c08308f3108fe77d0"}, "originalPosition": 71}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7032d1f8ebad1f0032fa720863fbbba1d2fce1ba", "author": {"user": {"login": "mhansonp", "name": null}}, "url": "https://github.com/apache/geode/commit/7032d1f8ebad1f0032fa720863fbbba1d2fce1ba", "committedDate": "2020-06-17T23:00:19Z", "message": "Making requested changes part 3"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f54714487cfb98f9b68dafdeb771234da8b727d0", "author": {"user": {"login": "mhansonp", "name": null}}, "url": "https://github.com/apache/geode/commit/f54714487cfb98f9b68dafdeb771234da8b727d0", "committedDate": "2020-06-17T23:12:33Z", "message": "Changes for integration test failures\n- Changes in serialized classes necessitate changes to\nsanctioned serializable files."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyODQ3MzQy", "url": "https://github.com/apache/geode/pull/5249#pullrequestreview-432847342", "createdAt": "2020-06-17T23:41:18Z", "commit": {"oid": "f54714487cfb98f9b68dafdeb771234da8b727d0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNTA1Njky", "url": "https://github.com/apache/geode/pull/5249#pullrequestreview-433505692", "createdAt": "2020-06-18T17:37:23Z", "commit": {"oid": "f54714487cfb98f9b68dafdeb771234da8b727d0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjMwNDkz", "url": "https://github.com/apache/geode/pull/5249#pullrequestreview-433630493", "createdAt": "2020-06-18T20:40:00Z", "commit": {"oid": "f54714487cfb98f9b68dafdeb771234da8b727d0"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjUwNTY0", "url": "https://github.com/apache/geode/pull/5249#pullrequestreview-433650564", "createdAt": "2020-06-18T21:11:42Z", "commit": {"oid": "f54714487cfb98f9b68dafdeb771234da8b727d0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21483c6d17a25febf2229603d0a2eceef953a3ad", "author": {"user": {"login": "jinmeiliao", "name": "Jinmei Liao"}}, "url": "https://github.com/apache/geode/commit/21483c6d17a25febf2229603d0a2eceef953a3ad", "committedDate": "2020-06-18T21:59:02Z", "message": "add @Experimental tag\nuse SerializableRestoreRedundancyResultsImpl in the function\nrename and add tests\nGet rid of ERROR status in RestoreRedundancyStatus"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjc3NDAy", "url": "https://github.com/apache/geode/pull/5249#pullrequestreview-433677402", "createdAt": "2020-06-18T22:01:38Z", "commit": {"oid": "21483c6d17a25febf2229603d0a2eceef953a3ad"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMjowMTozOFrOGmBqfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMjowMTozOFrOGmBqfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUyNjMzNA==", "bodyText": "@DonalEvans Please take a look at this change. We get rid of the ERROR status here because we found it's never used. No one is able to set the status to that state, and the getter of it would only return either SUCCESS or FAILURE. Even on develop branch, this state seems unreachable.", "url": "https://github.com/apache/geode/pull/5249#discussion_r442526334", "createdAt": "2020-06-18T22:01:38Z", "author": {"login": "jinmeiliao"}, "path": "geode-management/src/main/java/org/apache/geode/management/runtime/RestoreRedundancyResults.java", "diffHunk": "@@ -18,28 +18,28 @@\n import java.util.List;\n import java.util.Map;\n \n+import org.apache.geode.annotations.Experimental;\n+\n /**\n  * A class to collect the results of restore redundancy operations for one or more regions and\n  * determine the success of failure of the operation.\n  */\n+@Experimental\n public interface RestoreRedundancyResults extends OperationResult {\n \n   /**\n    * {@link #SUCCESS} is defined as every included region having fully satisfied redundancy.\n    * {@link #FAILURE} is defined as at least one region that is configured to have redundant copies\n    * having fewer than its configured number of redundant copies.\n-   * {@link #ERROR} is for cases when the restore redundancy operation was unable to begin or threw\n-   * an exception.\n    */\n   enum Status {\n     SUCCESS,\n-    FAILURE,\n-    ERROR", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21483c6d17a25febf2229603d0a2eceef953a3ad"}, "originalPosition": 23}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4467, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}