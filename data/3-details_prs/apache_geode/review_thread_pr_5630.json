{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA0MTc0ODg1", "number": 5630, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wOVQyMzozMzozMlrOFYpp0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wMVQxODo1NjoyNlrOFtNsXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYxMzkyNTk1OnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/cache/configuration/CacheConfig.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wOVQyMzozMzozMlrOIixJMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yMlQxMTo1Mzo0M1rOIpUEkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzMyNzY2NA==", "bodyText": "You should create a new unit test even for inner-classes. Any class that you make Serializable should also have to unit test coverage to ensure that both seriallization and deserialization succeeds and results in a faithful replica of the original object (shamelessly copied from Effective Java 3rd Ed. Item 86). I recommend using org.apache.commons.lang3.SerializationUtils to simplify the unit testing.", "url": "https://github.com/apache/geode/pull/5630#discussion_r573327664", "createdAt": "2021-02-09T23:33:32Z", "author": {"login": "kirklund"}, "path": "geode-core/src/main/java/org/apache/geode/cache/configuration/CacheConfig.java", "diffHunk": "@@ -2612,7 +2612,8 @@ public void setOverflowDirectory(String value) {\n   @XmlAccessorType(XmlAccessType.FIELD)\n   @XmlType(name = \"\", propOrder = {\"gatewayEventFilters\", \"gatewayEventSubstitutionFilter\",\n       \"gatewayTransportFilters\"})\n-  public static class GatewaySender {\n+  public static class GatewaySender extends CacheElement {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c4ca3bebcb1eef1a2e3691b7c99a583c30d7f61"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDE5MTM3OA==", "bodyText": "Removed serialization impacts, so no need for additional tests.", "url": "https://github.com/apache/geode/pull/5630#discussion_r580191378", "createdAt": "2021-02-22T11:53:43Z", "author": {"login": "mivanac"}, "path": "geode-core/src/main/java/org/apache/geode/cache/configuration/CacheConfig.java", "diffHunk": "@@ -2612,7 +2612,8 @@ public void setOverflowDirectory(String value) {\n   @XmlAccessorType(XmlAccessType.FIELD)\n   @XmlType(name = \"\", propOrder = {\"gatewayEventFilters\", \"gatewayEventSubstitutionFilter\",\n       \"gatewayTransportFilters\"})\n-  public static class GatewaySender {\n+  public static class GatewaySender extends CacheElement {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzMyNzY2NA=="}, "originalCommit": {"oid": "6c4ca3bebcb1eef1a2e3691b7c99a583c30d7f61"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYxMzkzNjg0OnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/GatewaySenderAttributes.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wOVQyMzozNjoyMlrOIixQuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMVQxODo0NjoyOFrOIt3ThQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzMyOTU5NQ==", "bodyText": "public mutable fields are not good. I guess this class has other such fields so I'll just skip over this class. If it was me, I'd completely rewrite this class to get make all fields private.", "url": "https://github.com/apache/geode/pull/5630#discussion_r573329595", "createdAt": "2021-02-09T23:36:22Z", "author": {"login": "kirklund"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/GatewaySenderAttributes.java", "diffHunk": "@@ -88,6 +88,20 @@\n   public boolean enforceThreadsConnectSameReceiver =\n       GatewaySender.DEFAULT_ENFORCE_THREADS_CONNECT_SAME_RECEIVER;\n \n+  // Added due to \"alter gateway-sender\" command\n+\n+  public boolean modifyAlertThreshold = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c4ca3bebcb1eef1a2e3691b7c99a583c30d7f61"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDk2Mjk0OQ==", "bodyText": "+1 to rewrite. Direct access is almost always a bad idea in a multithreaded system.", "url": "https://github.com/apache/geode/pull/5630#discussion_r584962949", "createdAt": "2021-03-01T18:46:28Z", "author": {"login": "mhansonp"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/GatewaySenderAttributes.java", "diffHunk": "@@ -88,6 +88,20 @@\n   public boolean enforceThreadsConnectSameReceiver =\n       GatewaySender.DEFAULT_ENFORCE_THREADS_CONNECT_SAME_RECEIVER;\n \n+  // Added due to \"alter gateway-sender\" command\n+\n+  public boolean modifyAlertThreshold = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzMyOTU5NQ=="}, "originalCommit": {"oid": "6c4ca3bebcb1eef1a2e3691b7c99a583c30d7f61"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzgxODI2MTQ2OnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/GatewaySenderAttributes.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0zMFQxNDoxMDozN1rOJAJWyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0zMFQxNTozNDo0OVrOJAOCUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDEzMzA2NA==", "bodyText": "What is the purpose of these members and the functions to get/set them? I have not found the use in the rest of the code.", "url": "https://github.com/apache/geode/pull/5630#discussion_r604133064", "createdAt": "2021-03-30T14:10:37Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/GatewaySenderAttributes.java", "diffHunk": "@@ -31,63 +31,201 @@\n   public static final boolean DEFAULT_IS_META_QUEUE = false;\n \n \n-  public int socketBufferSize = GatewaySender.DEFAULT_SOCKET_BUFFER_SIZE;\n+  private int socketBufferSize = GatewaySender.DEFAULT_SOCKET_BUFFER_SIZE;\n \n-  public int socketReadTimeout = GatewaySender.DEFAULT_SOCKET_READ_TIMEOUT;\n+  private int socketReadTimeout = GatewaySender.DEFAULT_SOCKET_READ_TIMEOUT;\n \n-  public int maximumQueueMemory = GatewaySender.DEFAULT_MAXIMUM_QUEUE_MEMORY;\n+  private int maximumQueueMemory = GatewaySender.DEFAULT_MAXIMUM_QUEUE_MEMORY;\n \n-  public int batchSize = GatewaySender.DEFAULT_BATCH_SIZE;\n+  private int batchSize = GatewaySender.DEFAULT_BATCH_SIZE;\n \n-  public int batchTimeInterval = GatewaySender.DEFAULT_BATCH_TIME_INTERVAL;\n+  private int batchTimeInterval = GatewaySender.DEFAULT_BATCH_TIME_INTERVAL;\n \n-  public boolean isBatchConflationEnabled = GatewaySender.DEFAULT_BATCH_CONFLATION;\n+  private boolean isBatchConflationEnabled = GatewaySender.DEFAULT_BATCH_CONFLATION;\n \n-  public boolean isPersistenceEnabled = GatewaySender.DEFAULT_PERSISTENCE_ENABLED;\n+  private boolean isPersistenceEnabled = GatewaySender.DEFAULT_PERSISTENCE_ENABLED;\n \n-  public int alertThreshold = GatewaySender.DEFAULT_ALERT_THRESHOLD;\n+  private int alertThreshold = GatewaySender.DEFAULT_ALERT_THRESHOLD;\n \n-  public boolean manualStart = GatewaySender.DEFAULT_MANUAL_START;\n+  private boolean manualStart = GatewaySender.DEFAULT_MANUAL_START;\n \n-  public String diskStoreName;\n+  private String diskStoreName;\n \n-  public List<GatewayEventFilter> eventFilters = new ArrayList<GatewayEventFilter>();\n+  private List<GatewayEventFilter> eventFilters = new ArrayList<GatewayEventFilter>();\n \n-  public ArrayList<GatewayTransportFilter> transFilters = new ArrayList<GatewayTransportFilter>();\n+  private ArrayList<GatewayTransportFilter> transFilters = new ArrayList<GatewayTransportFilter>();\n \n-  public List<AsyncEventListener> listeners = new ArrayList<AsyncEventListener>();\n+  private List<AsyncEventListener> listeners = new ArrayList<AsyncEventListener>();\n \n-  public GatewayEventSubstitutionFilter eventSubstitutionFilter;\n+  private GatewayEventSubstitutionFilter eventSubstitutionFilter;\n \n-  public String id;\n+  private String id;\n \n-  public int remoteDs = GatewaySender.DEFAULT_DISTRIBUTED_SYSTEM_ID;\n+  private int remoteDs = GatewaySender.DEFAULT_DISTRIBUTED_SYSTEM_ID;\n \n-  public LocatorDiscoveryCallback locatorDiscoveryCallback;\n+  private LocatorDiscoveryCallback locatorDiscoveryCallback;\n \n-  public boolean isDiskSynchronous = GatewaySender.DEFAULT_DISK_SYNCHRONOUS;\n+  private boolean isDiskSynchronous = GatewaySender.DEFAULT_DISK_SYNCHRONOUS;\n \n-  public OrderPolicy policy;\n+  private OrderPolicy policy;\n \n-  public int dispatcherThreads = GatewaySender.DEFAULT_DISPATCHER_THREADS;\n+  private int dispatcherThreads = GatewaySender.DEFAULT_DISPATCHER_THREADS;\n \n-  public int parallelism = GatewaySender.DEFAULT_PARALLELISM_REPLICATED_REGION;\n+  private int parallelism = GatewaySender.DEFAULT_PARALLELISM_REPLICATED_REGION;\n \n-  public boolean isParallel = GatewaySender.DEFAULT_IS_PARALLEL;\n+  private boolean isParallel = GatewaySender.DEFAULT_IS_PARALLEL;\n \n-  public boolean groupTransactionEvents = GatewaySender.DEFAULT_MUST_GROUP_TRANSACTION_EVENTS;\n+  private boolean groupTransactionEvents = GatewaySender.DEFAULT_MUST_GROUP_TRANSACTION_EVENTS;\n \n-  public boolean isForInternalUse = GatewaySender.DEFAULT_IS_FOR_INTERNAL_USE;\n+  private boolean isForInternalUse = GatewaySender.DEFAULT_IS_FOR_INTERNAL_USE;\n \n-  public boolean isBucketSorted = GatewaySenderAttributes.DEFAULT_IS_BUCKETSORTED;\n+  private boolean isBucketSorted = GatewaySenderAttributes.DEFAULT_IS_BUCKETSORTED;\n \n-  public boolean isMetaQueue = GatewaySenderAttributes.DEFAULT_IS_META_QUEUE;\n+  private boolean isMetaQueue = GatewaySenderAttributes.DEFAULT_IS_META_QUEUE;\n \n-  public boolean forwardExpirationDestroy = GatewaySender.DEFAULT_FORWARD_EXPIRATION_DESTROY;\n+  private boolean forwardExpirationDestroy = GatewaySender.DEFAULT_FORWARD_EXPIRATION_DESTROY;\n \n-  public boolean enforceThreadsConnectSameReceiver =\n+  private boolean enforceThreadsConnectSameReceiver =\n       GatewaySender.DEFAULT_ENFORCE_THREADS_CONNECT_SAME_RECEIVER;\n \n+  // Added due to \"alter gateway-sender\" command\n+\n+  private boolean modifyAlertThreshold = false;\n+\n+  private boolean modifyBatchSize = false;\n+\n+  private boolean modifyBatchTimeInterval = false;\n+\n+  private boolean modifyGroupTransactionEvents = false;\n+\n+  private boolean modifyGatewayEventFilter = false;\n+\n+  private boolean modifyGatewayTransportFilter = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9430438d08a37857ec518fbb0682e99b94b72188"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDIwOTc0Ng==", "bodyText": "Thanks for comments. This is not needed, since it was part of previous solution. I will remove it.", "url": "https://github.com/apache/geode/pull/5630#discussion_r604209746", "createdAt": "2021-03-30T15:34:49Z", "author": {"login": "mivanac"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/GatewaySenderAttributes.java", "diffHunk": "@@ -31,63 +31,201 @@\n   public static final boolean DEFAULT_IS_META_QUEUE = false;\n \n \n-  public int socketBufferSize = GatewaySender.DEFAULT_SOCKET_BUFFER_SIZE;\n+  private int socketBufferSize = GatewaySender.DEFAULT_SOCKET_BUFFER_SIZE;\n \n-  public int socketReadTimeout = GatewaySender.DEFAULT_SOCKET_READ_TIMEOUT;\n+  private int socketReadTimeout = GatewaySender.DEFAULT_SOCKET_READ_TIMEOUT;\n \n-  public int maximumQueueMemory = GatewaySender.DEFAULT_MAXIMUM_QUEUE_MEMORY;\n+  private int maximumQueueMemory = GatewaySender.DEFAULT_MAXIMUM_QUEUE_MEMORY;\n \n-  public int batchSize = GatewaySender.DEFAULT_BATCH_SIZE;\n+  private int batchSize = GatewaySender.DEFAULT_BATCH_SIZE;\n \n-  public int batchTimeInterval = GatewaySender.DEFAULT_BATCH_TIME_INTERVAL;\n+  private int batchTimeInterval = GatewaySender.DEFAULT_BATCH_TIME_INTERVAL;\n \n-  public boolean isBatchConflationEnabled = GatewaySender.DEFAULT_BATCH_CONFLATION;\n+  private boolean isBatchConflationEnabled = GatewaySender.DEFAULT_BATCH_CONFLATION;\n \n-  public boolean isPersistenceEnabled = GatewaySender.DEFAULT_PERSISTENCE_ENABLED;\n+  private boolean isPersistenceEnabled = GatewaySender.DEFAULT_PERSISTENCE_ENABLED;\n \n-  public int alertThreshold = GatewaySender.DEFAULT_ALERT_THRESHOLD;\n+  private int alertThreshold = GatewaySender.DEFAULT_ALERT_THRESHOLD;\n \n-  public boolean manualStart = GatewaySender.DEFAULT_MANUAL_START;\n+  private boolean manualStart = GatewaySender.DEFAULT_MANUAL_START;\n \n-  public String diskStoreName;\n+  private String diskStoreName;\n \n-  public List<GatewayEventFilter> eventFilters = new ArrayList<GatewayEventFilter>();\n+  private List<GatewayEventFilter> eventFilters = new ArrayList<GatewayEventFilter>();\n \n-  public ArrayList<GatewayTransportFilter> transFilters = new ArrayList<GatewayTransportFilter>();\n+  private ArrayList<GatewayTransportFilter> transFilters = new ArrayList<GatewayTransportFilter>();\n \n-  public List<AsyncEventListener> listeners = new ArrayList<AsyncEventListener>();\n+  private List<AsyncEventListener> listeners = new ArrayList<AsyncEventListener>();\n \n-  public GatewayEventSubstitutionFilter eventSubstitutionFilter;\n+  private GatewayEventSubstitutionFilter eventSubstitutionFilter;\n \n-  public String id;\n+  private String id;\n \n-  public int remoteDs = GatewaySender.DEFAULT_DISTRIBUTED_SYSTEM_ID;\n+  private int remoteDs = GatewaySender.DEFAULT_DISTRIBUTED_SYSTEM_ID;\n \n-  public LocatorDiscoveryCallback locatorDiscoveryCallback;\n+  private LocatorDiscoveryCallback locatorDiscoveryCallback;\n \n-  public boolean isDiskSynchronous = GatewaySender.DEFAULT_DISK_SYNCHRONOUS;\n+  private boolean isDiskSynchronous = GatewaySender.DEFAULT_DISK_SYNCHRONOUS;\n \n-  public OrderPolicy policy;\n+  private OrderPolicy policy;\n \n-  public int dispatcherThreads = GatewaySender.DEFAULT_DISPATCHER_THREADS;\n+  private int dispatcherThreads = GatewaySender.DEFAULT_DISPATCHER_THREADS;\n \n-  public int parallelism = GatewaySender.DEFAULT_PARALLELISM_REPLICATED_REGION;\n+  private int parallelism = GatewaySender.DEFAULT_PARALLELISM_REPLICATED_REGION;\n \n-  public boolean isParallel = GatewaySender.DEFAULT_IS_PARALLEL;\n+  private boolean isParallel = GatewaySender.DEFAULT_IS_PARALLEL;\n \n-  public boolean groupTransactionEvents = GatewaySender.DEFAULT_MUST_GROUP_TRANSACTION_EVENTS;\n+  private boolean groupTransactionEvents = GatewaySender.DEFAULT_MUST_GROUP_TRANSACTION_EVENTS;\n \n-  public boolean isForInternalUse = GatewaySender.DEFAULT_IS_FOR_INTERNAL_USE;\n+  private boolean isForInternalUse = GatewaySender.DEFAULT_IS_FOR_INTERNAL_USE;\n \n-  public boolean isBucketSorted = GatewaySenderAttributes.DEFAULT_IS_BUCKETSORTED;\n+  private boolean isBucketSorted = GatewaySenderAttributes.DEFAULT_IS_BUCKETSORTED;\n \n-  public boolean isMetaQueue = GatewaySenderAttributes.DEFAULT_IS_META_QUEUE;\n+  private boolean isMetaQueue = GatewaySenderAttributes.DEFAULT_IS_META_QUEUE;\n \n-  public boolean forwardExpirationDestroy = GatewaySender.DEFAULT_FORWARD_EXPIRATION_DESTROY;\n+  private boolean forwardExpirationDestroy = GatewaySender.DEFAULT_FORWARD_EXPIRATION_DESTROY;\n \n-  public boolean enforceThreadsConnectSameReceiver =\n+  private boolean enforceThreadsConnectSameReceiver =\n       GatewaySender.DEFAULT_ENFORCE_THREADS_CONNECT_SAME_RECEIVER;\n \n+  // Added due to \"alter gateway-sender\" command\n+\n+  private boolean modifyAlertThreshold = false;\n+\n+  private boolean modifyBatchSize = false;\n+\n+  private boolean modifyBatchTimeInterval = false;\n+\n+  private boolean modifyGroupTransactionEvents = false;\n+\n+  private boolean modifyGatewayEventFilter = false;\n+\n+  private boolean modifyGatewayTransportFilter = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDEzMzA2NA=="}, "originalCommit": {"oid": "9430438d08a37857ec518fbb0682e99b94b72188"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzgxODI4MzY1OnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/cache/configuration/CacheConfig.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0zMFQxNDoxNDo0OFrOJAJkwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0zMFQxNTo1Njo0M1rOJAPIyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDEzNjY0MQ==", "bodyText": "How about something more compact? return gatewayEventFilters != null;", "url": "https://github.com/apache/geode/pull/5630#discussion_r604136641", "createdAt": "2021-03-30T14:14:48Z", "author": {"login": "albertogpz"}, "path": "geode-core/src/main/java/org/apache/geode/cache/configuration/CacheConfig.java", "diffHunk": "@@ -2689,6 +2689,12 @@ public void setOverflowDirectory(String value) {\n       return this.gatewayEventFilters;\n     }\n \n+    public boolean areGatewayEventFiltersUpdated() {\n+      if (gatewayEventFilters == null)\n+        return false;\n+      return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9430438d08a37857ec518fbb0682e99b94b72188"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDIyNzc4Nw==", "bodyText": "Thanks. Updated.", "url": "https://github.com/apache/geode/pull/5630#discussion_r604227787", "createdAt": "2021-03-30T15:56:43Z", "author": {"login": "mivanac"}, "path": "geode-core/src/main/java/org/apache/geode/cache/configuration/CacheConfig.java", "diffHunk": "@@ -2689,6 +2689,12 @@ public void setOverflowDirectory(String value) {\n       return this.gatewayEventFilters;\n     }\n \n+    public boolean areGatewayEventFiltersUpdated() {\n+      if (gatewayEventFilters == null)\n+        return false;\n+      return true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDEzNjY0MQ=="}, "originalCommit": {"oid": "9430438d08a37857ec518fbb0682e99b94b72188"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzgxODI5MTEyOnYy", "diffSide": "RIGHT", "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/AlterGatewaySenderCommand.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0zMFQxNDoxNjowNlrOJAJpcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0zMFQxNTo1Njo1OFrOJAPJoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDEzNzg0Mg==", "bodyText": "This line is redundant.", "url": "https://github.com/apache/geode/pull/5630#discussion_r604137842", "createdAt": "2021-03-30T14:16:06Z", "author": {"login": "albertogpz"}, "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/AlterGatewaySenderCommand.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.management.internal.cli.commands;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.shell.core.annotation.CliCommand;\n+import org.springframework.shell.core.annotation.CliOption;\n+\n+import org.apache.geode.cache.configuration.CacheConfig;\n+import org.apache.geode.cache.configuration.DeclarableType;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.InternalConfigurationPersistenceService;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+import org.apache.geode.management.cli.CliMetaData;\n+import org.apache.geode.management.cli.ConverterHint;\n+import org.apache.geode.management.cli.SingleGfshCommand;\n+import org.apache.geode.management.internal.cli.functions.AlterGatewaySenderFunction;\n+import org.apache.geode.management.internal.cli.functions.GatewaySenderFunctionArgs;\n+import org.apache.geode.management.internal.cli.result.model.ResultModel;\n+import org.apache.geode.management.internal.exceptions.EntityNotFoundException;\n+import org.apache.geode.management.internal.functions.CliFunctionResult;\n+import org.apache.geode.management.internal.i18n.CliStrings;\n+import org.apache.geode.management.internal.security.ResourceOperation;\n+import org.apache.geode.security.ResourcePermission;\n+\n+public class AlterGatewaySenderCommand extends SingleGfshCommand {\n+  private final AlterGatewaySenderFunction alterGatewaySenderFunction =\n+      new AlterGatewaySenderFunction();\n+  private static final Logger logger = LogService.getLogger();\n+\n+  @CliCommand(value = CliStrings.ALTER_GATEWAYSENDER,\n+      help = CliStrings.ALTER_GATEWAYSENDER__HELP)\n+  @CliMetaData(relatedTopic = CliStrings.TOPIC_GEODE_WAN)\n+  @ResourceOperation(resource = ResourcePermission.Resource.CLUSTER,\n+      operation = ResourcePermission.Operation.MANAGE, target = ResourcePermission.Target.GATEWAY)\n+\n+  public ResultModel alterGatewaySender(@CliOption(key = CliStrings.ALTER_GATEWAYSENDER__ID,\n+      mandatory = true, optionContext = ConverterHint.GATEWAY_SENDER_ID,\n+      help = CliStrings.ALTER_GATEWAYSENDER__ID__HELP) String senderId,\n+      @CliOption(key = {CliStrings.GROUP, CliStrings.GROUPS},\n+          optionContext = ConverterHint.MEMBERGROUP,\n+          help = CliStrings.ALTER_GATEWAYSENDER__GROUP__HELP) String[] onGroup,\n+      @CliOption(key = {CliStrings.MEMBER, CliStrings.MEMBERS},\n+          optionContext = ConverterHint.MEMBERIDNAME,\n+          help = CliStrings.ALTER_GATEWAYSENDER__MEMBER__HELP) String[] onMember,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__ALERTTHRESHOLD,\n+          help = CliStrings.ALTER_GATEWAYSENDER__ALERTTHRESHOLD__HELP) Integer alertThreshold,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__BATCHSIZE,\n+          help = CliStrings.ALTER_GATEWAYSENDER__BATCHSIZE__HELP) Integer batchSize,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__BATCHTIMEINTERVAL,\n+          help = CliStrings.ALTER_GATEWAYSENDER__BATCHTIMEINTERVAL__HELP) Integer batchTimeInterval,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__GATEWAYEVENTFILTER,\n+          specifiedDefaultValue = CliStrings.NULL,\n+          help = CliStrings.ALTER_GATEWAYSENDER__GATEWAYEVENTFILTER__HELP) String[] gatewayEventFilters,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__GROUPTRANSACTIONEVENTS,\n+          specifiedDefaultValue = \"true\",\n+          help = CliStrings.ALTER_GATEWAYSENDER__GROUPTRANSACTIONEVENTS__HELP) Boolean groupTransactionEvents)\n+      throws EntityNotFoundException {\n+\n+    // need not check if any running servers has this gateway-sender. A server with this\n+    // gateway-sender id\n+    // may be shutdown, but we still need to update Cluster Configuration.\n+    if (getConfigurationPersistenceService() == null) {\n+      return ResultModel.createError(\"Cluster Configuration Service is not available. \"\n+          + \"Please connect to a locator with running Cluster Configuration Service.\");\n+    }\n+\n+    final String id = senderId.trim();\n+\n+    CacheConfig.GatewaySender oldConfiguration = findGW(id);\n+\n+    if (oldConfiguration == null) {\n+      String message = String.format(\"Cannot find a gateway sender with id '%s'.\", id);\n+      throw new EntityNotFoundException(message);\n+    }\n+\n+    if (groupTransactionEvents != null && groupTransactionEvents\n+        && !oldConfiguration.mustGroupTransactionEvents()) {\n+      if (!oldConfiguration.isParallel() && (oldConfiguration.getDispatcherThreads() == null\n+          || Integer.parseInt(oldConfiguration.getDispatcherThreads()) > 1)) {\n+        return ResultModel.createError(\n+            \"alter-gateway-sender cannot be performed for --group-transaction-events attribute if serial sender and dispatcher-threads is greater than 1.\");\n+      }\n+\n+      if (oldConfiguration.isEnableBatchConflation()) {\n+        return ResultModel.createError(\n+            \"alter-gateway-sender cannot be performed for --group-transaction-events attribute if batch-conflation is enabled.\");\n+      }\n+    }\n+\n+    Set<DistributedMember> dsMembers = findMembers(onGroup, onMember);\n+\n+    if (dsMembers.isEmpty()) {\n+      return ResultModel.createError(CliStrings.NO_MEMBERS_FOUND_MESSAGE);\n+    }\n+\n+    CacheConfig.GatewaySender gwConfiguration = new CacheConfig.GatewaySender();\n+    gwConfiguration.setId(id);\n+\n+    boolean modify = false;\n+\n+    if (alertThreshold != null) {\n+      modify = true;\n+      gwConfiguration.setAlertThreshold(alertThreshold.toString());\n+    }\n+\n+    if (batchSize != null) {\n+      modify = true;\n+      gwConfiguration.setBatchSize(batchSize.toString());\n+    }\n+\n+    if (batchTimeInterval != null) {\n+      modify = true;\n+      gwConfiguration.setBatchTimeInterval(batchTimeInterval.toString());\n+    }\n+\n+    if (groupTransactionEvents != null) {\n+      modify = true;\n+      gwConfiguration.setGroupTransactionEvents(groupTransactionEvents);\n+    }\n+\n+    if (gatewayEventFilters != null) {\n+      modify = true;\n+      if (gatewayEventFilters.length == 1\n+          && gatewayEventFilters[0].equalsIgnoreCase(CliStrings.NULL)) {\n+        gwConfiguration.getGatewayEventFilters();\n+      } else {\n+        gwConfiguration.getGatewayEventFilters()\n+            .addAll((stringsToDeclarableTypes(gatewayEventFilters)));\n+      }\n+    }\n+\n+    if (!modify) {\n+      return ResultModel.createError(CliStrings.ALTER_GATEWAYSENDER__RELEVANT__OPTION__MESSAGE);\n+    }\n+\n+    GatewaySenderFunctionArgs gatewaySenderFunctionArgs =\n+        new GatewaySenderFunctionArgs(gwConfiguration);\n+\n+    List<CliFunctionResult> gatewaySenderAlterResults =\n+        executeAndGetFunctionResult(alterGatewaySenderFunction, gatewaySenderFunctionArgs,\n+            dsMembers);\n+\n+    ResultModel resultModel = ResultModel.createMemberStatusResult(gatewaySenderAlterResults);\n+\n+    resultModel.setConfigObject(gwConfiguration);\n+\n+    return resultModel;\n+  }\n+\n+  @Override\n+  public boolean updateConfigForGroup(String group, CacheConfig config, Object configObject) {\n+    List<CacheConfig.GatewaySender> gwSenders = config.getGatewaySenders();\n+    if (gwSenders.isEmpty()) {\n+      return false;\n+    }\n+\n+    boolean gwConfigsHaveBeenUpdated = false;\n+    CacheConfig.GatewaySender gwConfiguration =\n+        ((CacheConfig.GatewaySender) configObject);\n+\n+    String gwId = gwConfiguration.getId();\n+\n+    for (CacheConfig.GatewaySender sender : gwSenders) {\n+      if (gwId.equals(sender.getId())) {\n+        gwConfigsHaveBeenUpdated = true;\n+        if (StringUtils.isNotBlank(gwConfiguration.getBatchSize())) {\n+          sender.setBatchSize(gwConfiguration.getBatchSize());\n+        }\n+\n+        if (StringUtils.isNotBlank(gwConfiguration.getBatchTimeInterval())) {\n+          sender.setBatchTimeInterval(gwConfiguration.getBatchTimeInterval());\n+        }\n+\n+        if (StringUtils.isNotBlank(gwConfiguration.getAlertThreshold())) {\n+          sender.setAlertThreshold(gwConfiguration.getAlertThreshold());\n+        }\n+        if (gwConfiguration.mustGroupTransactionEvents() != null) {\n+          sender.setGroupTransactionEvents(gwConfiguration.mustGroupTransactionEvents());\n+        }\n+\n+        if (gwConfiguration.areGatewayEventFiltersUpdated()) {\n+          if (!sender.getGatewayEventFilters().isEmpty()) {\n+            sender.getGatewayEventFilters().clear();\n+          }\n+          if (!gwConfiguration.getGatewayEventFilters().isEmpty()) {\n+            sender.getGatewayEventFilters().addAll(gwConfiguration.getGatewayEventFilters());\n+          }\n+        }\n+\n+      }\n+    }\n+    return gwConfigsHaveBeenUpdated;\n+\n+  }\n+\n+  private CacheConfig.GatewaySender findGW(String gwId) {\n+    CacheConfig.GatewaySender gwsender = null;\n+    InternalConfigurationPersistenceService ccService =\n+        (InternalConfigurationPersistenceService) this.getConfigurationPersistenceService();\n+    if (ccService == null) {\n+      return null;\n+    }\n+\n+    Set<String> groups = ccService.getGroups();\n+    gwsender = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9430438d08a37857ec518fbb0682e99b94b72188"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDIyODAwMA==", "bodyText": "Thanks. Updated.", "url": "https://github.com/apache/geode/pull/5630#discussion_r604228000", "createdAt": "2021-03-30T15:56:58Z", "author": {"login": "mivanac"}, "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/AlterGatewaySenderCommand.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.management.internal.cli.commands;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.shell.core.annotation.CliCommand;\n+import org.springframework.shell.core.annotation.CliOption;\n+\n+import org.apache.geode.cache.configuration.CacheConfig;\n+import org.apache.geode.cache.configuration.DeclarableType;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.InternalConfigurationPersistenceService;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+import org.apache.geode.management.cli.CliMetaData;\n+import org.apache.geode.management.cli.ConverterHint;\n+import org.apache.geode.management.cli.SingleGfshCommand;\n+import org.apache.geode.management.internal.cli.functions.AlterGatewaySenderFunction;\n+import org.apache.geode.management.internal.cli.functions.GatewaySenderFunctionArgs;\n+import org.apache.geode.management.internal.cli.result.model.ResultModel;\n+import org.apache.geode.management.internal.exceptions.EntityNotFoundException;\n+import org.apache.geode.management.internal.functions.CliFunctionResult;\n+import org.apache.geode.management.internal.i18n.CliStrings;\n+import org.apache.geode.management.internal.security.ResourceOperation;\n+import org.apache.geode.security.ResourcePermission;\n+\n+public class AlterGatewaySenderCommand extends SingleGfshCommand {\n+  private final AlterGatewaySenderFunction alterGatewaySenderFunction =\n+      new AlterGatewaySenderFunction();\n+  private static final Logger logger = LogService.getLogger();\n+\n+  @CliCommand(value = CliStrings.ALTER_GATEWAYSENDER,\n+      help = CliStrings.ALTER_GATEWAYSENDER__HELP)\n+  @CliMetaData(relatedTopic = CliStrings.TOPIC_GEODE_WAN)\n+  @ResourceOperation(resource = ResourcePermission.Resource.CLUSTER,\n+      operation = ResourcePermission.Operation.MANAGE, target = ResourcePermission.Target.GATEWAY)\n+\n+  public ResultModel alterGatewaySender(@CliOption(key = CliStrings.ALTER_GATEWAYSENDER__ID,\n+      mandatory = true, optionContext = ConverterHint.GATEWAY_SENDER_ID,\n+      help = CliStrings.ALTER_GATEWAYSENDER__ID__HELP) String senderId,\n+      @CliOption(key = {CliStrings.GROUP, CliStrings.GROUPS},\n+          optionContext = ConverterHint.MEMBERGROUP,\n+          help = CliStrings.ALTER_GATEWAYSENDER__GROUP__HELP) String[] onGroup,\n+      @CliOption(key = {CliStrings.MEMBER, CliStrings.MEMBERS},\n+          optionContext = ConverterHint.MEMBERIDNAME,\n+          help = CliStrings.ALTER_GATEWAYSENDER__MEMBER__HELP) String[] onMember,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__ALERTTHRESHOLD,\n+          help = CliStrings.ALTER_GATEWAYSENDER__ALERTTHRESHOLD__HELP) Integer alertThreshold,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__BATCHSIZE,\n+          help = CliStrings.ALTER_GATEWAYSENDER__BATCHSIZE__HELP) Integer batchSize,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__BATCHTIMEINTERVAL,\n+          help = CliStrings.ALTER_GATEWAYSENDER__BATCHTIMEINTERVAL__HELP) Integer batchTimeInterval,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__GATEWAYEVENTFILTER,\n+          specifiedDefaultValue = CliStrings.NULL,\n+          help = CliStrings.ALTER_GATEWAYSENDER__GATEWAYEVENTFILTER__HELP) String[] gatewayEventFilters,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__GROUPTRANSACTIONEVENTS,\n+          specifiedDefaultValue = \"true\",\n+          help = CliStrings.ALTER_GATEWAYSENDER__GROUPTRANSACTIONEVENTS__HELP) Boolean groupTransactionEvents)\n+      throws EntityNotFoundException {\n+\n+    // need not check if any running servers has this gateway-sender. A server with this\n+    // gateway-sender id\n+    // may be shutdown, but we still need to update Cluster Configuration.\n+    if (getConfigurationPersistenceService() == null) {\n+      return ResultModel.createError(\"Cluster Configuration Service is not available. \"\n+          + \"Please connect to a locator with running Cluster Configuration Service.\");\n+    }\n+\n+    final String id = senderId.trim();\n+\n+    CacheConfig.GatewaySender oldConfiguration = findGW(id);\n+\n+    if (oldConfiguration == null) {\n+      String message = String.format(\"Cannot find a gateway sender with id '%s'.\", id);\n+      throw new EntityNotFoundException(message);\n+    }\n+\n+    if (groupTransactionEvents != null && groupTransactionEvents\n+        && !oldConfiguration.mustGroupTransactionEvents()) {\n+      if (!oldConfiguration.isParallel() && (oldConfiguration.getDispatcherThreads() == null\n+          || Integer.parseInt(oldConfiguration.getDispatcherThreads()) > 1)) {\n+        return ResultModel.createError(\n+            \"alter-gateway-sender cannot be performed for --group-transaction-events attribute if serial sender and dispatcher-threads is greater than 1.\");\n+      }\n+\n+      if (oldConfiguration.isEnableBatchConflation()) {\n+        return ResultModel.createError(\n+            \"alter-gateway-sender cannot be performed for --group-transaction-events attribute if batch-conflation is enabled.\");\n+      }\n+    }\n+\n+    Set<DistributedMember> dsMembers = findMembers(onGroup, onMember);\n+\n+    if (dsMembers.isEmpty()) {\n+      return ResultModel.createError(CliStrings.NO_MEMBERS_FOUND_MESSAGE);\n+    }\n+\n+    CacheConfig.GatewaySender gwConfiguration = new CacheConfig.GatewaySender();\n+    gwConfiguration.setId(id);\n+\n+    boolean modify = false;\n+\n+    if (alertThreshold != null) {\n+      modify = true;\n+      gwConfiguration.setAlertThreshold(alertThreshold.toString());\n+    }\n+\n+    if (batchSize != null) {\n+      modify = true;\n+      gwConfiguration.setBatchSize(batchSize.toString());\n+    }\n+\n+    if (batchTimeInterval != null) {\n+      modify = true;\n+      gwConfiguration.setBatchTimeInterval(batchTimeInterval.toString());\n+    }\n+\n+    if (groupTransactionEvents != null) {\n+      modify = true;\n+      gwConfiguration.setGroupTransactionEvents(groupTransactionEvents);\n+    }\n+\n+    if (gatewayEventFilters != null) {\n+      modify = true;\n+      if (gatewayEventFilters.length == 1\n+          && gatewayEventFilters[0].equalsIgnoreCase(CliStrings.NULL)) {\n+        gwConfiguration.getGatewayEventFilters();\n+      } else {\n+        gwConfiguration.getGatewayEventFilters()\n+            .addAll((stringsToDeclarableTypes(gatewayEventFilters)));\n+      }\n+    }\n+\n+    if (!modify) {\n+      return ResultModel.createError(CliStrings.ALTER_GATEWAYSENDER__RELEVANT__OPTION__MESSAGE);\n+    }\n+\n+    GatewaySenderFunctionArgs gatewaySenderFunctionArgs =\n+        new GatewaySenderFunctionArgs(gwConfiguration);\n+\n+    List<CliFunctionResult> gatewaySenderAlterResults =\n+        executeAndGetFunctionResult(alterGatewaySenderFunction, gatewaySenderFunctionArgs,\n+            dsMembers);\n+\n+    ResultModel resultModel = ResultModel.createMemberStatusResult(gatewaySenderAlterResults);\n+\n+    resultModel.setConfigObject(gwConfiguration);\n+\n+    return resultModel;\n+  }\n+\n+  @Override\n+  public boolean updateConfigForGroup(String group, CacheConfig config, Object configObject) {\n+    List<CacheConfig.GatewaySender> gwSenders = config.getGatewaySenders();\n+    if (gwSenders.isEmpty()) {\n+      return false;\n+    }\n+\n+    boolean gwConfigsHaveBeenUpdated = false;\n+    CacheConfig.GatewaySender gwConfiguration =\n+        ((CacheConfig.GatewaySender) configObject);\n+\n+    String gwId = gwConfiguration.getId();\n+\n+    for (CacheConfig.GatewaySender sender : gwSenders) {\n+      if (gwId.equals(sender.getId())) {\n+        gwConfigsHaveBeenUpdated = true;\n+        if (StringUtils.isNotBlank(gwConfiguration.getBatchSize())) {\n+          sender.setBatchSize(gwConfiguration.getBatchSize());\n+        }\n+\n+        if (StringUtils.isNotBlank(gwConfiguration.getBatchTimeInterval())) {\n+          sender.setBatchTimeInterval(gwConfiguration.getBatchTimeInterval());\n+        }\n+\n+        if (StringUtils.isNotBlank(gwConfiguration.getAlertThreshold())) {\n+          sender.setAlertThreshold(gwConfiguration.getAlertThreshold());\n+        }\n+        if (gwConfiguration.mustGroupTransactionEvents() != null) {\n+          sender.setGroupTransactionEvents(gwConfiguration.mustGroupTransactionEvents());\n+        }\n+\n+        if (gwConfiguration.areGatewayEventFiltersUpdated()) {\n+          if (!sender.getGatewayEventFilters().isEmpty()) {\n+            sender.getGatewayEventFilters().clear();\n+          }\n+          if (!gwConfiguration.getGatewayEventFilters().isEmpty()) {\n+            sender.getGatewayEventFilters().addAll(gwConfiguration.getGatewayEventFilters());\n+          }\n+        }\n+\n+      }\n+    }\n+    return gwConfigsHaveBeenUpdated;\n+\n+  }\n+\n+  private CacheConfig.GatewaySender findGW(String gwId) {\n+    CacheConfig.GatewaySender gwsender = null;\n+    InternalConfigurationPersistenceService ccService =\n+        (InternalConfigurationPersistenceService) this.getConfigurationPersistenceService();\n+    if (ccService == null) {\n+      return null;\n+    }\n+\n+    Set<String> groups = ccService.getGroups();\n+    gwsender = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDEzNzg0Mg=="}, "originalCommit": {"oid": "9430438d08a37857ec518fbb0682e99b94b72188"}, "originalPosition": 225}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzgxODUwOTk5OnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderOperationsDUnitTest.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0zMFQxNDo1MjoyNVrOJALv_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0zMFQyMDoyMTo1NlrOJAZ-2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDE3MjI4Ng==", "bodyText": "Is it necessary that the sender is paused while the parameters are changed? If it is so, it would have to be said in the documentation. Otherwise, I would remove the pause here and in the other calls where a gateway sender parameter is changed.", "url": "https://github.com/apache/geode/pull/5630#discussion_r604172286", "createdAt": "2021-03-30T14:52:25Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderOperationsDUnitTest.java", "diffHunk": "@@ -1023,6 +1238,268 @@ private void createPartitionedRegions(boolean createAccessors) {\n     vm3.invoke(() -> createPartitionedRegion(regionName, \"ln\", 1, 100, isOffHeap()));\n   }\n \n+  private void updateBatchSize(int batchsize) {\n+    vm4.invoke(() -> {\n+      AbstractGatewaySender sender = (AbstractGatewaySender) cache.getGatewaySender(\"ln\");\n+      boolean paused = false;\n+      if (sender.isRunning() && !sender.isPaused()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9430438d08a37857ec518fbb0682e99b94b72188"}, "originalPosition": 244}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDIxNTI5OQ==", "bodyText": "Yes, pausing of gw sender is implemented internally as a part of command execution (see AlterGatewaySenderFunction). Since here we are using only setter, we must ensure that gw sender is paused.", "url": "https://github.com/apache/geode/pull/5630#discussion_r604215299", "createdAt": "2021-03-30T15:41:29Z", "author": {"login": "mivanac"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderOperationsDUnitTest.java", "diffHunk": "@@ -1023,6 +1238,268 @@ private void createPartitionedRegions(boolean createAccessors) {\n     vm3.invoke(() -> createPartitionedRegion(regionName, \"ln\", 1, 100, isOffHeap()));\n   }\n \n+  private void updateBatchSize(int batchsize) {\n+    vm4.invoke(() -> {\n+      AbstractGatewaySender sender = (AbstractGatewaySender) cache.getGatewaySender(\"ln\");\n+      boolean paused = false;\n+      if (sender.isRunning() && !sender.isPaused()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDE3MjI4Ng=="}, "originalCommit": {"oid": "9430438d08a37857ec518fbb0682e99b94b72188"}, "originalPosition": 244}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDM3NzAzMQ==", "bodyText": "What would happen if the sender is not paused? I think the consequences should be documented.", "url": "https://github.com/apache/geode/pull/5630#discussion_r604377031", "createdAt": "2021-03-30T19:33:12Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderOperationsDUnitTest.java", "diffHunk": "@@ -1023,6 +1238,268 @@ private void createPartitionedRegions(boolean createAccessors) {\n     vm3.invoke(() -> createPartitionedRegion(regionName, \"ln\", 1, 100, isOffHeap()));\n   }\n \n+  private void updateBatchSize(int batchsize) {\n+    vm4.invoke(() -> {\n+      AbstractGatewaySender sender = (AbstractGatewaySender) cache.getGatewaySender(\"ln\");\n+      boolean paused = false;\n+      if (sender.isRunning() && !sender.isPaused()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDE3MjI4Ng=="}, "originalCommit": {"oid": "9430438d08a37857ec518fbb0682e99b94b72188"}, "originalPosition": 244}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDQwNTQ2Ng==", "bodyText": "We pause gw sender to prevent any interference with running processes. This was one of comments on RFC. And I am not sure that internal handling in command execution is documented for users. But if everyone agrees that this is needed, I can add.", "url": "https://github.com/apache/geode/pull/5630#discussion_r604405466", "createdAt": "2021-03-30T20:21:56Z", "author": {"login": "mivanac"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderOperationsDUnitTest.java", "diffHunk": "@@ -1023,6 +1238,268 @@ private void createPartitionedRegions(boolean createAccessors) {\n     vm3.invoke(() -> createPartitionedRegion(regionName, \"ln\", 1, 100, isOffHeap()));\n   }\n \n+  private void updateBatchSize(int batchsize) {\n+    vm4.invoke(() -> {\n+      AbstractGatewaySender sender = (AbstractGatewaySender) cache.getGatewaySender(\"ln\");\n+      boolean paused = false;\n+      if (sender.isRunning() && !sender.isPaused()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDE3MjI4Ng=="}, "originalCommit": {"oid": "9430438d08a37857ec518fbb0682e99b94b72188"}, "originalPosition": 244}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzgxODUzOTMzOnYy", "diffSide": "RIGHT", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderAlterOperationsDUnitTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0zMFQxNDo1NzoyMlrOJAMCDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0zMFQxNDo1NzoyMlrOJAMCDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDE3NjkxMA==", "bodyText": "Same comment as before on the ParallelGateway sender tests. If it is necessary that the gateway sender is paused while parameters are changed, that would have to be documented. Otherwise, I would remove the pause here and in the other parameter changes, below.", "url": "https://github.com/apache/geode/pull/5630#discussion_r604176910", "createdAt": "2021-03-30T14:57:22Z", "author": {"login": "albertogpz"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderAlterOperationsDUnitTest.java", "diffHunk": "@@ -0,0 +1,885 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static java.lang.System.currentTimeMillis;\n+import static java.util.Arrays.asList;\n+import static org.apache.geode.cache.Region.SEPARATOR;\n+import static org.apache.geode.cache.RegionShortcut.REPLICATE;\n+import static org.apache.geode.cache.wan.GatewaySender.DEFAULT_ORDER_POLICY;\n+import static org.apache.geode.cache.wan.GatewaySender.DEFAULT_SOCKET_BUFFER_SIZE;\n+import static org.apache.geode.distributed.ConfigurationProperties.DISTRIBUTED_SYSTEM_ID;\n+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;\n+import static org.apache.geode.distributed.ConfigurationProperties.REMOTE_LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.START_LOCATOR;\n+import static org.apache.geode.internal.AvailablePortHelper.getRandomAvailableTCPPort;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.IgnoredException.addIgnoredException;\n+import static org.apache.geode.test.dunit.VM.getCurrentVMNum;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.apache.geode.test.dunit.VM.toArray;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.StringTokenizer;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+import org.junit.runners.Parameterized.UseParametersRunnerFactory;\n+\n+import org.apache.geode.cache.CacheClosedException;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.DiskStore;\n+import org.apache.geode.cache.DiskStoreFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionDestroyedException;\n+import org.apache.geode.cache.RegionFactory;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.cache.wan.GatewayEventFilter;\n+import org.apache.geode.cache.wan.GatewayQueueEvent;\n+import org.apache.geode.cache.wan.GatewayReceiver;\n+import org.apache.geode.cache.wan.GatewayReceiverFactory;\n+import org.apache.geode.cache.wan.GatewaySender;\n+import org.apache.geode.cache.wan.GatewaySender.OrderPolicy;\n+import org.apache.geode.distributed.Locator;\n+import org.apache.geode.distributed.internal.InternalLocator;\n+import org.apache.geode.internal.cache.ForceReattemptException;\n+import org.apache.geode.internal.cache.RegionQueue;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySenderEventProcessor;\n+import org.apache.geode.internal.cache.wan.GatewaySenderException;\n+import org.apache.geode.internal.cache.wan.InternalGatewaySender;\n+import org.apache.geode.internal.cache.wan.InternalGatewaySenderFactory;\n+import org.apache.geode.internal.cache.wan.WANTestBase;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.IgnoredException;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.cache.CacheTestCase;\n+import org.apache.geode.test.junit.categories.WanTest;\n+import org.apache.geode.test.junit.rules.serializable.SerializableTemporaryFolder;\n+import org.apache.geode.test.junit.runners.CategoryWithParameterizedRunnerFactory;\n+\n+@Category(WanTest.class)\n+@RunWith(Parameterized.class)\n+@UseParametersRunnerFactory(CategoryWithParameterizedRunnerFactory.class)\n+@SuppressWarnings(\"serial\")\n+public class SerialGatewaySenderAlterOperationsDUnitTest extends CacheTestCase {\n+  private static final Logger logger = LogService.getLogger();\n+\n+  @Parameters(name = \"{index}: numDispatchers={0}\")\n+  public static Collection<Integer> data() {\n+    return asList(1, 3, 5);\n+  }\n+\n+  @Parameter\n+  public int numDispatchers;\n+\n+  private VM vm0;\n+  private VM vm1;\n+  private VM vm2;\n+  private VM vm3;\n+  private VM vm4;\n+  private VM vm5;\n+  private VM vm6;\n+  private VM vm7;\n+\n+  private String className;\n+\n+  @Rule\n+  public SerializableTemporaryFolder temporaryFolder = new SerializableTemporaryFolder();\n+\n+  @Before\n+  public void setUp() {\n+    addIgnoredException(\"Broken pipe\");\n+    addIgnoredException(\"Connection refused\");\n+    addIgnoredException(\"Connection reset\");\n+    addIgnoredException(\"could not get remote locator information\");\n+    addIgnoredException(\"Software caused connection abort\");\n+    addIgnoredException(\"Unexpected IOException\");\n+\n+    className = getClass().getSimpleName();\n+\n+    vm0 = getVM(0);\n+    vm1 = getVM(1);\n+    vm2 = getVM(2);\n+    vm3 = getVM(3);\n+    vm4 = getVM(4);\n+    vm5 = getVM(5);\n+    vm6 = getVM(6);\n+    vm7 = getVM(7);\n+\n+    // Stopping the gateway closed the region, which causes this exception to get logged\n+    addIgnoredException(RegionDestroyedException.class);\n+  }\n+\n+  @Test\n+  public void testStartPauseResumeSerialGatewaySenderUpdateAttributes() throws Exception {\n+    int lnPort = vm0.invoke(() -> createFirstLocatorWithDSId(1));\n+    int nyPort = vm1.invoke(() -> createFirstRemoteLocator(2, lnPort));\n+\n+    for (VM vm : toArray(vm2, vm3)) {\n+      vm.invoke(() -> {\n+        createCache(nyPort);\n+        createReceiver();\n+      });\n+    }\n+\n+    vm4.invoke(() -> createCache(lnPort));\n+    vm5.invoke(() -> createCache(lnPort));\n+    vm6.invoke(() -> createCache(lnPort));\n+    vm7.invoke(() -> createCache(lnPort));\n+\n+    vm4.invoke(() -> createSenderInVm4());\n+    vm5.invoke(() -> createSenderInVm5());\n+\n+    vm2.invoke(() -> createReplicatedRegion(className + \"_RR\", null));\n+    vm3.invoke(() -> createReplicatedRegion(className + \"_RR\", null));\n+\n+    vm4.invoke(() -> createReplicatedRegion(className + \"_RR\", \"ln\"));\n+    vm5.invoke(() -> createReplicatedRegion(className + \"_RR\", \"ln\"));\n+    vm6.invoke(() -> createReplicatedRegion(className + \"_RR\", \"ln\"));\n+    vm7.invoke(() -> createReplicatedRegion(className + \"_RR\", \"ln\"));\n+\n+    for (VM vm : toArray(vm4, vm5)) {\n+      vm.invoke(() -> startSender(\"ln\"));\n+    }\n+\n+    vm4.invoke(() -> pauseSender(\"ln\"));\n+    vm5.invoke(() -> pauseSender(\"ln\"));\n+\n+    vm4.invoke(() -> validateSenderPausedState(\"ln\"));\n+    vm5.invoke(() -> validateSenderPausedState(\"ln\"));\n+\n+    vm4.invoke(() -> doPuts(className + \"_RR\", 1000));\n+\n+    updateBatchSize(50);\n+    updateBatchTimeInterval(200);\n+\n+    vm4.invoke(() -> resumeSender(\"ln\"));\n+    vm5.invoke(() -> resumeSender(\"ln\"));\n+\n+    vm4.invoke(() -> validateSenderResumedState(\"ln\"));\n+    vm5.invoke(() -> validateSenderResumedState(\"ln\"));\n+\n+    checkBatchSize(50);\n+    checkBatchTimeInterval(200);\n+\n+    vm4.invoke(() -> validateQueueContents(\"ln\", 0));\n+    vm5.invoke(() -> validateQueueContents(\"ln\", 0));\n+\n+    vm2.invoke(() -> validateRegionSize(className + \"_RR\", 1000));\n+    vm3.invoke(() -> validateRegionSize(className + \"_RR\", 1000));\n+  }\n+\n+  @Test\n+  public void testSerialGatewaySenderUpdateAttributesWhilePutting() throws Exception {\n+    int lnPort = vm0.invoke(() -> createFirstLocatorWithDSId(1));\n+    int nyPort = vm1.invoke(() -> createFirstRemoteLocator(2, lnPort));\n+\n+    for (VM vm : toArray(vm2, vm3)) {\n+      vm.invoke(() -> {\n+        createCache(nyPort);\n+        createReceiver();\n+      });\n+    }\n+\n+    vm4.invoke(() -> createCache(lnPort));\n+    vm5.invoke(() -> createCache(lnPort));\n+    vm6.invoke(() -> createCache(lnPort));\n+    vm7.invoke(() -> createCache(lnPort));\n+\n+    vm4.invoke(() -> createSenderInVm4());\n+    vm5.invoke(() -> createSenderInVm5());\n+\n+    vm2.invoke(() -> createReplicatedRegion(className + \"_RR\", null));\n+    vm3.invoke(() -> createReplicatedRegion(className + \"_RR\", null));\n+\n+    vm4.invoke(() -> createReplicatedRegion(className + \"_RR\", \"ln\"));\n+    vm5.invoke(() -> createReplicatedRegion(className + \"_RR\", \"ln\"));\n+    vm6.invoke(() -> createReplicatedRegion(className + \"_RR\", \"ln\"));\n+    vm7.invoke(() -> createReplicatedRegion(className + \"_RR\", \"ln\"));\n+\n+    for (VM vm : toArray(vm4, vm5)) {\n+      vm.invoke(() -> startSender(\"ln\"));\n+    }\n+\n+    // Do some puts from both vm4 and vm5 while restarting a sender\n+    AsyncInvocation doPutsInVm4 =\n+        vm4.invokeAsync(() -> doPuts(className + \"_RR\", 1000));\n+\n+    updateBatchSize(50);\n+    updateBatchTimeInterval(200);\n+\n+    doPutsInVm4.await();\n+\n+    checkBatchSize(50);\n+    checkBatchTimeInterval(200);\n+\n+    vm4.invoke(() -> validateQueueContents(\"ln\", 0));\n+    vm5.invoke(() -> validateQueueContents(\"ln\", 0));\n+\n+    vm2.invoke(() -> validateRegionSize(className + \"_RR\", 1000));\n+    vm3.invoke(() -> validateRegionSize(className + \"_RR\", 1000));\n+  }\n+\n+  @Test\n+  public void testSerialGatewaySenderUpdateGatewayEventFiltersWhilePutting() throws Exception {\n+    int lnPort = vm0.invoke(() -> createFirstLocatorWithDSId(1));\n+    int nyPort = vm1.invoke(() -> createFirstRemoteLocator(2, lnPort));\n+\n+    List<GatewayEventFilter> filters = new ArrayList<>();\n+    filters.add(new MyGatewayEventFilter_AfterAck());\n+    filters.add(new PDXGatewayEventFilter());\n+\n+    for (VM vm : toArray(vm2, vm3)) {\n+      vm.invoke(() -> {\n+        createCache(nyPort);\n+        createReceiver();\n+      });\n+    }\n+\n+    vm4.invoke(() -> createCache(lnPort));\n+    vm5.invoke(() -> createCache(lnPort));\n+    vm6.invoke(() -> createCache(lnPort));\n+    vm7.invoke(() -> createCache(lnPort));\n+\n+    vm4.invoke(() -> createSenderInVm4());\n+    vm5.invoke(() -> createSenderInVm5());\n+\n+    vm2.invoke(() -> createReplicatedRegion(className + \"_RR\", null));\n+    vm3.invoke(() -> createReplicatedRegion(className + \"_RR\", null));\n+\n+    vm4.invoke(() -> createReplicatedRegion(className + \"_RR\", \"ln\"));\n+    vm5.invoke(() -> createReplicatedRegion(className + \"_RR\", \"ln\"));\n+    vm6.invoke(() -> createReplicatedRegion(className + \"_RR\", \"ln\"));\n+    vm7.invoke(() -> createReplicatedRegion(className + \"_RR\", \"ln\"));\n+\n+    for (VM vm : toArray(vm4, vm5)) {\n+      vm.invoke(() -> startSender(\"ln\"));\n+    }\n+\n+    // Do some puts from both vm4 and vm5 while restarting a sender\n+    AsyncInvocation doPutsInVm4 =\n+        vm4.invokeAsync(() -> doPuts(className + \"_RR\", 5000));\n+\n+    updateBatchSize(40);\n+    updateGatewayEventFilters(filters);\n+\n+    doPutsInVm4.await();\n+\n+    checkBatchSize(40);\n+\n+    vm4.invoke(() -> validateQueueContents(\"ln\", 0));\n+    vm5.invoke(() -> validateQueueContents(\"ln\", 0));\n+\n+    vm2.invoke(() -> validateRegionSize(className + \"_RR\", 5000));\n+    vm3.invoke(() -> validateRegionSize(className + \"_RR\", 5000));\n+  }\n+\n+  protected boolean isOffHeap() {\n+    return false;\n+  }\n+\n+  protected void createSenderInVm4() throws IOException {\n+    createSender(\"ln\", 2, true, true, numDispatchers, DEFAULT_ORDER_POLICY);\n+  }\n+\n+  protected void createSenderInVm5() throws IOException {\n+    createSender(\"ln\", 2, true, true, numDispatchers, DEFAULT_ORDER_POLICY);\n+  }\n+\n+  protected final void createSender(String id,\n+      int remoteDsId,\n+      boolean isPersistent,\n+      boolean isManualStart,\n+      int numDispatchers,\n+      OrderPolicy policy) throws IOException {\n+    try (IgnoredException ie = addIgnoredException(\"Could not connect\")) {\n+      File persistentDirectory =\n+          temporaryFolder.newFolder(id + \"_disk_\" + currentTimeMillis() + \"_\" + getCurrentVMNum());\n+      DiskStoreFactory diskStoreFactory = getCache().createDiskStoreFactory();\n+      File[] dirs = new File[] {persistentDirectory};\n+\n+      InternalGatewaySenderFactory gatewaySenderFactory =\n+          (InternalGatewaySenderFactory) getCache().createGatewaySenderFactory();\n+\n+      gatewaySenderFactory.setParallel(false);\n+      gatewaySenderFactory.setMaximumQueueMemory(100);\n+      gatewaySenderFactory.setBatchSize(10);\n+      gatewaySenderFactory.setBatchConflationEnabled(false);\n+      gatewaySenderFactory.setManualStart(isManualStart);\n+      gatewaySenderFactory.setDispatcherThreads(numDispatchers);\n+      gatewaySenderFactory.setOrderPolicy(policy);\n+      gatewaySenderFactory.setSocketBufferSize(DEFAULT_SOCKET_BUFFER_SIZE);\n+\n+      if (isPersistent) {\n+        gatewaySenderFactory.setPersistenceEnabled(true);\n+        gatewaySenderFactory.setDiskStoreName(\n+            diskStoreFactory.setDiskDirs(dirs).create(id).getName());\n+      } else {\n+        DiskStore store = diskStoreFactory.setDiskDirs(dirs).create(id);\n+        gatewaySenderFactory.setDiskStoreName(store.getName());\n+      }\n+\n+      gatewaySenderFactory.create(id, remoteDsId);\n+    }\n+  }\n+\n+  private Properties getDistributedSystemProperties(int locatorPort) {\n+    Properties props = getDistributedSystemProperties();\n+    props.setProperty(MCAST_PORT, \"0\");\n+    props.setProperty(LOCATORS, \"localhost[\" + locatorPort + \"]\");\n+    return props;\n+  }\n+\n+  private void createCache(int locatorPort) {\n+    getCache(getDistributedSystemProperties(locatorPort));\n+  }\n+\n+  private void createReplicatedRegion(String regionName, String senderIds) {\n+    try (IgnoredException ie1 = addIgnoredException(ForceReattemptException.class);\n+        IgnoredException ie2 = addIgnoredException(GatewaySenderException.class);\n+        IgnoredException ie3 = addIgnoredException(InterruptedException.class)) {\n+      RegionFactory regionFactory = getCache().createRegionFactory(REPLICATE);\n+\n+      if (senderIds != null) {\n+        StringTokenizer tokenizer = new StringTokenizer(senderIds, \",\");\n+        while (tokenizer.hasMoreTokens()) {\n+          String senderId = tokenizer.nextToken();\n+          regionFactory.addGatewaySenderId(senderId);\n+        }\n+      }\n+\n+      regionFactory.setDataPolicy(DataPolicy.REPLICATE);\n+      regionFactory.setScope(Scope.DISTRIBUTED_ACK);\n+      regionFactory.setOffHeap(isOffHeap());\n+\n+      regionFactory.create(regionName);\n+    }\n+  }\n+\n+  private void doPuts(String regionName, int count) {\n+    try (IgnoredException ie1 = addIgnoredException(GatewaySenderException.class);\n+        IgnoredException ie2 = addIgnoredException(InterruptedException.class)) {\n+      Region<Number, String> region = getCache().getRegion(SEPARATOR + regionName);\n+      for (int i = 0; i < count; i++) {\n+        region.put(i, \"Value_\" + i);\n+      }\n+    }\n+  }\n+\n+  private void doPuts(String regionName, int from, int count) {\n+    Region<Number, String> region = getCache().getRegion(SEPARATOR + regionName);\n+    for (int i = from; i < count; i++) {\n+      region.put(i, \"Value_\" + i);\n+    }\n+  }\n+\n+  private int createFirstLocatorWithDSId(int systemId) {\n+    stopOldLocator();\n+    int locatorPort = getRandomAvailableTCPPort();\n+    startLocator(systemId, locatorPort, locatorPort, -1, true);\n+    return locatorPort;\n+  }\n+\n+  private int createFirstRemoteLocator(int systemId, int remoteLocatorPort) {\n+    stopOldLocator();\n+    int locatorPort = getRandomAvailableTCPPort();\n+    startLocator(systemId, locatorPort, locatorPort, remoteLocatorPort, true);\n+    return locatorPort;\n+  }\n+\n+  private void startLocator(int systemId, int locatorPort, int startLocatorPort,\n+      int remoteLocatorPort, boolean startServerLocator) {\n+    Properties props = getDistributedSystemProperties();\n+\n+    props.setProperty(DISTRIBUTED_SYSTEM_ID, String.valueOf(systemId));\n+    props.setProperty(MCAST_PORT, \"0\");\n+    props.setProperty(LOCATORS, \"localhost[\" + locatorPort + \"]\");\n+    props.setProperty(START_LOCATOR, \"localhost[\" + startLocatorPort + \"],server=\"\n+        + startServerLocator + \",peer=true,hostname-for-clients=localhost\");\n+\n+    if (remoteLocatorPort != -1) {\n+      props.setProperty(REMOTE_LOCATORS, \"localhost[\" + remoteLocatorPort + \"]\");\n+    }\n+\n+    // Start start the locator with a LOCATOR_DM_TYPE and not a NORMAL_DM_TYPE\n+    System.setProperty(InternalLocator.FORCE_LOCATOR_DM_TYPE, \"true\");\n+    try {\n+      getSystem(props);\n+    } finally {\n+      System.clearProperty(InternalLocator.FORCE_LOCATOR_DM_TYPE);\n+    }\n+  }\n+\n+  private void stopOldLocator() {\n+    if (Locator.hasLocator()) {\n+      Locator.getLocator().stop();\n+    }\n+  }\n+\n+  private InternalGatewaySender findInternalGatewaySender(String senderId) {\n+    return (InternalGatewaySender) findGatewaySender(senderId, true);\n+  }\n+\n+  private GatewaySender findGatewaySender(String senderId) {\n+    return findGatewaySender(senderId, true);\n+  }\n+\n+  private GatewaySender findGatewaySender(String senderId, boolean assertNotNull) {\n+    Set<GatewaySender> senders = getCache().getGatewaySenders();\n+    GatewaySender sender = null;\n+    for (GatewaySender s : senders) {\n+      if (s.getId().equals(senderId)) {\n+        sender = s;\n+        break;\n+      }\n+    }\n+\n+    if (assertNotNull) {\n+      assertThat(sender).isNotNull();\n+    }\n+\n+    return sender;\n+  }\n+\n+  private void startSender(String senderId) {\n+    try (IgnoredException ie1 = addIgnoredException(\"Could not connect\");\n+        IgnoredException ie2 = addIgnoredException(ForceReattemptException.class);\n+        IgnoredException ie3 = addIgnoredException(InterruptedException.class)) {\n+      findGatewaySender(senderId).start();\n+    }\n+  }\n+\n+  private void pauseSender(String senderId) {\n+    try (IgnoredException ie1 = addIgnoredException(\"Could not connect\");\n+        IgnoredException ie2 = addIgnoredException(ForceReattemptException.class)) {\n+      InternalGatewaySender sender = findInternalGatewaySender(senderId);\n+      sender.pause();\n+      sender.getEventProcessor().waitForDispatcherToPause();\n+    }\n+  }\n+\n+  private void resumeSender(String senderId) {\n+    try (IgnoredException ie1 = addIgnoredException(\"Could not connect\");\n+        IgnoredException ie2 = addIgnoredException(ForceReattemptException.class)) {\n+      findGatewaySender(senderId).resume();\n+    }\n+  }\n+\n+  private void stopSender(String senderId) {\n+    try (IgnoredException ie1 = addIgnoredException(\"Could not connect\");\n+        IgnoredException ie2 = addIgnoredException(ForceReattemptException.class)) {\n+      InternalGatewaySender sender = findInternalGatewaySender(senderId);\n+\n+      AbstractGatewaySenderEventProcessor eventProcessor = sender.getEventProcessor();\n+\n+      sender.stop();\n+\n+      if (eventProcessor instanceof ConcurrentSerialGatewaySenderEventProcessor) {\n+        ConcurrentSerialGatewaySenderEventProcessor concurrentEventProcessor =\n+            (ConcurrentSerialGatewaySenderEventProcessor) eventProcessor;\n+        Set<RegionQueue> queues = concurrentEventProcessor.getQueues();\n+        for (RegionQueue queue : queues) {\n+          if (queue instanceof SerialGatewaySenderQueue) {\n+            assertThat(((SerialGatewaySenderQueue) queue).isRemovalThreadAlive())\n+                .isFalse();\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  private int createReceiver() throws IOException {\n+    int receiverPort = getRandomAvailableTCPPort();\n+\n+    GatewayReceiverFactory gatewayReceiverFactory = getCache().createGatewayReceiverFactory();\n+    gatewayReceiverFactory.setStartPort(receiverPort);\n+    gatewayReceiverFactory.setEndPort(receiverPort);\n+    gatewayReceiverFactory.setManualStart(true);\n+\n+    GatewayReceiver receiver = gatewayReceiverFactory.create();\n+    receiver.start();\n+\n+    return receiverPort;\n+  }\n+\n+  private void validateRegionSize(String regionName, int regionSize) {\n+    try (IgnoredException ie1 = addIgnoredException(CacheClosedException.class);\n+        IgnoredException ie2 = addIgnoredException(ForceReattemptException.class)) {\n+      Region region = getCache().getRegion(SEPARATOR + regionName);\n+\n+      await()\n+          .untilAsserted(() -> {\n+            assertThat(region.keySet()).hasSize(regionSize);\n+          });\n+    }\n+  }\n+\n+  private void validateQueueContents(String senderId, int regionSize) {\n+    try (IgnoredException ie1 = addIgnoredException(GatewaySenderException.class);\n+        IgnoredException ie2 = addIgnoredException(InterruptedException.class)) {\n+      InternalGatewaySender sender = findInternalGatewaySender(senderId);\n+\n+      if (sender.isParallel()) {\n+        RegionQueue regionQueue = sender.getQueues().toArray(new RegionQueue[1])[0];\n+        await()\n+            .untilAsserted(() -> {\n+              assertThat(regionQueue.size())\n+                  .isEqualTo(regionSize);\n+            });\n+\n+      } else {\n+        Set<RegionQueue> queues = sender.getQueues();\n+        await()\n+            .untilAsserted(() -> {\n+              int size = 0;\n+              for (RegionQueue queue : queues) {\n+                size += queue.size();\n+              }\n+              assertThat(size)\n+                  .isEqualTo(regionSize);\n+            });\n+      }\n+    }\n+  }\n+\n+  private void validateSenderPausedState(String senderId) {\n+    GatewaySender sender = findGatewaySender(senderId);\n+\n+    assertThat(sender.isPaused())\n+        .isTrue();\n+  }\n+\n+  private void validateSenderResumedState(String senderId) {\n+    GatewaySender sender = findGatewaySender(senderId);\n+\n+    assertThat(sender.isPaused())\n+        .isFalse();\n+    assertThat(sender.isRunning())\n+        .isTrue();\n+  }\n+\n+  private void updateBatchSize(int batchsize) {\n+    vm4.invoke(() -> {\n+      AbstractGatewaySender sender = (AbstractGatewaySender) cache.getGatewaySender(\"ln\");\n+      boolean paused = false;\n+      if (sender.isRunning() && !sender.isPaused()) {\n+        sender.pause();\n+        paused = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9430438d08a37857ec518fbb0682e99b94b72188"}, "originalPosition": 598}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzgyNDQyOTY0OnYy", "diffSide": "RIGHT", "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/AlterGatewaySenderCommand.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0zMVQxNzozNDowNFrOJBD3Qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0zMVQxNzozNDowNFrOJBD3Qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNTA5MTY1MQ==", "bodyText": "Can this be renamed to findGatewaySenderConfiguration or something more explicit?", "url": "https://github.com/apache/geode/pull/5630#discussion_r605091651", "createdAt": "2021-03-31T17:34:04Z", "author": {"login": "boglesby"}, "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/AlterGatewaySenderCommand.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.management.internal.cli.commands;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.shell.core.annotation.CliCommand;\n+import org.springframework.shell.core.annotation.CliOption;\n+\n+import org.apache.geode.cache.configuration.CacheConfig;\n+import org.apache.geode.cache.configuration.DeclarableType;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.InternalConfigurationPersistenceService;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+import org.apache.geode.management.cli.CliMetaData;\n+import org.apache.geode.management.cli.ConverterHint;\n+import org.apache.geode.management.cli.SingleGfshCommand;\n+import org.apache.geode.management.internal.cli.functions.AlterGatewaySenderFunction;\n+import org.apache.geode.management.internal.cli.functions.GatewaySenderFunctionArgs;\n+import org.apache.geode.management.internal.cli.result.model.ResultModel;\n+import org.apache.geode.management.internal.exceptions.EntityNotFoundException;\n+import org.apache.geode.management.internal.functions.CliFunctionResult;\n+import org.apache.geode.management.internal.i18n.CliStrings;\n+import org.apache.geode.management.internal.security.ResourceOperation;\n+import org.apache.geode.security.ResourcePermission;\n+\n+public class AlterGatewaySenderCommand extends SingleGfshCommand {\n+  private final AlterGatewaySenderFunction alterGatewaySenderFunction =\n+      new AlterGatewaySenderFunction();\n+  private static final Logger logger = LogService.getLogger();\n+\n+  @CliCommand(value = CliStrings.ALTER_GATEWAYSENDER,\n+      help = CliStrings.ALTER_GATEWAYSENDER__HELP)\n+  @CliMetaData(relatedTopic = CliStrings.TOPIC_GEODE_WAN)\n+  @ResourceOperation(resource = ResourcePermission.Resource.CLUSTER,\n+      operation = ResourcePermission.Operation.MANAGE, target = ResourcePermission.Target.GATEWAY)\n+\n+  public ResultModel alterGatewaySender(@CliOption(key = CliStrings.ALTER_GATEWAYSENDER__ID,\n+      mandatory = true, optionContext = ConverterHint.GATEWAY_SENDER_ID,\n+      help = CliStrings.ALTER_GATEWAYSENDER__ID__HELP) String senderId,\n+      @CliOption(key = {CliStrings.GROUP, CliStrings.GROUPS},\n+          optionContext = ConverterHint.MEMBERGROUP,\n+          help = CliStrings.ALTER_GATEWAYSENDER__GROUP__HELP) String[] onGroup,\n+      @CliOption(key = {CliStrings.MEMBER, CliStrings.MEMBERS},\n+          optionContext = ConverterHint.MEMBERIDNAME,\n+          help = CliStrings.ALTER_GATEWAYSENDER__MEMBER__HELP) String[] onMember,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__ALERTTHRESHOLD,\n+          help = CliStrings.ALTER_GATEWAYSENDER__ALERTTHRESHOLD__HELP) Integer alertThreshold,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__BATCHSIZE,\n+          help = CliStrings.ALTER_GATEWAYSENDER__BATCHSIZE__HELP) Integer batchSize,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__BATCHTIMEINTERVAL,\n+          help = CliStrings.ALTER_GATEWAYSENDER__BATCHTIMEINTERVAL__HELP) Integer batchTimeInterval,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__GATEWAYEVENTFILTER,\n+          specifiedDefaultValue = CliStrings.NULL,\n+          help = CliStrings.ALTER_GATEWAYSENDER__GATEWAYEVENTFILTER__HELP) String[] gatewayEventFilters,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__GROUPTRANSACTIONEVENTS,\n+          specifiedDefaultValue = \"true\",\n+          help = CliStrings.ALTER_GATEWAYSENDER__GROUPTRANSACTIONEVENTS__HELP) Boolean groupTransactionEvents)\n+      throws EntityNotFoundException {\n+\n+    // need not check if any running servers has this gateway-sender. A server with this\n+    // gateway-sender id\n+    // may be shutdown, but we still need to update Cluster Configuration.\n+    if (getConfigurationPersistenceService() == null) {\n+      return ResultModel.createError(\"Cluster Configuration Service is not available. \"\n+          + \"Please connect to a locator with running Cluster Configuration Service.\");\n+    }\n+\n+    final String id = senderId.trim();\n+\n+    CacheConfig.GatewaySender oldConfiguration = findGW(id);\n+\n+    if (oldConfiguration == null) {\n+      String message = String.format(\"Cannot find a gateway sender with id '%s'.\", id);\n+      throw new EntityNotFoundException(message);\n+    }\n+\n+    if (groupTransactionEvents != null && groupTransactionEvents\n+        && !oldConfiguration.mustGroupTransactionEvents()) {\n+      if (!oldConfiguration.isParallel() && (oldConfiguration.getDispatcherThreads() == null\n+          || Integer.parseInt(oldConfiguration.getDispatcherThreads()) > 1)) {\n+        return ResultModel.createError(\n+            \"alter-gateway-sender cannot be performed for --group-transaction-events attribute if serial sender and dispatcher-threads is greater than 1.\");\n+      }\n+\n+      if (oldConfiguration.isEnableBatchConflation()) {\n+        return ResultModel.createError(\n+            \"alter-gateway-sender cannot be performed for --group-transaction-events attribute if batch-conflation is enabled.\");\n+      }\n+    }\n+\n+    Set<DistributedMember> dsMembers = findMembers(onGroup, onMember);\n+\n+    if (dsMembers.isEmpty()) {\n+      return ResultModel.createError(CliStrings.NO_MEMBERS_FOUND_MESSAGE);\n+    }\n+\n+    CacheConfig.GatewaySender gwConfiguration = new CacheConfig.GatewaySender();\n+    gwConfiguration.setId(id);\n+\n+    boolean modify = false;\n+\n+    if (alertThreshold != null) {\n+      modify = true;\n+      gwConfiguration.setAlertThreshold(alertThreshold.toString());\n+    }\n+\n+    if (batchSize != null) {\n+      modify = true;\n+      gwConfiguration.setBatchSize(batchSize.toString());\n+    }\n+\n+    if (batchTimeInterval != null) {\n+      modify = true;\n+      gwConfiguration.setBatchTimeInterval(batchTimeInterval.toString());\n+    }\n+\n+    if (groupTransactionEvents != null) {\n+      modify = true;\n+      gwConfiguration.setGroupTransactionEvents(groupTransactionEvents);\n+    }\n+\n+    if (gatewayEventFilters != null) {\n+      modify = true;\n+      if (gatewayEventFilters.length == 1\n+          && gatewayEventFilters[0].equalsIgnoreCase(CliStrings.NULL)) {\n+        gwConfiguration.getGatewayEventFilters();\n+      } else {\n+        gwConfiguration.getGatewayEventFilters()\n+            .addAll((stringsToDeclarableTypes(gatewayEventFilters)));\n+      }\n+    }\n+\n+    if (!modify) {\n+      return ResultModel.createError(CliStrings.ALTER_GATEWAYSENDER__RELEVANT__OPTION__MESSAGE);\n+    }\n+\n+    GatewaySenderFunctionArgs gatewaySenderFunctionArgs =\n+        new GatewaySenderFunctionArgs(gwConfiguration);\n+\n+    List<CliFunctionResult> gatewaySenderAlterResults =\n+        executeAndGetFunctionResult(alterGatewaySenderFunction, gatewaySenderFunctionArgs,\n+            dsMembers);\n+\n+    ResultModel resultModel = ResultModel.createMemberStatusResult(gatewaySenderAlterResults);\n+\n+    resultModel.setConfigObject(gwConfiguration);\n+\n+    return resultModel;\n+  }\n+\n+  @Override\n+  public boolean updateConfigForGroup(String group, CacheConfig config, Object configObject) {\n+    List<CacheConfig.GatewaySender> gwSenders = config.getGatewaySenders();\n+    if (gwSenders.isEmpty()) {\n+      return false;\n+    }\n+\n+    boolean gwConfigsHaveBeenUpdated = false;\n+    CacheConfig.GatewaySender gwConfiguration =\n+        ((CacheConfig.GatewaySender) configObject);\n+\n+    String gwId = gwConfiguration.getId();\n+\n+    for (CacheConfig.GatewaySender sender : gwSenders) {\n+      if (gwId.equals(sender.getId())) {\n+        gwConfigsHaveBeenUpdated = true;\n+        if (StringUtils.isNotBlank(gwConfiguration.getBatchSize())) {\n+          sender.setBatchSize(gwConfiguration.getBatchSize());\n+        }\n+\n+        if (StringUtils.isNotBlank(gwConfiguration.getBatchTimeInterval())) {\n+          sender.setBatchTimeInterval(gwConfiguration.getBatchTimeInterval());\n+        }\n+\n+        if (StringUtils.isNotBlank(gwConfiguration.getAlertThreshold())) {\n+          sender.setAlertThreshold(gwConfiguration.getAlertThreshold());\n+        }\n+        if (gwConfiguration.mustGroupTransactionEvents() != null) {\n+          sender.setGroupTransactionEvents(gwConfiguration.mustGroupTransactionEvents());\n+        }\n+\n+        if (gwConfiguration.areGatewayEventFiltersUpdated()) {\n+          if (!sender.getGatewayEventFilters().isEmpty()) {\n+            sender.getGatewayEventFilters().clear();\n+          }\n+          if (!gwConfiguration.getGatewayEventFilters().isEmpty()) {\n+            sender.getGatewayEventFilters().addAll(gwConfiguration.getGatewayEventFilters());\n+          }\n+        }\n+\n+      }\n+    }\n+    return gwConfigsHaveBeenUpdated;\n+\n+  }\n+\n+  private CacheConfig.GatewaySender findGW(String gwId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "174e17590ffb320f23d9a5fba706e739f409fc40"}, "originalPosition": 216}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzgyNDQzMDQ2OnYy", "diffSide": "RIGHT", "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/AlterGatewaySenderCommand.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0zMVQxNzozNDoxN1rOJBD30A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0zMVQxNzozNDoxN1rOJBD30A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNTA5MTc5Mg==", "bodyText": "This cast is not necessary.", "url": "https://github.com/apache/geode/pull/5630#discussion_r605091792", "createdAt": "2021-03-31T17:34:17Z", "author": {"login": "boglesby"}, "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/AlterGatewaySenderCommand.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.management.internal.cli.commands;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.shell.core.annotation.CliCommand;\n+import org.springframework.shell.core.annotation.CliOption;\n+\n+import org.apache.geode.cache.configuration.CacheConfig;\n+import org.apache.geode.cache.configuration.DeclarableType;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.InternalConfigurationPersistenceService;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+import org.apache.geode.management.cli.CliMetaData;\n+import org.apache.geode.management.cli.ConverterHint;\n+import org.apache.geode.management.cli.SingleGfshCommand;\n+import org.apache.geode.management.internal.cli.functions.AlterGatewaySenderFunction;\n+import org.apache.geode.management.internal.cli.functions.GatewaySenderFunctionArgs;\n+import org.apache.geode.management.internal.cli.result.model.ResultModel;\n+import org.apache.geode.management.internal.exceptions.EntityNotFoundException;\n+import org.apache.geode.management.internal.functions.CliFunctionResult;\n+import org.apache.geode.management.internal.i18n.CliStrings;\n+import org.apache.geode.management.internal.security.ResourceOperation;\n+import org.apache.geode.security.ResourcePermission;\n+\n+public class AlterGatewaySenderCommand extends SingleGfshCommand {\n+  private final AlterGatewaySenderFunction alterGatewaySenderFunction =\n+      new AlterGatewaySenderFunction();\n+  private static final Logger logger = LogService.getLogger();\n+\n+  @CliCommand(value = CliStrings.ALTER_GATEWAYSENDER,\n+      help = CliStrings.ALTER_GATEWAYSENDER__HELP)\n+  @CliMetaData(relatedTopic = CliStrings.TOPIC_GEODE_WAN)\n+  @ResourceOperation(resource = ResourcePermission.Resource.CLUSTER,\n+      operation = ResourcePermission.Operation.MANAGE, target = ResourcePermission.Target.GATEWAY)\n+\n+  public ResultModel alterGatewaySender(@CliOption(key = CliStrings.ALTER_GATEWAYSENDER__ID,\n+      mandatory = true, optionContext = ConverterHint.GATEWAY_SENDER_ID,\n+      help = CliStrings.ALTER_GATEWAYSENDER__ID__HELP) String senderId,\n+      @CliOption(key = {CliStrings.GROUP, CliStrings.GROUPS},\n+          optionContext = ConverterHint.MEMBERGROUP,\n+          help = CliStrings.ALTER_GATEWAYSENDER__GROUP__HELP) String[] onGroup,\n+      @CliOption(key = {CliStrings.MEMBER, CliStrings.MEMBERS},\n+          optionContext = ConverterHint.MEMBERIDNAME,\n+          help = CliStrings.ALTER_GATEWAYSENDER__MEMBER__HELP) String[] onMember,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__ALERTTHRESHOLD,\n+          help = CliStrings.ALTER_GATEWAYSENDER__ALERTTHRESHOLD__HELP) Integer alertThreshold,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__BATCHSIZE,\n+          help = CliStrings.ALTER_GATEWAYSENDER__BATCHSIZE__HELP) Integer batchSize,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__BATCHTIMEINTERVAL,\n+          help = CliStrings.ALTER_GATEWAYSENDER__BATCHTIMEINTERVAL__HELP) Integer batchTimeInterval,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__GATEWAYEVENTFILTER,\n+          specifiedDefaultValue = CliStrings.NULL,\n+          help = CliStrings.ALTER_GATEWAYSENDER__GATEWAYEVENTFILTER__HELP) String[] gatewayEventFilters,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__GROUPTRANSACTIONEVENTS,\n+          specifiedDefaultValue = \"true\",\n+          help = CliStrings.ALTER_GATEWAYSENDER__GROUPTRANSACTIONEVENTS__HELP) Boolean groupTransactionEvents)\n+      throws EntityNotFoundException {\n+\n+    // need not check if any running servers has this gateway-sender. A server with this\n+    // gateway-sender id\n+    // may be shutdown, but we still need to update Cluster Configuration.\n+    if (getConfigurationPersistenceService() == null) {\n+      return ResultModel.createError(\"Cluster Configuration Service is not available. \"\n+          + \"Please connect to a locator with running Cluster Configuration Service.\");\n+    }\n+\n+    final String id = senderId.trim();\n+\n+    CacheConfig.GatewaySender oldConfiguration = findGW(id);\n+\n+    if (oldConfiguration == null) {\n+      String message = String.format(\"Cannot find a gateway sender with id '%s'.\", id);\n+      throw new EntityNotFoundException(message);\n+    }\n+\n+    if (groupTransactionEvents != null && groupTransactionEvents\n+        && !oldConfiguration.mustGroupTransactionEvents()) {\n+      if (!oldConfiguration.isParallel() && (oldConfiguration.getDispatcherThreads() == null\n+          || Integer.parseInt(oldConfiguration.getDispatcherThreads()) > 1)) {\n+        return ResultModel.createError(\n+            \"alter-gateway-sender cannot be performed for --group-transaction-events attribute if serial sender and dispatcher-threads is greater than 1.\");\n+      }\n+\n+      if (oldConfiguration.isEnableBatchConflation()) {\n+        return ResultModel.createError(\n+            \"alter-gateway-sender cannot be performed for --group-transaction-events attribute if batch-conflation is enabled.\");\n+      }\n+    }\n+\n+    Set<DistributedMember> dsMembers = findMembers(onGroup, onMember);\n+\n+    if (dsMembers.isEmpty()) {\n+      return ResultModel.createError(CliStrings.NO_MEMBERS_FOUND_MESSAGE);\n+    }\n+\n+    CacheConfig.GatewaySender gwConfiguration = new CacheConfig.GatewaySender();\n+    gwConfiguration.setId(id);\n+\n+    boolean modify = false;\n+\n+    if (alertThreshold != null) {\n+      modify = true;\n+      gwConfiguration.setAlertThreshold(alertThreshold.toString());\n+    }\n+\n+    if (batchSize != null) {\n+      modify = true;\n+      gwConfiguration.setBatchSize(batchSize.toString());\n+    }\n+\n+    if (batchTimeInterval != null) {\n+      modify = true;\n+      gwConfiguration.setBatchTimeInterval(batchTimeInterval.toString());\n+    }\n+\n+    if (groupTransactionEvents != null) {\n+      modify = true;\n+      gwConfiguration.setGroupTransactionEvents(groupTransactionEvents);\n+    }\n+\n+    if (gatewayEventFilters != null) {\n+      modify = true;\n+      if (gatewayEventFilters.length == 1\n+          && gatewayEventFilters[0].equalsIgnoreCase(CliStrings.NULL)) {\n+        gwConfiguration.getGatewayEventFilters();\n+      } else {\n+        gwConfiguration.getGatewayEventFilters()\n+            .addAll((stringsToDeclarableTypes(gatewayEventFilters)));\n+      }\n+    }\n+\n+    if (!modify) {\n+      return ResultModel.createError(CliStrings.ALTER_GATEWAYSENDER__RELEVANT__OPTION__MESSAGE);\n+    }\n+\n+    GatewaySenderFunctionArgs gatewaySenderFunctionArgs =\n+        new GatewaySenderFunctionArgs(gwConfiguration);\n+\n+    List<CliFunctionResult> gatewaySenderAlterResults =\n+        executeAndGetFunctionResult(alterGatewaySenderFunction, gatewaySenderFunctionArgs,\n+            dsMembers);\n+\n+    ResultModel resultModel = ResultModel.createMemberStatusResult(gatewaySenderAlterResults);\n+\n+    resultModel.setConfigObject(gwConfiguration);\n+\n+    return resultModel;\n+  }\n+\n+  @Override\n+  public boolean updateConfigForGroup(String group, CacheConfig config, Object configObject) {\n+    List<CacheConfig.GatewaySender> gwSenders = config.getGatewaySenders();\n+    if (gwSenders.isEmpty()) {\n+      return false;\n+    }\n+\n+    boolean gwConfigsHaveBeenUpdated = false;\n+    CacheConfig.GatewaySender gwConfiguration =\n+        ((CacheConfig.GatewaySender) configObject);\n+\n+    String gwId = gwConfiguration.getId();\n+\n+    for (CacheConfig.GatewaySender sender : gwSenders) {\n+      if (gwId.equals(sender.getId())) {\n+        gwConfigsHaveBeenUpdated = true;\n+        if (StringUtils.isNotBlank(gwConfiguration.getBatchSize())) {\n+          sender.setBatchSize(gwConfiguration.getBatchSize());\n+        }\n+\n+        if (StringUtils.isNotBlank(gwConfiguration.getBatchTimeInterval())) {\n+          sender.setBatchTimeInterval(gwConfiguration.getBatchTimeInterval());\n+        }\n+\n+        if (StringUtils.isNotBlank(gwConfiguration.getAlertThreshold())) {\n+          sender.setAlertThreshold(gwConfiguration.getAlertThreshold());\n+        }\n+        if (gwConfiguration.mustGroupTransactionEvents() != null) {\n+          sender.setGroupTransactionEvents(gwConfiguration.mustGroupTransactionEvents());\n+        }\n+\n+        if (gwConfiguration.areGatewayEventFiltersUpdated()) {\n+          if (!sender.getGatewayEventFilters().isEmpty()) {\n+            sender.getGatewayEventFilters().clear();\n+          }\n+          if (!gwConfiguration.getGatewayEventFilters().isEmpty()) {\n+            sender.getGatewayEventFilters().addAll(gwConfiguration.getGatewayEventFilters());\n+          }\n+        }\n+\n+      }\n+    }\n+    return gwConfigsHaveBeenUpdated;\n+\n+  }\n+\n+  private CacheConfig.GatewaySender findGW(String gwId) {\n+    CacheConfig.GatewaySender gwsender = null;\n+    InternalConfigurationPersistenceService ccService =\n+        (InternalConfigurationPersistenceService) this.getConfigurationPersistenceService();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "174e17590ffb320f23d9a5fba706e739f409fc40"}, "originalPosition": 219}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzgyOTU0NTg4OnYy", "diffSide": "RIGHT", "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/AlterGatewaySenderCommand.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wMVQxODo1NjoyNlrOJBz46w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wOFQwNjo0MjowOVrOJFIO4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNTg3ODUwNw==", "bodyText": "A new way to do this is to use ClassName[]. The gfsh parser will parse the comma separated list and any initialization json and put them into this ClassName array for you. See AlterRegionCommand for examples.", "url": "https://github.com/apache/geode/pull/5630#discussion_r605878507", "createdAt": "2021-04-01T18:56:26Z", "author": {"login": "jinmeiliao"}, "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/AlterGatewaySenderCommand.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.management.internal.cli.commands;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.shell.core.annotation.CliCommand;\n+import org.springframework.shell.core.annotation.CliOption;\n+\n+import org.apache.geode.cache.configuration.CacheConfig;\n+import org.apache.geode.cache.configuration.DeclarableType;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.InternalConfigurationPersistenceService;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+import org.apache.geode.management.cli.CliMetaData;\n+import org.apache.geode.management.cli.ConverterHint;\n+import org.apache.geode.management.cli.SingleGfshCommand;\n+import org.apache.geode.management.internal.cli.functions.AlterGatewaySenderFunction;\n+import org.apache.geode.management.internal.cli.functions.GatewaySenderFunctionArgs;\n+import org.apache.geode.management.internal.cli.result.model.ResultModel;\n+import org.apache.geode.management.internal.exceptions.EntityNotFoundException;\n+import org.apache.geode.management.internal.functions.CliFunctionResult;\n+import org.apache.geode.management.internal.i18n.CliStrings;\n+import org.apache.geode.management.internal.security.ResourceOperation;\n+import org.apache.geode.security.ResourcePermission;\n+\n+public class AlterGatewaySenderCommand extends SingleGfshCommand {\n+  private final AlterGatewaySenderFunction alterGatewaySenderFunction =\n+      new AlterGatewaySenderFunction();\n+  private static final Logger logger = LogService.getLogger();\n+\n+  @CliCommand(value = CliStrings.ALTER_GATEWAYSENDER,\n+      help = CliStrings.ALTER_GATEWAYSENDER__HELP)\n+  @CliMetaData(relatedTopic = CliStrings.TOPIC_GEODE_WAN)\n+  @ResourceOperation(resource = ResourcePermission.Resource.CLUSTER,\n+      operation = ResourcePermission.Operation.MANAGE, target = ResourcePermission.Target.GATEWAY)\n+\n+  public ResultModel alterGatewaySender(@CliOption(key = CliStrings.ALTER_GATEWAYSENDER__ID,\n+      mandatory = true, optionContext = ConverterHint.GATEWAY_SENDER_ID,\n+      help = CliStrings.ALTER_GATEWAYSENDER__ID__HELP) String senderId,\n+      @CliOption(key = {CliStrings.GROUP, CliStrings.GROUPS},\n+          optionContext = ConverterHint.MEMBERGROUP,\n+          help = CliStrings.ALTER_GATEWAYSENDER__GROUP__HELP) String[] onGroup,\n+      @CliOption(key = {CliStrings.MEMBER, CliStrings.MEMBERS},\n+          optionContext = ConverterHint.MEMBERIDNAME,\n+          help = CliStrings.ALTER_GATEWAYSENDER__MEMBER__HELP) String[] onMember,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__ALERTTHRESHOLD,\n+          help = CliStrings.ALTER_GATEWAYSENDER__ALERTTHRESHOLD__HELP) Integer alertThreshold,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__BATCHSIZE,\n+          help = CliStrings.ALTER_GATEWAYSENDER__BATCHSIZE__HELP) Integer batchSize,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__BATCHTIMEINTERVAL,\n+          help = CliStrings.ALTER_GATEWAYSENDER__BATCHTIMEINTERVAL__HELP) Integer batchTimeInterval,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__GATEWAYEVENTFILTER,\n+          specifiedDefaultValue = CliStrings.NULL,\n+          help = CliStrings.ALTER_GATEWAYSENDER__GATEWAYEVENTFILTER__HELP) String[] gatewayEventFilters,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "174e17590ffb320f23d9a5fba706e739f409fc40"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTM1NzUzOA==", "bodyText": "Thanks for comments. Updated.", "url": "https://github.com/apache/geode/pull/5630#discussion_r609357538", "createdAt": "2021-04-08T06:42:09Z", "author": {"login": "mivanac"}, "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/AlterGatewaySenderCommand.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.management.internal.cli.commands;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.shell.core.annotation.CliCommand;\n+import org.springframework.shell.core.annotation.CliOption;\n+\n+import org.apache.geode.cache.configuration.CacheConfig;\n+import org.apache.geode.cache.configuration.DeclarableType;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.InternalConfigurationPersistenceService;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+import org.apache.geode.management.cli.CliMetaData;\n+import org.apache.geode.management.cli.ConverterHint;\n+import org.apache.geode.management.cli.SingleGfshCommand;\n+import org.apache.geode.management.internal.cli.functions.AlterGatewaySenderFunction;\n+import org.apache.geode.management.internal.cli.functions.GatewaySenderFunctionArgs;\n+import org.apache.geode.management.internal.cli.result.model.ResultModel;\n+import org.apache.geode.management.internal.exceptions.EntityNotFoundException;\n+import org.apache.geode.management.internal.functions.CliFunctionResult;\n+import org.apache.geode.management.internal.i18n.CliStrings;\n+import org.apache.geode.management.internal.security.ResourceOperation;\n+import org.apache.geode.security.ResourcePermission;\n+\n+public class AlterGatewaySenderCommand extends SingleGfshCommand {\n+  private final AlterGatewaySenderFunction alterGatewaySenderFunction =\n+      new AlterGatewaySenderFunction();\n+  private static final Logger logger = LogService.getLogger();\n+\n+  @CliCommand(value = CliStrings.ALTER_GATEWAYSENDER,\n+      help = CliStrings.ALTER_GATEWAYSENDER__HELP)\n+  @CliMetaData(relatedTopic = CliStrings.TOPIC_GEODE_WAN)\n+  @ResourceOperation(resource = ResourcePermission.Resource.CLUSTER,\n+      operation = ResourcePermission.Operation.MANAGE, target = ResourcePermission.Target.GATEWAY)\n+\n+  public ResultModel alterGatewaySender(@CliOption(key = CliStrings.ALTER_GATEWAYSENDER__ID,\n+      mandatory = true, optionContext = ConverterHint.GATEWAY_SENDER_ID,\n+      help = CliStrings.ALTER_GATEWAYSENDER__ID__HELP) String senderId,\n+      @CliOption(key = {CliStrings.GROUP, CliStrings.GROUPS},\n+          optionContext = ConverterHint.MEMBERGROUP,\n+          help = CliStrings.ALTER_GATEWAYSENDER__GROUP__HELP) String[] onGroup,\n+      @CliOption(key = {CliStrings.MEMBER, CliStrings.MEMBERS},\n+          optionContext = ConverterHint.MEMBERIDNAME,\n+          help = CliStrings.ALTER_GATEWAYSENDER__MEMBER__HELP) String[] onMember,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__ALERTTHRESHOLD,\n+          help = CliStrings.ALTER_GATEWAYSENDER__ALERTTHRESHOLD__HELP) Integer alertThreshold,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__BATCHSIZE,\n+          help = CliStrings.ALTER_GATEWAYSENDER__BATCHSIZE__HELP) Integer batchSize,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__BATCHTIMEINTERVAL,\n+          help = CliStrings.ALTER_GATEWAYSENDER__BATCHTIMEINTERVAL__HELP) Integer batchTimeInterval,\n+      @CliOption(key = CliStrings.ALTER_GATEWAYSENDER__GATEWAYEVENTFILTER,\n+          specifiedDefaultValue = CliStrings.NULL,\n+          help = CliStrings.ALTER_GATEWAYSENDER__GATEWAYEVENTFILTER__HELP) String[] gatewayEventFilters,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNTg3ODUwNw=="}, "originalCommit": {"oid": "174e17590ffb320f23d9a5fba706e739f409fc40"}, "originalPosition": 73}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4714, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}