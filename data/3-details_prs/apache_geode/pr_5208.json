{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI3NDAwMDE2", "number": 5208, "title": "GEODE-8173: Add unit test (coverage) for PartitionedRegionClear class.", "bodyText": "Thank you for submitting a contribution to Apache Geode.\nIn order to streamline the review of the contribution we ask you\nto ensure the following steps have been taken:\nFor all changes:\n\n\n[Y] Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?\n\n\n[Y] Has your PR been rebased against the latest commit within the target branch (typically develop)?\n\n\n[Y] Is your initial contribution a single, squashed commit?\n\n\n[Y] Does gradlew build run cleanly?\n\n\n[Y] Have you written or updated unit tests to verify your changes?\n\n\n[ NA] If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under ASF 2.0?\n\n\nNote:\nPlease ensure that once the PR is submitted, check Concourse for build issues and\nsubmit an update to your PR as soon as possible. If you need help, please send an\nemail to dev@geode.apache.org.", "createdAt": "2020-06-03T19:15:35Z", "url": "https://github.com/apache/geode/pull/5208", "merged": true, "mergeCommit": {"oid": "be392dbd193b2af2858116b32e4f3001c448a605"}, "closed": true, "closedAt": "2020-06-08T17:23:50Z", "author": {"login": "agingade"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcnuW2NgH2gAyNDI3NDAwMDE2OjQ2ZTNjOTNmMmQ0YzYyZDI0YjFmYWUwMzM5ZWZlNmY1NTQ2OTUyZDE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcpTwDyAFqTQyNjQ1MTg2NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "46e3c93f2d4c62d24b1fae0339efe6f5546952d1", "author": {"user": null}, "url": "https://github.com/apache/geode/commit/46e3c93f2d4c62d24b1fae0339efe6f5546952d1", "committedDate": "2020-06-03T19:09:43Z", "message": "GEODE-8173: Add unit test (coverage) for PartitionedRegionClear class."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzODYxNDYz", "url": "https://github.com/apache/geode/pull/5208#pullrequestreview-423861463", "createdAt": "2020-06-03T19:27:05Z", "commit": {"oid": "46e3c93f2d4c62d24b1fae0339efe6f5546952d1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzOTA2ODI0", "url": "https://github.com/apache/geode/pull/5208#pullrequestreview-423906824", "createdAt": "2020-06-03T20:31:33Z", "commit": {"oid": "46e3c93f2d4c62d24b1fae0339efe6f5546952d1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1cb8de5194b1ed5fe03b13c924936e57d2cdc2bf", "author": {"user": null}, "url": "https://github.com/apache/geode/commit/1cb8de5194b1ed5fe03b13c924936e57d2cdc2bf", "committedDate": "2020-06-03T21:52:25Z", "message": "Fixing test issue in PR pipeline.\nThe afterDestroy() could be triggered more than once in a server.\nAnother test case in this test verifies similarlly."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0Nzk5OTU4", "url": "https://github.com/apache/geode/pull/5208#pullrequestreview-424799958", "createdAt": "2020-06-04T20:23:23Z", "commit": {"oid": "1cb8de5194b1ed5fe03b13c924936e57d2cdc2bf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDoyMzoyNFrOGfWeYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDoyMzoyNFrOGfWeYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyNzI2Ng==", "bodyText": "Probably should use proper types for the Regions and Sets etc rather than raw types.", "url": "https://github.com/apache/geode/pull/5208#discussion_r435527266", "createdAt": "2020-06-04T20:23:24Z", "author": {"login": "mhansonp"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/PartitionedRegionClearTest.java", "diffHunk": "@@ -0,0 +1,594 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.catchThrowable;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.PartitionedRegionPartialClearException;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.distributed.internal.DMStats;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.MembershipListener;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.partitioned.RegionAdvisor;\n+import org.apache.geode.internal.cache.versions.RegionVersionVector;\n+\n+public class PartitionedRegionClearTest {\n+\n+  int numBuckets = 2;\n+  PartitionedRegionClear partitionedRegionClear;\n+  DistributionManager distributionManager;\n+  PartitionedRegion partitionedRegion;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cb8de5194b1ed5fe03b13c924936e57d2cdc2bf"}, "originalPosition": 53}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7bf63222b8acb0c12e38469a7c05819d2b8e2fd0", "author": {"user": null}, "url": "https://github.com/apache/geode/commit/7bf63222b8acb0c12e38469a7c05819d2b8e2fd0", "committedDate": "2020-06-04T23:26:07Z", "message": "Add reveiew comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NTA3MjI1", "url": "https://github.com/apache/geode/pull/5208#pullrequestreview-425507225", "createdAt": "2020-06-05T17:55:44Z", "commit": {"oid": "7bf63222b8acb0c12e38469a7c05819d2b8e2fd0"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNzo1NTo0NFrOGf38pQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNzo1OTowN1rOGf4EDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3NTY4NQ==", "bodyText": "I hate the idea of adding methods like this to Regions. It has nothing to do with Region. Maybe Transaction or TransactionManager would be a better place for this method.", "url": "https://github.com/apache/geode/pull/5208#discussion_r436075685", "createdAt": "2020-06-05T17:55:44Z", "author": {"login": "kirklund"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegion.java", "diffHunk": "@@ -10269,4 +10269,8 @@ boolean hasAnyClientsInterested() {\n     return (getRegionAdvisor().hasPRServerWithInterest()\n         || getRegionAdvisor().hasPRServerWithCQs());\n   }\n+\n+  boolean isTransactionDistributed() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bf63222b8acb0c12e38469a7c05819d2b8e2fd0"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3NjM1NA==", "bodyText": "We should be declaring vars as the interface instead of the impl:\nSet<BucketRegion> bucketRegions = new HashSet<>();", "url": "https://github.com/apache/geode/pull/5208#discussion_r436076354", "createdAt": "2020-06-05T17:56:57Z", "author": {"login": "kirklund"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/PartitionedRegionClearTest.java", "diffHunk": "@@ -0,0 +1,598 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.catchThrowable;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.PartitionedRegionPartialClearException;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.distributed.internal.DMStats;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.MembershipListener;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.partitioned.RegionAdvisor;\n+import org.apache.geode.internal.cache.versions.RegionVersionVector;\n+\n+public class PartitionedRegionClearTest {\n+\n+\n+  private PartitionedRegionClear partitionedRegionClear;\n+  private DistributionManager distributionManager;\n+  private PartitionedRegion partitionedRegion;\n+\n+  @Before\n+  public void setUp() {\n+\n+    partitionedRegion = mock(PartitionedRegion.class);\n+    distributionManager = mock(DistributionManager.class);\n+\n+    when(partitionedRegion.getDistributionManager()).thenReturn(distributionManager);\n+    when(partitionedRegion.getName()).thenReturn(\"prRegion\");\n+\n+    partitionedRegionClear = new PartitionedRegionClear(partitionedRegion);\n+  }\n+\n+  private Set<BucketRegion> setupBucketRegions(\n+      PartitionedRegionDataStore partitionedRegionDataStore,\n+      BucketAdvisor bucketAdvisor) {\n+    final int numBuckets = 2;\n+    HashSet<BucketRegion> bucketRegions = new HashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bf63222b8acb0c12e38469a7c05819d2b8e2fd0"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3NzU4Mw==", "bodyText": "You typically want to avoid if-else blocks like this, and separate it into two different tests. One for PR and one for Replicate.\nThe test class is ReplicateCacheListenerDistributedTest. I can't find any PartitionedRegions being created in this test. Does this belong in PRCacheListenerDistributedTest instead?", "url": "https://github.com/apache/geode/pull/5208#discussion_r436077583", "createdAt": "2020-06-05T17:59:07Z", "author": {"login": "kirklund"}, "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/ReplicateCacheListenerDistributedTest.java", "diffHunk": "@@ -179,7 +180,13 @@ public void afterRegionDestroyIsInvokedInEveryMember() {\n \n     region.destroyRegion();\n \n-    assertThat(sharedCountersRule.getTotal(REGION_DESTROY)).isEqualTo(expectedRegionDestroys());\n+    if (region instanceof PartitionedRegion) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bf63222b8acb0c12e38469a7c05819d2b8e2fd0"}, "originalPosition": 13}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NTM3OTM1", "url": "https://github.com/apache/geode/pull/5208#pullrequestreview-425537935", "createdAt": "2020-06-05T18:38:12Z", "commit": {"oid": "7bf63222b8acb0c12e38469a7c05819d2b8e2fd0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NjgzOTMy", "url": "https://github.com/apache/geode/pull/5208#pullrequestreview-425683932", "createdAt": "2020-06-05T23:56:33Z", "commit": {"oid": "7bf63222b8acb0c12e38469a7c05819d2b8e2fd0"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMzo1NjozNFrOGgAK5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMzo1OToyN1rOGgAMkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxMDQwNQ==", "bodyText": "I think this should be releaseClearLockLocal() instead?", "url": "https://github.com/apache/geode/pull/5208#discussion_r436210405", "createdAt": "2020-06-05T23:56:34Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/PartitionedRegionClearTest.java", "diffHunk": "@@ -0,0 +1,598 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.catchThrowable;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.PartitionedRegionPartialClearException;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.distributed.internal.DMStats;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.MembershipListener;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.partitioned.RegionAdvisor;\n+import org.apache.geode.internal.cache.versions.RegionVersionVector;\n+\n+public class PartitionedRegionClearTest {\n+\n+\n+  private PartitionedRegionClear partitionedRegionClear;\n+  private DistributionManager distributionManager;\n+  private PartitionedRegion partitionedRegion;\n+\n+  @Before\n+  public void setUp() {\n+\n+    partitionedRegion = mock(PartitionedRegion.class);\n+    distributionManager = mock(DistributionManager.class);\n+\n+    when(partitionedRegion.getDistributionManager()).thenReturn(distributionManager);\n+    when(partitionedRegion.getName()).thenReturn(\"prRegion\");\n+\n+    partitionedRegionClear = new PartitionedRegionClear(partitionedRegion);\n+  }\n+\n+  private Set<BucketRegion> setupBucketRegions(\n+      PartitionedRegionDataStore partitionedRegionDataStore,\n+      BucketAdvisor bucketAdvisor) {\n+    final int numBuckets = 2;\n+    HashSet<BucketRegion> bucketRegions = new HashSet<>();\n+    for (int i = 0; i < numBuckets; i++) {\n+      BucketRegion bucketRegion = mock(BucketRegion.class);\n+      when(bucketRegion.getBucketAdvisor()).thenReturn(bucketAdvisor);\n+      when(bucketRegion.size()).thenReturn(1);\n+      when(bucketRegion.getId()).thenReturn(i);\n+      bucketRegions.add(bucketRegion);\n+    }\n+\n+    when(partitionedRegionDataStore.getAllLocalBucketRegions()).thenReturn(bucketRegions);\n+    when(partitionedRegionDataStore.getAllLocalPrimaryBucketRegions()).thenReturn(bucketRegions);\n+\n+    return bucketRegions;\n+  }\n+\n+  @Test\n+  public void isLockedForListenerAndClientNotificationReturnsTrueWhenLocked() {\n+    InternalDistributedMember internalDistributedMember = mock(InternalDistributedMember.class);\n+    when(distributionManager.isCurrentMember(internalDistributedMember)).thenReturn(true);\n+    partitionedRegionClear.obtainClearLockLocal(internalDistributedMember);\n+\n+    assertThat(partitionedRegionClear.isLockedForListenerAndClientNotification()).isTrue();\n+  }\n+\n+  @Test\n+  public void isLockedForListenerAndClientNotificationReturnsFalseWhenMemberNotInTheSystemRequestsLock() {\n+    InternalDistributedMember internalDistributedMember = mock(InternalDistributedMember.class);\n+    when(distributionManager.isCurrentMember(internalDistributedMember)).thenReturn(false);\n+\n+    assertThat(partitionedRegionClear.isLockedForListenerAndClientNotification()).isFalse();\n+  }\n+\n+  @Test\n+  public void acquireDistributedClearLockGetsDistributedLock() {\n+    DistributedLockService distributedLockService = mock(DistributedLockService.class);\n+    String lockName = PartitionedRegionClear.CLEAR_OPERATION + partitionedRegion.getName();\n+    when(partitionedRegion.getPartitionedRegionLockService()).thenReturn(distributedLockService);\n+\n+    partitionedRegionClear.acquireDistributedClearLock(lockName);\n+\n+    verify(distributedLockService, times(1)).lock(lockName, -1, -1);\n+  }\n+\n+  @Test\n+  public void releaseDistributedClearLockReleasesDistributedLock() {\n+    DistributedLockService distributedLockService = mock(DistributedLockService.class);\n+    String lockName = PartitionedRegionClear.CLEAR_OPERATION + partitionedRegion.getName();\n+    when(partitionedRegion.getPartitionedRegionLockService()).thenReturn(distributedLockService);\n+\n+    partitionedRegionClear.releaseDistributedClearLock(lockName);\n+\n+    verify(distributedLockService, times(1)).unlock(lockName);\n+  }\n+\n+  @Test\n+  public void obtainLockForClearGetsLocalLockAndSendsMessageForRemote() throws Exception {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(regionEvent.clone()).thenReturn(mock(RegionEventImpl.class));\n+    Region<String, PartitionRegionConfig> region = mock(Region.class);\n+    when(partitionedRegion.getPRRoot()).thenReturn(region);\n+    PartitionedRegionClear spyPartitionedRegionClear = spy(partitionedRegionClear);\n+    doReturn(Collections.EMPTY_LIST).when(spyPartitionedRegionClear)\n+        .attemptToSendPartitionedRegionClearMessage(regionEvent,\n+            PartitionedRegionClearMessage.OperationType.OP_LOCK_FOR_PR_CLEAR);\n+    InternalDistributedMember internalDistributedMember = mock(InternalDistributedMember.class);\n+    when(distributionManager.getId()).thenReturn(internalDistributedMember);\n+\n+    spyPartitionedRegionClear.obtainLockForClear(regionEvent);\n+\n+    verify(spyPartitionedRegionClear, times(1)).obtainClearLockLocal(internalDistributedMember);\n+    verify(spyPartitionedRegionClear, times(1)).sendPartitionedRegionClearMessage(regionEvent,\n+        PartitionedRegionClearMessage.OperationType.OP_LOCK_FOR_PR_CLEAR);\n+  }\n+\n+  @Test\n+  public void releaseLockForClearReleasesLocalLockAndSendsMessageForRemote() throws Exception {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(regionEvent.clone()).thenReturn(mock(RegionEventImpl.class));\n+    Region<String, PartitionRegionConfig> region = mock(Region.class);\n+    when(partitionedRegion.getPRRoot()).thenReturn(region);\n+    PartitionedRegionClear spyPartitionedRegionClear = spy(partitionedRegionClear);\n+    doReturn(Collections.EMPTY_LIST).when(spyPartitionedRegionClear)\n+        .attemptToSendPartitionedRegionClearMessage(regionEvent,\n+            PartitionedRegionClearMessage.OperationType.OP_UNLOCK_FOR_PR_CLEAR);\n+    InternalDistributedMember internalDistributedMember = mock(InternalDistributedMember.class);\n+    when(distributionManager.getId()).thenReturn(internalDistributedMember);\n+\n+    spyPartitionedRegionClear.releaseLockForClear(regionEvent);\n+\n+    verify(spyPartitionedRegionClear, times(1)).releaseClearLockLocal();\n+    verify(spyPartitionedRegionClear, times(1)).sendPartitionedRegionClearMessage(regionEvent,\n+        PartitionedRegionClearMessage.OperationType.OP_UNLOCK_FOR_PR_CLEAR);\n+  }\n+\n+  @Test\n+  public void clearRegionClearsLocalAndSendsMessageForRemote() throws Exception {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(regionEvent.clone()).thenReturn(mock(RegionEventImpl.class));\n+    Region<String, PartitionRegionConfig> region = mock(Region.class);\n+    when(partitionedRegion.getPRRoot()).thenReturn(region);\n+    PartitionedRegionClear spyPartitionedRegionClear = spy(partitionedRegionClear);\n+    doReturn(Collections.EMPTY_LIST).when(spyPartitionedRegionClear)\n+        .attemptToSendPartitionedRegionClearMessage(regionEvent,\n+            PartitionedRegionClearMessage.OperationType.OP_PR_CLEAR);\n+    InternalDistributedMember internalDistributedMember = mock(InternalDistributedMember.class);\n+    when(distributionManager.getId()).thenReturn(internalDistributedMember);\n+    RegionVersionVector regionVersionVector = mock(RegionVersionVector.class);\n+\n+    spyPartitionedRegionClear.clearRegion(regionEvent, false, regionVersionVector);\n+\n+    verify(spyPartitionedRegionClear, times(1)).clearRegionLocal(regionEvent);\n+    verify(spyPartitionedRegionClear, times(1)).sendPartitionedRegionClearMessage(regionEvent,\n+        PartitionedRegionClearMessage.OperationType.OP_PR_CLEAR);\n+  }\n+\n+  @Test\n+  public void waitForPrimaryReturnsAfterFindingAllPrimary() {\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    PartitionedRegion.RetryTimeKeeper retryTimer = mock(PartitionedRegion.RetryTimeKeeper.class);\n+\n+    partitionedRegionClear.waitForPrimary(retryTimer);\n+\n+    verify(retryTimer, times(0)).waitForBucketsRecovery();\n+  }\n+\n+  @Test\n+  public void waitForPrimaryReturnsAfterRetryForPrimary() {\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(false).thenReturn(true);\n+    setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    PartitionedRegion.RetryTimeKeeper retryTimer = mock(PartitionedRegion.RetryTimeKeeper.class);\n+\n+    partitionedRegionClear.waitForPrimary(retryTimer);\n+\n+    verify(retryTimer, times(1)).waitForBucketsRecovery();\n+  }\n+\n+  @Test\n+  public void waitForPrimaryThrowsPartitionedRegionPartialClearException() {\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    PartitionedRegion.RetryTimeKeeper retryTimer = mock(PartitionedRegion.RetryTimeKeeper.class);\n+    when(retryTimer.overMaximum()).thenReturn(true);\n+\n+    Throwable thrown = catchThrowable(() -> partitionedRegionClear.waitForPrimary(retryTimer));\n+\n+    assertThat(thrown)\n+        .isInstanceOf(PartitionedRegionPartialClearException.class)\n+        .hasMessage(\n+            \"Unable to find primary bucket region during clear operation for region: prRegion\");\n+    verify(retryTimer, times(0)).waitForBucketsRecovery();\n+  }\n+\n+  @Test\n+  public void clearRegionLocalCallsClearOnLocalPrimaryBucketRegions() {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    doNothing().when(partitionedRegionDataStore).lockBucketCreationForRegionClear();\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+\n+    List bucketsCleared = partitionedRegionClear.clearRegionLocal(regionEvent);\n+\n+    assertThat(bucketsCleared.size()).isEqualTo(buckets.size());\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(1)).clear();\n+    }\n+  }\n+\n+  @Test\n+  public void clearRegionLocalRetriesClearOnLocalPrimaryBucketRegions() {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    doNothing().when(partitionedRegionDataStore).lockBucketCreationForRegionClear();\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    PartitionedRegionClear spyPartitionedRegionClear = spy(partitionedRegionClear);\n+    when(spyPartitionedRegionClear.getMembershipChange()).thenReturn(true).thenReturn(false);\n+\n+    List bucketsCleared = spyPartitionedRegionClear.clearRegionLocal(regionEvent);\n+\n+    int expectedClears = buckets.size() * 2; /* clear is called twice on each bucket */\n+    assertThat(bucketsCleared.size()).isEqualTo(expectedClears);\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(2)).clear();\n+    }\n+  }\n+\n+  @Test\n+  public void doAfterClearCallsNotifyClientsWhenClientHaveInterests() {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(partitionedRegion.hasAnyClientsInterested()).thenReturn(true);\n+    FilterProfile filterProfile = mock(FilterProfile.class);\n+    FilterRoutingInfo filterRoutingInfo = mock(FilterRoutingInfo.class);\n+    when(filterProfile.getFilterRoutingInfoPart1(regionEvent, FilterProfile.NO_PROFILES,\n+        Collections.emptySet())).thenReturn(filterRoutingInfo);\n+    when(filterProfile.getFilterRoutingInfoPart2(filterRoutingInfo, regionEvent)).thenReturn(\n+        filterRoutingInfo);\n+    when(partitionedRegion.getFilterProfile()).thenReturn(filterProfile);\n+\n+    partitionedRegionClear.doAfterClear(regionEvent);\n+\n+    verify(regionEvent, times(1)).setLocalFilterInfo(any());\n+    verify(partitionedRegion, times(1)).notifyBridgeClients(regionEvent);\n+  }\n+\n+  @Test\n+  public void doAfterClearDispatchesListenerEvents() {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(partitionedRegion.hasListener()).thenReturn(true);\n+\n+    partitionedRegionClear.doAfterClear(regionEvent);\n+\n+    verify(partitionedRegion, times(1)).dispatchListenerEvent(\n+        EnumListenerEvent.AFTER_REGION_CLEAR, regionEvent);\n+  }\n+\n+  @Test\n+  public void obtainClearLockLocalGetsLockOnPrimaryBuckets() {\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    InternalDistributedMember member = mock(InternalDistributedMember.class);\n+    when(distributionManager.isCurrentMember(member)).thenReturn(true);\n+\n+    partitionedRegionClear.obtainClearLockLocal(member);\n+\n+    assertThat(partitionedRegionClear.lockForListenerAndClientNotification.getLockRequester())\n+        .isSameAs(member);\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(1)).lockLocallyForClear(partitionedRegion.getDistributionManager(),\n+          partitionedRegion.getMyId(), null);\n+    }\n+  }\n+\n+  @Test\n+  public void obtainClearLockLocalDoesNotGetLocksOnPrimaryBucketsWhenMemberIsNotCurrent() {\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    InternalDistributedMember member = mock(InternalDistributedMember.class);\n+    when(distributionManager.isCurrentMember(member)).thenReturn(false);\n+\n+    partitionedRegionClear.obtainClearLockLocal(member);\n+\n+    assertThat(partitionedRegionClear.lockForListenerAndClientNotification.getLockRequester())\n+        .isNull();\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(0)).lockLocallyForClear(partitionedRegion.getDistributionManager(),\n+          partitionedRegion.getMyId(), null);\n+    }\n+  }\n+\n+  @Test\n+  public void releaseClearLockLocalReleasesLockOnPrimaryBuckets() {\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    InternalDistributedMember member = mock(InternalDistributedMember.class);\n+    when(distributionManager.isCurrentMember(member)).thenReturn(true);\n+    partitionedRegionClear.lockForListenerAndClientNotification.setLocked(member);\n+\n+    partitionedRegionClear.releaseClearLockLocal();\n+\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(1)).releaseLockLocallyForClear(null);\n+    }\n+  }\n+\n+  @Test\n+  public void releaseClearLockLocalDoesNotReleaseLocksOnPrimaryBucketsWhenMemberIsNotCurrent() {\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    InternalDistributedMember member = mock(InternalDistributedMember.class);\n+\n+    partitionedRegionClear.obtainClearLockLocal(member);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bf63222b8acb0c12e38469a7c05819d2b8e2fd0"}, "originalPosition": 367}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxMDgzMw==", "bodyText": "Small suggestion; you can instead use Set<InternalDistributedMember> prNodes = Collections.singleton(member); and Set<Node> configNodes = Collections.singleton(node); to condense the code a little.", "url": "https://github.com/apache/geode/pull/5208#discussion_r436210833", "createdAt": "2020-06-05T23:59:27Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/PartitionedRegionClearTest.java", "diffHunk": "@@ -0,0 +1,598 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.catchThrowable;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.PartitionedRegionPartialClearException;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.distributed.internal.DMStats;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.MembershipListener;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.partitioned.RegionAdvisor;\n+import org.apache.geode.internal.cache.versions.RegionVersionVector;\n+\n+public class PartitionedRegionClearTest {\n+\n+\n+  private PartitionedRegionClear partitionedRegionClear;\n+  private DistributionManager distributionManager;\n+  private PartitionedRegion partitionedRegion;\n+\n+  @Before\n+  public void setUp() {\n+\n+    partitionedRegion = mock(PartitionedRegion.class);\n+    distributionManager = mock(DistributionManager.class);\n+\n+    when(partitionedRegion.getDistributionManager()).thenReturn(distributionManager);\n+    when(partitionedRegion.getName()).thenReturn(\"prRegion\");\n+\n+    partitionedRegionClear = new PartitionedRegionClear(partitionedRegion);\n+  }\n+\n+  private Set<BucketRegion> setupBucketRegions(\n+      PartitionedRegionDataStore partitionedRegionDataStore,\n+      BucketAdvisor bucketAdvisor) {\n+    final int numBuckets = 2;\n+    HashSet<BucketRegion> bucketRegions = new HashSet<>();\n+    for (int i = 0; i < numBuckets; i++) {\n+      BucketRegion bucketRegion = mock(BucketRegion.class);\n+      when(bucketRegion.getBucketAdvisor()).thenReturn(bucketAdvisor);\n+      when(bucketRegion.size()).thenReturn(1);\n+      when(bucketRegion.getId()).thenReturn(i);\n+      bucketRegions.add(bucketRegion);\n+    }\n+\n+    when(partitionedRegionDataStore.getAllLocalBucketRegions()).thenReturn(bucketRegions);\n+    when(partitionedRegionDataStore.getAllLocalPrimaryBucketRegions()).thenReturn(bucketRegions);\n+\n+    return bucketRegions;\n+  }\n+\n+  @Test\n+  public void isLockedForListenerAndClientNotificationReturnsTrueWhenLocked() {\n+    InternalDistributedMember internalDistributedMember = mock(InternalDistributedMember.class);\n+    when(distributionManager.isCurrentMember(internalDistributedMember)).thenReturn(true);\n+    partitionedRegionClear.obtainClearLockLocal(internalDistributedMember);\n+\n+    assertThat(partitionedRegionClear.isLockedForListenerAndClientNotification()).isTrue();\n+  }\n+\n+  @Test\n+  public void isLockedForListenerAndClientNotificationReturnsFalseWhenMemberNotInTheSystemRequestsLock() {\n+    InternalDistributedMember internalDistributedMember = mock(InternalDistributedMember.class);\n+    when(distributionManager.isCurrentMember(internalDistributedMember)).thenReturn(false);\n+\n+    assertThat(partitionedRegionClear.isLockedForListenerAndClientNotification()).isFalse();\n+  }\n+\n+  @Test\n+  public void acquireDistributedClearLockGetsDistributedLock() {\n+    DistributedLockService distributedLockService = mock(DistributedLockService.class);\n+    String lockName = PartitionedRegionClear.CLEAR_OPERATION + partitionedRegion.getName();\n+    when(partitionedRegion.getPartitionedRegionLockService()).thenReturn(distributedLockService);\n+\n+    partitionedRegionClear.acquireDistributedClearLock(lockName);\n+\n+    verify(distributedLockService, times(1)).lock(lockName, -1, -1);\n+  }\n+\n+  @Test\n+  public void releaseDistributedClearLockReleasesDistributedLock() {\n+    DistributedLockService distributedLockService = mock(DistributedLockService.class);\n+    String lockName = PartitionedRegionClear.CLEAR_OPERATION + partitionedRegion.getName();\n+    when(partitionedRegion.getPartitionedRegionLockService()).thenReturn(distributedLockService);\n+\n+    partitionedRegionClear.releaseDistributedClearLock(lockName);\n+\n+    verify(distributedLockService, times(1)).unlock(lockName);\n+  }\n+\n+  @Test\n+  public void obtainLockForClearGetsLocalLockAndSendsMessageForRemote() throws Exception {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(regionEvent.clone()).thenReturn(mock(RegionEventImpl.class));\n+    Region<String, PartitionRegionConfig> region = mock(Region.class);\n+    when(partitionedRegion.getPRRoot()).thenReturn(region);\n+    PartitionedRegionClear spyPartitionedRegionClear = spy(partitionedRegionClear);\n+    doReturn(Collections.EMPTY_LIST).when(spyPartitionedRegionClear)\n+        .attemptToSendPartitionedRegionClearMessage(regionEvent,\n+            PartitionedRegionClearMessage.OperationType.OP_LOCK_FOR_PR_CLEAR);\n+    InternalDistributedMember internalDistributedMember = mock(InternalDistributedMember.class);\n+    when(distributionManager.getId()).thenReturn(internalDistributedMember);\n+\n+    spyPartitionedRegionClear.obtainLockForClear(regionEvent);\n+\n+    verify(spyPartitionedRegionClear, times(1)).obtainClearLockLocal(internalDistributedMember);\n+    verify(spyPartitionedRegionClear, times(1)).sendPartitionedRegionClearMessage(regionEvent,\n+        PartitionedRegionClearMessage.OperationType.OP_LOCK_FOR_PR_CLEAR);\n+  }\n+\n+  @Test\n+  public void releaseLockForClearReleasesLocalLockAndSendsMessageForRemote() throws Exception {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(regionEvent.clone()).thenReturn(mock(RegionEventImpl.class));\n+    Region<String, PartitionRegionConfig> region = mock(Region.class);\n+    when(partitionedRegion.getPRRoot()).thenReturn(region);\n+    PartitionedRegionClear spyPartitionedRegionClear = spy(partitionedRegionClear);\n+    doReturn(Collections.EMPTY_LIST).when(spyPartitionedRegionClear)\n+        .attemptToSendPartitionedRegionClearMessage(regionEvent,\n+            PartitionedRegionClearMessage.OperationType.OP_UNLOCK_FOR_PR_CLEAR);\n+    InternalDistributedMember internalDistributedMember = mock(InternalDistributedMember.class);\n+    when(distributionManager.getId()).thenReturn(internalDistributedMember);\n+\n+    spyPartitionedRegionClear.releaseLockForClear(regionEvent);\n+\n+    verify(spyPartitionedRegionClear, times(1)).releaseClearLockLocal();\n+    verify(spyPartitionedRegionClear, times(1)).sendPartitionedRegionClearMessage(regionEvent,\n+        PartitionedRegionClearMessage.OperationType.OP_UNLOCK_FOR_PR_CLEAR);\n+  }\n+\n+  @Test\n+  public void clearRegionClearsLocalAndSendsMessageForRemote() throws Exception {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(regionEvent.clone()).thenReturn(mock(RegionEventImpl.class));\n+    Region<String, PartitionRegionConfig> region = mock(Region.class);\n+    when(partitionedRegion.getPRRoot()).thenReturn(region);\n+    PartitionedRegionClear spyPartitionedRegionClear = spy(partitionedRegionClear);\n+    doReturn(Collections.EMPTY_LIST).when(spyPartitionedRegionClear)\n+        .attemptToSendPartitionedRegionClearMessage(regionEvent,\n+            PartitionedRegionClearMessage.OperationType.OP_PR_CLEAR);\n+    InternalDistributedMember internalDistributedMember = mock(InternalDistributedMember.class);\n+    when(distributionManager.getId()).thenReturn(internalDistributedMember);\n+    RegionVersionVector regionVersionVector = mock(RegionVersionVector.class);\n+\n+    spyPartitionedRegionClear.clearRegion(regionEvent, false, regionVersionVector);\n+\n+    verify(spyPartitionedRegionClear, times(1)).clearRegionLocal(regionEvent);\n+    verify(spyPartitionedRegionClear, times(1)).sendPartitionedRegionClearMessage(regionEvent,\n+        PartitionedRegionClearMessage.OperationType.OP_PR_CLEAR);\n+  }\n+\n+  @Test\n+  public void waitForPrimaryReturnsAfterFindingAllPrimary() {\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    PartitionedRegion.RetryTimeKeeper retryTimer = mock(PartitionedRegion.RetryTimeKeeper.class);\n+\n+    partitionedRegionClear.waitForPrimary(retryTimer);\n+\n+    verify(retryTimer, times(0)).waitForBucketsRecovery();\n+  }\n+\n+  @Test\n+  public void waitForPrimaryReturnsAfterRetryForPrimary() {\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(false).thenReturn(true);\n+    setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    PartitionedRegion.RetryTimeKeeper retryTimer = mock(PartitionedRegion.RetryTimeKeeper.class);\n+\n+    partitionedRegionClear.waitForPrimary(retryTimer);\n+\n+    verify(retryTimer, times(1)).waitForBucketsRecovery();\n+  }\n+\n+  @Test\n+  public void waitForPrimaryThrowsPartitionedRegionPartialClearException() {\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    PartitionedRegion.RetryTimeKeeper retryTimer = mock(PartitionedRegion.RetryTimeKeeper.class);\n+    when(retryTimer.overMaximum()).thenReturn(true);\n+\n+    Throwable thrown = catchThrowable(() -> partitionedRegionClear.waitForPrimary(retryTimer));\n+\n+    assertThat(thrown)\n+        .isInstanceOf(PartitionedRegionPartialClearException.class)\n+        .hasMessage(\n+            \"Unable to find primary bucket region during clear operation for region: prRegion\");\n+    verify(retryTimer, times(0)).waitForBucketsRecovery();\n+  }\n+\n+  @Test\n+  public void clearRegionLocalCallsClearOnLocalPrimaryBucketRegions() {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    doNothing().when(partitionedRegionDataStore).lockBucketCreationForRegionClear();\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+\n+    List bucketsCleared = partitionedRegionClear.clearRegionLocal(regionEvent);\n+\n+    assertThat(bucketsCleared.size()).isEqualTo(buckets.size());\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(1)).clear();\n+    }\n+  }\n+\n+  @Test\n+  public void clearRegionLocalRetriesClearOnLocalPrimaryBucketRegions() {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    doNothing().when(partitionedRegionDataStore).lockBucketCreationForRegionClear();\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    PartitionedRegionClear spyPartitionedRegionClear = spy(partitionedRegionClear);\n+    when(spyPartitionedRegionClear.getMembershipChange()).thenReturn(true).thenReturn(false);\n+\n+    List bucketsCleared = spyPartitionedRegionClear.clearRegionLocal(regionEvent);\n+\n+    int expectedClears = buckets.size() * 2; /* clear is called twice on each bucket */\n+    assertThat(bucketsCleared.size()).isEqualTo(expectedClears);\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(2)).clear();\n+    }\n+  }\n+\n+  @Test\n+  public void doAfterClearCallsNotifyClientsWhenClientHaveInterests() {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(partitionedRegion.hasAnyClientsInterested()).thenReturn(true);\n+    FilterProfile filterProfile = mock(FilterProfile.class);\n+    FilterRoutingInfo filterRoutingInfo = mock(FilterRoutingInfo.class);\n+    when(filterProfile.getFilterRoutingInfoPart1(regionEvent, FilterProfile.NO_PROFILES,\n+        Collections.emptySet())).thenReturn(filterRoutingInfo);\n+    when(filterProfile.getFilterRoutingInfoPart2(filterRoutingInfo, regionEvent)).thenReturn(\n+        filterRoutingInfo);\n+    when(partitionedRegion.getFilterProfile()).thenReturn(filterProfile);\n+\n+    partitionedRegionClear.doAfterClear(regionEvent);\n+\n+    verify(regionEvent, times(1)).setLocalFilterInfo(any());\n+    verify(partitionedRegion, times(1)).notifyBridgeClients(regionEvent);\n+  }\n+\n+  @Test\n+  public void doAfterClearDispatchesListenerEvents() {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(partitionedRegion.hasListener()).thenReturn(true);\n+\n+    partitionedRegionClear.doAfterClear(regionEvent);\n+\n+    verify(partitionedRegion, times(1)).dispatchListenerEvent(\n+        EnumListenerEvent.AFTER_REGION_CLEAR, regionEvent);\n+  }\n+\n+  @Test\n+  public void obtainClearLockLocalGetsLockOnPrimaryBuckets() {\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    InternalDistributedMember member = mock(InternalDistributedMember.class);\n+    when(distributionManager.isCurrentMember(member)).thenReturn(true);\n+\n+    partitionedRegionClear.obtainClearLockLocal(member);\n+\n+    assertThat(partitionedRegionClear.lockForListenerAndClientNotification.getLockRequester())\n+        .isSameAs(member);\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(1)).lockLocallyForClear(partitionedRegion.getDistributionManager(),\n+          partitionedRegion.getMyId(), null);\n+    }\n+  }\n+\n+  @Test\n+  public void obtainClearLockLocalDoesNotGetLocksOnPrimaryBucketsWhenMemberIsNotCurrent() {\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    InternalDistributedMember member = mock(InternalDistributedMember.class);\n+    when(distributionManager.isCurrentMember(member)).thenReturn(false);\n+\n+    partitionedRegionClear.obtainClearLockLocal(member);\n+\n+    assertThat(partitionedRegionClear.lockForListenerAndClientNotification.getLockRequester())\n+        .isNull();\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(0)).lockLocallyForClear(partitionedRegion.getDistributionManager(),\n+          partitionedRegion.getMyId(), null);\n+    }\n+  }\n+\n+  @Test\n+  public void releaseClearLockLocalReleasesLockOnPrimaryBuckets() {\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    InternalDistributedMember member = mock(InternalDistributedMember.class);\n+    when(distributionManager.isCurrentMember(member)).thenReturn(true);\n+    partitionedRegionClear.lockForListenerAndClientNotification.setLocked(member);\n+\n+    partitionedRegionClear.releaseClearLockLocal();\n+\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(1)).releaseLockLocallyForClear(null);\n+    }\n+  }\n+\n+  @Test\n+  public void releaseClearLockLocalDoesNotReleaseLocksOnPrimaryBucketsWhenMemberIsNotCurrent() {\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    InternalDistributedMember member = mock(InternalDistributedMember.class);\n+\n+    partitionedRegionClear.obtainClearLockLocal(member);\n+\n+    assertThat(partitionedRegionClear.lockForListenerAndClientNotification.getLockRequester())\n+        .isNull();\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(0)).releaseLockLocallyForClear(null);\n+    }\n+  }\n+\n+  @Test\n+  public void sendPartitionedRegionClearMessageSendsClearMessageToPRNodes() {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(regionEvent.clone()).thenReturn(mock(RegionEventImpl.class));\n+    Region<String, PartitionRegionConfig> prRoot = mock(Region.class);\n+    when(partitionedRegion.getPRRoot()).thenReturn(prRoot);\n+    InternalDistributedMember member = mock(InternalDistributedMember.class);\n+    RegionAdvisor regionAdvisor = mock(RegionAdvisor.class);\n+    Set<InternalDistributedMember> prNodes = new HashSet<>();\n+    prNodes.add(member);\n+    Node node = mock(Node.class);\n+    when(node.getMemberId()).thenReturn(member);\n+    Set<Node> configNodes = new HashSet<>();\n+    configNodes.add(node);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bf63222b8acb0c12e38469a7c05819d2b8e2fd0"}, "originalPosition": 389}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f887cb2bea8c68664ce66c89fbc1b7ee83036b5", "author": {"user": null}, "url": "https://github.com/apache/geode/commit/7f887cb2bea8c68664ce66c89fbc1b7ee83036b5", "committedDate": "2020-06-06T00:24:50Z", "message": "Changes to address review comments.\n- Separate the PRCacheListenerDistributedTest\n- Call bucket.cmnClearRegion()"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f6f704744cd6e0a28f5f6cdb538bf349e01f75a0", "author": {"user": null}, "url": "https://github.com/apache/geode/commit/f6f704744cd6e0a28f5f6cdb538bf349e01f75a0", "committedDate": "2020-06-06T00:32:59Z", "message": "Add revew comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2Mzg2ODgy", "url": "https://github.com/apache/geode/pull/5208#pullrequestreview-426386882", "createdAt": "2020-06-08T16:00:08Z", "commit": {"oid": "f6f704744cd6e0a28f5f6cdb538bf349e01f75a0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2NDUxODY0", "url": "https://github.com/apache/geode/pull/5208#pullrequestreview-426451864", "createdAt": "2020-06-08T17:17:41Z", "commit": {"oid": "f6f704744cd6e0a28f5f6cdb538bf349e01f75a0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4424, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}