{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE0ODE1MDU5", "number": 5070, "title": "GEODE-8079: Fix DistributedRegion Validations", "bodyText": "Attaching a parallel gateway-sender or async-event-queue to a\nReplicate Region through the AttributesMutator class now throws an\nexception instead of wrongly assigning the dispatcher to the region.\n\nFixed several warnings.\nAdded unit and distributed tests.\nReplaced usages of 'junit.Assert' by 'assertj'.\nChanged test methods to use more meaningful names.\nRemoved references to old ids used by another ticketing system.\n\nThank you for submitting a contribution to Apache Geode.\nIn order to streamline the review of the contribution we ask you\nto ensure the following steps have been taken:\nFor all changes:\n\n\n Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?\n\n\n Has your PR been rebased against the latest commit within the target branch (typically develop)?\n\n\n Is your initial contribution a single, squashed commit?\n\n\n Does gradlew build run cleanly?\n\n\n Have you written or updated unit tests to verify your changes?\n\n\n If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under ASF 2.0?\n\n\nNote:\nPlease ensure that once the PR is submitted, check Concourse for build issues and\nsubmit an update to your PR as soon as possible. If you need help, please send an\nemail to dev@geode.apache.org.", "createdAt": "2020-05-07T17:12:53Z", "url": "https://github.com/apache/geode/pull/5070", "merged": true, "mergeCommit": {"oid": "78a4fb9bf1643aaf72c120b0f378ca8730e16719"}, "closed": true, "closedAt": "2020-05-08T16:52:57Z", "author": {"login": "jujoramos"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcfAVi2AH2gAyNDE0ODE1MDU5OjlkYWMxN2RiZTcxMzliNWMwNWI3NzBjYWI1YzBjMWQ4OTA2NWM5NjQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcfUuL6gFqTQwODM3MDk3MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "9dac17dbe7139b5c05b770cab5c0c1d89065c964", "author": {"user": {"login": "jujoramos", "name": "Juan Jos\u00e9 Ramos"}}, "url": "https://github.com/apache/geode/commit/9dac17dbe7139b5c05b770cab5c0c1d89065c964", "committedDate": "2020-05-07T17:01:16Z", "message": "GEODE-8079: Refactor WanValidationsDUnitTest\n\n- Fixed several warnings.\n- Replaced usages of 'junit.Assert' by 'assertj'.\n- Changed test methods to use more meaningful names.\n- Removed references to old ids used by another ticketing system."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e06789324d2561f739b341da63a6b9dc1c9d4453", "author": {"user": {"login": "jujoramos", "name": "Juan Jos\u00e9 Ramos"}}, "url": "https://github.com/apache/geode/commit/e06789324d2561f739b341da63a6b9dc1c9d4453", "committedDate": "2020-05-07T17:01:16Z", "message": "GEODE-8079: Fix DistributedRegion Validations\n\nAttaching a parallel gateway-sender or async-event-queue to a\nReplicate Region through the AttributesMutator class now throws an\nexception instead of wrongly assigning the dispatcher to the region.\n\n- Fixed minor warnings.\n- Added unit and distributed tests."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3NzY5MTE3", "url": "https://github.com/apache/geode/pull/5070#pullrequestreview-407769117", "createdAt": "2020-05-07T19:24:49Z", "commit": {"oid": "e06789324d2561f739b341da63a6b9dc1c9d4453"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxOToyNDo1MFrOGSM8SQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxOToyNDo1MFrOGSM8SQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTczOTU5Mw==", "bodyText": "I'm a bit confused regarding the use of AsynchronousEventDispatcher in the parameter comment and the method name. Is that just a grouping of GatewaySender and AsyncEventListener?", "url": "https://github.com/apache/geode/pull/5070#discussion_r421739593", "createdAt": "2020-05-07T19:24:50Z", "author": {"login": "boglesby"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/DistributedRegion.java", "diffHunk": "@@ -1013,34 +1016,38 @@ public Lock getDistributedLock(Object key) throws IllegalStateException {\n     return new DistributedLock(key);\n   }\n \n-  @Override\n-  public void preInitialize() {\n-    Set<String> allGatewaySenderIds = getAllGatewaySenderIds();\n-\n-    if (!allGatewaySenderIds.isEmpty()) {\n-      for (GatewaySender sender : cache.getAllGatewaySenders()) {\n-        if (sender.isParallel() && allGatewaySenderIds.contains(sender.getId())) {\n-          // Once decided to support REPLICATED regions with parallel\n-          // gateway-sender/asynchronous-event-queue, ShadowPartitionedRegionForUserRR should be\n-          // called and this validation should be removed.\n-          if (sender.getId().contains(AsyncEventQueueImpl.ASYNC_EVENT_QUEUE_PREFIX)) {\n-            throw new AsyncEventQueueConfigurationException(\n-                String.format(\n-                    \"Parallel Async Event Queue %s can not be used with replicated region %s\",\n-\n-                    AsyncEventQueueImpl.getAsyncEventQueueIdFromSenderId(sender.getId()),\n-                    getFullPath()));\n-          } else {\n-            throw new GatewaySenderConfigurationException(\n-                String.format(\n-                    \"Parallel gateway sender %s can not be used with replicated region %s\",\n-                    sender.getId(), getFullPath()));\n-          }\n+  /**\n+   * Validates that the GatewaySender/AsyncEventQueue referenced by the {@param asyncDispatcherId}\n+   * can be attached to this region; that is, verifies that the dispatcher is not configured as\n+   * parallel.\n+   *\n+   * @param asyncDispatcherId Id of the AsynchronousEventDispatcher to validate.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e06789324d2561f739b341da63a6b9dc1c9d4453"}, "originalPosition": 42}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3NzkwNDk5", "url": "https://github.com/apache/geode/pull/5070#pullrequestreview-407790499", "createdAt": "2020-05-07T19:56:15Z", "commit": {"oid": "e06789324d2561f739b341da63a6b9dc1c9d4453"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxOTo1NjoxNVrOGSOAww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMDoxNDowOVrOGSOlIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc1NzEyMw==", "bodyText": "Would it be possible to have a spy DistributedRegion instead of a mock here? While using doCallRealMethod() works now because the validateAsynchronousEventDispatcher() method is entirely self-contained, if at some point in the future it's modified to access a field of DistributedRegion or call some other method in the class, the test will either fail, or pass despite not actually testing the true behaviour of the method.", "url": "https://github.com/apache/geode/pull/5070#discussion_r421757123", "createdAt": "2020-05-07T19:56:15Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/DistributedRegionTest.java", "diffHunk": "@@ -180,4 +189,75 @@ public void regionSyncNotInvokedInPerformSynchronizeForLostMemberTaskIfRegionNot\n \n     verify(distributedRegion, never()).synchronizeForLostMember(member, lostMemberVersionID);\n   }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldDoNothingWhenDispatcherIdCanNotBeFound() {\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders())\n+        .thenReturn(Collections.singleton(mock(GatewaySender.class)));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e06789324d2561f739b341da63a6b9dc1c9d4453"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc1Nzk3NA==", "bodyText": "Would it be possible to use a spy rather than a mock here?", "url": "https://github.com/apache/geode/pull/5070#discussion_r421757974", "createdAt": "2020-05-07T19:57:44Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/DistributedRegionTest.java", "diffHunk": "@@ -180,4 +189,75 @@ public void regionSyncNotInvokedInPerformSynchronizeForLostMemberTaskIfRegionNot\n \n     verify(distributedRegion, never()).synchronizeForLostMember(member, lostMemberVersionID);\n   }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldDoNothingWhenDispatcherIdCanNotBeFound() {\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders())\n+        .thenReturn(Collections.singleton(mock(GatewaySender.class)));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);\n+    when(distributedRegion.getCache()).thenReturn(internalCache);\n+    doCallRealMethod().when(distributedRegion).validateAsynchronousEventDispatcher(anyString());\n+\n+    distributedRegion.validateAsynchronousEventDispatcher(\"nonExistingDispatcher\");\n+  }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldDoNothingWhenFoundDispatcherIsSerial() {\n+    String senderId = \"mySender\";\n+    GatewaySender serialSender = mock(GatewaySender.class);\n+    when(serialSender.isParallel()).thenReturn(false);\n+    when(serialSender.getId()).thenReturn(senderId);\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders()).thenReturn(Collections.singleton(serialSender));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e06789324d2561f739b341da63a6b9dc1c9d4453"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc1OTA5Ng==", "bodyText": "Would it be possible to use a spy rather than a mock here?", "url": "https://github.com/apache/geode/pull/5070#discussion_r421759096", "createdAt": "2020-05-07T19:59:36Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/DistributedRegionTest.java", "diffHunk": "@@ -180,4 +189,75 @@ public void regionSyncNotInvokedInPerformSynchronizeForLostMemberTaskIfRegionNot\n \n     verify(distributedRegion, never()).synchronizeForLostMember(member, lostMemberVersionID);\n   }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldDoNothingWhenDispatcherIdCanNotBeFound() {\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders())\n+        .thenReturn(Collections.singleton(mock(GatewaySender.class)));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);\n+    when(distributedRegion.getCache()).thenReturn(internalCache);\n+    doCallRealMethod().when(distributedRegion).validateAsynchronousEventDispatcher(anyString());\n+\n+    distributedRegion.validateAsynchronousEventDispatcher(\"nonExistingDispatcher\");\n+  }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldDoNothingWhenFoundDispatcherIsSerial() {\n+    String senderId = \"mySender\";\n+    GatewaySender serialSender = mock(GatewaySender.class);\n+    when(serialSender.isParallel()).thenReturn(false);\n+    when(serialSender.getId()).thenReturn(senderId);\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders()).thenReturn(Collections.singleton(serialSender));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);\n+    when(distributedRegion.getCache()).thenReturn(internalCache);\n+    doCallRealMethod().when(distributedRegion).validateAsynchronousEventDispatcher(anyString());\n+\n+    distributedRegion.validateAsynchronousEventDispatcher(senderId);\n+  }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldThrowExceptionWhenDispatcherIdMatchesAnExistingParallelAsyncEventQueue() {\n+    String senderId = \"senderId\";\n+    String regionPath = \"thisRegion\";\n+    String internalSenderId = getSenderIdFromAsyncEventQueueId(senderId);\n+    GatewaySender parallelAsyncEventQueue = mock(GatewaySender.class);\n+    when(parallelAsyncEventQueue.isParallel()).thenReturn(true);\n+    when(parallelAsyncEventQueue.getId()).thenReturn(internalSenderId);\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders())\n+        .thenReturn(Collections.singleton(parallelAsyncEventQueue));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e06789324d2561f739b341da63a6b9dc1c9d4453"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc1OTE1MQ==", "bodyText": "Would it be possible to use a spy rather than a mock here?", "url": "https://github.com/apache/geode/pull/5070#discussion_r421759151", "createdAt": "2020-05-07T19:59:42Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/DistributedRegionTest.java", "diffHunk": "@@ -180,4 +189,75 @@ public void regionSyncNotInvokedInPerformSynchronizeForLostMemberTaskIfRegionNot\n \n     verify(distributedRegion, never()).synchronizeForLostMember(member, lostMemberVersionID);\n   }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldDoNothingWhenDispatcherIdCanNotBeFound() {\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders())\n+        .thenReturn(Collections.singleton(mock(GatewaySender.class)));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);\n+    when(distributedRegion.getCache()).thenReturn(internalCache);\n+    doCallRealMethod().when(distributedRegion).validateAsynchronousEventDispatcher(anyString());\n+\n+    distributedRegion.validateAsynchronousEventDispatcher(\"nonExistingDispatcher\");\n+  }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldDoNothingWhenFoundDispatcherIsSerial() {\n+    String senderId = \"mySender\";\n+    GatewaySender serialSender = mock(GatewaySender.class);\n+    when(serialSender.isParallel()).thenReturn(false);\n+    when(serialSender.getId()).thenReturn(senderId);\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders()).thenReturn(Collections.singleton(serialSender));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);\n+    when(distributedRegion.getCache()).thenReturn(internalCache);\n+    doCallRealMethod().when(distributedRegion).validateAsynchronousEventDispatcher(anyString());\n+\n+    distributedRegion.validateAsynchronousEventDispatcher(senderId);\n+  }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldThrowExceptionWhenDispatcherIdMatchesAnExistingParallelAsyncEventQueue() {\n+    String senderId = \"senderId\";\n+    String regionPath = \"thisRegion\";\n+    String internalSenderId = getSenderIdFromAsyncEventQueueId(senderId);\n+    GatewaySender parallelAsyncEventQueue = mock(GatewaySender.class);\n+    when(parallelAsyncEventQueue.isParallel()).thenReturn(true);\n+    when(parallelAsyncEventQueue.getId()).thenReturn(internalSenderId);\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders())\n+        .thenReturn(Collections.singleton(parallelAsyncEventQueue));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);\n+    when(distributedRegion.getCache()).thenReturn(internalCache);\n+    when(distributedRegion.getFullPath()).thenReturn(regionPath);\n+    doCallRealMethod().when(distributedRegion).validateAsynchronousEventDispatcher(anyString());\n+\n+    assertThatThrownBy(\n+        () -> distributedRegion.validateAsynchronousEventDispatcher(internalSenderId))\n+            .isInstanceOf(AsyncEventQueueConfigurationException.class)\n+            .hasMessage(\"Parallel Async Event Queue \" + senderId\n+                + \" can not be used with replicated region \" + regionPath);\n+  }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldThrowExceptionWhenDispatcherIdMatchesAnExistingParallelGatewaySender() {\n+    String senderId = \"senderId\";\n+    String regionPath = \"thisRegion\";\n+    GatewaySender parallelGatewaySender = mock(GatewaySender.class);\n+    when(parallelGatewaySender.isParallel()).thenReturn(true);\n+    when(parallelGatewaySender.getId()).thenReturn(senderId);\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders())\n+        .thenReturn(Collections.singleton(parallelGatewaySender));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e06789324d2561f739b341da63a6b9dc1c9d4453"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc2NTcxNQ==", "bodyText": "Could these tests use CommandStringBuilder to generate their gfsh commands? I find it makes things a little more readable.", "url": "https://github.com/apache/geode/pull/5070#discussion_r421765715", "createdAt": "2020-05-07T20:12:45Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/management/internal/cli/commands/AlterRegionCommandDUnitTest.java", "diffHunk": "@@ -343,4 +346,76 @@ public void alterPartitionPersistentRegionWithParallelNonPersistentGatewaySender\n       assertThat(regionConfig.getRegionAttributes().getGatewaySenderIds()).isBlank();\n     });\n   }\n+\n+  @Test\n+  public void alterReplicateRegionWithParallelGatewaySenderShouldFailAndDoNotPersistChangesIntoTheClusterConfigurationService() {\n+    addIgnoredException(GatewaySenderConfigurationException.class);\n+    addIgnoredException(\"could not get remote locator information\");\n+    String regionName = testName.getMethodName();\n+    String gatewaySenderId = testName.getMethodName() + \"_parallelGatewaySender\";\n+\n+    gfsh.executeAndAssertThat(\n+        \"create gateway-sender --parallel=true --enable-persistence=false --remote-distributed-system-id=2 --id=\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e06789324d2561f739b341da63a6b9dc1c9d4453"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc2NjE1Mg==", "bodyText": "Another place to possibly use CommandStringBuilder.", "url": "https://github.com/apache/geode/pull/5070#discussion_r421766152", "createdAt": "2020-05-07T20:13:36Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/management/internal/cli/commands/AlterRegionCommandDUnitTest.java", "diffHunk": "@@ -343,4 +346,76 @@ public void alterPartitionPersistentRegionWithParallelNonPersistentGatewaySender\n       assertThat(regionConfig.getRegionAttributes().getGatewaySenderIds()).isBlank();\n     });\n   }\n+\n+  @Test\n+  public void alterReplicateRegionWithParallelGatewaySenderShouldFailAndDoNotPersistChangesIntoTheClusterConfigurationService() {\n+    addIgnoredException(GatewaySenderConfigurationException.class);\n+    addIgnoredException(\"could not get remote locator information\");\n+    String regionName = testName.getMethodName();\n+    String gatewaySenderId = testName.getMethodName() + \"_parallelGatewaySender\";\n+\n+    gfsh.executeAndAssertThat(\n+        \"create gateway-sender --parallel=true --enable-persistence=false --remote-distributed-system-id=2 --id=\"\n+            + gatewaySenderId)\n+        .statusIsSuccess().doesNotContainOutput(\"Did not complete waiting\");\n+    gfsh.executeAndAssertThat(\"create region --type=REPLICATE --name=\" + regionName)\n+        .statusIsSuccess();\n+    locator.waitUntilRegionIsReadyOnExactlyThisManyServers(SEPARATOR + regionName, 1);\n+\n+    // Associate the gateway-sender\n+    gfsh.executeAndAssertThat(\n+        \"alter region --name=\" + regionName + \" --gateway-sender-id=\" + gatewaySenderId)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e06789324d2561f739b341da63a6b9dc1c9d4453"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc2NjIzNg==", "bodyText": "Another place to possibly use CommandStringBuilder.", "url": "https://github.com/apache/geode/pull/5070#discussion_r421766236", "createdAt": "2020-05-07T20:13:47Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/management/internal/cli/commands/AlterRegionCommandDUnitTest.java", "diffHunk": "@@ -343,4 +346,76 @@ public void alterPartitionPersistentRegionWithParallelNonPersistentGatewaySender\n       assertThat(regionConfig.getRegionAttributes().getGatewaySenderIds()).isBlank();\n     });\n   }\n+\n+  @Test\n+  public void alterReplicateRegionWithParallelGatewaySenderShouldFailAndDoNotPersistChangesIntoTheClusterConfigurationService() {\n+    addIgnoredException(GatewaySenderConfigurationException.class);\n+    addIgnoredException(\"could not get remote locator information\");\n+    String regionName = testName.getMethodName();\n+    String gatewaySenderId = testName.getMethodName() + \"_parallelGatewaySender\";\n+\n+    gfsh.executeAndAssertThat(\n+        \"create gateway-sender --parallel=true --enable-persistence=false --remote-distributed-system-id=2 --id=\"\n+            + gatewaySenderId)\n+        .statusIsSuccess().doesNotContainOutput(\"Did not complete waiting\");\n+    gfsh.executeAndAssertThat(\"create region --type=REPLICATE --name=\" + regionName)\n+        .statusIsSuccess();\n+    locator.waitUntilRegionIsReadyOnExactlyThisManyServers(SEPARATOR + regionName, 1);\n+\n+    // Associate the gateway-sender\n+    gfsh.executeAndAssertThat(\n+        \"alter region --name=\" + regionName + \" --gateway-sender-id=\" + gatewaySenderId)\n+        .statusIsError().containsOutput(\"server-1\", \"Parallel Gateway Sender \" + gatewaySenderId\n+            + \" can not be used with replicated region \" + SEPARATOR + regionName);\n+\n+    // Check the cluster configuration service.\n+    locator.invoke(() -> {\n+      InternalLocator internalLocator = ClusterStartupRule.getLocator();\n+      assertThat(internalLocator).isNotNull();\n+      CacheConfig config =\n+          internalLocator.getConfigurationPersistenceService().getCacheConfig(\"cluster\");\n+\n+      RegionConfig regionConfig = find(config.getRegions(), regionName);\n+      assertThat(regionConfig).isNotNull();\n+      assertThat(regionConfig.getRegionAttributes()).isNotNull();\n+      assertThat(regionConfig.getRegionAttributes().getGatewaySenderIds()).isNull();\n+    });\n+  }\n+\n+  @Test\n+  public void alterReplicateRegionWithParallelAsynchronousEventQueueShouldFailAndDoNotPersistChangesIntoTheClusterConfigurationService() {\n+    addIgnoredException(AsyncEventQueueConfigurationException.class);\n+    String regionName = testName.getMethodName();\n+    String asyncEventQueueName = testName.getMethodName() + \"_asyncEventQueue\";\n+\n+    gfsh.executeAndAssertThat(\n+        \"create async-event-queue --parallel=true --persistent=false --listener=org.apache.geode.internal.cache.wan.MyAsyncEventListener --id=\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e06789324d2561f739b341da63a6b9dc1c9d4453"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc2NjQzNQ==", "bodyText": "Another place to possibly use CommandStringBuilder.", "url": "https://github.com/apache/geode/pull/5070#discussion_r421766435", "createdAt": "2020-05-07T20:14:09Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/management/internal/cli/commands/AlterRegionCommandDUnitTest.java", "diffHunk": "@@ -343,4 +346,76 @@ public void alterPartitionPersistentRegionWithParallelNonPersistentGatewaySender\n       assertThat(regionConfig.getRegionAttributes().getGatewaySenderIds()).isBlank();\n     });\n   }\n+\n+  @Test\n+  public void alterReplicateRegionWithParallelGatewaySenderShouldFailAndDoNotPersistChangesIntoTheClusterConfigurationService() {\n+    addIgnoredException(GatewaySenderConfigurationException.class);\n+    addIgnoredException(\"could not get remote locator information\");\n+    String regionName = testName.getMethodName();\n+    String gatewaySenderId = testName.getMethodName() + \"_parallelGatewaySender\";\n+\n+    gfsh.executeAndAssertThat(\n+        \"create gateway-sender --parallel=true --enable-persistence=false --remote-distributed-system-id=2 --id=\"\n+            + gatewaySenderId)\n+        .statusIsSuccess().doesNotContainOutput(\"Did not complete waiting\");\n+    gfsh.executeAndAssertThat(\"create region --type=REPLICATE --name=\" + regionName)\n+        .statusIsSuccess();\n+    locator.waitUntilRegionIsReadyOnExactlyThisManyServers(SEPARATOR + regionName, 1);\n+\n+    // Associate the gateway-sender\n+    gfsh.executeAndAssertThat(\n+        \"alter region --name=\" + regionName + \" --gateway-sender-id=\" + gatewaySenderId)\n+        .statusIsError().containsOutput(\"server-1\", \"Parallel Gateway Sender \" + gatewaySenderId\n+            + \" can not be used with replicated region \" + SEPARATOR + regionName);\n+\n+    // Check the cluster configuration service.\n+    locator.invoke(() -> {\n+      InternalLocator internalLocator = ClusterStartupRule.getLocator();\n+      assertThat(internalLocator).isNotNull();\n+      CacheConfig config =\n+          internalLocator.getConfigurationPersistenceService().getCacheConfig(\"cluster\");\n+\n+      RegionConfig regionConfig = find(config.getRegions(), regionName);\n+      assertThat(regionConfig).isNotNull();\n+      assertThat(regionConfig.getRegionAttributes()).isNotNull();\n+      assertThat(regionConfig.getRegionAttributes().getGatewaySenderIds()).isNull();\n+    });\n+  }\n+\n+  @Test\n+  public void alterReplicateRegionWithParallelAsynchronousEventQueueShouldFailAndDoNotPersistChangesIntoTheClusterConfigurationService() {\n+    addIgnoredException(AsyncEventQueueConfigurationException.class);\n+    String regionName = testName.getMethodName();\n+    String asyncEventQueueName = testName.getMethodName() + \"_asyncEventQueue\";\n+\n+    gfsh.executeAndAssertThat(\n+        \"create async-event-queue --parallel=true --persistent=false --listener=org.apache.geode.internal.cache.wan.MyAsyncEventListener --id=\"\n+            + asyncEventQueueName)\n+        .statusIsSuccess();\n+    locator.waitUntilAsyncEventQueuesAreReadyOnExactlyThisManyServers(asyncEventQueueName, 1);\n+\n+    gfsh.executeAndAssertThat(\"create region --type=REPLICATE --name=\" + regionName)\n+        .statusIsSuccess();\n+    locator.waitUntilRegionIsReadyOnExactlyThisManyServers(SEPARATOR + regionName, 1);\n+\n+    // Associate the async-event-queue\n+    gfsh.executeAndAssertThat(\n+        \"alter region --name=\" + regionName + \" --async-event-queue-id=\" + asyncEventQueueName)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e06789324d2561f739b341da63a6b9dc1c9d4453"}, "originalPosition": 127}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2bd6553a2005c1e51b3ba0675268a89bd85feb30", "author": {"user": {"login": "jujoramos", "name": "Juan Jos\u00e9 Ramos"}}, "url": "https://github.com/apache/geode/commit/2bd6553a2005c1e51b3ba0675268a89bd85feb30", "committedDate": "2020-05-08T08:53:57Z", "message": "GEODE-8079: Changes requested by reviewers."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4MzQzMzc4", "url": "https://github.com/apache/geode/pull/5070#pullrequestreview-408343378", "createdAt": "2020-05-08T16:02:18Z", "commit": {"oid": "2bd6553a2005c1e51b3ba0675268a89bd85feb30"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4MzcwOTcw", "url": "https://github.com/apache/geode/pull/5070#pullrequestreview-408370970", "createdAt": "2020-05-08T16:46:17Z", "commit": {"oid": "2bd6553a2005c1e51b3ba0675268a89bd85feb30"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4704, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}