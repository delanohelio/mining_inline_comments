{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUzNjc4ODgy", "number": 5385, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNjowODoyMFrOEQsc8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNjoxNDoyNFrOEQsm7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1OTQwOTc2OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/acceptanceTest/java/session/NativeRedisSessionExpirationAcceptanceTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNjowODoyMFrOG0_UDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNjoyODowN1rOG1AHvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIxNjQ2MA==", "bodyText": "Normally when I see an ignore on a test I want to know why the test is being ignored. I think it is something we could fix and then have this test. In this case I think we are overriding a test that we will never do with native redis. It seems like the empty method impl takes care of that and you would not need the ignore. This is just my opinion, I'd be okay if you leave the ignore if you think that is best.", "url": "https://github.com/apache/geode/pull/5385#discussion_r458216460", "createdAt": "2020-07-21T16:08:20Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/acceptanceTest/java/session/NativeRedisSessionExpirationAcceptanceTest.java", "diffHunk": "@@ -50,4 +50,10 @@ public static void setup() {\n   public void sessionShouldTimeout_whenAppFailsOverToAnotherRedisServer() {\n     // Only using one server for Native Redis\n   }\n+\n+  @Test\n+  @Ignore", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0938a4c341c1f839d0c5fc84f7ac8205d30149d"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIyOTY5Mw==", "bodyText": "Just updated it and took out the ignores!", "url": "https://github.com/apache/geode/pull/5385#discussion_r458229693", "createdAt": "2020-07-21T16:28:07Z", "author": {"login": "sabbey37"}, "path": "geode-redis/src/acceptanceTest/java/session/NativeRedisSessionExpirationAcceptanceTest.java", "diffHunk": "@@ -50,4 +50,10 @@ public static void setup() {\n   public void sessionShouldTimeout_whenAppFailsOverToAnotherRedisServer() {\n     // Only using one server for Native Redis\n   }\n+\n+  @Test\n+  @Ignore", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIxNjQ2MA=="}, "originalCommit": {"oid": "d0938a4c341c1f839d0c5fc84f7ac8205d30149d"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1OTQzNTMyOnYy", "diffSide": "RIGHT", "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/session/SessionExpirationDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNjoxNDoyNFrOG0_kZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNjoyODoxOVrOG1AIMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIyMDY0Ng==", "bodyText": "instead of the hard coded \"113\", ask the PartitionedRegion for its max bucket. See PartitionedRegion.getTotalNumberOfBuckets. This will help in the future when we allow the redis bucket count to be configured", "url": "https://github.com/apache/geode/pull/5385#discussion_r458220646", "createdAt": "2020-07-21T16:14:24Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/session/SessionExpirationDUnitTest.java", "diffHunk": "@@ -86,15 +100,78 @@ public void sessionShouldTimeout_whenAppFailsOverToAnotherRedisServer() {\n     }\n   }\n \n+  @Test\n+  public void sessionShouldNotTimeout_whenPersisted() {\n+    String sessionCookie = createNewSessionWithNote(APP2, \"note1\");\n+    setMaxInactiveInterval(APP2, sessionCookie, -1);\n+\n+    compareMaxInactiveIntervals();\n+  }\n+\n   private void waitForTheSessionToExpire(String sessionId) {\n     GeodeAwaitility.await().ignoreExceptions().atMost((SHORT_SESSION_TIMEOUT + 5), TimeUnit.SECONDS)\n         .until(\n-            () -> jedisConnetedToServer1.ttl(\"spring:session:sessions:expires:\" + sessionId) < 0);\n+            () -> jedisConnetedToServer1.ttl(\"spring:session:sessions:expires:\" + sessionId) == -2);\n   }\n \n   private void refreshSession(String sessionCookie, int sessionApp) {\n     GeodeAwaitility.await()\n         .during(SHORT_SESSION_TIMEOUT + 2, TimeUnit.SECONDS)\n         .until(() -> getSessionNotes(sessionApp, sessionCookie) != null);\n   }\n+\n+  void setMaxInactiveInterval(int sessionApp, String sessionCookie, int maxInactiveInterval) {\n+    HttpHeaders requestHeaders = new HttpHeaders();\n+    requestHeaders.add(\"Cookie\", sessionCookie);\n+    HttpEntity<Integer> request = new HttpEntity<>(maxInactiveInterval, requestHeaders);\n+    new RestTemplate()\n+        .postForEntity(\n+            \"http://localhost:\" + ports.get(sessionApp) + \"/setMaxInactiveInterval\",\n+            request,\n+            Integer.class)\n+        .getHeaders();\n+  }\n+\n+  private void compareMaxInactiveIntervals() {\n+    cluster.getVM(1).invoke(() -> {\n+      for (int j = 0; j < 113; j++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0938a4c341c1f839d0c5fc84f7ac8205d30149d"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIyOTgxMQ==", "bodyText": "Good suggestion! Just updated it!", "url": "https://github.com/apache/geode/pull/5385#discussion_r458229811", "createdAt": "2020-07-21T16:28:19Z", "author": {"login": "sabbey37"}, "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/session/SessionExpirationDUnitTest.java", "diffHunk": "@@ -86,15 +100,78 @@ public void sessionShouldTimeout_whenAppFailsOverToAnotherRedisServer() {\n     }\n   }\n \n+  @Test\n+  public void sessionShouldNotTimeout_whenPersisted() {\n+    String sessionCookie = createNewSessionWithNote(APP2, \"note1\");\n+    setMaxInactiveInterval(APP2, sessionCookie, -1);\n+\n+    compareMaxInactiveIntervals();\n+  }\n+\n   private void waitForTheSessionToExpire(String sessionId) {\n     GeodeAwaitility.await().ignoreExceptions().atMost((SHORT_SESSION_TIMEOUT + 5), TimeUnit.SECONDS)\n         .until(\n-            () -> jedisConnetedToServer1.ttl(\"spring:session:sessions:expires:\" + sessionId) < 0);\n+            () -> jedisConnetedToServer1.ttl(\"spring:session:sessions:expires:\" + sessionId) == -2);\n   }\n \n   private void refreshSession(String sessionCookie, int sessionApp) {\n     GeodeAwaitility.await()\n         .during(SHORT_SESSION_TIMEOUT + 2, TimeUnit.SECONDS)\n         .until(() -> getSessionNotes(sessionApp, sessionCookie) != null);\n   }\n+\n+  void setMaxInactiveInterval(int sessionApp, String sessionCookie, int maxInactiveInterval) {\n+    HttpHeaders requestHeaders = new HttpHeaders();\n+    requestHeaders.add(\"Cookie\", sessionCookie);\n+    HttpEntity<Integer> request = new HttpEntity<>(maxInactiveInterval, requestHeaders);\n+    new RestTemplate()\n+        .postForEntity(\n+            \"http://localhost:\" + ports.get(sessionApp) + \"/setMaxInactiveInterval\",\n+            request,\n+            Integer.class)\n+        .getHeaders();\n+  }\n+\n+  private void compareMaxInactiveIntervals() {\n+    cluster.getVM(1).invoke(() -> {\n+      for (int j = 0; j < 113; j++) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIyMDY0Ng=="}, "originalCommit": {"oid": "d0938a4c341c1f839d0c5fc84f7ac8205d30149d"}, "originalPosition": 67}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4816, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}