{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAwOTUyNDc4", "number": 4928, "title": "GEODE-7971: Gw sender deliver TX events atomically to Gw receivers", "bodyText": "A new flag is added to gateway senders: group-transaction-events.\nIf set to true, events for the same transaction will not be\nspread across different batches, i.e. it is guaranteed that\nthey will be delivered inside the same batch.\nIn order to implement this behavior,\nthe last event for each transaction is marked with a new flag\nand the transactionId before it is put in the sender's queue\n(new flag added to GatewaySenderEvent). That way, it is possible\nfor the gateway senders to go through a\nbatch ready to be sent and verify if the last event for\neach transaction is present in the batch.\nIf not, the gateway sender will traverse the sender queue\nto get the missing events for the incomplete transactions\nand once they are added to the batch, the batch will be sent.\nThis feature has the following restrictions:\n\nThe group-transaction-events can only be set on\nserial gateway senders with just 1 dispatcher thread\nor on parallel gateway senders.\nIn order to guarantee that the events of a transaction\nare to not spread\nacross different batches, the regions involved in the\ntransaction must all have the same senders with the\ngroup-transaction-events flag set to true configured.\n\nThank you for submitting a contribution to Apache Geode.\nIn order to streamline the review of the contribution we ask you\nto ensure the following steps have been taken:\nFor all changes:\n\n\n Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?\n\n\n Has your PR been rebased against the latest commit within the target branch (typically develop)?\n\n\n Is your initial contribution a single, squashed commit?\n\n\n Does gradlew build run cleanly?\n\n\n Have you written or updated unit tests to verify your changes?\n\n\n If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under ASF 2.0?\n\n\nNote:\nPlease ensure that once the PR is submitted, check Concourse for build issues and\nsubmit an update to your PR as soon as possible. If you need help, please send an\nemail to dev@geode.apache.org.", "createdAt": "2020-04-08T16:26:47Z", "url": "https://github.com/apache/geode/pull/4928", "merged": true, "mergeCommit": {"oid": "e4328553fb5783e8310833df42e1f17e48dc2ac4"}, "closed": true, "closedAt": "2020-05-26T10:16:17Z", "author": {"login": "albertogpz"}, "timelineItems": {"totalCount": 42, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcVrtmYgBqjMyMTUyMDMwNDM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABclB7S0gFqTQxODE1OTU4Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "889672f409f1201c3bd548a7e47e8c6db78d34fc", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/889672f409f1201c3bd548a7e47e8c6db78d34fc", "committedDate": "2020-04-08T16:24:28Z", "message": "GEODE-7971: Gw sender deliver TX events atomically to Gw receivers\n\nA new flag is added to gateway senders: group-transaction-events.\nIf set to true, events for the same transaction will not be\nspread across different batches, i.e. it is guaranteed that\nthey will be delivered inside the same batch.\n\nIn order to implement this behavior,\nthe last event for each transaction is marked with a new flag\nand the transactionId before it is put in the sender's queue\n(new flag added to GatewaySenderEvent). That way, it is possible\nfor the gateway senders to go through a\nbatch ready to be sent and verify if the last event for\neach transaction is present in the batch.\nIf not, the gateway sender will traverse the sender queue\nto get the missing events for the incomplete transactions\nand once they are added to the batch, the batch will be sent.\n\nThis feature has the following restrictions:\n- The group-transaction-events can only be set on\nserial gateway senders with just 1 dispatcher thread\nor on parallel gateway senders.\n- In order to guarantee that the events of a transaction\nare to not spread\nacross different batches, the regions involved in the\ntransaction must all have the same senders with the\ngroup-transaction-events flag set to true configured."}, "afterCommit": {"oid": "0da146928a640788f5bffefac118a71533305799", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/0da146928a640788f5bffefac118a71533305799", "committedDate": "2020-04-08T17:53:14Z", "message": "GEODE-7971: Gw sender deliver TX events atomically to Gw receivers\n\nA new flag is added to gateway senders: group-transaction-events.\nIf set to true, events for the same transaction will not be\nspread across different batches, i.e. it is guaranteed that\nthey will be delivered inside the same batch.\n\nIn order to implement this behavior,\nthe last event for each transaction is marked with a new flag\nand the transactionId before it is put in the sender's queue\n(new flag added to GatewaySenderEvent). That way, it is possible\nfor the gateway senders to go through a\nbatch ready to be sent and verify if the last event for\neach transaction is present in the batch.\nIf not, the gateway sender will traverse the sender queue\nto get the missing events for the incomplete transactions\nand once they are added to the batch, the batch will be sent.\n\nThis feature has the following restrictions:\n- The group-transaction-events can only be set on\nserial gateway senders with just 1 dispatcher thread\nor on parallel gateway senders.\n- In order to guarantee that the events of a transaction\nare to not spread\nacross different batches, the regions involved in the\ntransaction must all have the same senders with the\ngroup-transaction-events flag set to true configured."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0da146928a640788f5bffefac118a71533305799", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/0da146928a640788f5bffefac118a71533305799", "committedDate": "2020-04-08T17:53:14Z", "message": "GEODE-7971: Gw sender deliver TX events atomically to Gw receivers\n\nA new flag is added to gateway senders: group-transaction-events.\nIf set to true, events for the same transaction will not be\nspread across different batches, i.e. it is guaranteed that\nthey will be delivered inside the same batch.\n\nIn order to implement this behavior,\nthe last event for each transaction is marked with a new flag\nand the transactionId before it is put in the sender's queue\n(new flag added to GatewaySenderEvent). That way, it is possible\nfor the gateway senders to go through a\nbatch ready to be sent and verify if the last event for\neach transaction is present in the batch.\nIf not, the gateway sender will traverse the sender queue\nto get the missing events for the incomplete transactions\nand once they are added to the batch, the batch will be sent.\n\nThis feature has the following restrictions:\n- The group-transaction-events can only be set on\nserial gateway senders with just 1 dispatcher thread\nor on parallel gateway senders.\n- In order to guarantee that the events of a transaction\nare to not spread\nacross different batches, the regions involved in the\ntransaction must all have the same senders with the\ngroup-transaction-events flag set to true configured."}, "afterCommit": {"oid": "83ff91505fa977b46506e7400a6fbaed15ef6a35", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/83ff91505fa977b46506e7400a6fbaed15ef6a35", "committedDate": "2020-04-09T07:31:55Z", "message": "GEODE-7971: Gw sender deliver TX events atomically to Gw receivers\n\nA new flag is added to gateway senders: group-transaction-events.\nIf set to true, events for the same transaction will not be\nspread across different batches, i.e. it is guaranteed that\nthey will be delivered inside the same batch.\n\nIn order to implement this behavior,\nthe last event for each transaction is marked with a new flag\nand the transactionId before it is put in the sender's queue\n(new flag added to GatewaySenderEvent). That way, it is possible\nfor the gateway senders to go through a\nbatch ready to be sent and verify if the last event for\neach transaction is present in the batch.\nIf not, the gateway sender will traverse the sender queue\nto get the missing events for the incomplete transactions\nand once they are added to the batch, the batch will be sent.\n\nThis feature has the following restrictions:\n- The group-transaction-events can only be set on\nserial gateway senders with just 1 dispatcher thread\nor on parallel gateway senders.\n- In order to guarantee that the events of a transaction\nare to not spread\nacross different batches, the regions involved in the\ntransaction must all have the same senders with the\ngroup-transaction-events flag set to true configured."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "83ff91505fa977b46506e7400a6fbaed15ef6a35", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/83ff91505fa977b46506e7400a6fbaed15ef6a35", "committedDate": "2020-04-09T07:31:55Z", "message": "GEODE-7971: Gw sender deliver TX events atomically to Gw receivers\n\nA new flag is added to gateway senders: group-transaction-events.\nIf set to true, events for the same transaction will not be\nspread across different batches, i.e. it is guaranteed that\nthey will be delivered inside the same batch.\n\nIn order to implement this behavior,\nthe last event for each transaction is marked with a new flag\nand the transactionId before it is put in the sender's queue\n(new flag added to GatewaySenderEvent). That way, it is possible\nfor the gateway senders to go through a\nbatch ready to be sent and verify if the last event for\neach transaction is present in the batch.\nIf not, the gateway sender will traverse the sender queue\nto get the missing events for the incomplete transactions\nand once they are added to the batch, the batch will be sent.\n\nThis feature has the following restrictions:\n- The group-transaction-events can only be set on\nserial gateway senders with just 1 dispatcher thread\nor on parallel gateway senders.\n- In order to guarantee that the events of a transaction\nare to not spread\nacross different batches, the regions involved in the\ntransaction must all have the same senders with the\ngroup-transaction-events flag set to true configured."}, "afterCommit": {"oid": "488cf2ec4b1a8320a55ad2018d9afa0dc09fe873", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/488cf2ec4b1a8320a55ad2018d9afa0dc09fe873", "committedDate": "2020-04-09T09:36:42Z", "message": "GEODE-7971: Gw sender deliver TX events atomically to Gw receivers\n\nA new flag is added to gateway senders: group-transaction-events.\nIf set to true, events for the same transaction will not be\nspread across different batches, i.e. it is guaranteed that\nthey will be delivered inside the same batch.\n\nIn order to implement this behavior,\nthe last event for each transaction is marked with a new flag\nand the transactionId before it is put in the sender's queue\n(new flag added to GatewaySenderEvent). That way, it is possible\nfor the gateway senders to go through a\nbatch ready to be sent and verify if the last event for\neach transaction is present in the batch.\nIf not, the gateway sender will traverse the sender queue\nto get the missing events for the incomplete transactions\nand once they are added to the batch, the batch will be sent.\n\nThis feature has the following restrictions:\n- The group-transaction-events can only be set on\nserial gateway senders with just 1 dispatcher thread\nor on parallel gateway senders.\n- In order to guarantee that the events of a transaction\nare to not spread\nacross different batches, the regions involved in the\ntransaction must all have the same senders with the\ngroup-transaction-events flag set to true configured."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "488cf2ec4b1a8320a55ad2018d9afa0dc09fe873", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/488cf2ec4b1a8320a55ad2018d9afa0dc09fe873", "committedDate": "2020-04-09T09:36:42Z", "message": "GEODE-7971: Gw sender deliver TX events atomically to Gw receivers\n\nA new flag is added to gateway senders: group-transaction-events.\nIf set to true, events for the same transaction will not be\nspread across different batches, i.e. it is guaranteed that\nthey will be delivered inside the same batch.\n\nIn order to implement this behavior,\nthe last event for each transaction is marked with a new flag\nand the transactionId before it is put in the sender's queue\n(new flag added to GatewaySenderEvent). That way, it is possible\nfor the gateway senders to go through a\nbatch ready to be sent and verify if the last event for\neach transaction is present in the batch.\nIf not, the gateway sender will traverse the sender queue\nto get the missing events for the incomplete transactions\nand once they are added to the batch, the batch will be sent.\n\nThis feature has the following restrictions:\n- The group-transaction-events can only be set on\nserial gateway senders with just 1 dispatcher thread\nor on parallel gateway senders.\n- In order to guarantee that the events of a transaction\nare to not spread\nacross different batches, the regions involved in the\ntransaction must all have the same senders with the\ngroup-transaction-events flag set to true configured."}, "afterCommit": {"oid": "a8c4c01f982760c62d08c6cb1fb38f751a524e06", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/a8c4c01f982760c62d08c6cb1fb38f751a524e06", "committedDate": "2020-04-09T09:53:54Z", "message": "GEODE-7971: Gw sender deliver TX events atomically to Gw receivers\n\nA new flag is added to gateway senders: group-transaction-events.\nIf set to true, events for the same transaction will not be\nspread across different batches, i.e. it is guaranteed that\nthey will be delivered inside the same batch.\n\nIn order to implement this behavior,\nthe last event for each transaction is marked with a new flag\nand the transactionId before it is put in the sender's queue\n(new flag added to GatewaySenderEvent). That way, it is possible\nfor the gateway senders to go through a\nbatch ready to be sent and verify if the last event for\neach transaction is present in the batch.\nIf not, the gateway sender will traverse the sender queue\nto get the missing events for the incomplete transactions\nand once they are added to the batch, the batch will be sent.\n\nThis feature has the following restrictions:\n- The group-transaction-events can only be set on\nserial gateway senders with just 1 dispatcher thread\nor on parallel gateway senders.\n- In order to guarantee that the events of a transaction\nare to not spread\nacross different batches, the regions involved in the\ntransaction must all have the same senders with the\ngroup-transaction-events flag set to true configured."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a8c4c01f982760c62d08c6cb1fb38f751a524e06", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/a8c4c01f982760c62d08c6cb1fb38f751a524e06", "committedDate": "2020-04-09T09:53:54Z", "message": "GEODE-7971: Gw sender deliver TX events atomically to Gw receivers\n\nA new flag is added to gateway senders: group-transaction-events.\nIf set to true, events for the same transaction will not be\nspread across different batches, i.e. it is guaranteed that\nthey will be delivered inside the same batch.\n\nIn order to implement this behavior,\nthe last event for each transaction is marked with a new flag\nand the transactionId before it is put in the sender's queue\n(new flag added to GatewaySenderEvent). That way, it is possible\nfor the gateway senders to go through a\nbatch ready to be sent and verify if the last event for\neach transaction is present in the batch.\nIf not, the gateway sender will traverse the sender queue\nto get the missing events for the incomplete transactions\nand once they are added to the batch, the batch will be sent.\n\nThis feature has the following restrictions:\n- The group-transaction-events can only be set on\nserial gateway senders with just 1 dispatcher thread\nor on parallel gateway senders.\n- In order to guarantee that the events of a transaction\nare to not spread\nacross different batches, the regions involved in the\ntransaction must all have the same senders with the\ngroup-transaction-events flag set to true configured."}, "afterCommit": {"oid": "c2bc5942c90049e6178e5dab502e8ba0a7784dd3", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/c2bc5942c90049e6178e5dab502e8ba0a7784dd3", "committedDate": "2020-04-10T18:57:32Z", "message": "GEODE-7971: Gw sender deliver TX events atomically to Gw receivers\n\nA new flag is added to gateway senders: group-transaction-events.\nIf set to true, events for the same transaction will not be\nspread across different batches, i.e. it is guaranteed that\nthey will be delivered inside the same batch.\n\nIn order to implement this behavior,\nthe last event for each transaction is marked with a new flag\nand the transactionId before it is put in the sender's queue\n(new flag added to GatewaySenderEvent). That way, it is possible\nfor the gateway senders to go through a\nbatch ready to be sent and verify if the last event for\neach transaction is present in the batch.\nIf not, the gateway sender will traverse the sender queue\nto get the missing events for the incomplete transactions\nand once they are added to the batch, the batch will be sent.\n\nThis feature has the following restrictions:\n- The group-transaction-events can only be set on\nserial gateway senders with just 1 dispatcher thread\nor on parallel gateway senders.\n- In order to guarantee that the events of a transaction\nare to not spread\nacross different batches, the regions involved in the\ntransaction must all have the same senders with the\ngroup-transaction-events flag set to true configured."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c2bc5942c90049e6178e5dab502e8ba0a7784dd3", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/c2bc5942c90049e6178e5dab502e8ba0a7784dd3", "committedDate": "2020-04-10T18:57:32Z", "message": "GEODE-7971: Gw sender deliver TX events atomically to Gw receivers\n\nA new flag is added to gateway senders: group-transaction-events.\nIf set to true, events for the same transaction will not be\nspread across different batches, i.e. it is guaranteed that\nthey will be delivered inside the same batch.\n\nIn order to implement this behavior,\nthe last event for each transaction is marked with a new flag\nand the transactionId before it is put in the sender's queue\n(new flag added to GatewaySenderEvent). That way, it is possible\nfor the gateway senders to go through a\nbatch ready to be sent and verify if the last event for\neach transaction is present in the batch.\nIf not, the gateway sender will traverse the sender queue\nto get the missing events for the incomplete transactions\nand once they are added to the batch, the batch will be sent.\n\nThis feature has the following restrictions:\n- The group-transaction-events can only be set on\nserial gateway senders with just 1 dispatcher thread\nor on parallel gateway senders.\n- In order to guarantee that the events of a transaction\nare to not spread\nacross different batches, the regions involved in the\ntransaction must all have the same senders with the\ngroup-transaction-events flag set to true configured."}, "afterCommit": {"oid": "8d149669673a9e6aa9810620efd9bdcfa07f4154", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/8d149669673a9e6aa9810620efd9bdcfa07f4154", "committedDate": "2020-04-11T07:53:42Z", "message": "GEODE-7971: Gw sender deliver TX events atomically to Gw receivers\n\nA new flag is added to gateway senders: group-transaction-events.\nIf set to true, events for the same transaction will not be\nspread across different batches, i.e. it is guaranteed that\nthey will be delivered inside the same batch.\n\nIn order to implement this behavior,\nthe last event for each transaction is marked with a new flag\nand the transactionId before it is put in the sender's queue\n(new flag added to GatewaySenderEvent). That way, it is possible\nfor the gateway senders to go through a\nbatch ready to be sent and verify if the last event for\neach transaction is present in the batch.\nIf not, the gateway sender will traverse the sender queue\nto get the missing events for the incomplete transactions\nand once they are added to the batch, the batch will be sent.\n\nThis feature has the following restrictions:\n- The group-transaction-events can only be set on\nserial gateway senders with just 1 dispatcher thread\nor on parallel gateway senders.\n- In order to guarantee that the events of a transaction\nare to not spread\nacross different batches, the regions involved in the\ntransaction must all have the same senders with the\ngroup-transaction-events flag set to true configured."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8d149669673a9e6aa9810620efd9bdcfa07f4154", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/8d149669673a9e6aa9810620efd9bdcfa07f4154", "committedDate": "2020-04-11T07:53:42Z", "message": "GEODE-7971: Gw sender deliver TX events atomically to Gw receivers\n\nA new flag is added to gateway senders: group-transaction-events.\nIf set to true, events for the same transaction will not be\nspread across different batches, i.e. it is guaranteed that\nthey will be delivered inside the same batch.\n\nIn order to implement this behavior,\nthe last event for each transaction is marked with a new flag\nand the transactionId before it is put in the sender's queue\n(new flag added to GatewaySenderEvent). That way, it is possible\nfor the gateway senders to go through a\nbatch ready to be sent and verify if the last event for\neach transaction is present in the batch.\nIf not, the gateway sender will traverse the sender queue\nto get the missing events for the incomplete transactions\nand once they are added to the batch, the batch will be sent.\n\nThis feature has the following restrictions:\n- The group-transaction-events can only be set on\nserial gateway senders with just 1 dispatcher thread\nor on parallel gateway senders.\n- In order to guarantee that the events of a transaction\nare to not spread\nacross different batches, the regions involved in the\ntransaction must all have the same senders with the\ngroup-transaction-events flag set to true configured."}, "afterCommit": {"oid": "2a6eac6877fb58a1630ad9bceea6e8f97e3854f5", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/2a6eac6877fb58a1630ad9bceea6e8f97e3854f5", "committedDate": "2020-04-11T10:59:52Z", "message": "GEODE-7971: Gw sender deliver TX events atomically to Gw receivers\n\nA new flag is added to gateway senders: group-transaction-events.\nIf set to true, events for the same transaction will not be\nspread across different batches, i.e. it is guaranteed that\nthey will be delivered inside the same batch.\n\nIn order to implement this behavior,\nthe last event for each transaction is marked with a new flag\nand the transactionId before it is put in the sender's queue\n(new flag added to GatewaySenderEvent). That way, it is possible\nfor the gateway senders to go through a\nbatch ready to be sent and verify if the last event for\neach transaction is present in the batch.\nIf not, the gateway sender will traverse the sender queue\nto get the missing events for the incomplete transactions\nand once they are added to the batch, the batch will be sent.\n\nThis feature has the following restrictions:\n- The group-transaction-events can only be set on\nserial gateway senders with just 1 dispatcher thread\nor on parallel gateway senders.\n- In order to guarantee that the events of a transaction\nare to not spread\nacross different batches, the regions involved in the\ntransaction must all have the same senders with the\ngroup-transaction-events flag set to true configured."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2a6eac6877fb58a1630ad9bceea6e8f97e3854f5", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/2a6eac6877fb58a1630ad9bceea6e8f97e3854f5", "committedDate": "2020-04-11T10:59:52Z", "message": "GEODE-7971: Gw sender deliver TX events atomically to Gw receivers\n\nA new flag is added to gateway senders: group-transaction-events.\nIf set to true, events for the same transaction will not be\nspread across different batches, i.e. it is guaranteed that\nthey will be delivered inside the same batch.\n\nIn order to implement this behavior,\nthe last event for each transaction is marked with a new flag\nand the transactionId before it is put in the sender's queue\n(new flag added to GatewaySenderEvent). That way, it is possible\nfor the gateway senders to go through a\nbatch ready to be sent and verify if the last event for\neach transaction is present in the batch.\nIf not, the gateway sender will traverse the sender queue\nto get the missing events for the incomplete transactions\nand once they are added to the batch, the batch will be sent.\n\nThis feature has the following restrictions:\n- The group-transaction-events can only be set on\nserial gateway senders with just 1 dispatcher thread\nor on parallel gateway senders.\n- In order to guarantee that the events of a transaction\nare to not spread\nacross different batches, the regions involved in the\ntransaction must all have the same senders with the\ngroup-transaction-events flag set to true configured."}, "afterCommit": {"oid": "dc11a43af87cd9ec917aceb02828f550594bff8e", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/dc11a43af87cd9ec917aceb02828f550594bff8e", "committedDate": "2020-04-11T14:21:22Z", "message": "GEODE-7971: Gw sender deliver TX events atomically to Gw receivers\n\nA new flag is added to gateway senders: group-transaction-events.\nIf set to true, events for the same transaction will not be\nspread across different batches, i.e. it is guaranteed that\nthey will be delivered inside the same batch.\n\nIn order to implement this behavior,\nthe last event for each transaction is marked with a new flag\nand the transactionId before it is put in the sender's queue\n(new flag added to GatewaySenderEvent). That way, it is possible\nfor the gateway senders to go through a\nbatch ready to be sent and verify if the last event for\neach transaction is present in the batch.\nIf not, the gateway sender will traverse the sender queue\nto get the missing events for the incomplete transactions\nand once they are added to the batch, the batch will be sent.\n\nThis feature has the following restrictions:\n- The group-transaction-events can only be set on\nserial gateway senders with just 1 dispatcher thread\nor on parallel gateway senders.\n- In order to guarantee that the events of a transaction\nare to not spread\nacross different batches, the regions involved in the\ntransaction must all have the same senders with the\ngroup-transaction-events flag set to true configured."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dc11a43af87cd9ec917aceb02828f550594bff8e", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/dc11a43af87cd9ec917aceb02828f550594bff8e", "committedDate": "2020-04-11T14:21:22Z", "message": "GEODE-7971: Gw sender deliver TX events atomically to Gw receivers\n\nA new flag is added to gateway senders: group-transaction-events.\nIf set to true, events for the same transaction will not be\nspread across different batches, i.e. it is guaranteed that\nthey will be delivered inside the same batch.\n\nIn order to implement this behavior,\nthe last event for each transaction is marked with a new flag\nand the transactionId before it is put in the sender's queue\n(new flag added to GatewaySenderEvent). That way, it is possible\nfor the gateway senders to go through a\nbatch ready to be sent and verify if the last event for\neach transaction is present in the batch.\nIf not, the gateway sender will traverse the sender queue\nto get the missing events for the incomplete transactions\nand once they are added to the batch, the batch will be sent.\n\nThis feature has the following restrictions:\n- The group-transaction-events can only be set on\nserial gateway senders with just 1 dispatcher thread\nor on parallel gateway senders.\n- In order to guarantee that the events of a transaction\nare to not spread\nacross different batches, the regions involved in the\ntransaction must all have the same senders with the\ngroup-transaction-events flag set to true configured."}, "afterCommit": {"oid": "e8e5ff0c9c52ca186289fadef1b6170284a82f6f", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/e8e5ff0c9c52ca186289fadef1b6170284a82f6f", "committedDate": "2020-04-11T19:14:15Z", "message": "GEODE-7971: Gw sender deliver TX events atomically to Gw receivers\n\nA new flag is added to gateway senders: group-transaction-events.\nIf set to true, events for the same transaction will not be\nspread across different batches, i.e. it is guaranteed that\nthey will be delivered inside the same batch.\n\nIn order to implement this behavior,\nthe last event for each transaction is marked with a new flag\nand the transactionId before it is put in the sender's queue\n(new flag added to GatewaySenderEvent). That way, it is possible\nfor the gateway senders to go through a\nbatch ready to be sent and verify if the last event for\neach transaction is present in the batch.\nIf not, the gateway sender will traverse the sender queue\nto get the missing events for the incomplete transactions\nand once they are added to the batch, the batch will be sent.\n\nThis feature has the following restrictions:\n- The group-transaction-events can only be set on\nserial gateway senders with just 1 dispatcher thread\nor on parallel gateway senders.\n- In order to guarantee that the events of a transaction\nare to not spread\nacross different batches, the regions involved in the\ntransaction must all have the same senders with the\ngroup-transaction-events flag set to true configured."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2Njk0NDE4", "url": "https://github.com/apache/geode/pull/4928#pullrequestreview-396694418", "createdAt": "2020-04-20T18:11:15Z", "commit": {"oid": "e8e5ff0c9c52ca186289fadef1b6170284a82f6f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxODoxMToxNlrOGIhSAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxODoxMToxNlrOGIhSAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU4NzA3NA==", "bodyText": "This looks similar to the other peekEventsFromIncompleteTransactions, is there a way to reuse the code?  Although the classes probably already do a lot of duplication ...", "url": "https://github.com/apache/geode/pull/4928#discussion_r411587074", "createdAt": "2020-04-20T18:11:16Z", "author": {"login": "jhuynh1"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueue.java", "diffHunk": "@@ -410,6 +441,53 @@ public Object peek() throws CacheException {\n     // so no need to worry about off-heap refCount.\n   }\n \n+  private void peekEventsFromIncompleteTransactions(List<AsyncEvent> batch,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8e5ff0c9c52ca186289fadef1b6170284a82f6f"}, "originalPosition": 125}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyMTgzMzQ0", "url": "https://github.com/apache/geode/pull/4928#pullrequestreview-402183344", "createdAt": "2020-04-28T20:23:58Z", "commit": {"oid": "cdcf0733380d3f8c7e14e0c39f3572a465bbaa9d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMDoyMzo1OVrOGNleKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMDoyMzo1OVrOGNleKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg5ODYwMQ==", "bodyText": "I'm not sure the cache8_0.dtd should be changed. That implies that this property is supported in earlier versions.", "url": "https://github.com/apache/geode/pull/4928#discussion_r416898601", "createdAt": "2020-04-28T20:23:59Z", "author": {"login": "boglesby"}, "path": "geode-core/src/main/resources/org/apache/geode/cache/doc-files/cache8_0.dtd", "diffHunk": "@@ -675,6 +675,7 @@ As of 6.5 roll-oplogs is deprecated. Use disk-store-name instead.\n   alert-threshold              CDATA #IMPLIED\n   dispatcher-threads           CDATA #IMPLIED\n   order-policy                 CDATA #IMPLIED\n+  group-transaction-events     (false | true) #IMPLIED", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdcf0733380d3f8c7e14e0c39f3572a465bbaa9d"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyMTg2NTE4", "url": "https://github.com/apache/geode/pull/4928#pullrequestreview-402186518", "createdAt": "2020-04-28T20:28:28Z", "commit": {"oid": "cdcf0733380d3f8c7e14e0c39f3572a465bbaa9d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMDoyODoyOVrOGNlofw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMDoyODoyOVrOGNlofw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkwMTI0Nw==", "bodyText": "Maybe maxRetries should be parameterized.", "url": "https://github.com/apache/geode/pull/4928#discussion_r416901247", "createdAt": "2020-04-28T20:28:29Z", "author": {"login": "boglesby"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueue.java", "diffHunk": "@@ -1282,22 +1277,90 @@ public List peek(int batchSize, int timeToWait) throws InterruptedException, Cac\n           Thread.currentThread().interrupt();\n           break;\n         }\n-        continue;\n       }\n     }\n+\n+    if (batch.size() > 0) {\n+      peekEventsFromIncompleteTransactions(batch, incompleteTransactionsInBatch, prQ);\n+    }\n+\n     if (isDebugEnabled) {\n       logger.debug(\"{}: Peeked a batch of {} entries. The size of the queue is {}. localSize is {}\",\n           this, batch.size(), size(), localSize());\n     }\n+\n     if (batch.size() == 0) {\n       blockProcessorThreadIfRequired();\n     }\n     return batch;\n   }\n \n+  private boolean stopPeekingDueToTime(long currentTime, int timeToWait, long end) {\n+    final boolean isDebugEnabled = logger.isDebugEnabled();\n+    // If time to wait is -1 (don't wait) or time interval has elapsed\n+    if (isDebugEnabled) {\n+      logger.debug(\"{}: Peek current time: {}\", this, currentTime);\n+    }\n+    if (timeToWait == -1 || (end <= currentTime)) {\n+      if (isDebugEnabled) {\n+        logger.debug(\"{}: Peek breaking\", this);\n+      }\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  protected boolean isGroupTransactionEvents() {\n+    return sender.isGroupTransactionEvents();\n+  }\n+\n+  private void peekEventsFromIncompleteTransactions(List<GatewaySenderEventImpl> batch,\n+      Map<TransactionId, Integer> incompleteTransactionIdsInBatch, PartitionedRegion prQ) {\n+    if (!isGroupTransactionEvents()) {\n+      return;\n+    }\n+\n+    if (areAllTransactionsCompleteInBatch(incompleteTransactionIdsInBatch)) {\n+      return;\n+    }\n+\n+    int maxRetries = 2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdcf0733380d3f8c7e14e0c39f3572a465bbaa9d"}, "originalPosition": 123}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "21e5948f2b5b880b095c26495540f46656c5cc8a", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/21e5948f2b5b880b095c26495540f46656c5cc8a", "committedDate": "2020-05-02T19:27:18Z", "message": "GEODE-7971: Revert changes on cache*.dtd files"}, "afterCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/5556d772491d3167e326343bc73e2d5aaa30a31d", "committedDate": "2020-05-04T00:12:40Z", "message": "GEODE-7971: Undo changes on cache*.dtd files unneeded\n\nAlso changed a couple of timeouts in test cases."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3MTU1Nzc1", "url": "https://github.com/apache/geode/pull/4928#pullrequestreview-407155775", "createdAt": "2020-05-07T05:21:29Z", "commit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNToyMToyOVrOGRuzVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNToyMjo0NlrOGRu0qQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI0NTc4MQ==", "bodyText": "Since creation of 1.13 release is ongoing, I assume that this will go in 1.14 release. Do we need to update this method to toDataPre_GEODE_1_14_0_0", "url": "https://github.com/apache/geode/pull/4928#discussion_r421245781", "createdAt": "2020-05-07T05:21:29Z", "author": {"login": "mivanac"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/GatewaySenderEventImpl.java", "diffHunk": "@@ -692,6 +704,17 @@ public int getDSFID() {\n   @Override\n   public void toData(DataOutput out,\n       SerializationContext context) throws IOException {\n+    toDataPre_GEODE_1_13_0_0(out, context);\n+    boolean hasTransaction = this.transactionId != null;\n+    DataSerializer.writeBoolean(hasTransaction, out);\n+    if (hasTransaction) {\n+      DataSerializer.writeBoolean(this.isLastEventInTransaction, out);\n+      context.getSerializer().writeObject(this.transactionId, out);\n+    }\n+  }\n+\n+  public void toDataPre_GEODE_1_13_0_0(DataOutput out,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI0NjEyMQ==", "bodyText": "Same comment as above. Do we need to update this method to fromDataPre_GEODE_1_14_0_0?", "url": "https://github.com/apache/geode/pull/4928#discussion_r421246121", "createdAt": "2020-05-07T05:22:46Z", "author": {"login": "mivanac"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/GatewaySenderEventImpl.java", "diffHunk": "@@ -725,6 +748,18 @@ protected void serializeKey(DataOutput out,\n   @Override\n   public void fromData(DataInput in,\n       DeserializationContext context) throws IOException, ClassNotFoundException {\n+    fromDataPre_GEODE_1_13_0_0(in, context);\n+    if (version >= Version.GEODE_1_13_0.ordinal()) {\n+      boolean hasTransaction = DataSerializer.readBoolean(in);\n+      if (hasTransaction) {\n+        this.isLastEventInTransaction = DataSerializer.readBoolean(in);\n+        this.transactionId = context.getDeserializer().readObject(in);\n+      }\n+    }\n+  }\n+\n+  public void fromDataPre_GEODE_1_13_0_0(DataInput in, DeserializationContext context)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 119}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4NDI5ODI0", "url": "https://github.com/apache/geode/pull/4928#pullrequestreview-408429824", "createdAt": "2020-05-08T18:19:52Z", "commit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4NDMzOTE4", "url": "https://github.com/apache/geode/pull/4928#pullrequestreview-408433918", "createdAt": "2020-05-08T18:26:20Z", "commit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 88, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODoyNzozMlrOGSvJsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDoxODo0M1rOGS29aA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwMDA4Mg==", "bodyText": "gemfire_properties.html.md.erb should be updated to include this new property, as well as any other relevant documentation pages.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422300082", "createdAt": "2020-05-08T18:27:32Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/main/java/org/apache/geode/cache/wan/GatewaySender.java", "diffHunk": "@@ -153,6 +155,13 @@\n       .getInteger(GeodeGlossary.GEMFIRE_PREFIX + \"gateway-connection-retry-interval\", 1000)\n       .intValue();\n \n+  /**\n+   * Number of times to retry to get events for a transaction from the gateway sender queue\n+   */\n+  int GET_TRANSACTION_EVENTS_FROM_QUEUE_RETRIES =\n+      Integer.getInteger(GeodeGlossary.GEMFIRE_PREFIX + \"get-transaction-events-from-queue-retries\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwNjg5MQ==", "bodyText": "Per the recent discussion on the dev list regarding the use of default methods in interfaces, does this absolutely need to be default?", "url": "https://github.com/apache/geode/pull/4928#discussion_r422306891", "createdAt": "2020-05-08T18:41:04Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/InternalRegion.java", "diffHunk": "@@ -307,6 +307,11 @@ void cacheWriteBeforePut(EntryEventImpl event, Set netWriteRecipients, CacheWrit\n \n   void invokeTXCallbacks(EnumListenerEvent afterDestroy, EntryEventImpl ee, boolean b);\n \n+  default void invokeTXCallbacks(EnumListenerEvent afterDestroy, EntryEventImpl ee, boolean b,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM0OTk3Mw==", "bodyText": "Unnecessary semicolon here.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422349973", "createdAt": "2020-05-08T20:11:46Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtils.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.ServiceConfigurationError;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.wan.GatewaySender;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class TXLastEventInTransactionUtils {\n+  private static final Logger logger = LogService.getLogger();\n+\n+  /**\n+   * @param callbacks list of events belonging to a transaction\n+   *\n+   * @return the last event of the transaction.\n+   *         If the regions to which the events belong do not have senders\n+   *         that group transactions it returns null.\n+   *         If the regions to which the\n+   *         events belong have different sets of senders that group transactions\n+   *         then it throws a ServiceConfigurationError exception.\n+   */\n+  public static EntryEventImpl getLastTransactionEvent(List<EntryEventImpl> callbacks,\n+      Cache cache)\n+      throws ServiceConfigurationError {\n+    if (checkNoSendersGroupTransactionEvents(callbacks, cache)) {\n+      return null;\n+    }\n+\n+    List<Set> senderIdsPerEvent = getGroupingSendersPerEvent(callbacks, cache);\n+    if (senderIdsPerEvent.stream().distinct().count() > 1) {\n+      String info = eventsAndSendersPerEventToString(callbacks, senderIdsPerEvent);\n+      throw new ServiceConfigurationError(\n+          \"Not all events go to the same senders that group transactions. \" + info);\n+    } ;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM1NzQwNw==", "bodyText": "Could this comment be cleaned up?", "url": "https://github.com/apache/geode/pull/4928#discussion_r422357407", "createdAt": "2020-05-08T20:28:24Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/AbstractGatewaySenderEventProcessor.java", "diffHunk": "@@ -862,14 +868,14 @@ private void logEvents(String message, List<GatewaySenderEventImpl> events) {\n               event.getRawCallbackArgument(), this.sender.getMyDSId(), allRemoteDSIds);\n           event.setCallbackArgument(geCallbackArg);\n           GatewaySenderEventImpl pdxSenderEvent =\n-              new GatewaySenderEventImpl(EnumListenerEvent.AFTER_UPDATE, event, null); // OFFHEAP:\n-                                                                                       // event for\n-                                                                                       // pdx type\n-                                                                                       // meta data\n-                                                                                       // so it\n-                                                                                       // should\n-                                                                                       // never be\n-                                                                                       // off-heap\n+              new GatewaySenderEventImpl(EnumListenerEvent.AFTER_UPDATE, event, null, false); // OFFHEAP:\n+          // event for\n+          // pdx type\n+          // meta data\n+          // so it\n+          // should\n+          // never be\n+          // off-heap", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MTU4Mg==", "bodyText": "Is there a reason for the formatting changes to the method signatures in this class? If not, they should be returned to how they were.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422361582", "createdAt": "2020-05-08T20:37:48Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -373,7 +373,8 @@ public static Integer createSecondRemoteLocator(int dsId, int localPort, int rem\n   }\n \n   public static Integer createSecondRemoteLocatorWithAPI(int dsId, int localPort, int remoteLocPort,\n-      String hostnameForClients) throws IOException {\n+      String hostnameForClients)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MTk0OA==", "bodyText": "Another possibly unnecessary formatting change.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422361948", "createdAt": "2020-05-08T20:38:32Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -497,7 +498,8 @@ public static void createPersistentReplicatedRegion(String regionName, String se\n   }\n \n   public static void createReplicatedRegionWithAsyncEventQueue(String regionName,\n-      String asyncQueueIds, Boolean offHeap) {\n+      String asyncQueueIds,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MTk3OA==", "bodyText": "Another possibly unnecessary formatting change.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422361978", "createdAt": "2020-05-08T20:38:37Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -519,7 +521,9 @@ public static void createReplicatedRegionWithAsyncEventQueue(String regionName,\n   }\n \n   public static void createReplicatedRegionWithSenderAndAsyncEventQueue(String regionName,\n-      String senderIds, String asyncChannelId, Boolean offHeap) {\n+      String senderIds,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjAxMg==", "bodyText": "Another possibly unnecessary formatting change.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422362012", "createdAt": "2020-05-08T20:38:41Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -560,7 +564,8 @@ public static void createReplicatedRegion(String regionName, String senderIds, S\n   }\n \n   public static void createAsyncEventQueue(String asyncChannelId, boolean isParallel,\n-      Integer maxMemory, Integer batchSize, boolean isConflation, boolean isPersistent,\n+      Integer maxMemory, Integer batchSize,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjA1OA==", "bodyText": "Another possibly unnecessary formatting change.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422362058", "createdAt": "2020-05-08T20:38:46Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -589,7 +594,8 @@ public static void createAsyncEventQueue(String asyncChannelId, boolean isParall\n   }\n \n   public static void createPartitionedRegion(String regionName, String senderIds,\n-      Integer redundantCopies, Integer totalNumBuckets, Boolean offHeap) {\n+      Integer redundantCopies, Integer totalNumBuckets,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjA5Ng==", "bodyText": "Another possibly unnecessary formatting change.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422362096", "createdAt": "2020-05-08T20:38:51Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -619,7 +625,8 @@ public static void createPartitionedRegion(String regionName, String senderIds,\n \n   // TODO:OFFHEAP: add offheap flavor\n   public static void createPartitionedRegionWithPersistence(String regionName, String senderIds,\n-      Integer redundantCopies, Integer totalNumBuckets) {\n+      Integer redundantCopies,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjEzMQ==", "bodyText": "Another possibly unnecessary formatting change.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422362131", "createdAt": "2020-05-08T20:38:55Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -647,7 +654,9 @@ public static void createPartitionedRegionWithPersistence(String regionName, Str\n   }\n \n   public static void createColocatedPartitionedRegion(String regionName, String senderIds,\n-      Integer redundantCopies, Integer totalNumBuckets, String colocatedWith) {\n+      Integer redundantCopies,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjE5MA==", "bodyText": "Another possibly unnecessary formatting change.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422362190", "createdAt": "2020-05-08T20:39:01Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -691,7 +700,8 @@ public static void addAsyncEventQueueThroughAttributesMutator(String regionName,\n   }\n \n   public static void createPartitionedRegionAsAccessor(String regionName, String senderIds,\n-      Integer redundantCopies, Integer totalNumBuckets) {\n+      Integer redundantCopies,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjIyOQ==", "bodyText": "Another possibly unnecessary formatting change.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422362229", "createdAt": "2020-05-08T20:39:06Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -709,7 +719,10 @@ public static void createPartitionedRegionAsAccessor(String regionName, String s\n   }\n \n   public static void createPartitionedRegionWithSerialParallelSenderIds(String regionName,\n-      String serialSenderIds, String parallelSenderIds, String colocatedWith, Boolean offHeap) {\n+      String serialSenderIds,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjI1Mw==", "bodyText": "Another possibly unnecessary formatting change.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422362253", "createdAt": "2020-05-08T20:39:11Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -734,7 +747,8 @@ public static void createPartitionedRegionWithSerialParallelSenderIds(String reg\n   }\n \n   public static void createPersistentPartitionedRegion(String regionName, String senderIds,\n-      Integer redundantCopies, Integer totalNumBuckets, Boolean offHeap) {\n+      Integer redundantCopies,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjI4Ng==", "bodyText": "Another possibly unnecessary formatting change.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422362286", "createdAt": "2020-05-08T20:39:17Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -764,7 +778,9 @@ public static void createPersistentPartitionedRegion(String regionName, String s\n   }\n \n   public static void createCustomerOrderShipmentPartitionedRegion(String senderIds,\n-      Integer redundantCopies, Integer totalNumBuckets, Boolean offHeap) {\n+      Integer redundantCopies,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjM3Ng==", "bodyText": "Another possibly unnecessary formatting change.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422362376", "createdAt": "2020-05-08T20:39:29Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -830,7 +846,8 @@ public static void createCustomerOrderShipmentPartitionedRegion(String senderIds\n   }\n \n   public static void createColocatedPartitionedRegions(String regionName, String senderIds,\n-      Integer redundantCopies, Integer totalNumBuckets, Boolean offHeap) {\n+      Integer redundantCopies,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MjM3OQ==", "bodyText": "Another possibly unnecessary formatting change.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422362379", "createdAt": "2020-05-08T20:39:30Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java", "diffHunk": "@@ -858,7 +875,8 @@ public static void createColocatedPartitionedRegions(String regionName, String s\n   }\n \n   public static void createColocatedPartitionedRegions2(String regionName, String senderIds,\n-      Integer redundantCopies, Integer totalNumBuckets, Boolean offHeap) {\n+      Integer redundantCopies,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM5NjM0OA==", "bodyText": "The currentTime argument can be removed and replaced with a call to System.currentTimeMillis() inside the method.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422396348", "createdAt": "2020-05-08T22:02:27Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueue.java", "diffHunk": "@@ -1282,22 +1278,89 @@ public List peek(int batchSize, int timeToWait) throws InterruptedException, Cac\n           Thread.currentThread().interrupt();\n           break;\n         }\n-        continue;\n       }\n     }\n+\n+    if (batch.size() > 0) {\n+      peekEventsFromIncompleteTransactions(batch, incompleteTransactionsInBatch, prQ);\n+    }\n+\n     if (isDebugEnabled) {\n       logger.debug(\"{}: Peeked a batch of {} entries. The size of the queue is {}. localSize is {}\",\n           this, batch.size(), size(), localSize());\n     }\n+\n     if (batch.size() == 0) {\n       blockProcessorThreadIfRequired();\n     }\n     return batch;\n   }\n \n+  private boolean stopPeekingDueToTime(long currentTime, int timeToWait, long end) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM5OTE5MA==", "bodyText": "A more descriptive name for this variable might be lastEventIsPresentInTransaction.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422399190", "createdAt": "2020-05-08T22:12:02Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueue.java", "diffHunk": "@@ -1282,22 +1278,89 @@ public List peek(int batchSize, int timeToWait) throws InterruptedException, Cac\n           Thread.currentThread().interrupt();\n           break;\n         }\n-        continue;\n       }\n     }\n+\n+    if (batch.size() > 0) {\n+      peekEventsFromIncompleteTransactions(batch, incompleteTransactionsInBatch, prQ);\n+    }\n+\n     if (isDebugEnabled) {\n       logger.debug(\"{}: Peeked a batch of {} entries. The size of the queue is {}. localSize is {}\",\n           this, batch.size(), size(), localSize());\n     }\n+\n     if (batch.size() == 0) {\n       blockProcessorThreadIfRequired();\n     }\n     return batch;\n   }\n \n+  private boolean stopPeekingDueToTime(long currentTime, int timeToWait, long end) {\n+    final boolean isDebugEnabled = logger.isDebugEnabled();\n+    // If time to wait is -1 (don't wait) or time interval has elapsed\n+    if (isDebugEnabled) {\n+      logger.debug(\"{}: Peek current time: {}\", this, currentTime);\n+    }\n+    if (timeToWait == -1 || (end <= currentTime)) {\n+      if (isDebugEnabled) {\n+        logger.debug(\"{}: Peek breaking\", this);\n+      }\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  protected boolean isGroupTransactionEvents() {\n+    return sender.isGroupTransactionEvents();\n+  }\n+\n+  private void peekEventsFromIncompleteTransactions(List<GatewaySenderEventImpl> batch,\n+      Map<TransactionId, Integer> incompleteTransactionIdsInBatch, PartitionedRegion prQ) {\n+    if (!isGroupTransactionEvents()) {\n+      return;\n+    }\n+\n+    if (areAllTransactionsCompleteInBatch(incompleteTransactionIdsInBatch)) {\n+      return;\n+    }\n+\n+    for (Map.Entry<TransactionId, Integer> pendingTransaction : incompleteTransactionIdsInBatch\n+        .entrySet()) {\n+      TransactionId transactionId = pendingTransaction.getKey();\n+      int bucketId = pendingTransaction.getValue();\n+      boolean presentLastEventInTransaction = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwNDA4MQ==", "bodyText": "A more descriptive name for this variable might be lastEventIsPresentInTransaction.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422404081", "createdAt": "2020-05-08T22:28:26Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueue.java", "diffHunk": "@@ -410,6 +442,53 @@ public Object peek() throws CacheException {\n     // so no need to worry about off-heap refCount.\n   }\n \n+  private void peekEventsFromIncompleteTransactions(List<AsyncEvent> batch,\n+      Set<TransactionId> incompleteTransactionIdsInBatch, long lastKey) {\n+    if (!isGroupTransactionEvents()) {\n+      return;\n+    }\n+\n+    if (areAllTransactionsCompleteInBatch(incompleteTransactionIdsInBatch)) {\n+      return;\n+    }\n+\n+    for (TransactionId transactionId : incompleteTransactionIdsInBatch) {\n+      boolean presentLastEventInTransaction = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwNTgyNA==", "bodyText": "This try/catch shouldn't be necessary, I think. The test will automatically fail if an exception is thrown. The exception should instead be added to the test method signature.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422405824", "createdAt": "2020-05-08T22:34:18Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/BucketRegionQueueJUnitTest.java", "diffHunk": "@@ -120,4 +137,69 @@ public void testBasicDestroyConflationEnabledAndValueNotInRegion() {\n     // Invoke basicDestroy\n     this.bucketRegionQueue.basicDestroy(event, true, null, false);\n   }\n+\n+  @Test\n+  public void testGetElementsMatching() {\n+    ParallelGatewaySenderEventProcessor processor =\n+        ParallelGatewaySenderHelper.createParallelGatewaySenderEventProcessor(this.sender);\n+\n+    TransactionId tx1 = new TXId(null, 1);\n+    TransactionId tx2 = new TXId(null, 2);\n+    TransactionId tx3 = new TXId(null, 3);\n+\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEvent(1, tx1, false);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEvent(2, tx2, false);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEvent(3, tx1, true);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEvent(4, tx2, true);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEvent(5, tx3, false);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEvent(6, tx3, false);\n+    GatewaySenderEventImpl event7 = createMockGatewaySenderEvent(7, tx1, true);\n+\n+    this.bucketRegionQueue\n+        .cleanUpDestroyedTokensAndMarkGIIComplete(InitialImageOperation.GIIStatus.NO_GII);\n+\n+    try {\n+      this.bucketRegionQueue.addToQueue(Long.valueOf(1), event1);\n+      this.bucketRegionQueue.addToQueue(Long.valueOf(2), event2);\n+      this.bucketRegionQueue.addToQueue(Long.valueOf(3), event3);\n+      this.bucketRegionQueue.addToQueue(Long.valueOf(4), event4);\n+      this.bucketRegionQueue.addToQueue(Long.valueOf(5), event5);\n+      this.bucketRegionQueue.addToQueue(Long.valueOf(6), event6);\n+      this.bucketRegionQueue.addToQueue(Long.valueOf(7), event7);\n+\n+    } catch (ForceReattemptException e) {\n+      fail(\"Exception thrown: \" + e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwNzU3MA==", "bodyText": "Can this test have a more descriptive name? Test names should ideally describe what is being tested, what the conditions are, and what the expected result is.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422407570", "createdAt": "2020-05-08T22:40:49Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/BucketRegionQueueJUnitTest.java", "diffHunk": "@@ -120,4 +137,69 @@ public void testBasicDestroyConflationEnabledAndValueNotInRegion() {\n     // Invoke basicDestroy\n     this.bucketRegionQueue.basicDestroy(event, true, null, false);\n   }\n+\n+  @Test\n+  public void testGetElementsMatching() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwNzgxMQ==", "bodyText": "This test name could be more descriptive. Also, an exception is never thrown from this method, so the throws can be removed.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422407811", "createdAt": "2020-05-08T22:41:49Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.AssertionsForClassTypes.assertThatThrownBy;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ServiceConfigurationError;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.wan.GatewaySender;\n+\n+public class TXLastEventInTransactionUtilsTest {\n+\n+  public static final String SENDER_1 = \"sender1\";\n+  public static final String SENDER_2 = \"sender2\";\n+  public static final String SENDER_3 = \"sender3\";\n+  public static final String SENDER_4 = \"sender4\";\n+  public static final String SENDER_5 = \"sender5\";\n+\n+  Cache cache;\n+  InternalRegion region1;\n+  InternalRegion region2;\n+  InternalRegion region3;\n+  InternalRegion region4;\n+  InternalRegion region5;\n+  InternalRegion region6;\n+  InternalRegion region7;\n+  InternalRegion region8;\n+\n+  GatewaySender sender1;\n+  GatewaySender sender2;\n+  GatewaySender sender3;\n+  GatewaySender sender4;\n+\n+  @Before\n+  public void setUp() {\n+    sender1 = mock(GatewaySender.class);\n+    when(sender1.isGroupTransactionEvents()).thenReturn(false);\n+    sender2 = mock(GatewaySender.class);\n+    when(sender2.isGroupTransactionEvents()).thenReturn(false);\n+    sender3 = mock(GatewaySender.class);\n+    when(sender3.isGroupTransactionEvents()).thenReturn(true);\n+    sender4 = mock(GatewaySender.class);\n+    when(sender4.isGroupTransactionEvents()).thenReturn(true);\n+\n+    cache = mock(Cache.class);\n+    when(cache.getGatewaySender(SENDER_1)).thenReturn(sender1);\n+    when(cache.getGatewaySender(SENDER_2)).thenReturn(sender2);\n+    when(cache.getGatewaySender(SENDER_3)).thenReturn(sender3);\n+    when(cache.getGatewaySender(SENDER_4)).thenReturn(sender4);\n+    when(cache.getGatewaySender(SENDER_5)).thenReturn(null);\n+\n+    final String listSenderIdsForRegion1_2[] = {SENDER_1, SENDER_2};\n+    final String listSenderIdsForRegion3_4[] = {SENDER_3, SENDER_4};\n+    final String listSenderIdsForRegion5_6[] = {SENDER_1, SENDER_3};\n+    final String listSenderIdsForRegion7[] = {SENDER_3};\n+    final String listSenderIdsForRegion8[] = {SENDER_5};\n+\n+\n+    Set senderIdsForRegion1_2 = new HashSet(Arrays.asList(listSenderIdsForRegion1_2));\n+    Set senderIdsForRegion3_4 = new HashSet(Arrays.asList(listSenderIdsForRegion3_4));\n+    Set senderIdsForRegion5_6 = new HashSet(Arrays.asList(listSenderIdsForRegion5_6));\n+    Set senderIdsForRegion7 = new HashSet(Arrays.asList(listSenderIdsForRegion7));\n+    Set senderIdsForRegion8 = new HashSet(Arrays.asList(listSenderIdsForRegion8));\n+\n+    region1 = mock(InternalRegion.class);\n+    when(region1.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region2 = mock(InternalRegion.class);\n+    when(region2.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region3 = mock(InternalRegion.class);\n+    when(region3.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region4 = mock(InternalRegion.class);\n+    when(region4.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region5 = mock(InternalRegion.class);\n+    when(region5.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region6 = mock(InternalRegion.class);\n+    when(region6.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region7 = mock(InternalRegion.class);\n+    when(region7.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion7);\n+\n+    region8 = mock(InternalRegion.class);\n+    when(region8.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion8);\n+  }\n+\n+  @Test\n+  public void noSenderGroupingTransactions() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwOTA2Ng==", "bodyText": "Can these arrays be declared java-style rather than C-style: String[] listSenderIdsForRegion1_2", "url": "https://github.com/apache/geode/pull/4928#discussion_r422409066", "createdAt": "2020-05-08T22:46:57Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.AssertionsForClassTypes.assertThatThrownBy;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ServiceConfigurationError;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.wan.GatewaySender;\n+\n+public class TXLastEventInTransactionUtilsTest {\n+\n+  public static final String SENDER_1 = \"sender1\";\n+  public static final String SENDER_2 = \"sender2\";\n+  public static final String SENDER_3 = \"sender3\";\n+  public static final String SENDER_4 = \"sender4\";\n+  public static final String SENDER_5 = \"sender5\";\n+\n+  Cache cache;\n+  InternalRegion region1;\n+  InternalRegion region2;\n+  InternalRegion region3;\n+  InternalRegion region4;\n+  InternalRegion region5;\n+  InternalRegion region6;\n+  InternalRegion region7;\n+  InternalRegion region8;\n+\n+  GatewaySender sender1;\n+  GatewaySender sender2;\n+  GatewaySender sender3;\n+  GatewaySender sender4;\n+\n+  @Before\n+  public void setUp() {\n+    sender1 = mock(GatewaySender.class);\n+    when(sender1.isGroupTransactionEvents()).thenReturn(false);\n+    sender2 = mock(GatewaySender.class);\n+    when(sender2.isGroupTransactionEvents()).thenReturn(false);\n+    sender3 = mock(GatewaySender.class);\n+    when(sender3.isGroupTransactionEvents()).thenReturn(true);\n+    sender4 = mock(GatewaySender.class);\n+    when(sender4.isGroupTransactionEvents()).thenReturn(true);\n+\n+    cache = mock(Cache.class);\n+    when(cache.getGatewaySender(SENDER_1)).thenReturn(sender1);\n+    when(cache.getGatewaySender(SENDER_2)).thenReturn(sender2);\n+    when(cache.getGatewaySender(SENDER_3)).thenReturn(sender3);\n+    when(cache.getGatewaySender(SENDER_4)).thenReturn(sender4);\n+    when(cache.getGatewaySender(SENDER_5)).thenReturn(null);\n+\n+    final String listSenderIdsForRegion1_2[] = {SENDER_1, SENDER_2};\n+    final String listSenderIdsForRegion3_4[] = {SENDER_3, SENDER_4};\n+    final String listSenderIdsForRegion5_6[] = {SENDER_1, SENDER_3};\n+    final String listSenderIdsForRegion7[] = {SENDER_3};\n+    final String listSenderIdsForRegion8[] = {SENDER_5};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwOTI2Mg==", "bodyText": "This test name could be more descriptive. Also, an exception is never thrown from this method, so the throws can be removed.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422409262", "createdAt": "2020-05-08T22:47:49Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.AssertionsForClassTypes.assertThatThrownBy;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ServiceConfigurationError;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.wan.GatewaySender;\n+\n+public class TXLastEventInTransactionUtilsTest {\n+\n+  public static final String SENDER_1 = \"sender1\";\n+  public static final String SENDER_2 = \"sender2\";\n+  public static final String SENDER_3 = \"sender3\";\n+  public static final String SENDER_4 = \"sender4\";\n+  public static final String SENDER_5 = \"sender5\";\n+\n+  Cache cache;\n+  InternalRegion region1;\n+  InternalRegion region2;\n+  InternalRegion region3;\n+  InternalRegion region4;\n+  InternalRegion region5;\n+  InternalRegion region6;\n+  InternalRegion region7;\n+  InternalRegion region8;\n+\n+  GatewaySender sender1;\n+  GatewaySender sender2;\n+  GatewaySender sender3;\n+  GatewaySender sender4;\n+\n+  @Before\n+  public void setUp() {\n+    sender1 = mock(GatewaySender.class);\n+    when(sender1.isGroupTransactionEvents()).thenReturn(false);\n+    sender2 = mock(GatewaySender.class);\n+    when(sender2.isGroupTransactionEvents()).thenReturn(false);\n+    sender3 = mock(GatewaySender.class);\n+    when(sender3.isGroupTransactionEvents()).thenReturn(true);\n+    sender4 = mock(GatewaySender.class);\n+    when(sender4.isGroupTransactionEvents()).thenReturn(true);\n+\n+    cache = mock(Cache.class);\n+    when(cache.getGatewaySender(SENDER_1)).thenReturn(sender1);\n+    when(cache.getGatewaySender(SENDER_2)).thenReturn(sender2);\n+    when(cache.getGatewaySender(SENDER_3)).thenReturn(sender3);\n+    when(cache.getGatewaySender(SENDER_4)).thenReturn(sender4);\n+    when(cache.getGatewaySender(SENDER_5)).thenReturn(null);\n+\n+    final String listSenderIdsForRegion1_2[] = {SENDER_1, SENDER_2};\n+    final String listSenderIdsForRegion3_4[] = {SENDER_3, SENDER_4};\n+    final String listSenderIdsForRegion5_6[] = {SENDER_1, SENDER_3};\n+    final String listSenderIdsForRegion7[] = {SENDER_3};\n+    final String listSenderIdsForRegion8[] = {SENDER_5};\n+\n+\n+    Set senderIdsForRegion1_2 = new HashSet(Arrays.asList(listSenderIdsForRegion1_2));\n+    Set senderIdsForRegion3_4 = new HashSet(Arrays.asList(listSenderIdsForRegion3_4));\n+    Set senderIdsForRegion5_6 = new HashSet(Arrays.asList(listSenderIdsForRegion5_6));\n+    Set senderIdsForRegion7 = new HashSet(Arrays.asList(listSenderIdsForRegion7));\n+    Set senderIdsForRegion8 = new HashSet(Arrays.asList(listSenderIdsForRegion8));\n+\n+    region1 = mock(InternalRegion.class);\n+    when(region1.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region2 = mock(InternalRegion.class);\n+    when(region2.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region3 = mock(InternalRegion.class);\n+    when(region3.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region4 = mock(InternalRegion.class);\n+    when(region4.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region5 = mock(InternalRegion.class);\n+    when(region5.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region6 = mock(InternalRegion.class);\n+    when(region6.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region7 = mock(InternalRegion.class);\n+    when(region7.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion7);\n+\n+    region8 = mock(InternalRegion.class);\n+    when(region8.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion8);\n+  }\n+\n+  @Test\n+  public void noSenderGroupingTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region1);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region2);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(null, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void lastEventFoundAllSendersGroupTransactions() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwOTU0MQ==", "bodyText": "This test name could be more descriptive. Also, an exception is never thrown from this method, so the throws can be removed.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422409541", "createdAt": "2020-05-08T22:48:58Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.AssertionsForClassTypes.assertThatThrownBy;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ServiceConfigurationError;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.wan.GatewaySender;\n+\n+public class TXLastEventInTransactionUtilsTest {\n+\n+  public static final String SENDER_1 = \"sender1\";\n+  public static final String SENDER_2 = \"sender2\";\n+  public static final String SENDER_3 = \"sender3\";\n+  public static final String SENDER_4 = \"sender4\";\n+  public static final String SENDER_5 = \"sender5\";\n+\n+  Cache cache;\n+  InternalRegion region1;\n+  InternalRegion region2;\n+  InternalRegion region3;\n+  InternalRegion region4;\n+  InternalRegion region5;\n+  InternalRegion region6;\n+  InternalRegion region7;\n+  InternalRegion region8;\n+\n+  GatewaySender sender1;\n+  GatewaySender sender2;\n+  GatewaySender sender3;\n+  GatewaySender sender4;\n+\n+  @Before\n+  public void setUp() {\n+    sender1 = mock(GatewaySender.class);\n+    when(sender1.isGroupTransactionEvents()).thenReturn(false);\n+    sender2 = mock(GatewaySender.class);\n+    when(sender2.isGroupTransactionEvents()).thenReturn(false);\n+    sender3 = mock(GatewaySender.class);\n+    when(sender3.isGroupTransactionEvents()).thenReturn(true);\n+    sender4 = mock(GatewaySender.class);\n+    when(sender4.isGroupTransactionEvents()).thenReturn(true);\n+\n+    cache = mock(Cache.class);\n+    when(cache.getGatewaySender(SENDER_1)).thenReturn(sender1);\n+    when(cache.getGatewaySender(SENDER_2)).thenReturn(sender2);\n+    when(cache.getGatewaySender(SENDER_3)).thenReturn(sender3);\n+    when(cache.getGatewaySender(SENDER_4)).thenReturn(sender4);\n+    when(cache.getGatewaySender(SENDER_5)).thenReturn(null);\n+\n+    final String listSenderIdsForRegion1_2[] = {SENDER_1, SENDER_2};\n+    final String listSenderIdsForRegion3_4[] = {SENDER_3, SENDER_4};\n+    final String listSenderIdsForRegion5_6[] = {SENDER_1, SENDER_3};\n+    final String listSenderIdsForRegion7[] = {SENDER_3};\n+    final String listSenderIdsForRegion8[] = {SENDER_5};\n+\n+\n+    Set senderIdsForRegion1_2 = new HashSet(Arrays.asList(listSenderIdsForRegion1_2));\n+    Set senderIdsForRegion3_4 = new HashSet(Arrays.asList(listSenderIdsForRegion3_4));\n+    Set senderIdsForRegion5_6 = new HashSet(Arrays.asList(listSenderIdsForRegion5_6));\n+    Set senderIdsForRegion7 = new HashSet(Arrays.asList(listSenderIdsForRegion7));\n+    Set senderIdsForRegion8 = new HashSet(Arrays.asList(listSenderIdsForRegion8));\n+\n+    region1 = mock(InternalRegion.class);\n+    when(region1.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region2 = mock(InternalRegion.class);\n+    when(region2.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region3 = mock(InternalRegion.class);\n+    when(region3.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region4 = mock(InternalRegion.class);\n+    when(region4.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region5 = mock(InternalRegion.class);\n+    when(region5.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region6 = mock(InternalRegion.class);\n+    when(region6.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region7 = mock(InternalRegion.class);\n+    when(region7.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion7);\n+\n+    region8 = mock(InternalRegion.class);\n+    when(region8.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion8);\n+  }\n+\n+  @Test\n+  public void noSenderGroupingTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region1);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region2);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(null, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void lastEventFoundAllSendersGroupTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region3);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region4);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(event2, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void lastEventFoundNotAllSendersGroupTransactions() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxMDA0OA==", "bodyText": "This test name could be more descriptive. Also, an exception is never thrown from this method, so the throws can be removed.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422410048", "createdAt": "2020-05-08T22:51:08Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.AssertionsForClassTypes.assertThatThrownBy;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ServiceConfigurationError;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.wan.GatewaySender;\n+\n+public class TXLastEventInTransactionUtilsTest {\n+\n+  public static final String SENDER_1 = \"sender1\";\n+  public static final String SENDER_2 = \"sender2\";\n+  public static final String SENDER_3 = \"sender3\";\n+  public static final String SENDER_4 = \"sender4\";\n+  public static final String SENDER_5 = \"sender5\";\n+\n+  Cache cache;\n+  InternalRegion region1;\n+  InternalRegion region2;\n+  InternalRegion region3;\n+  InternalRegion region4;\n+  InternalRegion region5;\n+  InternalRegion region6;\n+  InternalRegion region7;\n+  InternalRegion region8;\n+\n+  GatewaySender sender1;\n+  GatewaySender sender2;\n+  GatewaySender sender3;\n+  GatewaySender sender4;\n+\n+  @Before\n+  public void setUp() {\n+    sender1 = mock(GatewaySender.class);\n+    when(sender1.isGroupTransactionEvents()).thenReturn(false);\n+    sender2 = mock(GatewaySender.class);\n+    when(sender2.isGroupTransactionEvents()).thenReturn(false);\n+    sender3 = mock(GatewaySender.class);\n+    when(sender3.isGroupTransactionEvents()).thenReturn(true);\n+    sender4 = mock(GatewaySender.class);\n+    when(sender4.isGroupTransactionEvents()).thenReturn(true);\n+\n+    cache = mock(Cache.class);\n+    when(cache.getGatewaySender(SENDER_1)).thenReturn(sender1);\n+    when(cache.getGatewaySender(SENDER_2)).thenReturn(sender2);\n+    when(cache.getGatewaySender(SENDER_3)).thenReturn(sender3);\n+    when(cache.getGatewaySender(SENDER_4)).thenReturn(sender4);\n+    when(cache.getGatewaySender(SENDER_5)).thenReturn(null);\n+\n+    final String listSenderIdsForRegion1_2[] = {SENDER_1, SENDER_2};\n+    final String listSenderIdsForRegion3_4[] = {SENDER_3, SENDER_4};\n+    final String listSenderIdsForRegion5_6[] = {SENDER_1, SENDER_3};\n+    final String listSenderIdsForRegion7[] = {SENDER_3};\n+    final String listSenderIdsForRegion8[] = {SENDER_5};\n+\n+\n+    Set senderIdsForRegion1_2 = new HashSet(Arrays.asList(listSenderIdsForRegion1_2));\n+    Set senderIdsForRegion3_4 = new HashSet(Arrays.asList(listSenderIdsForRegion3_4));\n+    Set senderIdsForRegion5_6 = new HashSet(Arrays.asList(listSenderIdsForRegion5_6));\n+    Set senderIdsForRegion7 = new HashSet(Arrays.asList(listSenderIdsForRegion7));\n+    Set senderIdsForRegion8 = new HashSet(Arrays.asList(listSenderIdsForRegion8));\n+\n+    region1 = mock(InternalRegion.class);\n+    when(region1.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region2 = mock(InternalRegion.class);\n+    when(region2.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region3 = mock(InternalRegion.class);\n+    when(region3.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region4 = mock(InternalRegion.class);\n+    when(region4.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region5 = mock(InternalRegion.class);\n+    when(region5.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region6 = mock(InternalRegion.class);\n+    when(region6.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region7 = mock(InternalRegion.class);\n+    when(region7.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion7);\n+\n+    region8 = mock(InternalRegion.class);\n+    when(region8.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion8);\n+  }\n+\n+  @Test\n+  public void noSenderGroupingTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region1);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region2);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(null, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void lastEventFoundAllSendersGroupTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region3);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region4);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(event2, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void lastEventFoundNotAllSendersGroupTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region5);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region6);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(event2, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void notAllEventsToSameGroupingSenders() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxMDA3NQ==", "bodyText": "This test name could be more descriptive. Also, an exception is never thrown from this method, so the throws can be removed.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422410075", "createdAt": "2020-05-08T22:51:14Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.AssertionsForClassTypes.assertThatThrownBy;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ServiceConfigurationError;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.wan.GatewaySender;\n+\n+public class TXLastEventInTransactionUtilsTest {\n+\n+  public static final String SENDER_1 = \"sender1\";\n+  public static final String SENDER_2 = \"sender2\";\n+  public static final String SENDER_3 = \"sender3\";\n+  public static final String SENDER_4 = \"sender4\";\n+  public static final String SENDER_5 = \"sender5\";\n+\n+  Cache cache;\n+  InternalRegion region1;\n+  InternalRegion region2;\n+  InternalRegion region3;\n+  InternalRegion region4;\n+  InternalRegion region5;\n+  InternalRegion region6;\n+  InternalRegion region7;\n+  InternalRegion region8;\n+\n+  GatewaySender sender1;\n+  GatewaySender sender2;\n+  GatewaySender sender3;\n+  GatewaySender sender4;\n+\n+  @Before\n+  public void setUp() {\n+    sender1 = mock(GatewaySender.class);\n+    when(sender1.isGroupTransactionEvents()).thenReturn(false);\n+    sender2 = mock(GatewaySender.class);\n+    when(sender2.isGroupTransactionEvents()).thenReturn(false);\n+    sender3 = mock(GatewaySender.class);\n+    when(sender3.isGroupTransactionEvents()).thenReturn(true);\n+    sender4 = mock(GatewaySender.class);\n+    when(sender4.isGroupTransactionEvents()).thenReturn(true);\n+\n+    cache = mock(Cache.class);\n+    when(cache.getGatewaySender(SENDER_1)).thenReturn(sender1);\n+    when(cache.getGatewaySender(SENDER_2)).thenReturn(sender2);\n+    when(cache.getGatewaySender(SENDER_3)).thenReturn(sender3);\n+    when(cache.getGatewaySender(SENDER_4)).thenReturn(sender4);\n+    when(cache.getGatewaySender(SENDER_5)).thenReturn(null);\n+\n+    final String listSenderIdsForRegion1_2[] = {SENDER_1, SENDER_2};\n+    final String listSenderIdsForRegion3_4[] = {SENDER_3, SENDER_4};\n+    final String listSenderIdsForRegion5_6[] = {SENDER_1, SENDER_3};\n+    final String listSenderIdsForRegion7[] = {SENDER_3};\n+    final String listSenderIdsForRegion8[] = {SENDER_5};\n+\n+\n+    Set senderIdsForRegion1_2 = new HashSet(Arrays.asList(listSenderIdsForRegion1_2));\n+    Set senderIdsForRegion3_4 = new HashSet(Arrays.asList(listSenderIdsForRegion3_4));\n+    Set senderIdsForRegion5_6 = new HashSet(Arrays.asList(listSenderIdsForRegion5_6));\n+    Set senderIdsForRegion7 = new HashSet(Arrays.asList(listSenderIdsForRegion7));\n+    Set senderIdsForRegion8 = new HashSet(Arrays.asList(listSenderIdsForRegion8));\n+\n+    region1 = mock(InternalRegion.class);\n+    when(region1.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region2 = mock(InternalRegion.class);\n+    when(region2.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);\n+\n+    region3 = mock(InternalRegion.class);\n+    when(region3.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region4 = mock(InternalRegion.class);\n+    when(region4.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);\n+\n+    region5 = mock(InternalRegion.class);\n+    when(region5.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region6 = mock(InternalRegion.class);\n+    when(region6.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);\n+\n+    region7 = mock(InternalRegion.class);\n+    when(region7.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion7);\n+\n+    region8 = mock(InternalRegion.class);\n+    when(region8.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion8);\n+  }\n+\n+  @Test\n+  public void noSenderGroupingTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region1);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region2);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(null, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void lastEventFoundAllSendersGroupTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region3);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region4);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(event2, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void lastEventFoundNotAllSendersGroupTransactions() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region5);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region6);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    EntryEventImpl lastTransactionEvent =\n+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);\n+\n+    assertEquals(event2, lastTransactionEvent);\n+  }\n+\n+  @Test\n+  public void notAllEventsToSameGroupingSenders() throws Exception {\n+    List<EntryEventImpl> events = new ArrayList();\n+    EntryEventImpl event1 = createMockEntryEventImpl(region3);\n+    EntryEventImpl event2 = createMockEntryEventImpl(region7);\n+\n+    events.add(event1);\n+    events.add(event2);\n+\n+    assertThatThrownBy(() -> TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache))\n+        .isInstanceOf(ServiceConfigurationError.class)\n+        .hasMessageContaining(\"Not all events go to the same senders that group transactions\");\n+  }\n+\n+  @Test\n+  public void senderNotFound() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxMzY2Mw==", "bodyText": "This test name could be more descriptive.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422413663", "createdAt": "2020-05-08T23:06:47Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {\n     assertThat(queue.isDREvent(cache, event)).isFalse();\n   }\n \n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxMzgxNA==", "bodyText": "This test name could be more descriptive.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422413814", "createdAt": "2020-05-08T23:07:25Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {\n     assertThat(queue.isDREvent(cache, event)).isFalse();\n   }\n \n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsAndTimeout()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxMzg0NQ==", "bodyText": "This test name could be more descriptive.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422413845", "createdAt": "2020-05-08T23:07:36Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {\n     assertThat(queue.isDREvent(cache, event)).isFalse();\n   }\n \n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsAndTimeout()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(null);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(-1, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNjYyNg==", "bodyText": "This method does not need to be static.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422416626", "createdAt": "2020-05-08T23:20:15Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {\n     assertThat(queue.isDREvent(cache, event)).isFalse();\n   }\n \n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsAndTimeout()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(null);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(-1, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(2, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(3, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  private static GatewaySenderEventImpl createGatewaySenderEventImpl(int transactionId,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNzEwOA==", "bodyText": "Does the value of timeToWait here need to be so large? Unit tests should typically be expected to complete in milliseconds, so having an entire second timeout seems excessive. Also, is there a reason for this value of 1000 specifically being used? It seems arbitrary.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422417108", "createdAt": "2020-05-08T23:22:39Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {\n     assertThat(queue.isDREvent(cache, event)).isFalse();\n   }\n \n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNzE0Ng==", "bodyText": "Another large, apparently arbitrary timeToWait value.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422417146", "createdAt": "2020-05-08T23:22:56Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {\n     assertThat(queue.isDREvent(cache, event)).isFalse();\n   }\n \n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNzI3Mw==", "bodyText": "Another large, apparently arbitrary timeToWait value.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422417273", "createdAt": "2020-05-08T23:23:29Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {\n     assertThat(queue.isDREvent(cache, event)).isFalse();\n   }\n \n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsAndTimeout()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(null);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(-1, 1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNzM4MA==", "bodyText": "Another large, apparently arbitrary timeToWait value.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422417380", "createdAt": "2020-05-08T23:23:58Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {\n     assertThat(queue.isDREvent(cache, event)).isFalse();\n   }\n \n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsAndTimeout()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(null);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(-1, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(2, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNzM5Mw==", "bodyText": "Another large, apparently arbitrary timeToWait value.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422417393", "createdAt": "2020-05-08T23:24:04Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {\n     assertThat(queue.isDREvent(cache, event)).isFalse();\n   }\n \n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsAndTimeout()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);\n+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(null);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+    backingList.add(event6);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(-1, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()\n+      throws Exception {\n+\n+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(1, false);\n+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(2, false);\n+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(1, true);\n+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(2, true);\n+\n+    Queue backingList = new LinkedList();\n+    backingList.add(event1);\n+    backingList.add(event2);\n+    backingList.add(event3);\n+    backingList.add(event4);\n+    backingList.add(event5);\n+\n+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);\n+\n+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,\n+        Collections.emptySet(), 0, 1, metaRegionFactory);\n+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(3, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNzQ5Ng==", "bodyText": "What is the purpose of waiting here? Thread.sleep() should be avoided in tests as it leads to flakiness, so is there something that can be used with GeodeAwaitility.await() instead?", "url": "https://github.com/apache/geode/pull/4928#discussion_r422417496", "createdAt": "2020-05-08T23:24:32Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -201,18 +306,40 @@ private BucketRegionQueue mockBucketRegionQueue(final Queue backingList) {\n     // mocked pr region\n     when(mockBucketRegion.getLocalMaxMemory()).thenReturn(100);\n     when(mockBucketRegion.size()).thenReturn(backingList.size());\n-\n     BucketRegionQueue bucketRegionQueue = mock(BucketRegionQueue.class);\n     when(bucketRegionQueue.getPartitionedRegion()).thenReturn(mockBucketRegion);\n-    when(bucketRegionQueue.peek()).thenAnswer((Answer) invocation -> backingList.poll());\n+    when(bucketRegionQueue.peek())\n+        .thenAnswer((Answer) invocation -> pollAndWaitIfNull(backingList));\n+    when(bucketRegionQueue.getElementsMatching(any(), any()))\n+        .thenAnswer((Answer) invocation -> Arrays\n+            .asList(new Object[] {getFirstNotNull(backingList)}));\n     return bucketRegionQueue;\n   }\n \n+  private Object pollAndWaitIfNull(Queue queue) {\n+    Object object = queue.poll();\n+    if (object == null) {\n+      try {\n+        Thread.sleep(10);\n+      } catch (InterruptedException e) {\n+        e.printStackTrace();\n+      }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODMzMA==", "bodyText": "This test name could be more descriptive. Also, an exception is never thrown from this method, so the throws can be removed.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422418330", "createdAt": "2020-05-08T23:28:37Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODM0OA==", "bodyText": "This test name could be more descriptive. Also, an exception is never thrown from this method, so the throws can be removed.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422418348", "createdAt": "2020-05-08T23:28:42Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+    queue.put(event6);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsTimeout()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODM5MA==", "bodyText": "This test name could be more descriptive. Also, an exception is never thrown from this method, so the throws can be removed.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422418390", "createdAt": "2020-05-08T23:28:50Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+    queue.put(event6);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsTimeout()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair1 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(0L, event1);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair2 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(1L, event2);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair3 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(2L, event3);\n+\n+    TestableSerialGatewaySenderQueue realQueue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    TestableSerialGatewaySenderQueue queue = spy(realQueue);\n+    queue.setGroupTransactionEvents(true);\n+\n+    doAnswer(invocation -> eventPair1)\n+        .doAnswer(invocation -> eventPair2)\n+        .doAnswer(invocation -> eventPair3)\n+        .doAnswer(invocation -> null)\n+        .when(queue).peekAhead();\n+\n+    doAnswer(invocation -> new SerialGatewaySenderQueue.EventsAndLastKey(\n+        Arrays.asList(new Object[] {event4}), 2L))\n+            .when(queue).getElementsMatching(any(), any(), anyLong());\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODYyMQ==", "bodyText": "This method doesn't need to be static.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422418621", "createdAt": "2020-05-08T23:29:53Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+    queue.put(event6);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsTimeout()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair1 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(0L, event1);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair2 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(1L, event2);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair3 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(2L, event3);\n+\n+    TestableSerialGatewaySenderQueue realQueue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    TestableSerialGatewaySenderQueue queue = spy(realQueue);\n+    queue.setGroupTransactionEvents(true);\n+\n+    doAnswer(invocation -> eventPair1)\n+        .doAnswer(invocation -> eventPair2)\n+        .doAnswer(invocation -> eventPair3)\n+        .doAnswer(invocation -> null)\n+        .when(queue).peekAhead();\n+\n+    doAnswer(invocation -> new SerialGatewaySenderQueue.EventsAndLastKey(\n+        Arrays.asList(new Object[] {event4}), 2L))\n+            .when(queue).getElementsMatching(any(), any(), anyLong());\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(2, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(3, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  private static GatewaySenderEventImpl createMockGatewaySenderEventImpl(int transactionId,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODc4Ng==", "bodyText": "Does the value of timeToWait here need to be so large? Unit tests should typically be expected to complete in milliseconds, so having an entire second timeout seems excessive. Also, is there a reason for this value of 1000 specifically being used? It seems arbitrary.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422418786", "createdAt": "2020-05-08T23:30:42Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+    queue.put(event6);\n+\n+    List peeked = queue.peek(3, 1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODg1OA==", "bodyText": "Another large, seemingly arbitrary timeToWait value.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422418858", "createdAt": "2020-05-08T23:31:03Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+    queue.put(event6);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODkxMQ==", "bodyText": "Another large, seemingly arbitrary timeToWait value.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422418911", "createdAt": "2020-05-08T23:31:18Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+    queue.put(event6);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsTimeout()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair1 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(0L, event1);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair2 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(1L, event2);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair3 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(2L, event3);\n+\n+    TestableSerialGatewaySenderQueue realQueue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    TestableSerialGatewaySenderQueue queue = spy(realQueue);\n+    queue.setGroupTransactionEvents(true);\n+\n+    doAnswer(invocation -> eventPair1)\n+        .doAnswer(invocation -> eventPair2)\n+        .doAnswer(invocation -> eventPair3)\n+        .doAnswer(invocation -> null)\n+        .when(queue).peekAhead();\n+\n+    doAnswer(invocation -> new SerialGatewaySenderQueue.EventsAndLastKey(\n+        Arrays.asList(new Object[] {event4}), 2L))\n+            .when(queue).getElementsMatching(any(), any(), anyLong());\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(2, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+\n+    List peeked = queue.peek(3, 1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODkxOQ==", "bodyText": "Another large, seemingly arbitrary timeToWait value.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422418919", "createdAt": "2020-05-08T23:31:22Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+    queue.put(event6);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsTimeout()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair1 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(0L, event1);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair2 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(1L, event2);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair3 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(2L, event3);\n+\n+    TestableSerialGatewaySenderQueue realQueue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    TestableSerialGatewaySenderQueue queue = spy(realQueue);\n+    queue.setGroupTransactionEvents(true);\n+\n+    doAnswer(invocation -> eventPair1)\n+        .doAnswer(invocation -> eventPair2)\n+        .doAnswer(invocation -> eventPair3)\n+        .doAnswer(invocation -> null)\n+        .when(queue).peekAhead();\n+\n+    doAnswer(invocation -> new SerialGatewaySenderQueue.EventsAndLastKey(\n+        Arrays.asList(new Object[] {event4}), 2L))\n+            .when(queue).getElementsMatching(any(), any(), anyLong());\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(2, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(3, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMDE1Mg==", "bodyText": "Is there a way to test the new behaviour in SerialGatewaySenderQueue without creating an entire LocalRegion object here? Huge amounts of code that doesn't belong to SerialGatewaySenderQueue are being included in this test due to creating a real LocalRegion. If not, then this test should be an integration test rather than a unit test.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422420152", "createdAt": "2020-05-08T23:37:32Z", "author": {"login": "DonalEvans"}, "path": "geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan.serial;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.AttributesFactory;\n+import org.apache.geode.cache.Cache;\n+import org.apache.geode.cache.DataPolicy;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionAttributes;\n+import org.apache.geode.cache.Scope;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.GemFireCacheImpl;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.InternalRegionArguments;\n+import org.apache.geode.internal.cache.InternalRegionFactory;\n+import org.apache.geode.internal.cache.LocalRegion;\n+import org.apache.geode.internal.cache.TXId;\n+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;\n+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;\n+import org.apache.geode.internal.cache.wan.GatewaySenderStats;\n+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;\n+import org.apache.geode.internal.statistics.StatisticsClock;\n+import org.apache.geode.metrics.internal.NoopMeterRegistry;\n+\n+public class SerialGatewaySenderQueueJUnitTest {\n+\n+  private static final String TEST_REGION = \"testRegion\";\n+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;\n+  private GemFireCacheImpl cache;\n+  private AbstractGatewaySender sender;\n+  Region region;\n+  InternalRegionFactory regionFactory;\n+\n+  @Before\n+  public void setup() {\n+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);\n+    when(mockInternalDistributedSystem.getStatisticsManager())\n+        .thenReturn(new DummyStatisticsRegistry(\"\", 0));\n+\n+    cache = mock(GemFireCacheImpl.class);\n+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);\n+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());\n+\n+    region = createDistributedRegion(TEST_REGION, cache);\n+\n+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);\n+    when(regionFactory.setInternalMetaRegion(any())\n+        .setDestroyLockFlag(anyBoolean())\n+        .setSnapshotInputStream(any())\n+        .setImageTarget(any())\n+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())\n+        .setInternalRegion(anyBoolean())\n+        .setSerialGatewaySender(any())).thenReturn(regionFactory);\n+    when(regionFactory.create(TEST_REGION)).thenReturn(region);\n+\n+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);\n+\n+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);\n+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);\n+\n+    sender = mock(AbstractGatewaySender.class);\n+\n+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);\n+    when(sender.getCache()).thenReturn(cache);\n+    when(sender.getMaximumQueueMemory()).thenReturn(100);\n+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());\n+    when(sender.getId()).thenReturn(\"\");\n+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));\n+\n+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);\n+\n+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =\n+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);\n+\n+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);\n+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+    queue.setGroupTransactionEvents(true);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+    queue.put(event6);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(4, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  @Test\n+  public void peekedExtraEventsWhenIsGroupTransactionEventsTimeout()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair1 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(0L, event1);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair2 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(1L, event2);\n+    SerialGatewaySenderQueue.KeyAndEventPair eventPair3 =\n+        new SerialGatewaySenderQueue.KeyAndEventPair(2L, event3);\n+\n+    TestableSerialGatewaySenderQueue realQueue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    TestableSerialGatewaySenderQueue queue = spy(realQueue);\n+    queue.setGroupTransactionEvents(true);\n+\n+    doAnswer(invocation -> eventPair1)\n+        .doAnswer(invocation -> eventPair2)\n+        .doAnswer(invocation -> eventPair3)\n+        .doAnswer(invocation -> null)\n+        .when(queue).peekAhead();\n+\n+    doAnswer(invocation -> new SerialGatewaySenderQueue.EventsAndLastKey(\n+        Arrays.asList(new Object[] {event4}), 2L))\n+            .when(queue).getElementsMatching(any(), any(), anyLong());\n+\n+    List peeked = queue.peek(-1, 1);\n+    assertEquals(4, peeked.size());\n+  }\n+\n+  @Test\n+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()\n+      throws Exception {\n+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(1, false, region);\n+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(2, false, region);\n+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(1, true, region);\n+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(2, true, region);\n+\n+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,\n+        TEST_REGION, metaRegionFactory);\n+\n+    queue.put(event1);\n+    queue.put(event2);\n+    queue.put(event3);\n+    queue.put(event4);\n+    queue.put(event5);\n+\n+    List peeked = queue.peek(3, 1000);\n+    assertEquals(3, peeked.size());\n+    List peekedAfter = queue.peek(3, 1000);\n+    assertEquals(2, peekedAfter.size());\n+  }\n+\n+  private static GatewaySenderEventImpl createMockGatewaySenderEventImpl(int transactionId,\n+      boolean isLastEventInTransaction, Region region) {\n+    GatewaySenderEventImpl event = mock(GatewaySenderEventImpl.class);\n+    when(event.getTransactionId()).thenReturn(new TXId(null, transactionId));\n+    when(event.makeHeapCopyIfOffHeap()).thenReturn(event);\n+    when(event.isLastEventInTransaction()).thenReturn(isLastEventInTransaction);\n+    when(event.getRegion()).thenReturn(region);\n+    return event;\n+  }\n+\n+  private Region createDistributedRegion(String regionName, Cache cache) {\n+    AttributesFactory factory = new AttributesFactory();\n+    factory.setScope(Scope.DISTRIBUTED_ACK);\n+    factory.setDataPolicy(DataPolicy.NORMAL);\n+    RegionAttributes attrs = factory.create();\n+    InternalRegionArguments internalRegionArgs = new InternalRegionArguments();\n+    return new TestLocalRegion(regionName, attrs, null, (InternalCache) cache, internalRegionArgs,\n+        new TestStatisticsClock());\n+  }\n+\n+  public class TestLocalRegion extends LocalRegion {\n+    Map map = new ConcurrentHashMap();\n+\n+    public TestLocalRegion(String regionName, RegionAttributes attrs,\n+        LocalRegion parentRegion, InternalCache cache,\n+        InternalRegionArguments internalRegionArgs,\n+        StatisticsClock statisticsClock) {\n+      super(regionName, attrs, parentRegion, cache, internalRegionArgs, statisticsClock);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMzM1Nw==", "bodyText": "This test name could be more descriptive. Also an Exception is never thrown from this method, so the throws can be removed.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422423357", "createdAt": "2020-05-08T23:54:34Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMzU5Nw==", "bodyText": "This test name could be more descriptive. Also an Exception is never thrown from this method, so the throws can be removed.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422423597", "createdAt": "2020-05-08T23:55:54Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMzk5MQ==", "bodyText": "These casts to Integer are redundant.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422423991", "createdAt": "2020-05-08T23:58:14Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNDc2NQ==", "bodyText": "This method is deprecated and so should not be used. GeodeAwaitility.await() should be used when tests need to wait for some condition to be met before continuing.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422424765", "createdAt": "2020-05-09T00:02:20Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNDg5NQ==", "bodyText": "Redundant cast to Integer.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422424895", "createdAt": "2020-05-09T00:02:59Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTA1MQ==", "bodyText": "Deprecated method.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422425051", "createdAt": "2020-05-09T00:03:38Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 4 transactions of 3 events each are sent so that the first batch\n+    // would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // events of the third transaction are added to the batch which makes\n+    // that the batch is sent with 12 events.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTEzNA==", "bodyText": "This test name could be more descriptive.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422425134", "createdAt": "2020-05-09T00:03:57Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 4 transactions of 3 events each are sent so that the first batch\n+    // would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // events of the third transaction are added to the batch which makes\n+    // that the batch is sent with 12 events.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 1, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0, true));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTE3Mw==", "bodyText": "Redundant cast to Integer.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422425173", "createdAt": "2020-05-09T00:04:09Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 4 transactions of 3 events each are sent so that the first batch\n+    // would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // events of the third transaction are added to the batch which makes\n+    // that the batch is sent with 12 events.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 1, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0, true));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTM4NA==", "bodyText": "Thread.sleep() should be avoided in tests as it can lead to flakiness. GeodeAwaitility.await() should be used instead.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422425384", "createdAt": "2020-05-09T00:05:12Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 4 transactions of 3 events each are sent so that the first batch\n+    // would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // events of the third transaction are added to the batch which makes\n+    // that the batch is sent with 12 events.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 1, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0, true));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 24;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTQwNg==", "bodyText": "Deprecated method.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422425406", "createdAt": "2020-05-09T00:05:20Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 4 transactions of 3 events each are sent so that the first batch\n+    // would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // events of the third transaction are added to the batch which makes\n+    // that the batch is sent with 12 events.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 1, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0, true));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 24;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTQ2OQ==", "bodyText": "This test name could be more descriptive.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422425469", "createdAt": "2020-05-09T00:05:43Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 4 transactions of 3 events each are sent so that the first batch\n+    // would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // events of the third transaction are added to the batch which makes\n+    // that the batch is sent with 12 events.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 1, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0, true));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 24;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(3, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 3, true, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedGroupTransactions()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTUwMw==", "bodyText": "Redundant cast to Integer.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422425503", "createdAt": "2020-05-09T00:05:54Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 4 transactions of 3 events each are sent so that the first batch\n+    // would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // events of the third transaction are added to the batch which makes\n+    // that the batch is sent with 12 events.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 1, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0, true));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 24;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(3, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 3, true, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTYxNA==", "bodyText": "Use GeodeAwaitility.await() instead.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422425614", "createdAt": "2020-05-09T00:06:27Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 4 transactions of 3 events each are sent so that the first batch\n+    // would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // events of the third transaction are added to the batch which makes\n+    // that the batch is sent with 12 events.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 1, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0, true));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 24;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(3, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 3, true, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 24;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 8 transactions of 3 events each are sent so that the first batch\n+    // events would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // event of the third transaction is added to the batch which makes\n+    // that the first batch is sent with 12 events. The same happens with the\n+    // second batch which will contain 12 events too.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTY0Ng==", "bodyText": "Deprecated method.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422425646", "createdAt": "2020-05-09T00:06:38Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java", "diffHunk": "@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {\n \n   }\n \n+  @Test\n+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 2, true, false));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 12;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 4 transactions of 3 events each are sent so that the first batch\n+    // would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // events of the third transaction are added to the batch which makes\n+    // that the batch is sent with 12 events.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 1, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0, true));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 30000;\n+    boolean isGroupTransactionEvents = false;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 24;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);\n+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(3, entries, entries, true));\n+\n+    vm4.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, entries, entries));\n+    vm4.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 3, true, true));\n+\n+    vm5.invoke(() -> WANTestBase.checkQueueStats(\"ln\", 0, entries, 0, 0));\n+    vm5.invoke(() -> WANTestBase.checkBatchStats(\"ln\", 0));\n+  }\n+\n+  @Test\n+  public void testReplicatedSerialPropagationTransactionBatchRedistributedGroupTransactions()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);\n+\n+    int batchTimeInterval = 10000;\n+    boolean isGroupTransactionEvents = true;\n+    vm4.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm5.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm6.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+    vm7.invoke(\n+        () -> WANTestBase.createSender(\"ln\", 2, false, 100, 10, false, false, null, true,\n+            isGroupTransactionEvents,\n+            batchTimeInterval));\n+\n+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", null, isOffHeap()));\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + \"_RR\", \"ln\", isOffHeap()));\n+\n+    final Map keyValues = new HashMap();\n+    int entries = 24;\n+    for (int i = 0; i < entries; i++) {\n+      keyValues.put(i, i + \"_Value\");\n+    }\n+\n+    // 8 transactions of 3 events each are sent so that the first batch\n+    // events would initially contain the first 3 transactions complete and the first\n+    // event of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // event of the third transaction is added to the batch which makes\n+    // that the first batch is sent with 12 events. The same happens with the\n+    // second batch which will contain 12 events too.\n+    int eventsPerTransaction = 3;\n+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + \"_RR\", keyValues,\n+        eventsPerTransaction));\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    vm2.invoke(() -> WANTestBase.createReceiver());\n+\n+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + \"_RR\", entries));\n+\n+    pause(2000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjA0MA==", "bodyText": "Since the default unspecified value of group-transaction-events is false, does it need to be specified in the gfsh command here?", "url": "https://github.com/apache/geode/pull/4928#discussion_r422426040", "createdAt": "2020-05-09T00:08:55Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/wancommand/CreateDestroyGatewaySenderCommandDUnitTest.java", "diffHunk": "@@ -155,7 +155,8 @@ public void testCreateDestroyGatewaySender() {\n         + CliStrings.CREATE_GATEWAYSENDER__MAXQUEUEMEMORY + \"=1000\" + \" --\"\n         + CliStrings.CREATE_GATEWAYSENDER__ALERTTHRESHOLD + \"=100\" + \" --\"\n         + CliStrings.CREATE_GATEWAYSENDER__DISPATCHERTHREADS + \"=2\" + \" --\"\n-        + CliStrings.CREATE_GATEWAYSENDER__ORDERPOLICY + \"=THREAD\";\n+        + CliStrings.CREATE_GATEWAYSENDER__ORDERPOLICY + \"=THREAD\" + \" --\"\n+        + CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS + \"=false\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjI2Nw==", "bodyText": "Specifying the default value here is redundant.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422426267", "createdAt": "2020-05-09T00:09:57Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/wancommand/CreateDestroyGatewaySenderCommandDUnitTest.java", "diffHunk": "@@ -239,6 +241,7 @@ public void testCreateDestroyGatewaySenderWithGatewayEventFilters() {\n         + CliStrings.CREATE_GATEWAYSENDER__ALERTTHRESHOLD + \"=100\" + \" --\"\n         + CliStrings.CREATE_GATEWAYSENDER__DISPATCHERTHREADS + \"=2\" + \" --\"\n         + CliStrings.CREATE_GATEWAYSENDER__ORDERPOLICY + \"=THREAD\" + \" --\"\n+        + CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS + \"=false\" + \" --\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjMyMQ==", "bodyText": "Specifying the default value here is redundant.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422426321", "createdAt": "2020-05-09T00:10:12Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/wancommand/CreateDestroyGatewaySenderCommandDUnitTest.java", "diffHunk": "@@ -292,6 +295,7 @@ public void testCreateDestroyGatewaySenderWithGatewayTransportFilters() {\n         + CliStrings.CREATE_GATEWAYSENDER__ALERTTHRESHOLD + \"=100\" + \" --\"\n         + CliStrings.CREATE_GATEWAYSENDER__DISPATCHERTHREADS + \"=2\" + \" --\"\n         + CliStrings.CREATE_GATEWAYSENDER__ORDERPOLICY + \"=THREAD\" + \" --\"\n+        + CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS + \"=false\" + \" --\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjUyMA==", "bodyText": "Can these comments be cleaned up a bit?", "url": "https://github.com/apache/geode/pull/4928#discussion_r422426520", "createdAt": "2020-05-09T00:11:13Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -102,15 +108,18 @@ public void testQueueSizeInSecondaryBucketRegionQueuesWithMemberRestart() throws\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", NUM_PUTS));\n \n     assertEquals(NUM_PUTS, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue\n-                                                                                           // size\n-    assertEquals(NUM_PUTS * 2, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n-    assertEquals(NUM_PUTS * 2, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                               // queued\n+    // size\n+    assertEquals(NUM_PUTS * 2,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS * 2,\n+        v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n     assertEquals(0, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                    // distributed\n-    assertEquals(NUM_PUTS, v4List.get(10) + v5List.get(10) + v6List.get(10) + v7List.get(10)); // secondary\n-                                                                                               // queue\n-                                                                                               // size\n+    // distributed\n+    assertEquals(NUM_PUTS,\n+        v4List.get(10) + v5List.get(10) + v6List.get(10) + v7List.get(10)); // secondary\n+    // queue\n+    // size", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjY0Mw==", "bodyText": "More untidy comments.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422426643", "createdAt": "2020-05-09T00:11:49Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -137,7 +146,8 @@ public void testQueueSizeInSecondaryBucketRegionQueuesWithMemberRestart() throws\n     v5List = (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", NUM_PUTS));\n     v6List = (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", NUM_PUTS));\n     v7List = (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", NUM_PUTS));\n-    assertEquals(NUM_PUTS, v4List.get(10) + v5List.get(10) + v6List.get(10) + v7List.get(10)); // secondary\n+    assertEquals(NUM_PUTS,\n+        v4List.get(10) + v5List.get(10) + v6List.get(10) + v7List.get(10)); // secondary", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjY4Mw==", "bodyText": "More untidy comments.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422426683", "createdAt": "2020-05-09T00:11:56Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -159,10 +169,10 @@ public void testQueueSizeInSecondaryBucketRegionQueuesWithMemberRestart() throws\n     v7List = (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertEquals(0, v4List.get(10) + v5List.get(10) + v6List.get(10) + v7List.get(10)); // secondary\n-                                                                                        // queue\n-                                                                                        // size\n+    // queue\n+    // size", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjcxNA==", "bodyText": "More untidy comments.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422426714", "createdAt": "2020-05-09T00:12:04Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -194,15 +204,18 @@ public void testQueueSizeInSecondaryWithPrimarySwitch() throws Exception {\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", NUM_PUTS));\n \n     assertEquals(NUM_PUTS, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue\n-                                                                                           // size\n-    assertEquals(NUM_PUTS * 2, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n-    assertEquals(NUM_PUTS * 2, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                               // queued\n+    // size\n+    assertEquals(NUM_PUTS * 2,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS * 2,\n+        v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n     assertEquals(0, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                    // distributed\n-    assertEquals(NUM_PUTS, v4List.get(10) + v5List.get(10) + v6List.get(10) + v7List.get(10)); // secondary\n-                                                                                               // queue\n-                                                                                               // size\n+    // distributed\n+    assertEquals(NUM_PUTS,\n+        v4List.get(10) + v5List.get(10) + v6List.get(10) + v7List.get(10)); // secondary\n+    // queue\n+    // size", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjc2Mg==", "bodyText": "More untidy comments.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422426762", "createdAt": "2020-05-09T00:12:18Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -219,10 +232,10 @@ public void testQueueSizeInSecondaryWithPrimarySwitch() throws Exception {\n     v7List = (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertEquals(0, v4List.get(10) + v5List.get(10) + v6List.get(10) + v7List.get(10)); // secondary\n-                                                                                        // queue\n-                                                                                        // size\n+    // queue\n+    // size", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjc3Nw==", "bodyText": "More untidy comments.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422426777", "createdAt": "2020-05-09T00:12:22Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -254,16 +267,17 @@ public void testPartitionedRegionParallelPropagation_BeforeDispatch() throws Exc\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", NUM_PUTS));\n \n     assertEquals(NUM_PUTS, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue\n-                                                                                           // size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    // size\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(0, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                    // distributed\n+    // distributed\n     assertEquals(0, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n-                                                                                    // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjgwMA==", "bodyText": "More untidy comments.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422426800", "createdAt": "2020-05-09T00:12:31Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjk2Ng==", "bodyText": "This test name could be more descriptive. Also, the throws is not necessary.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422426966", "createdAt": "2020-05-09T00:13:18Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzA4NQ==", "bodyText": "Redundant case to Integer.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427085", "createdAt": "2020-05-09T00:13:52Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzIwMQ==", "bodyText": "More untidy comments.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427201", "createdAt": "2020-05-09T00:14:24Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzI2Mg==", "bodyText": "This test name could be more descriptive. Also, the throws is not needed.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427262", "createdAt": "2020-05-09T00:14:45Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzMxMQ==", "bodyText": "Redundant cast to Integer.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427311", "createdAt": "2020-05-09T00:14:58Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzQzNw==", "bodyText": "More untidy comments.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427437", "createdAt": "2020-05-09T00:15:43Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 3 transactions of 4 events each are sent so that the batch would\n+    // initially contain the first 2 transactions complete and the first\n+    // 2 events of the last transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the last transaction are added to the batch which makes\n+    // that only one batch of 12 events is sent.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 301}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzQ4Mw==", "bodyText": "This test name could be more descriptive.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427483", "createdAt": "2020-05-09T00:15:56Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 3 transactions of 4 events each are sent so that the batch would\n+    // initially contain the first 2 transactions complete and the first\n+    // 2 events of the last transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the last transaction are added to the batch which makes\n+    // that only one batch of 12 events is sent.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 305}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzUyOQ==", "bodyText": "Redundant cast to Integer.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427529", "createdAt": "2020-05-09T00:16:07Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 3 transactions of 4 events each are sent so that the batch would\n+    // initially contain the first 2 transactions complete and the first\n+    // 2 events of the last transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the last transaction are added to the batch which makes\n+    // that only one batch of 12 events is sent.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 308}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzU5OA==", "bodyText": "Use GeodeAwaitlity.await() instead.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427598", "createdAt": "2020-05-09T00:16:32Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 3 transactions of 4 events each are sent so that the batch would\n+    // initially contain the first 2 transactions complete and the first\n+    // 2 events of the last transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the last transaction are added to the batch which makes\n+    // that only one batch of 12 events is sent.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 6;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 345}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzY1Nw==", "bodyText": "More untidy comments.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427657", "createdAt": "2020-05-09T00:16:52Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 3 transactions of 4 events each are sent so that the batch would\n+    // initially contain the first 2 transactions complete and the first\n+    // 2 events of the last transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the last transaction are added to the batch which makes\n+    // that only one batch of 12 events is sent.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 6;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(3, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertTrue(\"Batch was not redistributed\",\n+        (v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)) > 0); // batches\n+    // redistributed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 372}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzcwOQ==", "bodyText": "This test name could be more descriptive.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427709", "createdAt": "2020-05-09T00:17:11Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 3 transactions of 4 events each are sent so that the batch would\n+    // initially contain the first 2 transactions complete and the first\n+    // 2 events of the last transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the last transaction are added to the batch which makes\n+    // that only one batch of 12 events is sent.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 6;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(3, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertTrue(\"Batch was not redistributed\",\n+        (v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)) > 0); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_GroupTransactionEvents()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 376}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzc0OA==", "bodyText": "Redundant cast to Integer.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427748", "createdAt": "2020-05-09T00:17:23Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 3 transactions of 4 events each are sent so that the batch would\n+    // initially contain the first 2 transactions complete and the first\n+    // 2 events of the last transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the last transaction are added to the batch which makes\n+    // that only one batch of 12 events is sent.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 6;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(3, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertTrue(\"Batch was not redistributed\",\n+        (v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)) > 0); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 379}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzg1OA==", "bodyText": "Use GeodeAwaitility.await() instead.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427858", "createdAt": "2020-05-09T00:17:54Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 3 transactions of 4 events each are sent so that the batch would\n+    // initially contain the first 2 transactions complete and the first\n+    // 2 events of the last transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the last transaction are added to the batch which makes\n+    // that only one batch of 12 events is sent.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 6;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(3, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertTrue(\"Batch was not redistributed\",\n+        (v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)) > 0); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 6;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 6 transactions of 4 events each are sent so that the first batch\n+    // would initially contain the first 2 transactions complete and the first\n+    // 2 events of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the second transaction are added to the batch which makes\n+    // that the first batch is sent with 12 events. The same happens with the\n+    // second batch which will contain 12 events too.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 426}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzg5Mw==", "bodyText": "More untidy comments.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427893", "createdAt": "2020-05-09T00:18:08Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(NUM_PUTS,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                           // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n \n     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));\n   }\n \n+  @Test\n+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 3;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 3 transactions of 4 events each are sent so that the batch would\n+    // initially contain the first 2 transactions complete and the first\n+    // 2 events of the last transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the last transaction are added to the batch which makes\n+    // that only one batch of 12 events is sent.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+    createReceiverInVMs(vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, false, batchTimeInterval);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 6;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(3, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertTrue(\"Batch was not redistributed\",\n+        (v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)) > 0); // batches\n+    // redistributed\n+  }\n+\n+  @Test\n+  public void testPartitionedRegionParallelPropagationBatchRedistributed_GroupTransactionEvents()\n+      throws Exception {\n+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));\n+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));\n+\n+    createCacheInVMs(nyPort, vm2);\n+\n+    int batchTimeInterval = 10000;\n+    createSenders(lnPort, true, batchTimeInterval);\n+\n+    createReceiverCustomerOrderShipmentPR(vm2, 0);\n+\n+    createSenderCustomerOrderShipmentPRs(0);\n+\n+    startSenderInVMs(\"ln\", vm4, vm5, vm6, vm7);\n+\n+\n+    final Map custKeyValue = new HashMap();\n+    int intCustId = 1;\n+    CustId custId = new CustId(intCustId);\n+    custKeyValue.put(custId, new Customer());\n+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));\n+\n+    int transactions = 6;\n+    final Map keyValues = new HashMap();\n+    for (int i = 0; i < transactions; i++) {\n+      OrderId orderId = new OrderId(i, custId);\n+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);\n+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);\n+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);\n+      keyValues.put(orderId, new Order());\n+      keyValues.put(shipmentId1, new Shipment());\n+      keyValues.put(shipmentId2, new Shipment());\n+      keyValues.put(shipmentId3, new Shipment());\n+    }\n+\n+    // 6 transactions of 4 events each are sent so that the first batch\n+    // would initially contain the first 2 transactions complete and the first\n+    // 2 events of the next transaction (10 entries).\n+    // As --group-transaction-events is configured in the senders, the remaining\n+    // 2 events of the second transaction are added to the batch which makes\n+    // that the first batch is sent with 12 events. The same happens with the\n+    // second batch which will contain 12 events too.\n+    int eventsPerTransaction = 4;\n+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,\n+        eventsPerTransaction));\n+\n+    int entries = (transactions * eventsPerTransaction) + 1;\n+\n+    // The receiver is started later in order for the batch to be redistributed (sent again)\n+    Thread.sleep(2000);\n+    createReceiverInVMs(vm2);\n+\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));\n+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));\n+\n+    ArrayList<Integer> v4List =\n+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v5List =\n+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v6List =\n+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+    ArrayList<Integer> v7List =\n+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n+\n+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n+    assertEquals(entries,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n+    // queued\n+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n+    // distributed\n+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches\n+    // distributed\n+    assertTrue(\"Batch was not redistributed\",\n+        (v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)) > 0); // batches\n+    // redistributed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 453}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzkyMA==", "bodyText": "More untidy comments.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427920", "createdAt": "2020-05-09T00:18:17Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -343,15 +653,16 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_Redundancy_3(\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(400, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(400,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(400, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                      // queued\n+    // queued\n     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                           // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 477}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzk1Ng==", "bodyText": "More untidy comments.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422427956", "createdAt": "2020-05-09T00:18:33Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -503,17 +815,16 @@ public void testParallelPropagationWithRemoteRegionDestroy() throws Exception {\n     ArrayList<Integer> v7List =\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", -1));\n \n-\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 1); // batches\n-                                                                                    // distributed :\n-                                                                                    // its quite\n-                                                                                    // possible that\n-                                                                                    // vm4 has\n-                                                                                    // distributed\n-                                                                                    // some of the\n-                                                                                    // batches.\n+    // distributed :\n+    // its quite\n+    // possible that\n+    // vm4 has\n+    // distributed\n+    // some of the\n+    // batches.\n     assertTrue(v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5) >= 1); // batches\n-                                                                                    // redistributed\n+    // redistributed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 525}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyODAwOA==", "bodyText": "More untidy comments.", "url": "https://github.com/apache/geode/pull/4928#discussion_r422428008", "createdAt": "2020-05-09T00:18:43Z", "author": {"login": "DonalEvans"}, "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java", "diffHunk": "@@ -559,17 +868,18 @@ public void testParallelPropagationWithFilter() throws Exception {\n         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats(\"ln\", 0));\n \n     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size\n-    assertEquals(1000, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n+    assertEquals(1000,\n+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived\n     assertEquals(900, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events\n-                                                                                      // queued\n+    // queued\n     assertEquals(800, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events\n-                                                                                      // distributed\n+    // distributed\n     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 80); // batches\n-                                                                                     // distributed\n+    // distributed\n     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches\n-                                                                                    // redistributed\n+    // redistributed\n     assertEquals(200, v4List.get(6) + v5List.get(6) + v6List.get(6) + v7List.get(6)); // events\n-                                                                                      // filtered\n+    // filtered", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5556d772491d3167e326343bc73e2d5aaa30a31d"}, "originalPosition": 559}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwMjQ4NDYx", "url": "https://github.com/apache/geode/pull/4928#pullrequestreview-410248461", "createdAt": "2020-05-12T17:06:07Z", "commit": {"oid": "8d02bba6ade5d8aea068ee856ec8e5bbbcfe62f4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNzowNjowN1rOGUQf8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNzowNjowN1rOGUQf8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5NTAyNw==", "bodyText": "This new option should be added to the docs for the create gateway-sender gfsh command in create.html.md.erb.", "url": "https://github.com/apache/geode/pull/4928#discussion_r423895027", "createdAt": "2020-05-12T17:06:07Z", "author": {"login": "DonalEvans"}, "path": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/CreateGatewaySenderCommand.java", "diffHunk": "@@ -75,6 +75,11 @@ public ResultModel createGatewaySender(\n           mandatory = true,\n           help = CliStrings.CREATE_GATEWAYSENDER__REMOTEDISTRIBUTEDSYSTEMID__HELP) Integer remoteDistributedSystemId,\n \n+      @CliOption(key = CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS,\n+          specifiedDefaultValue = \"true\",\n+          unspecifiedDefaultValue = \"false\",\n+          help = CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS__HELP) boolean groupTransactionEvents,\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d02bba6ade5d8aea068ee856ec8e5bbbcfe62f4"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNDU3NTU4", "url": "https://github.com/apache/geode/pull/4928#pullrequestreview-410457558", "createdAt": "2020-05-12T22:07:37Z", "commit": {"oid": "92b897bc0cd7dd914d06273df9018f9aae11b3aa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMjowNzozN1rOGUasGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMjowNzozN1rOGUasGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA2MTk3Ng==", "bodyText": "I think this should be --group-transaction-events(=value)? , since the value has a specified default value of true and so doesn't need to be included in all cases.", "url": "https://github.com/apache/geode/pull/4928#discussion_r424061976", "createdAt": "2020-05-12T22:07:37Z", "author": {"login": "DonalEvans"}, "path": "geode-docs/tools_modules/gfsh/command-pages/create.html.md.erb", "diffHunk": "@@ -504,6 +504,7 @@ create gateway-sender --id=value --remote-distributed-system-id=value\n    [--maximum-queue-memory=value] [--alert-threshold=value] [--dispatcher-threads=value] \n    [--order-policy=value][--gateway-event-filter=value(,value)*] \n    [--gateway-transport-filter=value(,value)*]\n+   [--group-transaction-events=value]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92b897bc0cd7dd914d06273df9018f9aae11b3aa"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExMDU0Mjg3", "url": "https://github.com/apache/geode/pull/4928#pullrequestreview-411054287", "createdAt": "2020-05-13T15:39:54Z", "commit": {"oid": "25cdae7121e27e8334cc2bac2bf8832fce107c2d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyOTIwNzAx", "url": "https://github.com/apache/geode/pull/4928#pullrequestreview-412920701", "createdAt": "2020-05-15T19:42:46Z", "commit": {"oid": "23472a799cd22d058cdf7be35b60e1c821325f13"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "441720cbdbdd55c6bbd2ceec6da63097a83873ac", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/441720cbdbdd55c6bbd2ceec6da63097a83873ac", "committedDate": "2020-05-18T19:03:54Z", "message": "feature/GEODE-7971: Documentation change after review and flaxy test fix"}, "afterCommit": {"oid": "2c9548b8b5b2409a352bf602980f95f3f4b94ce4", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/2c9548b8b5b2409a352bf602980f95f3f4b94ce4", "committedDate": "2020-05-18T19:29:57Z", "message": "feature/GEODE-7971: Documentation change after review and flaxy test fix"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e4c68ccf8df7fb9e0461e193b114466441b8e3fc", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/e4c68ccf8df7fb9e0461e193b114466441b8e3fc", "committedDate": "2020-05-22T08:34:47Z", "message": "Merge branch 'develop' into feature/GEODE-7971"}, "afterCommit": {"oid": "b9d61a1d04894b64b5c8bb4e97cad667a4ef0699", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/b9d61a1d04894b64b5c8bb4e97cad667a4ef0699", "committedDate": "2020-05-22T17:40:53Z", "message": "Merge branch 'develop' into feature/GEODE-7971\n\ni#"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MTA0NzYw", "url": "https://github.com/apache/geode/pull/4928#pullrequestreview-417104760", "createdAt": "2020-05-22T18:20:41Z", "commit": {"oid": "b9d61a1d04894b64b5c8bb4e97cad667a4ef0699"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b9d61a1d04894b64b5c8bb4e97cad667a4ef0699", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/b9d61a1d04894b64b5c8bb4e97cad667a4ef0699", "committedDate": "2020-05-22T17:40:53Z", "message": "Merge branch 'develop' into feature/GEODE-7971\n\ni#"}, "afterCommit": {"oid": "241be81ebe0ef9e810693cc7fcd2fc134140905c", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/241be81ebe0ef9e810693cc7fcd2fc134140905c", "committedDate": "2020-05-22T20:19:09Z", "message": "Merge branch 'develop' into feature/GEODE-7971"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "241be81ebe0ef9e810693cc7fcd2fc134140905c", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/241be81ebe0ef9e810693cc7fcd2fc134140905c", "committedDate": "2020-05-22T20:19:09Z", "message": "Merge branch 'develop' into feature/GEODE-7971"}, "afterCommit": {"oid": "b721d2a270df0ede630a8c8c499a98c110943ef1", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/b721d2a270df0ede630a8c8c499a98c110943ef1", "committedDate": "2020-05-22T23:13:29Z", "message": "Merge branch 'develop' into feature/GEODE-7971"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b721d2a270df0ede630a8c8c499a98c110943ef1", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/b721d2a270df0ede630a8c8c499a98c110943ef1", "committedDate": "2020-05-22T23:13:29Z", "message": "Merge branch 'develop' into feature/GEODE-7971"}, "afterCommit": {"oid": "4183c3f9727f8f94a16cceaa942fd16400125cb0", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/4183c3f9727f8f94a16cceaa942fd16400125cb0", "committedDate": "2020-05-23T07:34:39Z", "message": "Merge branch 'develop' into feature/GEODE-7971"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7b4eb1c83098c342e63e31540256b0c02d8b0f5d", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/7b4eb1c83098c342e63e31540256b0c02d8b0f5d", "committedDate": "2020-05-23T09:31:36Z", "message": "GEODE-7971: empty commit to retrigger CI"}, "afterCommit": {"oid": "e727fe3181779116ba742cf7a71133847ea71dfc", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/e727fe3181779116ba742cf7a71133847ea71dfc", "committedDate": "2020-05-23T17:46:45Z", "message": "GEODE-7971: empty commit to retrigger CI"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e727fe3181779116ba742cf7a71133847ea71dfc", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/e727fe3181779116ba742cf7a71133847ea71dfc", "committedDate": "2020-05-23T17:46:45Z", "message": "GEODE-7971: empty commit to retrigger CI"}, "afterCommit": {"oid": "d499407f1c2723c5487d1ec220f0e59e544ad79b", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/d499407f1c2723c5487d1ec220f0e59e544ad79b", "committedDate": "2020-05-23T19:53:37Z", "message": "GEODE-7971: empty commit to retrigger CI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c5c988a22e6600bfd7ba18635bfff4cc43dac6c", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/5c5c988a22e6600bfd7ba18635bfff4cc43dac6c", "committedDate": "2020-05-25T16:17:44Z", "message": "GEODE-7971: Gw sender deliver TX events atomically to Gw receivers\n\nA new flag is added to gateway senders: group-transaction-events.\nIf set to true, events for the same transaction will not be\nspread across different batches, i.e. it is guaranteed that\nthey will be delivered inside the same batch.\n\nIn order to implement this behavior,\nthe last event for each transaction is marked with a new flag\nand the transactionId before it is put in the sender's queue\n(new flag added to GatewaySenderEvent). That way, it is possible\nfor the gateway senders to go through a\nbatch ready to be sent and verify if the last event for\neach transaction is present in the batch.\nIf not, the gateway sender will traverse the sender queue\nto get the missing events for the incomplete transactions\nand once they are added to the batch, the batch will be sent.\n\nThis feature has the following restrictions:\n- The group-transaction-events can only be set on\nserial gateway senders with just 1 dispatcher thread\nor on parallel gateway senders.\n- In order to guarantee that the events of a transaction\nare to not spread\nacross different batches, the regions involved in the\ntransaction must all have the same senders with the\ngroup-transaction-events flag set to true configured."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35e33f42eb5584038f7f17ca5fdb08646987e459", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/35e33f42eb5584038f7f17ca5fdb08646987e459", "committedDate": "2020-05-25T16:17:45Z", "message": "GEODE-7971: small fix in gwSenderFactory + extra info on config error"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3ef15c6c6cb58519ef2b467268093d1448692e98", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/3ef15c6c6cb58519ef2b467268093d1448692e98", "committedDate": "2020-05-25T16:17:45Z", "message": "GEODE-7971: Add logic for case when batches are redistributed\n\nAlso added parameter for retries when not all\nevents for a transaction can be read from the queue."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6276ffba6a792d8231139962728cb4e261e2225c", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/6276ffba6a792d8231139962728cb4e261e2225c", "committedDate": "2020-05-25T16:17:45Z", "message": "GEODE-7971: Undo changes on cache*.dtd files unneeded\n\nAlso changed a couple of timeouts in test cases."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "53a62aef853952eab4b147daec8224d3bb350dd9", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/53a62aef853952eab4b147daec8224d3bb350dd9", "committedDate": "2020-05-25T16:17:45Z", "message": "feature/GEODE-7971: Changes after review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9675b4ef4f4467b31e4ab8dcd99632748de2858", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/f9675b4ef4f4467b31e4ab8dcd99632748de2858", "committedDate": "2020-05-25T16:17:45Z", "message": "feature/GEODE-7971: Simplify test JUnit test case"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eaf73c5a3e95dcc5677e3ccca32f4b666f292a5b", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/eaf73c5a3e95dcc5677e3ccca32f4b666f292a5b", "committedDate": "2020-05-25T16:17:45Z", "message": "GEODE-7971: Update create document and refactor test case"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a408067e3b7e183cb317ec31dce697d023315a6c", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/a408067e3b7e183cb317ec31dce697d023315a6c", "committedDate": "2020-05-25T16:17:45Z", "message": "GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.\n\nAlso corrected some documentation errors."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "549573a52dc5e35cab547343e48057626ddbac7d", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/549573a52dc5e35cab547343e48057626ddbac7d", "committedDate": "2020-05-25T16:17:45Z", "message": "GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d063a45d7d8bef09b6c08951467ff021a8d2b120", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/d063a45d7d8bef09b6c08951467ff021a8d2b120", "committedDate": "2020-05-25T16:17:45Z", "message": "feature/GEODE-7971: Documentation change after review and flaxy test fix"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8e9b171adb15168fa276cbfddda7deed7a1066b5", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/8e9b171adb15168fa276cbfddda7deed7a1066b5", "committedDate": "2020-05-25T13:47:19Z", "message": "GEODE-7971: Merge branch 'develop' into feature/GEODE-7971"}, "afterCommit": {"oid": "e1e12ed5c378c0effc94fc3dda21a7ea6d8e214d", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/e1e12ed5c378c0effc94fc3dda21a7ea6d8e214d", "committedDate": "2020-05-25T16:17:45Z", "message": "GEODE-7971: Doc changes after review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "855e2720570f33072665b19a4be083c96c4b8696", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/855e2720570f33072665b19a4be083c96c4b8696", "committedDate": "2020-05-26T08:21:19Z", "message": "GEODE-7971: Doc changes after review"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e1e12ed5c378c0effc94fc3dda21a7ea6d8e214d", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/e1e12ed5c378c0effc94fc3dda21a7ea6d8e214d", "committedDate": "2020-05-25T16:17:45Z", "message": "GEODE-7971: Doc changes after review"}, "afterCommit": {"oid": "855e2720570f33072665b19a4be083c96c4b8696", "author": {"user": {"login": "albertogpz", "name": "Alberto Gomez"}}, "url": "https://github.com/apache/geode/commit/855e2720570f33072665b19a4be083c96c4b8696", "committedDate": "2020-05-26T08:21:19Z", "message": "GEODE-7971: Doc changes after review"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4MTU5NTg3", "url": "https://github.com/apache/geode/pull/4928#pullrequestreview-418159587", "createdAt": "2020-05-26T10:15:57Z", "commit": {"oid": "855e2720570f33072665b19a4be083c96c4b8696"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4776, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}