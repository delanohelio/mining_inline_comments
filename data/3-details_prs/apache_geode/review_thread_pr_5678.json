{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTExMDkxOTQx", "number": 5678, "reviewThreads": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNjowMDoxMVrOEy4kqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNzowMTo0NVrOE2KlUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNzkxMTQ1OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/integrationTest/java/org/apache/geode/redis/internal/RedisStatsIntegrationTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNjowMDoxMVrOHpxfdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxODo0OTo0NVrOHqp-bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU2NDUzMg==", "bodyText": "We should use the awaitility timeout here: Math.toIntExact(GeodeAwaitility.getTimeout().toMillis())", "url": "https://github.com/apache/geode/pull/5678#discussion_r513564532", "createdAt": "2020-10-28T16:00:11Z", "author": {"login": "sabbey37"}, "path": "geode-redis/src/integrationTest/java/org/apache/geode/redis/internal/RedisStatsIntegrationTest.java", "diffHunk": "@@ -16,28 +16,469 @@\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.Before;\n import org.junit.ClassRule;\n import org.junit.Test;\n+import redis.clients.jedis.BitOP;\n import redis.clients.jedis.Jedis;\n \n import org.apache.geode.redis.GeodeRedisServerRule;\n import org.apache.geode.test.awaitility.GeodeAwaitility;\n \n public class RedisStatsIntegrationTest {\n+  public static final String EXISTING_HASH_KEY = \"Existing_Hash\";\n+  public static final String EXISTING_STRING_KEY = \"Existing_String\";\n+  public static final String EXISTING_SET_KEY_1 = \"Existing_Set_1\";\n+  public static final String EXISTING_SET_KEY_2 = \"Existing_Set_2\";\n+  public static final String NONEXISTENT_KEY = \"Nonexistent_Key\";\n+  Jedis jedis;\n+  long initialKeyspaceHits;\n+  long initialKeyspaceMisses;\n \n   @ClassRule\n   public static GeodeRedisServerRule server = new GeodeRedisServerRule();\n \n+  @Before\n+  public void setup() {\n+    jedis = new Jedis(\"localhost\", server.getPort(), 10000000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ae4b36cbf038c74dfb18648b2f15f68681e30ee"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ4NDA4Ng==", "bodyText": "done", "url": "https://github.com/apache/geode/pull/5678#discussion_r514484086", "createdAt": "2020-10-29T18:39:05Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/integrationTest/java/org/apache/geode/redis/internal/RedisStatsIntegrationTest.java", "diffHunk": "@@ -16,28 +16,469 @@\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.Before;\n import org.junit.ClassRule;\n import org.junit.Test;\n+import redis.clients.jedis.BitOP;\n import redis.clients.jedis.Jedis;\n \n import org.apache.geode.redis.GeodeRedisServerRule;\n import org.apache.geode.test.awaitility.GeodeAwaitility;\n \n public class RedisStatsIntegrationTest {\n+  public static final String EXISTING_HASH_KEY = \"Existing_Hash\";\n+  public static final String EXISTING_STRING_KEY = \"Existing_String\";\n+  public static final String EXISTING_SET_KEY_1 = \"Existing_Set_1\";\n+  public static final String EXISTING_SET_KEY_2 = \"Existing_Set_2\";\n+  public static final String NONEXISTENT_KEY = \"Nonexistent_Key\";\n+  Jedis jedis;\n+  long initialKeyspaceHits;\n+  long initialKeyspaceMisses;\n \n   @ClassRule\n   public static GeodeRedisServerRule server = new GeodeRedisServerRule();\n \n+  @Before\n+  public void setup() {\n+    jedis = new Jedis(\"localhost\", server.getPort(), 10000000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU2NDUzMg=="}, "originalCommit": {"oid": "2ae4b36cbf038c74dfb18648b2f15f68681e30ee"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ4OTk2Ng==", "bodyText": "done", "url": "https://github.com/apache/geode/pull/5678#discussion_r514489966", "createdAt": "2020-10-29T18:49:45Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/integrationTest/java/org/apache/geode/redis/internal/RedisStatsIntegrationTest.java", "diffHunk": "@@ -16,28 +16,469 @@\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.Before;\n import org.junit.ClassRule;\n import org.junit.Test;\n+import redis.clients.jedis.BitOP;\n import redis.clients.jedis.Jedis;\n \n import org.apache.geode.redis.GeodeRedisServerRule;\n import org.apache.geode.test.awaitility.GeodeAwaitility;\n \n public class RedisStatsIntegrationTest {\n+  public static final String EXISTING_HASH_KEY = \"Existing_Hash\";\n+  public static final String EXISTING_STRING_KEY = \"Existing_String\";\n+  public static final String EXISTING_SET_KEY_1 = \"Existing_Set_1\";\n+  public static final String EXISTING_SET_KEY_2 = \"Existing_Set_2\";\n+  public static final String NONEXISTENT_KEY = \"Nonexistent_Key\";\n+  Jedis jedis;\n+  long initialKeyspaceHits;\n+  long initialKeyspaceMisses;\n \n   @ClassRule\n   public static GeodeRedisServerRule server = new GeodeRedisServerRule();\n \n+  @Before\n+  public void setup() {\n+    jedis = new Jedis(\"localhost\", server.getPort(), 10000000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU2NDUzMg=="}, "originalCommit": {"oid": "2ae4b36cbf038c74dfb18648b2f15f68681e30ee"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxODQ4Mjg2OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/data/CommandHelper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxODowNDoxM1rOHp3GRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxODoyOTo1N1rOHqpSPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY1NjM4OQ==", "bodyText": "If we decide to increment the hits/misses this way, we could consolidate all of these and just have the if/else in the getRedisData method.", "url": "https://github.com/apache/geode/pull/5678#discussion_r513656389", "createdAt": "2020-10-28T18:04:13Z", "author": {"login": "sabbey37"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/data/CommandHelper.java", "diffHunk": "@@ -84,7 +84,13 @@ RedisData getRedisData(ByteArrayWrapper key, RedisData notFoundValue) {\n   }\n \n   RedisSet getRedisSet(ByteArrayWrapper key) {\n-    return checkSetType(getRedisData(key, NULL_REDIS_SET));\n+    RedisData redisData = getRedisData(key, NULL_REDIS_SET);\n+    if (redisData == NULL_REDIS_SET) {\n+      redisStats.incKeyspaceMisses();\n+    } else {\n+      redisStats.incKeyspaceHits();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ae4b36cbf038c74dfb18648b2f15f68681e30ee"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ3ODY1NA==", "bodyText": "will address in future stories that are coming to investigate overall functionality of this piece", "url": "https://github.com/apache/geode/pull/5678#discussion_r514478654", "createdAt": "2020-10-29T18:29:57Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/data/CommandHelper.java", "diffHunk": "@@ -84,7 +84,13 @@ RedisData getRedisData(ByteArrayWrapper key, RedisData notFoundValue) {\n   }\n \n   RedisSet getRedisSet(ByteArrayWrapper key) {\n-    return checkSetType(getRedisData(key, NULL_REDIS_SET));\n+    RedisData redisData = getRedisData(key, NULL_REDIS_SET);\n+    if (redisData == NULL_REDIS_SET) {\n+      redisStats.incKeyspaceMisses();\n+    } else {\n+      redisStats.incKeyspaceHits();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY1NjM4OQ=="}, "originalCommit": {"oid": "2ae4b36cbf038c74dfb18648b2f15f68681e30ee"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxODQ5Mzg1OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/data/RedisKeyCommandsFunctionExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxODowNjo0OFrOHp3NGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxODozMDoyN1rOHqpTeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY1ODEzOA==", "bodyText": "Similar to the comment in the CommandHelper class, if we decide to increment the hits/misses this way, we could consolidate all of these and just have the if/else in the getRedisData method.", "url": "https://github.com/apache/geode/pull/5678#discussion_r513658138", "createdAt": "2020-10-28T18:06:48Z", "author": {"login": "sabbey37"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/data/RedisKeyCommandsFunctionExecutor.java", "diffHunk": "@@ -33,12 +33,34 @@ public boolean del(ByteArrayWrapper key) {\n \n   @Override\n   public boolean exists(ByteArrayWrapper key) {\n-    return stripedExecute(key, () -> getRedisData(key).exists());\n+    boolean keyExists =\n+        stripedExecute(\n+            key,\n+            () -> getRedisData(key).exists());\n+\n+    if (keyExists) {\n+      helper.getRedisStats().incKeyspaceHits();\n+    } else {\n+      helper.getRedisStats().incKeyspaceMisses();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ae4b36cbf038c74dfb18648b2f15f68681e30ee"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ3ODk3MA==", "bodyText": "will address in future stories that are coming to investigate overall functionality of this piece", "url": "https://github.com/apache/geode/pull/5678#discussion_r514478970", "createdAt": "2020-10-29T18:30:27Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/data/RedisKeyCommandsFunctionExecutor.java", "diffHunk": "@@ -33,12 +33,34 @@ public boolean del(ByteArrayWrapper key) {\n \n   @Override\n   public boolean exists(ByteArrayWrapper key) {\n-    return stripedExecute(key, () -> getRedisData(key).exists());\n+    boolean keyExists =\n+        stripedExecute(\n+            key,\n+            () -> getRedisData(key).exists());\n+\n+    if (keyExists) {\n+      helper.getRedisStats().incKeyspaceHits();\n+    } else {\n+      helper.getRedisStats().incKeyspaceMisses();\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY1ODEzOA=="}, "originalCommit": {"oid": "2ae4b36cbf038c74dfb18648b2f15f68681e30ee"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxODQ5NzEwOnYy", "diffSide": "LEFT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/data/RedisStringCommandsFunctionExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxODowNzozNFrOHp3PHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxODozMTowNlrOHqpVGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY1ODY1NA==", "bodyText": "It seems strange that this was deleted.", "url": "https://github.com/apache/geode/pull/5678#discussion_r513658654", "createdAt": "2020-10-28T18:07:34Z", "author": {"login": "sabbey37"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/data/RedisStringCommandsFunctionExecutor.java", "diffHunk": "@@ -11,7 +11,6 @@\n  * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n  * or implied. See the License for the specific language governing permissions and limitations under\n  * the License.\n- *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ae4b36cbf038c74dfb18648b2f15f68681e30ee"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ3OTM4NA==", "bodyText": "good catch- not sure if that was a merge error?  weird", "url": "https://github.com/apache/geode/pull/5678#discussion_r514479384", "createdAt": "2020-10-29T18:31:06Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/data/RedisStringCommandsFunctionExecutor.java", "diffHunk": "@@ -11,7 +11,6 @@\n  * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n  * or implied. See the License for the specific language governing permissions and limitations under\n  * the License.\n- *", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY1ODY1NA=="}, "originalCommit": {"oid": "2ae4b36cbf038c74dfb18648b2f15f68681e30ee"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxODUxMTg1OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/integrationTest/java/org/apache/geode/redis/internal/executor/key/AbstractExistsIntegrationTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxODoxMToxNlrOHp3X7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxODo1MDoyMFrOHqp_zQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY2MDkxMQ==", "bodyText": "Since nothing else was changed in this file, and it's just a formatting change, maybe this could be reverted and we could allow spA to handle the formatting.", "url": "https://github.com/apache/geode/pull/5678#discussion_r513660911", "createdAt": "2020-10-28T18:11:16Z", "author": {"login": "sabbey37"}, "path": "geode-redis/src/integrationTest/java/org/apache/geode/redis/internal/executor/key/AbstractExistsIntegrationTest.java", "diffHunk": "@@ -61,7 +61,8 @@ public void givenKeyNotProvided_returnsWrongNumberOfArgumentsError() {\n \n   @Test\n   public void shouldReturnZero_givenKeyDoesNotExist() {\n-    assertThat(jedis.exists(toArray(\"doesNotExist\"))).isEqualTo(0L);\n+    assertThat(\n+        jedis.exists(toArray(\"doesNotExist\"))).isEqualTo(0L);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ae4b36cbf038c74dfb18648b2f15f68681e30ee"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ4NDg0Nw==", "bodyText": "will submit separate PR with format changes", "url": "https://github.com/apache/geode/pull/5678#discussion_r514484847", "createdAt": "2020-10-29T18:40:24Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/integrationTest/java/org/apache/geode/redis/internal/executor/key/AbstractExistsIntegrationTest.java", "diffHunk": "@@ -61,7 +61,8 @@ public void givenKeyNotProvided_returnsWrongNumberOfArgumentsError() {\n \n   @Test\n   public void shouldReturnZero_givenKeyDoesNotExist() {\n-    assertThat(jedis.exists(toArray(\"doesNotExist\"))).isEqualTo(0L);\n+    assertThat(\n+        jedis.exists(toArray(\"doesNotExist\"))).isEqualTo(0L);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY2MDkxMQ=="}, "originalCommit": {"oid": "2ae4b36cbf038c74dfb18648b2f15f68681e30ee"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ5MDMxNw==", "bodyText": "will create separate formatting pr", "url": "https://github.com/apache/geode/pull/5678#discussion_r514490317", "createdAt": "2020-10-29T18:50:20Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/integrationTest/java/org/apache/geode/redis/internal/executor/key/AbstractExistsIntegrationTest.java", "diffHunk": "@@ -61,7 +61,8 @@ public void givenKeyNotProvided_returnsWrongNumberOfArgumentsError() {\n \n   @Test\n   public void shouldReturnZero_givenKeyDoesNotExist() {\n-    assertThat(jedis.exists(toArray(\"doesNotExist\"))).isEqualTo(0L);\n+    assertThat(\n+        jedis.exists(toArray(\"doesNotExist\"))).isEqualTo(0L);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY2MDkxMQ=="}, "originalCommit": {"oid": "2ae4b36cbf038c74dfb18648b2f15f68681e30ee"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxODU2MzU3OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/server/InfoExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxODoyNDo0MFrOHp34kQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxODo1MzoxN1rOHqqGsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY2OTI2NQ==", "bodyText": "In Redis, if there are no keys in the database, info just displays # Keyspace with nothing after it. I like the idea of displaying 0 for those stats rather than nothing at all, but I'm not sure if there is any reason we need to emulate Redis's behavior?", "url": "https://github.com/apache/geode/pull/5678#discussion_r513669265", "createdAt": "2020-10-28T18:24:40Z", "author": {"login": "sabbey37"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/server/InfoExecutor.java", "diffHunk": "@@ -72,26 +78,91 @@ private String getSpecifiedSection(ExecutionHandlerContext context,\n   private String getServerSection(ExecutionHandlerContext context) {\n     final String CURRENT_REDIS_VERSION = \"5.0.6\";\n     final int TCP_PORT = context.getServerPort();\n+    final RedisStats redisStats = context.getRedisStats();\n     final String SERVER_STRING =\n         \"# Server\\r\\n\" +\n             \"redis_version:\" + CURRENT_REDIS_VERSION + \"\\r\\n\" +\n             \"redis_mode:standalone\\r\\n\" +\n-            \"tcp_port:\" + TCP_PORT + \"\\r\\n\";\n+            \"tcp_port:\" + TCP_PORT + \"\\r\\n\" +\n+            \"uptime_in_seconds:\" + redisStats.getUptimeInSeconds() + \"\\r\\n\" +\n+            \"uptime_in_days:\" + redisStats.getUptimeInDays() + \"\\r\\n\";\n     return SERVER_STRING;\n   }\n \n+  private String getClientsSection(ExecutionHandlerContext context) {\n+    final RedisStats redisStats = context.getRedisStats();\n+    final String CLIENTS_STRING =\n+        \"# Clients\\r\\n\" +\n+            \"connected_clients:\" + redisStats.getConnectedClients() + \"\\r\\n\" +\n+            \"blocked_clients:0\\r\\n\";\n+    return CLIENTS_STRING;\n+  }\n+\n+  private String getMemorySection(ExecutionHandlerContext context) {\n+    PartitionedRegion pr = (PartitionedRegion) context.getRegionProvider().getDataRegion();\n+    long usedMemory = pr.getDataStore().currentAllocatedMemory();\n+    final String MEMORY_STRING =\n+        \"# Memory\\r\\n\" +\n+            \"used_memory:\" + usedMemory + \"\\r\\n\" +\n+            \"mem_fragmentation_ratio:0\\r\\n\";\n+    return MEMORY_STRING;\n+  }\n+\n+  private String getStatsSection(ExecutionHandlerContext context) {\n+    final RedisStats redisStats = context.getRedisStats();\n+    String instantaneous_input_kbps =\n+        new DecimalFormat(\"0.00\")\n+            .format(redisStats.getNetworkKilobytesReadPerSecond());\n+    final String STATS_STRING =\n+        \"# Stats\\r\\n\" +\n+            \"total_commands_processed:\" + redisStats.getCommandsProcessed() + \"\\r\\n\" +\n+            \"instantaneous_ops_per_sec:\" + redisStats.getOpsPerSecond() + \"\\r\\n\" +\n+            \"total_net_input_bytes:\" + redisStats.getNetworkBytesRead() + \"\\r\\n\" +\n+            \"instantaneous_input_kbps:\" + instantaneous_input_kbps + \"\\r\\n\" +\n+            \"total_connections_received:\" + redisStats.getConnectionsReceived() + \"\\r\\n\" +\n+            \"keyspace_hits:\" + redisStats.getKeyspaceHits() + \"\\r\\n\" +\n+            \"keyspace_misses:\" + redisStats.getKeyspaceMisses() + \"\\r\\n\" +\n+            \"evicted_keys:0\\r\\n\" +\n+            \"rejected_connections:0\\r\\n\";\n+    return STATS_STRING;\n+  }\n+\n+  private String getKeyspaceSection(ExecutionHandlerContext context) {\n+    final RedisStats redisStats = context.getRedisStats();\n+    final String KEYSPACE_STRING =\n+        \"# Keyspace\\r\\n\" +\n+            \"db0:keys=\" + context.getRegionProvider().getDataRegion().size() +\n+            \",expires=\" + redisStats.getExpirations() +\n+            \",avg_ttl=0\\r\\n\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ae4b36cbf038c74dfb18648b2f15f68681e30ee"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ5MjA4MQ==", "bodyText": "story made for this", "url": "https://github.com/apache/geode/pull/5678#discussion_r514492081", "createdAt": "2020-10-29T18:53:17Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/server/InfoExecutor.java", "diffHunk": "@@ -72,26 +78,91 @@ private String getSpecifiedSection(ExecutionHandlerContext context,\n   private String getServerSection(ExecutionHandlerContext context) {\n     final String CURRENT_REDIS_VERSION = \"5.0.6\";\n     final int TCP_PORT = context.getServerPort();\n+    final RedisStats redisStats = context.getRedisStats();\n     final String SERVER_STRING =\n         \"# Server\\r\\n\" +\n             \"redis_version:\" + CURRENT_REDIS_VERSION + \"\\r\\n\" +\n             \"redis_mode:standalone\\r\\n\" +\n-            \"tcp_port:\" + TCP_PORT + \"\\r\\n\";\n+            \"tcp_port:\" + TCP_PORT + \"\\r\\n\" +\n+            \"uptime_in_seconds:\" + redisStats.getUptimeInSeconds() + \"\\r\\n\" +\n+            \"uptime_in_days:\" + redisStats.getUptimeInDays() + \"\\r\\n\";\n     return SERVER_STRING;\n   }\n \n+  private String getClientsSection(ExecutionHandlerContext context) {\n+    final RedisStats redisStats = context.getRedisStats();\n+    final String CLIENTS_STRING =\n+        \"# Clients\\r\\n\" +\n+            \"connected_clients:\" + redisStats.getConnectedClients() + \"\\r\\n\" +\n+            \"blocked_clients:0\\r\\n\";\n+    return CLIENTS_STRING;\n+  }\n+\n+  private String getMemorySection(ExecutionHandlerContext context) {\n+    PartitionedRegion pr = (PartitionedRegion) context.getRegionProvider().getDataRegion();\n+    long usedMemory = pr.getDataStore().currentAllocatedMemory();\n+    final String MEMORY_STRING =\n+        \"# Memory\\r\\n\" +\n+            \"used_memory:\" + usedMemory + \"\\r\\n\" +\n+            \"mem_fragmentation_ratio:0\\r\\n\";\n+    return MEMORY_STRING;\n+  }\n+\n+  private String getStatsSection(ExecutionHandlerContext context) {\n+    final RedisStats redisStats = context.getRedisStats();\n+    String instantaneous_input_kbps =\n+        new DecimalFormat(\"0.00\")\n+            .format(redisStats.getNetworkKilobytesReadPerSecond());\n+    final String STATS_STRING =\n+        \"# Stats\\r\\n\" +\n+            \"total_commands_processed:\" + redisStats.getCommandsProcessed() + \"\\r\\n\" +\n+            \"instantaneous_ops_per_sec:\" + redisStats.getOpsPerSecond() + \"\\r\\n\" +\n+            \"total_net_input_bytes:\" + redisStats.getNetworkBytesRead() + \"\\r\\n\" +\n+            \"instantaneous_input_kbps:\" + instantaneous_input_kbps + \"\\r\\n\" +\n+            \"total_connections_received:\" + redisStats.getConnectionsReceived() + \"\\r\\n\" +\n+            \"keyspace_hits:\" + redisStats.getKeyspaceHits() + \"\\r\\n\" +\n+            \"keyspace_misses:\" + redisStats.getKeyspaceMisses() + \"\\r\\n\" +\n+            \"evicted_keys:0\\r\\n\" +\n+            \"rejected_connections:0\\r\\n\";\n+    return STATS_STRING;\n+  }\n+\n+  private String getKeyspaceSection(ExecutionHandlerContext context) {\n+    final RedisStats redisStats = context.getRedisStats();\n+    final String KEYSPACE_STRING =\n+        \"# Keyspace\\r\\n\" +\n+            \"db0:keys=\" + context.getRegionProvider().getDataRegion().size() +\n+            \",expires=\" + redisStats.getExpirations() +\n+            \",avg_ttl=0\\r\\n\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY2OTI2NQ=="}, "originalCommit": {"oid": "2ae4b36cbf038c74dfb18648b2f15f68681e30ee"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxODY0NDc4OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/server/SlowlogExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxODo0NjoyOVrOHp4rdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxODo1Mzo0NFrOHqqHvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY4MjI5NA==", "bodyText": "Do we actually need this executor for monitoring software?  It doesn't seem like we use it anywhere.  The command itself is still listed as UNIMPLEMENTED in RedisCommandType, so it would return an error.", "url": "https://github.com/apache/geode/pull/5678#discussion_r513682294", "createdAt": "2020-10-28T18:46:29Z", "author": {"login": "sabbey37"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/server/SlowlogExecutor.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis.internal.executor.server;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.geode.redis.internal.data.ByteArrayWrapper;\n+import org.apache.geode.redis.internal.executor.AbstractExecutor;\n+import org.apache.geode.redis.internal.executor.RedisResponse;\n+import org.apache.geode.redis.internal.netty.Command;\n+import org.apache.geode.redis.internal.netty.ExecutionHandlerContext;\n+\n+// TODO: only exists for Redis monitoring software, maybe make functional someday?\n+public class SlowlogExecutor extends AbstractExecutor {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ae4b36cbf038c74dfb18648b2f15f68681e30ee"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ5MjM1MA==", "bodyText": "done.", "url": "https://github.com/apache/geode/pull/5678#discussion_r514492350", "createdAt": "2020-10-29T18:53:44Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/server/SlowlogExecutor.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.redis.internal.executor.server;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.geode.redis.internal.data.ByteArrayWrapper;\n+import org.apache.geode.redis.internal.executor.AbstractExecutor;\n+import org.apache.geode.redis.internal.executor.RedisResponse;\n+import org.apache.geode.redis.internal.netty.Command;\n+import org.apache.geode.redis.internal.netty.ExecutionHandlerContext;\n+\n+// TODO: only exists for Redis monitoring software, maybe make functional someday?\n+public class SlowlogExecutor extends AbstractExecutor {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY4MjI5NA=="}, "originalCommit": {"oid": "2ae4b36cbf038c74dfb18648b2f15f68681e30ee"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxODY0ODA2OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/GetBitExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxODo0NzoyNFrOHp4tpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxODo1MTo1MFrOHqqDFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY4Mjg1NA==", "bodyText": "Seems like we could leave this formatting change to spA.", "url": "https://github.com/apache/geode/pull/5678#discussion_r513682854", "createdAt": "2020-10-28T18:47:24Z", "author": {"login": "sabbey37"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/GetBitExecutor.java", "diffHunk": "@@ -40,7 +40,8 @@ public RedisResponse executeCommand(Command command, ExecutionHandlerContext con\n       return RedisResponse.error(ERROR_NOT_INT);\n     }\n \n-    int result = getRedisStringCommands(context).getbit(key, offset);\n+    int result = getRedisStringCommands(context)\n+        .getbit(key, offset);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ae4b36cbf038c74dfb18648b2f15f68681e30ee"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ5MTE1Nw==", "bodyText": "sure", "url": "https://github.com/apache/geode/pull/5678#discussion_r514491157", "createdAt": "2020-10-29T18:51:50Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/GetBitExecutor.java", "diffHunk": "@@ -40,7 +40,8 @@ public RedisResponse executeCommand(Command command, ExecutionHandlerContext con\n       return RedisResponse.error(ERROR_NOT_INT);\n     }\n \n-    int result = getRedisStringCommands(context).getbit(key, offset);\n+    int result = getRedisStringCommands(context)\n+        .getbit(key, offset);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY4Mjg1NA=="}, "originalCommit": {"oid": "2ae4b36cbf038c74dfb18648b2f15f68681e30ee"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxODc2ODcxOnYy", "diffSide": "RIGHT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/netty/NettyRedisServer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxOToyMDo1OFrOHp544g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxODo1MDoyOVrOHqqABw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcwMjExNA==", "bodyText": "Seems like we could let spA handle this formatting change, especially since nothing else was changed in this file.", "url": "https://github.com/apache/geode/pull/5678#discussion_r513702114", "createdAt": "2020-10-28T19:20:58Z", "author": {"login": "sabbey37"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/netty/NettyRedisServer.java", "diffHunk": "@@ -169,7 +169,8 @@ public void initChannel(SocketChannel socketChannel) {\n         }\n         ChannelPipeline pipeline = socketChannel.pipeline();\n         addSSLIfEnabled(socketChannel, pipeline);\n-        pipeline.addLast(ByteToCommandDecoder.class.getSimpleName(), new ByteToCommandDecoder());\n+        pipeline.addLast(ByteToCommandDecoder.class.getSimpleName(),\n+            new ByteToCommandDecoder(redisStats));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ae4b36cbf038c74dfb18648b2f15f68681e30ee"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ4NDY1Nw==", "bodyText": "will submit separate PR with format changes", "url": "https://github.com/apache/geode/pull/5678#discussion_r514484657", "createdAt": "2020-10-29T18:40:04Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/netty/NettyRedisServer.java", "diffHunk": "@@ -169,7 +169,8 @@ public void initChannel(SocketChannel socketChannel) {\n         }\n         ChannelPipeline pipeline = socketChannel.pipeline();\n         addSSLIfEnabled(socketChannel, pipeline);\n-        pipeline.addLast(ByteToCommandDecoder.class.getSimpleName(), new ByteToCommandDecoder());\n+        pipeline.addLast(ByteToCommandDecoder.class.getSimpleName(),\n+            new ByteToCommandDecoder(redisStats));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcwMjExNA=="}, "originalCommit": {"oid": "2ae4b36cbf038c74dfb18648b2f15f68681e30ee"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ5MDM3NQ==", "bodyText": "will create separate formatting pr", "url": "https://github.com/apache/geode/pull/5678#discussion_r514490375", "createdAt": "2020-10-29T18:50:29Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/netty/NettyRedisServer.java", "diffHunk": "@@ -169,7 +169,8 @@ public void initChannel(SocketChannel socketChannel) {\n         }\n         ChannelPipeline pipeline = socketChannel.pipeline();\n         addSSLIfEnabled(socketChannel, pipeline);\n-        pipeline.addLast(ByteToCommandDecoder.class.getSimpleName(), new ByteToCommandDecoder());\n+        pipeline.addLast(ByteToCommandDecoder.class.getSimpleName(),\n+            new ByteToCommandDecoder(redisStats));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcwMjExNA=="}, "originalCommit": {"oid": "2ae4b36cbf038c74dfb18648b2f15f68681e30ee"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxODkxMTY0OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/RedisStats.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMDowMTozOFrOHp7R1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxODo1MToxN1rOHqqB6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcyNDg4NQ==", "bodyText": "The clientID statistic is actually the same as connectedClients. We could make the getClients() method public and just use that (unless there's a reason we shouldn't make it public)", "url": "https://github.com/apache/geode/pull/5678#discussion_r513724885", "createdAt": "2020-10-28T20:01:38Z", "author": {"login": "sabbey37"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/RedisStats.java", "diffHunk": "@@ -171,13 +180,92 @@ public void endCommand(RedisCommandType command, long start) {\n   }\n \n   public void addClient() {\n+    connectionsReceived.incrementAndGet();\n+    connectedClients.incrementAndGet();\n     stats.incLong(clientId, 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ae4b36cbf038c74dfb18648b2f15f68681e30ee"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ4Njg3Ng==", "bodyText": "can likely be addressed in future changes to functionality", "url": "https://github.com/apache/geode/pull/5678#discussion_r514486876", "createdAt": "2020-10-29T18:44:09Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/RedisStats.java", "diffHunk": "@@ -171,13 +180,92 @@ public void endCommand(RedisCommandType command, long start) {\n   }\n \n   public void addClient() {\n+    connectionsReceived.incrementAndGet();\n+    connectedClients.incrementAndGet();\n     stats.incLong(clientId, 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcyNDg4NQ=="}, "originalCommit": {"oid": "2ae4b36cbf038c74dfb18648b2f15f68681e30ee"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ5MDg1Nw==", "bodyText": "will likely be addressed in future work on functionality here", "url": "https://github.com/apache/geode/pull/5678#discussion_r514490857", "createdAt": "2020-10-29T18:51:17Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/RedisStats.java", "diffHunk": "@@ -171,13 +180,92 @@ public void endCommand(RedisCommandType command, long start) {\n   }\n \n   public void addClient() {\n+    connectionsReceived.incrementAndGet();\n+    connectedClients.incrementAndGet();\n     stats.incLong(clientId, 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcyNDg4NQ=="}, "originalCommit": {"oid": "2ae4b36cbf038c74dfb18648b2f15f68681e30ee"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxODkxOTUxOnYy", "diffSide": "RIGHT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/RedisStats.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMDowNDowM1rOHp7W1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxODozMzowN1rOHqpZ3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcyNjE2NQ==", "bodyText": "We have a lot of integration tests for keyspaceHits and keyspaceMisses, but we don't have any for the other statistics. It would be good to test those as well.", "url": "https://github.com/apache/geode/pull/5678#discussion_r513726165", "createdAt": "2020-10-28T20:04:03Z", "author": {"login": "sabbey37"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/RedisStats.java", "diffHunk": "@@ -171,13 +180,92 @@ public void endCommand(RedisCommandType command, long start) {\n   }\n \n   public void addClient() {\n+    connectionsReceived.incrementAndGet();\n+    connectedClients.incrementAndGet();\n     stats.incLong(clientId, 1);\n   }\n \n   public void removeClient() {\n+    connectedClients.decrementAndGet();\n     stats.incLong(clientId, -1);\n   }\n \n+  private final AtomicLong commandsProcessed = new AtomicLong();\n+  private final AtomicLong opsPerSecond = new AtomicLong();\n+  private final AtomicLong networkBytesRead = new AtomicLong();\n+  private volatile double networkKilobytesReadPerSecond;\n+  private final AtomicLong connectionsReceived = new AtomicLong();\n+  private final AtomicLong connectedClients = new AtomicLong();\n+  private final AtomicLong expirations = new AtomicLong();\n+  private final AtomicLong keyspaceHits = new AtomicLong();\n+  private final AtomicLong keyspaceMisses = new AtomicLong();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ae4b36cbf038c74dfb18648b2f15f68681e30ee"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ4MDYwNA==", "bodyText": "will add", "url": "https://github.com/apache/geode/pull/5678#discussion_r514480604", "createdAt": "2020-10-29T18:33:07Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/RedisStats.java", "diffHunk": "@@ -171,13 +180,92 @@ public void endCommand(RedisCommandType command, long start) {\n   }\n \n   public void addClient() {\n+    connectionsReceived.incrementAndGet();\n+    connectedClients.incrementAndGet();\n     stats.incLong(clientId, 1);\n   }\n \n   public void removeClient() {\n+    connectedClients.decrementAndGet();\n     stats.incLong(clientId, -1);\n   }\n \n+  private final AtomicLong commandsProcessed = new AtomicLong();\n+  private final AtomicLong opsPerSecond = new AtomicLong();\n+  private final AtomicLong networkBytesRead = new AtomicLong();\n+  private volatile double networkKilobytesReadPerSecond;\n+  private final AtomicLong connectionsReceived = new AtomicLong();\n+  private final AtomicLong connectedClients = new AtomicLong();\n+  private final AtomicLong expirations = new AtomicLong();\n+  private final AtomicLong keyspaceHits = new AtomicLong();\n+  private final AtomicLong keyspaceMisses = new AtomicLong();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcyNjE2NQ=="}, "originalCommit": {"oid": "2ae4b36cbf038c74dfb18648b2f15f68681e30ee"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxODk1MTA4OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/integrationTest/java/org/apache/geode/redis/internal/RedisStatsIntegrationTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMDoxMzoyM1rOHp7qcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxODozMzoyNVrOHqparQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzczMTE4NA==", "bodyText": "I mentioned in another comment that we should test all the statistics, not just clients and keyspace hits and misses.  We should also add tests/update existing tests in AbstractInfoIntegrationTest", "url": "https://github.com/apache/geode/pull/5678#discussion_r513731184", "createdAt": "2020-10-28T20:13:23Z", "author": {"login": "sabbey37"}, "path": "geode-redis/src/integrationTest/java/org/apache/geode/redis/internal/RedisStatsIntegrationTest.java", "diffHunk": "@@ -16,28 +16,469 @@\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.Before;\n import org.junit.ClassRule;\n import org.junit.Test;\n+import redis.clients.jedis.BitOP;\n import redis.clients.jedis.Jedis;\n \n import org.apache.geode.redis.GeodeRedisServerRule;\n import org.apache.geode.test.awaitility.GeodeAwaitility;\n \n public class RedisStatsIntegrationTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ae4b36cbf038c74dfb18648b2f15f68681e30ee"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ4MDgxMw==", "bodyText": "will do", "url": "https://github.com/apache/geode/pull/5678#discussion_r514480813", "createdAt": "2020-10-29T18:33:25Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/integrationTest/java/org/apache/geode/redis/internal/RedisStatsIntegrationTest.java", "diffHunk": "@@ -16,28 +16,469 @@\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.Before;\n import org.junit.ClassRule;\n import org.junit.Test;\n+import redis.clients.jedis.BitOP;\n import redis.clients.jedis.Jedis;\n \n import org.apache.geode.redis.GeodeRedisServerRule;\n import org.apache.geode.test.awaitility.GeodeAwaitility;\n \n public class RedisStatsIntegrationTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzczMTE4NA=="}, "originalCommit": {"oid": "2ae4b36cbf038c74dfb18648b2f15f68681e30ee"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxODk5NTk5OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/connection/SelectExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMDoyNjowMVrOHp8FRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxODo0ODozNlrOHqp73g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzczODA1Mw==", "bodyText": "Not sure if we want to add the SelectExecutor in this PR, since there's another PR that adds it.  If we do add it in this PR, we need to remove SELECT from the list of unimplemented commands and add it to the list of unsupported commands in SupportedCommandsJUnitTest.", "url": "https://github.com/apache/geode/pull/5678#discussion_r513738053", "createdAt": "2020-10-28T20:26:01Z", "author": {"login": "sabbey37"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/connection/SelectExecutor.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.apache.geode.redis.internal.executor.connection;\n+\n+import org.apache.geode.redis.internal.executor.AbstractExecutor;\n+import org.apache.geode.redis.internal.executor.RedisResponse;\n+import org.apache.geode.redis.internal.netty.Command;\n+import org.apache.geode.redis.internal.netty.ExecutionHandlerContext;\n+\n+public class SelectExecutor extends AbstractExecutor {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ae4b36cbf038c74dfb18648b2f15f68681e30ee"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ4OTMxMA==", "bodyText": "thanks for catching this-  will remove", "url": "https://github.com/apache/geode/pull/5678#discussion_r514489310", "createdAt": "2020-10-29T18:48:36Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/connection/SelectExecutor.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.apache.geode.redis.internal.executor.connection;\n+\n+import org.apache.geode.redis.internal.executor.AbstractExecutor;\n+import org.apache.geode.redis.internal.executor.RedisResponse;\n+import org.apache.geode.redis.internal.netty.Command;\n+import org.apache.geode.redis.internal.netty.ExecutionHandlerContext;\n+\n+public class SelectExecutor extends AbstractExecutor {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzczODA1Mw=="}, "originalCommit": {"oid": "2ae4b36cbf038c74dfb18648b2f15f68681e30ee"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxOTAxNTE5OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/integrationTest/java/org/apache/geode/redis/internal/RedisStatsIntegrationTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMDozMDo1OFrOHp8RAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxOTowMjowMFrOHqqd3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc0MTA1Nw==", "bodyText": "why does this not cause two misses?", "url": "https://github.com/apache/geode/pull/5678#discussion_r513741057", "createdAt": "2020-10-28T20:30:58Z", "author": {"login": "nonbinaryprogrammer"}, "path": "geode-redis/src/integrationTest/java/org/apache/geode/redis/internal/RedisStatsIntegrationTest.java", "diffHunk": "@@ -16,28 +16,469 @@\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.Before;\n import org.junit.ClassRule;\n import org.junit.Test;\n+import redis.clients.jedis.BitOP;\n import redis.clients.jedis.Jedis;\n \n import org.apache.geode.redis.GeodeRedisServerRule;\n import org.apache.geode.test.awaitility.GeodeAwaitility;\n \n public class RedisStatsIntegrationTest {\n+  public static final String EXISTING_HASH_KEY = \"Existing_Hash\";\n+  public static final String EXISTING_STRING_KEY = \"Existing_String\";\n+  public static final String EXISTING_SET_KEY_1 = \"Existing_Set_1\";\n+  public static final String EXISTING_SET_KEY_2 = \"Existing_Set_2\";\n+  public static final String NONEXISTENT_KEY = \"Nonexistent_Key\";\n+  Jedis jedis;\n+  long initialKeyspaceHits;\n+  long initialKeyspaceMisses;\n \n   @ClassRule\n   public static GeodeRedisServerRule server = new GeodeRedisServerRule();\n \n+  @Before\n+  public void setup() {\n+    jedis = new Jedis(\"localhost\", server.getPort(), 10000000);\n+    jedis.flushAll();\n+    jedis.set(EXISTING_STRING_KEY, \"A_Value\");\n+    jedis.hset(EXISTING_HASH_KEY, \"Field1\", \"Value1\");\n+    jedis.sadd(EXISTING_SET_KEY_1, \"m1\", \"m2\", \"m3\");\n+    jedis.sadd(EXISTING_SET_KEY_2, \"m4\", \"m5\", \"m6\");\n+    initialKeyspaceHits = server.getServer().getStats().getKeyspaceHits();\n+    initialKeyspaceMisses = server.getServer().getStats().getKeyspaceMisses();\n+  }\n+\n   @Test\n-  public void clientsStat_withConnectAndClose_isCorrect() throws InterruptedException {\n+  public void clientsStat_withConnectAndClose_isCorrect() {\n     long initialClients = server.getServer().getStats().getClients();\n     Jedis jedis = new Jedis(\"localhost\", server.getPort(), 10000000);\n \n     jedis.ping();\n     assertThat(server.getServer().getStats().getClients()).isEqualTo(initialClients + 1);\n \n     jedis.close();\n-    GeodeAwaitility.await().untilAsserted(\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n         () -> assertThat(server.getServer().getStats().getClients()).isEqualTo(initialClients));\n   }\n+\n+  @Test\n+  public void keyspaceHitsStat_shouldIncrement_whenKeyAccessed() {\n+    jedis.get(EXISTING_STRING_KEY);\n+\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits + 1);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses);\n+        });\n+  }\n+\n+  @Test\n+  public void keyspaceHitsStat_shouldNotIncrement_whenNonexistentKeyAccessed() {\n+    jedis.get(\"Nonexistent_Key\");\n+\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses + 1);\n+        });\n+  }\n+\n+  // TODO: Set doesn't work like native Redis!\n+  @Test\n+  public void keyspaceStats_setCommand_existingKey() {\n+    jedis.set(EXISTING_STRING_KEY, \"New_Value\");\n+\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits + 1);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses);\n+        });\n+  }\n+\n+  // TODO: Set doesn't work like native Redis!\n+  @Test\n+  public void keyspaceStats_setCommand_nonexistentKey() {\n+    jedis.set(\"Another_Key\", \"Another_Value\");\n+\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses + 1);\n+        });\n+  }\n+\n+  @Test\n+  public void keyspaceStats_getBitCommand_existingKey() {\n+    jedis.getbit(EXISTING_STRING_KEY, 0);\n+\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits + 1);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses);\n+        });\n+  }\n+\n+  @Test\n+  public void keyspaceStats_getBitCommand_nonexistentKey() {\n+    jedis.getbit(\"Nonexistent_Key\", 0);\n+\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses + 1);\n+        });\n+  }\n+\n+  @Test\n+  public void keyspaceStats_getRangeCommand_existingKey() {\n+    jedis.getrange(EXISTING_STRING_KEY, 0, 1);\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits + 1);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses);\n+        });\n+  }\n+\n+  @Test\n+  public void keyspaceStats_getRangeCommand_nonexistentKey() {\n+    jedis.getrange(\"Nonexistent_Key\", 0, 1);\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses + 1);\n+        });\n+  }\n+\n+  @Test\n+  public void keyspaceStats_getSetCommand_existingKey() {\n+    jedis.getSet(EXISTING_STRING_KEY, \"New_Value\");\n+\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits + 1);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses);\n+        });\n+  }\n+\n+  @Test\n+  public void keyspaceStats_getSetCommand_nonexistentKey() {\n+    jedis.getSet(\"Nonexistent_Key\", \"FakeValue\");\n+\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses + 1);\n+        });\n+  }\n+\n+  @Test\n+  public void keyspaceStats_strlenCommand_existingKey() {\n+    jedis.strlen(EXISTING_STRING_KEY);\n+\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits + 1);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses);\n+        });\n+  }\n+\n+  @Test\n+  public void keyspaceStats_strlenCommand_nonexistentKey() {\n+    jedis.strlen(NONEXISTENT_KEY);\n+\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses + 1);\n+        });\n+  }\n+\n+  @Test\n+  public void keyspaceStats_mgetCommand() {\n+    jedis.mget(EXISTING_STRING_KEY, \"Nonexistent_Key\");\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits + 1);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses + 1);\n+        });\n+  }\n+\n+  @Test\n+  public void keyspaceStats_bitopCommand() {\n+    jedis.bitop(BitOP.AND, EXISTING_STRING_KEY, EXISTING_STRING_KEY, \"Nonexistent_Key\");\n+\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits + 2);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses + 1);\n+        });\n+  }\n+\n+  @Test\n+  public void keyspaceStats_bitcountCommand_existingKey() {\n+    jedis.bitcount(EXISTING_STRING_KEY);\n+\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits + 1);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses);\n+        });\n+  }\n+\n+  @Test\n+  public void keyspaceStats_bitcountCommand_nonexistentKey() {\n+    jedis.bitcount(\"Nonexistent_Key\");\n+\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses + 1);\n+        });\n+  }\n+\n+  @Test\n+  public void keyspaceStats_bitposCommand_existingKey() {\n+    jedis.bitpos(EXISTING_STRING_KEY, true);\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits + 1);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses);\n+        });\n+  }\n+\n+  @Test\n+  public void keyspaceStats_bitposCommand_nonexistentKey() {\n+    jedis.bitpos(\"Nonexistent_Key\", true);\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses + 1);\n+        });\n+  }\n+\n+  @Test\n+  public void keyspaceStats_hgetCommand_existingKey() {\n+    jedis.hget(EXISTING_HASH_KEY, \"Field1\");\n+\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits + 1);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses);\n+        });\n+  }\n+\n+  @Test\n+  public void keyspaceStats_hgetCommand_nonexistentKey() {\n+    jedis.hget(\"Nonexistent_Hash\", \"Field1\");\n+\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses + 1);\n+        });\n+  }\n+\n+  @Test\n+  public void keyspaceStats_smembersCommand_existingKey() {\n+    jedis.smembers(EXISTING_SET_KEY_1);\n+\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits + 1);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses);\n+        });\n+  }\n+\n+  @Test\n+  public void keyspaceStats_smembersCommand_nonexistentKey() {\n+    jedis.smembers(\"Nonexistent_Set\");\n+\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses + 1);\n+        });\n+  }\n+\n+  @Test\n+  public void keyspaceStats_sunionstoreCommand_existingKey() {\n+    jedis.sunionstore(\"New_Set\", EXISTING_SET_KEY_1, EXISTING_SET_KEY_2, \"Nonexistent_Set\");\n+\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits + 2);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses + 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ae4b36cbf038c74dfb18648b2f15f68681e30ee"}, "originalPosition": 370}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ5ODAxNQ==", "bodyText": "why does this not cause two misses?\nthis is a weird interface- the first parameter is the set that the union will be stored in - so no hit or miss- just created. the 2 hits come from the existing keys. the miss comes form the non-existent set. let us know if that still seems weird and isn't addressed in a new story", "url": "https://github.com/apache/geode/pull/5678#discussion_r514498015", "createdAt": "2020-10-29T19:02:00Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/integrationTest/java/org/apache/geode/redis/internal/RedisStatsIntegrationTest.java", "diffHunk": "@@ -16,28 +16,469 @@\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.Before;\n import org.junit.ClassRule;\n import org.junit.Test;\n+import redis.clients.jedis.BitOP;\n import redis.clients.jedis.Jedis;\n \n import org.apache.geode.redis.GeodeRedisServerRule;\n import org.apache.geode.test.awaitility.GeodeAwaitility;\n \n public class RedisStatsIntegrationTest {\n+  public static final String EXISTING_HASH_KEY = \"Existing_Hash\";\n+  public static final String EXISTING_STRING_KEY = \"Existing_String\";\n+  public static final String EXISTING_SET_KEY_1 = \"Existing_Set_1\";\n+  public static final String EXISTING_SET_KEY_2 = \"Existing_Set_2\";\n+  public static final String NONEXISTENT_KEY = \"Nonexistent_Key\";\n+  Jedis jedis;\n+  long initialKeyspaceHits;\n+  long initialKeyspaceMisses;\n \n   @ClassRule\n   public static GeodeRedisServerRule server = new GeodeRedisServerRule();\n \n+  @Before\n+  public void setup() {\n+    jedis = new Jedis(\"localhost\", server.getPort(), 10000000);\n+    jedis.flushAll();\n+    jedis.set(EXISTING_STRING_KEY, \"A_Value\");\n+    jedis.hset(EXISTING_HASH_KEY, \"Field1\", \"Value1\");\n+    jedis.sadd(EXISTING_SET_KEY_1, \"m1\", \"m2\", \"m3\");\n+    jedis.sadd(EXISTING_SET_KEY_2, \"m4\", \"m5\", \"m6\");\n+    initialKeyspaceHits = server.getServer().getStats().getKeyspaceHits();\n+    initialKeyspaceMisses = server.getServer().getStats().getKeyspaceMisses();\n+  }\n+\n   @Test\n-  public void clientsStat_withConnectAndClose_isCorrect() throws InterruptedException {\n+  public void clientsStat_withConnectAndClose_isCorrect() {\n     long initialClients = server.getServer().getStats().getClients();\n     Jedis jedis = new Jedis(\"localhost\", server.getPort(), 10000000);\n \n     jedis.ping();\n     assertThat(server.getServer().getStats().getClients()).isEqualTo(initialClients + 1);\n \n     jedis.close();\n-    GeodeAwaitility.await().untilAsserted(\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n         () -> assertThat(server.getServer().getStats().getClients()).isEqualTo(initialClients));\n   }\n+\n+  @Test\n+  public void keyspaceHitsStat_shouldIncrement_whenKeyAccessed() {\n+    jedis.get(EXISTING_STRING_KEY);\n+\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits + 1);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses);\n+        });\n+  }\n+\n+  @Test\n+  public void keyspaceHitsStat_shouldNotIncrement_whenNonexistentKeyAccessed() {\n+    jedis.get(\"Nonexistent_Key\");\n+\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses + 1);\n+        });\n+  }\n+\n+  // TODO: Set doesn't work like native Redis!\n+  @Test\n+  public void keyspaceStats_setCommand_existingKey() {\n+    jedis.set(EXISTING_STRING_KEY, \"New_Value\");\n+\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits + 1);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses);\n+        });\n+  }\n+\n+  // TODO: Set doesn't work like native Redis!\n+  @Test\n+  public void keyspaceStats_setCommand_nonexistentKey() {\n+    jedis.set(\"Another_Key\", \"Another_Value\");\n+\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses + 1);\n+        });\n+  }\n+\n+  @Test\n+  public void keyspaceStats_getBitCommand_existingKey() {\n+    jedis.getbit(EXISTING_STRING_KEY, 0);\n+\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits + 1);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses);\n+        });\n+  }\n+\n+  @Test\n+  public void keyspaceStats_getBitCommand_nonexistentKey() {\n+    jedis.getbit(\"Nonexistent_Key\", 0);\n+\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses + 1);\n+        });\n+  }\n+\n+  @Test\n+  public void keyspaceStats_getRangeCommand_existingKey() {\n+    jedis.getrange(EXISTING_STRING_KEY, 0, 1);\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits + 1);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses);\n+        });\n+  }\n+\n+  @Test\n+  public void keyspaceStats_getRangeCommand_nonexistentKey() {\n+    jedis.getrange(\"Nonexistent_Key\", 0, 1);\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses + 1);\n+        });\n+  }\n+\n+  @Test\n+  public void keyspaceStats_getSetCommand_existingKey() {\n+    jedis.getSet(EXISTING_STRING_KEY, \"New_Value\");\n+\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits + 1);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses);\n+        });\n+  }\n+\n+  @Test\n+  public void keyspaceStats_getSetCommand_nonexistentKey() {\n+    jedis.getSet(\"Nonexistent_Key\", \"FakeValue\");\n+\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses + 1);\n+        });\n+  }\n+\n+  @Test\n+  public void keyspaceStats_strlenCommand_existingKey() {\n+    jedis.strlen(EXISTING_STRING_KEY);\n+\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits + 1);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses);\n+        });\n+  }\n+\n+  @Test\n+  public void keyspaceStats_strlenCommand_nonexistentKey() {\n+    jedis.strlen(NONEXISTENT_KEY);\n+\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses + 1);\n+        });\n+  }\n+\n+  @Test\n+  public void keyspaceStats_mgetCommand() {\n+    jedis.mget(EXISTING_STRING_KEY, \"Nonexistent_Key\");\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits + 1);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses + 1);\n+        });\n+  }\n+\n+  @Test\n+  public void keyspaceStats_bitopCommand() {\n+    jedis.bitop(BitOP.AND, EXISTING_STRING_KEY, EXISTING_STRING_KEY, \"Nonexistent_Key\");\n+\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits + 2);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses + 1);\n+        });\n+  }\n+\n+  @Test\n+  public void keyspaceStats_bitcountCommand_existingKey() {\n+    jedis.bitcount(EXISTING_STRING_KEY);\n+\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits + 1);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses);\n+        });\n+  }\n+\n+  @Test\n+  public void keyspaceStats_bitcountCommand_nonexistentKey() {\n+    jedis.bitcount(\"Nonexistent_Key\");\n+\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses + 1);\n+        });\n+  }\n+\n+  @Test\n+  public void keyspaceStats_bitposCommand_existingKey() {\n+    jedis.bitpos(EXISTING_STRING_KEY, true);\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits + 1);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses);\n+        });\n+  }\n+\n+  @Test\n+  public void keyspaceStats_bitposCommand_nonexistentKey() {\n+    jedis.bitpos(\"Nonexistent_Key\", true);\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses + 1);\n+        });\n+  }\n+\n+  @Test\n+  public void keyspaceStats_hgetCommand_existingKey() {\n+    jedis.hget(EXISTING_HASH_KEY, \"Field1\");\n+\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits + 1);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses);\n+        });\n+  }\n+\n+  @Test\n+  public void keyspaceStats_hgetCommand_nonexistentKey() {\n+    jedis.hget(\"Nonexistent_Hash\", \"Field1\");\n+\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses + 1);\n+        });\n+  }\n+\n+  @Test\n+  public void keyspaceStats_smembersCommand_existingKey() {\n+    jedis.smembers(EXISTING_SET_KEY_1);\n+\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits + 1);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses);\n+        });\n+  }\n+\n+  @Test\n+  public void keyspaceStats_smembersCommand_nonexistentKey() {\n+    jedis.smembers(\"Nonexistent_Set\");\n+\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses + 1);\n+        });\n+  }\n+\n+  @Test\n+  public void keyspaceStats_sunionstoreCommand_existingKey() {\n+    jedis.sunionstore(\"New_Set\", EXISTING_SET_KEY_1, EXISTING_SET_KEY_2, \"Nonexistent_Set\");\n+\n+    jedis.close();\n+    GeodeAwaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(\n+        () -> {\n+          assertThat(server.getServer().getStats().getKeyspaceHits())\n+              .isEqualTo(initialKeyspaceHits + 2);\n+          assertThat(server.getServer().getStats().getKeyspaceMisses())\n+              .isEqualTo(initialKeyspaceMisses + 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc0MTA1Nw=="}, "originalCommit": {"oid": "2ae4b36cbf038c74dfb18648b2f15f68681e30ee"}, "originalPosition": 370}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxOTExODM2OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/RedisStats.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMTowMDo1N1rOHp9QNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxODo1NDoxMlrOHqqJFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc1NzIzOQ==", "bodyText": "I don't think we are counting expirations properly.  According to the Redis INFO docs (and also testing our version vs. Redis), it should be the number of keys with an expiration since we are using it in the keyspace section:\nThe keyspace section provides statistics on the main dictionary of each database. The statistics are the number of keys, and the number of keys with an expiration.\n\nFor each database, the following line is added:\n\ndbXXX: keys=XXX,expires=XXX\n\nThis means that we should increment the count when any key has an expiration set and decrement it when that key no longer has an expiration (because it was persisted, expired on its own, was deleted, etc.).  Right now, we only increment the count when a key expires, and we never decrement it.", "url": "https://github.com/apache/geode/pull/5678#discussion_r513757239", "createdAt": "2020-10-28T21:00:57Z", "author": {"login": "sabbey37"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/RedisStats.java", "diffHunk": "@@ -206,6 +294,7 @@ public void endExpiration(long start) {\n       stats.incLong(expirationTimeId, getTime() - start);\n     }\n     stats.incLong(expirationsId, 1);\n+    expirations.incrementAndGet();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ae4b36cbf038c74dfb18648b2f15f68681e30ee"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ4NzQ4OQ==", "bodyText": "story added to backlog for this", "url": "https://github.com/apache/geode/pull/5678#discussion_r514487489", "createdAt": "2020-10-29T18:45:19Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/RedisStats.java", "diffHunk": "@@ -206,6 +294,7 @@ public void endExpiration(long start) {\n       stats.incLong(expirationTimeId, getTime() - start);\n     }\n     stats.incLong(expirationsId, 1);\n+    expirations.incrementAndGet();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc1NzIzOQ=="}, "originalCommit": {"oid": "2ae4b36cbf038c74dfb18648b2f15f68681e30ee"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ5MjY5NA==", "bodyText": "story made for this", "url": "https://github.com/apache/geode/pull/5678#discussion_r514492694", "createdAt": "2020-10-29T18:54:12Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/RedisStats.java", "diffHunk": "@@ -206,6 +294,7 @@ public void endExpiration(long start) {\n       stats.incLong(expirationTimeId, getTime() - start);\n     }\n     stats.incLong(expirationsId, 1);\n+    expirations.incrementAndGet();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc1NzIzOQ=="}, "originalCommit": {"oid": "2ae4b36cbf038c74dfb18648b2f15f68681e30ee"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxOTU5NDYxOnYy", "diffSide": "RIGHT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/server/InfoExecutor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMzo1Mzo0OFrOHqBqDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxODo0OTowMlrOHqp8wA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgyOTM5MQ==", "bodyText": "We also need to add the following cases: clients, memory, stats, and keyspace", "url": "https://github.com/apache/geode/pull/5678#discussion_r513829391", "createdAt": "2020-10-28T23:53:48Z", "author": {"login": "sabbey37"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/server/InfoExecutor.java", "diffHunk": "@@ -58,6 +61,9 @@ private String getSpecifiedSection(ExecutionHandlerContext context,\n       case \"persistence\":\n         result = getPersistenceSection();\n         break;\n+      case \"replication\":\n+        result = getReplicationSection();\n+        break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ae4b36cbf038c74dfb18648b2f15f68681e30ee"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ4NzkwMQ==", "bodyText": "story made for this", "url": "https://github.com/apache/geode/pull/5678#discussion_r514487901", "createdAt": "2020-10-29T18:46:03Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/server/InfoExecutor.java", "diffHunk": "@@ -58,6 +61,9 @@ private String getSpecifiedSection(ExecutionHandlerContext context,\n       case \"persistence\":\n         result = getPersistenceSection();\n         break;\n+      case \"replication\":\n+        result = getReplicationSection();\n+        break;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgyOTM5MQ=="}, "originalCommit": {"oid": "2ae4b36cbf038c74dfb18648b2f15f68681e30ee"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ4OTUzNg==", "bodyText": "story added to implement this.", "url": "https://github.com/apache/geode/pull/5678#discussion_r514489536", "createdAt": "2020-10-29T18:49:02Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/server/InfoExecutor.java", "diffHunk": "@@ -58,6 +61,9 @@ private String getSpecifiedSection(ExecutionHandlerContext context,\n       case \"persistence\":\n         result = getPersistenceSection();\n         break;\n+      case \"replication\":\n+        result = getReplicationSection();\n+        break;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgyOTM5MQ=="}, "originalCommit": {"oid": "2ae4b36cbf038c74dfb18648b2f15f68681e30ee"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MjI2MjUzOnYy", "diffSide": "RIGHT", "path": "geode-redis/src/commonTest/java/org/apache/geode/redis/GeodeRedisServerRule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNjo0NjoyM1rOHu1jLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxODozNzo0MVrOHu5O4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg3MzkwMw==", "bodyText": "I don't think this is the right place to add these methods. Can the test that utilizes them not simply maintain local values for these (and initialize them in a @BeforeClass block?", "url": "https://github.com/apache/geode/pull/5678#discussion_r518873903", "createdAt": "2020-11-06T16:46:23Z", "author": {"login": "jdeppe-pivotal"}, "path": "geode-redis/src/commonTest/java/org/apache/geode/redis/GeodeRedisServerRule.java", "diffHunk": "@@ -47,6 +53,14 @@ protected void before() {\n     server.setAllowUnsupportedCommands(true);\n   }\n \n+  public long getStartTime() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c99b65445f3c1ba224d52ef5d3fecc29c67b4baa"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODkzNDI0MA==", "bodyText": "done", "url": "https://github.com/apache/geode/pull/5678#discussion_r518934240", "createdAt": "2020-11-06T18:37:41Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/commonTest/java/org/apache/geode/redis/GeodeRedisServerRule.java", "diffHunk": "@@ -47,6 +53,14 @@ protected void before() {\n     server.setAllowUnsupportedCommands(true);\n   }\n \n+  public long getStartTime() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg3MzkwMw=="}, "originalCommit": {"oid": "c99b65445f3c1ba224d52ef5d3fecc29c67b4baa"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MjI5MTg1OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/integrationTest/java/org/apache/geode/redis/internal/executor/key/AbstractExistsIntegrationTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNjo1NDowM1rOHu11ZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxODo1MDowM1rOHu5mxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg3ODU2NA==", "bodyText": "Please don't add formatting changes that seem somewhat arbitrary to the overall PR.", "url": "https://github.com/apache/geode/pull/5678#discussion_r518878564", "createdAt": "2020-11-06T16:54:03Z", "author": {"login": "jdeppe-pivotal"}, "path": "geode-redis/src/integrationTest/java/org/apache/geode/redis/internal/executor/key/AbstractExistsIntegrationTest.java", "diffHunk": "@@ -61,7 +61,8 @@ public void givenKeyNotProvided_returnsWrongNumberOfArgumentsError() {\n \n   @Test\n   public void shouldReturnZero_givenKeyDoesNotExist() {\n-    assertThat(jedis.exists(toArray(\"doesNotExist\"))).isEqualTo(0L);\n+    assertThat(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c99b65445f3c1ba224d52ef5d3fecc29c67b4baa"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk0MDM1Nw==", "bodyText": "changed back", "url": "https://github.com/apache/geode/pull/5678#discussion_r518940357", "createdAt": "2020-11-06T18:50:03Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/integrationTest/java/org/apache/geode/redis/internal/executor/key/AbstractExistsIntegrationTest.java", "diffHunk": "@@ -61,7 +61,8 @@ public void givenKeyNotProvided_returnsWrongNumberOfArgumentsError() {\n \n   @Test\n   public void shouldReturnZero_givenKeyDoesNotExist() {\n-    assertThat(jedis.exists(toArray(\"doesNotExist\"))).isEqualTo(0L);\n+    assertThat(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg3ODU2NA=="}, "originalCommit": {"oid": "c99b65445f3c1ba224d52ef5d3fecc29c67b4baa"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MjI5NzA5OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/GetBitExecutor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNjo1NToyNFrOHu14og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxODo1MDo1NFrOHu5ocA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg3OTM5NA==", "bodyText": "Please don't add formatting changes that seem somewhat arbitrary to the overall PR.", "url": "https://github.com/apache/geode/pull/5678#discussion_r518879394", "createdAt": "2020-11-06T16:55:24Z", "author": {"login": "jdeppe-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/GetBitExecutor.java", "diffHunk": "@@ -40,7 +40,8 @@ public RedisResponse executeCommand(Command command, ExecutionHandlerContext con\n       return RedisResponse.error(ERROR_NOT_INT);\n     }\n \n-    int result = getRedisStringCommands(context).getbit(key, offset);\n+    int result = getRedisStringCommands(context)\n+        .getbit(key, offset);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c99b65445f3c1ba224d52ef5d3fecc29c67b4baa"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk0MDc4NA==", "bodyText": "changed back", "url": "https://github.com/apache/geode/pull/5678#discussion_r518940784", "createdAt": "2020-11-06T18:50:54Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/string/GetBitExecutor.java", "diffHunk": "@@ -40,7 +40,8 @@ public RedisResponse executeCommand(Command command, ExecutionHandlerContext con\n       return RedisResponse.error(ERROR_NOT_INT);\n     }\n \n-    int result = getRedisStringCommands(context).getbit(key, offset);\n+    int result = getRedisStringCommands(context)\n+        .getbit(key, offset);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg3OTM5NA=="}, "originalCommit": {"oid": "c99b65445f3c1ba224d52ef5d3fecc29c67b4baa"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MjMwNzU1OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/server/InfoExecutor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNjo1ODoyM1rOHu1_Ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxODo0MDoxMVrOHu5TzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4MTExNQ==", "bodyText": "It would be better to create a private instance variable for this DecimalForamt and then re-use that here when calling .format. Don't make it static since DecimalFormat is not thread-safe.", "url": "https://github.com/apache/geode/pull/5678#discussion_r518881115", "createdAt": "2020-11-06T16:58:23Z", "author": {"login": "jdeppe-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/server/InfoExecutor.java", "diffHunk": "@@ -69,29 +75,97 @@ private String getSpecifiedSection(ExecutionHandlerContext context,\n     return result;\n   }\n \n+  private String getStatsSection(ExecutionHandlerContext context) {\n+    final RedisStats redisStats = context.getRedisStats();\n+    String instantaneous_input_kbps =\n+        new DecimalFormat(\"0.00\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c99b65445f3c1ba224d52ef5d3fecc29c67b4baa"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODkzNTUwMA==", "bodyText": "done", "url": "https://github.com/apache/geode/pull/5678#discussion_r518935500", "createdAt": "2020-11-06T18:40:11Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/server/InfoExecutor.java", "diffHunk": "@@ -69,29 +75,97 @@ private String getSpecifiedSection(ExecutionHandlerContext context,\n     return result;\n   }\n \n+  private String getStatsSection(ExecutionHandlerContext context) {\n+    final RedisStats redisStats = context.getRedisStats();\n+    String instantaneous_input_kbps =\n+        new DecimalFormat(\"0.00\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4MTExNQ=="}, "originalCommit": {"oid": "c99b65445f3c1ba224d52ef5d3fecc29c67b4baa"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MjMxMDMyOnYy", "diffSide": "RIGHT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/data/RedisKeyCommandsFunctionExecutor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNjo1OTowOVrOHu2BHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxODo0MDo1NFrOHu5VRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4MTU2Ng==", "bodyText": "Please keep this line formatted as it was.", "url": "https://github.com/apache/geode/pull/5678#discussion_r518881566", "createdAt": "2020-11-06T16:59:09Z", "author": {"login": "jdeppe-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/data/RedisKeyCommandsFunctionExecutor.java", "diffHunk": "@@ -33,12 +33,34 @@ public boolean del(ByteArrayWrapper key) {\n \n   @Override\n   public boolean exists(ByteArrayWrapper key) {\n-    return stripedExecute(key, () -> getRedisData(key).exists());\n+    boolean keyExists =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c99b65445f3c1ba224d52ef5d3fecc29c67b4baa"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODkzNTg3Ng==", "bodyText": "done", "url": "https://github.com/apache/geode/pull/5678#discussion_r518935876", "createdAt": "2020-11-06T18:40:54Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/data/RedisKeyCommandsFunctionExecutor.java", "diffHunk": "@@ -33,12 +33,34 @@ public boolean del(ByteArrayWrapper key) {\n \n   @Override\n   public boolean exists(ByteArrayWrapper key) {\n-    return stripedExecute(key, () -> getRedisData(key).exists());\n+    boolean keyExists =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4MTU2Ng=="}, "originalCommit": {"oid": "c99b65445f3c1ba224d52ef5d3fecc29c67b4baa"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MjMxMTU3OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/data/RedisKeyCommandsFunctionExecutor.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNjo1OToyOFrOHu2B7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxODo0NjozNVrOHu5ftw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4MTc3Mw==", "bodyText": "Please keep this line formatted as it was.", "url": "https://github.com/apache/geode/pull/5678#discussion_r518881773", "createdAt": "2020-11-06T16:59:28Z", "author": {"login": "jdeppe-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/data/RedisKeyCommandsFunctionExecutor.java", "diffHunk": "@@ -33,12 +33,34 @@ public boolean del(ByteArrayWrapper key) {\n \n   @Override\n   public boolean exists(ByteArrayWrapper key) {\n-    return stripedExecute(key, () -> getRedisData(key).exists());\n+    boolean keyExists =\n+        stripedExecute(\n+            key,\n+            () -> getRedisData(key).exists());\n+\n+    if (keyExists) {\n+      helper.getRedisStats().incKeyspaceHits();\n+    } else {\n+      helper.getRedisStats().incKeyspaceMisses();\n+    }\n+\n+    return keyExists;\n   }\n \n   @Override\n   public long pttl(ByteArrayWrapper key) {\n-    return stripedExecute(key, () -> getRedisData(key).pttl(getRegion(), key));\n+    long result =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c99b65445f3c1ba224d52ef5d3fecc29c67b4baa"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODkzNTk4NA==", "bodyText": "same as above", "url": "https://github.com/apache/geode/pull/5678#discussion_r518935984", "createdAt": "2020-11-06T18:41:08Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/data/RedisKeyCommandsFunctionExecutor.java", "diffHunk": "@@ -33,12 +33,34 @@ public boolean del(ByteArrayWrapper key) {\n \n   @Override\n   public boolean exists(ByteArrayWrapper key) {\n-    return stripedExecute(key, () -> getRedisData(key).exists());\n+    boolean keyExists =\n+        stripedExecute(\n+            key,\n+            () -> getRedisData(key).exists());\n+\n+    if (keyExists) {\n+      helper.getRedisStats().incKeyspaceHits();\n+    } else {\n+      helper.getRedisStats().incKeyspaceMisses();\n+    }\n+\n+    return keyExists;\n   }\n \n   @Override\n   public long pttl(ByteArrayWrapper key) {\n-    return stripedExecute(key, () -> getRedisData(key).pttl(getRegion(), key));\n+    long result =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4MTc3Mw=="}, "originalCommit": {"oid": "c99b65445f3c1ba224d52ef5d3fecc29c67b4baa"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODkzODU1MQ==", "bodyText": "done", "url": "https://github.com/apache/geode/pull/5678#discussion_r518938551", "createdAt": "2020-11-06T18:46:35Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/data/RedisKeyCommandsFunctionExecutor.java", "diffHunk": "@@ -33,12 +33,34 @@ public boolean del(ByteArrayWrapper key) {\n \n   @Override\n   public boolean exists(ByteArrayWrapper key) {\n-    return stripedExecute(key, () -> getRedisData(key).exists());\n+    boolean keyExists =\n+        stripedExecute(\n+            key,\n+            () -> getRedisData(key).exists());\n+\n+    if (keyExists) {\n+      helper.getRedisStats().incKeyspaceHits();\n+    } else {\n+      helper.getRedisStats().incKeyspaceMisses();\n+    }\n+\n+    return keyExists;\n   }\n \n   @Override\n   public long pttl(ByteArrayWrapper key) {\n-    return stripedExecute(key, () -> getRedisData(key).pttl(getRegion(), key));\n+    long result =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4MTc3Mw=="}, "originalCommit": {"oid": "c99b65445f3c1ba224d52ef5d3fecc29c67b4baa"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MjMxOTU1OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/RedisStats.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNzowMTo0NVrOHu2HDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNjowMToxMlrOHv1q7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4MzA4NQ==", "bodyText": "For consistency, I think it would be good to reset the other (Geode-specific) stats here too (not just clientId).", "url": "https://github.com/apache/geode/pull/5678#discussion_r518883085", "createdAt": "2020-11-06T17:01:45Z", "author": {"login": "jdeppe-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/RedisStats.java", "diffHunk": "@@ -82,6 +104,28 @@\n     expirationTimeId = type.nameToId(\"expirationTime\");\n   }\n \n+  public RedisStats(StatisticsFactory factory, StatisticsClock clock) {\n+    this(factory, \"redisStats\", clock);\n+  }\n+\n+  public RedisStats(StatisticsFactory factory, String textId, StatisticsClock clock) {\n+    stats = factory == null ? null : factory.createAtomicStatistics(type, textId);\n+    this.clock = clock;\n+    this.START_TIME_IN_NANOS = this.clock.getTime();\n+    perSecondExecutor = startPerSecondUpdater();\n+  }\n+\n+  public void clearAllStats() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c99b65445f3c1ba224d52ef5d3fecc29c67b4baa"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk0MTcwMg==", "bodyText": "agree, thanks.", "url": "https://github.com/apache/geode/pull/5678#discussion_r518941702", "createdAt": "2020-11-06T18:52:38Z", "author": {"login": "jhutchison"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/RedisStats.java", "diffHunk": "@@ -82,6 +104,28 @@\n     expirationTimeId = type.nameToId(\"expirationTime\");\n   }\n \n+  public RedisStats(StatisticsFactory factory, StatisticsClock clock) {\n+    this(factory, \"redisStats\", clock);\n+  }\n+\n+  public RedisStats(StatisticsFactory factory, String textId, StatisticsClock clock) {\n+    stats = factory == null ? null : factory.createAtomicStatistics(type, textId);\n+    this.clock = clock;\n+    this.START_TIME_IN_NANOS = this.clock.getTime();\n+    perSecondExecutor = startPerSecondUpdater();\n+  }\n+\n+  public void clearAllStats() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4MzA4NQ=="}, "originalCommit": {"oid": "c99b65445f3c1ba224d52ef5d3fecc29c67b4baa"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkyNDQ2MA==", "bodyText": "Not necessary to do this in this PR unless you're making other changes as well, but it might be a good idea to make this method protected instead of public and mark it as @VisibleForTesting", "url": "https://github.com/apache/geode/pull/5678#discussion_r519924460", "createdAt": "2020-11-09T16:01:12Z", "author": {"login": "sabbey37"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/RedisStats.java", "diffHunk": "@@ -82,6 +104,28 @@\n     expirationTimeId = type.nameToId(\"expirationTime\");\n   }\n \n+  public RedisStats(StatisticsFactory factory, StatisticsClock clock) {\n+    this(factory, \"redisStats\", clock);\n+  }\n+\n+  public RedisStats(StatisticsFactory factory, String textId, StatisticsClock clock) {\n+    stats = factory == null ? null : factory.createAtomicStatistics(type, textId);\n+    this.clock = clock;\n+    this.START_TIME_IN_NANOS = this.clock.getTime();\n+    perSecondExecutor = startPerSecondUpdater();\n+  }\n+\n+  public void clearAllStats() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4MzA4NQ=="}, "originalCommit": {"oid": "c99b65445f3c1ba224d52ef5d3fecc29c67b4baa"}, "originalPosition": 62}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4598, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}