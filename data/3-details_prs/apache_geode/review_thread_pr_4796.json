{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg2OTM4Nzc5", "number": 4796, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxNzozNDo1NlrODn6wkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxNzo0Nzo0NlrODn7AXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMTgzNzYzOnYy", "diffSide": "RIGHT", "path": "geode-membership/src/main/java/org/apache/geode/distributed/internal/membership/api/MembershipLocator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxNzozNDo1NlrOF2Mm-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxNzozNDo1NlrOF2Mm-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM3NDAxMQ==", "bodyText": "since the server socket has to be bound before it has an address, it makes sense not to refer to this as the \"bind address\" \u2713", "url": "https://github.com/apache/geode/pull/4796#discussion_r392374011", "createdAt": "2020-03-13T17:34:56Z", "author": {"login": "Bill"}, "path": "geode-membership/src/main/java/org/apache/geode/distributed/internal/membership/api/MembershipLocator.java", "diffHunk": "@@ -38,7 +38,7 @@\n \n   void restarting() throws IOException;\n \n-  SocketAddress getBindAddress();\n+  SocketAddress getSocketAddress();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3746afcb623e6072211591be35f69834c3ed1a63"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMTg0MDMxOnYy", "diffSide": "RIGHT", "path": "geode-tcp-server/src/main/java/org/apache/geode/distributed/internal/tcpserver/TcpServer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxNzozNTo0N1rOF2Moyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxNzozNTo0N1rOF2Moyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM3NDQ3NA==", "bodyText": "better!", "url": "https://github.com/apache/geode/pull/4796#discussion_r392374474", "createdAt": "2020-03-13T17:35:47Z", "author": {"login": "Bill"}, "path": "geode-tcp-server/src/main/java/org/apache/geode/distributed/internal/tcpserver/TcpServer.java", "diffHunk": "@@ -224,7 +224,7 @@ private void initializeServerSocket() throws IOException {\n    * @param millis how long to wait\n    */\n   public void join(long millis) throws InterruptedException {\n-    if (serverThread != null) {\n+    if (isAlive()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3746afcb623e6072211591be35f69834c3ed1a63"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMTg0MjEwOnYy", "diffSide": "RIGHT", "path": "geode-tcp-server/src/test/java/org/apache/geode/distributed/internal/tcpserver/HostAndPortTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxNzozNjoxOVrOF2Mp7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxNzo1NzoyOVrOF2NUJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM3NDc2NQ==", "bodyText": "there seems to be a misspelling here: \"Inent\"", "url": "https://github.com/apache/geode/pull/4796#discussion_r392374765", "createdAt": "2020-03-13T17:36:19Z", "author": {"login": "Bill"}, "path": "geode-tcp-server/src/test/java/org/apache/geode/distributed/internal/tcpserver/HostAndPortTest.java", "diffHunk": "@@ -14,19 +14,30 @@\n  */\n package org.apache.geode.distributed.internal.tcpserver;\n \n+import static org.apache.geode.internal.serialization.DataSerializableFixedID.HOST_AND_PORT;\n import static org.assertj.core.api.Assertions.assertThat;\n \n+import java.io.IOException;\n import java.net.InetSocketAddress;\n \n import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n \n+import org.apache.geode.internal.serialization.BufferDataOutputStream;\n+import org.apache.geode.internal.serialization.ByteArrayDataInput;\n+import org.apache.geode.internal.serialization.DSFIDSerializer;\n+import org.apache.geode.internal.serialization.DSFIDSerializerFactory;\n+import org.apache.geode.internal.serialization.Version;\n+import org.apache.geode.test.junit.categories.MembershipTest;\n+\n+@Category({MembershipTest.class})\n public class HostAndPortTest {\n \n   /**\n    * Test that getSocketInentAddress returns resolved InetSocketAddress\n    */\n   @Test\n-  public void Test_getSocketInentAddress_returns_resolved_SocketAddress() {\n+  public void getSocketInentAddress_returns_resolved_SocketAddress() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3746afcb623e6072211591be35f69834c3ed1a63"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM4NTU3Mw==", "bodyText": "fixed", "url": "https://github.com/apache/geode/pull/4796#discussion_r392385573", "createdAt": "2020-03-13T17:57:29Z", "author": {"login": "bschuchardt"}, "path": "geode-tcp-server/src/test/java/org/apache/geode/distributed/internal/tcpserver/HostAndPortTest.java", "diffHunk": "@@ -14,19 +14,30 @@\n  */\n package org.apache.geode.distributed.internal.tcpserver;\n \n+import static org.apache.geode.internal.serialization.DataSerializableFixedID.HOST_AND_PORT;\n import static org.assertj.core.api.Assertions.assertThat;\n \n+import java.io.IOException;\n import java.net.InetSocketAddress;\n \n import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n \n+import org.apache.geode.internal.serialization.BufferDataOutputStream;\n+import org.apache.geode.internal.serialization.ByteArrayDataInput;\n+import org.apache.geode.internal.serialization.DSFIDSerializer;\n+import org.apache.geode.internal.serialization.DSFIDSerializerFactory;\n+import org.apache.geode.internal.serialization.Version;\n+import org.apache.geode.test.junit.categories.MembershipTest;\n+\n+@Category({MembershipTest.class})\n public class HostAndPortTest {\n \n   /**\n    * Test that getSocketInentAddress returns resolved InetSocketAddress\n    */\n   @Test\n-  public void Test_getSocketInentAddress_returns_resolved_SocketAddress() {\n+  public void getSocketInentAddress_returns_resolved_SocketAddress() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM3NDc2NQ=="}, "originalCommit": {"oid": "3746afcb623e6072211591be35f69834c3ed1a63"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMTg1ODk0OnYy", "diffSide": "RIGHT", "path": "geode-tcp-server/src/test/java/org/apache/geode/distributed/internal/tcpserver/HostAndPortTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxNzo0MToyOVrOF2M0ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxODowMDo0M1rOF2NaSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM3NzUwMg==", "bodyText": "why would HostAndPort allow no hostname? is that only allowed during deserialization?", "url": "https://github.com/apache/geode/pull/4796#discussion_r392377502", "createdAt": "2020-03-13T17:41:29Z", "author": {"login": "Bill"}, "path": "geode-tcp-server/src/test/java/org/apache/geode/distributed/internal/tcpserver/HostAndPortTest.java", "diffHunk": "@@ -62,28 +73,97 @@ public void Test_equals_LocatorAddress_from_resolved_and_unresolved_SocketAddres\n   }\n \n   @Test\n-  public void Test_getPort_returns_port() {\n+  public void getPort_returns_port() {\n     HostAndPort locator1 = new HostAndPort(\"localhost\", 8090);\n     assertThat(locator1.getPort()).isEqualTo(8090);\n   }\n \n   @Test\n-  public void Test_getHostName_returns_hostname() {\n+  public void getHostName_returns_hostname() {\n     HostAndPort locator1 = new HostAndPort(\"fakelocalhost\", 8091);\n     assertThat(locator1.getHostName()).isEqualTo(\"fakelocalhost\");\n   }\n \n   @Test\n-  public void Test_hashCode_of_SocketAddress() {\n+  public void hashCode_of_SocketAddress() {\n     InetSocketAddress host1address = InetSocketAddress.createUnresolved(\"fakelocalhost\", 8091);\n     HostAndPort locator1 = new HostAndPort(\"fakelocalhost\", 8091);\n     assertThat(locator1.hashCode()).isEqualTo(host1address.hashCode());\n   }\n \n   @Test\n-  public void Test_toString_LocatorAddress() {\n+  public void toString_LocatorAddress() {\n     HostAndPort locator1 = new HostAndPort(\"fakelocalhost\", 8091);\n     assertThat(locator1.toString()).contains(\"socketInetAddress\");\n   }\n \n+  @Test\n+  public void constructorWithNoHostName() {\n+    HostAndPort hostAndPort = new HostAndPort(null, 8091);\n+    assertThat(hostAndPort.getAddress()).isNotNull();\n+    assertThat(hostAndPort.getHostName()).isEqualTo(\"0.0.0.0\");\n+    assertThat(hostAndPort.getPort()).isEqualTo(8091);\n+    assertThat(hostAndPort.getSocketInetAddress()).isNotNull();\n+  }\n+\n+  @Test\n+  public void testEquality() {\n+    HostAndPort hostAndPort1 = new HostAndPort(\"127.0.0.1\", 8091);\n+    HostAndPort hostAndPort2 = new HostAndPort(\"127.0.0.1\", 8091);\n+    HostAndPort hostAndPort3 = new HostAndPort(\"127.0.0.1\", 8092);\n+    assertThat(hostAndPort1.getSocketInetAddress()).isSameAs(hostAndPort1.getSocketInetAddress());\n+    assertThat(hostAndPort1).isEqualTo(hostAndPort1);\n+    assertThat(hostAndPort1).isEqualTo(hostAndPort2);\n+    assertThat(hostAndPort1).isNotEqualTo(hostAndPort3);\n+    assertThat(hostAndPort1.equals(null)).isFalse();\n+  }\n+\n+  @Test\n+  public void testSerializationWithNumericAddress() throws IOException, ClassNotFoundException {\n+    DSFIDSerializer dsfidSerializer = new DSFIDSerializerFactory().create();\n+    dsfidSerializer.registerDSFID(HOST_AND_PORT, HostAndPort.class);\n+    HostAndPort hostAndPort1 = new HostAndPort(\"127.0.0.1\", 8091);\n+    BufferDataOutputStream out = new BufferDataOutputStream(100, Version.CURRENT);\n+    dsfidSerializer.getObjectSerializer().writeObject(hostAndPort1, out);\n+    HostAndPort hostAndPort2 = dsfidSerializer.getObjectDeserializer()\n+        .readObject(new ByteArrayDataInput(out.toByteArray()));\n+    assertThat(hostAndPort1).isEqualTo(hostAndPort2);\n+    assertThat(hostAndPort2).isEqualTo(hostAndPort1);\n+  }\n+\n+  @Test\n+  public void testSerializationWithUnresolvableHostName()\n+      throws IOException, ClassNotFoundException {\n+    DSFIDSerializer dsfidSerializer = new DSFIDSerializerFactory().create();\n+    dsfidSerializer.registerDSFID(HOST_AND_PORT, HostAndPort.class);\n+    HostAndPort hostAndPort1 = new HostAndPort(\"unresolvable host name\", 8091);\n+    BufferDataOutputStream out = new BufferDataOutputStream(100, Version.CURRENT);\n+    dsfidSerializer.getObjectSerializer().writeObject(hostAndPort1, out);\n+    HostAndPort hostAndPort2 = dsfidSerializer.getObjectDeserializer()\n+        .readObject(new ByteArrayDataInput(out.toByteArray()));\n+    assertThat(hostAndPort1).isEqualTo(hostAndPort2);\n+    assertThat(hostAndPort2).isEqualTo(hostAndPort1);\n+    assertThat(hostAndPort1.getAddress()).isNull();\n+    assertThat(hostAndPort2.getAddress()).isNull();\n+    assertThat(hostAndPort2.getSocketInetAddress()).isNotNull();\n+    assertThat(hostAndPort1.getSocketInetAddress().isUnresolved()).isTrue();\n+    assertThat(hostAndPort2.getSocketInetAddress().isUnresolved()).isTrue();\n+  }\n+\n+  @Test\n+  public void testSerializationWithNoHostName() throws IOException, ClassNotFoundException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3746afcb623e6072211591be35f69834c3ed1a63"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM4MjAxMQ==", "bodyText": "I think it was for a local address.  That surprised me as well.", "url": "https://github.com/apache/geode/pull/4796#discussion_r392382011", "createdAt": "2020-03-13T17:50:22Z", "author": {"login": "bschuchardt"}, "path": "geode-tcp-server/src/test/java/org/apache/geode/distributed/internal/tcpserver/HostAndPortTest.java", "diffHunk": "@@ -62,28 +73,97 @@ public void Test_equals_LocatorAddress_from_resolved_and_unresolved_SocketAddres\n   }\n \n   @Test\n-  public void Test_getPort_returns_port() {\n+  public void getPort_returns_port() {\n     HostAndPort locator1 = new HostAndPort(\"localhost\", 8090);\n     assertThat(locator1.getPort()).isEqualTo(8090);\n   }\n \n   @Test\n-  public void Test_getHostName_returns_hostname() {\n+  public void getHostName_returns_hostname() {\n     HostAndPort locator1 = new HostAndPort(\"fakelocalhost\", 8091);\n     assertThat(locator1.getHostName()).isEqualTo(\"fakelocalhost\");\n   }\n \n   @Test\n-  public void Test_hashCode_of_SocketAddress() {\n+  public void hashCode_of_SocketAddress() {\n     InetSocketAddress host1address = InetSocketAddress.createUnresolved(\"fakelocalhost\", 8091);\n     HostAndPort locator1 = new HostAndPort(\"fakelocalhost\", 8091);\n     assertThat(locator1.hashCode()).isEqualTo(host1address.hashCode());\n   }\n \n   @Test\n-  public void Test_toString_LocatorAddress() {\n+  public void toString_LocatorAddress() {\n     HostAndPort locator1 = new HostAndPort(\"fakelocalhost\", 8091);\n     assertThat(locator1.toString()).contains(\"socketInetAddress\");\n   }\n \n+  @Test\n+  public void constructorWithNoHostName() {\n+    HostAndPort hostAndPort = new HostAndPort(null, 8091);\n+    assertThat(hostAndPort.getAddress()).isNotNull();\n+    assertThat(hostAndPort.getHostName()).isEqualTo(\"0.0.0.0\");\n+    assertThat(hostAndPort.getPort()).isEqualTo(8091);\n+    assertThat(hostAndPort.getSocketInetAddress()).isNotNull();\n+  }\n+\n+  @Test\n+  public void testEquality() {\n+    HostAndPort hostAndPort1 = new HostAndPort(\"127.0.0.1\", 8091);\n+    HostAndPort hostAndPort2 = new HostAndPort(\"127.0.0.1\", 8091);\n+    HostAndPort hostAndPort3 = new HostAndPort(\"127.0.0.1\", 8092);\n+    assertThat(hostAndPort1.getSocketInetAddress()).isSameAs(hostAndPort1.getSocketInetAddress());\n+    assertThat(hostAndPort1).isEqualTo(hostAndPort1);\n+    assertThat(hostAndPort1).isEqualTo(hostAndPort2);\n+    assertThat(hostAndPort1).isNotEqualTo(hostAndPort3);\n+    assertThat(hostAndPort1.equals(null)).isFalse();\n+  }\n+\n+  @Test\n+  public void testSerializationWithNumericAddress() throws IOException, ClassNotFoundException {\n+    DSFIDSerializer dsfidSerializer = new DSFIDSerializerFactory().create();\n+    dsfidSerializer.registerDSFID(HOST_AND_PORT, HostAndPort.class);\n+    HostAndPort hostAndPort1 = new HostAndPort(\"127.0.0.1\", 8091);\n+    BufferDataOutputStream out = new BufferDataOutputStream(100, Version.CURRENT);\n+    dsfidSerializer.getObjectSerializer().writeObject(hostAndPort1, out);\n+    HostAndPort hostAndPort2 = dsfidSerializer.getObjectDeserializer()\n+        .readObject(new ByteArrayDataInput(out.toByteArray()));\n+    assertThat(hostAndPort1).isEqualTo(hostAndPort2);\n+    assertThat(hostAndPort2).isEqualTo(hostAndPort1);\n+  }\n+\n+  @Test\n+  public void testSerializationWithUnresolvableHostName()\n+      throws IOException, ClassNotFoundException {\n+    DSFIDSerializer dsfidSerializer = new DSFIDSerializerFactory().create();\n+    dsfidSerializer.registerDSFID(HOST_AND_PORT, HostAndPort.class);\n+    HostAndPort hostAndPort1 = new HostAndPort(\"unresolvable host name\", 8091);\n+    BufferDataOutputStream out = new BufferDataOutputStream(100, Version.CURRENT);\n+    dsfidSerializer.getObjectSerializer().writeObject(hostAndPort1, out);\n+    HostAndPort hostAndPort2 = dsfidSerializer.getObjectDeserializer()\n+        .readObject(new ByteArrayDataInput(out.toByteArray()));\n+    assertThat(hostAndPort1).isEqualTo(hostAndPort2);\n+    assertThat(hostAndPort2).isEqualTo(hostAndPort1);\n+    assertThat(hostAndPort1.getAddress()).isNull();\n+    assertThat(hostAndPort2.getAddress()).isNull();\n+    assertThat(hostAndPort2.getSocketInetAddress()).isNotNull();\n+    assertThat(hostAndPort1.getSocketInetAddress().isUnresolved()).isTrue();\n+    assertThat(hostAndPort2.getSocketInetAddress().isUnresolved()).isTrue();\n+  }\n+\n+  @Test\n+  public void testSerializationWithNoHostName() throws IOException, ClassNotFoundException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM3NzUwMg=="}, "originalCommit": {"oid": "3746afcb623e6072211591be35f69834c3ed1a63"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM4NzE0Ng==", "bodyText": "oy ok", "url": "https://github.com/apache/geode/pull/4796#discussion_r392387146", "createdAt": "2020-03-13T18:00:43Z", "author": {"login": "Bill"}, "path": "geode-tcp-server/src/test/java/org/apache/geode/distributed/internal/tcpserver/HostAndPortTest.java", "diffHunk": "@@ -62,28 +73,97 @@ public void Test_equals_LocatorAddress_from_resolved_and_unresolved_SocketAddres\n   }\n \n   @Test\n-  public void Test_getPort_returns_port() {\n+  public void getPort_returns_port() {\n     HostAndPort locator1 = new HostAndPort(\"localhost\", 8090);\n     assertThat(locator1.getPort()).isEqualTo(8090);\n   }\n \n   @Test\n-  public void Test_getHostName_returns_hostname() {\n+  public void getHostName_returns_hostname() {\n     HostAndPort locator1 = new HostAndPort(\"fakelocalhost\", 8091);\n     assertThat(locator1.getHostName()).isEqualTo(\"fakelocalhost\");\n   }\n \n   @Test\n-  public void Test_hashCode_of_SocketAddress() {\n+  public void hashCode_of_SocketAddress() {\n     InetSocketAddress host1address = InetSocketAddress.createUnresolved(\"fakelocalhost\", 8091);\n     HostAndPort locator1 = new HostAndPort(\"fakelocalhost\", 8091);\n     assertThat(locator1.hashCode()).isEqualTo(host1address.hashCode());\n   }\n \n   @Test\n-  public void Test_toString_LocatorAddress() {\n+  public void toString_LocatorAddress() {\n     HostAndPort locator1 = new HostAndPort(\"fakelocalhost\", 8091);\n     assertThat(locator1.toString()).contains(\"socketInetAddress\");\n   }\n \n+  @Test\n+  public void constructorWithNoHostName() {\n+    HostAndPort hostAndPort = new HostAndPort(null, 8091);\n+    assertThat(hostAndPort.getAddress()).isNotNull();\n+    assertThat(hostAndPort.getHostName()).isEqualTo(\"0.0.0.0\");\n+    assertThat(hostAndPort.getPort()).isEqualTo(8091);\n+    assertThat(hostAndPort.getSocketInetAddress()).isNotNull();\n+  }\n+\n+  @Test\n+  public void testEquality() {\n+    HostAndPort hostAndPort1 = new HostAndPort(\"127.0.0.1\", 8091);\n+    HostAndPort hostAndPort2 = new HostAndPort(\"127.0.0.1\", 8091);\n+    HostAndPort hostAndPort3 = new HostAndPort(\"127.0.0.1\", 8092);\n+    assertThat(hostAndPort1.getSocketInetAddress()).isSameAs(hostAndPort1.getSocketInetAddress());\n+    assertThat(hostAndPort1).isEqualTo(hostAndPort1);\n+    assertThat(hostAndPort1).isEqualTo(hostAndPort2);\n+    assertThat(hostAndPort1).isNotEqualTo(hostAndPort3);\n+    assertThat(hostAndPort1.equals(null)).isFalse();\n+  }\n+\n+  @Test\n+  public void testSerializationWithNumericAddress() throws IOException, ClassNotFoundException {\n+    DSFIDSerializer dsfidSerializer = new DSFIDSerializerFactory().create();\n+    dsfidSerializer.registerDSFID(HOST_AND_PORT, HostAndPort.class);\n+    HostAndPort hostAndPort1 = new HostAndPort(\"127.0.0.1\", 8091);\n+    BufferDataOutputStream out = new BufferDataOutputStream(100, Version.CURRENT);\n+    dsfidSerializer.getObjectSerializer().writeObject(hostAndPort1, out);\n+    HostAndPort hostAndPort2 = dsfidSerializer.getObjectDeserializer()\n+        .readObject(new ByteArrayDataInput(out.toByteArray()));\n+    assertThat(hostAndPort1).isEqualTo(hostAndPort2);\n+    assertThat(hostAndPort2).isEqualTo(hostAndPort1);\n+  }\n+\n+  @Test\n+  public void testSerializationWithUnresolvableHostName()\n+      throws IOException, ClassNotFoundException {\n+    DSFIDSerializer dsfidSerializer = new DSFIDSerializerFactory().create();\n+    dsfidSerializer.registerDSFID(HOST_AND_PORT, HostAndPort.class);\n+    HostAndPort hostAndPort1 = new HostAndPort(\"unresolvable host name\", 8091);\n+    BufferDataOutputStream out = new BufferDataOutputStream(100, Version.CURRENT);\n+    dsfidSerializer.getObjectSerializer().writeObject(hostAndPort1, out);\n+    HostAndPort hostAndPort2 = dsfidSerializer.getObjectDeserializer()\n+        .readObject(new ByteArrayDataInput(out.toByteArray()));\n+    assertThat(hostAndPort1).isEqualTo(hostAndPort2);\n+    assertThat(hostAndPort2).isEqualTo(hostAndPort1);\n+    assertThat(hostAndPort1.getAddress()).isNull();\n+    assertThat(hostAndPort2.getAddress()).isNull();\n+    assertThat(hostAndPort2.getSocketInetAddress()).isNotNull();\n+    assertThat(hostAndPort1.getSocketInetAddress().isUnresolved()).isTrue();\n+    assertThat(hostAndPort2.getSocketInetAddress().isUnresolved()).isTrue();\n+  }\n+\n+  @Test\n+  public void testSerializationWithNoHostName() throws IOException, ClassNotFoundException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM3NzUwMg=="}, "originalCommit": {"oid": "3746afcb623e6072211591be35f69834c3ed1a63"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMTg3ODA2OnYy", "diffSide": "RIGHT", "path": "geode-tcp-server/src/test/java/org/apache/geode/distributed/internal/tcpserver/TcpServerJUnitTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxNzo0Nzo0NlrOF2NA_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxNzo1OToyOVrOF2NX6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM4MDY3MA==", "bodyText": "why was org.apache.geode.distributed.internal.InfoRequestHandler no longer suitable?", "url": "https://github.com/apache/geode/pull/4796#discussion_r392380670", "createdAt": "2020-03-13T17:47:46Z", "author": {"login": "Bill"}, "path": "geode-tcp-server/src/test/java/org/apache/geode/distributed/internal/tcpserver/TcpServerJUnitTest.java", "diffHunk": "@@ -344,19 +267,29 @@ public void endRequest(Object request, long startTime) {}\n     public void endResponse(Object request, long startTime) {}\n   }\n \n-  private/* GemStoneAddition */ static class SimpleStats implements PoolStatHelper {\n-    AtomicInteger ended = new AtomicInteger();\n-    AtomicInteger started = new AtomicInteger();\n \n+  public class InfoRequestHandler implements TcpHandler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3746afcb623e6072211591be35f69834c3ed1a63"}, "originalPosition": 219}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM4MjQ0Mw==", "bodyText": "That's a geode-core class.  It gets information from GemFireVersion, also in geode-core.", "url": "https://github.com/apache/geode/pull/4796#discussion_r392382443", "createdAt": "2020-03-13T17:51:12Z", "author": {"login": "bschuchardt"}, "path": "geode-tcp-server/src/test/java/org/apache/geode/distributed/internal/tcpserver/TcpServerJUnitTest.java", "diffHunk": "@@ -344,19 +267,29 @@ public void endRequest(Object request, long startTime) {}\n     public void endResponse(Object request, long startTime) {}\n   }\n \n-  private/* GemStoneAddition */ static class SimpleStats implements PoolStatHelper {\n-    AtomicInteger ended = new AtomicInteger();\n-    AtomicInteger started = new AtomicInteger();\n \n+  public class InfoRequestHandler implements TcpHandler {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM4MDY3MA=="}, "originalCommit": {"oid": "3746afcb623e6072211591be35f69834c3ed1a63"}, "originalPosition": 219}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM4NjUzNw==", "bodyText": "bravo!", "url": "https://github.com/apache/geode/pull/4796#discussion_r392386537", "createdAt": "2020-03-13T17:59:29Z", "author": {"login": "Bill"}, "path": "geode-tcp-server/src/test/java/org/apache/geode/distributed/internal/tcpserver/TcpServerJUnitTest.java", "diffHunk": "@@ -344,19 +267,29 @@ public void endRequest(Object request, long startTime) {}\n     public void endResponse(Object request, long startTime) {}\n   }\n \n-  private/* GemStoneAddition */ static class SimpleStats implements PoolStatHelper {\n-    AtomicInteger ended = new AtomicInteger();\n-    AtomicInteger started = new AtomicInteger();\n \n+  public class InfoRequestHandler implements TcpHandler {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM4MDY3MA=="}, "originalCommit": {"oid": "3746afcb623e6072211591be35f69834c3ed1a63"}, "originalPosition": 219}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4357, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}