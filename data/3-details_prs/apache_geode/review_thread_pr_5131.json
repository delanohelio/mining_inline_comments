{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIwMTkyMjk4", "number": 5131, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwMjowMDozMFrOD-ziNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwMjowMDozMFrOD-ziNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MTgyNjQ1OnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/internal/net/SocketCreator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwMjowMDozMFrOGZIYsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTozMTo1M1rOGZbXBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAwNDk3OQ==", "bodyText": "This strikes me as a security issue. Let's say I issued a start server with locators=1.2.3.4, which is bad but stick with me. Then here we lookup 1.2.3.4's PTR record. What if someone has maliciously inserted themselves into my DNS resolution path, easy to do with out greater adoption of DNSSEC. So my reverse lookup finds 1.2.3.4 PTR locator1.malicious.com and adds \"locator1.malicious.com\" to the SNI and proceeds to connect. Then connection is established to what our network stack thinks is 1.2.3.4, but is really our malicious router redirecting the connection. Now the malicious host will respond with a valid signed certificate for \"locator1.malicious.com\" and we will happily verify it. Of course that assumes also that the malicious certificate is signed by someone in our chain of trust. So, not a likely attack vector since we don't trust the root signers by default but not something a service that does trust the roots should ever do.", "url": "https://github.com/apache/geode/pull/5131#discussion_r429004979", "createdAt": "2020-05-22T02:00:30Z", "author": {"login": "pivotal-jbarrett"}, "path": "geode-core/src/main/java/org/apache/geode/internal/net/SocketCreator.java", "diffHunk": "@@ -791,7 +792,19 @@ private boolean setServerNames(SSLParameters modifiedParams, HostAndPort addr) {\n       return false;\n     }\n \n-    serverNames.add(new SNIHostName(addr.getHostName()));\n+    String hostName = addr.getHostName();\n+    if (this.sslConfig.doEndpointIdentification()\n+        && InetAddressValidator.getInstance().isValid(hostName)) {\n+      // endpoint validation typically uses a hostname in the sniServer parameter that the handshake\n+      // will compare against the subject alternative addresses in the server's certificate. Here\n+      // we attempt to get a hostname instead of the proffered numeric address\n+      try {\n+        hostName = InetAddress.getByName(hostName).getCanonicalHostName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26827452337899bcccf3211bcb6c089a7e23cbb8"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMxNTg0NQ==", "bodyText": "As you mentioned offline, the same malicious entity could inject the IP into their SAN and we would validate that. I don't think this code makes anything any less secure from that standpoint so I am removing my block.", "url": "https://github.com/apache/geode/pull/5131#discussion_r429315845", "createdAt": "2020-05-22T15:31:53Z", "author": {"login": "pivotal-jbarrett"}, "path": "geode-core/src/main/java/org/apache/geode/internal/net/SocketCreator.java", "diffHunk": "@@ -791,7 +792,19 @@ private boolean setServerNames(SSLParameters modifiedParams, HostAndPort addr) {\n       return false;\n     }\n \n-    serverNames.add(new SNIHostName(addr.getHostName()));\n+    String hostName = addr.getHostName();\n+    if (this.sslConfig.doEndpointIdentification()\n+        && InetAddressValidator.getInstance().isValid(hostName)) {\n+      // endpoint validation typically uses a hostname in the sniServer parameter that the handshake\n+      // will compare against the subject alternative addresses in the server's certificate. Here\n+      // we attempt to get a hostname instead of the proffered numeric address\n+      try {\n+        hostName = InetAddress.getByName(hostName).getCanonicalHostName();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAwNDk3OQ=="}, "originalCommit": {"oid": "26827452337899bcccf3211bcb6c089a7e23cbb8"}, "originalPosition": 29}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4078, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}