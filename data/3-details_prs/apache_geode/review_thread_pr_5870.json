{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQzNzM2MzYx", "number": 5870, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQwMDoyNjoyM1rOFLGVTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQwMDozMzozOVrOFLGasQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MTgyNDEzOnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueue.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQwMDoyNjoyM1rOIOF51Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQwMDozNTowM1rOIOGDUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTY0NzcwMQ==", "bodyText": "Do we having testing around this now synchronized method?", "url": "https://github.com/apache/geode/pull/5870#discussion_r551647701", "createdAt": "2021-01-05T00:26:23Z", "author": {"login": "echobravopapa"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueue.java", "diffHunk": "@@ -255,23 +247,18 @@ public void destroy() {\n   }\n \n   @Override\n-  public boolean put(Object event) throws CacheException {\n-    lock.writeLock().lock();\n-    try {\n-      GatewaySenderEventImpl eventImpl = (GatewaySenderEventImpl) event;\n-      final Region r = eventImpl.getRegion();\n-      final boolean isPDXRegion =\n-          (r instanceof DistributedRegion && r.getName().equals(PeerTypeRegistration.REGION_NAME));\n-      final boolean isWbcl =\n-          this.regionName.startsWith(AsyncEventQueueImpl.ASYNC_EVENT_QUEUE_PREFIX);\n-      if (!(isPDXRegion && isWbcl)) {\n-        putAndGetKey(event);\n-        return true;\n-      }\n-      return false;\n-    } finally {\n-      lock.writeLock().unlock();\n+  public synchronized boolean put(Object event) throws CacheException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8b04f090553f7e790a6a6964f1a95db7ad0bbe5"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTY1MDEyOQ==", "bodyText": "I didn't see any code changes for usage of this method...", "url": "https://github.com/apache/geode/pull/5870#discussion_r551650129", "createdAt": "2021-01-05T00:35:03Z", "author": {"login": "echobravopapa"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueue.java", "diffHunk": "@@ -255,23 +247,18 @@ public void destroy() {\n   }\n \n   @Override\n-  public boolean put(Object event) throws CacheException {\n-    lock.writeLock().lock();\n-    try {\n-      GatewaySenderEventImpl eventImpl = (GatewaySenderEventImpl) event;\n-      final Region r = eventImpl.getRegion();\n-      final boolean isPDXRegion =\n-          (r instanceof DistributedRegion && r.getName().equals(PeerTypeRegistration.REGION_NAME));\n-      final boolean isWbcl =\n-          this.regionName.startsWith(AsyncEventQueueImpl.ASYNC_EVENT_QUEUE_PREFIX);\n-      if (!(isPDXRegion && isWbcl)) {\n-        putAndGetKey(event);\n-        return true;\n-      }\n-      return false;\n-    } finally {\n-      lock.writeLock().unlock();\n+  public synchronized boolean put(Object event) throws CacheException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTY0NzcwMQ=="}, "originalCommit": {"oid": "f8b04f090553f7e790a6a6964f1a95db7ad0bbe5"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MTgzNzkzOnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueue.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQwMDozMzozOVrOIOGB-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQwMDozMzozOVrOIOGB-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTY0OTc4NQ==", "bodyText": "I was going to ask why this was re-ordered, but its just the diff making it look that way...", "url": "https://github.com/apache/geode/pull/5870#discussion_r551649785", "createdAt": "2021-01-05T00:33:39Z", "author": {"login": "echobravopapa"}, "path": "geode-core/src/main/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueue.java", "diffHunk": "@@ -316,71 +304,66 @@ public AsyncEvent take() throws CacheException {\n    * have peeked. If the entry was not peeked, this method will silently return.\n    */\n   @Override\n-  public void remove() throws CacheException {\n-    lock.writeLock().lock();\n+  public synchronized void remove() throws CacheException {\n+    if (peekedIds.isEmpty()) {\n+      return;\n+    }\n+    Long key = peekedIds.remove();\n+    boolean isExtraPeeked = extraPeekedIds.remove(key);\n     try {\n-      if (peekedIds.isEmpty()) {\n-        return;\n+      // Increment the head key\n+      if (!isExtraPeeked) {\n+        updateHeadKey(key.longValue());\n       }\n-      Long key = peekedIds.remove();\n-      boolean isExtraPeeked = extraPeekedIds.remove(key);\n-      try {\n-        // Increment the head key\n-        if (!isExtraPeeked) {\n-          updateHeadKey(key.longValue());\n-        }\n-        removeIndex(key);\n-        // Remove the entry at that key with a callback arg signifying it is\n-        // a WAN queue so that AbstractRegionEntry.destroy can get the value\n-        // even if it has been evicted to disk. In the normal case, the\n-        // AbstractRegionEntry.destroy only gets the value in the VM.\n-        this.region.localDestroy(key, WAN_QUEUE_TOKEN);\n-        this.stats.decQueueSize();\n-\n-      } catch (EntryNotFoundException ok) {\n-        // this is acceptable because the conflation can remove entries\n-        // out from underneath us.\n-        if (logger.isDebugEnabled()) {\n-          logger.debug(\n-              \"{}: Did not destroy entry at {} it was not there. It should have been removed by conflation.\",\n-              this, key);\n-        }\n+      removeIndex(key);\n+      // Remove the entry at that key with a callback arg signifying it is\n+      // a WAN queue so that AbstractRegionEntry.destroy can get the value\n+      // even if it has been evicted to disk. In the normal case, the\n+      // AbstractRegionEntry.destroy only gets the value in the VM.\n+      this.region.localDestroy(key, WAN_QUEUE_TOKEN);\n+      this.stats.decQueueSize();\n+\n+    } catch (EntryNotFoundException ok) {\n+      // this is acceptable because the conflation can remove entries\n+      // out from underneath us.\n+      if (logger.isDebugEnabled()) {\n+        logger.debug(\n+            \"{}: Did not destroy entry at {} it was not there. It should have been removed by conflation.\",\n+            this, key);\n       }\n+    }\n \n-      boolean wasEmpty = this.lastDispatchedKey == this.lastDestroyedKey;\n-      if (!isExtraPeeked) {\n+    boolean wasEmpty = this.lastDispatchedKey == this.lastDestroyedKey;\n+    if (!isExtraPeeked) {\n+      this.lastDispatchedKey = key;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8b04f090553f7e790a6a6964f1a95db7ad0bbe5"}, "originalPosition": 129}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4866, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}