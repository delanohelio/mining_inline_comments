{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAzNTk5Nzg1", "number": 5627, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDozODozM1rOEuKl1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDozODozM1rOEuKl1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2ODQzNDc3OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/key/ScanExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDozODozM1rOHiZQxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMTozMjowM1rOHib90A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyNzUyNw==", "bodyText": "I think it would be better to have this return a Pair<BigInteger, List<Object>> - that way it's not hiding the fact that the zero-th element is special.", "url": "https://github.com/apache/geode/pull/5627#discussion_r505827527", "createdAt": "2020-10-15T20:38:33Z", "author": {"login": "jdeppe-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/key/ScanExecutor.java", "diffHunk": "@@ -36,91 +39,87 @@\n   public RedisResponse executeCommand(Command command, ExecutionHandlerContext context) {\n     List<byte[]> commandElems = command.getProcessedCommand();\n \n-    if (commandElems.size() < 2) {\n-      return RedisResponse.error(ArityDef.SCAN);\n-    }\n-\n     String cursorString = command.getStringKey();\n-    int cursor = 0;\n-    Pattern matchPattern = null;\n-    String globMatchString = null;\n+    BigInteger cursor;\n+    Pattern matchPattern;\n+    String globPattern = null;\n     int count = DEFAULT_COUNT;\n+\n     try {\n-      cursor = Integer.parseInt(cursorString);\n+      cursor = new BigInteger(cursorString).abs();\n     } catch (NumberFormatException e) {\n       return RedisResponse.error(ERROR_CURSOR);\n     }\n-    if (cursor < 0) {\n+\n+    if (cursor.compareTo(UNSIGNED_LONG_CAPACITY) > 0) {\n       return RedisResponse.error(ERROR_CURSOR);\n     }\n \n-    if (commandElems.size() > 3) {\n-      try {\n-        byte[] bytes = commandElems.get(2);\n-        String tmp = Coder.bytesToString(bytes);\n-        if (tmp.equalsIgnoreCase(\"MATCH\")) {\n-          bytes = commandElems.get(3);\n-          globMatchString = Coder.bytesToString(bytes);\n-        } else if (tmp.equalsIgnoreCase(\"COUNT\")) {\n-          bytes = commandElems.get(3);\n-          count = Coder.bytesToInt(bytes);\n-        }\n-      } catch (NumberFormatException e) {\n-        return RedisResponse.error(ERROR_COUNT);\n-      }\n+    if (!cursor.equals(context.getScanCursor())) {\n+      cursor = new BigInteger(\"0\");\n     }\n \n-    if (commandElems.size() > 5) {\n-      try {\n-        byte[] bytes = commandElems.get(4);\n-        String tmp = Coder.bytesToString(bytes);\n-        if (tmp.equalsIgnoreCase(\"COUNT\")) {\n-          bytes = commandElems.get(5);\n-          count = Coder.bytesToInt(bytes);\n+    for (int i = 2; i < commandElems.size(); i = i + 2) {\n+      byte[] commandElemBytes = commandElems.get(i);\n+      String keyword = Coder.bytesToString(commandElemBytes);\n+      if (keyword.equalsIgnoreCase(\"MATCH\")) {\n+        commandElemBytes = commandElems.get(i + 1);\n+        globPattern = Coder.bytesToString(commandElemBytes);\n+\n+      } else if (keyword.equalsIgnoreCase(\"COUNT\")) {\n+        commandElemBytes = commandElems.get(i + 1);\n+        try {\n+          count = Coder.bytesToInt(commandElemBytes);\n+        } catch (NumberFormatException e) {\n+          return RedisResponse.error(ERROR_NOT_INTEGER);\n+        }\n+\n+        if (count < 1) {\n+          return RedisResponse.error(ERROR_SYNTAX);\n         }\n-      } catch (NumberFormatException e) {\n-        return RedisResponse.error(ERROR_COUNT);\n-      }\n-    }\n \n-    if (count < 0) {\n-      return RedisResponse.error(ERROR_COUNT);\n+      } else {\n+        return RedisResponse.error(ERROR_SYNTAX);\n+      }\n     }\n \n     try {\n-      matchPattern = convertGlobToRegex(globMatchString);\n+      matchPattern = convertGlobToRegex(globPattern);\n     } catch (PatternSyntaxException e) {\n-      return RedisResponse.error(ERROR_ILLEGAL_GLOB);\n+      LogService.getLogger().warn(\n+          \"Could not compile the pattern: '{}' due to the following exception: '{}'. SCAN will return an empty list.\",\n+          globPattern, e.getMessage());\n+      return RedisResponse.emptyScan();\n     }\n \n-    List<String> returnList = getIteration(getDataRegion(context).keySet(), matchPattern, count,\n+    List<Object> returnList = scan(getDataRegion(context).keySet(), matchPattern, count,\n         cursor);\n+    context.setScanCursor(new BigInteger((String) returnList.get(0)));\n \n     return RedisResponse.scan(returnList);\n   }\n \n-  private List<String> getIteration(Collection<ByteArrayWrapper> list, Pattern matchPattern,\n-      int count, int cursor) {\n-    List<String> returnList = new ArrayList<>();\n+  private List<Object> scan(Collection<ByteArrayWrapper> list, Pattern matchPattern,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7cbf856077d42e0c805820936d00636d284997ed"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg3MTgyNA==", "bodyText": "Good idea! I just implemented it. Let me know what you think.", "url": "https://github.com/apache/geode/pull/5627#discussion_r505871824", "createdAt": "2020-10-15T21:32:03Z", "author": {"login": "sabbey37"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/key/ScanExecutor.java", "diffHunk": "@@ -36,91 +39,87 @@\n   public RedisResponse executeCommand(Command command, ExecutionHandlerContext context) {\n     List<byte[]> commandElems = command.getProcessedCommand();\n \n-    if (commandElems.size() < 2) {\n-      return RedisResponse.error(ArityDef.SCAN);\n-    }\n-\n     String cursorString = command.getStringKey();\n-    int cursor = 0;\n-    Pattern matchPattern = null;\n-    String globMatchString = null;\n+    BigInteger cursor;\n+    Pattern matchPattern;\n+    String globPattern = null;\n     int count = DEFAULT_COUNT;\n+\n     try {\n-      cursor = Integer.parseInt(cursorString);\n+      cursor = new BigInteger(cursorString).abs();\n     } catch (NumberFormatException e) {\n       return RedisResponse.error(ERROR_CURSOR);\n     }\n-    if (cursor < 0) {\n+\n+    if (cursor.compareTo(UNSIGNED_LONG_CAPACITY) > 0) {\n       return RedisResponse.error(ERROR_CURSOR);\n     }\n \n-    if (commandElems.size() > 3) {\n-      try {\n-        byte[] bytes = commandElems.get(2);\n-        String tmp = Coder.bytesToString(bytes);\n-        if (tmp.equalsIgnoreCase(\"MATCH\")) {\n-          bytes = commandElems.get(3);\n-          globMatchString = Coder.bytesToString(bytes);\n-        } else if (tmp.equalsIgnoreCase(\"COUNT\")) {\n-          bytes = commandElems.get(3);\n-          count = Coder.bytesToInt(bytes);\n-        }\n-      } catch (NumberFormatException e) {\n-        return RedisResponse.error(ERROR_COUNT);\n-      }\n+    if (!cursor.equals(context.getScanCursor())) {\n+      cursor = new BigInteger(\"0\");\n     }\n \n-    if (commandElems.size() > 5) {\n-      try {\n-        byte[] bytes = commandElems.get(4);\n-        String tmp = Coder.bytesToString(bytes);\n-        if (tmp.equalsIgnoreCase(\"COUNT\")) {\n-          bytes = commandElems.get(5);\n-          count = Coder.bytesToInt(bytes);\n+    for (int i = 2; i < commandElems.size(); i = i + 2) {\n+      byte[] commandElemBytes = commandElems.get(i);\n+      String keyword = Coder.bytesToString(commandElemBytes);\n+      if (keyword.equalsIgnoreCase(\"MATCH\")) {\n+        commandElemBytes = commandElems.get(i + 1);\n+        globPattern = Coder.bytesToString(commandElemBytes);\n+\n+      } else if (keyword.equalsIgnoreCase(\"COUNT\")) {\n+        commandElemBytes = commandElems.get(i + 1);\n+        try {\n+          count = Coder.bytesToInt(commandElemBytes);\n+        } catch (NumberFormatException e) {\n+          return RedisResponse.error(ERROR_NOT_INTEGER);\n+        }\n+\n+        if (count < 1) {\n+          return RedisResponse.error(ERROR_SYNTAX);\n         }\n-      } catch (NumberFormatException e) {\n-        return RedisResponse.error(ERROR_COUNT);\n-      }\n-    }\n \n-    if (count < 0) {\n-      return RedisResponse.error(ERROR_COUNT);\n+      } else {\n+        return RedisResponse.error(ERROR_SYNTAX);\n+      }\n     }\n \n     try {\n-      matchPattern = convertGlobToRegex(globMatchString);\n+      matchPattern = convertGlobToRegex(globPattern);\n     } catch (PatternSyntaxException e) {\n-      return RedisResponse.error(ERROR_ILLEGAL_GLOB);\n+      LogService.getLogger().warn(\n+          \"Could not compile the pattern: '{}' due to the following exception: '{}'. SCAN will return an empty list.\",\n+          globPattern, e.getMessage());\n+      return RedisResponse.emptyScan();\n     }\n \n-    List<String> returnList = getIteration(getDataRegion(context).keySet(), matchPattern, count,\n+    List<Object> returnList = scan(getDataRegion(context).keySet(), matchPattern, count,\n         cursor);\n+    context.setScanCursor(new BigInteger((String) returnList.get(0)));\n \n     return RedisResponse.scan(returnList);\n   }\n \n-  private List<String> getIteration(Collection<ByteArrayWrapper> list, Pattern matchPattern,\n-      int count, int cursor) {\n-    List<String> returnList = new ArrayList<>();\n+  private List<Object> scan(Collection<ByteArrayWrapper> list, Pattern matchPattern,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyNzUyNw=="}, "originalCommit": {"oid": "7cbf856077d42e0c805820936d00636d284997ed"}, "originalPosition": 127}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4710, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}