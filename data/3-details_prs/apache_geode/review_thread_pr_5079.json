{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE1NDA1NTU5", "number": 5079, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNDoxMjozNFrOD8Fb3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNjo1MDo1M1rOD8JwRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MzMwMjA0OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/session/RedisSessionDistDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNDoxMjozNFrOGUzmgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQyMTowMDowNFrOGVuBJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ3MDE0Nw==", "bodyText": "This is cool... should we add this annotation to our other tests? What is the intent?", "url": "https://github.com/apache/geode/pull/5079#discussion_r424470147", "createdAt": "2020-05-13T14:12:34Z", "author": {"login": "sabbey37"}, "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/session/RedisSessionDistDUnitTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.redis.session;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.Map;\n+\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+import org.apache.geode.test.junit.categories.RedisTest;\n+\n+@Category({RedisTest.class})", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e2263ec3a1eb2a387e6c6dc487f13dc8b111133"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQyNzIzOQ==", "bodyText": "Historically tests were run by Category. I don't think that is used anymore though.", "url": "https://github.com/apache/geode/pull/5079#discussion_r425427239", "createdAt": "2020-05-14T21:00:04Z", "author": {"login": "jdeppe-pivotal"}, "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/session/RedisSessionDistDUnitTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.redis.session;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.Map;\n+\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+import org.apache.geode.test.junit.categories.RedisTest;\n+\n+@Category({RedisTest.class})", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ3MDE0Nw=="}, "originalCommit": {"oid": "8e2263ec3a1eb2a387e6c6dc487f13dc8b111133"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MzM2NTA5OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/session/SessionDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNDoyNjoxNlrOGU0PmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQyMToxMjo1NlrOGVua9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ4MDY2NA==", "bodyText": "Not sure if something weird happened with a rename, but could this parameter could just be named \"server\"?", "url": "https://github.com/apache/geode/pull/5079#discussion_r424480664", "createdAt": "2020-05-13T14:26:16Z", "author": {"login": "sabbey37"}, "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/session/SessionDUnitTest.java", "diffHunk": "@@ -80,137 +84,62 @@ public static void setup() {\n     cluster.startLocatorVM(LOCATOR);\n     startRedisServer(SERVER1);\n     startRedisServer(SERVER2);\n-    startSpringApp(APP1, SERVER1, SERVER2);\n-    startSpringApp(APP2, SERVER2, SERVER1);\n \n-    jedis = new Jedis(\"localhost\", ports.get(SERVER1), JEDIS_TIMEOUT);\n-  }\n-\n-  @After\n-  public void cleanupAfterTest() {\n-    jedis.flushAll();\n+    jedisConnetedToServer1 = new Jedis(\"localhost\", ports.get(SERVER1), JEDIS_TIMEOUT);\n   }\n \n   @AfterClass\n   public static void cleanupAfterClass() {\n-    jedis.disconnect();\n-  }\n-\n-  @Test\n-  public void should_beAbleToCreateASession_storedInRedis() {\n-    String sessionCookie = createNewSessionWithNote(APP1, \"note1\");\n-    String sessionId = getSessionId(sessionCookie);\n-\n-    Map<String, String> sessionInfo =\n-        jedis.hgetAll(\"spring:session:sessions:\" + sessionId);\n-\n-    assertThat(sessionInfo.get(\"sessionAttr:NOTES\")).contains(\"note1\");\n-  }\n-\n-  @Test\n-  public void should_storeSession() {\n-    String sessionCookie = createNewSessionWithNote(APP1, \"note1\");\n-\n-    String[] sessionNotes = getSessionNotes(APP2, sessionCookie);\n-\n-    assertThat(sessionNotes).containsExactly(\"note1\");\n-  }\n-\n-  @Test\n-  public void should_propagateSession_toOtherServers() {\n-    String sessionCookie = createNewSessionWithNote(APP1, \"noteFromClient1\");\n-\n-    String[] sessionNotes = getSessionNotes(APP2, sessionCookie);\n-\n-    assertThat(sessionNotes).containsExactly(\"noteFromClient1\");\n-  }\n-\n-  @Test\n-  public void should_getSessionFromServer1_whenServer2GoesDown() {\n-    String sessionCookie = createNewSessionWithNote(APP2, \"noteFromClient2\");\n-    cluster.crashVM(SERVER2);\n-    try {\n-      String[] sessionNotes = getSessionNotes(APP1, sessionCookie);\n-\n-      assertThat(sessionNotes).containsExactly(\"noteFromClient2\");\n-    } finally {\n-      startRedisServer(SERVER2);\n-    }\n-  }\n-\n-  @Test\n-  public void should_getSessionFromServer_whenServerGoesDownAndIsRestarted() {\n-    String sessionCookie = createNewSessionWithNote(APP2, \"noteFromClient2\");\n-    cluster.crashVM(SERVER2);\n-    addNoteToSession(APP1, sessionCookie);\n-    startRedisServer(SERVER2);\n-\n-    String[] sessionNotes = getSessionNotes(APP2, sessionCookie);\n-\n-    assertThat(sessionNotes).containsExactly(\"noteFromClient2\", \"noteFromClient1\");\n-  }\n-\n-  @Test\n-  public void should_getSession_whenServer2GoesDown_andAppFailsOverToServer1() {\n-    String sessionCookie = createNewSessionWithNote(APP2, \"noteFromClient2\");\n-    cluster.crashVM(SERVER2);\n-\n-    try {\n-      String[] sessionNotes = getSessionNotes(APP2, sessionCookie);\n-\n-      assertThat(sessionNotes).containsExactly(\"noteFromClient2\");\n-    } finally {\n-      startRedisServer(SERVER2);\n-    }\n-  }\n-\n-  @Test\n-  public void should_getSessionCreatedByApp2_whenApp2GoesDown_andClientConnectsToApp1() {\n-    String sessionCookie = createNewSessionWithNote(APP2, \"noteFromClient2\");\n+    jedisConnetedToServer1.disconnect();\n+    stopSpringApp(APP1);\n     stopSpringApp(APP2);\n+  }\n \n-    try {\n-      String[] sessionNotes = getSessionNotes(APP1, sessionCookie);\n-\n-      assertThat(sessionNotes).containsExactly(\"noteFromClient2\");\n-    } finally {\n-      startSpringApp(APP2, SERVER1, SERVER2);\n-    }\n-\n+  @After\n+  public void cleanupAfterTest() {\n+    jedisConnetedToServer1.flushAll();\n   }\n \n-  private static void startRedisServer(int server1) {\n+  protected static void startRedisServer(int server1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e2263ec3a1eb2a387e6c6dc487f13dc8b111133"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQzMzg0Ng==", "bodyText": "Done", "url": "https://github.com/apache/geode/pull/5079#discussion_r425433846", "createdAt": "2020-05-14T21:12:56Z", "author": {"login": "jdeppe-pivotal"}, "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/session/SessionDUnitTest.java", "diffHunk": "@@ -80,137 +84,62 @@ public static void setup() {\n     cluster.startLocatorVM(LOCATOR);\n     startRedisServer(SERVER1);\n     startRedisServer(SERVER2);\n-    startSpringApp(APP1, SERVER1, SERVER2);\n-    startSpringApp(APP2, SERVER2, SERVER1);\n \n-    jedis = new Jedis(\"localhost\", ports.get(SERVER1), JEDIS_TIMEOUT);\n-  }\n-\n-  @After\n-  public void cleanupAfterTest() {\n-    jedis.flushAll();\n+    jedisConnetedToServer1 = new Jedis(\"localhost\", ports.get(SERVER1), JEDIS_TIMEOUT);\n   }\n \n   @AfterClass\n   public static void cleanupAfterClass() {\n-    jedis.disconnect();\n-  }\n-\n-  @Test\n-  public void should_beAbleToCreateASession_storedInRedis() {\n-    String sessionCookie = createNewSessionWithNote(APP1, \"note1\");\n-    String sessionId = getSessionId(sessionCookie);\n-\n-    Map<String, String> sessionInfo =\n-        jedis.hgetAll(\"spring:session:sessions:\" + sessionId);\n-\n-    assertThat(sessionInfo.get(\"sessionAttr:NOTES\")).contains(\"note1\");\n-  }\n-\n-  @Test\n-  public void should_storeSession() {\n-    String sessionCookie = createNewSessionWithNote(APP1, \"note1\");\n-\n-    String[] sessionNotes = getSessionNotes(APP2, sessionCookie);\n-\n-    assertThat(sessionNotes).containsExactly(\"note1\");\n-  }\n-\n-  @Test\n-  public void should_propagateSession_toOtherServers() {\n-    String sessionCookie = createNewSessionWithNote(APP1, \"noteFromClient1\");\n-\n-    String[] sessionNotes = getSessionNotes(APP2, sessionCookie);\n-\n-    assertThat(sessionNotes).containsExactly(\"noteFromClient1\");\n-  }\n-\n-  @Test\n-  public void should_getSessionFromServer1_whenServer2GoesDown() {\n-    String sessionCookie = createNewSessionWithNote(APP2, \"noteFromClient2\");\n-    cluster.crashVM(SERVER2);\n-    try {\n-      String[] sessionNotes = getSessionNotes(APP1, sessionCookie);\n-\n-      assertThat(sessionNotes).containsExactly(\"noteFromClient2\");\n-    } finally {\n-      startRedisServer(SERVER2);\n-    }\n-  }\n-\n-  @Test\n-  public void should_getSessionFromServer_whenServerGoesDownAndIsRestarted() {\n-    String sessionCookie = createNewSessionWithNote(APP2, \"noteFromClient2\");\n-    cluster.crashVM(SERVER2);\n-    addNoteToSession(APP1, sessionCookie);\n-    startRedisServer(SERVER2);\n-\n-    String[] sessionNotes = getSessionNotes(APP2, sessionCookie);\n-\n-    assertThat(sessionNotes).containsExactly(\"noteFromClient2\", \"noteFromClient1\");\n-  }\n-\n-  @Test\n-  public void should_getSession_whenServer2GoesDown_andAppFailsOverToServer1() {\n-    String sessionCookie = createNewSessionWithNote(APP2, \"noteFromClient2\");\n-    cluster.crashVM(SERVER2);\n-\n-    try {\n-      String[] sessionNotes = getSessionNotes(APP2, sessionCookie);\n-\n-      assertThat(sessionNotes).containsExactly(\"noteFromClient2\");\n-    } finally {\n-      startRedisServer(SERVER2);\n-    }\n-  }\n-\n-  @Test\n-  public void should_getSessionCreatedByApp2_whenApp2GoesDown_andClientConnectsToApp1() {\n-    String sessionCookie = createNewSessionWithNote(APP2, \"noteFromClient2\");\n+    jedisConnetedToServer1.disconnect();\n+    stopSpringApp(APP1);\n     stopSpringApp(APP2);\n+  }\n \n-    try {\n-      String[] sessionNotes = getSessionNotes(APP1, sessionCookie);\n-\n-      assertThat(sessionNotes).containsExactly(\"noteFromClient2\");\n-    } finally {\n-      startSpringApp(APP2, SERVER1, SERVER2);\n-    }\n-\n+  @After\n+  public void cleanupAfterTest() {\n+    jedisConnetedToServer1.flushAll();\n   }\n \n-  private static void startRedisServer(int server1) {\n+  protected static void startRedisServer(int server1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ4MDY2NA=="}, "originalCommit": {"oid": "8e2263ec3a1eb2a387e6c6dc487f13dc8b111133"}, "originalPosition": 192}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MzM2NzI1OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/session/SessionDUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNDoyNjo0NlrOGU0RKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQyMToxMjo0M1rOGVuamg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ4MTA2NA==", "bodyText": "same as above: could this parameter could just be named \"server\"?", "url": "https://github.com/apache/geode/pull/5079#discussion_r424481064", "createdAt": "2020-05-13T14:26:46Z", "author": {"login": "sabbey37"}, "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/session/SessionDUnitTest.java", "diffHunk": "@@ -80,137 +84,62 @@ public static void setup() {\n     cluster.startLocatorVM(LOCATOR);\n     startRedisServer(SERVER1);\n     startRedisServer(SERVER2);\n-    startSpringApp(APP1, SERVER1, SERVER2);\n-    startSpringApp(APP2, SERVER2, SERVER1);\n \n-    jedis = new Jedis(\"localhost\", ports.get(SERVER1), JEDIS_TIMEOUT);\n-  }\n-\n-  @After\n-  public void cleanupAfterTest() {\n-    jedis.flushAll();\n+    jedisConnetedToServer1 = new Jedis(\"localhost\", ports.get(SERVER1), JEDIS_TIMEOUT);\n   }\n \n   @AfterClass\n   public static void cleanupAfterClass() {\n-    jedis.disconnect();\n-  }\n-\n-  @Test\n-  public void should_beAbleToCreateASession_storedInRedis() {\n-    String sessionCookie = createNewSessionWithNote(APP1, \"note1\");\n-    String sessionId = getSessionId(sessionCookie);\n-\n-    Map<String, String> sessionInfo =\n-        jedis.hgetAll(\"spring:session:sessions:\" + sessionId);\n-\n-    assertThat(sessionInfo.get(\"sessionAttr:NOTES\")).contains(\"note1\");\n-  }\n-\n-  @Test\n-  public void should_storeSession() {\n-    String sessionCookie = createNewSessionWithNote(APP1, \"note1\");\n-\n-    String[] sessionNotes = getSessionNotes(APP2, sessionCookie);\n-\n-    assertThat(sessionNotes).containsExactly(\"note1\");\n-  }\n-\n-  @Test\n-  public void should_propagateSession_toOtherServers() {\n-    String sessionCookie = createNewSessionWithNote(APP1, \"noteFromClient1\");\n-\n-    String[] sessionNotes = getSessionNotes(APP2, sessionCookie);\n-\n-    assertThat(sessionNotes).containsExactly(\"noteFromClient1\");\n-  }\n-\n-  @Test\n-  public void should_getSessionFromServer1_whenServer2GoesDown() {\n-    String sessionCookie = createNewSessionWithNote(APP2, \"noteFromClient2\");\n-    cluster.crashVM(SERVER2);\n-    try {\n-      String[] sessionNotes = getSessionNotes(APP1, sessionCookie);\n-\n-      assertThat(sessionNotes).containsExactly(\"noteFromClient2\");\n-    } finally {\n-      startRedisServer(SERVER2);\n-    }\n-  }\n-\n-  @Test\n-  public void should_getSessionFromServer_whenServerGoesDownAndIsRestarted() {\n-    String sessionCookie = createNewSessionWithNote(APP2, \"noteFromClient2\");\n-    cluster.crashVM(SERVER2);\n-    addNoteToSession(APP1, sessionCookie);\n-    startRedisServer(SERVER2);\n-\n-    String[] sessionNotes = getSessionNotes(APP2, sessionCookie);\n-\n-    assertThat(sessionNotes).containsExactly(\"noteFromClient2\", \"noteFromClient1\");\n-  }\n-\n-  @Test\n-  public void should_getSession_whenServer2GoesDown_andAppFailsOverToServer1() {\n-    String sessionCookie = createNewSessionWithNote(APP2, \"noteFromClient2\");\n-    cluster.crashVM(SERVER2);\n-\n-    try {\n-      String[] sessionNotes = getSessionNotes(APP2, sessionCookie);\n-\n-      assertThat(sessionNotes).containsExactly(\"noteFromClient2\");\n-    } finally {\n-      startRedisServer(SERVER2);\n-    }\n-  }\n-\n-  @Test\n-  public void should_getSessionCreatedByApp2_whenApp2GoesDown_andClientConnectsToApp1() {\n-    String sessionCookie = createNewSessionWithNote(APP2, \"noteFromClient2\");\n+    jedisConnetedToServer1.disconnect();\n+    stopSpringApp(APP1);\n     stopSpringApp(APP2);\n+  }\n \n-    try {\n-      String[] sessionNotes = getSessionNotes(APP1, sessionCookie);\n-\n-      assertThat(sessionNotes).containsExactly(\"noteFromClient2\");\n-    } finally {\n-      startSpringApp(APP2, SERVER1, SERVER2);\n-    }\n-\n+  @After\n+  public void cleanupAfterTest() {\n+    jedisConnetedToServer1.flushAll();\n   }\n \n-  private static void startRedisServer(int server1) {\n+  protected static void startRedisServer(int server1) {\n     cluster.startServerVM(server1, redisProperties(server1),\n         cluster.getMember(LOCATOR).getPort());\n+\n+    cluster.getVM(server1).invoke(\"Set logging level to DEBUG\", () -> {\n+      Logger logger = LogManager.getLogger(\"org.apache.geode.redis.internal\");\n+      Configurator.setAllLevels(logger.getName(), Level.getLevel(\"DEBUG\"));\n+      FastLogger.setDelegating(true);\n+    });\n   }\n \n   private static Properties redisProperties(int server2) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e2263ec3a1eb2a387e6c6dc487f13dc8b111133"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQzMzc1NA==", "bodyText": "Done.", "url": "https://github.com/apache/geode/pull/5079#discussion_r425433754", "createdAt": "2020-05-14T21:12:43Z", "author": {"login": "jdeppe-pivotal"}, "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/session/SessionDUnitTest.java", "diffHunk": "@@ -80,137 +84,62 @@ public static void setup() {\n     cluster.startLocatorVM(LOCATOR);\n     startRedisServer(SERVER1);\n     startRedisServer(SERVER2);\n-    startSpringApp(APP1, SERVER1, SERVER2);\n-    startSpringApp(APP2, SERVER2, SERVER1);\n \n-    jedis = new Jedis(\"localhost\", ports.get(SERVER1), JEDIS_TIMEOUT);\n-  }\n-\n-  @After\n-  public void cleanupAfterTest() {\n-    jedis.flushAll();\n+    jedisConnetedToServer1 = new Jedis(\"localhost\", ports.get(SERVER1), JEDIS_TIMEOUT);\n   }\n \n   @AfterClass\n   public static void cleanupAfterClass() {\n-    jedis.disconnect();\n-  }\n-\n-  @Test\n-  public void should_beAbleToCreateASession_storedInRedis() {\n-    String sessionCookie = createNewSessionWithNote(APP1, \"note1\");\n-    String sessionId = getSessionId(sessionCookie);\n-\n-    Map<String, String> sessionInfo =\n-        jedis.hgetAll(\"spring:session:sessions:\" + sessionId);\n-\n-    assertThat(sessionInfo.get(\"sessionAttr:NOTES\")).contains(\"note1\");\n-  }\n-\n-  @Test\n-  public void should_storeSession() {\n-    String sessionCookie = createNewSessionWithNote(APP1, \"note1\");\n-\n-    String[] sessionNotes = getSessionNotes(APP2, sessionCookie);\n-\n-    assertThat(sessionNotes).containsExactly(\"note1\");\n-  }\n-\n-  @Test\n-  public void should_propagateSession_toOtherServers() {\n-    String sessionCookie = createNewSessionWithNote(APP1, \"noteFromClient1\");\n-\n-    String[] sessionNotes = getSessionNotes(APP2, sessionCookie);\n-\n-    assertThat(sessionNotes).containsExactly(\"noteFromClient1\");\n-  }\n-\n-  @Test\n-  public void should_getSessionFromServer1_whenServer2GoesDown() {\n-    String sessionCookie = createNewSessionWithNote(APP2, \"noteFromClient2\");\n-    cluster.crashVM(SERVER2);\n-    try {\n-      String[] sessionNotes = getSessionNotes(APP1, sessionCookie);\n-\n-      assertThat(sessionNotes).containsExactly(\"noteFromClient2\");\n-    } finally {\n-      startRedisServer(SERVER2);\n-    }\n-  }\n-\n-  @Test\n-  public void should_getSessionFromServer_whenServerGoesDownAndIsRestarted() {\n-    String sessionCookie = createNewSessionWithNote(APP2, \"noteFromClient2\");\n-    cluster.crashVM(SERVER2);\n-    addNoteToSession(APP1, sessionCookie);\n-    startRedisServer(SERVER2);\n-\n-    String[] sessionNotes = getSessionNotes(APP2, sessionCookie);\n-\n-    assertThat(sessionNotes).containsExactly(\"noteFromClient2\", \"noteFromClient1\");\n-  }\n-\n-  @Test\n-  public void should_getSession_whenServer2GoesDown_andAppFailsOverToServer1() {\n-    String sessionCookie = createNewSessionWithNote(APP2, \"noteFromClient2\");\n-    cluster.crashVM(SERVER2);\n-\n-    try {\n-      String[] sessionNotes = getSessionNotes(APP2, sessionCookie);\n-\n-      assertThat(sessionNotes).containsExactly(\"noteFromClient2\");\n-    } finally {\n-      startRedisServer(SERVER2);\n-    }\n-  }\n-\n-  @Test\n-  public void should_getSessionCreatedByApp2_whenApp2GoesDown_andClientConnectsToApp1() {\n-    String sessionCookie = createNewSessionWithNote(APP2, \"noteFromClient2\");\n+    jedisConnetedToServer1.disconnect();\n+    stopSpringApp(APP1);\n     stopSpringApp(APP2);\n+  }\n \n-    try {\n-      String[] sessionNotes = getSessionNotes(APP1, sessionCookie);\n-\n-      assertThat(sessionNotes).containsExactly(\"noteFromClient2\");\n-    } finally {\n-      startSpringApp(APP2, SERVER1, SERVER2);\n-    }\n-\n+  @After\n+  public void cleanupAfterTest() {\n+    jedisConnetedToServer1.flushAll();\n   }\n \n-  private static void startRedisServer(int server1) {\n+  protected static void startRedisServer(int server1) {\n     cluster.startServerVM(server1, redisProperties(server1),\n         cluster.getMember(LOCATOR).getPort());\n+\n+    cluster.getVM(server1).invoke(\"Set logging level to DEBUG\", () -> {\n+      Logger logger = LogManager.getLogger(\"org.apache.geode.redis.internal\");\n+      Configurator.setAllLevels(logger.getName(), Level.getLevel(\"DEBUG\"));\n+      FastLogger.setDelegating(true);\n+    });\n   }\n \n   private static Properties redisProperties(int server2) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ4MTA2NA=="}, "originalCommit": {"oid": "8e2263ec3a1eb2a387e6c6dc487f13dc8b111133"}, "originalPosition": 203}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MzM4ODE5OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/session/SessionDUnitTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNDozMTowOFrOGU0edg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNDozMTowOFrOGU0edg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ4NDQ3MA==", "bodyText": "It was an awesome idea to make this an abstract class!", "url": "https://github.com/apache/geode/pull/5079#discussion_r424484470", "createdAt": "2020-05-13T14:31:08Z", "author": {"login": "sabbey37"}, "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/session/SessionDUnitTest.java", "diffHunk": "@@ -40,33 +40,37 @@\n import redis.clients.jedis.Jedis;\n \n import org.apache.geode.internal.AvailablePortHelper;\n-import org.apache.geode.redis.springRedisTestApplication.RedisSpringTestApplication;\n+import org.apache.geode.logging.internal.log4j.api.FastLogger;\n+import org.apache.geode.redis.session.springRedisTestApplication.RedisSpringTestApplication;\n import org.apache.geode.test.awaitility.GeodeAwaitility;\n import org.apache.geode.test.dunit.VM;\n import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n import org.apache.geode.test.dunit.rules.DistributedRestoreSystemProperties;\n-import org.apache.geode.test.junit.categories.RedisTest;\n \n-@Category({RedisTest.class})\n-public class RedisSessionDistDUnitTest implements Serializable {\n+public abstract class SessionDUnitTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e2263ec3a1eb2a387e6c6dc487f13dc8b111133"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NDAwOTY0OnYy", "diffSide": "RIGHT", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/ExecutionHandlerContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNjo1MDo1M1rOGU6s4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQyMToxMjoyNVrOGVuaCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU4NjQ2NQ==", "bodyText": "Could this copy call and the release call two lines down be moved into getPrintableByteBuf? Or maybe this whole block should be moved to a method named \"logResponse(command)\". Seems like the \"release\" call should be in a \"finally\" block in case an exception is thrown.", "url": "https://github.com/apache/geode/pull/5079#discussion_r424586465", "createdAt": "2020-05-13T16:50:53Z", "author": {"login": "dschneider-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/ExecutionHandlerContext.java", "diffHunk": "@@ -216,6 +217,13 @@ private void executeCommand(ChannelHandlerContext ctx, Command command) throws E\n         executeWithoutTransaction(command);\n       }\n \n+      if (logger.isDebugEnabled() && command.getResponse() != null) {\n+        ByteBuf response = command.getResponse()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e2263ec3a1eb2a387e6c6dc487f13dc8b111133"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQzMzYwOQ==", "bodyText": "Fixed.", "url": "https://github.com/apache/geode/pull/5079#discussion_r425433609", "createdAt": "2020-05-14T21:12:25Z", "author": {"login": "jdeppe-pivotal"}, "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/ExecutionHandlerContext.java", "diffHunk": "@@ -216,6 +217,13 @@ private void executeCommand(ChannelHandlerContext ctx, Command command) throws E\n         executeWithoutTransaction(command);\n       }\n \n+      if (logger.isDebugEnabled() && command.getResponse() != null) {\n+        ByteBuf response = command.getResponse()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU4NjQ2NQ=="}, "originalCommit": {"oid": "8e2263ec3a1eb2a387e6c6dc487f13dc8b111133"}, "originalPosition": 13}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4211, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}