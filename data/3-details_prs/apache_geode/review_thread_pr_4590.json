{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYyMzg1MzYy", "number": 4590, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMDo0OToyNVrODYCLFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMToxMzo0NVrODYCZ-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NTI4MDIzOnYy", "diffSide": "RIGHT", "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/membership/InternalDistributedMember.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMDo0OToyNVrOFdqbsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMDo0OToyNVrOFdqbsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY0ODI0Mg==", "bodyText": "Nice how having to call super forced us to put the extra logic into a method (getInetAddress).", "url": "https://github.com/apache/geode/pull/4590#discussion_r366648242", "createdAt": "2020-01-15T00:49:25Z", "author": {"login": "Bill"}, "path": "geode-core/src/main/java/org/apache/geode/distributed/internal/membership/InternalDistributedMember.java", "diffHunk": "@@ -244,19 +128,21 @@ public InternalDistributedMember(String i, int p) {\n    */\n \n   public InternalDistributedMember(ServerLocation location) {\n+    super(MemberDataBuilder.newBuilder(getInetAddress(location), location.getHostName())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55501f85e181fcb42ab1bf4d9cdee104a1f26c4d"}, "originalPosition": 211}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NTI4OTAzOnYy", "diffSide": "RIGHT", "path": "geode-core/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/membership/GMSJoinLeaveJUnitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMDo1NDo0OVrOFdqg_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNzo1MDo0NlrOFeBDOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY0OTU5OQ==", "bodyText": "is the reason for this change conscious uncoupling from the MemberIdentifierFactoryImpl class?", "url": "https://github.com/apache/geode/pull/4590#discussion_r366649599", "createdAt": "2020-01-15T00:54:49Z", "author": {"login": "Bill"}, "path": "geode-core/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/membership/GMSJoinLeaveJUnitTest.java", "diffHunk": "@@ -142,7 +144,18 @@ public void initMocks(boolean enableNetworkPartition, boolean useTestGMSJoinLeav\n     when(services.getCancelCriterion()).thenReturn(stopper);\n     when(services.getManager()).thenReturn(manager);\n     when(services.getHealthMonitor()).thenReturn(healthMonitor);\n-    when(services.getMemberFactory()).thenReturn(new MemberIdentifierFactoryImpl());\n+    when(services.getMemberFactory())\n+        .thenReturn(new MemberIdentifierFactory<InternalDistributedMember>() {\n+          @Override\n+          public InternalDistributedMember create(MemberData memberInfo) {\n+            return new InternalDistributedMember(memberInfo);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55501f85e181fcb42ab1bf4d9cdee104a1f26c4d"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAxODgxMQ==", "bodyText": "Basically. This test is still using InternalDistributedMember. So it needs a MemberIdentifierFactory that produces an IDM. I changed MemberIdentifierFactoryImpl to produce MemberIdentiferImpl.\nOnce we totally fix this test to just use MemberIdentefierImpl, we can go back to the MemberIdentiferFactoryImpl.", "url": "https://github.com/apache/geode/pull/4590#discussion_r367018811", "createdAt": "2020-01-15T17:50:46Z", "author": {"login": "upthewaterspout"}, "path": "geode-core/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/membership/GMSJoinLeaveJUnitTest.java", "diffHunk": "@@ -142,7 +144,18 @@ public void initMocks(boolean enableNetworkPartition, boolean useTestGMSJoinLeav\n     when(services.getCancelCriterion()).thenReturn(stopper);\n     when(services.getManager()).thenReturn(manager);\n     when(services.getHealthMonitor()).thenReturn(healthMonitor);\n-    when(services.getMemberFactory()).thenReturn(new MemberIdentifierFactoryImpl());\n+    when(services.getMemberFactory())\n+        .thenReturn(new MemberIdentifierFactory<InternalDistributedMember>() {\n+          @Override\n+          public InternalDistributedMember create(MemberData memberInfo) {\n+            return new InternalDistributedMember(memberInfo);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY0OTU5OQ=="}, "originalCommit": {"oid": "55501f85e181fcb42ab1bf4d9cdee104a1f26c4d"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NTMwMzE4OnYy", "diffSide": "RIGHT", "path": "geode-serialization/src/main/java/org/apache/geode/internal/serialization/StaticSerialization.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMTowMzo1M1rOFdqpag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMTowMzo1M1rOFdqpag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY1MTc1NA==", "bodyText": "ah I see why you moved this logic here from InternalDataSerializer: the latter is in geode-core and our new MemberIdentifierImpl is down in geode-membership and can't depend on stuff in core \u2713", "url": "https://github.com/apache/geode/pull/4590#discussion_r366651754", "createdAt": "2020-01-15T01:03:53Z", "author": {"login": "Bill"}, "path": "geode-serialization/src/main/java/org/apache/geode/internal/serialization/StaticSerialization.java", "diffHunk": "@@ -494,4 +494,64 @@ public static void writePrimitiveClass(Class c, DataOutput out) throws IOExcepti\n             String.format(\"unexpected typeCode: %s\", typeCode));\n     }\n   }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65c0720feb1369f53b34bdb1a30ab5aad56ae442"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NTMxMzQ3OnYy", "diffSide": "RIGHT", "path": "geode-membership/src/main/java/org/apache/geode/distributed/internal/membership/api/MemberIdentifierImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMToxMDoyMFrOFdqvlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMToxMDoyMFrOFdqvlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY1MzMzMg==", "bodyText": "now be a good time to give this method a meaningful name", "url": "https://github.com/apache/geode/pull/4590#discussion_r366653332", "createdAt": "2020-01-15T01:10:20Z", "author": {"login": "Bill"}, "path": "geode-membership/src/main/java/org/apache/geode/distributed/internal/membership/api/MemberIdentifierImpl.java", "diffHunk": "@@ -0,0 +1,978 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.distributed.internal.membership.api;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.EOFException;\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.net.InetAddress;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+import org.apache.commons.validator.routines.InetAddressValidator;\n+\n+import org.apache.geode.annotations.Immutable;\n+import org.apache.geode.annotations.VisibleForTesting;\n+import org.apache.geode.internal.serialization.DataSerializableFixedID;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.internal.serialization.StaticSerialization;\n+import org.apache.geode.internal.serialization.UnsupportedSerializationVersionException;\n+import org.apache.geode.internal.serialization.Version;\n+\n+/**\n+ * An implementation of {@link MemberIdentifier}\n+ */\n+public class MemberIdentifierImpl implements MemberIdentifier, DataSerializableFixedID {\n+  /** serialization bit flag */\n+  private static final int NPD_ENABLED_BIT = 0x1;\n+  /** serialization bit flag */\n+  private static final int COORD_ENABLED_BIT = 0x2;\n+  /** partial ID bit flag */\n+  private static final int PARTIAL_ID_BIT = 0x4;\n+  /** product version bit flag */\n+  private static final int VERSION_BIT = 0x8;\n+  /** The versions in which this message was modified */\n+  @Immutable\n+  private static final Version[] dsfidVersions = new Version[] {\n+      Version.GFE_71, Version.GFE_90};\n+  private MemberData memberData; // the underlying member object\n+  /**\n+   * whether this is a partial member ID (without roles, durable attributes). We use partial IDs in\n+   * EventID objects to reduce their size. It would be better to use canonical IDs but there is\n+   * currently no central mechanism that would allow that for both server and client identifiers\n+   */\n+  private boolean isPartial;\n+  /**\n+   * Unique tag (such as randomly generated bytes) to help enforce uniqueness. Note: this should be\n+   * displayable.\n+   */\n+  private String uniqueTag = null;\n+  private transient Version versionObj = Version.CURRENT;\n+\n+  public MemberIdentifierImpl() {}\n+\n+  public MemberIdentifierImpl(\n+      MemberData memberData, String uniqueTag) {\n+    this.memberData = memberData;\n+    this.isPartial = memberData.isPartial();\n+    this.uniqueTag = uniqueTag;\n+\n+    short version = memberData.getVersionOrdinal();\n+    try {\n+      this.versionObj = Version.fromOrdinal(version);\n+    } catch (UnsupportedSerializationVersionException e) {\n+      this.versionObj = Version.CURRENT;\n+    }\n+  }\n+\n+  public int getVmPid() {\n+    return memberData.getProcessId();\n+  }\n+\n+  public void setDurableTimeout(int newValue) {\n+    memberData.setDurableTimeout(newValue);\n+  }\n+\n+  public void setDurableId(String id) {\n+    memberData.setDurableId(id);\n+  }\n+\n+  /**\n+   * Replace the current member data with the given member data. This can be used to fill out an\n+   * InternalDistributedMember that was created from a partial data created by\n+   * readEssentialData.\n+   *\n+   * @param m the replacement member data\n+   */\n+  public void setMemberData(MemberData m) {\n+    this.memberData = m;\n+  }\n+\n+  /**\n+   * Return the underlying host address\n+   *\n+   * @return the underlying host address\n+   */\n+  public InetAddress getInetAddress() {\n+    return memberData.getInetAddress();\n+  }\n+\n+  /**\n+   * Return the underlying port (membership port)\n+   *\n+   * @return the underlying membership port\n+   */\n+  public int getMembershipPort() {\n+    return memberData.getMembershipPort();\n+  }\n+\n+  @Override\n+  public short getVersionOrdinal() {\n+    return versionObj == null ? memberData.getVersionOrdinal() : versionObj.ordinal();\n+  }\n+\n+  /**\n+   * Returns the port on which the direct channel runs\n+   */\n+  public int getDirectChannelPort() {\n+    assert !this.isPartial;\n+    return memberData.getDirectChannelPort();\n+  }\n+\n+  /**\n+   * [GemStone] Returns the kind of VM that hosts the distribution manager with this address.\n+   *\n+   * @see MemberIdentifier#NORMAL_DM_TYPE\n+   */\n+  public int getVmKind() {\n+    return memberData.getVmKind();\n+  }\n+\n+  @Override\n+  public int getMemberWeight() {\n+    return memberData.getMemberWeight();\n+  }\n+\n+  /**\n+   * Returns the membership view ID that this member was born in. For backward compatibility reasons\n+   * this is limited to 16 bits.\n+   */\n+  public int getVmViewId() {\n+    return memberData.getVmViewId();\n+  }\n+\n+  @Override\n+  public boolean preferredForCoordinator() {\n+    return memberData.isPreferredForCoordinator();\n+  }\n+\n+  @Override\n+  public List<String> getGroups() {\n+    return Collections.unmodifiableList(Arrays.asList(memberData.getGroups()));\n+  }\n+\n+  @Override\n+  public void setVmViewId(int p) {\n+    memberData.setVmViewId(p);\n+    cachedToString = null;\n+  }\n+\n+  @Override\n+  public void setPreferredForCoordinator(boolean preferred) {\n+    memberData.setPreferredForCoordinator(preferred);\n+    cachedToString = null;\n+  }\n+\n+  @Override\n+  public void setDirectChannelPort(int dcPort) {\n+    memberData.setDirectChannelPort(dcPort);\n+    cachedToString = null;\n+  }\n+\n+  @Override\n+  public void setVmKind(int dmType) {\n+    memberData.setVmKind(dmType);\n+    cachedToString = null;\n+  }\n+\n+  protected void setGroups(String[] newGroups) {\n+    this.memberData.setGroups(newGroups);\n+    cachedToString = null;\n+  }\n+\n+  /**\n+   * Returns the name of this member's distributed system connection or null if no name was\n+   * specified.\n+   */\n+  public String getName() {\n+    String result = memberData.getName();\n+    if (result == null) {\n+      result = \"\";\n+    }\n+    return result;\n+  }\n+\n+  public int compare(MemberIdentifierImpl other) {\n+    return this.compareTo(other, false, true);\n+  }\n+\n+  protected int compareTo(MemberIdentifierImpl other, boolean compareMemberData,\n+      boolean compareViewIds) {\n+    int myPort = getMembershipPort();\n+    int otherPort = other.getMembershipPort();\n+    if (myPort < otherPort)\n+      return -1;\n+    if (myPort > otherPort)\n+      return 1;\n+\n+    InetAddress myAddr = getInetAddress();\n+    InetAddress otherAddr = other.getInetAddress();\n+\n+    // Discard null cases\n+    if (myAddr == null && otherAddr == null) {\n+      return 0;\n+    } else if (myAddr == null) {\n+      return -1;\n+    } else if (otherAddr == null)\n+      return 1;\n+\n+    byte[] myBytes = myAddr.getAddress();\n+    byte[] otherBytes = otherAddr.getAddress();\n+\n+    if (myBytes != otherBytes) {\n+      for (int i = 0; i < myBytes.length; i++) {\n+        if (i >= otherBytes.length)\n+          return -1; // same as far as they go, but shorter...\n+        if (myBytes[i] < otherBytes[i])\n+          return -1;\n+        if (myBytes[i] > otherBytes[i])\n+          return 1;\n+      }\n+      if (myBytes.length > otherBytes.length)\n+        return 1; // same as far as they go, but longer...\n+    }\n+\n+    String myName = getName();\n+    String otherName = other.getName();\n+    if (!(other.isPartial || this.isPartial)) {\n+      if (myName == null && otherName == null) {\n+        // do nothing\n+      } else if (myName == null) {\n+        return -1;\n+      } else if (otherName == null) {\n+        return 1;\n+      } else {\n+        int i = myName.compareTo(otherName);\n+        if (i != 0) {\n+          return i;\n+        }\n+      }\n+    }\n+\n+    if (this.uniqueTag == null && other.uniqueTag == null) {\n+      if (compareViewIds) {\n+        // not loners, so look at P2P view ID\n+        int thisViewId = getVmViewId();\n+        int otherViewId = other.getVmViewId();\n+        if (thisViewId >= 0 && otherViewId >= 0) {\n+          if (thisViewId < otherViewId) {\n+            return -1;\n+          } else if (thisViewId > otherViewId) {\n+            return 1;\n+          } // else they're the same, so continue\n+        }\n+      }\n+    } else if (this.uniqueTag == null) {\n+      return -1;\n+    } else if (other.uniqueTag == null) {\n+      return 1;\n+    } else {\n+      int i = this.uniqueTag.compareTo(other.uniqueTag);\n+      if (i != 0) {\n+        return i;\n+      }\n+    }\n+\n+    if (compareMemberData && this.memberData != null && other.memberData != null) {\n+      return this.memberData.compareAdditionalData(other.memberData);\n+    } else {\n+      return 0;\n+    }\n+  }\n+\n+  /**\n+   * An InternalDistributedMember created for a test or via readEssentialData will be a Partial ID,\n+   * possibly not having ancillary info like \"name\".\n+   *\n+   * @return true if this is a partial ID\n+   */\n+  public boolean isPartial() {\n+    return isPartial;\n+  }\n+\n+  @Override\n+  public boolean equals(Object obj) {\n+    if (this == obj) {\n+      return true;\n+    }\n+    // GemStone fix for 29125\n+    if (!(obj instanceof MemberIdentifierImpl)) {\n+      return false;\n+    }\n+    MemberIdentifierImpl other = (MemberIdentifierImpl) obj;\n+\n+    int myPort = getMembershipPort();\n+    int otherPort = other.getMembershipPort();\n+    if (myPort != otherPort) {\n+      return false;\n+    }\n+\n+    InetAddress myAddr = getInetAddress();\n+    InetAddress otherAddr = other.getInetAddress();\n+    if (myAddr == null && otherAddr == null) {\n+      return true;\n+    } else if (!Objects.equals(myAddr, otherAddr)) {\n+      return false;\n+    }\n+\n+    if (!isPartial() && !other.isPartial()) {\n+      if (!Objects.equals(getName(), other.getName())) {\n+        return false;\n+      }\n+    }\n+\n+    if (this.uniqueTag == null && other.uniqueTag == null) {\n+      // not loners, so look at P2P view ID\n+      int thisViewId = getVmViewId();\n+      int otherViewId = other.getVmViewId();\n+      if (thisViewId >= 0 && otherViewId >= 0) {\n+        if (thisViewId != otherViewId) {\n+          return false;\n+        } // else they're the same, so continue\n+      }\n+    } else if (!Objects.equals(this.uniqueTag, other.uniqueTag)) {\n+      return false;\n+    }\n+\n+    if (this.memberData != null && other.memberData != null) {\n+      if (0 != this.memberData.compareAdditionalData(other.memberData)) {\n+        return false;\n+      }\n+    }\n+\n+    // purposely avoid checking roles\n+    // @todo Add durableClientAttributes to equals\n+\n+    return true;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    int result = 0;\n+    result = result + memberData.getInetAddress().hashCode();\n+    result = result + getMembershipPort();\n+    return result;\n+  }\n+\n+  private String shortName(String hostname) {\n+    if (hostname == null)\n+      return \"<null inet_addr hostname>\";\n+    int index = hostname.indexOf('.');\n+\n+    if (index > 0 && !Character.isDigit(hostname.charAt(0)))\n+      return hostname.substring(0, index);\n+    else\n+      return hostname;\n+  }\n+\n+\n+  /** the cached string description of this object */\n+  private transient String cachedToString;\n+\n+  @Override\n+  public String toString() {\n+    String result = cachedToString;\n+    if (result == null) {\n+      final StringBuilder sb = new StringBuilder();\n+      addFixedToString(sb, false);\n+\n+      // add version if not current\n+      short version = memberData.getVersionOrdinal();\n+      if (version != Version.CURRENT.ordinal()) {\n+        sb.append(\"(version:\").append(Version.toString(version)).append(')');\n+      }\n+\n+      // leave out Roles on purpose\n+\n+      result = sb.toString();\n+      cachedToString = result;\n+    }\n+    return result;\n+  }\n+\n+  public void addFixedToString(StringBuilder sb, boolean useIpAddress) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65c0720feb1369f53b34bdb1a30ab5aad56ae442"}, "originalPosition": 413}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NTMxODM0OnYy", "diffSide": "RIGHT", "path": "geode-membership/src/main/java/org/apache/geode/distributed/internal/membership/api/MemberIdentifierImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMToxMzo0NVrOFdqyvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMToxMzo0NVrOFdqyvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY1NDE0Mw==", "bodyText": "gawd this (class) really goes into the membership API. That makes everything this class does part of the membership contract right?\nclass inheritance coming home to roost. I guess the alternative is to put a factory in the API and hide this impl in the membership module implementation package. Then InternalDistributedMember would have a MemberIdentifierImpl through a MemberIdentifierreference.\nProblem with that idea is that MemberIdentifierImpl has a ton of methods not on MemberIdentifier. That implies we'd need another, wider, interface to implement those methods (maybe a sub-interface of MemberIdentifier) ugh.\nsorry for the stream of consciousness feedback. I'll try to hone it and get back to you\u2026", "url": "https://github.com/apache/geode/pull/4590#discussion_r366654143", "createdAt": "2020-01-15T01:13:45Z", "author": {"login": "Bill"}, "path": "geode-membership/src/main/java/org/apache/geode/distributed/internal/membership/api/MemberIdentifierImpl.java", "diffHunk": "@@ -0,0 +1,978 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.distributed.internal.membership.api;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65c0720feb1369f53b34bdb1a30ab5aad56ae442"}, "originalPosition": 15}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3827, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}