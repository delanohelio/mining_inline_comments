{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcwMzI0Mzkx", "number": 1322, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNjowNzo1MVrOEampuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNjowNzo1MVrOEampuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MzMxNzA1OnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/MainnetTransactionProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNjowNzo1MVrOHEIy8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNjoyMDoxN1rOHEJR7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwMDQ2NQ==", "bodyText": "How come we don't need this in the PrivateTransactionProcessor?", "url": "https://github.com/hyperledger/besu/pull/1322#discussion_r474100465", "createdAt": "2020-08-20T16:07:51Z", "author": {"login": "RatanRSur"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/MainnetTransactionProcessor.java", "diffHunk": "@@ -208,193 +209,204 @@ public Result processTransaction(\n       final BlockHashLookup blockHashLookup,\n       final Boolean isPersistingPrivateState,\n       final TransactionValidationParams transactionValidationParams) {\n-    LOG.trace(\"Starting execution of {}\", transaction);\n-\n-    ValidationResult<TransactionValidator.TransactionInvalidReason> validationResult =\n-        transactionValidator.validate(transaction, blockHeader.getBaseFee());\n-    // Make sure the transaction is intrinsically valid before trying to\n-    // compare against a sender account (because the transaction may not\n-    // be signed correctly to extract the sender).\n-    if (!validationResult.isValid()) {\n-      LOG.warn(\"Invalid transaction: {}\", validationResult.getErrorMessage());\n-      return Result.invalid(validationResult);\n-    }\n+    try {\n+      LOG.trace(\"Starting execution of {}\", transaction);\n+\n+      ValidationResult<TransactionValidator.TransactionInvalidReason> validationResult =\n+          transactionValidator.validate(transaction, blockHeader.getBaseFee());\n+      // Make sure the transaction is intrinsically valid before trying to\n+      // compare against a sender account (because the transaction may not\n+      // be signed correctly to extract the sender).\n+      if (!validationResult.isValid()) {\n+        LOG.warn(\"Invalid transaction: {}\", validationResult.getErrorMessage());\n+        return Result.invalid(validationResult);\n+      }\n \n-    final Address senderAddress = transaction.getSender();\n-    final DefaultEvmAccount sender = worldState.getOrCreate(senderAddress);\n-    validationResult =\n-        transactionValidator.validateForSender(transaction, sender, transactionValidationParams);\n-    if (!validationResult.isValid()) {\n-      LOG.debug(\"Invalid transaction: {}\", validationResult.getErrorMessage());\n-      return Result.invalid(validationResult);\n-    }\n+      final Address senderAddress = transaction.getSender();\n+      final DefaultEvmAccount sender = worldState.getOrCreate(senderAddress);\n+      validationResult =\n+          transactionValidator.validateForSender(transaction, sender, transactionValidationParams);\n+      if (!validationResult.isValid()) {\n+        LOG.debug(\"Invalid transaction: {}\", validationResult.getErrorMessage());\n+        return Result.invalid(validationResult);\n+      }\n \n-    final MutableAccount senderMutableAccount = sender.getMutable();\n-    final long previousNonce = senderMutableAccount.incrementNonce();\n-    final Wei transactionGasPrice =\n-        transactionPriceCalculator.price(transaction, blockHeader.getBaseFee());\n-    LOG.trace(\n-        \"Incremented sender {} nonce ({} -> {})\", senderAddress, previousNonce, sender.getNonce());\n-\n-    final Wei upfrontGasCost = transaction.getUpfrontGasCost(transactionGasPrice);\n-    final Wei previousBalance = senderMutableAccount.decrementBalance(upfrontGasCost);\n-    LOG.trace(\n-        \"Deducted sender {} upfront gas cost {} ({} -> {})\",\n-        senderAddress,\n-        upfrontGasCost,\n-        previousBalance,\n-        sender.getBalance());\n-\n-    final Gas intrinsicGas = gasCalculator.transactionIntrinsicGasCost(transaction);\n-    final Gas gasAvailable = Gas.of(transaction.getGasLimit()).minus(intrinsicGas);\n-    LOG.trace(\n-        \"Gas available for execution {} = {} - {} (limit - intrinsic)\",\n-        gasAvailable,\n-        transaction.getGasLimit(),\n-        intrinsicGas);\n-\n-    final WorldUpdater worldUpdater = worldState.updater();\n-    final MessageFrame initialFrame;\n-    final Deque<MessageFrame> messageFrameStack = new ArrayDeque<>();\n-    final ReturnStack returnStack = new ReturnStack();\n-\n-    if (transaction.isContractCreation()) {\n-      final Address contractAddress =\n-          Address.contractAddress(senderAddress, sender.getNonce() - 1L);\n-\n-      initialFrame =\n-          MessageFrame.builder()\n-              .type(MessageFrame.Type.CONTRACT_CREATION)\n-              .messageFrameStack(messageFrameStack)\n-              .returnStack(returnStack)\n-              .blockchain(blockchain)\n-              .worldState(worldUpdater.updater())\n-              .initialGas(gasAvailable)\n-              .address(contractAddress)\n-              .originator(senderAddress)\n-              .contract(contractAddress)\n-              .contractAccountVersion(createContractAccountVersion)\n-              .gasPrice(transactionGasPrice)\n-              .inputData(Bytes.EMPTY)\n-              .sender(senderAddress)\n-              .value(transaction.getValue())\n-              .apparentValue(transaction.getValue())\n-              .code(new Code(transaction.getPayload()))\n-              .blockHeader(blockHeader)\n-              .depth(0)\n-              .completer(c -> {})\n-              .miningBeneficiary(miningBeneficiary)\n-              .blockHashLookup(blockHashLookup)\n-              .isPersistingPrivateState(isPersistingPrivateState)\n-              .maxStackSize(maxStackSize)\n-              .transactionHash(transaction.getHash())\n-              .build();\n-\n-    } else {\n-      final Address to = transaction.getTo().get();\n-      final Account contract = worldState.get(to);\n-\n-      initialFrame =\n-          MessageFrame.builder()\n-              .type(MessageFrame.Type.MESSAGE_CALL)\n-              .messageFrameStack(messageFrameStack)\n-              .returnStack(returnStack)\n-              .blockchain(blockchain)\n-              .worldState(worldUpdater.updater())\n-              .initialGas(gasAvailable)\n-              .address(to)\n-              .originator(senderAddress)\n-              .contract(to)\n-              .contractAccountVersion(\n-                  contract != null ? contract.getVersion() : Account.DEFAULT_VERSION)\n-              .gasPrice(transactionGasPrice)\n-              .inputData(transaction.getPayload())\n-              .sender(senderAddress)\n-              .value(transaction.getValue())\n-              .apparentValue(transaction.getValue())\n-              .code(new Code(contract != null ? contract.getCode() : Bytes.EMPTY))\n-              .blockHeader(blockHeader)\n-              .depth(0)\n-              .completer(c -> {})\n-              .miningBeneficiary(miningBeneficiary)\n-              .blockHashLookup(blockHashLookup)\n-              .maxStackSize(maxStackSize)\n-              .isPersistingPrivateState(isPersistingPrivateState)\n-              .transactionHash(transaction.getHash())\n-              .build();\n-    }\n+      final MutableAccount senderMutableAccount = sender.getMutable();\n+      final long previousNonce = senderMutableAccount.incrementNonce();\n+      final Wei transactionGasPrice =\n+          transactionPriceCalculator.price(transaction, blockHeader.getBaseFee());\n+      LOG.trace(\n+          \"Incremented sender {} nonce ({} -> {})\",\n+          senderAddress,\n+          previousNonce,\n+          sender.getNonce());\n \n-    messageFrameStack.addFirst(initialFrame);\n+      final Wei upfrontGasCost = transaction.getUpfrontGasCost(transactionGasPrice);\n+      final Wei previousBalance = senderMutableAccount.decrementBalance(upfrontGasCost);\n+      LOG.trace(\n+          \"Deducted sender {} upfront gas cost {} ({} -> {})\",\n+          senderAddress,\n+          upfrontGasCost,\n+          previousBalance,\n+          sender.getBalance());\n+\n+      final Gas intrinsicGas = gasCalculator.transactionIntrinsicGasCost(transaction);\n+      final Gas gasAvailable = Gas.of(transaction.getGasLimit()).minus(intrinsicGas);\n+      LOG.trace(\n+          \"Gas available for execution {} = {} - {} (limit - intrinsic)\",\n+          gasAvailable,\n+          transaction.getGasLimit(),\n+          intrinsicGas);\n+\n+      final WorldUpdater worldUpdater = worldState.updater();\n+      final MessageFrame initialFrame;\n+      final Deque<MessageFrame> messageFrameStack = new ArrayDeque<>();\n+      final ReturnStack returnStack = new ReturnStack();\n+\n+      if (transaction.isContractCreation()) {\n+        final Address contractAddress =\n+            Address.contractAddress(senderAddress, sender.getNonce() - 1L);\n+\n+        initialFrame =\n+            MessageFrame.builder()\n+                .type(MessageFrame.Type.CONTRACT_CREATION)\n+                .messageFrameStack(messageFrameStack)\n+                .returnStack(returnStack)\n+                .blockchain(blockchain)\n+                .worldState(worldUpdater.updater())\n+                .initialGas(gasAvailable)\n+                .address(contractAddress)\n+                .originator(senderAddress)\n+                .contract(contractAddress)\n+                .contractAccountVersion(createContractAccountVersion)\n+                .gasPrice(transactionGasPrice)\n+                .inputData(Bytes.EMPTY)\n+                .sender(senderAddress)\n+                .value(transaction.getValue())\n+                .apparentValue(transaction.getValue())\n+                .code(new Code(transaction.getPayload()))\n+                .blockHeader(blockHeader)\n+                .depth(0)\n+                .completer(c -> {})\n+                .miningBeneficiary(miningBeneficiary)\n+                .blockHashLookup(blockHashLookup)\n+                .isPersistingPrivateState(isPersistingPrivateState)\n+                .maxStackSize(maxStackSize)\n+                .transactionHash(transaction.getHash())\n+                .build();\n+\n+      } else {\n+        final Address to = transaction.getTo().get();\n+        final Account contract = worldState.get(to);\n+\n+        initialFrame =\n+            MessageFrame.builder()\n+                .type(MessageFrame.Type.MESSAGE_CALL)\n+                .messageFrameStack(messageFrameStack)\n+                .returnStack(returnStack)\n+                .blockchain(blockchain)\n+                .worldState(worldUpdater.updater())\n+                .initialGas(gasAvailable)\n+                .address(to)\n+                .originator(senderAddress)\n+                .contract(to)\n+                .contractAccountVersion(\n+                    contract != null ? contract.getVersion() : Account.DEFAULT_VERSION)\n+                .gasPrice(transactionGasPrice)\n+                .inputData(transaction.getPayload())\n+                .sender(senderAddress)\n+                .value(transaction.getValue())\n+                .apparentValue(transaction.getValue())\n+                .code(new Code(contract != null ? contract.getCode() : Bytes.EMPTY))\n+                .blockHeader(blockHeader)\n+                .depth(0)\n+                .completer(c -> {})\n+                .miningBeneficiary(miningBeneficiary)\n+                .blockHashLookup(blockHashLookup)\n+                .maxStackSize(maxStackSize)\n+                .isPersistingPrivateState(isPersistingPrivateState)\n+                .transactionHash(transaction.getHash())\n+                .build();\n+      }\n \n-    while (!messageFrameStack.isEmpty()) {\n-      process(messageFrameStack.peekFirst(), operationTracer);\n-    }\n+      messageFrameStack.addFirst(initialFrame);\n \n-    if (initialFrame.getState() == MessageFrame.State.COMPLETED_SUCCESS) {\n-      worldUpdater.commit();\n-    }\n+      while (!messageFrameStack.isEmpty()) {\n+        process(messageFrameStack.peekFirst(), operationTracer);\n+      }\n \n-    if (LOG.isTraceEnabled()) {\n-      LOG.trace(\n-          \"Gas used by transaction: {}, by message call/contract creation: {}\",\n-          () -> Gas.of(transaction.getGasLimit()).minus(initialFrame.getRemainingGas()),\n-          () -> gasAvailable.minus(initialFrame.getRemainingGas()));\n-    }\n+      if (initialFrame.getState() == MessageFrame.State.COMPLETED_SUCCESS) {\n+        worldUpdater.commit();\n+      }\n \n-    // Refund the sender by what we should and pay the miner fee (note that we're doing them one\n-    // after the other so that if it is the same account somehow, we end up with the right result)\n-    final Gas selfDestructRefund =\n-        gasCalculator.getSelfDestructRefundAmount().times(initialFrame.getSelfDestructs().size());\n-    final Gas refundGas = initialFrame.getGasRefund().plus(selfDestructRefund);\n-    final Gas refunded = refunded(transaction, initialFrame.getRemainingGas(), refundGas);\n-    final Wei refundedWei = refunded.priceFor(transactionGasPrice);\n-    senderMutableAccount.incrementBalance(refundedWei);\n-\n-    final Gas gasUsedByTransaction =\n-        Gas.of(transaction.getGasLimit()).minus(initialFrame.getRemainingGas());\n-\n-    final MutableAccount coinbase = worldState.getOrCreate(miningBeneficiary).getMutable();\n-    final Gas coinbaseFee = Gas.of(transaction.getGasLimit()).minus(refunded);\n-    if (blockHeader.getBaseFee().isPresent() && transaction.isEIP1559Transaction()) {\n-      final Wei baseFee = Wei.of(blockHeader.getBaseFee().get());\n-      if (transactionGasPrice.compareTo(baseFee) < 0) {\n-        return Result.failed(\n-            gasUsedByTransaction.toLong(),\n-            refunded.toLong(),\n-            ValidationResult.invalid(\n-                TransactionValidator.TransactionInvalidReason.TRANSACTION_PRICE_TOO_LOW,\n-                \"transaction price must be greater than base fee\"),\n-            Optional.empty());\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\n+            \"Gas used by transaction: {}, by message call/contract creation: {}\",\n+            () -> Gas.of(transaction.getGasLimit()).minus(initialFrame.getRemainingGas()),\n+            () -> gasAvailable.minus(initialFrame.getRemainingGas()));\n       }\n-    }\n-    final CoinbaseFeePriceCalculator coinbaseCreditService =\n-        transaction.isFrontierTransaction()\n-            ? CoinbaseFeePriceCalculator.frontier()\n-            : coinbaseFeePriceCalculator;\n-    final Wei coinbaseWeiDelta =\n-        coinbaseCreditService.price(coinbaseFee, transactionGasPrice, blockHeader.getBaseFee());\n \n-    coinbase.incrementBalance(coinbaseWeiDelta);\n+      // Refund the sender by what we should and pay the miner fee (note that we're doing them one\n+      // after the other so that if it is the same account somehow, we end up with the right result)\n+      final Gas selfDestructRefund =\n+          gasCalculator.getSelfDestructRefundAmount().times(initialFrame.getSelfDestructs().size());\n+      final Gas refundGas = initialFrame.getGasRefund().plus(selfDestructRefund);\n+      final Gas refunded = refunded(transaction, initialFrame.getRemainingGas(), refundGas);\n+      final Wei refundedWei = refunded.priceFor(transactionGasPrice);\n+      senderMutableAccount.incrementBalance(refundedWei);\n+\n+      final Gas gasUsedByTransaction =\n+          Gas.of(transaction.getGasLimit()).minus(initialFrame.getRemainingGas());\n+\n+      final MutableAccount coinbase = worldState.getOrCreate(miningBeneficiary).getMutable();\n+      final Gas coinbaseFee = Gas.of(transaction.getGasLimit()).minus(refunded);\n+      if (blockHeader.getBaseFee().isPresent() && transaction.isEIP1559Transaction()) {\n+        final Wei baseFee = Wei.of(blockHeader.getBaseFee().get());\n+        if (transactionGasPrice.compareTo(baseFee) < 0) {\n+          return Result.failed(\n+              gasUsedByTransaction.toLong(),\n+              refunded.toLong(),\n+              ValidationResult.invalid(\n+                  TransactionValidator.TransactionInvalidReason.TRANSACTION_PRICE_TOO_LOW,\n+                  \"transaction price must be greater than base fee\"),\n+              Optional.empty());\n+        }\n+      }\n+      final CoinbaseFeePriceCalculator coinbaseCreditService =\n+          transaction.isFrontierTransaction()\n+              ? CoinbaseFeePriceCalculator.frontier()\n+              : coinbaseFeePriceCalculator;\n+      final Wei coinbaseWeiDelta =\n+          coinbaseCreditService.price(coinbaseFee, transactionGasPrice, blockHeader.getBaseFee());\n \n-    initialFrame.getSelfDestructs().forEach(worldState::deleteAccount);\n+      coinbase.incrementBalance(coinbaseWeiDelta);\n \n-    if (clearEmptyAccounts) {\n-      clearEmptyAccounts(worldState);\n-    }\n+      initialFrame.getSelfDestructs().forEach(worldState::deleteAccount);\n \n-    if (initialFrame.getState() == MessageFrame.State.COMPLETED_SUCCESS) {\n-      return Result.successful(\n-          initialFrame.getLogs(),\n-          gasUsedByTransaction.toLong(),\n-          refunded.toLong(),\n-          initialFrame.getOutputData(),\n-          validationResult);\n-    } else {\n-      return Result.failed(\n-          gasUsedByTransaction.toLong(),\n-          refunded.toLong(),\n-          validationResult,\n-          initialFrame.getRevertReason());\n+      if (clearEmptyAccounts) {\n+        clearEmptyAccounts(worldState);\n+      }\n+\n+      if (initialFrame.getState() == MessageFrame.State.COMPLETED_SUCCESS) {\n+        return Result.successful(\n+            initialFrame.getLogs(),\n+            gasUsedByTransaction.toLong(),\n+            refunded.toLong(),\n+            initialFrame.getOutputData(),\n+            validationResult);\n+      } else {\n+        return Result.failed(\n+            gasUsedByTransaction.toLong(),\n+            refunded.toLong(),\n+            validationResult,\n+            initialFrame.getRevertReason());\n+      }\n+    } catch (final RuntimeException re) {\n+      LOG.error(\"Critical Exception Processing Transaction\", re);\n+      return Result.invalid(\n+          ValidationResult.invalid(\n+              TransactionInvalidReason.INTERNAL_ERROR,\n+              \"Internal Error in Besu - \" + re.toString()));\n     }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bfc4279e823f1afaa11de13393464e15b50afcc"}, "originalPosition": 385}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwODM5Nw==", "bodyText": "We need it there too.  Added.", "url": "https://github.com/hyperledger/besu/pull/1322#discussion_r474108397", "createdAt": "2020-08-20T16:20:17Z", "author": {"login": "shemnon"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/MainnetTransactionProcessor.java", "diffHunk": "@@ -208,193 +209,204 @@ public Result processTransaction(\n       final BlockHashLookup blockHashLookup,\n       final Boolean isPersistingPrivateState,\n       final TransactionValidationParams transactionValidationParams) {\n-    LOG.trace(\"Starting execution of {}\", transaction);\n-\n-    ValidationResult<TransactionValidator.TransactionInvalidReason> validationResult =\n-        transactionValidator.validate(transaction, blockHeader.getBaseFee());\n-    // Make sure the transaction is intrinsically valid before trying to\n-    // compare against a sender account (because the transaction may not\n-    // be signed correctly to extract the sender).\n-    if (!validationResult.isValid()) {\n-      LOG.warn(\"Invalid transaction: {}\", validationResult.getErrorMessage());\n-      return Result.invalid(validationResult);\n-    }\n+    try {\n+      LOG.trace(\"Starting execution of {}\", transaction);\n+\n+      ValidationResult<TransactionValidator.TransactionInvalidReason> validationResult =\n+          transactionValidator.validate(transaction, blockHeader.getBaseFee());\n+      // Make sure the transaction is intrinsically valid before trying to\n+      // compare against a sender account (because the transaction may not\n+      // be signed correctly to extract the sender).\n+      if (!validationResult.isValid()) {\n+        LOG.warn(\"Invalid transaction: {}\", validationResult.getErrorMessage());\n+        return Result.invalid(validationResult);\n+      }\n \n-    final Address senderAddress = transaction.getSender();\n-    final DefaultEvmAccount sender = worldState.getOrCreate(senderAddress);\n-    validationResult =\n-        transactionValidator.validateForSender(transaction, sender, transactionValidationParams);\n-    if (!validationResult.isValid()) {\n-      LOG.debug(\"Invalid transaction: {}\", validationResult.getErrorMessage());\n-      return Result.invalid(validationResult);\n-    }\n+      final Address senderAddress = transaction.getSender();\n+      final DefaultEvmAccount sender = worldState.getOrCreate(senderAddress);\n+      validationResult =\n+          transactionValidator.validateForSender(transaction, sender, transactionValidationParams);\n+      if (!validationResult.isValid()) {\n+        LOG.debug(\"Invalid transaction: {}\", validationResult.getErrorMessage());\n+        return Result.invalid(validationResult);\n+      }\n \n-    final MutableAccount senderMutableAccount = sender.getMutable();\n-    final long previousNonce = senderMutableAccount.incrementNonce();\n-    final Wei transactionGasPrice =\n-        transactionPriceCalculator.price(transaction, blockHeader.getBaseFee());\n-    LOG.trace(\n-        \"Incremented sender {} nonce ({} -> {})\", senderAddress, previousNonce, sender.getNonce());\n-\n-    final Wei upfrontGasCost = transaction.getUpfrontGasCost(transactionGasPrice);\n-    final Wei previousBalance = senderMutableAccount.decrementBalance(upfrontGasCost);\n-    LOG.trace(\n-        \"Deducted sender {} upfront gas cost {} ({} -> {})\",\n-        senderAddress,\n-        upfrontGasCost,\n-        previousBalance,\n-        sender.getBalance());\n-\n-    final Gas intrinsicGas = gasCalculator.transactionIntrinsicGasCost(transaction);\n-    final Gas gasAvailable = Gas.of(transaction.getGasLimit()).minus(intrinsicGas);\n-    LOG.trace(\n-        \"Gas available for execution {} = {} - {} (limit - intrinsic)\",\n-        gasAvailable,\n-        transaction.getGasLimit(),\n-        intrinsicGas);\n-\n-    final WorldUpdater worldUpdater = worldState.updater();\n-    final MessageFrame initialFrame;\n-    final Deque<MessageFrame> messageFrameStack = new ArrayDeque<>();\n-    final ReturnStack returnStack = new ReturnStack();\n-\n-    if (transaction.isContractCreation()) {\n-      final Address contractAddress =\n-          Address.contractAddress(senderAddress, sender.getNonce() - 1L);\n-\n-      initialFrame =\n-          MessageFrame.builder()\n-              .type(MessageFrame.Type.CONTRACT_CREATION)\n-              .messageFrameStack(messageFrameStack)\n-              .returnStack(returnStack)\n-              .blockchain(blockchain)\n-              .worldState(worldUpdater.updater())\n-              .initialGas(gasAvailable)\n-              .address(contractAddress)\n-              .originator(senderAddress)\n-              .contract(contractAddress)\n-              .contractAccountVersion(createContractAccountVersion)\n-              .gasPrice(transactionGasPrice)\n-              .inputData(Bytes.EMPTY)\n-              .sender(senderAddress)\n-              .value(transaction.getValue())\n-              .apparentValue(transaction.getValue())\n-              .code(new Code(transaction.getPayload()))\n-              .blockHeader(blockHeader)\n-              .depth(0)\n-              .completer(c -> {})\n-              .miningBeneficiary(miningBeneficiary)\n-              .blockHashLookup(blockHashLookup)\n-              .isPersistingPrivateState(isPersistingPrivateState)\n-              .maxStackSize(maxStackSize)\n-              .transactionHash(transaction.getHash())\n-              .build();\n-\n-    } else {\n-      final Address to = transaction.getTo().get();\n-      final Account contract = worldState.get(to);\n-\n-      initialFrame =\n-          MessageFrame.builder()\n-              .type(MessageFrame.Type.MESSAGE_CALL)\n-              .messageFrameStack(messageFrameStack)\n-              .returnStack(returnStack)\n-              .blockchain(blockchain)\n-              .worldState(worldUpdater.updater())\n-              .initialGas(gasAvailable)\n-              .address(to)\n-              .originator(senderAddress)\n-              .contract(to)\n-              .contractAccountVersion(\n-                  contract != null ? contract.getVersion() : Account.DEFAULT_VERSION)\n-              .gasPrice(transactionGasPrice)\n-              .inputData(transaction.getPayload())\n-              .sender(senderAddress)\n-              .value(transaction.getValue())\n-              .apparentValue(transaction.getValue())\n-              .code(new Code(contract != null ? contract.getCode() : Bytes.EMPTY))\n-              .blockHeader(blockHeader)\n-              .depth(0)\n-              .completer(c -> {})\n-              .miningBeneficiary(miningBeneficiary)\n-              .blockHashLookup(blockHashLookup)\n-              .maxStackSize(maxStackSize)\n-              .isPersistingPrivateState(isPersistingPrivateState)\n-              .transactionHash(transaction.getHash())\n-              .build();\n-    }\n+      final MutableAccount senderMutableAccount = sender.getMutable();\n+      final long previousNonce = senderMutableAccount.incrementNonce();\n+      final Wei transactionGasPrice =\n+          transactionPriceCalculator.price(transaction, blockHeader.getBaseFee());\n+      LOG.trace(\n+          \"Incremented sender {} nonce ({} -> {})\",\n+          senderAddress,\n+          previousNonce,\n+          sender.getNonce());\n \n-    messageFrameStack.addFirst(initialFrame);\n+      final Wei upfrontGasCost = transaction.getUpfrontGasCost(transactionGasPrice);\n+      final Wei previousBalance = senderMutableAccount.decrementBalance(upfrontGasCost);\n+      LOG.trace(\n+          \"Deducted sender {} upfront gas cost {} ({} -> {})\",\n+          senderAddress,\n+          upfrontGasCost,\n+          previousBalance,\n+          sender.getBalance());\n+\n+      final Gas intrinsicGas = gasCalculator.transactionIntrinsicGasCost(transaction);\n+      final Gas gasAvailable = Gas.of(transaction.getGasLimit()).minus(intrinsicGas);\n+      LOG.trace(\n+          \"Gas available for execution {} = {} - {} (limit - intrinsic)\",\n+          gasAvailable,\n+          transaction.getGasLimit(),\n+          intrinsicGas);\n+\n+      final WorldUpdater worldUpdater = worldState.updater();\n+      final MessageFrame initialFrame;\n+      final Deque<MessageFrame> messageFrameStack = new ArrayDeque<>();\n+      final ReturnStack returnStack = new ReturnStack();\n+\n+      if (transaction.isContractCreation()) {\n+        final Address contractAddress =\n+            Address.contractAddress(senderAddress, sender.getNonce() - 1L);\n+\n+        initialFrame =\n+            MessageFrame.builder()\n+                .type(MessageFrame.Type.CONTRACT_CREATION)\n+                .messageFrameStack(messageFrameStack)\n+                .returnStack(returnStack)\n+                .blockchain(blockchain)\n+                .worldState(worldUpdater.updater())\n+                .initialGas(gasAvailable)\n+                .address(contractAddress)\n+                .originator(senderAddress)\n+                .contract(contractAddress)\n+                .contractAccountVersion(createContractAccountVersion)\n+                .gasPrice(transactionGasPrice)\n+                .inputData(Bytes.EMPTY)\n+                .sender(senderAddress)\n+                .value(transaction.getValue())\n+                .apparentValue(transaction.getValue())\n+                .code(new Code(transaction.getPayload()))\n+                .blockHeader(blockHeader)\n+                .depth(0)\n+                .completer(c -> {})\n+                .miningBeneficiary(miningBeneficiary)\n+                .blockHashLookup(blockHashLookup)\n+                .isPersistingPrivateState(isPersistingPrivateState)\n+                .maxStackSize(maxStackSize)\n+                .transactionHash(transaction.getHash())\n+                .build();\n+\n+      } else {\n+        final Address to = transaction.getTo().get();\n+        final Account contract = worldState.get(to);\n+\n+        initialFrame =\n+            MessageFrame.builder()\n+                .type(MessageFrame.Type.MESSAGE_CALL)\n+                .messageFrameStack(messageFrameStack)\n+                .returnStack(returnStack)\n+                .blockchain(blockchain)\n+                .worldState(worldUpdater.updater())\n+                .initialGas(gasAvailable)\n+                .address(to)\n+                .originator(senderAddress)\n+                .contract(to)\n+                .contractAccountVersion(\n+                    contract != null ? contract.getVersion() : Account.DEFAULT_VERSION)\n+                .gasPrice(transactionGasPrice)\n+                .inputData(transaction.getPayload())\n+                .sender(senderAddress)\n+                .value(transaction.getValue())\n+                .apparentValue(transaction.getValue())\n+                .code(new Code(contract != null ? contract.getCode() : Bytes.EMPTY))\n+                .blockHeader(blockHeader)\n+                .depth(0)\n+                .completer(c -> {})\n+                .miningBeneficiary(miningBeneficiary)\n+                .blockHashLookup(blockHashLookup)\n+                .maxStackSize(maxStackSize)\n+                .isPersistingPrivateState(isPersistingPrivateState)\n+                .transactionHash(transaction.getHash())\n+                .build();\n+      }\n \n-    while (!messageFrameStack.isEmpty()) {\n-      process(messageFrameStack.peekFirst(), operationTracer);\n-    }\n+      messageFrameStack.addFirst(initialFrame);\n \n-    if (initialFrame.getState() == MessageFrame.State.COMPLETED_SUCCESS) {\n-      worldUpdater.commit();\n-    }\n+      while (!messageFrameStack.isEmpty()) {\n+        process(messageFrameStack.peekFirst(), operationTracer);\n+      }\n \n-    if (LOG.isTraceEnabled()) {\n-      LOG.trace(\n-          \"Gas used by transaction: {}, by message call/contract creation: {}\",\n-          () -> Gas.of(transaction.getGasLimit()).minus(initialFrame.getRemainingGas()),\n-          () -> gasAvailable.minus(initialFrame.getRemainingGas()));\n-    }\n+      if (initialFrame.getState() == MessageFrame.State.COMPLETED_SUCCESS) {\n+        worldUpdater.commit();\n+      }\n \n-    // Refund the sender by what we should and pay the miner fee (note that we're doing them one\n-    // after the other so that if it is the same account somehow, we end up with the right result)\n-    final Gas selfDestructRefund =\n-        gasCalculator.getSelfDestructRefundAmount().times(initialFrame.getSelfDestructs().size());\n-    final Gas refundGas = initialFrame.getGasRefund().plus(selfDestructRefund);\n-    final Gas refunded = refunded(transaction, initialFrame.getRemainingGas(), refundGas);\n-    final Wei refundedWei = refunded.priceFor(transactionGasPrice);\n-    senderMutableAccount.incrementBalance(refundedWei);\n-\n-    final Gas gasUsedByTransaction =\n-        Gas.of(transaction.getGasLimit()).minus(initialFrame.getRemainingGas());\n-\n-    final MutableAccount coinbase = worldState.getOrCreate(miningBeneficiary).getMutable();\n-    final Gas coinbaseFee = Gas.of(transaction.getGasLimit()).minus(refunded);\n-    if (blockHeader.getBaseFee().isPresent() && transaction.isEIP1559Transaction()) {\n-      final Wei baseFee = Wei.of(blockHeader.getBaseFee().get());\n-      if (transactionGasPrice.compareTo(baseFee) < 0) {\n-        return Result.failed(\n-            gasUsedByTransaction.toLong(),\n-            refunded.toLong(),\n-            ValidationResult.invalid(\n-                TransactionValidator.TransactionInvalidReason.TRANSACTION_PRICE_TOO_LOW,\n-                \"transaction price must be greater than base fee\"),\n-            Optional.empty());\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\n+            \"Gas used by transaction: {}, by message call/contract creation: {}\",\n+            () -> Gas.of(transaction.getGasLimit()).minus(initialFrame.getRemainingGas()),\n+            () -> gasAvailable.minus(initialFrame.getRemainingGas()));\n       }\n-    }\n-    final CoinbaseFeePriceCalculator coinbaseCreditService =\n-        transaction.isFrontierTransaction()\n-            ? CoinbaseFeePriceCalculator.frontier()\n-            : coinbaseFeePriceCalculator;\n-    final Wei coinbaseWeiDelta =\n-        coinbaseCreditService.price(coinbaseFee, transactionGasPrice, blockHeader.getBaseFee());\n \n-    coinbase.incrementBalance(coinbaseWeiDelta);\n+      // Refund the sender by what we should and pay the miner fee (note that we're doing them one\n+      // after the other so that if it is the same account somehow, we end up with the right result)\n+      final Gas selfDestructRefund =\n+          gasCalculator.getSelfDestructRefundAmount().times(initialFrame.getSelfDestructs().size());\n+      final Gas refundGas = initialFrame.getGasRefund().plus(selfDestructRefund);\n+      final Gas refunded = refunded(transaction, initialFrame.getRemainingGas(), refundGas);\n+      final Wei refundedWei = refunded.priceFor(transactionGasPrice);\n+      senderMutableAccount.incrementBalance(refundedWei);\n+\n+      final Gas gasUsedByTransaction =\n+          Gas.of(transaction.getGasLimit()).minus(initialFrame.getRemainingGas());\n+\n+      final MutableAccount coinbase = worldState.getOrCreate(miningBeneficiary).getMutable();\n+      final Gas coinbaseFee = Gas.of(transaction.getGasLimit()).minus(refunded);\n+      if (blockHeader.getBaseFee().isPresent() && transaction.isEIP1559Transaction()) {\n+        final Wei baseFee = Wei.of(blockHeader.getBaseFee().get());\n+        if (transactionGasPrice.compareTo(baseFee) < 0) {\n+          return Result.failed(\n+              gasUsedByTransaction.toLong(),\n+              refunded.toLong(),\n+              ValidationResult.invalid(\n+                  TransactionValidator.TransactionInvalidReason.TRANSACTION_PRICE_TOO_LOW,\n+                  \"transaction price must be greater than base fee\"),\n+              Optional.empty());\n+        }\n+      }\n+      final CoinbaseFeePriceCalculator coinbaseCreditService =\n+          transaction.isFrontierTransaction()\n+              ? CoinbaseFeePriceCalculator.frontier()\n+              : coinbaseFeePriceCalculator;\n+      final Wei coinbaseWeiDelta =\n+          coinbaseCreditService.price(coinbaseFee, transactionGasPrice, blockHeader.getBaseFee());\n \n-    initialFrame.getSelfDestructs().forEach(worldState::deleteAccount);\n+      coinbase.incrementBalance(coinbaseWeiDelta);\n \n-    if (clearEmptyAccounts) {\n-      clearEmptyAccounts(worldState);\n-    }\n+      initialFrame.getSelfDestructs().forEach(worldState::deleteAccount);\n \n-    if (initialFrame.getState() == MessageFrame.State.COMPLETED_SUCCESS) {\n-      return Result.successful(\n-          initialFrame.getLogs(),\n-          gasUsedByTransaction.toLong(),\n-          refunded.toLong(),\n-          initialFrame.getOutputData(),\n-          validationResult);\n-    } else {\n-      return Result.failed(\n-          gasUsedByTransaction.toLong(),\n-          refunded.toLong(),\n-          validationResult,\n-          initialFrame.getRevertReason());\n+      if (clearEmptyAccounts) {\n+        clearEmptyAccounts(worldState);\n+      }\n+\n+      if (initialFrame.getState() == MessageFrame.State.COMPLETED_SUCCESS) {\n+        return Result.successful(\n+            initialFrame.getLogs(),\n+            gasUsedByTransaction.toLong(),\n+            refunded.toLong(),\n+            initialFrame.getOutputData(),\n+            validationResult);\n+      } else {\n+        return Result.failed(\n+            gasUsedByTransaction.toLong(),\n+            refunded.toLong(),\n+            validationResult,\n+            initialFrame.getRevertReason());\n+      }\n+    } catch (final RuntimeException re) {\n+      LOG.error(\"Critical Exception Processing Transaction\", re);\n+      return Result.invalid(\n+          ValidationResult.invalid(\n+              TransactionInvalidReason.INTERNAL_ERROR,\n+              \"Internal Error in Besu - \" + re.toString()));\n     }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwMDQ2NQ=="}, "originalCommit": {"oid": "2bfc4279e823f1afaa11de13393464e15b50afcc"}, "originalPosition": 385}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 760, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}