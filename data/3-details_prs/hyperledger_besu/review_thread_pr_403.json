{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc1NTQxMzcw", "number": 403, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxOTo1ODozMFrODgfjfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNDozNToxNFrODjfNrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1Mzk4MDE0OnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/chain/BlockAddedEvent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxOTo1ODozMFrOFqumbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxOTo1ODozMFrOFqumbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM0ODAxNQ==", "bodyText": "Whenever possible, use Optional instead of null.", "url": "https://github.com/hyperledger/besu/pull/403#discussion_r380348015", "createdAt": "2020-02-17T19:58:30Z", "author": {"login": "RatanRSur"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/chain/BlockAddedEvent.java", "diffHunk": "@@ -73,7 +83,8 @@ public static BlockAddedEvent createForFork(final Block block) {\n         block,\n         Collections.emptyList(),\n         Collections.emptyList(),\n-        Collections.emptyList());\n+        Collections.emptyList(),\n+        null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5fcbf57d34db262c71c257ec40ea65d0b6b4571"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1Mzk4Mjk1OnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/chain/BlockAddedEvent.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QyMDowMDowNlrOFquoIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QyMDowNDoxM1rOFqusQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM0ODQ1MQ==", "bodyText": "reorgBlock is a bit ambiguous with block above. I suggest renaming the first one to newChainHead and the second to commonAncestorWithOldHead", "url": "https://github.com/hyperledger/besu/pull/403#discussion_r380348451", "createdAt": "2020-02-17T20:00:06Z", "author": {"login": "RatanRSur"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/chain/BlockAddedEvent.java", "diffHunk": "@@ -55,16 +58,23 @@ public static BlockAddedEvent createForHeadAdvancement(\n         block,\n         block.getBody().getTransactions(),\n         Collections.emptyList(),\n-        logsWithMetadata);\n+        logsWithMetadata,\n+        null);\n   }\n \n   public static BlockAddedEvent createForChainReorg(\n       final Block block,\n       final List<Transaction> addedTransactions,\n       final List<Transaction> removedTransactions,\n-      final List<LogWithMetadata> logsWithMetadata) {\n+      final List<LogWithMetadata> logsWithMetadata,\n+      final Block reorgBlock) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5fcbf57d34db262c71c257ec40ea65d0b6b4571"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM0OTUwNA==", "bodyText": "I think there's actually always a sensible value for commonAncestorWithOldHead, even for non-reorgs. It would be the parent block of the block in the event. Then, the new block subscription could actually just walk between the common ancestor block and the event block, sending notifications as it walks. I think this would remove the need to split the logic in onBlockAdded.\nIf it works, it would also remove the need to use Optional or null", "url": "https://github.com/hyperledger/besu/pull/403#discussion_r380349504", "createdAt": "2020-02-17T20:04:13Z", "author": {"login": "RatanRSur"}, "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/chain/BlockAddedEvent.java", "diffHunk": "@@ -55,16 +58,23 @@ public static BlockAddedEvent createForHeadAdvancement(\n         block,\n         block.getBody().getTransactions(),\n         Collections.emptyList(),\n-        logsWithMetadata);\n+        logsWithMetadata,\n+        null);\n   }\n \n   public static BlockAddedEvent createForChainReorg(\n       final Block block,\n       final List<Transaction> addedTransactions,\n       final List<Transaction> removedTransactions,\n-      final List<LogWithMetadata> logsWithMetadata) {\n+      final List<LogWithMetadata> logsWithMetadata,\n+      final Block reorgBlock) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM0ODQ1MQ=="}, "originalCommit": {"oid": "f5fcbf57d34db262c71c257ec40ea65d0b6b4571"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MTI2MjQ1OnYy", "diffSide": "RIGHT", "path": "ethereum/api/src/test/java/org/hyperledger/besu/ethereum/api/jsonrpc/websocket/subscription/blockheaders/NewBlockHeadersSubscriptionServiceTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yM1QwOTozMjo0M1rOFtPs0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMzo0NDoxNlrOFthCXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk4NzQ3Mw==", "bodyText": "we need to add the final keyword whenever possible", "url": "https://github.com/hyperledger/besu/pull/403#discussion_r382987473", "createdAt": "2020-02-23T09:32:43Z", "author": {"login": "matkt"}, "path": "ethereum/api/src/test/java/org/hyperledger/besu/ethereum/api/jsonrpc/websocket/subscription/blockheaders/NewBlockHeadersSubscriptionServiceTest.java", "diffHunk": "@@ -63,76 +73,116 @@\n   @Captor ArgumentCaptor<JsonRpcResult> responseCaptor;\n \n   @Mock private SubscriptionManager subscriptionManager;\n-  @Mock private BlockchainQueries blockchainQueries;\n \n   private final BlockHeaderTestFixture blockHeaderTestFixture = new BlockHeaderTestFixture();\n   private final TransactionTestFixture txTestFixture = new TransactionTestFixture();\n   private final BlockHeader blockHeader = blockHeaderTestFixture.buildHeader();\n   private final BlockResultFactory blockResultFactory = new BlockResultFactory();\n+  private final BlockDataGenerator gen = new BlockDataGenerator();\n+  private final BlockchainStorage blockchainStorage =\n+      new KeyValueStoragePrefixedKeyBlockchainStorage(\n+          new InMemoryKeyValueStorage(), new MainnetBlockHeaderFunctions());\n+  private final Block genesisBlock = gen.genesisBlock();\n+  private final DefaultBlockchain blockchain =\n+      (DefaultBlockchain)\n+          DefaultBlockchain.createMutable(genesisBlock, blockchainStorage, new NoOpMetricsSystem());\n+\n+  @Spy\n+  private BlockchainQueries blockchainQueriesSpy =\n+      Mockito.spy(new BlockchainQueries(blockchain, createInMemoryWorldStateArchive()));\n \n   @Before\n   public void before() {\n     newBlockHeadersSubscriptionService =\n-        new NewBlockHeadersSubscriptionService(subscriptionManager, blockchainQueries);\n+        new NewBlockHeadersSubscriptionService(subscriptionManager, blockchainQueriesSpy);\n   }\n \n   @Test\n   public void shouldSendMessageWhenBlockAddedOnCanonicalChain() {\n     final NewBlockHeadersSubscription subscription = createSubscription(false);\n     mockSubscriptionManagerNotifyMethod(subscription);\n-    final BlockResult expectedNewBlock = expectedBlockWithTransactions(Collections.emptyList());\n \n-    simulateAddingBlockOnCanonicalChain();\n+    final Block testBlock = appendBlockWithParent(blockchain, blockchain.getChainHeadBlock());\n+    simulateAddingBlockOnCanonicalChain(testBlock);\n+    final BlockResult expectedNewBlock =\n+        blockResultFactory.transactionHash(\n+            blockchainQueriesSpy.blockByHashWithTxHashes(testBlock.getHash()).orElse(null));\n \n     verify(subscriptionManager)\n         .sendMessage(subscriptionIdCaptor.capture(), responseCaptor.capture());\n     assertThat(subscriptionIdCaptor.getValue()).isEqualTo(subscription.getSubscriptionId());\n-    assertThat(responseCaptor.getValue())\n-        .isEqualToComparingFieldByFieldRecursively(expectedNewBlock);\n+    assertThat(responseCaptor.getValue()).usingRecursiveComparison().isEqualTo(expectedNewBlock);\n   }\n \n   @Test\n   public void shouldNotSendMessageWhenBlockAddedIsNotOnCanonicalChain() {\n     simulateAddingBlockOnNonCanonicalChain();\n \n-    verifyZeroInteractions(subscriptionManager);\n+    verifyNoMoreInteractions(subscriptionManager);\n+  }\n+\n+  @Test\n+  public void shouldSendMessagesWhenReorgBlockAdded() {\n+    final NewBlockHeadersSubscription subscription = createSubscription(false);\n+    mockSubscriptionManagerNotifyMethod(subscription);\n+\n+    appendBlockWithParent(blockchain, genesisBlock);\n+    final Block forkBlock = appendBlockWithParent(blockchain, genesisBlock);\n+    final Block forkBlock1 = appendBlockWithParent(blockchain, forkBlock);\n+    final Block forkBlock2 = appendBlockWithParent(blockchain, forkBlock1);\n+    simulateAddingReorgBlock(forkBlock2, genesisBlock);\n+    final BlockResult expectedNewBlock =\n+        blockResultFactory.transactionHash(\n+            blockchainQueriesSpy.blockByHashWithTxHashes(forkBlock2.getHash()).orElse(null));\n+\n+    verify(subscriptionManager, times(3)).notifySubscribersOnWorkerThread(any(), any(), any());\n+    verify(subscriptionManager, times(3))\n+        .sendMessage(subscriptionIdCaptor.capture(), responseCaptor.capture());\n+    assertThat(subscriptionIdCaptor.getValue()).isEqualTo(subscription.getSubscriptionId());\n+    assertThat(responseCaptor.getValue()).usingRecursiveComparison().isEqualTo(expectedNewBlock);\n   }\n \n   @Test\n   public void shouldReturnTxHashesWhenIncludeTransactionsFalse() {\n     final NewBlockHeadersSubscription subscription = createSubscription(false);\n     mockSubscriptionManagerNotifyMethod(subscription);\n-    final List<Hash> txHashList = transactionsWithHashOnly();\n-    final BlockResult expectedNewBlock = expectedBlockWithTransactions(txHashList);\n+    final List<Transaction> transactions = transactions();\n \n-    simulateAddingBlockOnCanonicalChain();\n+    final Block testBlock =\n+        appendBlockWithParent(blockchain, blockchain.getChainHeadBlock(), transactions);\n+    simulateAddingBlockOnCanonicalChain(testBlock);\n+    final BlockResult expectedNewBlock =\n+        blockResultFactory.transactionHash(\n+            blockchainQueriesSpy.blockByHashWithTxHashes(testBlock.getHash()).orElse(null));\n \n     verify(subscriptionManager)\n         .sendMessage(subscriptionIdCaptor.capture(), responseCaptor.capture());\n     assertThat(subscriptionIdCaptor.getValue()).isEqualTo(subscription.getSubscriptionId());\n     final Object actualBlock = responseCaptor.getValue();\n     assertThat(actualBlock).isInstanceOf(BlockResult.class);\n-    assertThat(((BlockResult) actualBlock).getTransactions()).hasSize(txHashList.size());\n-    assertThat(actualBlock).isEqualToComparingFieldByFieldRecursively(expectedNewBlock);\n+    assertThat(((BlockResult) actualBlock).getTransactions()).hasSize(transactions.size());\n+    assertThat(actualBlock).usingRecursiveComparison().isEqualTo(expectedNewBlock);\n \n-    verify(blockchainQueries, times(1)).blockByHashWithTxHashes(any());\n-    verify(blockchainQueries, times(0)).blockByHash(any());\n+    verify(blockchainQueriesSpy, times(2)).blockByHashWithTxHashes(any());\n+    verify(blockchainQueriesSpy, times(0)).blockByHash(any());\n   }\n \n   @Test\n   public void shouldReturnCompleteTxWhenParameterTrue() {\n     final NewBlockHeadersSubscription subscription = createSubscription(true);\n     mockSubscriptionManagerNotifyMethod(subscription);\n-    final List<TransactionWithMetadata> txHashList = transactionsWithMetadata();\n-    final BlockWithMetadata<TransactionWithMetadata, Hash> testBlockWithMetadata =\n-        new BlockWithMetadata<>(\n-            blockHeader, txHashList, Collections.emptyList(), blockHeader.getDifficulty(), 0);\n+    final List<TransactionWithMetadata> transactionsWithMetadata = transactionsWithMetadata();\n+\n+    List<Transaction> transactions =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4061482e18f930ab191089e600e79881f8127659"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI3MTUxNw==", "bodyText": "Done.", "url": "https://github.com/hyperledger/besu/pull/403#discussion_r383271517", "createdAt": "2020-02-24T13:44:16Z", "author": {"login": "davemec"}, "path": "ethereum/api/src/test/java/org/hyperledger/besu/ethereum/api/jsonrpc/websocket/subscription/blockheaders/NewBlockHeadersSubscriptionServiceTest.java", "diffHunk": "@@ -63,76 +73,116 @@\n   @Captor ArgumentCaptor<JsonRpcResult> responseCaptor;\n \n   @Mock private SubscriptionManager subscriptionManager;\n-  @Mock private BlockchainQueries blockchainQueries;\n \n   private final BlockHeaderTestFixture blockHeaderTestFixture = new BlockHeaderTestFixture();\n   private final TransactionTestFixture txTestFixture = new TransactionTestFixture();\n   private final BlockHeader blockHeader = blockHeaderTestFixture.buildHeader();\n   private final BlockResultFactory blockResultFactory = new BlockResultFactory();\n+  private final BlockDataGenerator gen = new BlockDataGenerator();\n+  private final BlockchainStorage blockchainStorage =\n+      new KeyValueStoragePrefixedKeyBlockchainStorage(\n+          new InMemoryKeyValueStorage(), new MainnetBlockHeaderFunctions());\n+  private final Block genesisBlock = gen.genesisBlock();\n+  private final DefaultBlockchain blockchain =\n+      (DefaultBlockchain)\n+          DefaultBlockchain.createMutable(genesisBlock, blockchainStorage, new NoOpMetricsSystem());\n+\n+  @Spy\n+  private BlockchainQueries blockchainQueriesSpy =\n+      Mockito.spy(new BlockchainQueries(blockchain, createInMemoryWorldStateArchive()));\n \n   @Before\n   public void before() {\n     newBlockHeadersSubscriptionService =\n-        new NewBlockHeadersSubscriptionService(subscriptionManager, blockchainQueries);\n+        new NewBlockHeadersSubscriptionService(subscriptionManager, blockchainQueriesSpy);\n   }\n \n   @Test\n   public void shouldSendMessageWhenBlockAddedOnCanonicalChain() {\n     final NewBlockHeadersSubscription subscription = createSubscription(false);\n     mockSubscriptionManagerNotifyMethod(subscription);\n-    final BlockResult expectedNewBlock = expectedBlockWithTransactions(Collections.emptyList());\n \n-    simulateAddingBlockOnCanonicalChain();\n+    final Block testBlock = appendBlockWithParent(blockchain, blockchain.getChainHeadBlock());\n+    simulateAddingBlockOnCanonicalChain(testBlock);\n+    final BlockResult expectedNewBlock =\n+        blockResultFactory.transactionHash(\n+            blockchainQueriesSpy.blockByHashWithTxHashes(testBlock.getHash()).orElse(null));\n \n     verify(subscriptionManager)\n         .sendMessage(subscriptionIdCaptor.capture(), responseCaptor.capture());\n     assertThat(subscriptionIdCaptor.getValue()).isEqualTo(subscription.getSubscriptionId());\n-    assertThat(responseCaptor.getValue())\n-        .isEqualToComparingFieldByFieldRecursively(expectedNewBlock);\n+    assertThat(responseCaptor.getValue()).usingRecursiveComparison().isEqualTo(expectedNewBlock);\n   }\n \n   @Test\n   public void shouldNotSendMessageWhenBlockAddedIsNotOnCanonicalChain() {\n     simulateAddingBlockOnNonCanonicalChain();\n \n-    verifyZeroInteractions(subscriptionManager);\n+    verifyNoMoreInteractions(subscriptionManager);\n+  }\n+\n+  @Test\n+  public void shouldSendMessagesWhenReorgBlockAdded() {\n+    final NewBlockHeadersSubscription subscription = createSubscription(false);\n+    mockSubscriptionManagerNotifyMethod(subscription);\n+\n+    appendBlockWithParent(blockchain, genesisBlock);\n+    final Block forkBlock = appendBlockWithParent(blockchain, genesisBlock);\n+    final Block forkBlock1 = appendBlockWithParent(blockchain, forkBlock);\n+    final Block forkBlock2 = appendBlockWithParent(blockchain, forkBlock1);\n+    simulateAddingReorgBlock(forkBlock2, genesisBlock);\n+    final BlockResult expectedNewBlock =\n+        blockResultFactory.transactionHash(\n+            blockchainQueriesSpy.blockByHashWithTxHashes(forkBlock2.getHash()).orElse(null));\n+\n+    verify(subscriptionManager, times(3)).notifySubscribersOnWorkerThread(any(), any(), any());\n+    verify(subscriptionManager, times(3))\n+        .sendMessage(subscriptionIdCaptor.capture(), responseCaptor.capture());\n+    assertThat(subscriptionIdCaptor.getValue()).isEqualTo(subscription.getSubscriptionId());\n+    assertThat(responseCaptor.getValue()).usingRecursiveComparison().isEqualTo(expectedNewBlock);\n   }\n \n   @Test\n   public void shouldReturnTxHashesWhenIncludeTransactionsFalse() {\n     final NewBlockHeadersSubscription subscription = createSubscription(false);\n     mockSubscriptionManagerNotifyMethod(subscription);\n-    final List<Hash> txHashList = transactionsWithHashOnly();\n-    final BlockResult expectedNewBlock = expectedBlockWithTransactions(txHashList);\n+    final List<Transaction> transactions = transactions();\n \n-    simulateAddingBlockOnCanonicalChain();\n+    final Block testBlock =\n+        appendBlockWithParent(blockchain, blockchain.getChainHeadBlock(), transactions);\n+    simulateAddingBlockOnCanonicalChain(testBlock);\n+    final BlockResult expectedNewBlock =\n+        blockResultFactory.transactionHash(\n+            blockchainQueriesSpy.blockByHashWithTxHashes(testBlock.getHash()).orElse(null));\n \n     verify(subscriptionManager)\n         .sendMessage(subscriptionIdCaptor.capture(), responseCaptor.capture());\n     assertThat(subscriptionIdCaptor.getValue()).isEqualTo(subscription.getSubscriptionId());\n     final Object actualBlock = responseCaptor.getValue();\n     assertThat(actualBlock).isInstanceOf(BlockResult.class);\n-    assertThat(((BlockResult) actualBlock).getTransactions()).hasSize(txHashList.size());\n-    assertThat(actualBlock).isEqualToComparingFieldByFieldRecursively(expectedNewBlock);\n+    assertThat(((BlockResult) actualBlock).getTransactions()).hasSize(transactions.size());\n+    assertThat(actualBlock).usingRecursiveComparison().isEqualTo(expectedNewBlock);\n \n-    verify(blockchainQueries, times(1)).blockByHashWithTxHashes(any());\n-    verify(blockchainQueries, times(0)).blockByHash(any());\n+    verify(blockchainQueriesSpy, times(2)).blockByHashWithTxHashes(any());\n+    verify(blockchainQueriesSpy, times(0)).blockByHash(any());\n   }\n \n   @Test\n   public void shouldReturnCompleteTxWhenParameterTrue() {\n     final NewBlockHeadersSubscription subscription = createSubscription(true);\n     mockSubscriptionManagerNotifyMethod(subscription);\n-    final List<TransactionWithMetadata> txHashList = transactionsWithMetadata();\n-    final BlockWithMetadata<TransactionWithMetadata, Hash> testBlockWithMetadata =\n-        new BlockWithMetadata<>(\n-            blockHeader, txHashList, Collections.emptyList(), blockHeader.getDifficulty(), 0);\n+    final List<TransactionWithMetadata> transactionsWithMetadata = transactionsWithMetadata();\n+\n+    List<Transaction> transactions =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk4NzQ3Mw=="}, "originalCommit": {"oid": "4061482e18f930ab191089e600e79881f8127659"}, "originalPosition": 180}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NDIwNTMzOnYy", "diffSide": "RIGHT", "path": "ethereum/api/src/test/java/org/hyperledger/besu/ethereum/api/jsonrpc/websocket/subscription/blockheaders/NewBlockHeadersSubscriptionServiceTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxNzo1Nzo1N1rOFtqMuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxODoxMjoxMlrOFtqoBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQyMTYyNw==", "bodyText": "What happens if this cast isn't here?", "url": "https://github.com/hyperledger/besu/pull/403#discussion_r383421627", "createdAt": "2020-02-24T17:57:57Z", "author": {"login": "RatanRSur"}, "path": "ethereum/api/src/test/java/org/hyperledger/besu/ethereum/api/jsonrpc/websocket/subscription/blockheaders/NewBlockHeadersSubscriptionServiceTest.java", "diffHunk": "@@ -63,76 +73,116 @@\n   @Captor ArgumentCaptor<JsonRpcResult> responseCaptor;\n \n   @Mock private SubscriptionManager subscriptionManager;\n-  @Mock private BlockchainQueries blockchainQueries;\n \n   private final BlockHeaderTestFixture blockHeaderTestFixture = new BlockHeaderTestFixture();\n   private final TransactionTestFixture txTestFixture = new TransactionTestFixture();\n   private final BlockHeader blockHeader = blockHeaderTestFixture.buildHeader();\n   private final BlockResultFactory blockResultFactory = new BlockResultFactory();\n+  private final BlockDataGenerator gen = new BlockDataGenerator();\n+  private final BlockchainStorage blockchainStorage =\n+      new KeyValueStoragePrefixedKeyBlockchainStorage(\n+          new InMemoryKeyValueStorage(), new MainnetBlockHeaderFunctions());\n+  private final Block genesisBlock = gen.genesisBlock();\n+  private final DefaultBlockchain blockchain =\n+      (DefaultBlockchain)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfdca5b87bbeca1d71a9a9a359f7c4da6bde6c9c"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQyODYxMg==", "bodyText": "I will change the variable to be a MutableBlockchain.", "url": "https://github.com/hyperledger/besu/pull/403#discussion_r383428612", "createdAt": "2020-02-24T18:12:12Z", "author": {"login": "davemec"}, "path": "ethereum/api/src/test/java/org/hyperledger/besu/ethereum/api/jsonrpc/websocket/subscription/blockheaders/NewBlockHeadersSubscriptionServiceTest.java", "diffHunk": "@@ -63,76 +73,116 @@\n   @Captor ArgumentCaptor<JsonRpcResult> responseCaptor;\n \n   @Mock private SubscriptionManager subscriptionManager;\n-  @Mock private BlockchainQueries blockchainQueries;\n \n   private final BlockHeaderTestFixture blockHeaderTestFixture = new BlockHeaderTestFixture();\n   private final TransactionTestFixture txTestFixture = new TransactionTestFixture();\n   private final BlockHeader blockHeader = blockHeaderTestFixture.buildHeader();\n   private final BlockResultFactory blockResultFactory = new BlockResultFactory();\n+  private final BlockDataGenerator gen = new BlockDataGenerator();\n+  private final BlockchainStorage blockchainStorage =\n+      new KeyValueStoragePrefixedKeyBlockchainStorage(\n+          new InMemoryKeyValueStorage(), new MainnetBlockHeaderFunctions());\n+  private final Block genesisBlock = gen.genesisBlock();\n+  private final DefaultBlockchain blockchain =\n+      (DefaultBlockchain)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQyMTYyNw=="}, "originalCommit": {"oid": "bfdca5b87bbeca1d71a9a9a359f7c4da6bde6c9c"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NDIyMzUwOnYy", "diffSide": "RIGHT", "path": "ethereum/api/src/test/java/org/hyperledger/besu/ethereum/api/jsonrpc/websocket/subscription/blockheaders/NewBlockHeadersSubscriptionServiceTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxODowMzoxOFrOFtqXdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxODozMDowM1rOFtrKUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQyNDM3NA==", "bodyText": "Why did you choose VerifyNoMoreInteractions over VerifyNoInteractions?", "url": "https://github.com/hyperledger/besu/pull/403#discussion_r383424374", "createdAt": "2020-02-24T18:03:18Z", "author": {"login": "RatanRSur"}, "path": "ethereum/api/src/test/java/org/hyperledger/besu/ethereum/api/jsonrpc/websocket/subscription/blockheaders/NewBlockHeadersSubscriptionServiceTest.java", "diffHunk": "@@ -63,76 +73,116 @@\n   @Captor ArgumentCaptor<JsonRpcResult> responseCaptor;\n \n   @Mock private SubscriptionManager subscriptionManager;\n-  @Mock private BlockchainQueries blockchainQueries;\n \n   private final BlockHeaderTestFixture blockHeaderTestFixture = new BlockHeaderTestFixture();\n   private final TransactionTestFixture txTestFixture = new TransactionTestFixture();\n   private final BlockHeader blockHeader = blockHeaderTestFixture.buildHeader();\n   private final BlockResultFactory blockResultFactory = new BlockResultFactory();\n+  private final BlockDataGenerator gen = new BlockDataGenerator();\n+  private final BlockchainStorage blockchainStorage =\n+      new KeyValueStoragePrefixedKeyBlockchainStorage(\n+          new InMemoryKeyValueStorage(), new MainnetBlockHeaderFunctions());\n+  private final Block genesisBlock = gen.genesisBlock();\n+  private final DefaultBlockchain blockchain =\n+      (DefaultBlockchain)\n+          DefaultBlockchain.createMutable(genesisBlock, blockchainStorage, new NoOpMetricsSystem());\n+\n+  @Spy\n+  private BlockchainQueries blockchainQueriesSpy =\n+      Mockito.spy(new BlockchainQueries(blockchain, createInMemoryWorldStateArchive()));\n \n   @Before\n   public void before() {\n     newBlockHeadersSubscriptionService =\n-        new NewBlockHeadersSubscriptionService(subscriptionManager, blockchainQueries);\n+        new NewBlockHeadersSubscriptionService(subscriptionManager, blockchainQueriesSpy);\n   }\n \n   @Test\n   public void shouldSendMessageWhenBlockAddedOnCanonicalChain() {\n     final NewBlockHeadersSubscription subscription = createSubscription(false);\n     mockSubscriptionManagerNotifyMethod(subscription);\n-    final BlockResult expectedNewBlock = expectedBlockWithTransactions(Collections.emptyList());\n \n-    simulateAddingBlockOnCanonicalChain();\n+    final Block testBlock = appendBlockWithParent(blockchain, blockchain.getChainHeadBlock());\n+    simulateAddingBlockOnCanonicalChain(testBlock);\n+    final BlockResult expectedNewBlock =\n+        blockResultFactory.transactionHash(\n+            blockchainQueriesSpy.blockByHashWithTxHashes(testBlock.getHash()).orElse(null));\n \n     verify(subscriptionManager)\n         .sendMessage(subscriptionIdCaptor.capture(), responseCaptor.capture());\n     assertThat(subscriptionIdCaptor.getValue()).isEqualTo(subscription.getSubscriptionId());\n-    assertThat(responseCaptor.getValue())\n-        .isEqualToComparingFieldByFieldRecursively(expectedNewBlock);\n+    assertThat(responseCaptor.getValue()).usingRecursiveComparison().isEqualTo(expectedNewBlock);\n   }\n \n   @Test\n   public void shouldNotSendMessageWhenBlockAddedIsNotOnCanonicalChain() {\n     simulateAddingBlockOnNonCanonicalChain();\n \n-    verifyZeroInteractions(subscriptionManager);\n+    verifyNoMoreInteractions(subscriptionManager);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfdca5b87bbeca1d71a9a9a359f7c4da6bde6c9c"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQzNzM5NA==", "bodyText": "I misread the javadoc where it says VerifyNoMoreInteractions does the same thing. Will update to VerifyNoInteractions.", "url": "https://github.com/hyperledger/besu/pull/403#discussion_r383437394", "createdAt": "2020-02-24T18:30:03Z", "author": {"login": "davemec"}, "path": "ethereum/api/src/test/java/org/hyperledger/besu/ethereum/api/jsonrpc/websocket/subscription/blockheaders/NewBlockHeadersSubscriptionServiceTest.java", "diffHunk": "@@ -63,76 +73,116 @@\n   @Captor ArgumentCaptor<JsonRpcResult> responseCaptor;\n \n   @Mock private SubscriptionManager subscriptionManager;\n-  @Mock private BlockchainQueries blockchainQueries;\n \n   private final BlockHeaderTestFixture blockHeaderTestFixture = new BlockHeaderTestFixture();\n   private final TransactionTestFixture txTestFixture = new TransactionTestFixture();\n   private final BlockHeader blockHeader = blockHeaderTestFixture.buildHeader();\n   private final BlockResultFactory blockResultFactory = new BlockResultFactory();\n+  private final BlockDataGenerator gen = new BlockDataGenerator();\n+  private final BlockchainStorage blockchainStorage =\n+      new KeyValueStoragePrefixedKeyBlockchainStorage(\n+          new InMemoryKeyValueStorage(), new MainnetBlockHeaderFunctions());\n+  private final Block genesisBlock = gen.genesisBlock();\n+  private final DefaultBlockchain blockchain =\n+      (DefaultBlockchain)\n+          DefaultBlockchain.createMutable(genesisBlock, blockchainStorage, new NoOpMetricsSystem());\n+\n+  @Spy\n+  private BlockchainQueries blockchainQueriesSpy =\n+      Mockito.spy(new BlockchainQueries(blockchain, createInMemoryWorldStateArchive()));\n \n   @Before\n   public void before() {\n     newBlockHeadersSubscriptionService =\n-        new NewBlockHeadersSubscriptionService(subscriptionManager, blockchainQueries);\n+        new NewBlockHeadersSubscriptionService(subscriptionManager, blockchainQueriesSpy);\n   }\n \n   @Test\n   public void shouldSendMessageWhenBlockAddedOnCanonicalChain() {\n     final NewBlockHeadersSubscription subscription = createSubscription(false);\n     mockSubscriptionManagerNotifyMethod(subscription);\n-    final BlockResult expectedNewBlock = expectedBlockWithTransactions(Collections.emptyList());\n \n-    simulateAddingBlockOnCanonicalChain();\n+    final Block testBlock = appendBlockWithParent(blockchain, blockchain.getChainHeadBlock());\n+    simulateAddingBlockOnCanonicalChain(testBlock);\n+    final BlockResult expectedNewBlock =\n+        blockResultFactory.transactionHash(\n+            blockchainQueriesSpy.blockByHashWithTxHashes(testBlock.getHash()).orElse(null));\n \n     verify(subscriptionManager)\n         .sendMessage(subscriptionIdCaptor.capture(), responseCaptor.capture());\n     assertThat(subscriptionIdCaptor.getValue()).isEqualTo(subscription.getSubscriptionId());\n-    assertThat(responseCaptor.getValue())\n-        .isEqualToComparingFieldByFieldRecursively(expectedNewBlock);\n+    assertThat(responseCaptor.getValue()).usingRecursiveComparison().isEqualTo(expectedNewBlock);\n   }\n \n   @Test\n   public void shouldNotSendMessageWhenBlockAddedIsNotOnCanonicalChain() {\n     simulateAddingBlockOnNonCanonicalChain();\n \n-    verifyZeroInteractions(subscriptionManager);\n+    verifyNoMoreInteractions(subscriptionManager);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQyNDM3NA=="}, "originalCommit": {"oid": "bfdca5b87bbeca1d71a9a9a359f7c4da6bde6c9c"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NDI0NTE2OnYy", "diffSide": "RIGHT", "path": "ethereum/api/src/test/java/org/hyperledger/besu/ethereum/api/jsonrpc/websocket/subscription/blockheaders/NewBlockHeadersSubscriptionServiceTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxODoxMDo0NVrOFtqlWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxODoxMDo0NVrOFtqlWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQyNzkyOQ==", "bodyText": "Might as well streamline this using java streams while we're here.", "url": "https://github.com/hyperledger/besu/pull/403#discussion_r383427929", "createdAt": "2020-02-24T18:10:45Z", "author": {"login": "RatanRSur"}, "path": "ethereum/api/src/test/java/org/hyperledger/besu/ethereum/api/jsonrpc/websocket/subscription/blockheaders/NewBlockHeadersSubscriptionServiceTest.java", "diffHunk": "@@ -221,15 +273,35 @@ private void simulateAddingBlockOnNonCanonicalChain() {\n     return Lists.newArrayList(t1, t2);\n   }\n \n-  private List<Hash> transactionsWithHashOnly() {\n-    final List<Hash> hashes = new ArrayList<>();\n+  private List<Transaction> transactions() {\n+    final List<Transaction> transactions = new ArrayList<>();\n     for (final TransactionWithMetadata transactionWithMetadata : transactionsWithMetadata()) {\n-      hashes.add(transactionWithMetadata.getTransaction().getHash());\n+      transactions.add(transactionWithMetadata.getTransaction());\n     }\n-    return hashes;\n+    return transactions;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfdca5b87bbeca1d71a9a9a359f7c4da6bde6c9c"}, "originalPosition": 300}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NDI3MTczOnYy", "diffSide": "RIGHT", "path": "ethereum/api/src/test/java/org/hyperledger/besu/ethereum/api/jsonrpc/websocket/subscription/blockheaders/NewBlockHeadersSubscriptionServiceTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxODoxOTozNVrOFtq1rA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxODoxOTozNVrOFtq1rA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQzMjEwOA==", "bodyText": "I see this is just copied over from the existing code but I think we can get rid of the times(1)", "url": "https://github.com/hyperledger/besu/pull/403#discussion_r383432108", "createdAt": "2020-02-24T18:19:35Z", "author": {"login": "RatanRSur"}, "path": "ethereum/api/src/test/java/org/hyperledger/besu/ethereum/api/jsonrpc/websocket/subscription/blockheaders/NewBlockHeadersSubscriptionServiceTest.java", "diffHunk": "@@ -194,21 +236,31 @@ private void mockSubscriptionManagerNotifyMethod(\n         .notifySubscribersOnWorkerThread(any(), any(), any());\n   }\n \n-  private void simulateAddingBlockOnCanonicalChain() {\n-    final BlockBody blockBody = new BlockBody(Collections.emptyList(), Collections.emptyList());\n-    final Block testBlock = new Block(blockHeader, blockBody);\n+  private void simulateAddingBlockOnCanonicalChain(final Block block) {\n     newBlockHeadersSubscriptionService.onBlockAdded(\n-        BlockAddedEvent.createForHeadAdvancement(testBlock, Collections.emptyList()),\n-        blockchainQueries.getBlockchain());\n-    verify(blockchainQueries, times(1)).getBlockchain();\n+        BlockAddedEvent.createForHeadAdvancement(block, Collections.emptyList()),\n+        blockchainQueriesSpy.getBlockchain());\n+    verify(blockchainQueriesSpy, times(1)).getBlockchain();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfdca5b87bbeca1d71a9a9a359f7c4da6bde6c9c"}, "originalPosition": 261}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NzU1ODM2OnYy", "diffSide": "RIGHT", "path": "ethereum/api/src/test/java/org/hyperledger/besu/ethereum/api/jsonrpc/websocket/subscription/blockheaders/NewBlockHeadersSubscriptionServiceTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNToxNzowMFrOFuKE-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMTo0NzowNlrOFuWZ6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk0MzkzMQ==", "bodyText": "Does this make sure the reorg blocks are sent in the right order?", "url": "https://github.com/hyperledger/besu/pull/403#discussion_r383943931", "createdAt": "2020-02-25T15:17:00Z", "author": {"login": "RatanRSur"}, "path": "ethereum/api/src/test/java/org/hyperledger/besu/ethereum/api/jsonrpc/websocket/subscription/blockheaders/NewBlockHeadersSubscriptionServiceTest.java", "diffHunk": "@@ -63,76 +73,115 @@\n   @Captor ArgumentCaptor<JsonRpcResult> responseCaptor;\n \n   @Mock private SubscriptionManager subscriptionManager;\n-  @Mock private BlockchainQueries blockchainQueries;\n \n   private final BlockHeaderTestFixture blockHeaderTestFixture = new BlockHeaderTestFixture();\n   private final TransactionTestFixture txTestFixture = new TransactionTestFixture();\n   private final BlockHeader blockHeader = blockHeaderTestFixture.buildHeader();\n   private final BlockResultFactory blockResultFactory = new BlockResultFactory();\n+  private final BlockDataGenerator gen = new BlockDataGenerator();\n+  private final BlockchainStorage blockchainStorage =\n+      new KeyValueStoragePrefixedKeyBlockchainStorage(\n+          new InMemoryKeyValueStorage(), new MainnetBlockHeaderFunctions());\n+  private final Block genesisBlock = gen.genesisBlock();\n+  private final MutableBlockchain blockchain =\n+      DefaultBlockchain.createMutable(genesisBlock, blockchainStorage, new NoOpMetricsSystem());\n+\n+  @Spy\n+  private BlockchainQueries blockchainQueriesSpy =\n+      Mockito.spy(new BlockchainQueries(blockchain, createInMemoryWorldStateArchive()));\n \n   @Before\n   public void before() {\n     newBlockHeadersSubscriptionService =\n-        new NewBlockHeadersSubscriptionService(subscriptionManager, blockchainQueries);\n+        new NewBlockHeadersSubscriptionService(subscriptionManager, blockchainQueriesSpy);\n   }\n \n   @Test\n   public void shouldSendMessageWhenBlockAddedOnCanonicalChain() {\n     final NewBlockHeadersSubscription subscription = createSubscription(false);\n     mockSubscriptionManagerNotifyMethod(subscription);\n-    final BlockResult expectedNewBlock = expectedBlockWithTransactions(Collections.emptyList());\n \n-    simulateAddingBlockOnCanonicalChain();\n+    final Block testBlock = appendBlockWithParent(blockchain, blockchain.getChainHeadBlock());\n+    simulateAddingBlockOnCanonicalChain(testBlock);\n+    final BlockResult expectedNewBlock =\n+        blockResultFactory.transactionHash(\n+            blockchainQueriesSpy.blockByHashWithTxHashes(testBlock.getHash()).orElse(null));\n \n     verify(subscriptionManager)\n         .sendMessage(subscriptionIdCaptor.capture(), responseCaptor.capture());\n     assertThat(subscriptionIdCaptor.getValue()).isEqualTo(subscription.getSubscriptionId());\n-    assertThat(responseCaptor.getValue())\n-        .isEqualToComparingFieldByFieldRecursively(expectedNewBlock);\n+    assertThat(responseCaptor.getValue()).usingRecursiveComparison().isEqualTo(expectedNewBlock);\n   }\n \n   @Test\n   public void shouldNotSendMessageWhenBlockAddedIsNotOnCanonicalChain() {\n     simulateAddingBlockOnNonCanonicalChain();\n \n-    verifyZeroInteractions(subscriptionManager);\n+    verifyNoInteractions(subscriptionManager);\n+  }\n+\n+  @Test\n+  public void shouldSendMessagesWhenReorgBlockAdded() {\n+    final NewBlockHeadersSubscription subscription = createSubscription(false);\n+    mockSubscriptionManagerNotifyMethod(subscription);\n+\n+    appendBlockWithParent(blockchain, genesisBlock);\n+    final Block forkBlock = appendBlockWithParent(blockchain, genesisBlock);\n+    final Block forkBlock1 = appendBlockWithParent(blockchain, forkBlock);\n+    final Block forkBlock2 = appendBlockWithParent(blockchain, forkBlock1);\n+    simulateAddingReorgBlock(forkBlock2, genesisBlock);\n+    final BlockResult expectedNewBlock =\n+        blockResultFactory.transactionHash(\n+            blockchainQueriesSpy.blockByHashWithTxHashes(forkBlock2.getHash()).orElse(null));\n+\n+    verify(subscriptionManager, times(3)).notifySubscribersOnWorkerThread(any(), any(), any());\n+    verify(subscriptionManager, times(3))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bfd94a85da02d10db166cda0ce169bc3ed78c05"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE0NTg5Ng==", "bodyText": "Updated to ensure proper ordering.", "url": "https://github.com/hyperledger/besu/pull/403#discussion_r384145896", "createdAt": "2020-02-25T21:47:06Z", "author": {"login": "davemec"}, "path": "ethereum/api/src/test/java/org/hyperledger/besu/ethereum/api/jsonrpc/websocket/subscription/blockheaders/NewBlockHeadersSubscriptionServiceTest.java", "diffHunk": "@@ -63,76 +73,115 @@\n   @Captor ArgumentCaptor<JsonRpcResult> responseCaptor;\n \n   @Mock private SubscriptionManager subscriptionManager;\n-  @Mock private BlockchainQueries blockchainQueries;\n \n   private final BlockHeaderTestFixture blockHeaderTestFixture = new BlockHeaderTestFixture();\n   private final TransactionTestFixture txTestFixture = new TransactionTestFixture();\n   private final BlockHeader blockHeader = blockHeaderTestFixture.buildHeader();\n   private final BlockResultFactory blockResultFactory = new BlockResultFactory();\n+  private final BlockDataGenerator gen = new BlockDataGenerator();\n+  private final BlockchainStorage blockchainStorage =\n+      new KeyValueStoragePrefixedKeyBlockchainStorage(\n+          new InMemoryKeyValueStorage(), new MainnetBlockHeaderFunctions());\n+  private final Block genesisBlock = gen.genesisBlock();\n+  private final MutableBlockchain blockchain =\n+      DefaultBlockchain.createMutable(genesisBlock, blockchainStorage, new NoOpMetricsSystem());\n+\n+  @Spy\n+  private BlockchainQueries blockchainQueriesSpy =\n+      Mockito.spy(new BlockchainQueries(blockchain, createInMemoryWorldStateArchive()));\n \n   @Before\n   public void before() {\n     newBlockHeadersSubscriptionService =\n-        new NewBlockHeadersSubscriptionService(subscriptionManager, blockchainQueries);\n+        new NewBlockHeadersSubscriptionService(subscriptionManager, blockchainQueriesSpy);\n   }\n \n   @Test\n   public void shouldSendMessageWhenBlockAddedOnCanonicalChain() {\n     final NewBlockHeadersSubscription subscription = createSubscription(false);\n     mockSubscriptionManagerNotifyMethod(subscription);\n-    final BlockResult expectedNewBlock = expectedBlockWithTransactions(Collections.emptyList());\n \n-    simulateAddingBlockOnCanonicalChain();\n+    final Block testBlock = appendBlockWithParent(blockchain, blockchain.getChainHeadBlock());\n+    simulateAddingBlockOnCanonicalChain(testBlock);\n+    final BlockResult expectedNewBlock =\n+        blockResultFactory.transactionHash(\n+            blockchainQueriesSpy.blockByHashWithTxHashes(testBlock.getHash()).orElse(null));\n \n     verify(subscriptionManager)\n         .sendMessage(subscriptionIdCaptor.capture(), responseCaptor.capture());\n     assertThat(subscriptionIdCaptor.getValue()).isEqualTo(subscription.getSubscriptionId());\n-    assertThat(responseCaptor.getValue())\n-        .isEqualToComparingFieldByFieldRecursively(expectedNewBlock);\n+    assertThat(responseCaptor.getValue()).usingRecursiveComparison().isEqualTo(expectedNewBlock);\n   }\n \n   @Test\n   public void shouldNotSendMessageWhenBlockAddedIsNotOnCanonicalChain() {\n     simulateAddingBlockOnNonCanonicalChain();\n \n-    verifyZeroInteractions(subscriptionManager);\n+    verifyNoInteractions(subscriptionManager);\n+  }\n+\n+  @Test\n+  public void shouldSendMessagesWhenReorgBlockAdded() {\n+    final NewBlockHeadersSubscription subscription = createSubscription(false);\n+    mockSubscriptionManagerNotifyMethod(subscription);\n+\n+    appendBlockWithParent(blockchain, genesisBlock);\n+    final Block forkBlock = appendBlockWithParent(blockchain, genesisBlock);\n+    final Block forkBlock1 = appendBlockWithParent(blockchain, forkBlock);\n+    final Block forkBlock2 = appendBlockWithParent(blockchain, forkBlock1);\n+    simulateAddingReorgBlock(forkBlock2, genesisBlock);\n+    final BlockResult expectedNewBlock =\n+        blockResultFactory.transactionHash(\n+            blockchainQueriesSpy.blockByHashWithTxHashes(forkBlock2.getHash()).orElse(null));\n+\n+    verify(subscriptionManager, times(3)).notifySubscribersOnWorkerThread(any(), any(), any());\n+    verify(subscriptionManager, times(3))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk0MzkzMQ=="}, "originalCommit": {"oid": "8bfd94a85da02d10db166cda0ce169bc3ed78c05"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MjY1MDg0OnYy", "diffSide": "RIGHT", "path": "ethereum/api/src/test/java/org/hyperledger/besu/ethereum/api/jsonrpc/websocket/subscription/blockheaders/NewBlockHeadersSubscriptionServiceTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMDoyMjowNVrOFu62VQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMDoyMjowNVrOFu62VQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc0Mjk5Nw==", "bodyText": "Now that we use block data generator, can we get rid of all the old fixtures and use the generator instead?", "url": "https://github.com/hyperledger/besu/pull/403#discussion_r384742997", "createdAt": "2020-02-26T20:22:05Z", "author": {"login": "RatanRSur"}, "path": "ethereum/api/src/test/java/org/hyperledger/besu/ethereum/api/jsonrpc/websocket/subscription/blockheaders/NewBlockHeadersSubscriptionServiceTest.java", "diffHunk": "@@ -194,21 +244,31 @@ private void mockSubscriptionManagerNotifyMethod(\n         .notifySubscribersOnWorkerThread(any(), any(), any());\n   }\n \n-  private void simulateAddingBlockOnCanonicalChain() {\n-    final BlockBody blockBody = new BlockBody(Collections.emptyList(), Collections.emptyList());\n-    final Block testBlock = new Block(blockHeader, blockBody);\n+  private void simulateAddingBlockOnCanonicalChain(final Block block) {\n     newBlockHeadersSubscriptionService.onBlockAdded(\n-        BlockAddedEvent.createForHeadAdvancement(testBlock, Collections.emptyList()),\n-        blockchainQueries.getBlockchain());\n-    verify(blockchainQueries, times(1)).getBlockchain();\n+        BlockAddedEvent.createForHeadAdvancement(block, Collections.emptyList()),\n+        blockchainQueriesSpy.getBlockchain());\n+    verify(blockchainQueriesSpy, times(1)).getBlockchain();\n   }\n \n   private void simulateAddingBlockOnNonCanonicalChain() {\n     final BlockBody blockBody = new BlockBody(Collections.emptyList(), Collections.emptyList());\n     final Block testBlock = new Block(blockHeader, blockBody);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc4e4b049a9f047396e3086d7a39291c3f35d0ac"}, "originalPosition": 275}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NTM4MDcwOnYy", "diffSide": "RIGHT", "path": "ethereum/api/src/test/java/org/hyperledger/besu/ethereum/api/jsonrpc/websocket/subscription/blockheaders/NewBlockHeadersSubscriptionServiceTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNDozNDo1OVrOFvUntQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNDozNDo1OVrOFvUntQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE2NTIzNw==", "bodyText": "Now the simulate method forces the call of onBlockAdded but since you have the blockchain, these should automatically be called when you subscribe to NewHeaders.\nBasically, the tests could look like:\n\nCreate blockchain\nSubscribe to BlockHeaders\nAdd blocks\nCheck what queries were made\n\nAll without ever calling onBlockAdded manually.", "url": "https://github.com/hyperledger/besu/pull/403#discussion_r385165237", "createdAt": "2020-02-27T14:34:59Z", "author": {"login": "RatanRSur"}, "path": "ethereum/api/src/test/java/org/hyperledger/besu/ethereum/api/jsonrpc/websocket/subscription/blockheaders/NewBlockHeadersSubscriptionServiceTest.java", "diffHunk": "@@ -251,11 +232,9 @@ private void simulateAddingBlockOnCanonicalChain(final Block block) {\n     verify(blockchainQueriesSpy, times(1)).getBlockchain();\n   }\n \n-  private void simulateAddingBlockOnNonCanonicalChain() {\n-    final BlockBody blockBody = new BlockBody(Collections.emptyList(), Collections.emptyList());\n-    final Block testBlock = new Block(blockHeader, blockBody);\n+  private void simulateAddingBlockOnNonCanonicalChain(final Block block) {\n     newBlockHeadersSubscriptionService.onBlockAdded(\n-        BlockAddedEvent.createForFork(testBlock), blockchainQueriesSpy.getBlockchain());\n+        BlockAddedEvent.createForFork(block), blockchainQueriesSpy.getBlockchain());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fce6d316dee59fffd2e4b4acd108956c8dc90b6"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NTM4MTU4OnYy", "diffSide": "RIGHT", "path": "ethereum/api/src/test/java/org/hyperledger/besu/ethereum/api/jsonrpc/websocket/subscription/blockheaders/NewBlockHeadersSubscriptionServiceTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNDozNToxNFrOFvUoUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNDozNToxNFrOFvUoUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE2NTM5NA==", "bodyText": "Now the simulate method forces the call of onBlockAdded but since you have the blockchain, these should automatically be called when you subscribe to NewHeaders.\nBasically, the tests could look like:\n\nCreate blockchain\nSubscribe to BlockHeaders\nAdd blocks\nCheck what queries were made\n\nAll without ever calling onBlockAdded manually.", "url": "https://github.com/hyperledger/besu/pull/403#discussion_r385165394", "createdAt": "2020-02-27T14:35:14Z", "author": {"login": "RatanRSur"}, "path": "ethereum/api/src/test/java/org/hyperledger/besu/ethereum/api/jsonrpc/websocket/subscription/blockheaders/NewBlockHeadersSubscriptionServiceTest.java", "diffHunk": "@@ -251,11 +232,9 @@ private void simulateAddingBlockOnCanonicalChain(final Block block) {\n     verify(blockchainQueriesSpy, times(1)).getBlockchain();\n   }\n \n-  private void simulateAddingBlockOnNonCanonicalChain() {\n-    final BlockBody blockBody = new BlockBody(Collections.emptyList(), Collections.emptyList());\n-    final Block testBlock = new Block(blockHeader, blockBody);\n+  private void simulateAddingBlockOnNonCanonicalChain(final Block block) {\n     newBlockHeadersSubscriptionService.onBlockAdded(\n-        BlockAddedEvent.createForFork(testBlock), blockchainQueriesSpy.getBlockchain());\n+        BlockAddedEvent.createForFork(block), blockchainQueriesSpy.getBlockchain());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fce6d316dee59fffd2e4b4acd108956c8dc90b6"}, "originalPosition": 107}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1099, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}